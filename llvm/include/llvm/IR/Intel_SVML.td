//===------ Intel_SVML.td - Defines all SVML variants -*- tablegen -*------===//
//
// Copyright (C) 2016 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
// ===--------------------------------------------------------------------=== //
///
/// \file
/// This file defines the classes used to represent the set of SVML variants.
/// The TableGen classes defined here provide enough flexibility to define
/// variants of single/double precision or both and whether or not a masked
/// variant is available.
///
/// Note: vector length is not encoded here because the loop vectorizer can
/// emit an svml call of any logical vector length. Therefore, vector lengths
/// of 2 .. 64 are automatically generated by the TableGen backend that
/// processes this file (llvm/utils/TableGen/Intel_SVMLEmitter.cpp). We rely
/// on legalization to rewrite the logical svml calls into target legal ones.
///
// ===--------------------------------------------------------------------=== //

class Type<bits<2> type> {
  bits<2> Type = type;
}

def FPSingle : Type<1>;
def FPDouble : Type<2>;
def FPBoth   : Type<3>;

class Variant<bit masked> {
  bit isMasked = masked;
}

def Masked    : Variant<1>;
def NonMasked : Variant<0>;

class IntrinFormat<bit intrin> {
  bit hasIntrinsic = intrin;
}

// The incoming LLVM IR may be in the form of an intrinsic instead of
// a math library call. If so, allow TableGen to generate the intrinsic
// to SVML function mapping.
def NoIntrin : IntrinFormat<0>;
def Intrin   : IntrinFormat<1>;

// Extra attributes (represented via bits) for every SVML table entry. Default is NoAttrs.
class ExtraAttrs<bits<3> attrs> {
  bits<3> extraAttrs = attrs;
}

def NoAttrs       : ExtraAttrs<0>;
def IsOCLFn       : ExtraAttrs<1>;
def IsComplexFn   : ExtraAttrs<2>;
def IsFortranOnly : ExtraAttrs<4>;

class VariantType<Type Ty, Variant V, IntrinFormat IF, ExtraAttrs Attrs = NoAttrs> {
  bit isMasked  = V.isMasked;
  bit hasSingle = Ty.Type{0};
  bit hasDouble = Ty.Type{1};
  bit hasIntrinsic = IF.hasIntrinsic;
  bits<3> extraAttrs = Attrs.extraAttrs;
}

class SvmlVariants<list<VariantType> Variants> {
  list<VariantType> VList = Variants;
}

def FPSingleMasked          : VariantType<FPSingle, Masked,    NoIntrin>;
def FPSingleNonMasked       : VariantType<FPSingle, NonMasked, NoIntrin>;
def FPDoubleMasked          : VariantType<FPDouble, Masked,    NoIntrin>;
def FPDoubleNonMasked       : VariantType<FPDouble, NonMasked, NoIntrin>;
def FPBothMasked            : VariantType<FPBoth,   Masked,    NoIntrin>;
def FPBothNonMasked         : VariantType<FPBoth,   NonMasked, NoIntrin>;
def FPBothMaskedComplex     : VariantType<FPBoth,   Masked, NoIntrin, IsComplexFn>;

def FPSingleMaskedIntrin    : VariantType<FPSingle, Masked,    Intrin>;
def FPSingleNonMaskedIntrin : VariantType<FPSingle, NonMasked, Intrin>;
def FPDoubleMaskedIntrin    : VariantType<FPDouble, Masked,    Intrin>;
def FPDoubleNonMaskedIntrin : VariantType<FPDouble, NonMasked, Intrin>;
def FPBothMaskedIntrin      : VariantType<FPBoth,   Masked,    Intrin>;
def FPBothNonMaskedIntrin   : VariantType<FPBoth,   NonMasked, Intrin>;

def sin        : SvmlVariants<[FPBothMaskedIntrin]>;
def sinpi      : SvmlVariants<[FPBothMasked]>;
def cos        : SvmlVariants<[FPBothMaskedIntrin]>;
def cospi      : SvmlVariants<[FPBothMasked]>;
def pow        : SvmlVariants<[FPBothMaskedIntrin]>;
def exp        : SvmlVariants<[FPBothMaskedIntrin]>;
def log        : SvmlVariants<[FPBothMaskedIntrin]>;
def sincos     : SvmlVariants<[FPBothMasked]>;
def acos       : SvmlVariants<[FPBothMasked]>;
def acosh      : SvmlVariants<[FPBothMasked]>;
def acospi     : SvmlVariants<[FPBothMasked]>;
def asin       : SvmlVariants<[FPBothMasked]>;
def asinh      : SvmlVariants<[FPBothMasked]>;
def asinpi     : SvmlVariants<[FPBothMasked]>;
def atan2      : SvmlVariants<[FPBothMasked]>;
def atan2pi    : SvmlVariants<[FPBothMasked]>;
def atan       : SvmlVariants<[FPBothMasked]>;
def atanh      : SvmlVariants<[FPBothMasked]>;
def atanpi     : SvmlVariants<[FPBothMasked]>;
def cbrt       : SvmlVariants<[FPBothMasked]>;
def cdfnorm    : SvmlVariants<[FPBothMasked]>;
def cdfnorminv : SvmlVariants<[FPBothMasked]>;
def ceil       : SvmlVariants<[FPBothMasked]>;
def cexp       : SvmlVariants<[FPBothMaskedComplex]>;
def clog       : SvmlVariants<[FPBothMaskedComplex]>;
def cosd       : SvmlVariants<[FPBothMasked]>;
def cosh       : SvmlVariants<[FPBothMasked]>;
def erf        : SvmlVariants<[FPBothMasked]>;
def erfc       : SvmlVariants<[FPBothMasked]>;
def erfcinv    : SvmlVariants<[FPBothMasked]>;
def erfinv     : SvmlVariants<[FPBothMasked]>;
def exp10      : SvmlVariants<[FPBothMasked]>;
def exp2       : SvmlVariants<[FPBothMaskedIntrin]>;
def expm1      : SvmlVariants<[FPBothMasked]>;
def fdim       : SvmlVariants<[FPBothMasked]>;
def floor      : SvmlVariants<[FPBothMasked]>;
def fmod       : SvmlVariants<[FPBothMasked]>;
def hypot      : SvmlVariants<[FPBothMasked]>;
def invsqrt    : SvmlVariants<[FPBothMasked]>;
// Due to the unique signature of ldexp function, llvm.ldexp intrinsic is
// handled inside the emitter.
def ldexp      : SvmlVariants<[FPBothMasked]>;
def log10      : SvmlVariants<[FPBothMaskedIntrin]>;
def log1p      : SvmlVariants<[FPBothMasked]>;
def log2       : SvmlVariants<[FPBothMaskedIntrin]>;
def logb       : SvmlVariants<[FPBothMasked]>;
def maxmag     : SvmlVariants<[FPBothMasked]>;
def minmag     : SvmlVariants<[FPBothMasked]>;
def nearbyint  : SvmlVariants<[FPBothMasked]>;
def nextafter  : SvmlVariants<[FPBothMasked]>;
def pow2o3     : SvmlVariants<[FPBothMasked]>;
def pow3o2     : SvmlVariants<[FPBothMasked]>;
def powr       : SvmlVariants<[FPBothMasked]>;
def remainder  : SvmlVariants<[FPBothMasked]>;
def rint       : SvmlVariants<[FPBothMasked]>;
def round      : SvmlVariants<[FPBothMasked]>;
def sind       : SvmlVariants<[FPBothMasked]>;
def sinh       : SvmlVariants<[FPBothMasked]>;
def sqrt       : SvmlVariants<[FPBothMasked]>;
def tan        : SvmlVariants<[FPBothMasked]>;
def tand       : SvmlVariants<[FPBothMasked]>;
def tanh       : SvmlVariants<[FPBothMasked]>;
def tanpi      : SvmlVariants<[FPBothMasked]>;
def trunc      : SvmlVariants<[FPBothMasked]>;
