//===------ Intel_SVML.td - Defines all SVML variants -*- tablegen -*------===//
//
// Copyright (C) 2016 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
// ===--------------------------------------------------------------------=== //
///
/// \file
/// This file defines the classes used to represent the set of SVML variants.
/// The TableGen classes defined here provide enough flexibility to define
/// variants of single/double precision or both and whether or not a masked
/// variant is available.
///
/// Note: vector length is not encoded here because the loop vectorizer can
/// emit an svml call of any logical vector length. Therefore, vector lengths
/// of 2 .. 64 are automatically generated by the TableGen backend that
/// processes this file (llvm/utils/TableGen/Intel_SVMLEmitter.cpp). We rely
/// on legalization to rewrite the logical svml calls into target legal ones.
///
// ===--------------------------------------------------------------------=== //

class Type<bits<2> type> {
  bits<2> Type = type;
}

def FPSingle : Type<1>;
def FPDouble : Type<2>;
def FPBoth   : Type<3>;

class Variant<bit masked> {
  bit isMasked = masked;
}

def Masked    : Variant<1>;
def NonMasked : Variant<0>;

class IntrinFormat<bit intrin> {
  bit hasIntrinsic = intrin;
}

// The incoming LLVM IR may be in the form of an intrinsic instead of
// a math library call. If so, allow TableGen to generate the intrinsic
// to SVML function mapping.
def NoIntrin : IntrinFormat<0>;
def Intrin   : IntrinFormat<1>;

// Extra attributes (represented via bits) for every SVML table entry. Default is NoAttrs.
class ExtraAttrs<bits<3> attrs> {
  bits<3> extraAttrs = attrs;
}

def NoAttrs       : ExtraAttrs<0>;
def IsOCLFn       : ExtraAttrs<1>;
def IsComplexFn   : ExtraAttrs<2>;
def IsFortranOnly : ExtraAttrs<4>;

class VariantType<Type Ty, Variant V, IntrinFormat IF, ExtraAttrs Attrs = NoAttrs> {
  bit isMasked  = V.isMasked;
  bit hasSingle = Ty.Type{0};
  bit hasDouble = Ty.Type{1};
  bit hasIntrinsic = IF.hasIntrinsic;
  bits<3> extraAttrs = Attrs.extraAttrs;
}

class SvmlVariants<list<VariantType> Variants, int NArgs> {
  list<VariantType> VList = Variants;
  int NumArgs = NArgs;
}

def FPSingleMasked          : VariantType<FPSingle, Masked,    NoIntrin>;
def FPSingleNonMasked       : VariantType<FPSingle, NonMasked, NoIntrin>;
def FPDoubleMasked          : VariantType<FPDouble, Masked,    NoIntrin>;
def FPDoubleNonMasked       : VariantType<FPDouble, NonMasked, NoIntrin>;
def FPBothMasked            : VariantType<FPBoth,   Masked,    NoIntrin>;
def FPBothNonMasked         : VariantType<FPBoth,   NonMasked, NoIntrin>;
def FPBothMaskedComplex     : VariantType<FPBoth,   Masked,    NoIntrin,  IsComplexFn>;

def FPSingleMaskedIntrin    : VariantType<FPSingle, Masked,    Intrin>;
def FPSingleNonMaskedIntrin : VariantType<FPSingle, NonMasked, Intrin>;
def FPDoubleMaskedIntrin    : VariantType<FPDouble, Masked,    Intrin>;
def FPDoubleNonMaskedIntrin : VariantType<FPDouble, NonMasked, Intrin>;
def FPBothMaskedIntrin      : VariantType<FPBoth,   Masked,    Intrin>;
def FPBothNonMaskedIntrin   : VariantType<FPBoth,   NonMasked, Intrin>;

def sin        : SvmlVariants<[FPBothMaskedIntrin], 1>;
def sinpi      : SvmlVariants<[FPBothMasked], 1>;
def cos        : SvmlVariants<[FPBothMaskedIntrin], 1>;
def cospi      : SvmlVariants<[FPBothMasked], 1>;
def pow        : SvmlVariants<[FPBothMaskedIntrin], 2>;
def exp        : SvmlVariants<[FPBothMaskedIntrin], 1>;
def log        : SvmlVariants<[FPBothMaskedIntrin], 1>;
def sincos     : SvmlVariants<[FPBothMasked], 1>;
def acos       : SvmlVariants<[FPBothMasked], 1>;
def acosh      : SvmlVariants<[FPBothMasked], 1>;
def acospi     : SvmlVariants<[FPBothMasked], 1>;
def asin       : SvmlVariants<[FPBothMasked], 1>;
def asinh      : SvmlVariants<[FPBothMasked], 1>;
def asinpi     : SvmlVariants<[FPBothMasked], 1>;
def atan2      : SvmlVariants<[FPBothMasked], 1>;
def atan2pi    : SvmlVariants<[FPBothMasked], 2>;
def atan       : SvmlVariants<[FPBothMasked], 1>;
def atanh      : SvmlVariants<[FPBothMasked], 1>;
def atanpi     : SvmlVariants<[FPBothMasked], 1>;
def cbrt       : SvmlVariants<[FPBothMasked], 1>;
def cdfnorm    : SvmlVariants<[FPBothMasked], 1>;
def cdfnorminv : SvmlVariants<[FPBothMasked], 1>;
def ceil       : SvmlVariants<[FPBothMasked], 1>;
def cexp       : SvmlVariants<[FPBothMaskedComplex], 1>;
def clog       : SvmlVariants<[FPBothMaskedComplex], 1>;
def cosd       : SvmlVariants<[FPBothMasked], 1>;
def cosh       : SvmlVariants<[FPBothMasked], 1>;
def erf        : SvmlVariants<[FPBothMasked], 1>;
def erfc       : SvmlVariants<[FPBothMasked], 1>;
def erfcinv    : SvmlVariants<[FPBothMasked], 1>;
def erfinv     : SvmlVariants<[FPBothMasked], 1>;
def exp10      : SvmlVariants<[FPBothMasked], 1>;
def exp2       : SvmlVariants<[FPBothMaskedIntrin], 1>;
def expm1      : SvmlVariants<[FPBothMasked], 1>;
def fdim       : SvmlVariants<[FPBothMasked], 2>;
def floor      : SvmlVariants<[FPBothMasked], 1>;
def fmod       : SvmlVariants<[FPBothMasked], 1>;
def hypot      : SvmlVariants<[FPBothMasked], 1>;
def invsqrt    : SvmlVariants<[FPBothMasked], 1>;
// Due to the unique signature of ldexp function, llvm.ldexp intrinsic is
// handled inside the emitter.
def ldexp      : SvmlVariants<[FPBothMasked], 2>;
def log10      : SvmlVariants<[FPBothMaskedIntrin], 1>;
def log1p      : SvmlVariants<[FPBothMasked], 1>;
def log2       : SvmlVariants<[FPBothMaskedIntrin], 1>;
def logb       : SvmlVariants<[FPBothMasked], 1>;
def maxmag     : SvmlVariants<[FPBothMasked], 2>;
def minmag     : SvmlVariants<[FPBothMasked], 2>;
def nearbyint  : SvmlVariants<[FPBothMasked], 1>;
def nextafter  : SvmlVariants<[FPBothMasked], 2>;
def pow2o3     : SvmlVariants<[FPBothMasked], 1>;
def pow3o2     : SvmlVariants<[FPBothMasked], 1>;
def powr       : SvmlVariants<[FPBothMasked], 2>;
def remainder  : SvmlVariants<[FPBothMasked], 2>;
def rint       : SvmlVariants<[FPBothMasked], 1>;
def round      : SvmlVariants<[FPBothMasked], 1>;
def sind       : SvmlVariants<[FPBothMasked], 1>;
def sinh       : SvmlVariants<[FPBothMasked], 1>;
def sqrt       : SvmlVariants<[FPBothMasked], 1>;
def tan        : SvmlVariants<[FPBothMasked], 1>;
def tand       : SvmlVariants<[FPBothMasked], 1>;
def tanh       : SvmlVariants<[FPBothMasked], 1>;
def tanpi      : SvmlVariants<[FPBothMasked], 1>;
def trunc      : SvmlVariants<[FPBothMasked], 1>;
