//=-- VPOParoptUtils.h - Class definition for VPO Paropt utilites -*- C++ -*-=//
//
// Copyright (C) 2015-2016 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
// Authors:
// --------
// Xinmin Tian (xinmin.tian@intel.com)
//
// Major Revisions:
// ----------------
// Nov 2015: Initial Implementation of OpenMP runtime APIs (Xinmin Tian)
//
//===----------------------------------------------------------------------===//
///
/// \file
/// This file defines the VPOParoptUtils class and provides a set of utilities
/// that are used for Paropt transformation and multi-threaded code generation.
///
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORM_VPO_PAROPT_UTILS_H
#define LLVM_TRANSFORM_VPO_PAROPT_UTILS_H

#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Debug.h"
#include "llvm/Transforms/Utils/ValueMapper.h"
#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/Analysis/Intel_VPO/WRegionInfo/WRegionUtils.h"
#include <unordered_map>

// Use trampoline for internal microtasks
#define KMP_IDENT_IMB              0x01

// Use c-style ident structure
#define KMP_IDENT_KMPC             0x02

// Entry point generated using Cluster OpenMP switch
#define KMP_IDENT_CLOMP            0x04

// Entry point generated by auto-parallelization
#define KMP_IDENT_AUTOPAR          0x08

// compiler generates atomic reduction option for kmpc_reduce
#define KMP_IDENT_ATOMIC_REDUCE    0x10

// replaced by KMP_IDENT_BARRIER_EXPL below
// #define KMP_IDENT_EXPLICIT_BARRIER 0x20

//
// Implicit barriers are classified further
//
// = 0000 0010 0000 barrier directive in user's code
#define KMP_IDENT_BARRIER_EXPL           0x0020

// = 0000 0100 0000
#define KMP_IDENT_BARRIER_IMPL           0x0040

// = 0001 1100 0000 unused by cmplr
#define KMP_IDENT_BARRIER_IMPL_MASK      0x01C0

// = 0000 0100 0000
#define KMP_IDENT_BARRIER_IMPL_FOR       0x0040

// = 0000 1100 0000
#define KMP_IDENT_BARRIER_IMPL_SECTIONS  0x00C0

// = 0001 0100 0000
#define KMP_IDENT_BARRIER_IMPL_SINGLE    0x0140

// = 0001 1100 0000 workshare construct not supported by cmplr
#define KMP_IDENT_BARRIER_IMPL_WORKSHARE 0x01C0

namespace llvm {

class Value;
class Module;
class Function;
class Type;
class BasicBlock;
class Loop;
class LoopInfo;
class DominatorTree;
class StringRef;
class CallInst;
class IntrinsicInst;
class Constant;
class LLVMContext;
class BasicBlock;

namespace vpo {

/// \brief This class contains a set of utility functions used by VPO Paropt 
/// Transformation passes.
class VPOParoptUtils {

public:

    /// \brief Generate OpenMP runtime __kmpc_begin(&loc, flags) 
    /// initialization code. The generated runtime routine call is invoked 
    /// (only once) right after entering the main function.
    static CallInst* genKmpcBeginCall(Function *F, Instruction *InsertPt, 
                                      StructType *IdentTy);

    /// \brief Generate OpenMP runtime __kmpc_end(&loc) termination code 
    /// The generated runtime routine call is invoked (only once) right 
    /// before exiting the main function.
    static CallInst* genKmpcEndCall(Function *F, 
                                    Instruction *InsertPt, 
                                    StructType *IdentTy);

    /// \brief Check whether the call __kmpc_global_thread_num() exists
    /// in the given basic block BB.
    static CallInst* findKmpcGlobalThreadNumCall(BasicBlock *BB);

    /// \brief Check whether the given instruction is the call
    /// __kmpc_global_thread_num().
    static bool isKmpcGlobalThreadNumCall(Value *V);
   
    /// \brief Generate OpenMP runtime __kmpc_global_thread_num() call 
    /// The generated runtime routine call is invoked (only once) to get 
    /// runtime right 
    /// after entering each function that contains OpenMP constructs 
    static CallInst* genKmpcGlobalThreadNumCall(Function    *F, 
                                                Instruction *InsertPt, 
                                                StructType  *IdentTy);

    /// \brief Generates OpenMP runtime __kmpc_threadprivate_cached call.
    static CallInst* genKmpcThreadPrivateCachedCall(Function *F,
                                                    Instruction *AI,
                                                    StructType *IdentTy,
                                                    Value *Tid,
                                                    Value *GV,
                                                    Value *GVSize,
                                                    Value *TpvGV);
      
    /// \brief Generate OpenMP runtime ForkTest = ___kmpc_ok_to_fork(&loc) 
    static CallInst* genKmpcForkTest(WRegionNode *W, StructType *IdentTy, 
                                     Instruction *InsertPt);

    /// \brief Generate source location information from Instruction DebugLoc
    static GlobalVariable *genKmpcLocfromDebugLoc(Function *F, Instruction *AI,
                                                  StructType *IdentTy,
                                                  int Flags, BasicBlock *BS,
                                                  BasicBlock *BE);

    
    /// \brief This function generates a call to set num_threads for the 
    /// parallel region and parallel loop/sections
    ///
    /// call void @__kmpc_push_num_threads(%ident_t* %loc, i32 %tid, i32 %nths)
    static void genKmpcPushNumThreads(WRegionNode *W,
                                      StructType *IdentTy,
                                      Value *Tid, Value *NumThreads,
                                      Instruction *InsertPt);

    /// \brief Generate a call to notify the runtime system that the static 
    /// loop scheduling is started 
    /// call void @__kmpc_for_static_init_4(%ident_t* %loc, i32 %tid,
    ///             i32 schedtype, i32* %islast,i32* %lb, i32* %ub, i32* %st,
    ///             i32 inc, i32 chunk)
    static CallInst* genKmpcStaticInit(WRegionNode *W,
                                       StructType *IdentTy,
                                       Value *Tid, Value *SchedType, 
                                       Value *IsLastVal, Value *LB, Value *UB, 
                                       Value *ST, Value *Inc, Value *Chunk,
                                       int Size, bool IsUnsigned,
                                       Instruction *InsertPt);

    /// \brief Generate a call to notify the runtime system that the static 
    /// loop scheduling is done 
    ///   call void @__kmpc_for_static_fini(%ident_t* %loc, i32 %tid)
    static CallInst* genKmpcStaticFini(WRegionNode *W,
                                       StructType *IdentTy,
                                       Value *Tid, Instruction *InsertPt);

    /// \brief Generate a call to pass all loop info to the runtime system 
    /// for guided/runtime/dynamic/auto loop scheduling
    ///
    ///   call void @__kmpc_for_dispatch_init_4{u}(%ident_t* %loc, i32 %tid,
    ///               i32 schedtype, i32 %lb, i32 %ub, i32 %st, i32 chunk)
    ///
    ///   call void @__kmpc_for_dispatch_init_8{u}4(%ident_t* %loc, i32 %tid,
    ///               i32 schedtype, i64 %lb, i64 %ub, i64 %st, i64 chunk)
    static CallInst* genKmpcDispatchInit(WRegionNode *W,
                                         StructType *IdentTy,
                                         Value *Tid, Value *SchedType,
                                         Value *LB, Value *UB,
                                         Value *ST, Value *Chunk,
                                         int Size, bool IsUnsigned,
                                         Instruction *InsertPt);

    /// \brief Generate a call to the runtime system that performs
    /// loop partitioning for guided/runtime/dynamic/auto scheduling.
    ///
    ///   call void @__kmpc_for_dispatch_next_4{u}(%ident_t* %loc, i32 %tid,
    ///               i32 *isLast, i32 *%lb, i32 *%ub, i32 *%st)
    ///
    ///   call void @__kmpc_for_dispatch_next_8{u}(%ident_t* %loc, i32 %tid,
    ///               i32 *isLast, i64 *%lb, i64 *%ub, i64 *%st)
    static CallInst* genKmpcDispatchNext(WRegionNode *W,
                                         StructType *IdentTy,
                                         Value *Tid, Value *IsLastVal, 
                                         Value *LB, Value *UB, Value *ST,
                                         int Size, bool IsUnsigned,
                                         Instruction *InsertPt);

    /// \brief Generate a call to the runtime system that informs 
    /// guided/runtime/dynamic/auto scheduling is done.
    ///
    ///   call void @__kmpc_for_dispatch_fini_4{u}(%ident_t* %loc, i32 %tid)
    ///   call void @__kmpc_for_dispatch_fini_8{u}(%ident_t* %loc, i32 %tid)
    static CallInst* genKmpcDispatchFini(WRegionNode *W,
                                         StructType *IdentTy,
                                         Value *Tid, int Size, bool IsUnsigned, 
                                         Instruction *InsertPt);

    /// \Brief Update loop scheduling kind based on ordered clause and chunk 
    /// size information
    static WRNScheduleKind genScheduleKind(WRNScheduleKind Kind, 
                                           int IsOrdered, int Chunk);

    /// \Brief Query loop scheduling kind based on ordered clause and chunk 
    /// size information
    static WRNScheduleKind getLoopScheduleKind(WRegionNode *W);

    static WRNScheduleKind genLoopScheduleKind(WRegionNode *W);
    /// \brief Generate source location information for Explicit barrier
    static GlobalVariable* genKmpcLocforExplicitBarrier(Function *F,
                                                        Instruction *InsertPt,
                                                        StructType *IdentTy,
                                                        BasicBlock *BB);

    /// \brief Generate source location information for Implicit barrier
    static GlobalVariable* genKmpcLocforImplicitBarrier(WRegionNode *W,
                                                        Function *F,
                                                        Instruction *InsertPt,
                                                        StructType *IdentTy,
                                                        BasicBlock *BB);

    /// \brief Generates a critical section surrounding all the inner
    /// BasicBlocks of the WRegionNode \p W. The function works only on
    /// directives which have an Entry BasicBlock with "DIR.OMP..." intrinsic
    /// calls, and an exit BasicBlock with a corresponding "DIR.OMP.END..."
    /// calls. The middle BasicBlocks will then be surrounded by a critical
    /// section. The function emits calls to `__kmpc_critical` and
    /// `__kmpc_end_critical` in positions marked in the following diagram:
    ///
    ///    EntryBB:
    ///      call void @llvm.intel.directive(metadata !"DIR.OMP...")
    ///      call void @llvm.intel.directive(metadata !"DIR.QUAL.LIST.END")
    /// +------< begin critical >
    /// |    br label %BB1
    /// |
    /// |  BB1:
    /// |    ...
    /// |  ...
    /// |    br label %ExitBB
    /// |
    /// |  ExitBB:
    /// |    call void @llvm.intel.directive(metadata !"DIR.OMP.END...")
    /// |    call void @llvm.intel.directive(metadata !"DIR.QUAL.LIST.END")
    /// +------< end critical >
    ///      br label %..
    ///
    /// \p IdentTy is needed to obtain the Loc struct for the KMPC calls.
    /// \p TidPtr is the AllocaInst for ThreadId, needed for the KMPC calls.
    /// \p LockNameSuffix will be used as suffix in the name of the lock
    /// variable used for the critical section. (The prefix is determined based
    /// on the architecture and the kind of WRegionNode \W).
    ///
    /// Example KMPC calls:
    /// call void @__kmpc_begin_critical(%ident_t* %loc.addr.11.12, i32 %my.tid,
    /// [8 x i32]* @_kmpc_atomic_lock)
    ///
    /// call void @__kmpc_end_critical(%ident_t* %loc.addr.11.122, i32 %my.tid1,
    /// [8 x i32]* @_kmpc_atomic_lock)
    ///
    /// \returns `true` if the calls to `__kmpc_critical` and
    /// `__kmpc_end_critical` are successfully inserted, `false` otherwise.
    static bool genKmpcCriticalSection(WRegionNode *W, StructType *IdentTy,
                                       AllocaInst *TidPtr,
                                       const StringRef &LockNameSuffix);

    /// \brief Identical to the function above, but uses a default suffix for
    /// the name of the lock variable to be used for the critical section.
    /// \see genKmpcCriticalSection(WRegionNode*, StructType*, AllocaInst*,
    /// const StringRef &) for more details.
    ///
    /// \returns `true` if the calls to `__kmpc_critical` and
    /// `__kmpc_end_critical` are successfully inserted, `false` otherwise.
    static bool genKmpcCriticalSection(WRegionNode *W, StructType *IdentTy,
                                       AllocaInst *TidPtr);

    /// \brief Generates a critical section around Instructions \p BeginInst
    /// and \p EndInst. The function emits calls to `__kmpc_critical`
    /// before \p BeginInst and `__kmpc_end_critical` after \p EndInst.
    ///
    /// +------< begin critical >
    /// |    BeginInst
    /// |    ...
    /// |    ...
    /// |    EndInst
    /// +------< end critical >
    ///
    /// \p BeginInst is the Instruction before which the call to
    /// `__kmpc_critical` is inserted.
    /// \p EndInst is the Instruction after which the call to
    /// `__kmpc_end_critical` is inserted.
    ///
    /// Note: Other Instructions, aside from the `__kmpc_critical` and
    /// `__kmpc_end_critical` calls, which are needed for the KMPC calls,
    /// are also inserted into the IR. \see genKmpcCallWithTid() for details.
    ///
    /// \see genKmpcCriticalSection(WRegionNode*, StructType*, AllocaInst*,
    /// const StringRef &) for examples of the KMPC critical calls.
    ///
    /// \returns `true` if the calls to `__kmpc_critical` and
    /// `__kmpc_end_critical` are successfully inserted, `false` otherwise.
    static bool genKmpcCriticalSection(WRegionNode *W, StructType *IdentTy,
                                       AllocaInst *TidPtr,
                                       Instruction *BeginInst,
                                       Instruction *EndInst,
                                       const StringRef &LockNameSuffix);

    /// \brief This function generates a call to query if the current thread
    /// is master thread or a call to end_master for the team of threads.
    ///   call master = @__kmpc_master(%ident_t* %loc, i32 %tid)
    ///      or
    ///   call void @__kmpc_end_master(%ident_t* %loc, i32 %tid)
    static CallInst* genKmpcMasterOrEndMasterCall(WRegionNode *W,
                       StructType *IdentTy, Value *Tid, Instruction *InsertPt,
                       bool IsMasterStart);

    /// \brief This function generates a call to guard single-region is
    /// executed by one of threads in the enclosing thread team.
    ///
    ///   call single = @__kmpc_single(%ident_t* %loc, i32 %tid)
    ///      or
    ///   call void @__kmpc_end_single(%ident_t* %loc, i32 %tid)
    static CallInst* genKmpcSingleOrEndSingleCall(WRegionNode *W,
                       StructType *IdentTy, Value *Tid, Instruction *InsertPt,
                       bool IsSingleStart);

    /// \Brief This function generates calls to guard the ordered thread
    /// execution for the ordered/end ordered region.
    ///
    ///   call void @__kmpc_ordered(%ident_t* %loc, i32 %tid)
    ///      or
    ///   call void @__kmpc_end_ordered(%ident_t* %loc, i32 %tid)
    static CallInst* genKmpcOrderedOrEndOrderedCall(WRegionNode *W,
                       StructType *IdentTy, Value *Tid,
                       Instruction *InsertPt, bool IsOrderedStart);

    /// \brief Generate KMPC runtime call to the function \p IntrinsicName
    /// with arguments Loc(obtained using \p IdentTy), Tid (Obtained using \p
    /// TidPtr), and \p Args.
    /// \param TidPtr is the AllocaInst for Tid.
    /// \param IdentTy and \p InsertPt are used to obtain Loc needed by the
    /// KMPC call.
    /// \param IntrinsicName is the name of the function.
    /// \param ReturnTy is the return type of the function.
    /// \param Args arguments for the function call.
    /// Note: The function inserts a LoadInst for getting Tid, into the IR
    /// (before the \p InsertPt), and inserts the function prototype for the
    /// KMPC intrinsic \p IntrinsicName into the module symbol table. But it
    /// does not insert the KMPC call into the IR.
    ///
    /// \returns The generated CallInst.
    static CallInst *genKmpcCallWithTid(WRegionNode *W, StructType *IdentTy,
                                        AllocaInst *TidPtr,
                                        Instruction *InsertPt,
                                        StringRef IntrinsicName, Type *ReturnTy,
                                        ArrayRef<Value *> Args);

    /// \brief Generate a memcpy call with the destination argument D
    /// and the source argument S at the end of basic block BB.
    ///
    ///     call void @llvm.memcpy.p0i8.p0i8.i32(i8* bitcast (i32* @a to i8*),
    ///                                          i8* %2,
    ///                                          i32 4,
    ///                                          i32 4,
    ///                                          i1 false)
    static CallInst *genMemcpy(Value *D, Value *S, const DataLayout &DL,
                               unsigned Align, BasicBlock *BB);

    /// \brief Computes the OpenMP loop upper bound so that the loop 
    //  iteration space can be closed interval.
    static CmpInst::Predicate computeOmpPredicate(CmpInst::Predicate PD);

    /// \brief Returns the predicate which includes equal for the 
    //  zero trip test.
    static Value* computeOmpUpperBound(WRegionNode *W,
                                       Instruction* InsertPt);

    /// \brief Updates the bottom test predicate to include equal predicate.
    /// It also updates the loop upper bound.
    static void updateOmpPredicateAndUpperBound(WRegionNode *W, 
                                                Value *Load,
                                                Instruction *InsertPt);

    /// \brief Clones the instructions and inserts before the InsertPt.
    static Value *cloneInstructions(Value *V, Instruction *InsertPt);

    /// \brief Generate the pointer pointing to the head of the array.
    static Value *genArrayLength(AllocaInst *AI, Value *BaseAddr,
                                 Instruction *InsertPt, IRBuilder<> &Builder,
                                 Type *&ElementTy, Value *&ArrayBegin);

    /// \brief This function generates a call as follows.
    ///    i8* @__kmpc_omp_task_alloc({ i32, i32, i32, i32, i8* }*, i32, i32,
    ///    i64, i64, i32 (i32, i8*)*)
    static CallInst *
    genKmpcTaskAlloc(WRegionNode *W, StructType *IdentTy, Value *TidPtr,
                     int KmpTaskTTWithPrivatesTySz, int KmpSharedTySz,
                     PointerType *KmpRoutineEntryPtrTy, Function *MicroTaskFn,
                     Instruction *InsertPt, bool UseTbb);

    /// \brief This function generates a call as follows.
    ///    void @__kmpc_taskloop({ i32, i32, i32, i32, i8* }*, i32, i8*, i32,
    ///    i64*, i64*, i64, i32, i32, i64, i8*)
    static CallInst *genKmpcTaskLoop(WRegionNode *W, StructType *IdentTy,
                                     Value *TidPtr, Value *TaskAlloc,
                                     Value *LBVal, Value *UBVal, Value *STVal,
                                     StructType *KmpTaskTTWithPrivatesTy,
                                     Instruction *InsertPt, bool UseTbb);

    /// \brief This function generates a call as follows.
    ///    i8* @__kmpc_task_reduction_get_th_data(i32, i8*, i8*)
    static CallInst *genKmpcRedGetNthData(WRegionNode *W, Value *TidPtr,
                                          Value *SharedGep,
                                          Instruction *InsertPt, bool UseTbb);

    /// \brief This function generates a call as follows.
    ///    i8* @__kmpc_task_reduction_init(i32, i32, i8*)
    static CallInst *genKmpcTaskReductionInit(WRegionNode *W, Value *TidPtr,
                                              int ParmNum, Value *RedRecord,
                                              Instruction *InsertPt,
                                              bool UseTbb);

    /// \brief returns min/max int of the given integer type.
    /// This can be used to initialize min/max reduction variables.
    static ConstantInt* getMinMaxIntVal(LLVMContext &C, Type *Ty,
                                        bool IsUnsigned, bool GetMax);
    // static uint64_t getMinInt(Type *IntTy, bool IsUnsigned);
    // static uint64_t getMaxInt(Type *IntTy, bool IsUnsigned);

  private:
    /// \name Private constructor and destructor to disable instantiation.
    /// @{

    VPOParoptUtils() = delete;
    ~VPOParoptUtils() = delete;

    /// @}

    /// \name Helper methods for generating a KMPC call.
    /// @{

    /// \brief Generates KMPC runtime call to the function \p IntrinsicName
    /// with arguments Loc(obtained using \p IdentTy) and \p Args.
    /// \param IdentTy and \p InsertPt are used to obtain Loc needed by the
    /// KMPC call.
    /// \param IntrinsicName is the name of the function.
    /// \param ReturnTy is the return type of the function.
    /// \param Args arguments for the function call.
    ///
    /// \returns the generated CallInst.
    static CallInst *genKmpcCall(WRegionNode *W, StructType *IdentTy,
                                 Instruction *InsertPt, StringRef IntrinsicName,
                                 Type *ReturnTy, ArrayRef<Value *> Args);

    /// \brief Generates a call to the function \p FnName.
    /// If the function is not already declared in the module \p M, then it is
    /// declared here. Otherwise, the existing declaration is used.
    /// \param M Module for which the call is generated.
    /// \param FnName Name of the function.
    /// \param ReturnTy Return type of the function.
    /// \param FnArgs Arguments for the function call.
    ///
    /// \returns the generated CallInst.
    static CallInst *genCall(Module *M, StringRef FnName, Type *ReturnTy,
                             ArrayRef<Value *> FnArgs);

    /// @}

    /// \name Helper methods for generating a Critical Section.
    /// @{

    /// \brief Creates a prefix for the name of the lock var to be used in KMPC
    /// critical calls based on the kind of WRegionNode \p W.
    ///
    /// \returns A string prefix for the KMPC Lock object for \p W.
    static SmallString<64> getKmpcCriticalLockNamePrefix(WRegionNode *W);\

    /// \brief Returns a GlobalVariable that can be used as the Lock object for
    /// `__kmpc_critical` and __kmpc_end_critical` calls.
    /// \p W is used to determine the name of the Lock object generated.
    /// \p LockNameSuffix will be used as suffix in the name of the lock
    /// variable used for the critical section. (The prefix is determined based
    /// on the architecture and the kind of WRegionNode \W).
    ///
    /// \returns The lock variable for the critical section to be generated.
    static GlobalVariable *
    genKmpcCriticalLockVar(WRegionNode *W, const StringRef &LockNameSuffix);

    /// \brief Handles generation of a critical section around \p BeginInst
    /// and \p EndInst.
    /// The function needs a lock variable \p LockVar, which is generated by
    /// genKmpcCriticalLockVar().
    /// \see genKmpcCriticalSection() functions more details. They are the
    /// public functions which invokes this private helper.
    ///
    /// \returns `true` if the calls to `__kmpc_critical` and
    /// `__kmpc_end_critical` are successfully inserted, `false` otherwise.
    static bool genKmpcCriticalSectionImpl(WRegionNode *W, StructType *IdentTy,
                                           AllocaInst *TidPtr,
                                           Instruction *BeginInst,
                                           Instruction *EndInst,
                                           GlobalVariable *LockVar);


    /// @}

    };

} // End vpo namespace
} // End llvm namespace

#endif // LLVM_TRANSFORMS_VPO_PAROPT_UTILS_H

