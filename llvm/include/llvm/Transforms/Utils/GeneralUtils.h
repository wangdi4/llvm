// INTEL_CUSTOMIZATION // -*- C++ -*-
//
// INTEL CONFIDENTIAL
//
// Modifications, Copyright (C) 2021 Intel Corporation
//
// This software and the related documents are Intel copyrighted materials, and
// your use of them is governed by the express license under which they were
// provided to you ("License"). Unless the License provides otherwise, you may not
// use, modify, copy, publish, distribute, disclose or transmit this software or
// the related documents without Intel's prior written permission.
//
// This software and the related documents are provided as is, with no express
// or implied warranties, other than those that are expressly stated in the
// License.
//
// end INTEL_CUSTOMIZATION
#if INTEL_COLLAB // -*- C++ -*-
//===------------ GeneralUtils.h - Class definition -*- C++ -*-------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
///
/// \file
/// General purpose set of utilities
///
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORM_UTILS_GENERALUTILS_H
#define LLVM_TRANSFORM_UTILS_GENERALUTILS_H

#include "llvm/ADT/SmallVector.h"
#include "llvm/IR/DerivedTypes.h"

namespace llvm {

class Constant;
class Loop;
class LoopInfo;
class BasicBlock;
class Type;
class LLVMContext;
class Instruction;
class DbgDeclareInst;
class DbgValueInst;
class DbgInfoIntrinsic;
class ConstantExpr;
class Value;
class Function;
class DominatorTree;
class Module;

/// \brief This class provides a set of general utility functions that can be
/// used for a variety of purposes.
class GeneralUtils {

public:

  /// \brief Returns a floating point or integer constant depending on Ty.
  template <typename T>
  static Constant* getConstantValue(Type *Ty, LLVMContext &Context, T Val);

  /// \brief Returns Loop in LoopInfo corresponding to the WRN.  The initial
  /// call to this recursive DFS function should pass in the WRN's EntryBB and
  /// ExitBB to prevent searching for the loop header outside of the region.
  static Loop *getLoopFromLoopInfo(LoopInfo *LI, DominatorTree *DT,
                                   BasicBlock *EntryBB, BasicBlock *ExitBB);

  /// \brief Generates BB set in sub CFG for a given WRegionNode.
  /// The entry basic block 'EntryBB' and the exit basic
  /// block 'ExitBB' are the inputs, and 'BBSet' is the output containing all
  /// the basic blocks that belong to this region. It guarantees that the
  /// first item in BBSet is 'EntryBB' and the last item is 'ExitBB'. 'EntryBB'
  /// and 'ExitBB' should not be the same basic block.
  static void collectBBSet(BasicBlock *EntryBB, BasicBlock *ExitBB,
                           SmallVectorImpl<BasicBlock *> &BBSet);
  /// \brief Breaks up the instruction recursively for all the constant
  /// expression operands. If NewInstArr is not null, put the newly created
  /// instructions in *NewInstArr. If \p ExprsToBreak is provided, only Exprs in
  /// that list are broken from \p Inst. Otherwise, all Exprs in \p Inst are
  /// broken.
  static void
  breakExpressions(Instruction *Inst,
                   SmallVectorImpl<Instruction *> *NewInstArr = nullptr,
                   SmallPtrSetImpl<ConstantExpr *> *ExprsToBreak = nullptr);

  /// \brief Breaks up the instruction recursively for the gvien constant
  /// expression operand. If NewInstArr is not null, put the newly created
  /// instructions in *NewInstArr. If \p ExprsToBreak is provided, \p Expr is
  /// broken only if it's in that list.
  static void breakExpressionsHelper(
      ConstantExpr *Expr, unsigned OperandIndex, Instruction *User,
      SmallVectorImpl<Instruction *> *NewInstArr = nullptr,
      SmallPtrSetImpl<ConstantExpr *> *ExprsToBreak = nullptr);

  /// \brief Returns false if I's next instruction is terminator instruction.
  /// Otherwise returns true.
  static bool hasNextUniqueInstruction(Instruction *I);

  /// \brief Returns instruction I's next instruction in the same basic block.
  static Instruction* nextUniqueInstruction(Instruction *I);

#if INTEL_CUSTOMIZATION
  /// \brief Returns true if the value V escapes.
  static bool isEscaped(const Value *V);
#endif // INTEL_CUSTOMIZATION

  /// \brief Return the size_t type for 32/64 bit architecture
  static Type *getSizeTTy(Function *F);
  static Type *getSizeTTy(Module *M);

  /// Returns true if \p V is an expression that may be generated by FE
  /// for a global variable reference in an OpenMP clause,
  /// which is an optionally AddrSpaceCast'ed GlobalVariable.
  static bool isOMPItemGlobalVAR(const Value *V);

  /// Returns true if \p V is an instruction that may be generated by FE
  /// for a local variable reference in an OpenMP clause,
  /// which is a value of a pointer type, except isOMPItemGlobalVAR().
  static bool isOMPItemLocalVAR(const Value *V);

  /// Returns the pointer's element type of a local variable referenced
  /// in an OpenMP clause. The second return value is the number of
  /// elements of the underlying element type in the object referenced
  /// by the clause. It is isOneValue() for scalars, and something else
  /// for VLAs. Note that array allocations with known size will
  /// have their size represented in the type itself in most cases.
  /// isOMPItemLocalVAR() is asserted for \p V.
  /// \p VElemTy is the ElementType for V's Pointer Type.
  /// This is the default returned when the Value is not a local variable/
  /// alloca Inst. The Argument is passed to make the API compatible with
  /// opaque pointers.
  static std::tuple<Type *, Value *>
  getOMPItemLocalVARPointerTypeAndNumElem(Value *V, Type *VElemTy);
};

} // end llvm namespace

#endif // LLVM_TRANSFORM_UTILS_GENERALUTILS_H
#endif // INTEL_COLLAB
