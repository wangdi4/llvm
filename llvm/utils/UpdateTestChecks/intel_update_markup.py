#!/usr/bin/env python3
"""A intel markup update script.

This script is a utility to update intel markup for test file.
Supported file extension: .ll, .mir.
"""

import argparse
import os
import tempfile
import subprocess
from subprocess import PIPE
import logging
import sys
# This script can be used either as part of the UpdateTestChecks module
# or as the main module
if __name__ == '__main__':
    import common
else:
    from . import common

def check_ext(file_ext):
    if file_ext not in {'.ll', '.mir'}:
        raise NotImplementedError(f'Unsupported file extension {file_ext}')


def get_comment_char(file_ext):
    check_ext(file_ext)
    return ';' if file_ext == '.ll' else '#'


def get_special_comment_char():
    return ';'


def get_special_single_line_markup():
    # Only this single-line markup can be used on RUN and CHECK line
    scc = get_special_comment_char()
    return f'{scc}INTEL'


def get_single_line_markup(file_ext):
    check_ext(file_ext)
    cc = get_comment_char(file_ext)
    return f'{cc} INTEL'


def get_multi_line_markup(file_ext):
    check_ext(file_ext)
    cc = get_comment_char(file_ext)
    return f'{cc} INTEL_CUSTOMIZATION', f'{cc} end INTEL_CUSTOMIZATION'


def get_note(file_ext):
    check_ext(file_ext)
    cc = get_comment_char(file_ext)
    return f'{cc} INTEL markup has been autogenerated by {os.path.basename(__file__)}'


def get_ext(exp):
    _, file_ext = os.path.splitext(exp)
    check_ext(file_ext)
    return file_ext


def get_markup(exp):
    file_ext = get_ext(exp)
    ss_markup = get_special_single_line_markup()
    s_markup = get_single_line_markup(file_ext)
    m_markup_start, m_markup_end = get_multi_line_markup(file_ext)
    return ss_markup, s_markup, m_markup_start, m_markup_end


def get_dir():
    return os.path.dirname(os.path.realpath(__file__))


def has_git():
    version = subprocess.run(['git', '--version'], stdout=PIPE, stderr=PIPE)
    return version.returncode == 0


def has_sed():
    version = subprocess.run(['sed', '--version'], stdout=PIPE, stderr=PIPE)
    return version.returncode == 0


def get_llorg_ref(exp):
    """Get the latest llorg version of the file"""
    dir_path = get_dir()
    ref_commit = subprocess.run(['git', 'merge-base', 'origin/main', 'HEAD'],
                                stdout=PIPE,
                                stderr=PIPE,
                                cwd=dir_path,
                                check=True)
    ref_commit = ref_commit.stdout.decode('utf-8').strip()
    logging.debug(f'Merge base: {ref_commit}')

    # Get the path of the file relative to git repository root, so that
    # we can run the script in any subdirectory.
    exp_path = subprocess.run(['git', 'ls-files', '--full-name', exp],
                             stdout=PIPE,
                             stderr=PIPE)
    exp = exp_path.stdout.decode('utf-8').strip()
    if not exp:
        return None
    ref_str = subprocess.run(['git', 'show', f'{ref_commit}:{exp}'],
                             stdout=PIPE,
                             stderr=PIPE,
                             cwd=dir_path)
    if ref_str.returncode:
        return None

    logging.debug(f'Found llorg ref: {exp}')
    # Clone the older version to a temp file
    ref_file = tempfile.NamedTemporaryFile(delete=False)
    logging.debug(f'Cloning llorg ref to {ref_file.name} ...')
    try:
        ref_file.write(ref_str.stdout)
    finally:
        ref_file.close()
        ref = ref_file.name

    return ref


def drop(exp):
    """Remove existing intel markup and note"""
    # No error and no ouput by intention b/c the API may be called by a test
    if not has_sed():
        logging.debug(f'Not found SED')
        return
    ss_markup, s_markup, m_markup_start, m_markup_end = get_markup(exp)
    note = get_note(get_ext(exp))
    logging.debug(f'Dropping markup and note ...')

    script = R'/{m_markup_start}\|{m_markup_end}/Id;s/\s\+{s_markup}$//;s/\s\+{ss_markup}$//;/{note}/d'
    script = script.replace(R'{m_markup_start}', str(m_markup_start))
    script = script.replace(R'{m_markup_end}', str(m_markup_end))
    script = script.replace(R'{s_markup}', str(s_markup))
    script = script.replace(R'{ss_markup}', str(ss_markup))
    script = script.replace(R'{note}', str(note))
    logging.debug(f'SED script: {script}')
    subprocess.run(['sed', '-i', '-b', script, exp], check=True)


def find_interested_lines(exp, script):
    lines = subprocess.run(['sed', '-n', script, exp], stdout=PIPE, check=True)
    lines = lines.stdout.decode('utf-8').strip().split()
    lines = list(map(int, lines))
    return lines


def find_run_lines(exp):
    with open(exp) as file:
        run_lines = [i for i, l in enumerate(file, 1) if common.RUN_LINE_RE.match(l)]
    if run_lines:
        logging.debug(f'Found RUN lines: {run_lines}')
    return run_lines


def find_run_lines_with_line_continue(exp):
    with open(exp) as file:
        run_lines = [i for i, l in enumerate(file, 1) if l.rstrip().endswith('\\')]
    if run_lines:
        logging.debug(f'Found RUN lines that end with \\: {run_lines}')
    return run_lines


def get_check_prefixes_from(filecheck_cmd):
    check_prefixes = [item for m in common.CHECK_PREFIX_RE.finditer(filecheck_cmd)
                             for item in m.group(1).split(',')]
    if not check_prefixes:
        check_prefixes = ['CHECK']
    if check_prefixes:
        logging.debug(f'Found CHECK prefixes: {check_prefixes}')
    return check_prefixes


def get_filecheck_cmds(exp, run_lines):
    # filecheck can only be the last cmd in pipeline
    run_lines_set = set(run_lines)
    with open(exp) as file:
        filecheck_cmds = [l.split('|')[-1].strip() for i, l in enumerate(file, 1) if i in run_lines_set and 'FileCheck' in l]
    if filecheck_cmds:
        logging.debug(f'Found FileCheck commands: {filecheck_cmds}')
    return filecheck_cmds


def get_check_prefixes(exp, run_lines):
    check_prefixes = []
    for cmd in get_filecheck_cmds(exp, run_lines):
        check_prefixes = check_prefixes + get_check_prefixes_from(cmd)
    return check_prefixes


def find_check_lines(exp, run_lines):
    prefix_set = set(get_check_prefixes(exp, run_lines))
    check_lines = []
    with open(exp) as file:
        for i, l in enumerate(file, 1):
            m = common.CHECK_RE.match(l)
            if m and m.group(1) in prefix_set:
                check_lines.append(i)
    if check_lines:
        logging.debug(f'Found CHECK lines: {check_lines}')
    return check_lines


def add(exp, max_line, ref, comment):
    """Add intel markup and note for a clean file"""
    # No error and no ouput by intention b/c the API may be called by a test
    if not has_git() or not has_sed():
        logging.debug(f'Not found GIT or SED')
        return

    ss_markup, s_markup, m_markup_start, m_markup_end = get_markup(exp)

    # Use the latest file from llorg by default
    if not ref:
        ref = get_llorg_ref(exp)
    # ref does not exist (a intel-only file)
    if not ref:
        return

    # Format for output of git diff:
    #
    # @@ -[ref_start][,ref_lines] +[exp_start],[,exp_lines] @@
    #
    # [,ref_lines] or [,exp_lines] can be omitted if it's a single-line change
    diff = subprocess.run([
        'git', 'diff', '--ignore-cr-at-eol', '--unified=0', '--no-index',
        '--no-color', ref, exp
    ],
                          stdout=PIPE)
    diff = subprocess.run(['sed', '-nE', R"s/^@@[0-9 ,-]+\+([0-9,]+).*/\1/p"],
                          input=diff.stdout,
                          stdout=PIPE,
                          check=True)
    diff = diff.stdout.decode('utf-8').strip().split()

    # We prefer to use muti-line markup for a range with blank lines b/c one-line markup
    # looks weird on a blank line
    blank_lines = find_interested_lines(exp, '/^\s*$/=')
    has_blank_line = lambda start, end : any(line >= start and line <= end for line in blank_lines)

    # One-line markup is not supported on FEATURE line
    feature_str = 'INTEL_' + 'FEATURE_' # Work around the ipscan issue by splitting the string
    feature_lines = find_interested_lines(exp, f'/{feature_str}/=')
    has_feature_line = lambda start, end : any(line >= start and line <= end for line in feature_lines)

    # One-line markup is not supported on RUN line with line continue chararter
    run_lines_with_line_continue = find_run_lines_with_line_continue(exp)
    has_run_lines_with_line_continue = lambda start, end : any(line >= start and line <= end for line in run_lines_with_line_continue)

    # Only special single-line markup can be used on RUN/CHECK line
    run_lines = find_run_lines(exp)
    check_lines = find_check_lines(exp, run_lines)
    run_check_lines = set(run_lines) | set(check_lines)

    has_s_markup = False
    has_m_markup = False
    logging.debug(f'Adding markup ...')
    for line_range in diff:
        exp_start = int(line_range.split(',')[0])
        exp_lines = int(line_range.split(',')[1]) if ',' in line_range else 1
        if not exp_lines:
            continue
        exp_end = exp_start + exp_lines - 1
        if exp_lines <= max_line and not has_blank_line(exp_start, exp_end) and not has_feature_line(exp_start, exp_end) and not has_run_lines_with_line_continue(exp_start, exp_end):
            change_lines = set(range(exp_start, exp_end + 1))
            change_lines_w_ss = change_lines & run_check_lines
            change_lines_w_s = change_lines - run_check_lines
            s_script = ''
            for l in change_lines_w_ss:
                s_script += f'{l}s/$/ {ss_markup}/;'
            for l in change_lines_w_s:
                s_script += f'{l}s/$/ {s_markup}/;'
            s_script = s_script.rstrip(';')
            logging.debug(f'SED script: {s_script}')
            subprocess.run(['sed', '-i', '-b', s_script, exp])
            has_s_markup = True
        else:
            # No new line here, so the line info from git diff is still valid
            m_script = f'{exp_start}s/^/{m_markup_start} /;{exp_end}s/$/{m_markup_end} /'
            logging.debug(f'SED script: {m_script}')
            subprocess.run(['sed', '-i', '-b', m_script, exp])
            has_m_markup = True

    # Make multi-line markup in a stand-alone line
    if has_m_markup:
        m_script = R's/^\({m_markup_start}\) /\1\n/;s/\({m_markup_end}\) $/\n\1/'
        m_script = m_script.replace(R'{m_markup_start}', str(m_markup_start))
        m_script = m_script.replace(R'{m_markup_end}', str(m_markup_end))
        subprocess.run(['sed', '-i', '-b', m_script, exp])

    if not comment:
        return
    # Add note at the first line
    if has_s_markup or has_m_markup:
        logging.debug(f'Adding note ...')
        script = R'1i\{note}'
        note = get_note(get_ext(exp))
        script = script.replace(R'{note}', note)
        logging.debug(f'SED script: {script}')
        subprocess.run(['sed', '-i', '-b', script, exp])


def update(exp, max_line=3, ref=None, comment=True):
    """Update intel markup for a file (Do nothing if there is an explicit INTEL_MARKUP=0) """
    markup = os.environ.get('INTEL_MARKUP', '1')
    if markup == '0':
        return

    drop(exp)
    add(exp, max_line, ref, comment)


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('exp', metavar='EXP', help='The file to be updated')
    parser.add_argument(
        '--max',
        metavar='MAX',
        help=
        'single-line markup for change within MAX, otherwise multi-line markup',
        type=int,
        default=3)
    parser.add_argument(
        '--ref',
        metavar='REF',
        help=
        'The file used a reference (latest llorg version is used if not provided'
    )
    parser.add_argument('--drop', help='Drop markup and note', action='store_true')
    parser.add_argument('--comment', help='Add a comment if markup is added', action='store_true')
    parser.add_argument('--log', help='Print the log', action='store_true')
    args = parser.parse_args()

    # Argument checking
    max_line = args.max
    if max_line < 0:
        raise ValueError(f'--max value {max_line} is less than 0')
    exp = args.exp
    if not os.path.isfile(exp):
        raise OSError(f'Non-existing file {exp}')
    ref = args.ref
    if ref and not os.path.isfile(ref):
        raise OSError(f'Non-existing file {ref}')

    log_level = logging.DEBUG if args.log else logging.WARNING
    logging.basicConfig(format='%(message)s', level=log_level, stream=sys.stdout)
    drop(exp)
    if args.drop:
        return

    add(exp, max_line, ref, args.comment)


if __name__ == '__main__':
    main()
