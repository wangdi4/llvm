#!/usr/bin/env python3
"""A intel markup update script.

This script is a utility to update intel markup for test file.
Supported file extension: .ll, .mir, .s, .txt, '.c', '.cpp', '.td', '.test', '.mm'
"""

import argparse
import os
import tempfile
import subprocess
from subprocess import PIPE
import logging
import sys
from multiprocessing import Pool
from functools import partial
import re

# REGEX copied from common
RUN_LINE_RE = re.compile(r'^\s*(?://|[;#])\s*RUN:\s*(.*)$')
CHECK_PREFIX_RE = re.compile(r'--?check-prefix(?:es)?[= ](\S+)')
CHECK_RE = re.compile(r'^\s*(?://|[;#])\s*([^:]+?)(?:-NEXT|-NOT|-DAG|-LABEL|-SAME|-EMPTY)?:')

# NOTE: Duplication of REGEX could be avoid by following statements, but it
#       would trigger error on windows due to known issue
#
#       https://bugs.python.org/issue45914
#
# This script can be used either as part of the UpdateTestChecks module
# or as the main module
# if __name__ == '__main__':
#     import common
# else:
#     from . import common
#
# The error can be reproduced by on linux via
#    multiprocessing.set_start_method('spawn')

def check_ext(file_ext):
    if file_ext not in {'ll', 'mir', 's', 'txt', 'c', 'cpp', 'td', 'test', 'mm'}:
        raise NotImplementedError(f'Unsupported file extension .{file_ext}')


def get_comment_char(file_ext):
    check_ext(file_ext)
    if file_ext == 'll':
        return ';'
    elif file_ext in {'mir', 's', 'txt', 'test'}:
        return '#'
    else:
        return '\/\/'


def get_special_comment_char():
    return ';'


def get_special_single_line_markup():
    # Only this single-line markup can be used on RUN and CHECK line
    scc = get_special_comment_char()
    return f'{scc}INTEL'


def get_single_line_markup(file_ext):
    check_ext(file_ext)
    cc = get_comment_char(file_ext)
    return f'{cc} INTEL'


def get_multi_line_markup(file_ext):
    check_ext(file_ext)
    cc = get_comment_char(file_ext)
    return f'{cc} INTEL_CUSTOMIZATION', f'{cc} end INTEL_CUSTOMIZATION'


def get_note(file_ext):
    check_ext(file_ext)
    cc = get_comment_char(file_ext)
    return f'{cc} INTEL markup has been autogenerated by {os.path.basename(__file__)}'


def get_ext(exp):
    _, file_ext = os.path.splitext(exp)
    file_ext = file_ext.lstrip('.')
    check_ext(file_ext)
    return file_ext


def get_markup(exp):
    file_ext = get_ext(exp)
    ss_markup = get_special_single_line_markup()
    s_markup = get_single_line_markup(file_ext)
    m_markup_start, m_markup_end = get_multi_line_markup(file_ext)
    return ss_markup, s_markup, m_markup_start, m_markup_end


def get_dir(file=__file__):
    return os.path.dirname(os.path.realpath(file))


def check_tool(exe, error=True):
    version = subprocess.run([exe, '--version'], stdout=PIPE, stderr=PIPE)
    if version.returncode:
        msg = f'Not found {exe}'
        if error:
            raise EnvironmentError(msg)
        else:
            logging.debug(msg)
            return False
    return True


def check_git(error=True):
    return check_tool('git', error)


def check_sed(error=True):
    return check_tool('sed', error)


def check_git_sed(error=True):
    return check_git(error) and check_sed(error)


def get_ref_branch():
    return 'origin/main'


def get_merge_base():
    base = subprocess.run(['git', 'merge-base', f'{get_ref_branch()}', 'HEAD'],
                                stdout=PIPE,
                                stderr=PIPE,
                                cwd=get_dir(),
                                check=True)
    base = base.stdout.decode('utf-8').strip()
    assert base, f'Expect a common ancestor with f{get_ref_branch()}'
    logging.debug(f'Merge base: {base}')
    return base


def get_file_path_in_git(exp):
    exp = subprocess.run(['git', 'ls-files', '--full-name', exp],
                             stdout=PIPE,
                             stderr=PIPE)
    exp = exp.stdout.decode('utf-8').strip()
    return exp


# MODIFY THIS FUNCTION WITH CARE!
# GIT is used for version control, so we don't test git history to avoid circular dependencies.
def get_llorg_ref(exp, ref_commit=None):
    """Get file from best common ancestor with llorg"""
    # Get the path of the file relative to git repository root, so that
    # we can run the script in any subdirectory.
    exp_path = exp
    exp = get_file_path_in_git(exp)
    # NOTE: It's time consuming to get a merge base. So we check the result of
    # get_file_path_in_git before calling get_merge_base to bail out quickly
    # for a untracked file.
    if not exp:
        logging.debug(f'File {exp_path} is no tracked by GIT')
        return None

    if ref_commit == None:
        ref_commit = get_merge_base()

    ref_str = subprocess.run(['git', 'show', f'{ref_commit}:{exp}'],
                             stdout=PIPE,
                             stderr=PIPE,
                             cwd=get_dir())
    if ref_str.returncode:
        logging.debug(f'Commit {ref_commit} does not have file {exp}')
        return None

    logging.debug(f'Found llorg ref: {exp}')
    # Clone the older version to a temp file
    ref_file = tempfile.NamedTemporaryFile(delete=False)
    logging.debug(f'Cloning llorg ref to {ref_file.name} ...')
    try:
        ref_file.write(ref_str.stdout)
    finally:
        ref_file.close()
        ref = ref_file.name

    return ref


def drop(exp):
    """Remove existing intel markup and note"""
    ss_markup, s_markup, m_markup_start, m_markup_end = get_markup(exp)
    note = get_note(get_ext(exp))
    logging.debug(f'Dropping markup and note ...')

    script = R'/{m_markup_start}\|{m_markup_end}/Id;s/\s\+{s_markup}$//;s/\s\+{ss_markup}$//;/{note}/d'
    script = script.replace(R'{m_markup_start}', str(m_markup_start))
    script = script.replace(R'{m_markup_end}', str(m_markup_end))
    script = script.replace(R'{s_markup}', str(s_markup))
    script = script.replace(R'{ss_markup}', str(ss_markup))
    script = script.replace(R'{note}', str(note))
    logging.debug(f'SED script: {script}')
    subprocess.run(['sed', '-i', '-b', script, exp], check=True)


def find_interested_lines(exp, script):
    lines = subprocess.run(['sed', '-n', script, exp], stdout=PIPE, check=True)
    lines = lines.stdout.decode('utf-8').strip().split()
    lines = list(map(int, lines))
    return lines


def find_run_lines(exp):
    with open(exp) as file:
        run_lines = [i for i, l in enumerate(file, 1) if RUN_LINE_RE.match(l)]
    if run_lines:
        logging.debug(f'Found RUN lines: {run_lines}')
    return run_lines


def find_run_lines_with_line_continue(exp):
    with open(exp) as file:
        run_lines = [i for i, l in enumerate(file, 1) if l.rstrip().endswith('\\')]
    if run_lines:
        logging.debug(f'Found RUN lines that end with \\: {run_lines}')
    return run_lines


def get_check_prefixes_from(filecheck_cmd):
    check_prefixes = [item for m in CHECK_PREFIX_RE.finditer(filecheck_cmd)
                             for item in m.group(1).split(',')]
    if not check_prefixes:
        check_prefixes = ['CHECK']
    if check_prefixes:
        logging.debug(f'Found CHECK prefixes: {check_prefixes}')
    return check_prefixes


def get_filecheck_cmds(exp, run_lines):
    # filecheck can only be the last cmd in pipeline
    run_lines_set = set(run_lines)
    with open(exp) as file:
        filecheck_cmds = [l.split('|')[-1].strip() for i, l in enumerate(file, 1) if i in run_lines_set and 'FileCheck' in l]
    if filecheck_cmds:
        logging.debug(f'Found FileCheck commands: {filecheck_cmds}')
    return filecheck_cmds


def get_check_prefixes(exp, run_lines):
    check_prefixes = []
    for cmd in get_filecheck_cmds(exp, run_lines):
        check_prefixes = check_prefixes + get_check_prefixes_from(cmd)
    return check_prefixes


def find_check_lines(exp, run_lines):
    prefix_set = set(get_check_prefixes(exp, run_lines))
    check_lines = []
    with open(exp) as file:
        for i, l in enumerate(file, 1):
            m = CHECK_RE.match(l)
            if m and m.group(1) in prefix_set:
                check_lines.append(i)
    if check_lines:
        logging.debug(f'Found CHECK lines: {check_lines}')
    return check_lines


def add(exp, max_line, ref, comment):
    """Add intel markup and note for a clean file"""
    assert ref, 'Expect a ref file'

    ss_markup, s_markup, m_markup_start, m_markup_end = get_markup(exp)

    # Format for output of git diff:
    #
    # @@ -[ref_start][,ref_lines] +[exp_start],[,exp_lines] @@
    #
    # [,ref_lines] or [,exp_lines] can be omitted if it's a single-line change
    diff = subprocess.run([
        'git', 'diff', '--ignore-cr-at-eol', '--unified=0', '--no-index',
        '--no-color', ref, exp
    ],
                          stdout=PIPE)
    diff = subprocess.run(['sed', '-nE', R"s/^@@[0-9 ,-]+\+([0-9,]+).*/\1/p"],
                          input=diff.stdout,
                          stdout=PIPE,
                          check=True)
    diff = diff.stdout.decode('utf-8').strip().split()

    # We prefer to use muti-line markup for a range with blank lines b/c one-line markup
    # looks weird on a blank line
    blank_lines = find_interested_lines(exp, '/^\s*$/=')
    has_blank_line = lambda start, end : any(line >= start and line <= end for line in blank_lines)

    # One-line markup is not supported on FEATURE line
    feature_str = 'INTEL_' + 'FEATURE_' # Work around the ipscan issue by splitting the string
    feature_lines = find_interested_lines(exp, f'/{feature_str}/=')
    has_feature_line = lambda start, end : any(line >= start and line <= end for line in feature_lines)

    # One-line markup is not supported on RUN line with line continue chararter
    run_lines_with_line_continue = find_run_lines_with_line_continue(exp)
    has_run_lines_with_line_continue = lambda start, end : any(line >= start and line <= end for line in run_lines_with_line_continue)

    # Only special single-line markup can be used on RUN/CHECK line
    run_lines = find_run_lines(exp)
    check_lines = find_check_lines(exp, run_lines)
    run_check_lines = set(run_lines) | set(check_lines)

    has_s_markup = False
    has_m_markup = False
    logging.debug(f'Adding markup ...')
    for line_range in diff:
        exp_start = int(line_range.split(',')[0])
        exp_lines = int(line_range.split(',')[1]) if ',' in line_range else 1
        if not exp_lines:
            continue
        exp_end = exp_start + exp_lines - 1
        if exp_lines <= max_line and not has_blank_line(exp_start, exp_end) and not has_feature_line(exp_start, exp_end) and not has_run_lines_with_line_continue(exp_start, exp_end):
            change_lines = set(range(exp_start, exp_end + 1))
            change_lines_w_ss = change_lines & run_check_lines
            change_lines_w_s = change_lines - run_check_lines
            s_script = ''
            for l in change_lines_w_ss:
                s_script += f'{l}s/$/ {ss_markup}/;'
            for l in change_lines_w_s:
                s_script += f'{l}s/$/ {s_markup}/;'
            s_script = s_script.rstrip(';')
            logging.debug(f'SED script: {s_script}')
            subprocess.run(['sed', '-i', '-b', s_script, exp])
            has_s_markup = True
        else:
            # No new line here, so the line info from git diff is still valid
            m_script = f'{exp_start}s/^/{m_markup_start} /;{exp_end}s/$/{m_markup_end} /'
            logging.debug(f'SED script: {m_script}')
            subprocess.run(['sed', '-i', '-b', m_script, exp])
            has_m_markup = True

    # Make multi-line markup in a stand-alone line
    if has_m_markup:
        m_script = R's/^\({m_markup_start}\) /\1\n/;s/\({m_markup_end}\) $/\n\1/'
        m_script = m_script.replace(R'{m_markup_start}', str(m_markup_start))
        m_script = m_script.replace(R'{m_markup_end}', str(m_markup_end))
        subprocess.run(['sed', '-i', '-b', m_script, exp])

    if not comment:
        return
    # Add note at the first line
    if has_s_markup or has_m_markup:
        logging.debug(f'Adding note ...')
        script = R'1i\{note}'
        note = get_note(get_ext(exp))
        script = script.replace(R'{note}', note)
        logging.debug(f'SED script: {script}')
        subprocess.run(['sed', '-i', '-b', script, exp])


def update(exp, max_line=3, ref=None, comment=True):
    """Update intel markup for a file (Do nothing if there is an explicit INTEL_MARKUP=0) """
    markup = os.environ.get('INTEL_MARKUP', '1')
    if markup == '0':
        return
    # No error b/c the API may be called by a LIT test
    if not check_git_sed(False):
        return

    drop(exp)
    if not ref:
        ref = get_llorg_ref(exp)
    if not ref: # INTEL-only file
        return
    add(exp, max_line, ref, comment)


def check_file(file):
    if not os.path.isfile(file):
        raise OSError(f'Non-existing file {file}')


def check_file_and_ext(file):
    check_file(file)
    get_ext(file)


def check_noneg(name, value):
    if value < 0:
        raise ValueError(f'{name} value {value} is less than 0')


def drop_may_add(exp, max_line, ref, ref_commit, comment, drop_only):
    logging.debug(f'Processing file {exp} ...')
    drop(exp)
    if drop_only:
        return
    ref = ref if ref else get_llorg_ref(exp, ref_commit)
    if not ref:
        return
    add(exp, max_line, ref, comment)


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('exps', metavar='EXP', nargs='+', help='file to be updated')
    parser.add_argument(
        '--max',
        metavar='MAX',
        help=
        'single-line markup for change within MAX, otherwise multi-line markup',
        type=int,
        default=3)
    parser.add_argument(
        '--ref',
        metavar='REF',
        help=
        'file used as reference (file from best common ancestor with llorg is used if not provided)'
    )
    parser.add_argument('--drop', help='drop markup and note', action='store_true')
    parser.add_argument('--comment', help='add a comment if markup is added', action='store_true')
    parser.add_argument('--log', help='print the log (supported only on posix os)', action='store_true')
    parser.add_argument('-j', metavar='N', dest='jobs', help=f'run N jobs in parallel (default={os.cpu_count()} on this system)', type=int, default=os.cpu_count())
    args = parser.parse_args()

    check_git_sed(True)

    # Log utility
    log_level = logging.DEBUG if args.log else logging.WARNING
    logging.basicConfig(format='%(message)s', level=log_level, stream=sys.stdout)

    # Argument checking
    check_noneg('--max', args.max)
    args.ref and check_file(args.ref)
    if args.log and os.name != 'posix':
        raise NotImplementedError('--log is supported on posix only') # Due to multiprocessing implementation
    check_noneg('-j', args.jobs)
    jobs = min(args.jobs, len(args.exps))
    logging.debug(f'Running {jobs} job(s) in parallel ...')
    with Pool(jobs) as p:
        p.map(check_file_and_ext, args.exps)

    # Look for the best common ancestor only once
    ref_commit = None if args.ref or args.drop else get_merge_base()
    assert not (args.ref and ref_commit), 'One at most'

    # Process files
    helper = partial(drop_may_add, max_line=args.max, ref=args.ref, ref_commit=ref_commit, comment=args.comment, drop_only=args.drop)
    with Pool(jobs) as p:
        p.map(helper, args.exps)


if __name__ == '__main__':
    main()
