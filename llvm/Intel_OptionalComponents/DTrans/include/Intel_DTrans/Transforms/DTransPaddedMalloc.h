//===------------- DTransPaddedMalloc.h - DTransPaddedMalloc  -------------===//
//
// Copyright (C) 2018-2019 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
//===----------------------------------------------------------------------===//
//
// This file declares the DTrans padded malloc optimization pass.
//
//===----------------------------------------------------------------------===//

#if !INTEL_INCLUDE_DTRANS
#error DTransPaddedMalloc.h include in an non-INTEL_INCLUDE_DTRANS build.
#endif

#ifndef INTEL_DTRANS_TRANSFORMS_PADDEDMALLOC_H
#define INTEL_DTRANS_TRANSFORMS_PADDEDMALLOC_H

#include "Intel_DTrans/Analysis/DTransAnalysis.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/PassManager.h"
#include <set>
#include <vector>

namespace llvm {

namespace dtrans {

// This pair indicates if a function is inside an OpenMP
// region or not
typedef std::pair<Function *, bool> PaddedMallocFunc;

// Class used to build and remove the global variable
// and interface used in padded malloc
class PaddedMallocGlobals {

public:
  PaddedMallocGlobals(){};

  // Build the global counter and interface that will be used in Padded Malloc
  void buildGlobalsInfo(Module &M);

  // Build the runtime bad cast validation for a \p Func. \p ArgumentIndex and
  // \p StructIndex indicate what argument to validate.
  bool buildFuncBadCastValidation(Function *Func, unsigned ArgumentIndex,
                                  unsigned StructIndex);

  // Destroy the global counter and interface that were generated
  void destroyGlobalsInfo(Module &M);

  // Return true if all the data for padded malloc is set correctly.
  bool isPaddedMallocDataAvailable(Module &M);

  // Return the interface generated by padded malloc function
  Function *getPaddedMallocInterface(Module &M);

  // Return the global variable generated by padded malloc
  GlobalVariable *getPaddedMallocVariable(Module &M);

  // Return the size used in the padded malloc optimizaton
  unsigned getPaddedMallocSize(Module &M);

private:
  // Build the counter used to identify if padded malloc will be applied
  // or not
  void buildGlobalVariableCounter(Module &M);

  // Build a new boolean function in the module M that checks if
  // global counter has reached the limit or not.
  void buildInterfaceFunction(Module &M);

private:
  SmallVector<Function *, 8> BadCastValidatedFuncs;
};

/// Pass to perform DTrans padded malloc.
class PaddedMallocPass : public PassInfoMixin<dtrans::PaddedMallocPass> {
public:
  PaddedMallocPass(){};

  // Lambda function to collect the LoopInfo for a given function
  using LoopInfoFuncType = std::function<LoopInfo &(Function &)>;

  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);

  // Actual implementation of the optimization
  bool runImpl(
      Module &M, DTransAnalysisInfo &DTInfo, LoopInfoFuncType &GetLI,
      std::function<const TargetLibraryInfo &(Function &)> GetTLI,
      WholeProgramInfo &WPInfo);

private:
  PaddedMallocGlobals PaddedMallocData;

  // Apply the padded malloc optimization to the functions stored in
  // PaddedMallocFuncs.
  bool applyPaddedMalloc(std::vector<PaddedMallocFunc> &PaddedMallocVect,
                         GlobalVariable *globCounter, Function *PMFunc,
                         Module *M, const TargetLibraryInfo &TLInfo,
                         DTransAnalysisInfo &DTInfo);

  // Return true if the input Instruction will be used in the input BranchInst,
  // else return false.
  bool checkDependence(Instruction *CheckInst, BranchInst *Branch);

  // Set true on each entry of PaddedMallocVect that is inside an OpenMP region
  void checkForParallelRegion(
      Module &M, std::vector<dtrans::PaddedMallocFunc> &PaddedMallocVect);

  // Return true if the input BasicBlock is a comparison between
  // two pointer/array/vector entries in order to exit a loop.
  // Else, return false.
  bool exitDueToSearch(BasicBlock &BB);

  // Traverse through each field of the structures stored in DTInfo and check
  // if the memory allocation for each field only happens in one function. If
  // so, then collect that function and store it in PaddedMallocVect.
  bool
  findFieldSingleValueFuncs(DTransAnalysisInfo &DTInfo,
                            std::vector<PaddedMallocFunc> &PaddedMallocVect);

  // Return true if at least one Function in the input Module has a
  // search loop
  bool findSearchLoops(Module &M, LoopInfoFuncType &GetLI);

  // Return true if there is a search loop in the input Function,
  // else return false.
  bool funcHasSearchLoop(Function &Fn, LoopInfoFuncType &GetLI);

  // Return true if Fn is being called from an OpenMP region,
  // else return false.
  bool insideParallelRegion(Function *Fn,
                            SmallPtrSet<Function *, 10> &VisitedFuncs);

  // Return true if at least one successor of the input BasicBlock will
  // exit the input Loop, else return false.
  bool isExitLoop(Loop *LoopData, BasicBlock *BB);

  // Return true if the input Function is an OpenMP outline function,
  // else return false
  bool isOutlineFunction(Function *F);

  // Return true if the input GetElementPtrInst is valid to consider as a
  // an array, vector or a pointer memory space allocated.
  bool isValidType(GetElementPtrInst *ElemInst);

  // Return true if the padded malloc was applied in the input BasicBlock
  // that corresponds to the input Function. Else return false.
  bool updateBasicBlock(BasicBlock &BB, Function *F,
                        GlobalVariable *GlobalCounter,
                        const TargetLibraryInfo &TLInfo, Module *M,
                        bool UseOpenMP);
};

} // namespace dtrans

ModulePass *createDTransPaddedMallocWrapperPass();

unsigned getPaddedMallocLimit();

// Returns 'true' if the padded malloc optimization is expected to be
// applied. Expected to be used in heuristics.
extern bool PaddedMallocIsActive(Module &M);

} // namespace llvm

#endif // INTEL_DTRANS_TRANSFORMS_PADDEDMALLOC_H
