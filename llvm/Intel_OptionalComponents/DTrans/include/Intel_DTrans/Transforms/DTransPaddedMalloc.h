//===------------- DTransPaddedMalloc.h - DTransPaddedMalloc  -------------===//
//
// Copyright (C) 2018-2023 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
//===----------------------------------------------------------------------===//
//
// This file declares the DTrans padded malloc optimization pass.
//
//===----------------------------------------------------------------------===//

#if !INTEL_FEATURE_SW_DTRANS
#error DTransPaddedMalloc.h include in an non-INTEL_FEATURE_SW_DTRANS build.
#endif

#ifndef INTEL_DTRANS_TRANSFORMS_PADDEDMALLOC_H
#define INTEL_DTRANS_TRANSFORMS_PADDEDMALLOC_H

#include "Intel_DTrans/Analysis/DTransAnalysis.h"
#include "Intel_DTrans/Analysis/DTransInfoAdapter.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/PassManager.h"
#include <set>
#include <vector>

namespace llvm {

namespace dtrans {

using LoopInfoFuncType = std::function<LoopInfo &(Function &)>;

// This pair indicates if a function is inside an OpenMP
// region or not
typedef std::pair<Function *, bool> PaddedMallocFunc;

// Class used to build and remove the global variable
// and interface used in padded malloc
template <class InfoClass>
class PaddedMallocGlobals {

public:
  PaddedMallocGlobals(InfoClass &DTransInfo) : DTransInfo(DTransInfo){};

  // Build the global counter and interface that will be used in Padded Malloc
  void buildGlobalsInfo(Module &M);

  // Build the runtime bad cast validation for a \p Func. \p ArgumentIndex and
  // \p StructIndex indicate what argument to validate.
  bool buildFuncBadCastValidation(Function *Func, unsigned ArgumentIndex,
                                  unsigned StructIndex);

  // Destroy the global counter and interface that were generated
  void destroyGlobalsInfo(Module &M);

  // Return true if all the data for padded malloc is set correctly.
  bool isPaddedMallocDataAvailable(Module &M);

  // Return the interface generated by padded malloc function
  Function *getPaddedMallocInterface(Module &M);

  // Return the global variable generated by padded malloc
  GlobalVariable *getPaddedMallocVariable(Module &M);

  // Return the size used in the padded malloc optimizaton
  unsigned getPaddedMallocSize(Module &M);

private:
  // Build the counter used to identify if padded malloc will be applied
  // or not
  void buildGlobalVariableCounter(Module &M);

  // Build a new boolean function in the module M that checks if
  // global counter has reached the limit or not.
  void buildInterfaceFunction(Module &M);

private:
  SmallVector<Function *, 8> BadCastValidatedFuncs;
  InfoClass &DTransInfo;
};

class PaddedMallocPass : public PassInfoMixin<dtrans::PaddedMallocPass> {
public:
  PaddedMallocPass() {};

  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);

  // Actual implementation of the optimization
  bool runImpl(
      Module &M, DTransAnalysisInfo &DTInfo, LoopInfoFuncType &GetLI,
      std::function<const TargetLibraryInfo &(Function &)> GetTLI,
      WholeProgramInfo &WPInfo);
};

} // namespace dtrans

namespace dtransOP {

class PaddedMallocOPPass : public PassInfoMixin<PaddedMallocOPPass> {
public:
  PaddedMallocOPPass() {};

  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);

  // Actual implementation of the optimization
  bool runImpl(
      Module &M, DTransSafetyInfo &DTInfo, dtrans::LoopInfoFuncType &GetLI,
      std::function<const TargetLibraryInfo &(Function &)> GetTLI,
      WholeProgramInfo &WPInfo);
};

} // namespace dtransOP

unsigned getPaddedMallocLimit();

// Returns 'true' if the padded malloc optimization is expected to be
// applied. Expected to be used in heuristics.
extern bool PaddedMallocIsActive(Module &M);

} // namespace llvm

#endif // INTEL_DTRANS_TRANSFORMS_PADDEDMALLOC_H
