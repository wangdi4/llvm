//===--------------- Intel_CPU_utils.cpp - CPU utilities -*---------------===//
//
// Copyright (C) 2019 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
//===----------------------------------------------------------------------===//
// This file contains the utilities that will be shared between llvm
// and clang
//===----------------------------------------------------------------------===//

#include "llvm/Support/Intel_CPU_utils.h"
#include "llvm/Support/ManagedStatic.h"
#include <bitset>

using namespace llvm;

namespace {
//
// CPUs are built from a subset of features.
// Here, we define the enumeration of the features only.
//
#define CPU_FEATURE_BEGIN(feature) feature,
#define CPU_FEATURE_DOC(s)
#define CPU_FEATURE_ADD_FEATURE(f)
#define CPU_FEATURE_BIT_POS(n)
#define CPU_FEATURE_ADD_ISA_NAME(s)
#define CPU_FEATURE_LIBIRC_NAME(s)
#define CPU_FEATURE_ADD_MACRO_NAME(s)
#define CPU_FEATURE_AUTOGENERATED
#define CPU_FEATURE_END
// Start of the enumeration
typedef enum {
  c_feature_none = 0,
#include "intel_glob_isa_list.def"
  c_feature_libirc_end
} IntelLibFeatureId;
#undef CPU_FEATURE_BEGIN
#undef CPU_FEATURE_DOC
#undef CPU_FEATURE_ADD_FEATURE
#undef CPU_FEATURE_BIT_POS
#undef CPU_FEATURE_ADD_ISA_NAME
#undef CPU_FEATURE_LIBIRC_NAME
#undef CPU_FEATURE_ADD_MACRO_NAME
#undef CPU_FEATURE_AUTOGENERATED
#undef CPU_FEATURE_END

//
// The following features aren't used in libIRC (features that contribute cpu
// dispatching), so they are defined here.
// The whole features set is a superset of features defined here with those
// in libirc (glob_feature_list.h is actually a copy of that definition)
// for identifying a cpu.
// Note that these "features" are not necessarily identified via CPUID.
// For example, "c_feature_nwd" is not a CPUID feature, but was used by the
// compiler to switch on the newer Pentuim4 die.
//
typedef enum {
  // Based on PentiumIII CPU with SSE2 support.
  c_feature_nwd = c_feature_libirc_end,
  // Graphic processor.
  c_feature_gfx,
  c_features_num
} IntelFeatureId;

typedef std::bitset<c_features_num> CpuInfoFeatureSet;
const int c_isa_vec_element_size = sizeof(X86::ISAVecElementTy) * CHAR_BIT;

// This structure holds information about LIBIRC feature within the driver
// context (icc).  BE maintains its own structure.
struct FeatureDefType {
  CpuInfoFeatureSet features;
  StringRef isa_name;
  std::vector<StringRef> public_macro_names;
  // Currently libirc_name is used for verification purposes only.
  StringRef libirc_name;
  int bitpos = -1;
  // Those that can be autogenerated by the compiler have this flag set.
  bool autogenerated = false;
  bool visited = false;
};

class ProcInfoFeatures {
  FeatureDefType proc_info_features[c_feature_libirc_end];

public:
  ProcInfoFeatures();

  const FeatureDefType *getFeatureByName(StringRef Feature) {
    auto I = find_if(proc_info_features,
                     [&](const FeatureDefType &Entry) {
                       return (Entry.isa_name == Feature);
                     });
    if (I != std::end(proc_info_features))
      return I;

    return nullptr;
  }
};
} // namespace

ProcInfoFeatures::ProcInfoFeatures() {
  // ISA table initialization.
#define CPU_FEATURE_BEGIN(isa)                                                 \
  {                                                                            \
    IntelLibFeatureId __curr_isa__ = (isa);                                    \
    proc_info_features[__curr_isa__].features[__curr_isa__] = 1;

#define CPU_FEATURE_DOC(s)
#define CPU_FEATURE_ADD_FEATURE(isa)                                           \
  assert(proc_info_features[(isa)].visited && "Unexpected feature");           \
  proc_info_features[__curr_isa__].features[(isa)] = 1;                        \
  proc_info_features[__curr_isa__].features |=                                 \
      proc_info_features[(isa)].features;

#define CPU_FEATURE_BIT_POS(n) proc_info_features[__curr_isa__].bitpos = (n);
#define CPU_FEATURE_ADD_ISA_NAME(name)                                         \
  proc_info_features[__curr_isa__].isa_name = StringRef(name);

#define CPU_FEATURE_LIBIRC_NAME(name)                                          \
  proc_info_features[__curr_isa__].libirc_name = StringRef(name);
#define CPU_FEATURE_ADD_MACRO_NAME(name)                                       \
  proc_info_features[__curr_isa__].public_macro_names.push_back(               \
      StringRef(name));
#define CPU_FEATURE_AUTOGENERATED                                              \
  proc_info_features[__curr_isa__].autogenerated = true;
#define CPU_FEATURE_END                                                        \
  proc_info_features[__curr_isa__].visited = true;                             \
  }

#include "intel_glob_isa_list.def"

#undef CPU_FEATURE_BEGIN
#undef CPU_FEATURE_DOC
#undef CPU_FEATURE_ADD_FEATURE
#undef CPU_FEATURE_BIT_POS
#undef CPU_FEATURE_ADD_ISA_NAME
#undef CPU_FEATURE_LIBIRC_NAME
#undef CPU_FEATURE_ADD_MACRO_NAME
#undef CPU_FEATURE_AUTOGENERATED
#undef CPU_FEATURE_END
}

static ManagedStatic<ProcInfoFeatures> PIF;

namespace llvm {

std::array<X86::ISAVecElementTy, 2>
X86::getCpuFeatureBitmap(ArrayRef<StringRef> CpuFeatures,
                         bool OnlyAutogenerated) {
  std::array<X86::ISAVecElementTy, 2> masks = {0, 0};

  for (auto CpuFeature : CpuFeatures) {
    const FeatureDefType *Entry = PIF->getFeatureByName(CpuFeature);
    if (!Entry)
      continue;
    if (OnlyAutogenerated && !Entry->autogenerated)
      continue;

    int bitpos = Entry->bitpos;
    int idx = bitpos / c_isa_vec_element_size;
    masks[idx] |= 1ULL << (bitpos - idx * c_isa_vec_element_size);
  }

  return masks;
}

bool X86::isCpuFeatureValid(StringRef CpuFeature) {
  return PIF->getFeatureByName(CpuFeature) != nullptr;
}
} // namespace llvm
