//===- Intel_ForcedCMOVGeneration.cpp - CMOV generation for special cases -===//
//
// Copyright (C) 2019 - 2020 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive
// property of Intel Corporation and may not be disclosed, examined
// or reproduced in whole or in part without explicit written authorization
// from the company.
//
//===----------------------------------------------------------------------===//
//
// Introduction
// ============
// ForcedCMOVGeneration pass will be used to generate CMOVs for cases where a
// single store instruction is found inside a 'then'  block of a if-then (no
// 'else') construct. if-then construct will be replaced by CMOV followed by
// store. This transformation will be done only if replacing a branch condition
// with a predicated instruction is profitable.
//
// Algorithm
// =========
// Step 1: The first step is scanning the code looking for if-then constructs.
// All Basic blocks in the function are parsed and a function
// IsACandidateBasicBlock(BB) is called for each of them. This function
// checks if BB is header block of a if-then construct.
// There are two more checks performed. The first test looks at the 'then' block
// and checks if it only has a single store instuction. HasSingleStore(..) is
// the function used for this. Another test is performed to check if it is
// profitable to replace the if-then construct with scalar code containing CMOV
// IsProfitableForCMOV(..) function is used for this test. This test uses a
// heuristic. This heuristic is the same as that used to decide between ‘select’
// and ‘if-then-else’ during the LLVM CodeGen phase
//
// Step 2: For each candidate if-then headerblock found in Step 1,
// transformation is performed in this step via the function AddSelectInst(..).
// In this transformation, a dummy variable in the stack (addr-1) is created.
// By parsing the 'then' block, the address in the store instruction (addr-2)
// is found.
// A select instruction is created to choose between the two addresses.
// For example:
// Before the pass:
//  ....
//  %cmp14 = icmp sgt i32 %5, %conv9
//  br i1 %cmp14, label %if.then, label %if.end
//if.then:
//  store i32 %conv9, i32* %arrayidx.i35, align 4, !tbaa !2
//  br label %if.end
//if.end:
//  .....
// After the pass:
//  ....
//  %0 = alloca i32
//  %cmp14 = icmp sgt i32 %5, %conv9
//  %new_addr = select i1 %cmp14, i32* %arrayidx.i35, i32* %0
//  store i32 %conv9, i32* %new_addr, align 4, !tbaa !2
//  br label %if.end
//if.end:
//  .....
//
// Limitations/TODOs
// =================
// - This transformation may be extended to more complex if-then-else constructs
// - Currently, this transform is limited to 'then' blocks with a single store
//   instruction. This can be extended

#include "llvm/Transforms/Scalar/Intel_ForcedCMOVGeneration.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/MapVector.h"
#include "llvm/ADT/PostOrderIterator.h"
#include "llvm/ADT/SetVector.h"
#include "llvm/ADT/SmallPtrSet.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/Analysis/GlobalsModRef.h"
#include "llvm/Analysis/Intel_Andersens.h"
#include "llvm/Analysis/Utils/Local.h"
#include "llvm/Analysis/ValueTracking.h"
#include "llvm/Analysis/BlockFrequencyInfo.h"
#include "llvm/Analysis/BranchProbabilityInfo.h"
#include "llvm/Analysis/ConstantFolding.h"
#include "llvm/Analysis/InstructionSimplify.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Analysis/MemoryBuiltins.h"
#include "llvm/Analysis/MemorySSA.h"
#include "llvm/Analysis/MemorySSAUpdater.h"
#include "llvm/Analysis/ProfileSummaryInfo.h"
#include "llvm/IR/Argument.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constant.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Operator.h"
#include "llvm/IR/PassManager.h"
#include "llvm/IR/PatternMatch.h"
#include "llvm/IR/ProfDataUtils.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/User.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/ValueHandle.h"
#include "llvm/IR/Verifier.h"
#include "llvm/InitializePasses.h"
#include "llvm/Pass.h"
#include "llvm/Support/BranchProbability.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Transforms/Scalar.h"
#include <algorithm>
#include <cassert>
#include <utility>

using namespace llvm;
using namespace intel_forcedcmovgen;

#define DEBUG_TYPE "forced-cmov-generation"

STATISTIC(NumOfCmovsGenerated, "Number of CMOVs generated by early IR pass");

static cl::opt<bool>
    ForcedCMOVGenerationEnable("forced-cmov-generation-enable", cl::init(true),
                        cl::Hidden, cl::desc("Enable forced CMOV generation."));

// This option is equivalent to min-predictable-branch option
// Although this default value is arbitrary, it is not random. It is assumed
// that a condition that evaluates the same way by a higher percentage than this
// is best represented as control flow. Therefore, the default value N should be
// set such that the win from N% correct executions is greater than the loss
// from (100 - N)% mispredicted executions for the majority of intended targets.
// Here, N is the percentage of times as condition is either true or false
// (not unknown)
static cl::opt<int> MaxBranchPredictionPercentageForCMOV(
    "max-branch-pred-percentage", cl::init(99),
    cl::desc("Maximum percentage (0-100) that a condition must be either true "
             "or false for CMOV to be useful"),
    cl::Hidden);

// Only scalar stores are supported
// Currently, this optimization is limited to if-then constructs with a single
// store inside the 'then' block.
// Also, the store needs to be of the form A[B[i]] =x.
bool ForcedCMOVGeneration::HasSingleStore(BasicBlock *B) {
  if (B->sizeWithoutDebug() == 2 &&
      isa<StoreInst>(&*(B->instructionsWithoutDebug().begin())) &&
      B->getSingleSuccessor() &&
      !(dyn_cast<StoreInst>(&*(B->instructionsWithoutDebug().begin()))
                            ->getValueOperand()->getType()->isVectorTy())) {
    StoreInst *SI = dyn_cast<StoreInst>(&*(B->instructionsWithoutDebug().begin()));
    GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(SI->getPointerOperand()); 
    if (GEPI == nullptr || !(GEPI->hasIndices())) return false;
    // Get the last index
    Value *Index = GEPI->getOperand(GEPI->getNumIndices());
    if (isa<LoadInst>(Index)) return true;
    ZExtInst *Inst = dyn_cast<ZExtInst>(Index);
    return (Inst != nullptr) && (isa<LoadInst>(Inst->getOperand(0)));               
  }
  return false;
}

// Heuristics used here is the same as the one used in
// isFormingBranchFromSelectProfitable which is found in CodeGenPrepare.cpp
// This function is greedy and returns 'true' if profile data is not available.
// If profile information is available, we perform additional checks to
// determine if CMOV is profitable.
// However, the additional checks are also greedy and the function returns true
// in 99% of the cases
// Further tuning is warranted
bool ForcedCMOVGeneration::IsProfitableForCMOV(BasicBlock *Entry) {
  BranchInst *BI = dyn_cast<BranchInst>(Entry->getTerminator());
  if (BI == nullptr)
    return false;
  uint64_t TrueWeight, FalseWeight;
  if (extractBranchWeights(*BI, TrueWeight, FalseWeight)) {
    LLVM_DEBUG(dbgs() << "Metadata is available\n");
    LLVM_DEBUG(dbgs() << "TrueWeight = " << TrueWeight << " and FalseWeight =  " << FalseWeight << "\n");
    uint64_t Max = std::max(TrueWeight, FalseWeight);
    uint64_t Sum = TrueWeight + FalseWeight;
    if (Sum != 0) {
      auto Probability = BranchProbability::getBranchProbability(Max, Sum);
      BranchProbability BranchProbThres
        = BranchProbability(MaxBranchPredictionPercentageForCMOV, 100);
      if (Probability < BranchProbThres) {
        LLVM_DEBUG(dbgs() << "Probability is below threshold\n");
        return true;
      } else {
        LLVM_DEBUG(dbgs() << "Probability is above threshold\n");
        return false;
      }
    }
  }
  LLVM_DEBUG(dbgs() << "Metadata is not available\n");
  return true;
}

bool ForcedCMOVGeneration::IsACandidateBasicBlock(BasicBlock &B,
                                                  IfThenConstruct &Construct) {
  LLVM_DEBUG(dbgs() << "IsACandidateBasicBlock to BB = " << B.getName() << "\n");
  BranchInst *BI = dyn_cast<BranchInst>(B.getTerminator());
  if (BI == nullptr)
    return false;

  if (BI->getNumSuccessors() != 2)
    return false;

  BasicBlock &Succ0 = *BI->getSuccessor(0);
  BasicBlock &Succ1 = *BI->getSuccessor(1);

  if (&B == &Succ0 || &B == &Succ1 || &Succ0 == &Succ1) {
    return false;
  }
  BasicBlock *CandidateBB = nullptr;
  BasicBlock *MergeBB = nullptr;
  bool ThenIsTrue;
  // if-then (triangle).
  if (Succ0.getSinglePredecessor() != nullptr &&
      Succ0.getSingleSuccessor() == &Succ1) {
    CandidateBB = &Succ0;
    MergeBB = &Succ1;
    ThenIsTrue = true;
  }
  // if-else (triangle).
  if (Succ1.getSinglePredecessor() != nullptr &&
      Succ1.getSingleSuccessor() == &Succ0) {
    CandidateBB = &Succ1;
    MergeBB = &Succ0;
    ThenIsTrue = false;
  }
  if (CandidateBB == nullptr)
    return false;
  // Verify that B and CandidateBB do not send different values to MergeBB
  // via PHIs
  if (MergeBB != nullptr)
    for (PHINode &PN : MergeBB->phis())
      if (PN.getIncomingValueForBlock(&B) != PN.getIncomingValueForBlock(CandidateBB))
        return false;
  Construct.ThenBlock = CandidateBB;
  Construct.EndBlock = MergeBB;
  Construct.ThenIsTrue = ThenIsTrue;
  return (HasSingleStore(CandidateBB) && IsProfitableForCMOV(&B));
}

void ForcedCMOVGeneration::AddSelectInst(BasicBlock &B,
                                         IfThenConstruct &Construct) {
  LLVM_DEBUG(dbgs() << "AddSelectInst to BB = " << B.getName() << "\n");
  BranchInst *BI = dyn_cast<BranchInst>(B.getTerminator());
  // Create dummy variable on stack
  // add select instruction to select between address in store of ThenBlock and
  // the dummy variable
  // Replace addr in this store inst with output of select and move it to end of
  // Header Block
  // Delete ThenBlock
  bool ThenIsTrue = Construct.ThenIsTrue;
  llvm::IRBuilder<> Builder(&B);
  Builder.SetInsertPoint(BI);
  auto I = Construct.ThenBlock->instructionsWithoutDebug().begin();
  Instruction *Inst = &*I;
  StoreInst *SI = dyn_cast<StoreInst>(Inst);
  assert(SI != nullptr);
  Type *Ty = SI->getValueOperand()->getType();
  AllocaInst *Dummy = new AllocaInst(Ty, SI->getPointerAddressSpace(), "",
                                     F.getEntryBlock().getFirstNonPHI());
  Value *SelectInst = Builder.CreateSelect(BI->getCondition(),
                              (ThenIsTrue) ? SI->getPointerOperand() : Dummy,
                              (ThenIsTrue) ? Dummy : SI->getPointerOperand(),
                              "",
                              BI);
  SI->setOperand(SI->getPointerOperandIndex(), SelectInst);
  Instruction *CopySI = SI->clone();
  Builder.Insert(CopySI);
  Builder.CreateBr(Construct.EndBlock);
  BI->eraseFromParent();
  Construct.EndBlock->removePredecessor(Construct.ThenBlock);
  Construct.ThenBlock->eraseFromParent();
  return;
}

// Entry point for forced CMOV generation.
// Returns true if we need to invalidate analysis.
bool ForcedCMOVGeneration::run() {
  bool Changed = false;

  if (!ForcedCMOVGenerationEnable)
    return false;
  LLVM_DEBUG(dbgs() << "Before:\n"; F.dump());
  for (auto& B : F) {
    IfThenConstruct Construct;
    if (IsACandidateBasicBlock(B, Construct)) {
      LLVM_DEBUG(dbgs() << "Entry to valid if-then BB = " << B.getName() << "\n");
      AddSelectInst(B, Construct);
      ++NumOfCmovsGenerated;
      Changed = true;
    }
  }
  LLVM_DEBUG(dbgs() << "After:\n"; F.dump());
  return Changed;
}

bool ForcedCMOVGenerationPass::runImpl(Function &F) {
  return ForcedCMOVGeneration(F).run();
}

PreservedAnalyses ForcedCMOVGenerationPass::run(Function &F,
                                                FunctionAnalysisManager &AM) {
  bool Changed = runImpl(F);
  if (Changed) {
    return PreservedAnalyses::none();
  }
  return PreservedAnalyses::all();
}

char ForcedCMOVGenerationLegacyPass::ID = 0;

ForcedCMOVGenerationLegacyPass::ForcedCMOVGenerationLegacyPass() : FunctionPass(ID) {
  initializeForcedCMOVGenerationLegacyPassPass(*PassRegistry::getPassRegistry());
}

bool ForcedCMOVGenerationLegacyPass::runOnFunction(Function &F) {
  return Impl.runImpl(F);
}

INITIALIZE_PASS(ForcedCMOVGenerationLegacyPass, "forced-cmov-generation",
                      "Forced CMOV generation", false, false)

// Public interface to the pass
FunctionPass *llvm::createForcedCMOVGenerationPass() {
  return new ForcedCMOVGenerationLegacyPass();
}

