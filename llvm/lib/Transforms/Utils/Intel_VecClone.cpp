//=---- Intel_VecClone.cpp - Vector function to loop transform -*- C++ -*----=//
//
// Copyright (C) 2015-2022 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive property
// of Intel Corporation and may not be disclosed, examined or reproduced in
// whole or in part without explicit written authorization from the company.
//
// Main author:
// ------------
// Matt Masten (C) 2017 [matt.masten@intel.com]
//
// Major revisions:
// ----------------
// May 2015, initial development -- Matt Masten
//
// ===--------------------------------------------------------------------=== //
///
/// \file
/// This pass inserts the body of a vector function inside a vector length
/// trip count scalar loop for functions that are declared SIMD. The pass
/// follows the Intel vector ABI requirements for name mangling encodings.
///
/// Conceptually, this pass performs the following transformation:
///
/// Before Translation:
///
/// main.cpp
///
/// #pragma omp declare simd uniform(a) linear(k)
///
/// extern float dowork(float *a, int k);
///
/// float a[4096];
/// int main() {
///   int k;
/// #pragma clang loop vectorize(enable)
///   for (k = 0; k < 4096; k++) {
///     a[k] = k * 0.5;
///     a[k] = dowork(a, k);
///   }
/// }
///
/// dowork.cpp
///
/// #pragma omp declare simd uniform(a) linear(k) #0
/// float dowork(float *a, int k) {
///   a[k] = sinf(a[k]) + 9.8f;
/// }
///
/// attributes #0 = { nounwind uwtable "_ZGVbM4ul_", "ZGVbN4ul_", ... }
///
/// After Translation:
///
/// dowork.cpp
///
/// // Non-masked variant
///
/// <VL x float> "_ZGVbN4ul_dowork(float *a, int k) {
///   alloc <VL x float> vec_ret;
///   for (int i = k; i < k + VL, i++) {
///     a[i] = sinf(a[i]) + 9.8f;
///   }
///   load vec_ret, a[k:VL]
///   return vec_ret;
/// }
///
/// // Masked variant
///
/// <VL x float> "_ZGVbM4ul_dowork(float *a, int k, <VL x int> mask) {
///   alloc <VL x float> vec_ret;
///   for (int i = k; i < k + VL, i++) {
///     if (mask[i] != 0)
///       a[i] = sinf(a[i]) + 9.8f;
///   }
///   load vec_ret, a[k:VL]
///   return vec_ret;
/// }
///
///
///
// ===--------------------------------------------------------------------=== //

// This pass is flexible enough to deal with two forms of LLVM IR, namely when
// Mem2Reg has run and when Mem2Reg has not run.
//
// When Mem2Reg has run:
//
// define i32 @foo(i32 %i, i32 %x) #0 {
// entry:
//   %add = add nsw i32 %x, %i
//   ret i32 %add
// }
//
// When Mem2Reg has not run:
//
// define i32 @foo(i32 %i, i32 %x) #0 {
// entry:
// %i.addr = alloca i32, align 4
// %x.addr = alloca i32, align 4
// store i32 %i, i32* %i.addr, align 4
// store i32 %x, i32* %x.addr, align 4
// %0 = load i32, i32* %x.addr, align 4
// %1 = load i32, i32* %i.addr, align 4
// %add = add nsw i32 %0, %1
//  ret i32 %add
// }
//
// Both forms are handled the same by always generating new allocas for
// vector arguments and updating users via def-use chain. This keeps the
// implementation straightfoward for all inputs.
//
// The function "insertDirectiveIntrinsics" creates a WRN region around the
// for-loop. VPlan works on this region. The beginning of the WRN region is
// marked with @llvm.directive.region.entry() and the end with
// @llvm.directive.region.end(). In the above example, a new basic-block is
// created before loop's header:
//
// simd.begin.region:                                ; preds = %entry
// %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(),
// "QUAL.OMP.UNIFORM"(float* %a), "QUAL.OMP.LINEAR"(i32 %k, i32 1),
// "QUAL.OMP.SIMDLEN"(i32 4) ]
//     br label %simd.loop.header
//
// and a new basic-block is emitted after loop's latch:
//
// simd.loop.latch:                            ; preds = %simd.loop.header
// %indvar = add nuw i32 %index, 1
// %vl.cond = icmp ult i32 %indvar, 4
// br i1 %vl.cond, label %simd.loop.header, label %simd.end.region
//
// The pass must run at all optimization levels because it is possible that
// a loop calling the vector function is vectorized, but the vector function
// itself is not vectorized. For example, above main.cpp may be compiled at
// -O2, but dowork.cpp may be compiled at -O0. Therefore, it is required that
// the attribute list for the vector function specify all variants that must
// be generated by this pass so as to avoid any linking problems. This pass
// also serves to canonicalize the input IR to the loop vectorizer.

#include "llvm/Transforms/Utils/Intel_VecClone.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Analysis/Directives.h"
#include "llvm/Analysis/GlobalsModRef.h"
#include "llvm/Analysis/Intel_Andersens.h"
#include "llvm/Analysis/Passes.h"
#include "llvm/Analysis/VectorUtils.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/InitializePasses.h"
#include "llvm/PassRegistry.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/Transforms/Utils/GeneralUtils.h"
#include "llvm/Transforms/Utils/IntrinsicUtils.h"
#include <map>
#include <set>
#include <string>

#include "llvm/IR/Verifier.h"

#define SV_NAME "vec-clone"
#define DEBUG_TYPE "VecClone"

using namespace llvm;

extern bool Usei1MaskForSimdFunctions;

// Support for future opaque pointers. Will become the only option in future.
static cl::opt<bool>
    EmitTypedOMP("vec-clone-typed-omp", cl::init(false), cl::Hidden,
                 cl::desc("Emit 'TYPED' version of OMP clauses."));

VecClone::VecClone() : ModulePass(ID) {
  initializeVecClonePass(*PassRegistry::getPassRegistry());
}

bool VecClone::runOnModule(Module &M) {
  auto &OROP = getAnalysis<OptReportOptionsPass>();
  ORBuilder.setup(M.getContext(), OROP.getVerbosity());
  return Impl.runImpl(M, &ORBuilder, getLimiter());
}

#if INTEL_CUSTOMIZATION
// The following two functions are virtual and they are overloaded when
// VecClone is called by language-specific optimizations. Their default
// implementation is empty.
void VecCloneImpl::handleLanguageSpecifics(Function &F, PHINode *Phi,
                                       Function *Clone,
                                       BasicBlock *EntryBlock,
                                       const VFInfo &Variant) {}

void VecCloneImpl::languageSpecificInitializations(Module &M) {}
#endif // INTEL_CUSTOMIZATION

Function *VecCloneImpl::CloneFunction(Function &F, const VFInfo &V,
                                      ValueToValueMapTy &VMap) {

  LLVM_DEBUG(dbgs() << "Cloning Function: " << F.getName() << "\n");
  LLVM_DEBUG(F.dump());

  FunctionType* OrigFunctionType = F.getFunctionType();
  Type *CharacteristicType = calcCharacteristicType(F, V);

  const auto *VKIt = V.getParameters().begin();
  SmallVector<Type*, 4> ParmTypes;
  for (auto ParmIt = OrigFunctionType->param_begin(),
            ParmEnd = OrigFunctionType->param_end();
       ParmIt != ParmEnd; ++ParmIt, ++VKIt) {
    Type *ParmType = *ParmIt;
    if (VKIt->isVector()) {
      if (ParmType->isIntOrIntVectorTy(1)) {
        // Promote an `i1` or `<N x i1>` argument to `i8` or `<N x i8>` to
        // avoid a GEP into `<VF x i1>` when accessing elements.
        ParmType = ParmType->getWithNewBitWidth(8);
      }
      unsigned VF = V.getVF();
      if (auto *FVT = dyn_cast<FixedVectorType>(ParmType))
        VF *= FVT->getNumElements();
      ParmTypes.push_back(FixedVectorType::get(ParmType->getScalarType(), VF));
    } else {
      ParmTypes.push_back(*ParmIt);
    }
  }

  if (V.isMasked()) {
    Type *MaskScalarTy = (Usei1MaskForSimdFunctions) ?
      Type::getInt1Ty(F.getContext()) : CharacteristicType;
    Type *MaskVecTy = FixedVectorType::get(MaskScalarTy, V.getVF());
    ParmTypes.push_back(MaskVecTy);
  }

  Function* Clone = getOrInsertVectorVariantFunction(&F, V.getVF(), ParmTypes,
                                                     &V, V.isMasked());

  // Remove vector variant attributes from the original function. They are
  // not needed for the cloned function and it prevents any attempts at
  // trying to clone the function again in case the pass is called more than
  // once.
  AttributeMask AB;
  for (auto Attr : getVectorVariantAttributes(F)) {
    AB.addAttribute(Attr);
  }

  F.removeFnAttrs(AB);

  // Copy all the attributes from the scalar function to its vector version
  // except for the vector variant attributes.
  Clone->copyAttributesFrom(&F);

  // Remove incompatible argument attributes (applied to the scalar argument,
  // does not apply to its vector counterpart).
  Function::arg_iterator ArgIt = Clone->arg_begin();
  Function::arg_iterator ArgEnd = Clone->arg_end();
  // TODO (Dave Kreitzer): Once we pull down the changes that add the
  //   Function::removeParamAttrs method, we should use it in lieu of
  //   Function::removeAttributes. We just need to change the Idx
  //   initialization here to start at 0.
  for (uint64_t Idx = 1; ArgIt != ArgEnd; ++ArgIt, ++Idx) {
    Type* ArgType = (*ArgIt).getType();
    Clone->removeFnAttrs(AttributeFuncs::typeIncompatible(ArgType));
  }

  Function::arg_iterator NewArgIt = Clone->arg_begin();
  for (Argument &Arg : F.args()) {
    NewArgIt->setName(Arg.getName());
    VMap[&Arg] = &*NewArgIt;
    ++NewArgIt;
  }

  if (V.isMasked()) {
    Argument &MaskArg = *NewArgIt;
    MaskArg.setName("mask");
  }

  SmallVector<ReturnInst*, 8> Returns;
  CloneFunctionInto(Clone, &F, VMap, CloneFunctionChangeType::LocalChangesOnly,
                    Returns);
  // For some reason, this causes DCE to remove calls to these functions.
  // Disable for now.
  //Clone->setCallingConv(CallingConv::X86_RegCall);

  LLVM_DEBUG(dbgs() << "After Cloning and Parameter/Return Expansion\n");
  LLVM_DEBUG(Clone->dump());

  return Clone;
}

BasicBlock *VecCloneImpl::splitEntryIntoLoop(Function *Clone, const VFInfo &V,
                                             BasicBlock *EntryBlock) {

  SmallVector<Instruction *, 4> EntryInsts;
  for (auto BBIt = EntryBlock->begin(), BBEnd = EntryBlock->end();
       BBIt != BBEnd; ++BBIt) {
    if (auto Alloca = dyn_cast<AllocaInst>(BBIt)) {
      EntryInsts.push_back(Alloca);
      // Add alloca to SIMD loop private
      PrivateMemory.insert(Alloca);
    }
  }

  BasicBlock *LoopHeader =
      EntryBlock->splitBasicBlock(EntryBlock->begin(), "simd.loop.header");

  for (auto *Inst : EntryInsts) {
    Inst->removeFromParent();
    Inst->insertBefore(EntryBlock->getTerminator());
  }

  LLVM_DEBUG(dbgs() << "After Entry Block Split\n");
  LLVM_DEBUG(Clone->dump());

  return LoopHeader;
}

BasicBlock *VecCloneImpl::splitLoopIntoReturn(Function *Clone,
                                              BasicBlock *LoopHeader) {
  assert(count_if(*Clone,
                  [](const BasicBlock &BB) {
                    return isa<ReturnInst>(BB.getTerminator());
                  }) <= 1 &&
         "Unsupported CFG for VecClone!");

  auto RetBlockIt = find_if(*Clone, [](const BasicBlock &BB) {
    return isa<ReturnInst>(BB.getTerminator());
                                    });
  if (RetBlockIt == Clone->end())
    return nullptr;

  BasicBlock &RetBlock = *RetBlockIt;
  auto *Return = cast<ReturnInst>(RetBlock.getTerminator());
  return RetBlock.splitBasicBlock(Return, "return");
}

PHINode *VecCloneImpl::createPhiAndBackedgeForLoop(
    Function *Clone, BasicBlock *LoopPreHeader, BasicBlock *LoopHeader,
    BasicBlock *LoopLatch, BasicBlock *ReturnBlock, int VectorLength) {
  // Create the phi node for the top of the loop header and add the back
  // edge to the loop from the loop latch.

  PHINode *Phi = PHINode::Create(Type::getInt32Ty(Clone->getContext()), 2,
                                 "index", &*LoopHeader->getFirstInsertionPt());

  Constant *Inc = ConstantInt::get(Type::getInt32Ty(Clone->getContext()), 1);
  Constant *IndInit = ConstantInt::get(Type::getInt32Ty(Clone->getContext()),
                                       0);

  Instruction *Induction = BinaryOperator::CreateNUWAdd(Phi, Inc, "indvar",
                                                        LoopLatch);

  Constant *VL = ConstantInt::get(Type::getInt32Ty(Clone->getContext()),
                                  VectorLength);

  Instruction *VLCmp = new ICmpInst(*LoopLatch, CmpInst::ICMP_ULT,
                                    Induction, VL, "vl.cond");

  BranchInst::Create(LoopHeader, ReturnBlock, VLCmp, LoopLatch);

  Phi->addIncoming(IndInit, LoopPreHeader);
  Phi->addIncoming(Induction, LoopLatch);

  LLVM_DEBUG(dbgs() << "After Loop Insertion\n");
  LLVM_DEBUG(Clone->dump());

  return Phi;
}

void VecCloneImpl::updateVectorArgumentUses(
    Function *Clone, Function &OrigFn, const DataLayout &DL, Argument *Arg,
    Type *ElemType, BitCastInst *VecArgCast, BasicBlock *EntryBlock,
    BasicBlock *LoopLatch, PHINode *Phi) {

  // This code updates argument users with a gep/load of an element for a
  // specific lane using the loop index.
  for (auto &U:  make_early_inc_range(Arg->uses())) {
    auto *User = cast<Instruction>(U.getUser());

    // Don't update any users in the entry block; e.g., the store of the
    // vector argument to the widened alloca.
    if (User->getParent() == EntryBlock)
      continue;

    // If arg is returned, make sure gep and load appear in the loop.
    Instruction *InsertPt = isa<ReturnInst>(User) ?
        LoopLatch->getFirstNonPHI() : User;

    GetElementPtrInst *VecGep = nullptr;
    if (!isa<PHINode>(User))
      VecGep = GetElementPtrInst::Create(
          ElemType, VecArgCast, Phi, VecArgCast->getName() + ".gep", InsertPt);

    // Otherwise, we need to load the value from the gep first before
    // using it. This effectively loads the particular element from
    // the vector argument.
    if (PHINode *PHIUser = dyn_cast<PHINode>(User)) {
      BasicBlock *IncommingBB = PHIUser->getIncomingBlock(U.getOperandNo());
      VecGep = GetElementPtrInst::Create(
          ElemType, VecArgCast, Phi, VecArgCast->getName() + ".gep",
          IncommingBB->getTerminator());
    }
    assert(VecGep && "Expect VecGep to be a non-null value.");
    Type *LoadTy = VecGep->getResultElementType();
    LoadInst *ArgElemLoad = new LoadInst(
        LoadTy, VecGep, "vec." + Arg->getName() + ".elem", false /*volatile*/,
        Clone->getParent()->getDataLayout().getABITypeAlign(LoadTy));
    ArgElemLoad->insertAfter(VecGep);

    Value *ArgValue = ArgElemLoad;
    Type *OrigArgTy = OrigFn.getArg(Arg->getArgNo())->getType();
    if (OrigArgTy->isIntOrIntVectorTy(1)) {
      // If the original arg type was `i1` or `<N x i1>`, we need truncate the
      // value back to its original type after loads.
      assert(ElemType->isIntOrIntVectorTy(8) &&
             "expected element type to be promoted to i8 from i1");
      TruncInst *TruncatedLoad = new TruncInst(
          ArgElemLoad, OrigArgTy, ArgElemLoad->getName() + ".trunc");
      TruncatedLoad->insertAfter(ArgElemLoad);
      ArgValue = TruncatedLoad;
    }

    // If the user happens to be a return instruction, then the operand
    // of the return is replaced with the load also. This doesn't matter
    // because this instruction is later replaced with the return vector
    // in updateReturnBlockInstructions().
    User->setOperand(U.getOperandNo(), ArgValue);
  }
}

Instruction *VecCloneImpl::widenVectorArguments(
    Function *Clone, Function &OrigFn, const VFInfo &V, BasicBlock *EntryBlock,
    BasicBlock *LoopHeader, PHINode *Phi, ValueToValueMapTy &VMap,
    AllocaInst *&LastAlloca) {

  // Create a completely new VF-widened alloca for each vector argument. Then,
  // bitcast the vector and store the argument and the bitcast in a map. The map
  // is later used to insert the gep/load and to replace the old scalar argument
  // references. If there are no arguments, then the function simply does not
  // perform any expansion since we iterate over the function's arg list.

  const DataLayout &DL = Clone->getParent()->getDataLayout();
  Instruction *Mask = nullptr;
  ArrayRef<VFParameter> Parms = V.getParameters();

  for (auto ArgIt : enumerate(Clone->args())) {
    Argument *Arg = &ArgIt.value();

    VFParameter Parm = Parms[ArgIt.index()];

    // If the original parameter isn't vector, we should not widen it.
    if (!Parm.isVector())
      continue;

    // This function is run after the arguments have been already widened!
    VectorType *VecType = cast<VectorType>(Arg->getType());

    // Some args other than the mask may not have users, but have not been
    // removed as dead. In those cases, just go on to the next argument.
    // There's no need to widen non-mask arguments with no users.
    bool MaskArg = Parm.isMask();
    if (!MaskArg && Arg->getNumUses() == 0)
      continue;

    // Create a new vector alloca and bitcast to a pointer to the element
    // type. The following is an example of what the cast should look like:
    //
    // %veccast = bitcast <2 x i32>* %vec_a.addr to i32*
    //
    // geps using the bitcast will appear in a scalar form instead of
    // casting to an array or using vector. For example,
    //
    // %vecgep1 = getelementptr i32, i32* %veccast, i32 %index
    //
    // instead of:
    //
    // getelementptr inbounds [4 x i32], [4 x i32]* %a, i32 0, i64 1
    //
    // We do this to put the geps in a scalar form that can be indexed
    // using the loop index.

    AllocaInst *VecAlloca =
        new AllocaInst(VecType, DL.getAllocaAddrSpace(), nullptr,
                       DL.getPrefTypeAlign(VecType), "vec." + Arg->getName());
    if (LastAlloca)
      VecAlloca->insertAfter(LastAlloca);
    else
      VecAlloca->insertBefore(&EntryBlock->front());
    LastAlloca = VecAlloca;

    Type *OrigArgTy = nullptr;
    for (const auto &Pair : VMap)
      if (Pair.second == Arg)
        OrigArgTy = Pair.first->getType();

    Type *ElemType = nullptr;
    if (!OrigArgTy) {
      // If the argument is a mask, it does not exist in VMap.
      ElemType = VecType->getElementType();
    } else if (OrigArgTy->isIntOrIntVectorTy(1)) {
      // If the original argument type was `i1`, then we promoted it to an
      // `i8`. Use `i8` as the element type instead, to avoid a GEP into a
      // `<VF x i1>` when updating the argument's uses.
      assert(VecType->getElementType()->isIntegerTy(8) &&
             "expected element type to be promoted to i8 from i1");
      ElemType = OrigArgTy->getWithNewBitWidth(8);
    } else {
      ElemType = OrigArgTy;
    }

    PointerType *ElemTypePtr =
        PointerType::get(ElemType, VecAlloca->getType()->getAddressSpace());

    BitCastInst *VecArgCast = nullptr;
    if (MaskArg) {
      Mask = new BitCastInst(VecAlloca, ElemTypePtr, "mask.cast");
      // Mask points to the bitcast of the alloca instruction to element type
      // pointer. Insert the bitcast after all of the other bitcasts for vector
      // arguments.
      Mask->insertBefore(EntryBlock->getTerminator());
    } else {
      VecArgCast = new BitCastInst(VecAlloca, ElemTypePtr,
                                   "vec." + Arg->getName() + ".cast");
      VecArgCast->insertBefore(EntryBlock->getTerminator());
    }

    if (Mask)
      return Mask;

    // Store the vector argument into the new VF-widened alloca.
    Value *ArgValue = cast<Value>(Arg);
    StoreInst *Store = new StoreInst(ArgValue, VecAlloca, false /*volatile*/,
                                     DL.getABITypeAlign(ArgValue->getType()));
    Store->insertBefore(EntryBlock->getTerminator());

    updateVectorArgumentUses(Clone, OrigFn, DL, Arg, ElemType, VecArgCast,
                             EntryBlock, LoopHeader, Phi);
  }

  return nullptr;
}

Instruction *VecCloneImpl::createWidenedReturn(Function *Clone,
                                               BasicBlock *EntryBlock,
                                               Type *OrigFuncReturnType,
                                               AllocaInst *&LastAlloca) {
  // Expand the return temp to a vector. Also create the bitcast to
  // scalar element type ptr so that it can be used to reference
  // individual elements in the loop using loop index.

  VectorType *AllocaType = cast<VectorType>(Clone->getReturnType());

  const DataLayout &DL = Clone->getParent()->getDataLayout();
  AllocaInst *VecAlloca =
      new AllocaInst(AllocaType, DL.getAllocaAddrSpace(), nullptr,
                     DL.getPrefTypeAlign(AllocaType), "vec.retval");
  if (LastAlloca)
    VecAlloca->insertAfter(LastAlloca);
  else
    VecAlloca->insertBefore(&EntryBlock->front());
  LastAlloca = VecAlloca;

  auto *ElemTypePtr =
      PointerType::get(OrigFuncReturnType,
                       VecAlloca->getType()->getAddressSpace());

  BitCastInst *VecCast = new BitCastInst(VecAlloca, ElemTypePtr, "ret.cast");
  VecCast->insertBefore(EntryBlock->getTerminator());

  return VecCast;
}

Instruction *VecCloneImpl::widenReturn(Function *Clone, Function &F,
                                       BasicBlock *EntryBlock,
                                       BasicBlock *LoopHeader,
                                       BasicBlock *ReturnBlock,
                                       PHINode* Phi,
                                       AllocaInst *&LastAlloca) {

  const DataLayout &DL = Clone->getParent()->getDataLayout();
  ReturnInst *FuncReturn = dyn_cast<ReturnInst>(ReturnBlock->getTerminator());
  assert(FuncReturn && "Expected ret instruction to terminate the return\
                        basic block");
  Value *ValToStore = FuncReturn->getOperand(0);
  Type *RetTy = F.getReturnType();
  // GEPs into vectors of i1 do not make sense, so promote it to i8,
  // similar to later CodeGen processing.
  if (RetTy->isIntegerTy(1))
    RetTy = Type::getInt8Ty(RetTy->getContext());

  Instruction *InsertPt = dyn_cast<Instruction>(ValToStore);
  if (InsertPt) {
    InsertPt = InsertPt->getNextNode();
    // If InsertPt is a PHINode, move it to the last PHINode in the BB.
    while (isa<PHINode>(InsertPt))
      InsertPt = cast<Instruction>(InsertPt)->getNextNode();
  } else {
    // Could be returning a constant, so insert gep/store at end of the
    // LoopHeader.
    InsertPt = LoopHeader->getFirstNonPHI();
  }

  IRBuilder<> Builder(InsertPt);

  // If a conflict with the promoted type, extend.
  // TODO: write test that returns i1 argument directly. When we reach
  // here, the cast<Integer> will fail because the argument has already
  // been widened to vector. For now, check for IntegerType before
  // promoting return values.
  if (RetTy->isIntegerTy() && isa<IntegerType>(ValToStore->getType())) {
    IntegerType *ValToStoreTy = cast<IntegerType>(ValToStore->getType());
    if (RetTy != ValToStoreTy) {
      assert(ValToStoreTy->getBitWidth() <
             cast<IntegerType>(RetTy)->getBitWidth() &&
             "Expect the type to be promoted.");
      Value *ZExt = Builder.CreateZExt(ValToStore, RetTy,
                                       ValToStore->getName() + ".zext");
      ValToStore = ZExt;
    }
  }

  Instruction *VecReturn = createWidenedReturn(Clone, EntryBlock, RetTy,
                                               LastAlloca);
  Value *VecGep = Builder.CreateGEP(RetTy, VecReturn, Phi,
                                    VecReturn->getName() + ".gep");
  Builder.CreateAlignedStore(ValToStore, VecGep, DL.getABITypeAlign(RetTy),
                             false);
  return VecReturn;
}

Instruction *VecCloneImpl::widenVectorArgumentsAndReturn(
    Function *Clone, Function &F, const VFInfo &V, Instruction *&Mask,
    BasicBlock *EntryBlock, BasicBlock *LoopHeader, BasicBlock *ReturnBlock,
    PHINode *Phi, ValueToValueMapTy &VMap) {

  // The function arguments are processed from left to right. The corresponding
  // allocas should be emitted in a specific order: the alloca that corresponds
  // to the most left argument should be emitted at the top of the entry block.
  AllocaInst *LastAlloca = nullptr;

  // If there are no arguments, then this function will do nothing and this
  // is the expected behavior.
  Mask = widenVectorArguments(Clone, F, V, EntryBlock, LoopHeader, Phi,
                              VMap, LastAlloca);

  // If the function returns void, then don't attempt to widen to vector.
  Instruction *WidenedReturn = ReturnBlock->getTerminator();
  if (!Clone->getReturnType()->isVoidTy()) {
    WidenedReturn = widenReturn(Clone, F, EntryBlock, LoopHeader,
                                ReturnBlock, Phi, LastAlloca);
    assert(WidenedReturn && "The return value has not been widened.");
  }

  // Insert the mask argument store to alloca and bitcast if this is a masked
  // variant.
  if (Mask) {
    Value *MaskVector = Mask->getOperand(0);

    // MaskArg points to the function's mask argument.
    Function::arg_iterator MaskArg = Clone->arg_end();
    MaskArg--;

    // Copy the mask argument to an alloca and put it at the end of EntryBlock.
    StoreInst *MaskStore =
        new StoreInst(&*MaskArg, MaskVector, false /*volatile*/,
                      Clone->getParent()->getDataLayout().getABITypeAlign(
                          MaskArg->getType()));
    MaskStore->insertBefore(EntryBlock->getTerminator());
  }

  LLVM_DEBUG(dbgs() << "After Parameter/Return Expansion\n");
  LLVM_DEBUG(Clone->dump());

  return WidenedReturn;
}

Value *VecCloneImpl::generateStrideForArgument(Function *Clone, Value *Arg,
                                               Instruction *ArgUser,
                                               Value *Stride, PHINode *Phi) {
  // For linear values, a mul + add/gep sequence is needed to generate the
  // correct value. i.e., val = linear_var + stride * loop_index;

  // Insert the stride related instructions before the user.
  IRBuilder<> Builder(ArgUser);

  if (auto *ArgTy = dyn_cast<PointerType>(Arg->getType())) {
    // For pointer types the stride is specified in bytes!
    if (!ArgTy->isOpaque()) {
      // Try to make compute nicely looking without byte arithmetic. Purely for
      // aesthetic purposes.
      auto *Mul = Builder.CreateMul(Stride, Phi, "stride.mul");
      assert(Stride->getType() == Phi->getType() &&
             "Type of stride and loop index are different");

      // Linear updates to pointer arguments involves an address calculation,
      // so use gep. To properly update linear pointers we only need to
      // multiply the loop index and stride since gep is indexed starting at 0
      // from the base address passed to the vector function.

      // Mul is always generated as i32 since it is calculated using the i32
      // loop phi that is inserted by this pass. No cast on Mul is necessary
      // because gep can use a base address of one type with an index of
      // another type.
      Value *LinearArgGep = Builder.CreateGEP(
          ArgTy->getPointerElementType(), Arg, Mul, Arg->getName() + ".gep");

      return LinearArgGep;
    }
    auto *Mul = Builder.CreateMul(Stride, Phi, "stride.mul");
    auto *Gep = Builder.CreateGEP(Builder.getInt8Ty(), Arg, Mul,
                                  Arg->getName() + ".gep");
    return Gep;
  }

  // If Stride is a constant, then it has already been typed appropriately in
  // processLinearArgs when creating the constant value. However, if Stride is
  // in a variable then it may need to be cast to the arg type. The decision to
  // cast here is done because IRBuilder is needed for correct insertion.
  Value *StrideCast = Stride;
  if (Stride->getType() != Arg->getType()) {
    StrideCast = Builder.CreateCast(
        CastInst::getCastOpcode(Stride, false /* SrcIsSigned */, Arg->getType(),
                                false /* DestIsSigned */),
        Stride, Arg->getType(), "stride.cast");
  }

  // Cast the loop index to match the stride type for the multiply part of the
  // stride calculation. Integer stride is calculated as:
  // arg + loop idx * stride.
  Value *PhiCast = Phi;
  if (StrideCast->getType() != Phi->getType()) {
    PhiCast = Builder.CreateCast(
        CastInst::getCastOpcode(Phi, false /* SrcIsSigned */,
                                StrideCast->getType(),
                                false /* DestIsSigned */),
        Phi, StrideCast->getType(), "phi.cast");
  }

  Value *Mul =
      Builder.CreateMul(StrideCast, PhiCast, "stride.mul");

  // Floating point strides are not allowed.
  assert(!Arg->getType()->isFloatingPointTy() &&
         "The value should not be floating point!");
  // At this point, the loop index, stride, and arg types should match.
  auto Add = Builder.CreateAdd(Arg, Mul, "stride.add");
  return Add;
}

// Emits store and load of \p ArgValue and replaces all uses of \p ArgValue with
// the load.
static LoadInst* emitLoadStoreForParameter(AllocaInst *Alloca, Value *ArgValue,
                                           BasicBlock *LoopPreHeader) {
  // Emit the load in the simd.loop.preheader block.
  IRBuilder<> Builder(&*LoopPreHeader->begin());
  LoadInst *Load = Builder.CreateLoad(Alloca->getAllocatedType(), Alloca,
                                      "load." + ArgValue->getName());
  ArgValue->replaceAllUsesWith(Load);
  // After updating the uses of the function argument with its stack variable,
  // we emit the store.
  Builder.SetInsertPoint(Alloca->getNextNode());
  Builder.CreateStore(ArgValue, Alloca);

  return Load;
}

// Create an alloca for args where memory is not already on the stack.
// This is done regardless of whether there is an existing alloca for
// the argument. In those cases we still create a new alloca that will
// be marked appropriately (e.g., linear, uniform) and the old alloca
// can be marked as private because loads/stores using it will be in
// the loop. This approach helps simplify the implementation because
// we don't have to distinguish between opt levels.
static void getOrCreateArgMemory(Argument &Arg, BasicBlock *EntryBlock,
                                 BasicBlock *LoopPreHeader, Value* &ArgVal,
                                 Value* &ArgMemory) {
  ArgVal = &Arg;
  ArgMemory = &Arg;
  // TODO:  Should it be !hasPointeeInMemoryValueAttr() instead?
  if (!Arg.hasByValAttr()) {
    IRBuilder<> Builder(&*EntryBlock->begin());
    AllocaInst *ArgAlloca = Builder.CreateAlloca(Arg.getType(), nullptr,
                                                 "alloca." + Arg.getName());
    ArgVal = emitLoadStoreForParameter(cast<AllocaInst>(ArgAlloca), ArgVal,
                                       LoopPreHeader);
    ArgMemory = ArgAlloca;
  }
}

void VecCloneImpl::processUniformArgs(Function *Clone, const VFInfo &V,
                                      BasicBlock *EntryBlock,
                                      BasicBlock *LoopPreHeader) {
  ArrayRef<VFParameter> Parms = V.getParameters();
  for (Argument &Arg : Clone->args()) {
    if (Parms[Arg.getArgNo()].isUniform()) {
      Value *ArgVal;
      Value *ArgMemory;
      getOrCreateArgMemory(Arg, EntryBlock, LoopPreHeader, ArgVal, ArgMemory);
      UniformMemory[&Arg] = std::make_pair(ArgMemory, ArgVal);
    }
  }
}

void VecCloneImpl::processLinearArgs(Function *Clone, const VFInfo &V,
                                     PHINode *Phi, BasicBlock *EntryBlock,
                                     BasicBlock *LoopPreHeader) {
  // Add stride to arguments marked as linear. These instructions are added
  // before the arg user and uses are updated accordingly.
  ArrayRef<VFParameter> Parms = V.getParameters();

  for (Argument &Arg : Clone->args()) {
    const VFParameter Parm = Parms[Arg.getArgNo()];
    if (Parm.isLinear()) {
      Value *StrideVal = nullptr;
      Value *ArgVal = nullptr;
      Value *ArgMemory = nullptr;
      if (Parm.isConstantStrideLinear()) {
        int Stride = Parm.getStride();
        if (auto *PtrTy = dyn_cast<PointerType>(Arg.getType())) {
          // For pointer types with constant stride, the gep index is the same
          // type as the phi (loop index), which is i32.
          if (!PtrTy->isOpaque()) {
            const DataLayout &DL = Clone->getParent()->getDataLayout();
            unsigned PointeeEltSize =
                DL.getTypeAllocSize(PtrTy->getPointerElementType());
            assert(Stride % PointeeEltSize == 0 &&
                   "Stride is expected to be a multiple of element size!");
            Stride /= PointeeEltSize;
          }
          StrideVal = ConstantInt::get(Phi->getType(), Stride);
        } else {
          assert(Arg.getType()->isIntegerTy() &&
                 "Expected integer type for arg");
          // For integer types with constant stride, the value of the stride
          // must be the same type as the arg.
          StrideVal =
              GeneralUtils::getConstantValue(Arg.getType(),
              Clone->getContext(), Stride);
        }
        getOrCreateArgMemory(Arg, EntryBlock, LoopPreHeader, ArgVal, ArgMemory);
        LinearMemory[ArgMemory] = StrideVal;
      } else if (Parm.isVariableStride() && Arg.getType()->isIntegerTy()) {
        // Get the stride value from the argument holding it.
        int StrideArgPos = Parm.getStrideArgumentPosition();
        Argument *StrideArg = Clone->getArg(StrideArgPos);
        StrideVal = UniformMemory[StrideArg].second;
        getOrCreateArgMemory(Arg, EntryBlock, LoopPreHeader, ArgVal, ArgMemory);
        LinearMemory[ArgMemory] = UniformMemory[StrideArg].first;
      } else {
        llvm_unreachable("Unsupported linear modifier");
      }

      // Eventually, this for loop can be removed once we start relying on
      // just marking the allocas as linear and letting VPlan deal with
      // accounting for stride calculations rather than VecClone inserting
      // new instructions for the stride and updating users.
      for (auto &U:  make_early_inc_range(ArgVal->uses())) {
        auto *User = cast<Instruction>(U.getUser());
        Value *StrideInst =
            generateStrideForArgument(Clone, ArgVal, User, StrideVal, Phi);
        User->setOperand(U.getOperandNo(), StrideInst);
      }
    }
  }

  LLVM_DEBUG(dbgs() << "After Linear Updates\n");
  LLVM_DEBUG(Clone->dump());
}

void VecCloneImpl::updateReturnBlockInstructions(Function *Clone,
                                                 BasicBlock *ReturnBlock,
                                                 Instruction *WidenedReturn) {
  // If the vector function returns void, then there is no need to do any
  // packing. The only instruction in the ReturnBlock is 'ret void', so
  // we can just leave this instruction and we're done.
  if (Clone->getReturnType()->isVoidTy())
    return;

  // Remove all instructions from the return block. These will be replaced
  // with the instructions necessary to return a vector temp. The verifier
  // will complain if we remove the definitions of users first, so remove
  // instructions from the bottom up.
  while (!ReturnBlock->empty())
    ReturnBlock->back().eraseFromParent();

  // Pack up the elements into a vector temp and return it. If the return
  // vector was bitcast to a pointer to the element type, we must bitcast to
  // vector before returning.
  // Operand 0 is the actual alloc reference in the bitcast.
  AllocaInst *Alloca = cast<AllocaInst>(WidenedReturn->getOperand(0));
  PointerType *PtrVecType =
      PointerType::get(Clone->getReturnType(),
                       Alloca->getType()->getAddressSpace());
  BitCastInst *BitCast =
    new BitCastInst(WidenedReturn, PtrVecType,
                    "vec." + WidenedReturn->getName(),
                    ReturnBlock);

  // Return can't be void here due to early exit at the top of this function.
  // Return is expected to be a bitcast instruction because we always create
  // a vector alloca for the return value and cast that to a scalar pointer.
  // for use within the loop. I.e., this cast is used with the loop index to
  // reference a specific vector element. At the point of the function return,
  // the scalar cast is converted back to vector and we load from that to the
  // return vector.
  // TODO: this can actually be simplified further by just returning Alloca
  // from above. There doesn't seem to be a good reason to do this extra
  // casting. Leaving for now because this change is NFC.
  LoadInst *VecReturn =
      new LoadInst(Clone->getReturnType(), BitCast, "vec.ret", ReturnBlock);
  ReturnInst::Create(Clone->getContext(), VecReturn, ReturnBlock);

  LLVM_DEBUG(dbgs() << "After Return Block Update\n");
  LLVM_DEBUG(Clone->dump());
}

static Type* getMemoryType(Value* Memory) {
  if (AllocaInst *Alloca = dyn_cast<AllocaInst>(Memory))
    return Alloca->getAllocatedType();
  else if (Argument *Arg = dyn_cast<Argument>(Memory)) {
    // Represents byval args where there is already a stack slot
    // available for the arg.
    return Arg->getPointeeInMemoryValueType();
  } else
    llvm_unreachable("Arg memory should be on the stack");
}

// Creates the simd.begion.region block which marks the beginning of the WRN
// region. Given the function arguments, emits the correct directive in the
// simd.begion.region block. If the arguments are linear or uniform, a new
// basic block (simd.loop.preheader) is created between the simd.begin.region
// block and the simd.loop.header block. VPLoopEntity needs the addresses of
// the uniform/linear arguments. For this reason, we need to pass the address
// of the arguments to the directives instead of their values. In VecClone, we
// have the values, not the addresses. So, we create a stack variable for each
// uniform and linear argument and store them in the stack (the store is
// emitted in the EntryBlock). Next, we load it and we update its uses (the load
// is emitted in simd.loop.preheader). This is similar to the code emitted by
// the front-end for simd loops.
CallInst *VecCloneImpl::insertBeginRegion(Module &M, Function *Clone,
                                          Function &F, const VFInfo &V,
                                          BasicBlock *EntryBlock,
                                          BasicBlock *LoopPreHeader) {
  IRBuilder<> Builder(&*EntryBlock->begin());

  SmallVector<llvm::OperandBundleDef, 4> OpndBundles;
  OpndBundles.emplace_back(
      std::string(IntrinsicUtils::getDirectiveString(DIR_OMP_SIMD)), None);

  auto Clause = [](OMP_CLAUSES ClauseId, auto &&... Mods) -> std::string {
    std::initializer_list<StringRef> Modifiers = {Mods...};
    std::string Result = IntrinsicUtils::getClauseString(ClauseId).str();
    if (Modifiers.size() == 0)
      return Result;
    raw_string_ostream SS(Result);
    SS << ":";
    ListSeparator LS;
    for (StringRef Mod : Modifiers)
      SS << LS << Mod;
    return Result;
  };

  auto AddTypedClause = [&OpndBundles, Clause](OMP_CLAUSES ClauseId, Value *Ptr,
                                               Type *Ty, auto &&... Ops) {
    if (!EmitTypedOMP) {
      OpndBundles.push_back(OperandBundleDef{Clause(ClauseId), {Ptr, Ops...}});
      return;
    }

    std::string ClauseString = IntrinsicUtils::getClauseString(ClauseId).str();
    std::string ClauseStringUpdates = "TYPED";
    if (Ptr->getType()->isOpaquePointerTy() &&
        ClauseString == "QUAL.OMP.LINEAR") {
      ClauseStringUpdates += ".PTR_TO_PTR";
      Ty = llvm::Type::getInt8Ty(Ty->getContext());
    }
    OpndBundles.push_back(OperandBundleDef{
        Clause(ClauseId, ClauseStringUpdates),
        {Ptr, Constant::getNullValue(Ty),
         ConstantInt::get(Type::getInt32Ty(Ty->getContext()), 1), // #Elts
         Ops...}});
  };

  // Insert vectorlength directive
  OpndBundles.emplace_back(Clause(QUAL_OMP_SIMDLEN),
                           Builder.getInt32(V.getVF()));

  // Mark linear memory for the SIMD directives
  for (auto LinearMem : LinearMemory) {
    Type *LinearTy = getMemoryType(LinearMem.first);
    AddTypedClause(QUAL_OMP_LINEAR, LinearMem.first, LinearTy,
                   LinearMem.second);
  }
  
  // Mark uniform memory for the SIMD directives
  for (auto UniformMem : UniformMemory) {
    // The alloca for the arg.
    Value *ArgMemory = UniformMem.second.first;
    Type *UniformTy = getMemoryType(ArgMemory);
    AddTypedClause(QUAL_OMP_UNIFORM, ArgMemory, UniformTy);
  }

  // Mark private memory for the SIMD directives
  for (Value *PrivateMem : PrivateMemory) {
    assert(isa<AllocaInst>(PrivateMem) &&
           "private memory is expected to be an alloca instruction");
    AddTypedClause(QUAL_OMP_PRIVATE, PrivateMem,
                   cast<AllocaInst>(PrivateMem)->getAllocatedType());
  }

  // Create simd.begin.region block which indicates the begining of the WRN
  // region.
  CallInst *SIMDBeginCall = CallInst::Create(
      Intrinsic::getDeclaration(&M, Intrinsic::directive_region_entry), None,
      OpndBundles, "entry.region");
  SIMDBeginCall->insertBefore(EntryBlock->getTerminator());
  EntryBlock->splitBasicBlock(SIMDBeginCall, "simd.begin.region");
  return SIMDBeginCall;
}

void VecCloneImpl::insertEndRegion(Module &M, Function *Clone,
                                   BasicBlock *LoopLatch,
                                   BasicBlock *ReturnBlock,
                                   CallInst *EntryDirCall) {
  BasicBlock *EndDirectiveBlock = BasicBlock::Create(
      Clone->getContext(), "simd.end.region", Clone, ReturnBlock);

  BranchInst *LoopLatchBranch =
      dyn_cast<BranchInst>(LoopLatch->getTerminator());
  assert(LoopLatchBranch && "Expecting br instruction for loop latch block");
  LoopLatchBranch->setOperand(1, EndDirectiveBlock);

  BranchInst::Create(ReturnBlock, EndDirectiveBlock);

  CallInst *SIMDEndCall =
      IntrinsicUtils::createSimdDirectiveEnd(M, EntryDirCall);
  SIMDEndCall->insertBefore(EndDirectiveBlock->getTerminator());
}

void VecCloneImpl::insertDirectiveIntrinsics(Module &M, Function *Clone,
                                             Function &F, const VFInfo &V,
                                             BasicBlock *EntryBlock,
                                             BasicBlock *LoopPreHeader,
                                             BasicBlock *LoopLatch,
                                             BasicBlock *ReturnBlock) {
  CallInst *EntryDirCall = insertBeginRegion(M, Clone, F, V, EntryBlock,
                                             LoopPreHeader);
  insertEndRegion(M, Clone, LoopLatch, ReturnBlock, EntryDirCall);
  LLVM_DEBUG(dbgs() << "After Directives Insertion\n");
  LLVM_DEBUG(Clone->dump());
}

bool VecCloneImpl::isSimpleFunction(Function *Func) {
  // For really simple functions, there is no need to go through the process
  // of inserting a loop.

  // Example:
  //
  // void foo(void) {
  //   return;
  // }
  //
  // No need to insert a loop for this case since it's basically a no-op. Just
  // clone the function and return. It's possible that we could have some code
  // inside of a vector function that modifies global memory. Let that case go
  // through.
  return isa<ReturnInst>(Func->front().front()) &&
         Func->getReturnType()->isVoidTy();
}

void VecCloneImpl::insertSplitForMaskedVariant(Function *Clone,
                                               BasicBlock *LoopHeader,
                                               BasicBlock *LoopLatch,
                                               Instruction *Mask,
                                               PHINode *Phi) {
  BasicBlock *LoopThenBlock =
      LoopHeader->splitBasicBlock(LoopHeader->getFirstNonPHI(),
                                 "simd.loop.then");

  BasicBlock *LoopElseBlock = BasicBlock::Create(Clone->getContext(),
                                                 "simd.loop.else",
                                                 Clone, LoopLatch);

  BranchInst::Create(LoopLatch, LoopElseBlock);

  auto *BitCast = cast<BitCastInst>(Mask);
  auto *Alloca = cast<AllocaInst>(BitCast->getOperand(0));

  Type *PointeeType =
      cast<VectorType>(Alloca->getAllocatedType())->getElementType();

  GetElementPtrInst *MaskGep =
      GetElementPtrInst::Create(PointeeType, Mask, Phi, "mask.gep",
                                LoopHeader->getTerminator());

  Type *LoadTy = MaskGep->getResultElementType();
  LoadInst *MaskLoad = new LoadInst(LoadTy, MaskGep, "mask.parm",
                                    LoopHeader->getTerminator());

  Type *CompareTy = MaskLoad->getType();
  Instruction *MaskCmp;
  Constant* Zero;

  // Generate the compare instruction to see if the mask bit is on. In ICC, we
  // use the movemask intrinsic which takes both float/int mask registers and
  // converts to an integer scalar value, one bit representing each element.
  if (CompareTy->isIntegerTy()) {
    Zero = GeneralUtils::getConstantValue(CompareTy, Clone->getContext(),
                                               0);
    MaskCmp = new ICmpInst(LoopHeader->getTerminator(), CmpInst::ICMP_NE,
                           MaskLoad, Zero, "mask.cond");
  } else if (CompareTy->isFloatingPointTy()) {
    Zero = GeneralUtils::getConstantValue(CompareTy, Clone->getContext(),
                                               0.0);
    MaskCmp = new FCmpInst(LoopHeader->getTerminator(), CmpInst::FCMP_UNE,
                           MaskLoad, Zero, "mask.cond");
  } else {
    llvm_unreachable("Unsupported mask compare");
  }

  Instruction *Term = LoopHeader->getTerminator();
  Term->eraseFromParent();
  BranchInst::Create(LoopThenBlock, LoopElseBlock, MaskCmp, LoopHeader);

  LLVM_DEBUG(dbgs() << "After Split Insertion For Masked Variant\n");
  LLVM_DEBUG(Clone->dump());
}

void VecCloneImpl::disableLoopUnrolling(BasicBlock *Latch) {
  // Set disable unroll metadata on the conditional branch of the loop latch
  // for the simd loop. The following is an example of what the loop latch
  // and Metadata will look like. The !llvm.loop marks the beginning of the
  // loop Metadata and is always placed on the terminator of the loop latch.
  // (i.e., simd.loop.latch in this case). According to LLVM documentation, to
  // properly set the loop Metadata, the 1st operand of !16 must be a self-
  // reference to avoid some type of Metadata merging conflicts that have
  // apparently arisen in the past. This is part of LLVM history that I do not
  // know. Also, according to LLVM documentation, any Metadata nodes referring
  // to themselves are marked as distinct. As such, all Metadata corresponding
  // to a loop belongs to that loop alone and no sharing of Metadata can be
  // done across different loops.
  //
  // simd.loop.latch:        ; preds = %simd.loop.header, %if.else, %if.then
  //  %indvar = add nuw i32 %index, 1
  //  %vl.cond = icmp ult i32 %indvar, 2
  //  br i1 %vl.cond, label %simd.loop.header, label %simd.end.region, !llvm.loop !16
  //
  // !16 = distinct !{!16, !17}
  // !17 = !{!"llvm.loop.unroll.disable"}

  SmallVector<Metadata *, 4> MDs;

  // Reserve first location for self reference to the LoopID metadata node.
  MDs.push_back(nullptr);

  // Add unroll(disable) metadata to disable future unrolling.
  LLVMContext &Context = Latch->getContext();
  SmallVector<Metadata *, 1> DisableOperands;
  DisableOperands.push_back(MDString::get(Context, "llvm.loop.unroll.disable"));
  MDNode *DisableNode = MDNode::get(Context, DisableOperands);
  MDs.push_back(DisableNode);

  MDNode *NewLoopID = MDNode::get(Context, MDs);
  // Set operand 0 to refer to the loop id itself.
  NewLoopID->replaceOperandWith(0, NewLoopID);
  Latch->getTerminator()->setMetadata("llvm.loop", NewLoopID);
}

PreservedAnalyses VecClonePass::run(Module &M, ModuleAnalysisManager &AM) {
  // NOTE: Update here if new analyses are needed before VecClone
  // (getAnalysisUsage from LegacyPM)

  auto &OROA = AM.getResult<OptReportOptionsAnalysis>(M);
  ORBuilder.setup(M.getContext(), OROA.getVerbosity());

  if (!Impl.runImpl(M, &ORBuilder))
    return PreservedAnalyses::all();

  auto PA = PreservedAnalyses::none();
  PA.preserve<AndersensAA>();
  PA.preserve<GlobalsAA>();
  return PA;
}

void VecClone::getAnalysisUsage(AnalysisUsage &AU) const {
  // VecClone pass does not make any changes in the existing functions and
  // Andersens analysis is conservative on new functions. So we can consider it
  // as preserved.
  AU.addPreserved<AndersensAAWrapperPass>(); // INTEL
  AU.addPreserved<GlobalsAAWrapperPass>();
  AU.addRequired<OptReportOptionsPass>(); // INTEL
}

#if INTEL_CUSTOMIZATION
void VecCloneImpl::filterUnsupportedVectorVariants(
    Module &M, SmallVector<Function *, 8> &FuncDiagList,
    OptReportBuilder *ORBuilder) {
  // Traverse both definitions and declarations to not pick the unsupported
  // vector variant when vectorizing.
  for (auto &F : M) {
    if (F.hasFnAttribute("vector-variants")) {
      Attribute Attr = F.getFnAttribute("vector-variants");
      StringRef VariantsStr = Attr.getValueAsString();
      SmallVector<StringRef, 8> Variants;
      VariantsStr.split(Variants, ',');

      SmallVector<StringRef, 8> SupportedVariants;
      llvm::copy_if(Variants, std::back_inserter(SupportedVariants),
                    [](StringRef Variant) {
                      assert(Variant.find_first_of("_ZGV") == 0 &&
                             "Expect vector variant mangling!");
                      // Drop "_ZGV".
                      StringRef Encoding =
                      Variant.drop_front(StringRef("_ZGV").size());
                      // Extract encoding.
                      size_t EncodingEnd = Encoding.find_first_of('_');
                      assert(EncodingEnd != Encoding.npos &&
                             "Unexpected end of vector variant.");
                      Encoding = Encoding.take_front(EncodingEnd);
                      bool Unsupported = Encoding.contains('R') ||
                                         Encoding.contains('U') ||
                                         Encoding.contains('L');
                      return !Unsupported;
                    });

      if (ORBuilder && (Variants.size() != SupportedVariants.size()))
        FuncDiagList.push_back(&F);

      // Replace existing vector variants with supported ones.
      if (!SupportedVariants.empty()) {
        AttributeList AL = F.getAttributes();
        AL = AL.addFnAttribute(F.getContext(), "vector-variants",
                               llvm::join(SupportedVariants, ","));
        F.setAttributes(AL);
      } else {
        F.removeFnAttr("vector-variants");
      }
    }
  }
}
#endif // INTEL_CUSTOMIZATION

bool VecCloneImpl::runImpl(Module &M, OptReportBuilder *ORBuilder,
                           LoopOptLimiter Limiter) {

  LLVM_DEBUG(dbgs() << "\nExecuting SIMD Function Cloning ...\n\n");

#if INTEL_CUSTOMIZATION
  // This filtering can be removed once R/U/L encodings are supported.
  SmallVector<Function *, 8> FuncDiagList;
  filterUnsupportedVectorVariants(M, FuncDiagList, ORBuilder);

  // Language specific hook
  languageSpecificInitializations(M);
#endif // INTEL_CUSTOMIZATION

  MapVector<Function *, std::vector<StringRef>> FunctionsToVectorize;
  getFunctionsToVectorize(M, FunctionsToVectorize);

  for (auto VarIt : FunctionsToVectorize) {
    Function& F = *(VarIt.first);

    if (!doesLoopOptPipelineAllowToRun(Limiter, F))
      continue;

    auto Variants = map_range(VarIt.second, [](StringRef Name) {
        return VFABI::demangleForVFABI(Name);
    });

    for (const VFInfo &Variant : Variants) {
      // VecClone runs after OCLVecClone. Hence, VecClone will be triggered
      // again for the OpenCL kernels. To prevent this, we do not process
      // functions whose name include the current vector variant name. The
      // vector variant name is a combination of the scalar function name and
      // the Vector ABI encoding.
      if (M.getFunction(Variant.VectorName))
        continue;

      // Clone the original function.
      LLVM_DEBUG(dbgs() << "Before SIMD Function Cloning\n");
      LLVM_DEBUG(F.dump());
      ValueToValueMapTy VMap;
      Function *Clone = CloneFunction(F, Variant, VMap);
      BasicBlock *EntryBlock = &Clone->front();

      if (isSimpleFunction(Clone))
        continue;

      BasicBlock *LoopHeader = splitEntryIntoLoop(Clone, Variant, EntryBlock);

      BasicBlock *LoopPreHeader = EntryBlock->splitBasicBlock(
          EntryBlock->getTerminator(), "simd.loop.preheader");

      BasicBlock *ReturnBlock = splitLoopIntoReturn(Clone, &Clone->back());
      if (!ReturnBlock) {
        // OpenCL, it's valid to have an infinite loop inside kernel with no
        // independent forward progress guarantee. As such, creating a VecClone
        // loop around the body is required. Handle such cases.
        // For OpenMP cases, it's probably UB in the incoming IR, so creation of
        // the loop is still valid.
        ReturnBlock =
            BasicBlock::Create(Clone->getContext(), "unreachable.ret", Clone);
        IRBuilder<> B(ReturnBlock);
        B.CreateUnreachable();
      }

      BasicBlock *LoopLatch = BasicBlock::Create(
          Clone->getContext(), "simd.loop.latch", Clone, ReturnBlock);
      ReturnBlock->replaceAllUsesWith(LoopLatch);

      PHINode *Phi = createPhiAndBackedgeForLoop(Clone, LoopPreHeader,
                                                 LoopHeader, LoopLatch,
                                                 ReturnBlock,
                                                 Variant.getVF());

      // At this point, we've gathered some parameter information and have
      // restructured the function into an entry block, a set of blocks
      // forming the loop, a loop latch block, and a return block. Now,
      // we can go through and update instructions since we know what
      // is part of the loop.

      // Create a new vector alloca instruction for all vector arguments and
      // return. Store the vector argument to the alloca. Replace users with
      // gep/load using the loop index.

      Instruction *Mask = nullptr;
      Instruction *WidenedReturn = widenVectorArgumentsAndReturn(
          Clone, F, Variant, Mask, EntryBlock, LoopHeader, ReturnBlock,
          Phi, VMap);

      // Mark uniform memory for SIMD directives
      processUniformArgs(Clone, Variant, EntryBlock, LoopPreHeader);

      // Update any linear variables with the appropriate stride. This function
      // will insert a mul/add sequence before the use of the argument. For
      // linear pointer arguments, the stride calculation is just a mul
      // instruction using the loop induction var and the stride value on the
      // argument. This mul instruction is then used as the index of the gep
      // that will be inserted before the next use of the argument. The
      // function also updates the users of the argument with the new
      // calculation involving the stride. Also mark linear memory for SIMD
      // directives.
      processLinearArgs(Clone, Variant, Phi, EntryBlock, LoopPreHeader);

      // Remove the old scalar instructions associated with the return and
      // replace with packing instructions.
      updateReturnBlockInstructions(Clone, ReturnBlock, WidenedReturn);

      // If this is the masked vector variant, insert the mask condition and
      // if/else blocks.
      if (Variant.isMasked()) {
        insertSplitForMaskedVariant(Clone, LoopHeader, LoopLatch, Mask, Phi);
      }

#if INTEL_CUSTOMIZATION
      // Language specific hook.
      handleLanguageSpecifics(F, Phi, Clone, EntryBlock, Variant);
#endif // INTEL_CUSTOMIZATION

      // Insert the basic blocks that mark the beginning/end of the SIMD loop.
      insertDirectiveIntrinsics(M, Clone, F, Variant, EntryBlock, LoopPreHeader,
                                LoopLatch, ReturnBlock);
      PrivateMemory.clear();
      UniformMemory.clear();
      LinearMemory.clear();

      // Add may-have-openmp-directive attribute since we inserted directives.
      Clone->addFnAttr("may-have-openmp-directive", "true");

      LLVM_DEBUG(dbgs() << "After SIMD Function Cloning\n");
      LLVM_DEBUG(Clone->dump());

      // Disable unrolling from kicking in on the simd loop.
      disableLoopUnrolling(LoopLatch);
    } // End of function cloning for the variant
  } // End of function cloning for all variants

#if INTEL_CUSTOMIZATION
 // Issue the diagnostics post-cloning to avoid duplicating them.
 if (ORBuilder)
   for (auto *F : FuncDiagList) {
       (*ORBuilder)(*F).addRemark(
         OptReportVerbosity::Medium,
         "'omp declare' vector variants with linear reference/ref()/uval()/" \
         "val() or linear step passed as another argument were skipped " \
         "as unsupported.");
}
#endif // INTEL_CUSTOMIZATION

  //FIXME: return false if all functions were skipped or IR was not modified.
  return true; // LLVM IR has been modified
}

ModulePass *llvm::createVecClonePass() {
  return new llvm::VecClone();
}

char VecClone::ID = 0;

static const char lv_name[] = "VecClone";
INITIALIZE_PASS_BEGIN(VecClone, SV_NAME, lv_name,
                      false /* modifies CFG */, false /* transform pass */)
INITIALIZE_PASS_DEPENDENCY(OptReportOptionsPass)
INITIALIZE_PASS_END(VecClone, SV_NAME, lv_name,
                    false /* modififies CFG */, false /* transform pass */)
