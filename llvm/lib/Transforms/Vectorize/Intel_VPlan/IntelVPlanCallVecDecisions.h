//===-- IntelVPlanCallVecDecisions.h ---------------------------*- C++ -*-===//
//
//   Copyright (C) 2020-2022 Intel Corporation. All rights reserved.
//
//   The information and source code contained herein is the exclusive
//   property of Intel Corporation and may not be disclosed, examined
//   or reproduced in whole or in part without explicit written authorization
//   from the company.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// This file defines VPlanCallVecDecisions class which implements a VPlan
/// analysis that visits each VPCallInstruction, identifies ideal
/// vectorization scenario for a given VF and records decision by updating
/// vectorization properties of the VPCall.
///
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORMS_VECTORIZE_INTEL_VPLAN_INTELVPLANCALLVECDECISIONS_H
#define LLVM_TRANSFORMS_VECTORIZE_INTEL_VPLAN_INTELVPLANCALLVECDECISIONS_H

#include "IntelVPlan.h"

namespace llvm {

class TargetTransformInfo;
class TargetLibraryInfo;
struct VFInfo;

namespace vpo {

extern bool VPlanVecNonReadonlyLibCalls;

class VPlanCallVecDecisions {

public:
  VPlanCallVecDecisions(VPlanVector &Plan) : Plan(Plan) {}

  /// Public interface for analysis that visits all VPCallInstructions in
  /// current VPlan CFG and updates them with appropriate decision on how to
  /// vectorize the Call. This interface should be used if caller requires
  /// analysis for a specific VF.
  // TODO: This should be removed once SVA is in place to directly invoke Call
  // specific interface below.
  void runForVF(unsigned VF, const TargetLibraryInfo *TLI,
                const TargetTransformInfo *TTI);

  /// Public interface for analysis when we are dealing with a merged VPlan CFG
  /// i.e. input VPlan was generated by VPlan CFGMerger transform. VFs that must
  /// be used to analyze different calls are determined by consuming information
  /// embedded in CFG through the VPPush/PopVF instructions. It functionally
  /// mimics runForVF interface.
  void runForMergedCFG(const TargetLibraryInfo *TLI,
                       const TargetTransformInfo *TTI);

  /// Determine the characteristic type of the vector function as
  /// specified according to the vector function ABI.
  static Type *calcCharacteristicType(VPCallInstruction *VPCallInst,
                                      const VFInfo &Variant);

  /// \Returns the best simd function variant and its index.
  llvm::Optional<std::pair<VFInfo, unsigned>>
  matchVectorVariant(const VPCallInstruction *VPCall, bool Masked, unsigned VF,
                     const TargetTransformInfo *TTI);

  /// Public interface to reset decisions recorded for analyzed VPCalls in given
  /// VPlan. This is done by resetting the corresponding vectorization scenarios
  /// of each call, setting their last analyzed VF with an invalid value (VF=0).
  void reset();

private:
  /// Determine call vectorization properties for a given \p VPCall. This
  /// decision is taken based on given \p VF and various external components
  /// like vector variants, target library functions, call site and function
  /// attributes.
  void analyzeCall(VPCallInstruction *VPCall, unsigned VF,
                   const TargetLibraryInfo *TLI,
                   const TargetTransformInfo *TTI);

  /// Generates a VFInfo placeholder for TTI so that it can match the
  /// most appropriate vector variant of the called function \p VPCall.
  VFInfo getVectorVariantForCallParameters(const VPCallInstruction *VPCall,
                                           bool Masked, int VF);

  VPlanVector &Plan;
};

} // end namespace vpo
} // end namespace llvm

#endif // LLVM_TRANSFORMS_VECTORIZE_INTEL_VPLAN_INTELVPLANCALLVECDECISIONS_H
