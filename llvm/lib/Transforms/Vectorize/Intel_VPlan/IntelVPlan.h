//===- IntelVPlan.h - Represent A Vectorizer Plan -------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains the declarations of the Vectorization Plan base classes:
// 1. VPBasicBlock and VPRegionBlock that inherit from a common pure virtual
//    VPBlockBase, together implementing a Hierarchical CFG;
// 2. Specializations of GraphTraits that allow VPBlockBase graphs to be treated
//    as proper graphs for generic algorithms;
// 3. Pure virtual VPRecipeBase and its pure virtual sub-classes
//    represent base classes for recipes contained within VPBasicBlocks;
// 4. The VPlan class holding a candidate for vectorization;
// 5. The VPlanUtils class providing methods for building plans;
// 6. The VPlanPrinter class providing a way to print a plan in dot format.
// These are documented in docs/VectorizationPlan.rst.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORMS_VECTORIZE_INTEL_VPLAN_INTELVPLAN_H
#define LLVM_TRANSFORMS_VECTORIZE_INTEL_VPLAN_INTELVPLAN_H

#if INTEL_CUSTOMIZATION
#include "IntelVPlanValue.h"
#else
#include "VPlanValue.h"
#endif //INTEL_CUSTOMIZATION
#include "llvm/ADT/GraphTraits.h"
#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/ilist.h"
#include "llvm/ADT/ilist_node.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/Support/GenericDomTreeConstruction.h"
#include "llvm/Support/raw_ostream.h"

#if INTEL_CUSTOMIZATION
#include "IntelVPlanDivergenceAnalysis.h"
#include "Intel_VPlan/IntelVPLoopAnalysis.h"
#include "Intel_VPlan/IntelVPlanLoopInfo.h"
#include "Intel_VPlan/VPlanHIR/IntelVPlanInstructionDataHIR.h"
#include "llvm/ADT/DepthFirstIterator.h"
#include "llvm/Analysis/Intel_LoopAnalysis/IR/Diag.h"
#include "llvm/Analysis/Intel_LoopAnalysis/IR/HLInst.h"
#include "llvm/Analysis/Intel_LoopAnalysis/IR/HLGoto.h"
#include "llvm/Analysis/Intel_OptReport/LoopOptReportBuilder.h"
#include "llvm/Support/FormattedStream.h"
#endif // INTEL_CUSTOMIZATION

namespace llvm {
// The (re)use of existing LoopVectorize classes is subject to future VPlan
// refactoring.
// namespace {
class InnerLoopVectorizer;
class LoopVectorizationLegality;
class LoopInfo;
//}

#if INTEL_CUSTOMIZATION
namespace loopopt {
class RegDDRef;
class HLLoop;
class OptReportDiag;
} // namespace loopopt

namespace vpo {
class VPValue;
class VPlan;
class VPBlockBase;
class VPOCodeGen;
class VPOCodeGenHIR;
class VPOVectorizationLegality;
class VPBasicBlock;
using VPDominatorTree = DomTreeBase<VPBlockBase>;
using VPPostDominatorTree = PostDomTreeBase<VPBlockBase>;
#if INTEL_CUSTOMIZATION
class VPlanCostModel; // INTEL: to be later declared as a friend
class VPlanCostModelProprietary; // INTEL: to be later declared as a friend
class VPlanDivergenceAnalysis;
class VPlanBranchDependenceAnalysis;
#endif // INTEL_CUSTOMIZATION
typedef SmallPtrSet<VPValue *, 8> UniformsTy;

// Class names mapping to minimize the diff:
#define InnerLoopVectorizer VPOCodeGen
#define LoopVectorizationLegality VPOVectorizationLegality
#endif // INTEL_CUSTOMIZATION

/// In what follows, the term "input IR" refers to code that is fed into the
/// vectorizer whereas the term "output IR" refers to code that is generated by
/// the vectorizer.

/// VPIteration represents a single point in the iteration space of the output
/// (vectorized and/or unrolled) IR loop.
struct VPIteration {
  unsigned Part; ///< in [0..UF)
  unsigned Lane; ///< in [0..VF)
  VPIteration(unsigned Part, unsigned Lane) : Part(Part), Lane(Lane) {}
  VPIteration(unsigned Part) : Part(Part), Lane(ALL_LANES()) {}
  static unsigned ALL_LANES() { return -1; }
};

/// This is a helper struct for maintaining vectorization state. It's used for
/// mapping values from the original loop to their corresponding values in
/// the new loop. Two mappings are maintained: one for vectorized values and
/// one for scalarized values. Vectorized values are represented with UF
/// vector values in the new loop, and scalarized values are represented with
/// UF x VF scalar values in the new loop. UF and VF are the unroll and
/// vectorization factors, respectively.
///
/// Entries can be added to either map with setVectorValue and setScalarValue,
/// which assert that an entry was not already added before. If an entry is to
/// replace an existing one, call resetVectorValue and resetScalarValue. This is
/// currently needed to modify the mapped values during "fix-up" operations that
/// occur once the first phase of widening is complete. These operations include
/// type truncation and the second phase of recurrence widening.
///
/// Entries from either map can be retrieved using the getVectorValue and
/// getScalarValue functions, which assert that the desired value exists.

struct VectorizerValueMap {
  friend struct VPTransformState;

private:
  /// The unroll factor. Each entry in the vector map contains UF vector values.
  unsigned UF;

  /// The vectorization factor. Each entry in the scalar map contains UF x VF
  /// scalar values.
  unsigned VF;

  /// The vector and scalar map storage. We use std::map and not DenseMap
  /// because insertions to DenseMap invalidate its iterators.
  typedef SmallVector<Value *, 2> VectorParts;
  typedef SmallVector<SmallVector<Value *, 4>, 2> ScalarParts;
  std::map<Value *, VectorParts> VectorMapStorage;
  std::map<Value *, ScalarParts> ScalarMapStorage;

public:
  /// Construct an empty map with the given unroll and vectorization factors.
  VectorizerValueMap(unsigned UF, unsigned VF) : UF(UF), VF(VF) {}

  /// \return True if the map has any vector entry for \p Key.
  bool hasAnyVectorValue(Value *Key) const {
    return VectorMapStorage.count(Key);
  }

  /// \return True if the map has a vector entry for \p Key and \p Part.
  bool hasVectorValue(Value *Key, unsigned Part) const {
    assert(Part < UF && "Queried Vector Part is too large.");
    if (!hasAnyVectorValue(Key))
      return false;
    const VectorParts &Entry = VectorMapStorage.find(Key)->second;
    assert(Entry.size() == UF && "VectorParts has wrong dimensions.");
    return Entry[Part] != nullptr;
  }

  /// \return True if the map has any scalar entry for \p Key.
  bool hasAnyScalarValue(Value *Key) const {
    return ScalarMapStorage.count(Key);
  }

  /// \return True if the map has a scalar entry for \p Key and \p Instance.
  bool hasScalarValue(Value *Key, const VPIteration &Instance) const {
    assert(Instance.Part < UF && "Queried Scalar Part is too large.");
    assert(Instance.Lane < VF && "Queried Scalar Lane is too large.");
    if (!hasAnyScalarValue(Key))
      return false;
    const ScalarParts &Entry = ScalarMapStorage.find(Key)->second;
    assert(Entry.size() == UF && "ScalarParts has wrong dimensions.");
    assert(Entry[Instance.Part].size() == VF &&
           "ScalarParts has wrong dimensions.");
    return Entry[Instance.Part][Instance.Lane] != nullptr;
  }

  /// Retrieve the existing vector value that corresponds to \p Key and
  /// \p Part.
  Value *getVectorValue(Value *Key, unsigned Part) {
    assert(hasVectorValue(Key, Part) && "Getting non-existent value.");
    return VectorMapStorage[Key][Part];
  }

  /// Retrieve the existing scalar value that corresponds to \p Key and
  /// \p Instance.
  Value *getScalarValue(Value *Key, const VPIteration &Instance) {
    assert(hasScalarValue(Key, Instance) && "Getting non-existent value.");
    return ScalarMapStorage[Key][Instance.Part][Instance.Lane];
  }

  /// Set a vector value associated with \p Key and \p Part. Assumes such a
  /// value is not already set. If it is, use resetVectorValue() instead.
  void setVectorValue(Value *Key, unsigned Part, Value *Vector) {
    assert(!hasVectorValue(Key, Part) && "Vector value already set for part");
    if (!VectorMapStorage.count(Key)) {
      VectorParts Entry(UF);
      VectorMapStorage[Key] = Entry;
    }
    VectorMapStorage[Key][Part] = Vector;
  }

  /// Set a scalar value associated with \p Key and \p Instance. Assumes such a
  /// value is not already set.
  void setScalarValue(Value *Key, const VPIteration &Instance, Value *Scalar) {
    assert(!hasScalarValue(Key, Instance) && "Scalar value already set");
    if (!ScalarMapStorage.count(Key)) {
      ScalarParts Entry(UF);
      // TODO: Consider storing uniform values only per-part, as they occupy
      //       lane 0 only, keeping the other VF-1 redundant entries null.
      for (unsigned Part = 0; Part < UF; ++Part)
        Entry[Part].resize(VF, nullptr);
      ScalarMapStorage[Key] = Entry;
    }
    ScalarMapStorage[Key][Instance.Part][Instance.Lane] = Scalar;
  }

  /// Reset the vector value associated with \p Key for the given \p Part.
  /// This function can be used to update values that have already been
  /// vectorized. This is the case for "fix-up" operations including type
  /// truncation and the second phase of recurrence vectorization.
  void resetVectorValue(Value *Key, unsigned Part, Value *Vector) {
    assert(hasVectorValue(Key, Part) && "Vector value not set for part");
    VectorMapStorage[Key][Part] = Vector;
  }

  /// Reset the scalar value associated with \p Key for \p Part and \p Lane.
  /// This function can be used to update values that have already been
  /// scalarized. This is the case for "fix-up" operations including scalar phi
  /// nodes for scalarized and predicated instructions.
  void resetScalarValue(Value *Key, const VPIteration &Instance,
                        Value *Scalar) {
    assert(hasScalarValue(Key, Instance) &&
           "Scalar value not set for part and lane");
    ScalarMapStorage[Key][Instance.Part][Instance.Lane] = Scalar;
  }
};

/// This class is used to enable the VPlan to invoke a method of ILV. This is
/// needed until the method is refactored out of ILV and becomes reusable.
struct VPCallback {
  virtual ~VPCallback() {}
  virtual Value *getOrCreateVectorValues(Value *V, unsigned Part) = 0;
};

/// VPTransformState holds information passed down when "executing" a VPlan,
/// needed for generating the output IR.
struct VPTransformState {

#if INTEL_CUSTOMIZATION
  VPTransformState(unsigned VF, unsigned UF, LoopInfo *LI,
                   class DominatorTree *DT, IRBuilder<> &Builder,
                   VectorizerValueMap &ValueMap, InnerLoopVectorizer *ILV,
                   VPCallback &Callback, LoopVectorizationLegality *Legal)
      : VF(VF), UF(UF), Instance(), LI(LI), DT(DT), Builder(Builder),
        ValueMap(ValueMap), ILV(ILV), Callback(Callback), Legal(Legal) {}
#else
  VPTransformState(unsigned VF, unsigned UF, LoopInfo *LI,
                   class DominatorTree *DT, IRBuilder<> &Builder,
                   VectorizerValueMap &ValueMap, InnerLoopVectorizer *ILV,
                   VPCallback &Callback)
      : VF(VF), UF(UF), Instance(), LI(LI), DT(DT), Builder(Builder),
        ValueMap(ValueMap), ILV(ILV), Callback(Callback) {
  }
#endif
  /// The chosen Vectorization and Unroll Factors of the loop being vectorized.
  unsigned VF;
  unsigned UF;

  /// Hold the indices to generate specific scalar instructions. Null indicates
  /// that all instances are to be generated, using either scalar or vector
  /// instructions.
  Optional<VPIteration> Instance;

  struct DataState {
    /// A type for vectorized values in the new loop. Each value from the
    /// original loop, when vectorized, is represented by UF vector values in
    /// the new unrolled loop, where UF is the unroll factor.
    typedef SmallVector<Value *, 2> PerPartValuesTy;

    DenseMap<VPValue *, PerPartValuesTy> PerPartOutput;
  } Data;

  /// Get the generated Value for a given VPValue and a given Part. If such a
  /// Value does not exist by the time this method is called, then this Def
  /// represents Values that are still generated by ILV via ValueMap.
  Value *get(VPValue *Def, unsigned Part) {
    if (Data.PerPartOutput.count(Def))
      return Data.PerPartOutput[Def][Part];
    // Bring the Values from ValueMap.
    return Callback.getOrCreateVectorValues(VPValue2Value[Def], Part);
  }

  /// Set the generated Value for a given VPValue and a given Part.
  void set(VPValue *Def, Value *V, unsigned Part) {
    if (!Data.PerPartOutput.count(Def)) {
      DataState::PerPartValuesTy Entry(UF);
      Data.PerPartOutput[Def] = Entry;
    }
    Data.PerPartOutput[Def][Part] = V;
  }

  /// Hold state information used when constructing the CFG of the output IR,
  /// traversing the VPBasicBlocks and generating corresponding IR BasicBlocks.
  struct CFGState {
    /// The previous VPBasicBlock visited. Initially set to null.
    VPBasicBlock *PrevVPBB;
    /// The previous IR BasicBlock created or used. Initially set to the new
    /// header BasicBlock.
    BasicBlock *PrevBB;
    /// The last IR BasicBlock in the output IR. Set to the new latch
    /// BasicBlock, used for placing the newly created BasicBlocks.
    BasicBlock *LastBB;
    /// A mapping of each VPBasicBlock to the corresponding BasicBlock. In case
    /// of replication, maps the BasicBlock of the last replica created.
    SmallDenseMap<VPBasicBlock *, BasicBlock *> VPBB2IRBB;

#if INTEL_CUSTOMIZATION
    SmallDenseMap<class VPBasicBlock *, class BasicBlock *> EdgesToFix;
#endif
    CFGState() : PrevVPBB(nullptr), PrevBB(nullptr), LastBB(nullptr) {}
  } CFG;

  /// Hold a pointer to LoopInfo to register new basic blocks in the loop.
  class LoopInfo *LI;

  /// Hold a pointer to Dominator Tree to register new basic blocks in the loop.
  class DominatorTree *DT;

  /// Hold a reference to the IRBuilder used to generate output IR code.
  IRBuilder<> &Builder;

  /// Hold a reference to the Value state information used when generating the
  /// Values of the output IR.
  VectorizerValueMap &ValueMap;

  /// Hold a reference to a mapping between VPValues in VPlan and original
  /// Values they correspond to.
  VPValue2ValueTy VPValue2Value;

  /// Hold a pointer to InnerLoopVectorizer to reuse its IR generation methods.
  class InnerLoopVectorizer *ILV;

  VPCallback &Callback;
#if INTEL_CUSTOMIZATION
  /// Hold a pointer to LoopVectorizationLegality to access its
  /// IsUniformAfterVectorization method.
  class LoopVectorizationLegality *Legal;
#endif
#if INTEL_CUSTOMIZATION
  // NOTE: The condition bit generated by codegen used to be carried by the
  //       conditionbit recipes. Now that these are gone, codegen needs a way
  //       to access this data.
  //       We initialize it in VPInstruction::execute().
  //       It is being used in VPBasicBlock::createEmptyBasicBlock().
  //
  // 2. Mapping the CBVs to llvm values during the CBV's execute()
  /// The condition bit value carried by the VPValue.
  SmallDenseMap<VPValue *, Value *> CBVToConditionBitMap;
  UniformsTy *UniformCBVs;
#endif
};

/// VPRecipeBase is a base class modeling a sequence of one or more output IR
/// instructions.
class VPRecipeBase : public ilist_node_with_parent<VPRecipeBase, VPBasicBlock> {
  friend VPBasicBlock;

private:
  const unsigned char SubclassID; /// Subclass identifier (for isa/dyn_cast).

  /// Each VPRecipe belongs to a single VPBasicBlock.
  VPBasicBlock *Parent;

public:
  /// An enumeration for keeping track of the concrete subclass of VPRecipeBase
  /// that is actually instantiated. Values of this enumeration are kept in the
  /// SubclassID field of the VPRecipeBase objects. They are used for concrete
  /// type identification.
  typedef enum {
#if INTEL_CUSTOMIZATION
    VPInstructionSC,

    // Old recipes to be removed.
    VPVectorizeOneByOneSC,
    VPScalarizeOneByOneSC,
    VPWidenIntInductionSC,
    VPBuildScalarStepsSC,
    VPInterleaveSC,
    VPExtractMaskBitSC,
    VPMergeScalarizeBranchSC,
    VPBlockPredicatesRecipeSC,
    VPIfTruePredicateRecipeSC,
    VPIfFalsePredicateRecipeSC,
    VPEdgePredicateRecipeSC,
    VPUniformBranchSC,
    VPLiveInBranchSC,
    VPVectorizeBooleanSC,
    VPUniformBooleanSC,
    VPCmpBitSC,
    VPPhiValueSC,
    VPConstantSC,
    VPBranchIfNotAllZeroRecipeSC,
    VPMaskGenerationRecipeSC,
    VPNonUniformBranchSC,
#else
    VPBlendSC,
    VPBranchOnMaskSC,
    VPInstructionSC,
    VPInterleaveSC,
    VPPredInstPHISC,
    VPReplicateSC,
    VPWidenIntOrFpInductionSC,
    VPWidenMemoryInstructionSC,
    VPWidenPHISC,
    VPWidenSC,
#endif // INTEL_CUSTOMIZATION

  } VPRecipeTy;

  VPRecipeBase(const unsigned char SC) : SubclassID(SC), Parent(nullptr) {}

  virtual ~VPRecipeBase() {}

  /// \return an ID for the concrete type of this object.
  /// This is used to implement the classof checks. This should not be used
  /// for any other purpose, as the values may change as LLVM evolves.
  unsigned getVPRecipeID() const { return SubclassID; }

  /// \return the VPBasicBlock which this VPRecipe belongs to.
  VPBasicBlock *getParent() { return Parent; }
  const VPBasicBlock *getParent() const { return Parent; }

  /// The method which generates the output IR instructions that correspond to
  /// this VPRecipe, thereby "executing" the VPlan.
  virtual void execute(struct VPTransformState &State) = 0;
#if INTEL_CUSTOMIZATION
  virtual void executeHIR(VPOCodeGenHIR *CG) = 0;

  virtual void dump(raw_ostream &O) const = 0;

  virtual void dump() const = 0;
#endif

  /// Each recipe prints itself.
  virtual void print(raw_ostream &O, const Twine &Indent) const = 0;
};

#if INTEL_CUSTOMIZATION
class VPMaskGenerationRecipe : public VPRecipeBase {
  friend class VPlanUtilsLoopVectorizer;

private:
  const Value *IncomingPred;
  const Value *LoopBackedge;

public:
  VPMaskGenerationRecipe(const Value *Pred, const Value *Backedge)
      : VPRecipeBase(VPMaskGenerationRecipeSC), IncomingPred(Pred),
        LoopBackedge(Backedge) {}

  ~VPMaskGenerationRecipe() {}

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPMaskGenerationRecipeSC;
  }

  /// Print the recipe.
  void print(raw_ostream &OS, const Twine &Indent) const override {
    OS << " +\n" << Indent << "\"MaskGeneration";
    OS << " " << *LoopBackedge << "\\l\"";
  }

  void dump(raw_ostream &OS) const override {
    OS << *LoopBackedge << "\n";
  }
  void dump() const override {
    dump(errs());
  }

  void execute(struct VPTransformState &State) override {
    // TODO: vectorizing this recipe should involve generating a mask for the
    // instructions in the loop body. i.e., a phi instruction that has incoming
    // values using IncomingPred and LoopBackedge.
  }
  void executeHIR(VPOCodeGenHIR *CG) override {}
};

/// A VPConstantRecipe is a recipe which represents a constant in VPlan.
/// This recipe represents a scalar integer w/o any relation to the source IR.
/// The usage of this recipe is mainly beneficial when we need to argue about
/// new recipes altering the original structure of the code and introducing new
/// commands. e.g. consider the single-exit loop massaging, we need to
/// represent a new \phi with respect to new constant values and compares to
/// those same values
class VPConstantRecipe : public VPRecipeBase {
public:
  VPConstantRecipe(int val) : VPRecipeBase(VPConstantSC), val(val) {}

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPConstantSC;
  }

  /// The method clones a uniform instruction that calculates condition
  /// for uniform branch.
  void execute(VPTransformState &State) override {}
  void executeHIR(VPOCodeGenHIR *CG) override {}

  Value *getValue(void) const {
    // TODO after vectorize.
    return nullptr;
  }

  /// Print the recipe.
  void print(raw_ostream &OS, const Twine &Indent) const override {
    OS << " +\n" << Indent << "\"Const " << val << "\\l\"";
  }

  void dump(raw_ostream &OS) const override {
    OS << val << "\n";;
  }
  void dump() const override {
    dump(errs());
  }

  StringRef getName() const { return "Constant: " + val; };

private:
  int val;
   };
#endif //INTEL_CUSTOMIZATION

/// This is a concrete Recipe that models a single VPlan-level instruction.
/// While as any Recipe it may generate a sequence of IR instructions when
/// executed, these instructions would always form a single-def expression as
/// the VPInstruction is also a single def-use vertex.
///
#if INTEL_CUSTOMIZATION
/// For HIR, we classify VPInstructions into 3 sub-types:
///   1) Master VPInstruction: It has underlying HIR data attached and its
///      operands could have been decomposed or not. If so, this VPInstruction
///      is the last one in the UD chain of the group of decomposed
///      VPInstructions. If this VPInstruction or any of its decomposed ones are
///      modified, the HIR will automatically be marked as invalid.
///   2) Decomposed VPInstruction: It's created as a result of decomposing a
///      master VPInstruction. It doesn't have underlying HIR directly attached
///      but it has a pointer to its master VPInstruction holding it. In order
///      to check whether the underlying HIR of a decomposed VPInstruction is
///      valid, its master VPInstruction must be checked.
///   3) New VPInstruction: It's created as a result of a VPlan-to-VPlan
///      transformation, excluding decomposition. It doesn't have underlying HIR
///      or master VPInstruction attached. New VPInstructions also exist in the
///      LLVM-IR path.
///
/// DESIGN PRINCIPLE: access to the underlying IR is forbidden by default. Only
/// the front-end and back-end of VPlan should have access to the underlying IR
/// and be aware of the VPInstruction sub-type (master/decomposed/new)
/// instructions. Some well-delimited VPlan analyses, previous design review
/// approval, may also need to have access to the underlying IR and
/// VPInstruction sub-types to bring analysis information computed on the input
/// IR to VPlan. The remaining VPlan algorithms should process all the
/// VPInstructions ignoring their underlying IR and sub-type. For these
/// reasons, adding new friends to this class must be very well justified.
///
/// DESIGN DECISION: for VPO, we decided to pay the memory and design cost of
/// having LLVM-IR data (Inst) HIR data (MasterData) and their respective
/// interfaces in the same class in favor of minimizing divergence with the
/// community. We know that this is not the best design but creating a
/// VPInstructionHIR sub-class would be complicated because VPInstruction also
/// has sub-classes (VPCmpInst, VPPHINode, etc.) that would need to be
/// replicated under the VPInstructionHIR.
#endif
class VPInstruction : public VPUser, public VPRecipeBase {
#if INTEL_CUSTOMIZATION
  friend class HIRSpecifics;
  friend class VPBuilder;
  friend class VPBranchInst;
  friend class VPBuilderHIR;
  friend class VPDecomposerHIR;
  // To get underlying HIRData until we have proper VPType.
  friend class VPlanCostModel;
  friend class VPlanCostModelProprietary;
  friend class VPlanIdioms;

  /// Hold all the HIR-specific data and interfaces for a VPInstruction.
  class HIRSpecifics {
  public: 
    HIRSpecifics() {}
    ~HIRSpecifics() {
      if (isMaster())
        delete getVPInstData();
    }

    // DESIGN PRINCIPLE: IR-independent algorithms don't need to know about
    // HIR-specific master, decomposed and new VPInstructions. For that reason,
    // access to the following HIR-specific methods must be restricted. We
    // achieve that goal by making VPInstruction's HIRSpecifics member private.

    /// Pointer to access the underlying HIR data attached to this
    /// VPInstruction, if any, depending on its sub-type:
    ///   1) Master VPInstruction: MasterData points to a VPInstDataHIR holding
    ///      the actual HIR data.
    ///   2) Decomposed VPInstruction: MasterData points to master VPInstruction
    ///      holding the actual HIR data.
    ///   3) Other VPInstruction (!Master and !Decomposed): MasterData is null.
    ///      We use a void pointer to represent this case.
    PointerUnion3<MasterVPInstData *, VPInstruction *, void *> MasterData =
        (int *)nullptr;

    // Wrapper that returns the VPInstruction data of a master VPInstruction.
    MasterVPInstData *getVPInstData() {
      assert(isMaster() && "Only master VPInstructions have HIR Data!");
      return MasterData.get<MasterVPInstData *>();
    }
    const MasterVPInstData *getVPInstData() const {
      return const_cast<HIRSpecifics *>(this)->getVPInstData();
    }

    void verifyState() const {
      if (MasterData.is<MasterVPInstData *>())
        assert(!MasterData.isNull() &&
               "MasterData can't be null for master VPInstruction!");
      else if (MasterData.is<VPInstruction *>())
        assert(!MasterData.isNull() &&
               "MasterData can't be null for decomposed VPInstruction!");
      else
        assert(MasterData.is<void *>() && MasterData.isNull() &&
               "MasterData must be null for VPInstruction that is not master "
               "or decomposed!");
    }

    /// Return true if this is a master VPInstruction.
    bool isMaster() const {
      verifyState();
      return MasterData.is<MasterVPInstData *>();
    }

    /// Return true if this is a decomposed VPInstruction.
    bool isDecomposed() const {
      verifyState();
      return MasterData.is<VPInstruction *>();
    }

    // Return true if MasterData contains actual HIR data.
    bool isSet() const {
      verifyState();
      return !MasterData.is<void *>();
    }

    /// Return the underlying HIR attached to this master VPInstruction.
    loopopt::HLNode *getUnderlyingNode() {
      loopopt::HLNode *Node = getVPInstData()->getNode();
      assert(Node && "Underlying HIR cannot be null!");
      return Node;
    }
    const loopopt::HLNode *getUnderlyingNode() const {
      return const_cast<HIRSpecifics *>(this)->getUnderlyingNode();
    }

    /// Attach \p UnderlyingNode to this VPInstruction and turn it into a master
    /// VPInstruction.
    void setUnderlyingNode(loopopt::HLNode *UnderlyingNode) {
      assert(!isSet() && "MasterData is already set!");
      MasterData = new MasterVPInstData(UnderlyingNode);
    }

    /// Return the master VPInstruction attached to a decomposed VPInstruction.
    VPInstruction *getMaster() {
      assert(isDecomposed() && "Only decomposed VPInstructions have a pointer "
                               "to a master VPInstruction!");
      return MasterData.get<VPInstruction *>();
    }
    const VPInstruction *getMaster() const {
      return const_cast<HIRSpecifics *>(this)->getMaster();
    }

    /// Attach \p MasterVPI as master VPInstruction of a decomposed
    /// VPInstruction.
    void setMaster(VPInstruction *MasterVPI) {
      assert(MasterVPI && "Master VPInstruction cannot be set to null!");
      assert(!isMaster() &&
             "A master VPInstruction can't point to a master VPInstruction!");
      assert(!isSet() && "Master VPInstruction is already set!");
      MasterData = MasterVPI;
    }

    /// Return true if the underlying HIR data is valid. If it's a decomposed
    /// VPInstruction, the HIR of the attached master VPInstruction is checked.
    bool isValid() const {
      if (isMaster())
        return getVPInstData()->isValid();
      if (isDecomposed())
        return getMaster()->HIR.getVPInstData()->isValid();
      // For other VPInstructions without underlying HIR.
      assert(!isSet() && "HIR data must be unset!");
      return false;
    }

    /// Mark the underlying HIR data as valid.
    void setValid() {
      assert(isMaster() && "Only a master VPInstruction must set HIR!");
      getVPInstData()->setValid();
    }

    /// Invalidate underlying HIR deta. If decomposed VPInstruction, the HIR of
    /// its master VPInstruction is invalidated.
    void invalidate() {
      if (isMaster())
        getVPInstData()->setInvalid();
      else if (isDecomposed())
        getMaster()->HIR.getVPInstData()->setInvalid();
    }

    /// Print HIR-specific flags. It's mainly for debugging purposes.
    void printHIRFlags(raw_ostream &OS) const {
      OS << "IsMaster=" << isMaster() << " IsDecomp=" << isDecomposed()
         << " IsNew=" << !isSet() << " HasValidHIR= " << isValid() << "\n";
    }
  };
#endif // INTEL_CUSTOMIZATION

public:
#if INTEL_CUSTOMIZATION
  /// VPlan opcodes, extending LLVM IR with idiomatics instructions.
  // SemiPhi is an experimental mechanism to deal with multiple definitions
  // coming from HIR, but in a more "relaxed way" (to be defined) than using
  // proper Phi nodes. At this point, we can find semi-phis at any point of the
  // VPBasicBlock and even redundant semi-phis blending exactly the same
  // definitions.
  enum { Not = Instruction::OtherOpsEnd + 1, SemiPhi, SMax, UMax, };
#else
  enum { Not = Instruction::OtherOpsEnd + 1 };
#endif

private:
  typedef unsigned char OpcodeTy;
  OpcodeTy Opcode;

#if INTEL_CUSTOMIZATION
  // Hold the underlying HIR information, if any, attached to this
  // VPInstruction.
  HIRSpecifics HIR;
#endif

  /// Utility method serving execute(): generates a single instance of the
  /// modeled instruction.
  void generateInstruction(VPTransformState &State, unsigned Part);

#if INTEL_CUSTOMIZATION
protected:
  /// Return the underlying Instruction attached to this VPInstruction. Return
  /// null if there is no Instruction attached. This interface is similar to
  /// getValue() but it hides the cast when we are working with VPInstruction
  /// pointers.
  Instruction *getInstruction() const {
    assert((!UnderlyingVal || isa<Instruction>(UnderlyingVal)) &&
           "Expected Instruction as underlying Value.");
    return cast_or_null<Instruction>(UnderlyingVal);
  }

  /// Return true if this is a new VPInstruction (i.e., an VPInstruction that is
  /// not coming from the underlying IR.
  bool isNew() const { return UnderlyingVal == nullptr && !HIR.isSet(); }
#endif

public:
#if INTEL_CUSTOMIZATION
  VPInstruction(unsigned Opcode, ArrayRef<VPValue *> Operands)
      : VPUser(VPValue::VPInstructionSC, Operands),
        VPRecipeBase(VPRecipeBase::VPInstructionSC), Opcode(Opcode) {}
#endif
  VPInstruction(unsigned Opcode, std::initializer_list<VPValue *> Operands)
      : VPInstruction(Opcode, ArrayRef<VPValue *>(Operands)) {}

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPValue *V) {
    return V->getVPValueID() == VPValue::VPInstructionSC;
  }

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *R) {
    return R->getVPRecipeID() == VPRecipeBase::VPInstructionSC;
  }

  unsigned getOpcode() const { return Opcode; }
#if INTEL_CUSTOMIZATION
  // FIXME: To be replaced by a proper VPType.
  virtual Type *getType() const override {
    if (UnderlyingVal)
      return UnderlyingVal->getType();

    if (!HIR.isMaster())
      return nullptr;

    const loopopt::HLNode *Node = HIR.getUnderlyingNode();
    const loopopt::HLInst *Inst = dyn_cast_or_null<loopopt::HLInst>(Node);

    if (!Inst)
      return nullptr;

    const Instruction *LLVMInst = Inst->getLLVMInstruction();
    if (!LLVMInst)
      return nullptr;

    return LLVMInst->getType();
  }
#endif // INTEL_CUSTOMIZATION

  /// Generate the instruction.
  /// TODO: We currently execute only per-part unless a specific instance is
  /// provided.
  void execute(VPTransformState &State) override;
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG) override;

  /// Dump the VPInstruction.
  void dump(raw_ostream &O) const override;

  void dump() const override { dump(errs()); }
#endif

  /// Print the Recipe.
  void print(raw_ostream &O, const Twine &Indent) const override;

  /// Print the VPInstruction.
  void print(raw_ostream &O) const;
};

#if INTEL_CUSTOMIZATION
/// Concrete class for comparison. Represents both integers and floats.
class VPCmpInst : public VPInstruction {
public:
  typedef CmpInst::Predicate Predicate;
  /// \brief Create VPCmpInst with its two operands
  VPCmpInst(VPValue *LHS, VPValue *RHS, Predicate Pred)
      : VPInstruction(inferOpcodeFromPredicate(Pred),
                      ((LHS || RHS) ? ArrayRef<VPValue *>({LHS, RHS})
                                    : ArrayRef<VPValue *>({}))),
        Pred(Pred) {
    // TODO: Enable assert after fixing VPlanHCFGBuilderHIR.
    // assert(LHS && RHS && "VPCmpInst's operands can't be null!");
  }

  /// \brief Return the predicate for this instruction
  Predicate getPredicate() const { return Pred; }

  /// \brief Methods for supporting type inquiry through isa, cast, and
  /// dyn_cast:
  static bool classof(const VPInstruction *VPI) {
    return VPI->getOpcode() == Instruction::ICmp ||
           VPI->getOpcode() == Instruction::FCmp;
  }
  static bool classof(const VPValue *V) {
    return isa<VPInstruction>(V) && classof(cast<VPInstruction>(V));
  }

private:
  Predicate Pred;

  // Return the opcode that corresponds to predicate
  unsigned inferOpcodeFromPredicate(Predicate Pred) {
    // Infer Opcode from Pred
    if (CmpInst::isIntPredicate(Pred))
      return Instruction::ICmp;
    if (CmpInst::isFPPredicate(Pred))
      return Instruction::FCmp;
    llvm_unreachable("Integer/Float predicate expected");
  }
};

/// Concrete class to represent branch instruction in VPlan.
class VPBranchInst : public VPInstruction {
public:
  explicit VPBranchInst() : VPInstruction(Instruction::Br, {}) {}

  const loopopt::HLGoto *getHLGoto() const {
    return cast<loopopt::HLGoto>(HIR.getUnderlyingNode());
  }

  const BasicBlock *getTargetBlock() const {
    if (getHLGoto())
      return getHLGoto()->getTargetBBlock();
    // TODO: LLVM-IR implementation is needed.
    return nullptr;
  }

  void print(raw_ostream &O) const;

  static inline bool classof(const VPInstruction *VPI) {
    return VPI->getOpcode() == Instruction::Br;
  }
};
#endif

/// A VPPredicateRecipeBase is a pure virtual recipe which supports predicate
/// generation/modeling. Concrete sub-classes represent block & edge predicates
/// and their relations to one another.
/// The predicate value and its generating VPPredicateRecipe are considered as
/// one (in a similar manner to a value and its instruction in LLVM-IR).
/// Moreover, a concrete predicate-recipe exists with the main purpose of
/// generating a specific portion of the predicate generation sequence in the
/// output-IR. While some recipe instances serve as the actual predicates for
/// predicating instructions in a predicated VP-BB, other recipe instances may
/// only exist as an intermediate recipe in the predicate generation process.
///
/// Predicate relations are defined as listed below:
/// *** A predicate/edge-condition is represented in the definition as the set
/// *** of active lanes.
/// (a) Predicate(VP-BB): Either (1) the union across all incoming
///     edge-predicates. Or (2) the \phi between them, this kind of case serves
///     inner-loop predicate handling in the header of the loop.
/// (b) Predicate(edge): the intersection between the source-BB predicate and
///     the condition-predicate (where a condition-predicate is defined as
///     the set of lanes choosing to traverse a given edge). E.g. given the
///     true-edge of an if-statement, its condition-predicate is the set of
///     lanes traversing it across all lanes (rather than only considering the
///     active lanes). When the condition is void, the source-BB has only a
///     single edge and its condition-predicate is set to all lanes.
class VPPredicateRecipeBase : public VPRecipeBase {
public:
  /// Type definition for an array of vectorized masks. One per unroll
  /// iteration.
  typedef SmallVector<Value *, 2> VectorParts;
  typedef SmallVector<loopopt::RegDDRef *, 2> HIRVectorParts;

  /// Temporary, should be removed.
  BasicBlock *SourceBB;

protected:
  /// The result after vectorizing. used for feeding future v-instructions.
  VectorParts VectorizedPredicate;
  HIRVectorParts VectorizedPredicateHIR;

  /// Construct a VPPredicateRecipeBase.
  VPPredicateRecipeBase(const unsigned char SC)
    : VPRecipeBase(SC), VectorizedPredicate(), VectorizedPredicateHIR() {}

  /// Predicate's name.
  std::string Name;

#if INTEL_CUSTOMIZATION
  /// The predicate inputs - for debugging
  std::string Inputs;
#endif

public:
  /// Get the vectorized value. Must be used after vectorizing the concrete
  /// recipe.
  const VectorParts &getVectorizedPredicate() const {
    return VectorizedPredicate;
  }

  const HIRVectorParts &getVectorizedPredicateHIR() const {
    return VectorizedPredicateHIR;
  }

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPBlockPredicatesRecipeSC ||
           V->getVPRecipeID() == VPRecipeBase::VPIfTruePredicateRecipeSC ||
           V->getVPRecipeID() == VPRecipeBase::VPIfFalsePredicateRecipeSC;
  }

  // Get predicate's name.
  std::string getName() const { return Name; }

  // Set predicate's name.
  void setName(std::string Name) { this->Name = Name; }
};

/// A VPBlockPredicateRecipe is a concrete VPPredicateRecipe recipe which
/// models a block predicate. As defined above in Predicate relations (a.1.),
/// this predicate is the union of all IncomingPredicates.
class VPBlockPredicateRecipe : public VPPredicateRecipeBase {
  friend class VPValueUtils;

private:
  /// The list of incoming edges to the block
  SmallVector<VPPredicateRecipeBase *, 2> IncomingPredicates;

  /// \brief Add Incoming Predicate.
  void appendIncomingPredicate(VPPredicateRecipeBase *Incoming) {
    assert(Incoming && "Cannot add nullptr incoming predicate!");
    IncomingPredicates.push_back(Incoming);
  }

  /// \brief Remove Incoming Predicate.
  void removeIncomingPredicate(VPPredicateRecipeBase *Incoming) {
    assert(Incoming && "Cannot add nullptr incoming predicate!");
    auto Pos = std::find(IncomingPredicates.begin(), IncomingPredicates.end(),
                         Incoming);
    assert(Pos && "Incoming does not exist!");
    IncomingPredicates.erase(Pos);
  }

  /// \brief Clear list of incoming predicates
  void clearIncomingPredicates() { IncomingPredicates.clear(); }

public:
  /// Construct a VPPredicateRecipeBase.
  VPBlockPredicateRecipe()
      : VPPredicateRecipeBase(VPBlockPredicatesRecipeSC), IncomingPredicates() {
  }

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPBlockPredicatesRecipeSC;
  }

  const SmallVectorImpl<VPPredicateRecipeBase *> &
  getIncomingPredicates(void) const {
    return const_cast<VPBlockPredicateRecipe *>(this)->getIncomingPredicates();
  }

  SmallVectorImpl<VPPredicateRecipeBase *> &getIncomingPredicates(void) {
    return IncomingPredicates;
  }

  void execute(VPTransformState &State) override;
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG) override;

  void dump(raw_ostream &OS) const override;

  void dump() const override { dump(errs()); }
#endif

  void print(raw_ostream &OS, const Twine &Indent) const override;
};

/// A VPEdgePredicateRecipeBase is a pure virtual recipe which supports
/// predicate generation/modeling on edges. Concrete sub-classes represent
/// if-statement edge predicates and select-statement edge predicates in the
/// future.
/// A VPEdgePredicateRecipeBase holds reference to edge's source-BB predicate
/// and condition-predicate as illustrated in Predicate relations (b).
class VPEdgePredicateRecipeBase : public VPPredicateRecipeBase {
protected:
  /// A pointer to the recipe closest to the condition value
  VPValue *ConditionValue;

  /// A pointer to the predecessor block's predicate.
  VPPredicateRecipeBase *PredecessorPredicate;

  /// Construct a VPEdgePredicateRecipeBase.
  VPEdgePredicateRecipeBase(const unsigned char SC, VPValue *CV,
                            VPPredicateRecipeBase *PredecessorPredicate)
      : VPPredicateRecipeBase(SC), ConditionValue(CV),
        PredecessorPredicate(PredecessorPredicate) {}

  /// A helper function which prints out the details of an edge predicate.
  void printDetails(raw_ostream &O) const;

public:
  const VPPredicateRecipeBase *getPredecessorPredicate() const {
    return const_cast<VPEdgePredicateRecipeBase *>(this)
        ->getPredecessorPredicate();
  }
  VPPredicateRecipeBase *getPredecessorPredicate() {
    return PredecessorPredicate;
  }

  // TODO: Private + utility
  void setPredecessorPredicate(VPPredicateRecipeBase *Predicate) {
    PredecessorPredicate = Predicate;
  }

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPIfTruePredicateRecipeSC ||
           V->getVPRecipeID() == VPRecipeBase::VPIfFalsePredicateRecipeSC ||
           V->getVPRecipeID() == VPRecipeBase::VPEdgePredicateRecipeSC;
  }
};

class VPEdgePredicateRecipe : public VPEdgePredicateRecipeBase {
public:
  /// Construct a VPIfTruePredicateRecipe.
  VPEdgePredicateRecipe(VPPredicateRecipeBase *PredecessorPredicate,
                        BasicBlock *From, BasicBlock *To)
      : VPEdgePredicateRecipeBase(VPEdgePredicateRecipeSC, nullptr,
                                  PredecessorPredicate),
        FromBB(From), ToBB(To) {}

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPBlockPredicatesRecipeSC;
  }

  void execute(VPTransformState &State) override;
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG) override;

  void dump(raw_ostream &OS) const override;

  void dump() const override { dump(errs()); }
#endif

  void print(raw_ostream &OS, const Twine &Indent) const override;

private:
  BasicBlock *FromBB;
  BasicBlock *ToBB;
};

/// A VPIfTruePredicateRecipe is a concrete recipe which represents the
/// edge-predicate of the true-edged if-statement case.
class VPIfTruePredicateRecipe : public VPEdgePredicateRecipeBase {

public:
  /// Construct a VPIfTruePredicateRecipe.
  VPIfTruePredicateRecipe(VPValue *CV,
                          VPPredicateRecipeBase *PredecessorPredicate,
                          BasicBlock *From, BasicBlock *To)
      : VPEdgePredicateRecipeBase(VPIfTruePredicateRecipeSC, CV,
                                  PredecessorPredicate),
        FromBB(From), ToBB(To) {}

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPIfTruePredicateRecipeSC;
  }

  void execute(VPTransformState &State) override;
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG) override;

  void dump(raw_ostream &OS) const override;

  void dump() const override { dump(errs()); }
#endif

  void print(raw_ostream &OS, const Twine &Indent) const override;

private:
  BasicBlock *FromBB;
  BasicBlock *ToBB;
};

/// A VPIfFalsePredicateRecipe is a concrete recipe which represents the
/// edge-predicate of the false-edged if-statement case.
class VPIfFalsePredicateRecipe : public VPEdgePredicateRecipeBase {
public:
  /// Construct a VPIfFalsePredicateRecipe.
  VPIfFalsePredicateRecipe(VPValue *CV,
                           VPPredicateRecipeBase *PredecessorPredicate,
                           BasicBlock *From, BasicBlock *To)
      : VPEdgePredicateRecipeBase(VPIfFalsePredicateRecipeSC, CV,
                                  PredecessorPredicate),
        FromBB(From), ToBB(To) {}

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPIfFalsePredicateRecipeSC;
  }

  void execute(VPTransformState &State) override;
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG) override;

  void dump(raw_ostream &OS) const override;

  void dump() const override { dump(errs()); }
#endif

  void print(raw_ostream &OS, const Twine &Indent) const override;

private:
  BasicBlock *FromBB;
  BasicBlock *ToBB;
};

/// VPBlockBase is the building block of the Hierarchical CFG. A VPBlockBase
/// can be either a VPBasicBlock or a VPRegionBlock.
///
/// The Hierarchical CFG is a control-flow graph whose nodes are basic-blocks
/// or Hierarchical CFG's. The Hierarchical CFG data structure we use is similar
/// to the Tile Tree [1], where cross-Tile edges are lifted to connect Tiles
/// instead of the original basic-blocks as in Sharir [2], promoting the Tile
/// encapsulation. We use the terms Region and Block rather than Tile [1] to
/// avoid confusion with loop tiling.
///
/// [1] "Register Allocation via Hierarchical Graph Coloring", David Callahan
/// and Brian Koblenz, PLDI 1991
///
/// [2] "Structural analysis: A new approach to flow analysis in optimizing
/// compilers", M. Sharir, Journal of Computer Languages, Jan. 1980
///
/// Note that in contrast to the IR BasicBlock, a VPBlockBase models its
/// control-flow edges with successor and predecessor VPBlockBase directly,
/// rather than through a Terminator branch or through predecessor branches that
/// Use the VPBlockBase.
class VPBlockBase {
  friend class VPBlockUtils;

private:
  const unsigned char VBID; // Subclass identifier (for isa/dyn_cast).

  std::string Name;

  /// The immediate VPRegionBlock which this VPBlockBase belongs to, or null if
  /// it is a topmost VPBlockBase.
  class VPRegionBlock *Parent = nullptr;

  /// List of predecessor blocks.
  SmallVector<VPBlockBase *, 2> Predecessors;

  /// List of successor blocks.
  SmallVector<VPBlockBase *, 2> Successors;

  /// Successor selector, null for zero or single successor blocks.
  VPValue *CondBit = nullptr;

  /// holds a predicate for a VPBlock.
  VPPredicateRecipeBase *PredicateRecipe = nullptr;

#if INTEL_CUSTOMIZATION
public:
#endif
  /// \brief Add \p Successor as the last successor to this block.
  void appendSuccessor(VPBlockBase *Successor) {
    assert(Successor && "Cannot add nullptr successor!");
    Successors.push_back(Successor);
  }

  /// \brief Add \p Predecessor as the last predecessor to this block.
  void appendPredecessor(VPBlockBase *Predecessor) {
    assert(Predecessor && "Cannot add nullptr predecessor!");
    Predecessors.push_back(Predecessor);
  }

  /// \brief Remove \p Predecessor from the predecessors of this block.
  void removePredecessor(VPBlockBase *Predecessor) {
    auto Pos = std::find(Predecessors.begin(), Predecessors.end(), Predecessor);
    assert(Pos && "Predecessor does not exist");
    Predecessors.erase(Pos);
  }

  /// \brief Remove \p Successor from the successors of this block.
  void removeSuccessor(VPBlockBase *Successor) {
    auto Pos = std::find(Successors.begin(), Successors.end(), Successor);
    assert(Pos && "Successor does not exist");
    Successors.erase(Pos);
  }

protected:
  VPBlockBase(const unsigned char SC, const std::string &N)
      : VBID(SC), Name(N) {}

public:
  /// An enumeration for keeping track of the concrete subclass of VPBlockBase
  /// that is actually instantiated. Values of this enumeration are kept in the
  /// VPBlockBase classes VBID field. They are used for concrete type
  /// identification.
#if INTEL_CUSTOMIZATION
  typedef enum {
    VPBasicBlockSC,
    VPRegionBlockSC,
    VPLoopRegionSC,
    VPLoopRegionHIRSC
  } VPBlockTy;
#else
  typedef enum { VPBasicBlockSC, VPRegionBlockSC } VPBlockTy;
#endif
  virtual ~VPBlockBase() {}

  const std::string &getName() const { return Name; }

  /// \return an ID for the concrete type of this object.
  /// This is used to implement the classof checks. This should not be used
  /// for any other purpose, as the values may change as LLVM evolves.
  unsigned getVPBlockID() const { return VBID; }

  VPRegionBlock *getParent() { return Parent; }
  const VPRegionBlock *getParent() const { return Parent; }

  void setParent(VPRegionBlock *P) { Parent = P; }

  /// \return the VPBasicBlock that is the entry of this VPBlockBase,
  /// recursively, if the latter is a VPRegionBlock. Otherwise, if this
  /// VPBlockBase is a VPBasicBlock, it is returned.
  const class VPBasicBlock *getEntryBasicBlock() const;

  /// \return the VPBasicBlock that is the exit of this VPBlockBase,
  /// recursively, if the latter is a VPRegionBlock. Otherwise, if this
  /// VPBlockBase is a VPBasicBlock, it is returned.
  const class VPBasicBlock *getExitBasicBlock() const;
  class VPBasicBlock *getExitBasicBlock();

  const SmallVectorImpl<VPBlockBase *> &getSuccessors() const {
    return Successors;
  }

  const SmallVectorImpl<VPBlockBase *> &getPredecessors() const {
    return Predecessors;
  }

  SmallVectorImpl<VPBlockBase *> &getSuccessors() { return Successors; }

  SmallVectorImpl<VPBlockBase *> &getPredecessors() { return Predecessors; }

#if INTEL_CUSTOMIZATION
  VPBlockBase *getSingleSuccessor() {
    if (Successors.size() != 1)
      return nullptr;
    return *Successors.begin();
  }

  VPBlockBase *getSinglePredecessor() {
    if (Predecessors.size() != 1)
      return nullptr;
    return *Predecessors.begin();
  }

  size_t getNumSuccessors() const { return Successors.size(); }

  size_t getNumPredecessors() const { return Predecessors.size(); }
#endif // INTEL_CUSTOMIZATION

  /// \return the successor of this VPBlockBase if it has a single successor.
  /// Otherwise return a null pointer.
  VPBlockBase *getSingleSuccessor() const {
    return (Successors.size() == 1 ? *Successors.begin() : nullptr);
  }

  /// \return the predecessor of this VPBlockBase if it has a single
  /// predecessor. Otherwise return a null pointer.
  VPBlockBase *getSinglePredecessor() const {
    return (Predecessors.size() == 1 ? *Predecessors.begin() : nullptr);
  }

#if INTEL_CUSTOMIZATION
  /// If this basic block has a unique predecessor block, return the block,
  /// otherwise return a null pointer. Note that unique predecessor doesn't
  /// mean single edge, there can be multiple edges from the unique predecessor
  /// to this block (for example a switch statement with multiple cases having
  /// the same destination).
  const VPBlockBase *getUniquePredecessor() const {
    auto PI = Predecessors.begin();
    auto E = Predecessors.end();
    if (PI == E)
      return nullptr; // No preds.
    const VPBlockBase *PredBB = *PI;
    ++PI;
    for (; PI != E; ++PI) {
      if (*PI != PredBB)
        return nullptr;
      // The same predecessor appears multiple times in the predecessor list.
      // This is OK.
    }
    return PredBB;
  }
#endif // INTEL_CUSTOMIZATION

  /// Returns the closest ancestor starting from "this", which has successors.
  /// Returns the root ancestor if all ancestors have no successors.
  VPBlockBase *getAncestorWithSuccessors();

  /// Returns the closest ancestor starting from "this", which has predecessors.
  /// Returns the root ancestor if all ancestors have no predecessors.
  VPBlockBase *getAncestorWithPredecessors();

  /// \return the successors either attached directly to this VPBlockBase or, if
  /// this VPBlockBase is the exit block of a VPRegionBlock and has no
  /// successors of its own, search recursively for the first enclosing
  /// VPRegionBlock that has successors and return them. If no such
  /// VPRegionBlock exists, return the (empty) successors of the topmost
  /// VPBlockBase reached.
  const SmallVectorImpl<VPBlockBase *> &getHierarchicalSuccessors() {
    return getAncestorWithSuccessors()->getSuccessors();
  }

  /// \return the hierarchical successor of this VPBlockBase if it has a single
  /// hierarchical successor. Otherwise return a null pointer.
  VPBlockBase *getSingleHierarchicalSuccessor() {
    return getAncestorWithSuccessors()->getSingleSuccessor();
  }

  /// \return the predecessors either attached directly to this VPBlockBase or,
  /// if this VPBlockBase is the entry block of a VPRegionBlock and has no
  /// predecessors of its own, search recursively for the first enclosing
  /// VPRegionBlock that has predecessors and return them. If no such
  /// VPRegionBlock exists, return the (empty) predecessors of the topmost
  /// VPBlockBase reached.
  const SmallVectorImpl<VPBlockBase *> &getHierarchicalPredecessors() {
    return getAncestorWithPredecessors()->getPredecessors();
  }

  /// \return the hierarchical predecessor of this VPBlockBase if it has a
  /// single hierarchical predecessor. Otherwise return a null pointer.
  VPBlockBase *getSingleHierarchicalPredecessor() {
    return getAncestorWithPredecessors()->getSinglePredecessor();
  }

#if INTEL_CUSTOMIZATION
  // Please, do not use setSuccessor and setTwoSuccessors in VPO Vectorizer.
  // Depending on what you need, you may want to use connectBlocks or
  // insertBlockBefore and insertBlockAfter. appendBlockSuccessor,
  // appendBlockPredecessor, setBlockSuccessor and setBlockTwoSuccessors are
  // also available but their use should be less common. Original setSuccessor
  // and setTwoSuccessors are also setting predecessors and parent, which is
  // known to cause problems:
  //  1. Predecessors for original LLVM CFG must be appended in the right order
  //  and not following successors' order.
  //  2. If Block's parent is wrong, it will be propagated to Successor anyway.
#endif

  /// connectBlocks should be used instead of this function when possible.
  /// Set a given VPBlockBase \p Successor as the single successor of this
  /// VPBlockBase. This VPBlockBase is not added as predecessor of \p Successor.
  /// This VPBlockBase must have no successors.
  void setOneSuccessor(VPBlockBase *Successor) {
    assert(Successors.empty() && "Setting one successor when others exist.");
    appendSuccessor(Successor);
  }

  /// connectBlocks should be used instead of this function when possible.
  /// Set two given VPBlockBases \p IfTrue and \p IfFalse to be the two
  /// successors of this VPBlockBase. This VPBlockBase is not added as
  /// predecessor of \p IfTrue or \p IfFalse. This VPBlockBase must have no
  /// successors. \p ConditionV is set as successor selector.
  void setTwoSuccessors(VPValue *ConditionV, VPBlockBase *IfTrue,
                        VPBlockBase *IfFalse, VPlan *Plan) {
    assert(Successors.empty() && "Setting two successors when others exist.");
    setCondBit(ConditionV, Plan);
    appendSuccessor(IfTrue);
    appendSuccessor(IfFalse);
  }

  /// Set each VPBasicBlock in \p NewPreds as predecessor of this VPBlockBase.
  /// This VPBlockBase must have no predecessors. This VPBlockBase is not added
  /// as successor of any VPBasicBlock in \p NewPreds.
  void setPredecessors(ArrayRef<VPBlockBase *> NewPreds) {
    assert(Predecessors.empty() && "Block predecessors already set.");
    for (auto *Pred : NewPreds)
      appendPredecessor(Pred);
  }

#if INTEL_CUSTOMIZATION
  /// Remove all the predecessor of this block.
  void clearPredecessors() { Predecessors.clear(); }

  /// Remove all the successors of this block and set to null its condition bit
  /// recipe.
  void clearSuccessors() {
    Successors.clear();
    CondBit = nullptr;
  }
#endif

  /// \return the condition bit selecting the successor.
  VPValue *getCondBit() { return CondBit; }

  const VPValue *getCondBit() const { return CondBit; }

#if INTEL_CUSTOMIZATION
  void setCondBit(VPValue *CB, VPlan *Plan);
#else
  void setCondBit(VPValue *CB) { CondBit = CB; }
#endif

  VPPredicateRecipeBase *getPredicateRecipe() const { return PredicateRecipe; }

  void setPredicateRecipe(VPPredicateRecipeBase *R) { PredicateRecipe = R; }

  /// The method which generates all new IR instructions that correspond to
  /// this VPBlockBase in the vectorized version, thereby "executing" the VPlan.
  virtual void execute(struct VPTransformState *State) = 0;
#if INTEL_CUSTOMIZATION
  virtual void executeHIR(VPOCodeGenHIR *CG) = 0;
#endif


  // Delete all blocks reachable from a given VPBlockBase, inclusive.
  static void deleteCFG(VPBlockBase *Entry);

  // Quick hack to get pulldown to compile. This needs more serious
  // consideration.
  bool isLegalToHoistInto() { return true; }

#if INTEL_CUSTOMIZATION
  void printAsOperand(raw_ostream &OS, bool PrintType) const {
    formatted_raw_ostream FOS(OS);
    print(FOS, 0);
  }

  void print(raw_ostream &OS) const {
    formatted_raw_ostream FOS(OS);
    print(FOS, 0);
  }

  void print(formatted_raw_ostream &OS, unsigned Depth) const {
    std::string Indent((Depth * 4), ' ');
    OS << Indent << getName();
  }

  virtual void dump() const = 0;

  virtual void dump(raw_ostream &OS, unsigned Indent = 0) const = 0;
#endif
};

#if INTEL_CUSTOMIZATION
/// A VPPhiValueRecipe is a recipe which represents a new Phi in VPlan to
/// facilitate the alteration of VPlan from its original source coded form.
/// Currently the elements of the phi are constants in-order to generate the
/// needed \phi for the single-exit loop massaging. However, this phi can be
/// further enhanced to handle any type of value.
class VPPhiValueRecipe : public VPRecipeBase {
public:
  VPPhiValueRecipe() : VPRecipeBase(VPPhiValueSC), Incoming(), Phi(nullptr) {}

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPRecipeBase *V) {
    return V->getVPRecipeID() == VPRecipeBase::VPLiveInBranchSC;
  }

  /// The method clones a uniform instruction that calculates condition
  /// for uniform branch.
  void execute(VPTransformState &State) override {}
  void executeHIR(VPOCodeGenHIR *CG) override {}

  /// Return the phi value after vectorization.
  Value *getValue(void) const {
    return Phi;
  }

  /// Adds a new element to the resulting \phi.
  void addIncomingValue(VPConstantRecipe IncomingValue,
    VPBlockBase* IncomingBlock) {
    Incoming.push_back(IncomingPair(IncomingValue, IncomingBlock));
  }

  /// Print the recipe.
  void print(raw_ostream &OS, const Twine &Indent) const override {
    OS << " +\n" << Indent << "\"Phi ";

    for (auto item : Incoming) {
      OS << "[";
      item.first.print(OS, Indent);
      OS << ", " << item.second->getName() << "] ";
    }

    OS << "\\l\"";
  }

  void dump(raw_ostream &OS) const override {
    OS << "Phi ";
    for (auto Item : Incoming) {
      Item.first.dump(OS);
      OS << ", " << Item.second->getName() << " ";
    }
    OS << "\n";
  }
  void dump() const override {
    dump(errs());
  }

  StringRef getName() const { return "Phi Recipe"; };

  ~VPPhiValueRecipe() {
    Phi->deleteValue();
  }

private:
  typedef std::pair<VPConstantRecipe , VPBlockBase *> IncomingPair;
  SmallVector<IncomingPair, 4> Incoming;
  Value* Phi;
};
#endif //INTEL_CUSTOMIZATION

/// VPBasicBlock serves as the leaf of the Hierarchical CFG. It represents a
/// sequence of instructions that will appear consecutively in a basic block
/// of the vectorized version. The VPBasicBlock takes care of the control-flow
/// relations with other VPBasicBlock's and Regions. It holds a sequence of zero
/// or more VPRecipe's that take care of representing the instructions.
/// A VPBasicBlock that holds no VPRecipe's represents no instructions; this
/// may happen, e.g., to support disjoint Regions and to ensure Regions have a
/// single exit, possibly an empty one.
///
/// Note that in contrast to the IR BasicBlock, a VPBasicBlock models its
/// control-flow edges with successor and predecessor VPBlockBase directly,
/// rather than through a Terminator branch or through predecessor branches that
/// "use" the VPBasicBlock.
class VPBasicBlock : public VPBlockBase {
public:
  typedef iplist<VPRecipeBase> RecipeListTy;

private:
  /// The list of VPRecipes, held in order of instructions to generate.
  RecipeListTy Recipes;

public:
  /// Instruction iterators...
  typedef RecipeListTy::iterator iterator;
  typedef RecipeListTy::const_iterator const_iterator;
  typedef RecipeListTy::reverse_iterator reverse_iterator;
  typedef RecipeListTy::const_reverse_iterator const_reverse_iterator;

  //===--------------------------------------------------------------------===//
  /// Recipe iterator methods
  ///
  inline iterator begin() { return Recipes.begin(); }
  inline const_iterator begin() const { return Recipes.begin(); }
  inline iterator end() { return Recipes.end(); }
  inline const_iterator end() const { return Recipes.end(); }

  inline reverse_iterator rbegin() { return Recipes.rbegin(); }
  inline const_reverse_iterator rbegin() const { return Recipes.rbegin(); }
  inline reverse_iterator rend() { return Recipes.rend(); }
  inline const_reverse_iterator rend() const { return Recipes.rend(); }

  inline size_t size() const { return Recipes.size(); }
  inline bool empty() const { return Recipes.empty(); }
  inline const VPRecipeBase &front() const { return Recipes.front(); }
  inline VPRecipeBase &front() { return Recipes.front(); }
  inline const VPRecipeBase &back() const { return Recipes.back(); }
  inline VPRecipeBase &back() { return Recipes.back(); }

  /// \brief Return the underlying instruction list container.
  ///
  /// Currently you need to access the underlying instruction list container
  /// directly if you want to modify it.
  const RecipeListTy &getInstList() const { return Recipes; }
  RecipeListTy &getInstList() { return Recipes; }

  /// \brief Returns a pointer to a member of the instruction list.
  static RecipeListTy VPBasicBlock::*getSublistAccess(VPRecipeBase *) {
    return &VPBasicBlock::Recipes;
  }

  VPBasicBlock(const std::string &Name, VPRecipeBase *Recipe = nullptr)
      : VPBlockBase(VPBasicBlockSC, Name), CBlock(nullptr), TBlock(nullptr),
        FBlock(nullptr), OriginalBB(nullptr) {
    if (Recipe)
      appendRecipe(Recipe);
  }

  ~VPBasicBlock() { Recipes.clear(); }

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPBlockBase *V) {
    return V->getVPBlockID() == VPBlockBase::VPBasicBlockSC;
  }

  void insert(VPRecipeBase *Recipe, iterator InsertPt) {
    assert(Recipe && "No recipe to append.");
    assert(!Recipe->Parent && "Recipe already in VPlan");
    Recipe->Parent = this;
    Recipes.insert(InsertPt, Recipe);
  }

  /// Augment the existing recipes of a VPBasicBlock with an additional
  /// \p Recipe as the last recipe.
  void appendRecipe(VPRecipeBase *Recipe) { insert(Recipe, end()); }

#if INTEL_CUSTOMIZATION
  /// Add \p Recipe after \p After. If \p After is null, \p Recipe will be
  /// inserted as the first recipe.
  void addRecipeAfter(VPRecipeBase *Recipe, VPRecipeBase *After) {
    Recipe->Parent = this;
    if (!After) {
      Recipes.insert(Recipes.begin(), Recipe);
    } else {
      Recipes.insertAfter(After->getIterator(), Recipe);
    }
  }

  /// Augment the existing recipes of a VPBasicBlock with an additional
  /// \p Recipe at a position given by an existing recipe \p Before. If
  /// \p Before is null, \p Recipe is appended as the last recipe.
  void addRecipe(VPRecipeBase *Recipe, VPRecipeBase *Before = nullptr) {
    Recipe->Parent = this;
    if (!Before) {
      Recipes.insert(Recipes.end(), Recipe);
    } else {
      assert(Before->Parent == this &&
             "Insertion before point not in this basic block.");
      Recipes.insert(Before->getIterator(), Recipe);
    }
  }

  void moveConditionalEOBTo(VPBasicBlock *ToBB, VPlan *Plan);
#endif

  /// Remove the recipe from VPBasicBlock's recipes.
  // TODO: Please, note that this is actually destroying Recipe object. We
  // should replace 'erase' by 'remove' and revisit algorithms using
  // 'removeRecipe'.
  void removeRecipe(VPRecipeBase *Recipe) { Recipes.erase(Recipe); }

  /// Remove the recipe from VPBasicBlock's recipes and destroy Recipe object.
  void eraseRecipe(VPRecipeBase *Recipe) { Recipes.erase(Recipe); }

  /// The method which generates all new IR instructions that correspond to
  /// this VPBasicBlock in the vectorized version, thereby "executing" the
  /// VPlan.
  void execute(struct VPTransformState *State) override;
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG) override;
#endif

  /// Retrieve the list of VPRecipes that belong to this VPBasicBlock.
  const RecipeListTy &getRecipes() const { return Recipes; }
  RecipeListTy &getRecipes() { return Recipes; }
#if INTEL_CUSTOMIZATION
  void dump() const;
  void dump(raw_ostream &OS, unsigned Indent = 0) const;
  void setCBlock(BasicBlock *CB) { CBlock = CB; }
  void setFBlock(BasicBlock *FB) { FBlock = FB; }
  void setTBlock(BasicBlock *TB) { TBlock = TB; }
  BasicBlock *getCBlock() { return CBlock; }
  BasicBlock *getTBlock() { return TBlock; }
  BasicBlock *getFBlock() { return FBlock; }

  bool hasTrueEdge() { return CBlock && TBlock; }
  bool hasFalseEdge() { return CBlock && FBlock; }

  void setOriginalBB(BasicBlock *BB) { OriginalBB = BB; }
  BasicBlock *getOriginalBB() { return OriginalBB; }

private:
  BasicBlock *CBlock;
  BasicBlock *TBlock;
  BasicBlock *FBlock;
  BasicBlock *OriginalBB;
#endif
  /// Create an IR BasicBlock to hold the instructions vectorized from this
  /// VPBasicBlock, and return it. Update the CFGState accordingly.
#if INTEL_CUSTOMIZATION
  BasicBlock *createEmptyBasicBlock(VPTransformState *State);
#else
  BasicBlock *createEmptyBasicBlock(VPTransformState::CFGState &CFG);
#endif
};

/// VPRegionBlock represents a collection of VPBasicBlocks and VPRegionBlocks
/// which form a single-entry-single-exit subgraph of the CFG in the vectorized
/// code.
///
/// A VPRegionBlock may indicate that its contents are to be replicated several
/// times. This is designed to support predicated scalarization, in which a
/// scalar if-then code structure needs to be generated VF * UF times. Having
/// this replication indicator helps to keep a single VPlan for multiple
/// candidate VF's; the actual replication takes place only once the desired VF
/// and UF have been determined.
///
/// **Design principle:** when some additional information relates to an SESE
/// set of VPBlockBase, we use a VPRegionBlock to wrap them and attach the
/// information to it. For example, a VPRegionBlock can be used to indicate that
/// a scalarized SESE region is to be replicated, and that a vectorized SESE
/// region can retain its internal control-flow, independent of the control-flow
/// external to the region.
class VPRegionBlock : public VPBlockBase {
  friend class VPBlockUtils;

private:
  /// Hold the Single Entry of the SESE region represented by the VPRegionBlock.
  VPBlockBase *Entry;

  /// Hold the Single Exit of the SESE region represented by the VPRegionBlock.
  VPBlockBase *Exit;

  /// A VPRegionBlock can represent either a single instance of its
  /// VPBlockBases, or multiple (VF * UF) replicated instances. The latter is
  /// used when the internal SESE region handles a single scalarized lane.
  bool IsReplicator;

#if INTEL_CUSTOMIZATION
  /// Holds the number of VPBasicBlocks within the region. It is necessary for
  /// dominator tree.
  unsigned Size;

  /// Holds whether the control flow within the region is divergent or uniform.
  bool IsDivergent;

  /// Traverse all the region VPBasicBlocks to recompute Size
  void recomputeSize();
#endif

#if INTEL_CUSTOMIZATION
  /// Dominator Tree for the region
  VPDominatorTree *RegionDT;
  /// Post-Dominator Tree for the region
  VPPostDominatorTree *RegionPDT;
#endif

public:
  /// An enumeration for keeping track of the concrete subclass of VPRegionBlock
  /// that is actually instantiated. Values of this enumeration are kept in the
  /// VPRegionBlock classes VRID field. They are used for concrete type
  /// identification.
#if INTEL_CUSTOMIZATION
  VPRegionBlock(const unsigned char SC, const std::string &Name,
                bool IsReplicator = false)
      : VPBlockBase(SC, Name), Entry(nullptr), Exit(nullptr),
        IsReplicator(IsReplicator), Size(0), IsDivergent(true),
        RegionDT(nullptr), RegionPDT(nullptr) {}
#else
  VPRegionBlock(const std::string &Name, bool IsReplicator = false)
      : VPBlockBase(VPRegionBlockSC, Name), Entry(nullptr), Exit(nullptr),
        IsReplicator(IsReplicator) {}
#endif

  ~VPRegionBlock();

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPBlockBase *V) {
#if INTEL_CUSTOMIZATION
    return V->getVPBlockID() == VPBlockBase::VPRegionBlockSC ||
           V->getVPBlockID() == VPBlockBase::VPLoopRegionSC ||
           V->getVPBlockID() == VPBlockBase::VPLoopRegionHIRSC;
#else
    return V->getVPBlockID() == VPBlockBase::VPRegionBlockSC;
#endif
  }

  const VPBlockBase *getEntry() const { return Entry; }
  VPBlockBase *getEntry() { return Entry; }

  /// Set \p EntryBlock as the entry VPBlockBase of this VPRegionBlock. \p
  /// EntryBlock must have no predecessors.
  void setEntry(VPBlockBase *EntryBlock) {
    assert(EntryBlock->getPredecessors().empty() &&
           "Entry block cannot have predecessors.");
    Entry = EntryBlock;
    EntryBlock->setParent(this);
  }

  const VPBlockBase *getExit() const { return Exit; }
  VPBlockBase *getExit() { return Exit; }

  /// Set \p ExitBlock as the exit VPBlockBase of this VPRegionBlock. \p
  /// ExitBlock must have no successors.
  void setExit(VPBlockBase *ExitBlock) {
    assert(ExitBlock->getSuccessors().empty() &&
           "Exit block cannot have successors.");
    Exit = ExitBlock;
    ExitBlock->setParent(this);
  }

#if INTEL_CUSTOMIZATION
  unsigned getSize() const { return Size; }

  void setSize(unsigned Sz) { Size = Sz; }

  bool isDivergent() const { return IsDivergent; }

  void setDivergent(bool IsDiv) { IsDivergent = IsDiv; }

  // TODO: This is weird. For some reason, DominatorTreeBase is using
  // A->getParent()->front() instead of using GraphTraints::getEntry. We may
  // need to report it.
  VPBlockBase &front() const { return *Entry; }
#endif
  /// An indicator if the VPRegionBlock represents single or multiple instances.
  bool isReplicator() const { return IsReplicator; }

  void setReplicator(bool ToReplicate) { IsReplicator = ToReplicate; }

#if INTEL_CUSTOMIZATION
  /// Getters for Dominator Tree
  VPDominatorTree *getDT(void) { return RegionDT; }
  const VPDominatorTree *getDT(void) const { return RegionDT; }
  /// Getter for Post-Dominator Tree
  VPPostDominatorTree *getPDT(void) { return RegionPDT; }

  /// Compute the Dominator Tree for this region
  void computeDT(void);

  /// Compute the Post-Dominator Tree for this region
  void computePDT(void);

  void getOrderedBlocks(std::vector<const VPBlockBase *> &Blocks) const;
  void dump() const;
  void dump(raw_ostream &OS, unsigned Indent = 0) const;
#endif

  /// The method which generates the new IR instructions that correspond to
  /// this VPRegionBlock in the vectorized version, thereby "executing" the
  /// VPlan.
  void execute(struct VPTransformState *State) override;
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG) override;
#endif
};

/// VPlan models a candidate for vectorization, encoding various decisions take
/// to produce efficient output IR, including which branches, basic-blocks and
/// output IR instructions to generate, and their cost. VPlan holds a
/// Hierarchical-CFG of VPBasicBlocks and VPRegionBlocks rooted at an Entry
/// VPBlock.
class VPlan {
  friend class VPlanPrinter;

private:
#if INTEL_CUSTOMIZATION
  VPLoopInfo *VPLInfo = nullptr;
  VPlanDivergenceAnalysis *VPlanDA = nullptr;
#endif

#if INTEL_CUSTOMIZATION
protected:
#endif
  /// Hold the single entry to the Hierarchical CFG of the VPlan.
  VPBlockBase *Entry;

#if INTEL_CUSTOMIZATION
  /// The IR instructions which are to be transformed to fill the vectorized
  /// version are held as ingredients inside the VPRecipe's of the VPlan. Hold a
  /// reverse mapping to locate the VPRecipe an IR instruction belongs to. This
  /// serves optimizations that operate on the VPlan.
  DenseMap<Instruction *, VPRecipeBase *> Inst2Recipe;

  /// Keep track of the VPBasicBlock users of a CondBit.
  DenseMap<VPValue *, std::set<const VPBlockBase *>> CondBitUsers;
#endif // INTEL_CUSTOMIZATION

  /// Holds the VFs applicable to this VPlan.
  SmallSet<unsigned, 2> VFs;

  /// Holds the name of the VPlan, for printing.
  std::string Name;

#if INTEL_CUSTOMIZATION
  /// Holds all the VPConstants created for this VPlan.
  DenseSet<VPConstant*> VPConstants;

  // TODO: We should follow the same approach for VPExternalDefs as for
  // VPConstant (i.e. having a single instance per structurally equal external
  // definition). However, it is better to wait until we have the right
  // class to represent external definitions (VPLiveIn class or similar) because
  // they need a specific '<' operator and guarantee that the class is immutable
  // after the construction. For now, the following data structure is used only
  // for memory deallocation purposes.
  /// Holds all the external definitions created for this VPlan.
  SmallSet<VPValue *, 32> VPExternalDefs;

  std::shared_ptr<VPLoopAnalysisBase> VPLA;
#else
  /// Holds a mapping between Values and their corresponding VPValue inside
  /// VPlan.
  Value2VPValueTy Value2VPValue;
#endif

public:
#if INTEL_CUSTOMIZATION
  /// Keep the uniform VPValues here, so that we won't have to check
  /// the underlying IR.
  // TODO: To be moved to the Divergence Analysis Infrastructure
  UniformsTy UniformCBVs;
  VPlan(std::shared_ptr<VPLoopAnalysisBase> VPLA, VPBlockBase *Entry = nullptr)
      : Entry(Entry), VPLA(VPLA) {}
#endif
  VPlan(VPBlockBase *Entry = nullptr) : Entry(Entry) {}

  ~VPlan() {
    if (Entry)
      VPBlockBase::deleteCFG(Entry);
#if INTEL_CUSTOMIZATION
    if (VPLInfo)
      delete (VPLInfo);
    if (VPlanDA)
      delete VPlanDA;
    for (auto *VPConst : VPConstants)
      delete VPConst;
    for (auto *VPInst : VPExternalDefs)
      delete VPInst;
#else
    for (auto &MapEntry : Value2VPValue)
      delete MapEntry.second;
#endif
  }

  /// Generate the IR code for this VPlan.
  void execute(struct VPTransformState *State);
#if INTEL_CUSTOMIZATION
  void executeHIR(VPOCodeGenHIR *CG);
  VPLoopInfo *getVPLoopInfo() { return VPLInfo; }

  VPLoopAnalysisBase* getVPLoopAnalysis(void) const { return VPLA.get(); }

  const VPLoopInfo *getVPLoopInfo() const { return VPLInfo; }

  void setVPLoopInfo(VPLoopInfo *VPLI) { VPLInfo = VPLI; }

  void setVPlanDA(VPlanDivergenceAnalysis *VPDA) { VPlanDA = VPDA; }
#endif // INTEL_CUSTOMIZATION

  VPBlockBase *getEntry() { return Entry; }
  const VPBlockBase *getEntry() const { return Entry; }

  void setEntry(VPBlockBase *Block) { Entry = Block; }

#if INTEL_CUSTOMIZATION // Old interfaces. To be removed.
  void setInst2Recipe(Instruction *I, VPRecipeBase *R) { Inst2Recipe[I] = R; }

  void resetInst2Recipe(Instruction *I) { Inst2Recipe.erase(I); }

  void resetInst2RecipeRange(BasicBlock::iterator B, BasicBlock::iterator E) {
    for (auto It = B; It != E; ++It) {
      resetInst2Recipe(&*It);
    }
  }

  std::set<const VPBlockBase *> &getCondBitUsers(VPValue *ConditionV) {
    return CondBitUsers[ConditionV];
  }

  void removeCondBitUsers(VPValue *ConditionV) {
    CondBitUsers[ConditionV].clear();
  }

  void setCondBitUser(VPValue *ConditionV, const VPBlockBase *Block) {
    CondBitUsers[ConditionV].insert(Block);
  }

  void printInst2Recipe();

  /// Print (in text format) VPlan blocks in order based on dominator tree.
  void dump(raw_ostream &OS) const;
  void dump() const;
#endif // INTEL_CUSTOMIZATION

  void addVF(unsigned VF) { VFs.insert(VF); }

  bool hasVF(unsigned VF) { return VFs.count(VF); }

  const std::string &getName() const { return Name; }

  void setName(const Twine &newName) { Name = newName.str(); }

#if INTEL_CUSTOMIZATION
  /// Create a new VPConstant for \p Const if it doesn't exist or retrieve the
  /// existing one.
  VPConstant *getVPConstant(Constant *Const) {
    // Dropping the const qualifier is not a problem because VPConstant is
    // immutable.
    return *VPConstants.insert(new VPConstant(Const)).first;
  }

  /// Add \p VPVal to the pool of external definitions if it's not already
  /// in the pool.
  void addExternalDef(VPValue *VPVal) {
    VPExternalDefs.insert(VPVal);
  }
#else
  void addVPValue(Value &V) {
    if (!Value2VPValue.count(&V))
      Value2VPValue[&V] = new VPValue();
  }

  VPValue *getVPValue(Value &V) { return Value2VPValue[&V]; }
#endif

private:
  /// Add to the given dominator tree the header block and every new basic block
  /// that was created between it and the latch block, inclusive.
  static void updateDominatorTree(class DominatorTree *DT,
                                  BasicBlock *LoopPreHeaderBB,
                                  BasicBlock *LoopLatchBB);
};

#if INTEL_CUSTOMIZATION
class VPLoopRegion : public VPRegionBlock {
private:
  // Pointer to VPLoopInfo analysis information for this loop region
  VPLoop *VPLp;

protected:
  VPLoopRegion(const unsigned char SC, const std::string &Name, VPLoop *Lp)
      : VPRegionBlock(SC, Name), VPLp(Lp) {}

public:
  VPLoopRegion(const std::string &Name, VPLoop *Lp)
      : VPRegionBlock(VPLoopRegionSC, Name), VPLp(Lp) {}

  const VPLoop *getVPLoop() const { return VPLp; }
  VPLoop *getVPLoop() { return VPLp; }

  /// Method to support type inquiry through isa, cast, and dyn_cast.
  static inline bool classof(const VPBlockBase *B) {
    return B->getVPBlockID() == VPBlockBase::VPLoopRegionSC ||
           B->getVPBlockID() == VPBlockBase::VPLoopRegionHIRSC;
  }
};

#endif

/// VPlanPrinter prints a given VPlan to a given output stream. The printing is
/// indented and follows the dot format.
class VPlanPrinter {
  friend inline raw_ostream &operator<<(raw_ostream &OS, const VPlan &Plan);
  friend inline raw_ostream &operator<<(raw_ostream &OS,
                                        const struct VPlanIngredient &I);

private:
  raw_ostream &OS;
  const VPlan &Plan;
  unsigned Depth;
  unsigned TabWidth = 2;
  std::string Indent;

  unsigned BID = 0;

  SmallDenseMap<const VPBlockBase *, unsigned> BlockID;

  /// Handle indentation.
  void bumpIndent(int b) { Indent = std::string((Depth += b) * TabWidth, ' '); }

  /// Print a given \p Block of the Plan.
  void dumpBlock(const VPBlockBase *Block);

  /// Print the information related to the CFG edges going out of a given
  /// \p Block, followed by printing the successor blocks themselves.
  void dumpEdges(const VPBlockBase *Block);

  /// Print a given \p BasicBlock, including its VPRecipes, followed by printing
  /// its successor blocks.
  void dumpBasicBlock(const VPBasicBlock *BasicBlock);

  /// Print a given \p Region of the Plan.
  void dumpRegion(const VPRegionBlock *Region);

  unsigned getOrCreateBID(const VPBlockBase *Block) {
    return BlockID.count(Block) ? BlockID[Block] : BlockID[Block] = BID++;
  }

  const Twine getOrCreateName(const VPBlockBase *Block);

  const Twine getUID(const VPBlockBase *Block);

  /// Print the information related to a CFG edge between two VPBlockBases.
  void drawEdge(const VPBlockBase *From, const VPBlockBase *To, bool Hidden,
                const Twine &Label);

  VPlanPrinter(raw_ostream &O, const VPlan &P) : OS(O), Plan(P) {}

  void dump();

  static void printAsIngredient(raw_ostream &O, Value *V);
};

#if !INTEL_CUSTOMIZATION
inline raw_ostream &operator<<(raw_ostream &OS, const VPlanIngredient &I) {
  VPlanPrinter::printAsIngredient(OS, I.V);
  return OS;
}
#endif

inline raw_ostream &operator<<(raw_ostream &OS, const VPlan &Plan) {
  VPlanPrinter Printer(OS, Plan);
  Printer.dump();
  return OS;
}

#if INTEL_CUSTOMIZATION
// Set of print functions
inline raw_ostream &operator<<(raw_ostream &OS, const VPInstruction &I) {
  I.dump(OS);
  return OS;
}
inline raw_ostream &operator<<(raw_ostream &OS, const VPRecipeBase &R) {
  R.dump(OS);
  return OS;
}
inline raw_ostream &operator<<(raw_ostream &OS,
                               const VPBlockPredicateRecipe &P) {
  P.dump(OS);
  return OS;
}
inline raw_ostream &operator<<(raw_ostream &OS,
                               const VPEdgePredicateRecipe &P) {
  P.dump(OS);
  return OS;
}
inline raw_ostream &operator<<(raw_ostream &OS,
                               const VPIfTruePredicateRecipe &P) {
  P.dump(OS);
  return OS;
}
inline raw_ostream &operator<<(raw_ostream &OS,
                               const VPIfFalsePredicateRecipe &P) {
  P.dump(OS);
  return OS;
}
inline raw_ostream &operator<<(raw_ostream &OS, const VPBasicBlock &BB) {
  BB.dump(OS, 2);
  return OS;
}
inline raw_ostream &operator<<(raw_ostream &OS, const VPRegionBlock &RB) {
  RB.dump(OS, 2);
  return OS;
}

#endif // INTEL_CUSTOMIZATION

//===----------------------------------------------------------------------===//
// VPlan Utilities
//===----------------------------------------------------------------------===//

/// Class that provides utilities for VPBlockBases in VPlan.
class VPBlockUtils {
public:
  VPBlockUtils() = delete;

#if INTEL_CUSTOMIZATION
  /// Insert NewBlock in the HCFG before BlockPtr and update parent region
  /// accordingly
  static void insertBlockBefore(VPBlockBase *NewBlock, VPBlockBase *BlockPtr) {
    VPRegionBlock *ParentRegion = BlockPtr->getParent();

    movePredecessors(BlockPtr, NewBlock);
    NewBlock->setParent(ParentRegion);
    connectBlocks(NewBlock, BlockPtr);
    ++BlockPtr->Parent->Size;

    // If BlockPtr is parent region's entry, set BlockPtr as parent region's
    // entry
    if (ParentRegion->getEntry() == BlockPtr)
      ParentRegion->setEntry(NewBlock);
  }

  /// Insert NewBlock in the HCFG after BlockPtr and update parent region
  /// accordingly. If BlockPtr has more that one successors, its CondBit is
  /// propagated to NewBlock.
  static void insertBlockAfter(VPBlockBase *NewBlock, VPBlockBase *BlockPtr,
                               VPlan *Plan) {

    if (BlockPtr->getNumSuccessors() > 1) {
      VPBasicBlock *ThisBB = cast<VPBasicBlock>(BlockPtr);
      VPBasicBlock *ToBB = cast<VPBasicBlock>(NewBlock);
      ThisBB->moveConditionalEOBTo(ToBB, Plan);
    }

    VPRegionBlock *ParentRegion = BlockPtr->getParent();
    moveSuccessors(BlockPtr, NewBlock);
    NewBlock->setParent(ParentRegion);
    connectBlocks(BlockPtr, NewBlock);
    ++BlockPtr->Parent->Size;

    // If BlockPtr is parent region's exit, set BlockPtr as parent region's
    // exit
    if (ParentRegion->getExit() == BlockPtr)
      ParentRegion->setExit(NewBlock);
  }
#endif

  /// Connect VPBlockBases \p From and \p To bi-directionally. Append \p To to
  /// the successors of \p From and \p From to the predecessors of \p To. Both
  /// VPBlockBases must have the same parent, which can be null. Both
  /// VPBlockBases can be already connected to other VPBlockBases.
  static void connectBlocks(VPBlockBase *From, VPBlockBase *To) {
    assert((From->getParent() == To->getParent()) &&
           "Can't connect two block with different parents");
    assert(From->getNumSuccessors() < 2 &&
           "Blocks can't have more than two successors.");
    From->appendSuccessor(To);
    To->appendPredecessor(From);
  }

#if INTEL_CUSTOMIZATION
  /// Connect \p From to \p IfTrue and \p IfFalse bi-directionally. \p IfTrue
  /// and \p IfFalse are set as successors of \p From. \p From is set as
  /// predecessor of \p IfTrue and \p IfFalse. \p From must have no successors.
  static void connectBlocks(VPBlockBase *From, VPValue *ConditionV,
                            VPBlockBase *IfTrue, VPBlockBase *IfFalse,
                            VPlan *Plan) {
    From->setTwoSuccessors(ConditionV, IfTrue, IfFalse, Plan);
    IfTrue->appendPredecessor(From);
    IfFalse->appendPredecessor(From);
  }
#endif

  /// Disconnect VPBlockBases \p From and \p To bi-directionally. Remove \p To
  /// from the successors of \p From and \p From from the predecessors of \p To.
  static void disconnectBlocks(VPBlockBase *From, VPBlockBase *To) {
    assert(To && "Successor to disconnect is null.");
    From->removeSuccessor(To);
    To->removePredecessor(From);
  }

#if INTEL_CUSTOMIZATION
  // Replace \p OldSuccessor by \p NewSuccessor in Block's successor list.
  // \p NewSuccessor will be inserted in the same position as \p OldSuccessor.
  static void replaceBlockSuccessor(VPBlockBase *Block,
                                    VPBlockBase *OldSuccessor,
                                    VPBlockBase *NewSuccessor) {
    // Replace successor
    // TODO: Add VPBlockBase::replaceSuccessor. Let's not modify VPlan.h too
    // much by now
    auto &Successors = Block->getSuccessors();
    auto SuccIt = std::find(Successors.begin(), Successors.end(), OldSuccessor);
    assert(SuccIt != Successors.end() && "Successor not found");
    SuccIt = Successors.erase(SuccIt);
    Successors.insert(SuccIt, NewSuccessor);
  }

  // Replace \p OldPredecessor by \p NewPredecessor in Block's predecessor list.
  // \p NewPredecessor will be inserted in the same position as \p
  // OldPredecessor.
  static void replaceBlockPredecessor(VPBlockBase *Block,
                                      VPBlockBase *OldPredecessor,
                                      VPBlockBase *NewPredecessor) {
    // Replace predecessor
    // TODO: Add VPBlockBase::replacePredecessor. Let's not modify VPlan.h too
    // much by now
    auto &Predecessors = Block->getPredecessors();
    auto PredIt =
        std::find(Predecessors.begin(), Predecessors.end(), OldPredecessor);
    assert(PredIt != Predecessors.end() && "Predecessor not found");
    PredIt = Predecessors.erase(PredIt);
    Predecessors.insert(PredIt, NewPredecessor);
  }

  static void movePredecessor(VPBlockBase *Pred, VPBlockBase *From,
                              VPBlockBase *To) {
    replaceBlockSuccessor(Pred, From /*OldSuccessor*/, To /*NewSuccessor*/);
    To->appendPredecessor(Pred);
    From->removePredecessor(Pred);
  }

  static void movePredecessors(VPBlockBase *From, VPBlockBase *To) {
    auto &Predecessors = From->getPredecessors();

    for (auto &Pred : Predecessors) {
      replaceBlockSuccessor(Pred, From, To);
      To->appendPredecessor(Pred);
    }

    // Remove predecessors from From
    Predecessors.clear();
  }

  static void moveSuccessors(VPBlockBase *From, VPBlockBase *To) {
    auto &Successors = From->getSuccessors();

    for (auto &Succ : Successors) {
      replaceBlockPredecessor(Succ, From, To);
      To->appendSuccessor(Succ);
    }

    // Remove successors from From
    Successors.clear();
  }

  /// Returns true if the edge \p FromBlock -> \p ToBlock is a back-edge.
  static bool isBackEdge(const VPBlockBase *FromBlock,
                         const VPBlockBase *ToBlock, const VPLoopInfo *VPLI) {
    assert(FromBlock->getParent() == ToBlock->getParent() &&
           FromBlock->getParent() != nullptr && "Must be in same region");
    const VPLoop *FromLoop = VPLI->getLoopFor(FromBlock);
    const VPLoop *ToLoop = VPLI->getLoopFor(ToBlock);
    if (FromLoop == nullptr || ToLoop == nullptr || FromLoop != ToLoop) {
      return false;
    }
    // A back-edge is latch->header
    return (ToBlock == ToLoop->getHeader() && ToLoop->isLoopLatch(FromBlock));
  }

  /// Returns true if \p Block is a loop latch
  static bool blockIsLoopLatch(const VPBlockBase *Block,
                               const VPLoopInfo *VPLInfo) {

    if (const VPLoop *ParentVPL = VPLInfo->getLoopFor(Block)) {
      return ParentVPL->isLoopLatch(Block);
    }

    return false;
  }

  static VPBasicBlock *splitBlock(VPBlockBase *Block, VPLoopInfo *VPLInfo,
                                  VPDominatorTree &DomTree,
                                  VPPostDominatorTree &PostDomTree,
                                  VPlan *Plan);

  //===----------------------------------------------------------------------===//
  // VPRegionBlock specific Utilities
  //===----------------------------------------------------------------------===//

  /// Insert a \p Region in a HCFG using \p Entry and \p Exit blocks as Region's
  /// single entry and single exit. \p Entry and \p Exit blocks must be part of
  /// the HCFG and be in the same region. \p Region cannot be part of a HCFG.
  static void insertRegion(VPRegionBlock *Region, VPBlockBase *Entry,
                           VPBlockBase *Exit, bool RecomputeSize = true) {

    assert(Entry->getNumSuccessors() != 0 && "Entry must be in a HCFG");
    assert(Entry->getNumPredecessors() != 0 && "Exit must be in a HCFG");
    assert(Entry->getParent() && Exit->getParent() &&
           "Entry and Exit must have a parent region");
    assert(Entry->getParent() == Exit->getParent() &&
           "Entry and Exit must have the same parent region");
    assert(Exit->getParent()->getExit() != Exit &&
           "Exit node cannot be an exit node in another region");
    assert(!Region->getEntry() && "Region's entry must be null");
    assert(!Region->getExit() && "Region's exit must be null");
    assert(!Region->getNumSuccessors() && "Region cannot have successors");
    assert(!Region->getNumPredecessors() && "Region cannot have predecessors");

    VPRegionBlock *ParentRegion = Entry->getParent();

    // If Entry is parent region's entry, set Region as parent region's entry
    if (ParentRegion->getEntry() == Entry) {
      ParentRegion->setEntry(Region);
    } else {
      VPBlockUtils::movePredecessors(Entry, Region);
    }

    // moveSuccessors is propagating Exit's parent to Region
    VPBlockUtils::moveSuccessors(Exit, Region);
    Region->setEntry(Entry);
    Region->setExit(Exit);

    // Recompute region size and update parent
    if (RecomputeSize) {
      Region->recomputeSize();
      ParentRegion->Size -= Region->Size + 1 /*Region*/;
    }
  }
#endif // INTEL_CUSTOMIZATION
};

#if INTEL_CUSTOMIZATION
/// Class that provides utilities for VPValue and VPRecipe in VPlan.
class VPValueUtils {
public:
  VPValueUtils() = delete;

  //===----------------------------------------------------------------------===//
  // VPRecipe specific Utilities
  //===----------------------------------------------------------------------===//

  /// \brief Add \p Incoming predicate to \p BlockPred.
  static void appendIncomingToBlockPred(VPBlockPredicateRecipe *BlockPred,
                                        VPPredicateRecipeBase *Incoming) {
    if (Incoming)
      BlockPred->appendIncomingPredicate(Incoming);
  }

  /// \brief Remove \p Incoming predicate from \p BlockPred.
  static void removeIncomingFromBlockPred(VPBlockPredicateRecipe *BlockPred,
                                          VPPredicateRecipeBase *Incoming) {
    if (Incoming)
      BlockPred->removeIncomingPredicate(Incoming);
  }

  /// \brief Clear list of incoming predicates from \p BlockPred.
  static void clearIncomingsFromBlockPred(VPBlockPredicateRecipe *BlockPred) {
    BlockPred->clearIncomingPredicates();
  }
};
#endif // INTEL_CUSTOMIZATION

/// The VPlanUtils class provides common interfaces and functions that are
/// required across different VPlan classes like VPBlockBase, VPRegionBlock
/// and VPPredicateRecipe.
class VPlanUtils {
private:
  /// Unique ID generator.
  static std::atomic<unsigned> NextOrdinal;

public:
  VPlanUtils() = delete;

  /// Create a unique name for a new VPlan entity such as a VPBasicBlock or
  /// VPRegionBlock.
  static std::string createUniqueName(const char *Prefix) {
    std::string S;
    raw_string_ostream RSO(S);
    RSO << Prefix << NextOrdinal++;
    return RSO.str();
  }
};

/// A wrapper class to add VPlan related remarks for opt-report. Currently
/// the implementation is naive with a single method to add a remark for
/// a given LoopType loop.
//  TODO:
/// In the future this will be extended to record all vectorization related
/// remarks emitted by VPlan by mapping the remarks to underlying VPlan data
/// structures that represent a loop. For example:
///
/// VPLoopRegion MainLoop --> {"LOOP WAS VECTORIZED", "vector length: 4"}
/// VPLoopRegion RemainderLoop --> {"remainder loop was not vectorized"}
template <class LoopType> class VPlanOptReportBuilder {
  LoopOptReportBuilder &LORBuilder;

public:
  VPlanOptReportBuilder(LoopOptReportBuilder &LORB) : LORBuilder(LORB) {}

  /// Add a vectorization related remark for \p Lp. The remark message is
  /// identified by \p MsgID.
  template <typename... Args>
  void addRemark(LoopType *Lp, OptReportVerbosity::Level Verbosity,
                 unsigned MsgID, Args &&... args) {
    LORBuilder(*Lp).addRemark(Verbosity, loopopt::OptReportDiag::getMsg(MsgID),
                              std::forward<Args>(args)...);
  }
};

} // namespace vpo

//===----------------------------------------------------------------------===//
// GraphTraits specializations for VPlan H-CFG Control-Flow Graphs            //
//===----------------------------------------------------------------------===//

// The following set of template specializations implement GraphTraits to treat
// any VPBlockBase as a node in a graph of VPBlockBases. It's important to note
// that VPBlockBase traits don't recurse into VPRegionBlocks, i.e., if the
// VPBlockBase is a VPRegionBlock, this specialization provides access to its
// successors/predecessors but not to the blocks inside the region.

template <> struct GraphTraits<vpo::VPBlockBase *> {
  using NodeRef = vpo::VPBlockBase *;
  using ChildIteratorType = SmallVectorImpl<vpo::VPBlockBase *>::iterator;

  static NodeRef getEntryNode(NodeRef N) { return N; }

  static inline ChildIteratorType child_begin(NodeRef N) {
    return N->getSuccessors().begin();
  }

  static inline ChildIteratorType child_end(NodeRef N) {
    return N->getSuccessors().end();
  }
};

template <> struct GraphTraits<const vpo::VPBlockBase *> {
  using NodeRef = const vpo::VPBlockBase *;
  using ChildIteratorType = SmallVectorImpl<vpo::VPBlockBase *>::const_iterator;

  static NodeRef getEntryNode(NodeRef N) { return N; }

  static inline ChildIteratorType child_begin(NodeRef N) {
    return N->getSuccessors().begin();
  }

  static inline ChildIteratorType child_end(NodeRef N) {
    return N->getSuccessors().end();
  }
};

// Inverse order specialization for VPBlockBases. Predecessors are used instead
// of successors for the inverse traversal.
template <> struct GraphTraits<Inverse<vpo::VPBlockBase *>> {
  using NodeRef = vpo::VPBlockBase *;
  using ChildIteratorType = SmallVectorImpl<vpo::VPBlockBase *>::iterator;

  static NodeRef getEntryNode(Inverse<NodeRef> B) { return B.Graph; }

  static inline ChildIteratorType child_begin(NodeRef N) {
    return N->getPredecessors().begin();
  }

  static inline ChildIteratorType child_end(NodeRef N) {
    return N->getPredecessors().end();
  }
};

// The following set of template specializations implement GraphTraits to
// treat VPRegionBlock as a graph and recurse inside its nodes. It's important
// to note that the blocks inside the VPRegionBlock are treated as VPBlockBases
// (i.e., no dyn_cast is performed, VPBlockBases specialization is used), so
// there won't be automatic recursion into other VPBlockBases that turn to be
// VPRegionBlocks.

template <>
struct GraphTraits<vpo::VPRegionBlock *>
    : public GraphTraits<vpo::VPBlockBase *> {
  using GraphRef = vpo::VPRegionBlock *;
  using nodes_iterator = df_iterator<NodeRef>;

  static NodeRef getEntryNode(GraphRef N) { return N->getEntry(); }

  static nodes_iterator nodes_begin(GraphRef N) {
    return nodes_iterator::begin(N->getEntry());
  }

  static nodes_iterator nodes_end(GraphRef N) {
    // df_iterator returns an empty iterator so the node used doesn't matter.
    return nodes_iterator::end(N);
  }

  static unsigned size(GraphRef N) { return N->getSize(); }
};

template <>
struct GraphTraits<const vpo::VPRegionBlock *>
    : public GraphTraits<const vpo::VPBlockBase *> {
  using GraphRef = const vpo::VPRegionBlock *;
  using nodes_iterator = df_iterator<NodeRef>;

  static NodeRef getEntryNode(GraphRef N) { return N->getEntry(); }

  static nodes_iterator nodes_begin(GraphRef N) {
    return nodes_iterator::begin(N->getEntry());
  }

  static nodes_iterator nodes_end(GraphRef N) {
    // df_iterator returns an empty iterator so the node used doesn't matter.
    return nodes_iterator::end(N);
  }

  static unsigned size(GraphRef N) { return N->getSize(); }
};

template <>
struct GraphTraits<Inverse<vpo::VPRegionBlock *>>
    : public GraphTraits<Inverse<vpo::VPBlockBase *>> {
  using GraphRef = vpo::VPRegionBlock *;
  using nodes_iterator = df_iterator<NodeRef>;

  static NodeRef getEntryNode(Inverse<GraphRef> N) {
    return N.Graph->getExit();
  }

  static nodes_iterator nodes_begin(GraphRef N) {
    return nodes_iterator::begin(N->getExit());
  }

  static nodes_iterator nodes_end(GraphRef N) {
    // df_iterator returns an empty iterator so the node used doesn't matter.
    return nodes_iterator::end(N);
  }

  static unsigned size(GraphRef N) { return N->getSize(); }
};

} // namespace llvm

#endif // LLVM_TRANSFORMS_VECTORIZE_INTEL_VPLAN_INTELVPLAN_H
