//===-- CSAISelDAGToDAG.cpp - A dag to dag inst selector for CSA ----------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the CSA target.
//
//===----------------------------------------------------------------------===//

#include "CSA.h"
#include "CSATargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetLowering.h"
using namespace llvm;

#define DEBUG_TYPE "csa-isel"

/// CSADAGToDAGISel - CSA specific code to select CSA machine
/// instructions for SelectionDAG operations.
///
namespace {
  class CSADAGToDAGISel : public SelectionDAGISel {
    const CSATargetLowering &Lowering;
    const CSASubtarget &Subtarget;

  public:
    CSADAGToDAGISel(CSATargetMachine &TM, CodeGenOpt::Level OptLevel)
        : SelectionDAGISel(TM, OptLevel),
          Lowering(*TM.getSubtargetImpl()->getTargetLowering()),
          Subtarget(*TM.getSubtargetImpl()) {}

    StringRef getPassName() const override {
      return "CSA DAG->DAG Pattern Instruction Selection";
    }

    // Include the pieces autogenerated from the target description.
  #include "CSAGenDAGISel.inc"

  private:
    // Complex patterns
    bool SelectRegImm(SDValue Opnd, SDValue &Result);

    bool SelectAddrRegIdx(SDNode *Parent, SDValue Addr, SDValue &Base,
	SDValue &ScaledOffset);

    bool SelectAddrRegImm(SDNode *Parent, SDValue Addr, SDValue &Base,
        SDValue &Offset);

    bool SelectAddrRegReg(SDNode *Parent, SDValue Addr, SDValue &Base,
        SDValue &Offset);

    bool SelectAddrImm(SDNode *Parent, SDValue Addr, SDValue &Base);

    bool SelectAddrReg(SDNode *Parent, SDValue Addr, SDValue &Base);

    void Select(SDNode *N) override;
  };
}  // end anonymous namespace

/// createCSAISelDag - This pass converts a legalized DAG into a
/// CSA-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createCSAISelDag(CSATargetMachine &TM,
                                        CodeGenOpt::Level OptLevel) {
  return new CSADAGToDAGISel(TM, OptLevel);
}

// Match a register or immediate operand
bool CSADAGToDAGISel::SelectRegImm(SDValue Opnd,
                                         SDValue &Result)
{
  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Opnd)) {
    SDLoc dl(Opnd);
    const ConstantInt &ci = *(CN->getConstantIntValue());
    Result = CurDAG->getTargetConstant(ci, dl, CN->getValueType(0));
    return true;
  }

  // Get the bits for FP types
  // See also CSAMCInstLower.cpp::Lower, case MO_FPImmediate
  if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(Opnd)) {
    SDLoc dl(Opnd);
    const ConstantFP* f = CN->getConstantFPValue();
    APFloat apf = f->getValueAPF();
    bool ignored;
    if (f->getType() == Type::getFloatTy(f->getContext()))
      apf.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven, &ignored);
    double d = apf.convertToDouble();
    if (f->getType()->getTypeID() == Type::FloatTyID) {
      // Result = CurDAG->getTargetConstantFP(f, dl, EVT(MVT::f32)); ?
      union { int i; float f; } ifu;
      ifu.f = d;
      Result = CurDAG->getTargetConstant(ifu.i, dl, MVT::i64);
      return true;
    } else if (f->getType()->getTypeID() == Type::DoubleTyID) {
      // Result = CurDAG->getTargetConstantFP(f, dl, EVT(MVT::f64)); ?
      union { long long l; double d; } ldu;
      ldu.d = d;
      Result = CurDAG->getTargetConstant(ldu.l, dl, MVT::i64);
      return true;
    }
  }

  // Fall back to register match
  Result = Opnd;
  return true;
}

// Scaled indexing (for scaling by 2/4/8 matching opcode access size)
bool CSADAGToDAGISel::SelectAddrRegIdx(SDNode *Parent, SDValue Addr, SDValue &Base,
					SDValue &ScaledOffset) {
  MemSDNode* memSDNode = dyn_cast<MemSDNode>(Parent);
  //If add operation, we can optimize.
  if (memSDNode && Addr.getOpcode() == ISD::ADD) {
    //true if node is a constant.
    if (dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      return false;
    }

    // The shift amount value needs to match the size of the operation
    unsigned int byteSize = memSDNode->getMemoryVT().getStoreSize();
    // Better be over a SHL
    if (Addr.getOperand(1).getOpcode() != ISD::SHL)
	return false;
    // And the shift amount must match the size of the reference
    ConstantSDNode* shamt = dyn_cast<ConstantSDNode>(Addr.getOperand(1).getOperand(1));
    if (!shamt)
	return false;
    if ( (1u << shamt->getZExtValue()) != byteSize)
	return false;

    //set address and offset.
    Base   = Addr.getOperand(0);
    ScaledOffset = Addr.getOperand(1).getOperand(0);
    return true;
  }
  return false;
}

// Displacement
bool CSADAGToDAGISel::SelectAddrRegImm(SDNode *Parent, SDValue Addr,
                                         SDValue &Base, SDValue &Offset) {
  MemSDNode *memSDNode = dyn_cast<MemSDNode>(Parent);

  if (memSDNode && Addr.getOpcode() == ISD::ADD) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      // If operation is a stack operation base becomes offset of
      // the frame.
      if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
      }
      // otherwise, this isn't a stack operation so use passed in
      // register offset.
      else {
        Base = Addr.getOperand(0);
      }
      SDLoc dl(Parent);
      Offset = CurDAG->getTargetConstant(CN->getSExtValue(), dl, MVT::i64);
      return true;
    }
  }
  return false;

}

// Unscaled reg/reg
bool CSADAGToDAGISel::SelectAddrRegReg(SDNode *Parent, SDValue Addr,
                                       SDValue &Base, SDValue &Offset) {
  MemSDNode* memSDNode = dyn_cast<MemSDNode>(Parent);
  //If add operation, we can optimize
  if (memSDNode && Addr.getOpcode() == ISD::ADD) {
    //set address and offset.
    Base   = Addr.getOperand(0);
    Offset = Addr.getOperand(1);
    return true;
  }
  return false;
}

bool CSADAGToDAGISel::SelectAddrImm(SDNode *Parent, SDValue Addr,
                                         SDValue &Base)
{
  if(dyn_cast<MemSDNode>(Parent)) {
    if (Addr.getOpcode() == CSAISD::Wrapper) {
      Base = Addr.getOperand(0);
      return true;
    }

    if (Addr.getOpcode() == ISD::TargetExternalSymbol) {
      Base = Addr;
      return true;
    }

    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr)) {
      SDLoc dl(Parent);
      Base = CurDAG->getTargetConstant(CN->getZExtValue(), dl, MVT::i64);
      return true;
    }
  }
  //not our operation type, so return false.
  return false;
}

bool CSADAGToDAGISel::SelectAddrReg(SDNode *Parent, SDValue Addr,
                                      SDValue &Base)
{
  if(dyn_cast<MemSDNode>(Parent)) {
    Base = Addr;
    return true;
  }
  return false;
}

void CSADAGToDAGISel::Select(SDNode *Node) {
  SDLoc dl(Node);

  // Dump information about the Node being selected
  DEBUG(errs() << "Selecting: ");
  DEBUG(Node->dump(CurDAG));
  DEBUG(errs() << "\n");

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    DEBUG(errs() << "== ";
          Node->dump(CurDAG);
          errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Custom selection
  switch (Node->getOpcode()) {
  default: break;
  case ISD::FrameIndex: {
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI,
        TLI->getPointerTy(MF->getDataLayout()));
    CurDAG->SelectNodeTo(Node, CSA::MOV64, MVT::i64, TFI);
    return;
  }
  }

  // Select the default instruction
  SelectCode(Node);

  DEBUG(errs() << "=> ");
  DEBUG(Node->dump(CurDAG));
  DEBUG(errs() << "\n");

  return;
}
