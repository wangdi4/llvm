//===-- CSAISelDAGToDAG.cpp - A dag to dag inst selector for CSA ----------===//
//
// Copyright (C) 2017-2019 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive
// property of Intel Corporation and may not be disclosed, examined
// or reproduced in whole or in part without explicit written authorization
// from the company.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the CSA target.
//
//===----------------------------------------------------------------------===//

#include "CSA.h"
#include "CSATargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "csa-isel"

/// CSADAGToDAGISel - CSA specific code to select CSA machine
/// instructions for SelectionDAG operations.
///
namespace {
class CSADAGToDAGISel : public SelectionDAGISel {
  const CSASubtarget *Subtarget;
public:
  CSADAGToDAGISel(CSATargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel),
        Subtarget(nullptr) {}

  StringRef getPassName() const override {
    return "CSA: DAG->DAG Pattern Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<CSASubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

    // Include the pieces autogenerated from the target description.
#include "CSAGenDAGISel.inc"

private:
  // Complex patterns
  bool SelectRegImm(SDValue Opnd, SDValue &Result);

  bool SelectAddrRegIdx(SDNode *Parent, SDValue Addr, SDValue &Base,
                        SDValue &ScaledOffset);

  bool SelectAddrRegImm(SDNode *Parent, SDValue Addr, SDValue &Base,
                        SDValue &Offset);

  void Select(SDNode *N) override;

  void SelectMinMax(SDNode *);
};
} // end anonymous namespace

/// createCSAISelDag - This pass converts a legalized DAG into a
/// CSA-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createCSAISelDag(CSATargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new CSADAGToDAGISel(TM, OptLevel);
}

// Match a register or immediate operand
bool CSADAGToDAGISel::SelectRegImm(SDValue Opnd, SDValue &Result) {
  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Opnd)) {
    SDLoc dl(Opnd);
    const ConstantInt &ci = *(CN->getConstantIntValue());
    Result = CurDAG->getTargetConstant(ci, dl, CN->getValueType(0));
    return true;
  }

  // Get the bits for FP types
  // See also CSAMCInstLower.cpp::Lower, case MO_FPImmediate
  if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(Opnd)) {
    SDLoc dl(Opnd);
    const ConstantFP *f = CN->getConstantFPValue();
    APFloat apf         = f->getValueAPF();
    bool ignored;
    if (f->getType() == Type::getFloatTy(f->getContext()))
      apf.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven,
                  &ignored);
    double d = apf.convertToDouble();
    if (f->getType()->getTypeID() == Type::FloatTyID) {
      // Result = CurDAG->getTargetConstantFP(f, dl, EVT(MVT::f32)); ?
      union {
        int i;
        float f;
      } ifu;
      ifu.f  = d;
      Result = CurDAG->getTargetConstant(ifu.i, dl, MVT::i64);
      return true;
    } else if (f->getType()->getTypeID() == Type::DoubleTyID) {
      // Result = CurDAG->getTargetConstantFP(f, dl, EVT(MVT::f64)); ?
      union {
        long long l;
        double d;
      } ldu;
      ldu.d  = d;
      Result = CurDAG->getTargetConstant(ldu.l, dl, MVT::i64);
      return true;
    }
  }

  // Vector types: match constant vectors
  if (ISD::isBuildVectorOfConstantSDNodes(Opnd.getNode()) ||
      ISD::isBuildVectorOfConstantFPSDNodes(Opnd.getNode())) {
    APInt ImmValue(Opnd.getValueSizeInBits(), 0, false);
    unsigned BitSize = Opnd.getScalarValueSizeInBits();
    for (unsigned i = 0; i < Opnd->getNumOperands(); i++) {
      SDValue Op = Opnd->getOperand(i);
      if (auto ConstNode = dyn_cast<ConstantSDNode>(Op)) {
        ImmValue.insertBits(ConstNode->getAPIntValue(), BitSize * i);
      } else if (auto ConstNode = dyn_cast<ConstantFPSDNode>(Op)) {
        ImmValue.insertBits(ConstNode->getValueAPF().bitcastToAPInt(),
            BitSize * i);
      }
    }
    Result = CurDAG->getTargetConstant(ImmValue, SDLoc(Opnd),
        EVT::getIntegerVT(*CurDAG->getContext(), Opnd.getValueSizeInBits()));
    return true;
  }

  // Fall back to register match
  Result = Opnd;
  return true;
}

// Scaled indexing (for scaling by 2/4/8 matching opcode access size)
bool CSADAGToDAGISel::SelectAddrRegIdx(SDNode *Parent, SDValue Addr,
                                       SDValue &Base, SDValue &ScaledOffset) {
  MemSDNode *memSDNode = dyn_cast<MemSDNode>(Parent);
  // If add operation, we can optimize.
  if (memSDNode && Addr.getOpcode() == ISD::ADD) {
    // true if node is a constant.
    if (dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      return false;
    }

    // The shift amount value needs to match the size of the operation
    unsigned int byteSize = memSDNode->getMemoryVT().getStoreSize();
    // Better be over a SHL
    if (Addr.getOperand(1).getOpcode() != ISD::SHL)
      return false;
    // And the shift amount must match the size of the reference
    ConstantSDNode *shamt =
      dyn_cast<ConstantSDNode>(Addr.getOperand(1).getOperand(1));
    if (!shamt)
      return false;
    if ((1u << shamt->getZExtValue()) != byteSize)
      return false;

    // set address and offset.
    Base         = Addr.getOperand(0);
    ScaledOffset = Addr.getOperand(1).getOperand(0);
    return true;
  }
  return false;
}

// Displacement
bool CSADAGToDAGISel::SelectAddrRegImm(SDNode *Parent, SDValue Addr,
                                       SDValue &Base, SDValue &Offset) {
  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    // If operation is a stack operation base becomes offset of
    // the frame.
    if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
    }
    // otherwise, this isn't a stack operation so use passed in
    // register offset.
    else {
      Base = Addr.getOperand(0);
    }
    SDLoc dl(Parent);
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    Offset = CurDAG->getTargetConstant(CN->getSExtValue(), dl, MVT::i64);
    return true;
  }

  if (Addr.getOpcode() == ISD::ADD) {
    Base   = Addr.getOperand(0);
    Offset = Addr.getOperand(1);
    return true;
  }
  return false;

}

void CSADAGToDAGISel::Select(SDNode *Node) {
  SDLoc dl(Node);

  // Dump information about the Node being selected
  LLVM_DEBUG(errs() << "Selecting: ");
  LLVM_DEBUG(Node->dump(CurDAG));
  LLVM_DEBUG(errs() << "\n");

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Custom selection
  switch (Node->getOpcode()) {
  default:
    break;
  case ISD::FrameIndex: {
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI =
      CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(MF->getDataLayout()));
    CurDAG->SelectNodeTo(Node, CSA::MOV64, MVT::i64, TFI);
    return;
  }
  case CSAISD::Min:
  case CSAISD::UMin:
  case CSAISD::Max:
  case CSAISD::UMax:
    return SelectMinMax(Node);

  case CSAISD::Swizzle: {
    unsigned SwizzleMask = Node->getConstantOperandVal(1);
    int LoLane, HiLane;
    switch (SwizzleMask) {
    case 0: LoLane = 0; HiLane = 1; break;
    case 1: LoLane = 0; HiLane = 0; break;
    case 2: LoLane = 1; HiLane = 1; break;
    case 3: LoLane = 1; HiLane = 0; break;
    default: llvm_unreachable("Unknown swizzle mask for CSA");
    }
    EVT VT = Node->getValueType(0);
    SDValue Shuffle = CurDAG->getVectorShuffle(VT, dl, Node->getOperand(0),
        CurDAG->getUNDEF(VT), { LoLane, HiLane });
    ReplaceNode(Node, Shuffle.getNode());
    // Select the UNDEF value first...
    Select(Shuffle->getOperand(1).getNode());
    // ... and then the shuffle itself.
    return Select(Shuffle.getNode());
  }
  case ISD::VECTOR_SHUFFLE: {
    // We could match this in the tablegen, but the mask parameters aren't
    // operands that are exposed.
    MVT VT = Node->getSimpleValueType(0);
    assert(VT.getSizeInBits() == 64 && VT.getScalarSizeInBits() == 32 &&
        "Only supporting <2 x *32> vectors");

    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(Node)->getMask();
    CurDAG->SelectNodeTo(Node, CSA::SHUFI32X2, VT,
        {Node->getOperand(0), Node->getOperand(1),
        CurDAG->getTargetConstant(Mask[0], dl, MVT::i8),
        CurDAG->getTargetConstant(Mask[1], dl, MVT::i8)});
    return;

  // The shuffle vector instruction is quite literally the parameters of the
  // shuffle vector itself, but SelectionDAG doesn't put the mask operands as
  // actual operands, so we need to create the immediates manually for these.
  }
  }

  // Select the default instruction
  SelectCode(Node);

  LLVM_DEBUG(errs() << "=> ");
  LLVM_DEBUG(Node->dump(CurDAG));
  LLVM_DEBUG(errs() << "\n");

  return;
}

void CSADAGToDAGISel::SelectMinMax(SDNode *Node) {
  const unsigned SDOp = Node->getOpcode();
  MVT VT              = Node->getSimpleValueType(0);
  const unsigned Bits = VT.getSizeInBits();
  const CSA::OpcodeClass Class =
    VT.isFloatingPoint()
      ? CSA::VARIANT_FLOAT
      : (SDOp == CSAISD::UMin or SDOp == CSAISD::UMax) ? CSA::VARIANT_UNSIGNED
                                                       : CSA::VARIANT_SIGNED;
  const CSAInstrInfo &TII = *static_cast<const CSAInstrInfo *>(
    Subtarget->TargetSubtargetInfo::getInstrInfo());
  const unsigned OpCode = TII.makeOpcode(
    (SDOp == CSAISD::Max or SDOp == CSAISD::UMax) ? CSA::Generic::MAX
                                                  : CSA::Generic::MIN,
    Bits, Class);
  CurDAG->SelectNodeTo(Node, OpCode, VT, MVT::i1, Node->getOperand(0),
                       Node->getOperand(1));
}
