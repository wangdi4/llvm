//===-- CSAISelDAGToDAG.cpp - A dag to dag inst selector for CSA ----------===//
//
// Copyright (C) 2017 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive
// property of Intel Corporation and may not be disclosed, examined
// or reproduced in whole or in part without explicit written authorization
// from the company.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the CSA target.
//
//===----------------------------------------------------------------------===//

#include "CSA.h"
#include "CSATargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "csa-isel"

/// CSADAGToDAGISel - CSA specific code to select CSA machine
/// instructions for SelectionDAG operations.
///
namespace {
class CSADAGToDAGISel : public SelectionDAGISel {
  const CSASubtarget *Subtarget;
public:
  CSADAGToDAGISel(CSATargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel),
        Subtarget(nullptr) {}

  StringRef getPassName() const override {
    return "CSA: DAG->DAG Pattern Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<CSASubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

    // Include the pieces autogenerated from the target description.
#include "CSAGenDAGISel.inc"

private:
  // Complex patterns
  bool SelectRegImm(SDValue Opnd, SDValue &Result);

  bool SelectAddrRegIdx(SDNode *Parent, SDValue Addr, SDValue &Base,
                        SDValue &ScaledOffset);

  bool SelectAddrRegImm(SDNode *Parent, SDValue Addr, SDValue &Base,
                        SDValue &Offset);

  void Select(SDNode *N) override;

  void SelectMinMax(SDNode *);
};
} // end anonymous namespace

/// createCSAISelDag - This pass converts a legalized DAG into a
/// CSA-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createCSAISelDag(CSATargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new CSADAGToDAGISel(TM, OptLevel);
}

// Match a register or immediate operand
bool CSADAGToDAGISel::SelectRegImm(SDValue Opnd, SDValue &Result) {

  // Ignore bitcasts when looking for constants.
  SDValue CV = Opnd;
  if (CV->getOpcode() == ISD::BITCAST)
    CV = CV->getOperand(0);

  // Extract the bits if this is a constant; clear CV otherwise.
  APInt ImmBits;
  EVT ImmType =
    EVT::getIntegerVT(*CurDAG->getContext(), CV.getValueSizeInBits());
  if (const auto CN = dyn_cast<ConstantSDNode>(CV)) {
    ImmBits = CN->getAPIntValue();
  } else if (const auto CFN = dyn_cast<ConstantFPSDNode>(CV)) {
    ImmBits = CFN->getValueAPF().bitcastToAPInt();
  } else {
    CV = SDValue{};
  }

  // If a constant was found, create a TargetConstant.
  if (CV) {
    Result = CurDAG->getTargetConstant(ImmBits, SDLoc{CV}, ImmType);
    return true;
  }

  // Otherwise, fall back to a register match.
  Result = Opnd;
  return true;
}

// Scaled indexing (for scaling by 2/4/8 matching opcode access size)
bool CSADAGToDAGISel::SelectAddrRegIdx(SDNode *Parent, SDValue Addr,
                                       SDValue &Base, SDValue &ScaledOffset) {
  MemSDNode *memSDNode = dyn_cast<MemSDNode>(Parent);
  // If add operation, we can optimize.
  if (memSDNode && Addr.getOpcode() == ISD::ADD) {
    // true if node is a constant.
    if (dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      return false;
    }

    // The shift amount value needs to match the size of the operation
    unsigned int byteSize = memSDNode->getMemoryVT().getStoreSize();
    // Better be over a SHL
    if (Addr.getOperand(1).getOpcode() != ISD::SHL)
      return false;
    // And the shift amount must match the size of the reference
    ConstantSDNode *shamt =
      dyn_cast<ConstantSDNode>(Addr.getOperand(1).getOperand(1));
    if (!shamt)
      return false;
    if ((1u << shamt->getZExtValue()) != byteSize)
      return false;

    // set address and offset.
    Base         = Addr.getOperand(0);
    ScaledOffset = Addr.getOperand(1).getOperand(0);
    return true;
  }
  return false;
}

// Displacement
bool CSADAGToDAGISel::SelectAddrRegImm(SDNode *Parent, SDValue Addr,
                                       SDValue &Base, SDValue &Offset) {
  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    // If operation is a stack operation base becomes offset of
    // the frame.
    if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
    }
    // otherwise, this isn't a stack operation so use passed in
    // register offset.
    else {
      Base = Addr.getOperand(0);
    }
    SDLoc dl(Parent);
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    Offset = CurDAG->getTargetConstant(CN->getSExtValue(), dl, MVT::i64);
    return true;
  }

  if (Addr.getOpcode() == ISD::ADD) {
    Base   = Addr.getOperand(0);
    Offset = Addr.getOperand(1);
    return true;
  }
  return false;

}

void CSADAGToDAGISel::Select(SDNode *Node) {
  SDLoc dl(Node);

  // Dump information about the Node being selected
  LLVM_DEBUG(errs() << "Selecting: ");
  LLVM_DEBUG(Node->dump(CurDAG));
  LLVM_DEBUG(errs() << "\n");

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Custom selection
  switch (Node->getOpcode()) {
  case ISD::SETCC: {
    // This code here is to handle this special pattern that
    // does SIMD min when the results are either 0 or 1.
    //     t3: v8i8 = setcc t1, t2, setne:ch
    //       t2: v8i8 = bitcast Constant:i64<0>
    //
    // Only continue the rewrite if
    //       the result type is a vector type,
    //   and the condition is ne,
    //   and the second operand is bitcast constant 0.
    EVT RVT = Node->getValueType(0);
    if (!RVT.isVector()) break;

    const ISD::CondCode CC = cast<CondCodeSDNode>(Node->getOperand(2))->get();
    if (CC != ISD::SETNE) break;

    SDNode* Op1 = Node->getOperand(1).getNode();
    if (Op1->getOpcode() != ISD::BITCAST ||
        Op1->getConstantOperandVal(0) != 0) break;

    // Rewrite ISD::SETCC to CSA::MINU.
    // Op0: Original first operand
    // Op1: For i8, then it's 0x0101010101010101
    //      For i16 then it's 0x0001000100010001
    SmallVector<SDValue, 2> Ops;
    Ops.push_back(Node->getOperand(0));
    EVT VT = Op1->getValueType(0);
    unsigned Opcode;
    if (VT.getScalarSizeInBits() == 8) {
      Opcode = CSA::MINU8X8;
      Ops.push_back(CurDAG->getTargetConstant(0x0101010101010101, dl, MVT::i64));
    } else if (VT.getScalarSizeInBits() == 16) {
      Opcode = CSA::MINU16X4;
      Ops.push_back(CurDAG->getTargetConstant(0x0001000100010001, dl, MVT::i64));
    } else
      report_fatal_error("Unsupported vector for MINU");

    CurDAG->SelectNodeTo(Node, Opcode, VT, Ops);
    return;
  }
  case ISD::BITCAST: {
    // All types of the same size are forced into the same register classes
    // anyways, so drop the bitcast entirely.
    ReplaceUses(SDValue(Node, 0), Node->getOperand(0));
    CurDAG->RemoveDeadNode(Node);
    return;
  }
  default:
    break;
  case ISD::FrameIndex: {
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI =
      CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(MF->getDataLayout()));
    CurDAG->SelectNodeTo(Node, CSA::MOV64, MVT::i64, TFI);
    return;
  }
  case CSAISD::Min:
  case CSAISD::UMin:
  case CSAISD::Max:
  case CSAISD::UMax:
    return SelectMinMax(Node);

  case CSAISD::Swizzle: {
    unsigned SwizzleMask = Node->getConstantOperandVal(1);
    int LoLane, HiLane;
    switch (SwizzleMask) {
    case 0: LoLane = 0; HiLane = 1; break;
    case 1: LoLane = 0; HiLane = 0; break;
    case 2: LoLane = 1; HiLane = 1; break;
    case 3: LoLane = 1; HiLane = 0; break;
    default: llvm_unreachable("Unknown swizzle mask for CSA");
    }
    EVT VT = Node->getValueType(0);
    SmallVector<int, 4> LaneMask = { LoLane, HiLane };
    if (VT.getVectorNumElements() == 4) {
      LaneMask.push_back(LoLane + 2);
      LaneMask.push_back(HiLane + 2);
    }
    SDValue Shuffle = CurDAG->getVectorShuffle(VT, dl, Node->getOperand(0),
        CurDAG->getUNDEF(VT), LaneMask);
    ReplaceNode(Node, Shuffle.getNode());
    // Select the UNDEF value first...
    Select(Shuffle->getOperand(1).getNode());
    // ... and then the shuffle itself.
    return Select(Shuffle.getNode());
  }
  case ISD::VECTOR_SHUFFLE: {
    // We could match this in the tablegen, but the mask parameters aren't
    // operands that are exposed.
    MVT VT = Node->getSimpleValueType(0);
    assert(VT.getSizeInBits() == 64 && "Only supporting 64-bit vectors");

    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(Node)->getMask();
    SmallVector<SDValue, 6> Ops;
    Ops.push_back(Node->getOperand(0));
    Ops.push_back(Node->getOperand(1));
    for (int El : Mask)
      Ops.push_back(CurDAG->getTargetConstant(El, dl, MVT::i8));

    unsigned Opcode;
    if (VT.getScalarSizeInBits() == 32)
      Opcode = CSA::SHUFI32X2;
    else if (VT.getScalarSizeInBits() == 16)
      Opcode = CSA::SHUFI16X4;
    else if (VT.getScalarSizeInBits() == 8)
      Opcode = CSA::SHUFI8X8;
    else
      report_fatal_error("Unsupported vector for shuffle");
    CurDAG->SelectNodeTo(Node, Opcode, VT, Ops);
    return;

  // The shuffle vector instruction is quite literally the parameters of the
  // shuffle vector itself, but SelectionDAG doesn't put the mask operands as
  // actual operands, so we need to create the immediates manually for these.
  }
  }

  // Select the default instruction
  SelectCode(Node);

  LLVM_DEBUG(errs() << "=> ");
  LLVM_DEBUG(Node->dump(CurDAG));
  LLVM_DEBUG(errs() << "\n");

  return;
}

void CSADAGToDAGISel::SelectMinMax(SDNode *Node) {
  const unsigned SDOp = Node->getOpcode();
  MVT VT              = Node->getSimpleValueType(0);
  const unsigned Bits = VT.getSizeInBits();
  const CSA::OpcodeClass Class =
    VT.isFloatingPoint()
      ? CSA::VARIANT_FLOAT
      : (SDOp == CSAISD::UMin or SDOp == CSAISD::UMax) ? CSA::VARIANT_UNSIGNED
                                                       : CSA::VARIANT_SIGNED;
  const CSAInstrInfo &TII = *static_cast<const CSAInstrInfo *>(
    Subtarget->TargetSubtargetInfo::getInstrInfo());
  const unsigned OpCode = TII.makeOpcode(
    (SDOp == CSAISD::Max or SDOp == CSAISD::UMax) ? CSA::Generic::MAX
                                                  : CSA::Generic::MIN,
    Bits, Class);
  CurDAG->SelectNodeTo(Node, OpCode, VT, MVT::i1, Node->getOperand(0),
                       Node->getOperand(1));
}
