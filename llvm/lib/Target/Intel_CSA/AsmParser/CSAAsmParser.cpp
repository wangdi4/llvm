//===-- CSAAsmParser.cpp - Parse CSA assembly to MCInst instructions --===//
//
// Copyright (C) 2017-2019 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive
// property of Intel Corporation and may not be disclosed, examined
// or reproduced in whole or in part without explicit written authorization
// from the company.
//
//===----------------------------------------------------------------------===//

#include "CSA.h"
#include "CSAInstrInfo.h"
#include "MCTargetDesc/CSAMCTargetDesc.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/SmallBitVector.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCParser/MCAsmLexer.h"
#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
#include "llvm/MC/MCParser/MCTargetAsmParser.h"
#include "llvm/MC/MCStreamer.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/MC/MCSymbol.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/TargetRegistry.h"

namespace llvm {
namespace {
struct CSAOperand;

class CSAAsmParser : public MCTargetAsmParser {
  // Parse operands
  std::unique_ptr<CSAOperand> parseRegister();

  std::unique_ptr<CSAOperand> parseImmediate();

  std::unique_ptr<CSAOperand> defaultOptionalRegOperands();
#define CSA_ASM_OPERAND(Asm, Enum, Default, ...) \
  std::unique_ptr<CSAOperand> default##Asm##Operands();
#include "AsmOperands.h"
  std::unique_ptr<CSAOperand> defaultPrioOrderOperands();

  bool parsePrePost(StringRef Type, int *OffsetValue);

  bool ParseDirective(AsmToken DirectiveID) override;

  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name,
                        SMLoc NameLoc, OperandVector &Operands) override;

  bool ParseRegister(unsigned &RegNum, SMLoc &StartLoc, SMLoc &EndLoc) override;

  bool MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                               OperandVector &Operands, MCStreamer &Out,
                               uint64_t &ErrorInfo,
                               bool MatchingInlineAsm) override;

  unsigned validateTargetOperandClass(MCParsedAsmOperand &Op,
                                      unsigned Kind) override;

// Auto-generated instruction matching functions
#define GET_ASSEMBLER_HEADER
#include "CSAGenAsmMatcher.inc"

  OperandMatchResultTy parseOperand(OperandVector *Operands);

public:
  CSAAsmParser(const MCSubtargetInfo &STI, MCAsmParser &Parser,
                 const MCInstrInfo &MII, const MCTargetOptions &Options)
      : MCTargetAsmParser(Options, STI, MII), Parser(Parser),
        Lexer(Parser.getLexer()), SubtargetInfo(STI) {
    setAvailableFeatures(
      ComputeAvailableFeatures(SubtargetInfo.getFeatureBits()));
  }

private:
  MCAsmParser &Parser;
  MCAsmLexer &Lexer;

  const MCSubtargetInfo &SubtargetInfo;
};

// Auto-generated by TableGen
static unsigned MatchRegisterName(llvm::StringRef Name);

// CSAOperand - Instances of this class represented a parsed machine
// instruction
struct CSAOperand : public MCParsedAsmOperand {
  enum KindTy {
    TOKEN,
    REGISTER,
    IMMEDIATE,
  } Kind;

  SMLoc StartLoc, EndLoc;

  struct Token {
    const char *Data;
    unsigned Length;
  };

  struct RegOp {
    unsigned RegNum;
  };

  struct ImmOp {
    const MCExpr *Value;
  };

  union {
    struct Token Tok;
    struct RegOp Reg;
    struct ImmOp Imm;
  };

  explicit CSAOperand(KindTy Kind) : MCParsedAsmOperand(), Kind(Kind) {}

public:
  // The functions below are used by the autogenerated ASM matcher and hence to
  // be of the form expected.

  // getStartLoc - Gets location of the first token of this operand
  SMLoc getStartLoc() const override { return StartLoc; }

  // getEndLoc - Gets location of the last token of this operand
  SMLoc getEndLoc() const override { return EndLoc; }

  unsigned getReg() const override {
    assert(isReg() && "Invalid type access!");
    return Reg.RegNum;
  }

  const MCExpr *getImm() const {
    assert(isImm() && "Invalid type access!");
    return Imm.Value;
  }

  bool getRegImm(const MCExpr **e, unsigned *r) const {
    assert((isImm() || isReg()) && "Invalid type access!");
    if (isImm()) {
      assert(r);
      *e = Imm.Value;
      return true;
    }
    if (isReg()) {
      // Otherwise, this is a register.
      assert(e);
      *r = Reg.RegNum;
      return true;
    }
    return false;
  }

  StringRef getToken() const {
    assert(isToken() && "Invalid type access!");
    return StringRef(Tok.Data, Tok.Length);
  }

  // Functions for testing operand type
  bool isReg() const override { return Kind == REGISTER; }

  bool isImm() const override { return Kind == IMMEDIATE; }

  bool isRegImm() { return isReg() || isImm(); }

  bool isToken() const override { return Kind == TOKEN; }

  bool isOptionalReg() const { return isReg(); }

#define CSA_ASM_OPERAND(Asm, Enum, Default, ...) \
  bool is##Asm() const { return isImm(); }
#include "AsmOperands.h"

  bool isPrioOrder() const { return isImm(); }

  bool isMem() const { llvm_unreachable("No isMem"); }

  void print(raw_ostream &OS) const override {
    switch (Kind) {
    case IMMEDIATE:
      OS << "Imm: " << getImm() << "\n";
      break;
    case TOKEN:
      OS << "Token: " << getToken() << "\n";
      break;
    case REGISTER:
      OS << "Reg: %r" << getReg() << "\n";
      break;
    default:
      OS << "[uknown_operand]\n";
      break;
    }
  }

  static std::unique_ptr<CSAOperand> CreateToken(StringRef Str, SMLoc Start) {
    auto Op        = std::make_unique<CSAOperand>(TOKEN);
    Op->Tok.Data   = Str.data();
    Op->Tok.Length = Str.size();
    Op->StartLoc   = Start;
    Op->EndLoc     = Start;
    return Op;
  }

  static std::unique_ptr<CSAOperand> createReg(unsigned RegNum, SMLoc Start,
                                               SMLoc End) {
    auto Op        = std::make_unique<CSAOperand>(REGISTER);
    Op->Reg.RegNum = RegNum;
    Op->StartLoc   = Start;
    Op->EndLoc     = End;
    return Op;
  }

  static std::unique_ptr<CSAOperand> createImm(const MCExpr *Value, SMLoc Start,
                                               SMLoc End) {
    auto Op       = std::make_unique<CSAOperand>(IMMEDIATE);
    Op->Imm.Value = Value;
    Op->StartLoc  = Start;
    Op->EndLoc    = End;
    return Op;
  }

  void addExpr(MCInst &Inst, const MCExpr *Expr) const {
    // Add as immediates where possible. Null MCExpr = 0
    if (Expr == nullptr)
      Inst.addOperand(MCOperand::createImm(0));
    else if (const MCConstantExpr *ConstExpr = dyn_cast<MCConstantExpr>(Expr))
      Inst.addOperand(MCOperand::createImm(ConstExpr->getValue()));
    else
      Inst.addOperand(MCOperand::createExpr(Expr));
  }

  void addRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

  void addImmOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    addExpr(Inst, getImm());
  }

  void addRegImmOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    if (isImm())
      addExpr(Inst, getImm());
    else if (isReg())
      Inst.addOperand(MCOperand::createReg(getReg()));
    else
      assert(false && "Invalid operand type!");
  }

  void addOptionalRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

#define CSA_ASM_OPERAND(Asm, Enum, Default, ...) \
  void add##Asm##Operands(MCInst &Inst, unsigned N) const { \
    assert(N == 1 && "Invalid number of operands!"); \
    addExpr(Inst, getImm()); \
  }
#include "AsmOperands.h"

  void addPrioOrderOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands!");
    addExpr(Inst, getImm());
  }

};

bool CSAAsmParser::ParseDirective(AsmToken /*DirectiveId*/) { return true; }

bool CSAAsmParser::MatchAndEmitInstruction(SMLoc IdLoc, unsigned &Opcode,
                                           OperandVector &Operands,
                                           MCStreamer &Out, uint64_t &ErrorInfo,
                                           bool MatchingInlineAsm) {
  MCInst Inst;
  SMLoc ErrorLoc;

  switch (MatchInstructionImpl(Operands, Inst, ErrorInfo, MatchingInlineAsm)) {
  case Match_Success:
    Out.EmitInstruction(Inst, SubtargetInfo);
    Opcode = Inst.getOpcode();
    return false;
  case Match_MissingFeature:
    return Error(IdLoc, "Instruction use requires option to be enabled");
  case Match_MnemonicFail:
    return Error(IdLoc, "Unrecognized instruction mnemonic");
  case Match_InvalidOperand: {
    ErrorLoc = IdLoc;
    if (ErrorInfo != ~0U) {
      if (ErrorInfo >= Operands.size())
        return Error(IdLoc, "Too few operands for instruction");

      ErrorLoc = ((CSAOperand &)*Operands[ErrorInfo]).getStartLoc();
      if (ErrorLoc == SMLoc())
        ErrorLoc = IdLoc;
    }
    return Error(ErrorLoc, "Invalid operand for instruction");
  }
  default:
    break;
  }

  llvm_unreachable("Unknown match type detected!");
}

// Both '%rN' and 'rN' are parsed as valid registers. This was done to remain
// backwards compatible with GCC and the different ways inline assembly is
// handled.
// TODO: see if there isn't a better way to do this.
std::unique_ptr<CSAOperand> CSAAsmParser::parseRegister() {
  SMLoc Start = Parser.getTok().getLoc();
  SMLoc End = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  unsigned RegNum;

  if (Lexer.getKind() == AsmToken::Dollar) {
    // We are parsing not a true CSA operand, but an extended-style inline
    // assembly argument. Pass this through as an illegal register number.
    // Gross. Sorry.

    // Eat the '$'.
    Parser.Lex();

    // A number should follow.
    int64_t dollarNum = Lexer.getTok().getIntVal();

    RegNum = CSA::NUM_TARGET_REGS + dollarNum;
    Parser.Lex(); // Eat the number.
    return CSAOperand::createReg(RegNum, Start, End);
  }

  // This is hopefully a real register. Eat the '%' if it exists.
  if (Lexer.getKind() == AsmToken::Percent)
    Parser.Lex();
  if (Lexer.getKind() == AsmToken::Identifier) {
    RegNum = MatchRegisterName(Lexer.getTok().getIdentifier());
    if (RegNum == 0)
      return 0;
    Parser.Lex(); // Eat identifier token
    return CSAOperand::createReg(RegNum, Start, End);
  }
  return 0;
}

bool CSAAsmParser::ParseRegister(unsigned &RegNum, SMLoc &StartLoc,
                                 SMLoc &EndLoc) {
  const AsmToken &Tok            = getParser().getTok();
  StartLoc                       = Tok.getLoc();
  EndLoc                         = Tok.getEndLoc();
  std::unique_ptr<CSAOperand> Op = parseRegister();
  if (Op != nullptr)
    RegNum = Op->getReg();
  return (Op == nullptr);
}

static int asmImmediateLabel(StringRef T) {
  StringSwitch<int> sw(T);
#define CSA_ASM_OPERAND_VALUE(x) sw.Case(#x, CSA::x)
#define CSA_ASM_OPERAND(Asm, Enum, Default, ...) __VA_ARGS__;
#include "AsmOperands.h"
  return sw.Default(-1);
}

std::unique_ptr<CSAOperand> CSAAsmParser::parseImmediate() {
  SMLoc Start = Parser.getTok().getLoc();
  SMLoc End = SMLoc::getFromPointer(Parser.getTok().getLoc().getPointer() - 1);

  const MCExpr *ExprVal;
  switch (Lexer.getKind()) {
  case AsmToken::Identifier: {
    StringRef Identifier;
    if (Parser.parseIdentifier(Identifier))
      return 0;

    // Check for one of the enum words
    int value = asmImmediateLabel(Identifier);
    if (value >= 0) {
      const MCConstantExpr *exp = MCConstantExpr::create(value, getContext());
      return CSAOperand::createImm(exp, Start, End);
    }

    // Otherwise, it's a symbol of some kind.
    MCSymbol *Sym = getContext().getOrCreateSymbol(Identifier);
    const MCExpr *Res =
      MCSymbolRefExpr::create(Sym, MCSymbolRefExpr::VK_None, getContext());
    return CSAOperand::createImm(Res, Start, End);
  }
  case AsmToken::Plus:
  case AsmToken::Minus:
  case AsmToken::Integer:
  case AsmToken::Dot:
    if (!Parser.parseExpression(ExprVal))
      return CSAOperand::createImm(ExprVal, Start, End);
  default:
    return 0;
  }
}

std::unique_ptr<CSAOperand> CSAAsmParser::defaultOptionalRegOperands() {
  SMLoc loc = Parser.getTok().getLoc();
  return CSAOperand::createReg(CSA::IGN, loc, loc);
}

#define CSA_ASM_OPERAND(Asm, Enum, Default, ...) \
  std::unique_ptr<CSAOperand> CSAAsmParser::default##Asm##Operands() { \
    SMLoc loc = Parser.getTok().getLoc(); \
    return CSAOperand::createImm( \
        MCConstantExpr::create(CSA::Default, getContext()), loc, loc); \
  }
#include "AsmOperands.h"

std::unique_ptr<CSAOperand> CSAAsmParser::defaultPrioOrderOperands() {
  SMLoc loc = Parser.getTok().getLoc();
  return CSAOperand::createImm(
    MCConstantExpr::create(0, getContext()), loc, loc);
}

static int SizeForSuffix(StringRef T) {
  return StringSwitch<int>(T).EndsWith(".h", 2).EndsWith(".b", 1).Default(4);
}

bool CSAAsmParser::parsePrePost(StringRef Type, int *OffsetValue) {
  bool PreOrPost = false;
  if (Lexer.getKind() == Lexer.peekTok(true).getKind()) {
    PreOrPost = true;
    if (Lexer.is(AsmToken::Minus))
      *OffsetValue = -SizeForSuffix(Type);
    else if (Lexer.is(AsmToken::Plus))
      *OffsetValue = SizeForSuffix(Type);
    else
      return false;

    // Eat the '-' '-' or '+' '+'
    Parser.Lex();
    Parser.Lex();
  } else if (Lexer.is(AsmToken::Star)) {
    Parser.Lex(); // Eat the '*'
    PreOrPost = true;
  }

  return PreOrPost;
}

// Looks at a token type and creates the relevant operand from this
// information, adding to operands.
// If operand was parsed, returns false, else true.
OperandMatchResultTy CSAAsmParser::parseOperand(OperandVector *Operands) {

  // Attempt to parse token as register
  std::unique_ptr<CSAOperand> Op = parseRegister();

  // Attempt to parse token as immediate
  if (!Op)
    Op = parseImmediate();

  // If the token could not be parsed then fail
  if (!Op) {
    Error(Parser.getTok().getLoc(), "Unknown operand");
    Parser.eatToEndOfStatement();
    return MatchOperand_ParseFail;
  }

  // Push back parsed operand into list of operands
  Operands->push_back(std::move(Op));

  return MatchOperand_Success;
}

bool CSAAsmParser::ParseInstruction(ParseInstructionInfo & /*Info*/,
                                    StringRef Name, SMLoc NameLoc,
                                    OperandVector &Operands) {
  // First operand is token for instruction
  Operands.push_back(CSAOperand::CreateToken(Name, NameLoc));

  // If there are no more operands, then finish
  if (Lexer.is(AsmToken::EndOfStatement))
    return false;

  // Parse first operand
  if (parseOperand(&Operands) != MatchOperand_Success)
    return true;

  // Parse until end of statement, consuming commas between operands
  while (Lexer.isNot(AsmToken::EndOfStatement) && Lexer.is(AsmToken::Comma)) {
    // Consume comma token
    Lex();

    // Parse next operand
    if (parseOperand(&Operands) != MatchOperand_Success)
      return true;
  }

  return false;
}

#define GET_REGISTER_MATCHER
#define GET_MATCHER_IMPLEMENTATION
#include "CSAGenAsmMatcher.inc"

// This is consulted if the generated validateOperandClass doesn't approve of
// an operand based on type. Our version implements several relaxations
// necessary due to the limitations of register class and instruction
// descriptions.
unsigned CSAAsmParser::validateTargetOperandClass(MCParsedAsmOperand &GOp,
                                                  unsigned Kind) {
  CSAOperand &Op = (CSAOperand &)GOp;
  switch (Kind) {
  default:
    break;
  case MCK_I1:
    // This is what the matcher generates as the type for register+channel
    // operands. ("I1" because technically all of the R* register classes
    // contain all of the regular registers. There is no such thing as
    // MCK_RI32, for example, since it would always be included in
    // MCK_I1.) We need to allow CI* here, since CI* is technically
    // disjoint with I* (which is currently equivalent to I1).
    if (Op.isReg())
      return MCTargetAsmParser::Match_Success;
    break;
  case MCK_ANYC:
    // ANYC is what the matcher generates as the type for channel-only operands.
    // We've been having some problems (CMPLRLLVM-9224) because our inline asms'
    // dollar operands are represented using out-of-bounds registers that aren't
    // seen as part of ANYC, which means that the matcher will reject attempts
    // to connect to channel-only operands in inline asms. This case works
    // around this by declaring these out-of-range registers to be compatible
    // with ANYC.
    if (Op.isReg() && Op.getReg() >= CSA::NUM_TARGET_REGS)
      return MCTargetAsmParser::Match_Success;
    break;
  case MCK__PCT_ra:
    // We don't get this as a register for some reason. Fortunately
    // it's easy to match as a one-off. The resulting MI doesn't
    // actually use %ra since it doesn't have any operands.
    if (Op.isReg() && Op.getReg() == CSA::RA)
      return MCTargetAsmParser::Match_Success;
    break;
  }

  return Match_InvalidOperand;
}

} // namespace

extern "C" void LLVMInitializeCSAAsmParser() {
  RegisterMCAsmParser<CSAAsmParser> x(getTheCSATarget());
}

} // namespace llvm
