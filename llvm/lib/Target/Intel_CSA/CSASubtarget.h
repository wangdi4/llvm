//===-- CSASubtarget.h - Define Subtarget for the CSA ----------*- C++ -*--===//
//
// Copyright (C) 2017 Intel Corporation. All rights reserved.
//
// The information and source code contained herein is the exclusive
// property of Intel Corporation and may not be disclosed, examined
// or reproduced in whole or in part without explicit written authorization
// from the company.
//
//===----------------------------------------------------------------------===//
//
// This file declares the CSA specific subclass of TargetSubtargetInfo.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_TARGET_CSA_CSASUBTARGET_H
#define LLVM_LIB_TARGET_CSA_CSASUBTARGET_H

#include "CSAFrameLowering.h"
#include "CSAISelLowering.h"
#include "CSAInstrInfo.h"
#include "CSARegisterInfo.h"
#include "CSASelectionDAGInfo.h"
#include "llvm/CodeGen/TargetSubtargetInfo.h"
#include <string>

#define GET_SUBTARGETINFO_HEADER
#include "CSAGenSubtargetInfo.inc"

namespace llvm {
class StringRef;

class CSASubtarget : public CSAGenSubtargetInfo {
  virtual void anchor();

protected:
  bool IsOrdered    = false;
  bool CanSpeculate = false;
  bool IsSequential = false;
  bool HasI0        = false;
  bool HasI1        = false;
  bool HasI8        = false;
  bool HasI16       = false;
  bool HasI32       = false;
  bool HasI64       = false;
  bool HasF16       = false;
  bool HasF32       = false;
  bool HasF64       = false;
  bool HasSextL     = false;
  bool HasDispl     = false;
  bool HasIndex     = false;
  bool HasShAdd     = false;
  bool HasBitOp     = false;
  bool HasIDiv      = false;
  bool HasFDiv      = false;
  bool HasFMA       = false;
  bool HasRcpA      = false;
  bool HasRSqrtA    = false;
  bool HasSqrt      = false;
  bool HasMath0     = false;
  bool HasRMWAtomic = false;

private:
  // The feature members listed above may be set to true during construction
  // of members listed below (see CSASubtarget() constructor).
  // We should initialize the feature members before we conditionally update
  // them, thus, we need to keep this order of members.  Otherwise, the default
  // initializers will reset the feature members to false.
  CSAFrameLowering FrameLowering;
  CSAInstrInfo InstrInfo;
  CSATargetLowering TLInfo;
  CSASelectionDAGInfo TSInfo;
  std::string CSAName;

public:
  std::string csaName() const { return CSAName; }
  bool isOrdered() const { return IsOrdered; }
  bool canSpeculate() const { return CanSpeculate; }
  bool isSequential() const { return IsSequential; }
  bool hasI0() const { return HasI0; }
  bool hasI1() const { return HasI1; }
  bool hasI8() const { return HasI8; }
  bool hasI16() const { return HasI16; }
  bool hasI32() const { return HasI32; }
  bool hasI64() const { return HasI64; }
  bool hasF16() const { return HasF16; }
  bool hasF32() const { return HasF32; }
  bool hasF64() const { return HasF64; }
  bool hasSextL() const { return HasSextL; }
  bool hasDispl() const { return HasDispl; }
  bool hasIndex() const { return HasIndex; }
  bool hasShAdd() const { return HasShAdd; }
  bool hasBitOp() const { return HasBitOp; }
  bool hasIDiv() const { return HasIDiv; }
  bool hasFDiv() const { return HasFDiv; }
  bool hasFMA() const { return HasFMA; }
  bool hasRcpA() const { return HasRcpA; }
  bool hasRSqrtA() const { return HasRSqrtA; }
  bool hasSqrt() const { return HasSqrt; }
  bool hasMath0() const;
  bool hasRMWAtomic() const { return HasRMWAtomic; }

  /// This constructor initializes the data members to match that
  /// of the specified triple.
  ///
  CSASubtarget(const Triple &TT, const std::string &CPU, const std::string &FS,
               const TargetMachine &TM);

  CSASubtarget &initializeSubtargetDependencies(StringRef CPU, StringRef FS);

  /// ParseSubtargetFeatures - Parses features string setting specified
  /// subtarget options.  Definition of function is auto generated by tblgen.
  void ParseSubtargetFeatures(StringRef CPU, StringRef FS);

  const TargetFrameLowering *getFrameLowering() const override {
    return &FrameLowering;
  }
  const CSAInstrInfo *getInstrInfo() const override { return &InstrInfo; }
  const TargetRegisterInfo *getRegisterInfo() const override {
    return &InstrInfo.getRegisterInfo();
  }
  const CSATargetLowering *getTargetLowering() const override {
    return &TLInfo;
  }
  const CSASelectionDAGInfo *getSelectionDAGInfo() const override {
    return &TSInfo;
  }

  // No scheduling...
  RegisterScheduler::FunctionPassCtor
  getDAGScheduler(CodeGenOpt::Level) const override {
    return createDAGLinearizer;
  }
  bool enableMachineScheduler() const override { return false; }
  bool enablePostRAScheduler() const override { return false; }
};
} // namespace llvm

#endif // LLVM_TARGET_CSA_SUBTARGET_H
