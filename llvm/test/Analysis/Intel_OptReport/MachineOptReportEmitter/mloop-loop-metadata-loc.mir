# RUN: llc -run-pass=intel-mir-optreport-emitter -x mir < %s 2>&1 | FileCheck %s

# Because we have some functionality for fishing the original loop metadata out
# of IR for machine loops, we can use that to get a more accurate debug location
# for loops. This test checks that we can use that more accurate loop location
# when it's available.

# The original loop in this testcase (starting on line 10) is:

# do i=1,N
#   A(i) = i;
# end do

# With the loop metadata, we're able to identify this loop as starting on line
# 10; without it, we'd need to estimate the debug location from machine
# instructions and would end up with a debug location for the loop on line 13
# instead.

# CHECK:      Global Mloop optimization report for : iota_
# CHECK-EMPTY:
# CHECK-NEXT: LOOP BEGIN at iota.f90 (10, 3)
# CHECK-NEXT: LOOP END

--- |
  ; ModuleID = 'iota.bc'
  source_filename = "iota.f90"
  target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-unknown-linux-gnu"
  
  ; Function Attrs: argmemonly nofree nosync nounwind writeonly uwtable
  define void @iota_(double* noalias nocapture writeonly dereferenceable(8) %"iota_$A") local_unnamed_addr #0 !dbg !4 !llfort.type_idx !15 {
  alloca_0:
    call void @llvm.dbg.declare(metadata double* %"iota_$A", metadata !8, metadata !DIExpression()), !dbg !16
    call void @llvm.dbg.value(metadata i32 1, metadata !13, metadata !DIExpression()), !dbg !17
    br label %loop.17
  
  loop.17:                                          ; preds = %loop.17, %alloca_0
    %i1.i64.0 = phi i64 [ 0, %alloca_0 ], [ %nextivloop.17, %loop.17 ]
    %tmp = trunc i64 %i1.i64.0 to i32
    %0 = insertelement <16 x i32> undef, i32 %tmp, i64 0, !dbg !18
    %1 = shufflevector <16 x i32> %0, <16 x i32> poison, <16 x i32> zeroinitializer, !dbg !18
    %2 = add <16 x i32> %1, <i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16>, !dbg !18
    %3 = sitofp <16 x i32> %2 to <16 x double>, !dbg !18
    %scevgep = getelementptr double, double* %"iota_$A", i64 %i1.i64.0, !dbg !19
    %scevgep1 = bitcast double* %scevgep to <16 x double>*, !dbg !19
    store <16 x double> %3, <16 x double>* %scevgep1, align 1, !dbg !19, !tbaa !20
    %nextivloop.17 = add nuw nsw i64 %i1.i64.0, 16, !dbg !25
    %4 = add nsw i64 %nextivloop.17, -16, !dbg !25
    %condloop.17 = icmp ult i64 %4, 1008, !dbg !25
    br i1 %condloop.17, label %loop.17, label %afterloop.17, !dbg !25, !llvm.loop !26
  
  afterloop.17:                                     ; preds = %loop.17
    ret void, !dbg !29
  }
  
  ; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
  declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
  
  ; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
  declare void @llvm.dbg.value(metadata, metadata, metadata) #1
  
  attributes #0 = { argmemonly nofree nosync nounwind writeonly uwtable "denormal-fp-math"="preserve_sign" "frame-pointer"="none" "intel-lang"="fortran" "loopopt-pipeline"="full" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "target-cpu"="skylake-avx512" "target-features"="+adx,+aes,+avx,+avx2,+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl,+bmi,+bmi2,+clflushopt,+clwb,+crc32,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+pku,+popcnt,+prfchw,+rdrnd,+rdseed,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsavec,+xsaveopt,+xsaves" "unsafe-fp-math"="true" }
  attributes #1 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
  
  !llvm.module.flags = !{!0, !1}
  !llvm.dbg.cu = !{!2}
  !omp_offload.info = !{}
  
  !0 = !{i32 2, !"Debug Info Version", i32 3}
  !1 = !{i32 2, !"Dwarf Version", i32 4}
  !2 = distinct !DICompileUnit(language: DW_LANG_Fortran95, file: !3, producer: "Intel(R) Fortran 23.0-1051", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)
  !3 = !DIFile(filename: "iota.f90", directory: "/nfs/site/home/dwoodwor/iloc/iota")
  !4 = distinct !DISubprogram(name: "iota", linkageName: "iota_", scope: !3, file: !3, line: 1, type: !5, scopeLine: 1, spFlags: DISPFlagDefinition, unit: !2, retainedNodes: !7)
  !5 = !DISubroutineType(types: !6)
  !6 = !{null}
  !7 = !{!8, !13}
  !8 = !DILocalVariable(name: "a", arg: 1, scope: !4, file: !3, line: 1, type: !9)
  !9 = !DICompositeType(tag: DW_TAG_array_type, baseType: !10, elements: !11)
  !10 = !DIBasicType(name: "REAL*8", size: 64, encoding: DW_ATE_float)
  !11 = !{!12}
  !12 = !DISubrange(count: 1024, lowerBound: 1)
  !13 = !DILocalVariable(name: "i", scope: !4, file: !3, line: 8, type: !14)
  !14 = !DIBasicType(name: "INTEGER*4", size: 32, encoding: DW_ATE_signed)
  !15 = !{i64 25}
  !16 = !DILocation(line: 1, column: 17, scope: !4)
  !17 = !DILocation(line: 0, scope: !4)
  !18 = !DILocation(line: 11, column: 12, scope: !4)
  !19 = !DILocation(line: 11, column: 5, scope: !4)
  !20 = !{!21, !21, i64 0}
  !21 = !{!"ifx$unique_sym$2", !22, i64 0}
  !22 = !{!"Fortran Data Symbol", !23, i64 0}
  !23 = !{!"Generic Fortran Symbol", !24, i64 0}
  !24 = !{!"ifx$root$1$iota_"}
  !25 = !DILocation(line: 12, column: 3, scope: !4)
  !26 = distinct !{!26, !27, !28, !30}
  !27 = !{!"llvm.loop.vectorize.width", i32 1}
  !28 = !{!"llvm.loop.interleave.count", i32 1}
  !29 = !DILocation(line: 13, column: 1, scope: !4)
  !30 = !DILocation(line: 10, column: 3, scope: !4)

...
---
name:            iota_
alignment:       16
tracksRegLiveness: true
tracksDebugUserValues: true
liveins:
  - { reg: '$rdi' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
constants:
  - id:              0
    value:           '<8 x i32> <i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16>'
    alignment:       32
  - id:              1
    value:           '<8 x i32> <i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8>'
    alignment:       32
machineFunctionInfo: {}
body:             |
  bb.0.alloca_0:
    liveins: $rdi
  
    DBG_VALUE $rdi, 0, !8, !DIExpression(), debug-location !16
    renamable $eax = XOR32rr undef $eax, undef $eax, implicit-def dead $eflags, implicit-def $rax
    DBG_VALUE 1, $noreg, !13, !DIExpression(), debug-location !17
    renamable $ymm0 = VMOVDQAYrm $rip, 1, $noreg, %const.0, $noreg :: (load (s256) from constant-pool)
    renamable $ymm1 = VMOVDQAYrm $rip, 1, $noreg, %const.1, $noreg :: (load (s256) from constant-pool)
  
  bb.1.loop.17 (align 16):
    successors: %bb.1(0x7c000000), %bb.2(0x04000000)
    liveins: $rax, $rdi, $ymm0, $ymm1
  
    DBG_VALUE $rdi, 0, !8, !DIExpression(), debug-location !17
    DBG_VALUE 1, $noreg, !13, !DIExpression(), debug-location !17
    renamable $ymm2 = VPBROADCASTDrZ256rr renamable $eax, debug-location !18
    renamable $ymm3 = VPADDDYrr renamable $ymm2, renamable $ymm0, debug-location !18
    renamable $ymm2 = VPADDDYrr killed renamable $ymm2, renamable $ymm1, debug-location !18
    renamable $ymm4 = VCVTDQ2PDYrr renamable $xmm2, debug-location !18
    renamable $xmm2 = VEXTRACTI128rr killed renamable $ymm2, 1, debug-location !18
    renamable $ymm2 = VCVTDQ2PDYrr killed renamable $xmm2, debug-location !18
    renamable $ymm5 = VCVTDQ2PDYrr renamable $xmm3, debug-location !18
    renamable $xmm3 = VEXTRACTI128rr killed renamable $ymm3, 1, debug-location !18
    renamable $ymm3 = VCVTDQ2PDYrr killed renamable $xmm3, debug-location !18
    VMOVUPSYmr renamable $rdi, 8, renamable $rax, 96, $noreg, killed renamable $ymm3, debug-location !19 :: (store (s256) into %ir.scevgep1 + 96, align 1, !tbaa !20)
    VMOVUPSYmr renamable $rdi, 8, renamable $rax, 64, $noreg, killed renamable $ymm5, debug-location !19 :: (store (s256) into %ir.scevgep1 + 64, align 1, !tbaa !20)
    VMOVUPSYmr renamable $rdi, 8, renamable $rax, 32, $noreg, killed renamable $ymm2, debug-location !19 :: (store (s256) into %ir.scevgep1 + 32, align 1, !tbaa !20)
    VMOVUPSYmr renamable $rdi, 8, renamable $rax, 0, $noreg, killed renamable $ymm4, debug-location !19 :: (store (s256) into %ir.scevgep1, align 1, !tbaa !20)
    renamable $rcx = LEA64r renamable $rax, 1, $noreg, 16, $noreg, debug-location !25
    CMP64ri32 killed renamable $rax, 1008, implicit-def $eflags, debug-location !25
    $rax = MOV64rr killed $rcx
    JCC_1 %bb.1, 2, implicit killed $eflags, debug-location !25
  
  bb.2.afterloop.17:
    DBG_VALUE $rdi, 0, !8, !DIExpression(), debug-location !17
    DBG_VALUE 1, $noreg, !13, !DIExpression(), debug-location !17
    VZEROUPPER implicit-def $ymm0, implicit-def $ymm1, implicit-def $ymm2, implicit-def $ymm3, implicit-def $ymm4, implicit-def $ymm5, implicit-def $ymm6, implicit-def $ymm7, implicit-def $ymm8, implicit-def $ymm9, implicit-def $ymm10, implicit-def $ymm11, implicit-def $ymm12, implicit-def $ymm13, implicit-def $ymm14, implicit-def $ymm15, debug-location !29
    RET64 debug-location !29

...
