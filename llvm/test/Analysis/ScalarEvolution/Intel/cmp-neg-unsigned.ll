; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes="loop(indvars)" -S %s | FileCheck %s

; %temp has a known range [8,10].
; This logic:
;  %temp10 = add nsw i32 %temp9, -17
;  %temp11 = icmp ult i32 %temp10, -15
; is the same as "%temp9 < 2 || %temp9 > 16"
; The comparison is unsigned, so for example, if %temp9==18, then 18-17 ult -15.
; The nsw flag is valid, as the result is always in the range of 32-bit signed.

; SCEV deduces nuw because of the input range [8,10]. This is correct
; (as 10 + -17 does not go past 0), but then this causes SCEV to use a signed
; compare, which gives a different result than unsigned.
; This compare:
;  %temp21 = icmp ult i16 %temp17, %temp14
; is incorrectly deleted as always-true.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local void @foo(i16 %quotient, i16 %step) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br i1 undef, label [[BB3:%.*]], label [[BB4:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    br label [[BB4]]
; CHECK:       bb4:
; CHECK-NEXT:    [[TEMP:%.*]] = phi i8 [ 8, [[BB3]] ], [ 10, [[BB:%.*]] ]
; CHECK-NEXT:    [[TEMP9:%.*]] = zext i8 [[TEMP]] to i32
; CHECK-NEXT:    [[TEMP10:%.*]] = add nsw i32 [[TEMP9]], -17
; CHECK-NEXT:    [[TEMP11:%.*]] = icmp ult i32 [[TEMP10]], -15
; CHECK-NEXT:    br i1 [[TEMP11]], label [[BB27:%.*]], label [[BB12:%.*]]
; CHECK:       bb12:
; CHECK-NEXT:    br label [[BB13:%.*]]
; CHECK:       bb13:
; CHECK-NEXT:    [[TEMP14:%.*]] = zext i8 [[TEMP]] to i16
; CHECK-NEXT:    br label [[BB16:%.*]]
; CHECK:       bb16:
; CHECK-NEXT:    [[TEMP17:%.*]] = phi i16 [ [[TEMP23:%.*]], [[BB22:%.*]] ], [ [[QUOTIENT:%.*]], [[BB13]] ]
; CHECK-NEXT:    [[TEMP18:%.*]] = icmp eq i16 [[TEMP17]], [[TEMP14]]
; CHECK-NEXT:    br i1 [[TEMP18]], label [[BB19:%.*]], label [[BB20:%.*]]
; CHECK:       bb19:
; CHECK-NEXT:    unreachable
; CHECK:       bb20:
; CHECK-NEXT:    [[TEMP21:%.*]] = icmp ult i16 [[TEMP17]], [[TEMP14]]
; CHECK-NEXT:    br i1 [[TEMP21]], label [[BB24:%.*]], label [[BB22]]
; CHECK:       bb22:
; CHECK-NEXT:    [[TEMP23]] = sub i16 [[TEMP17]], [[STEP:%.*]]
; CHECK-NEXT:    br label [[BB16]]
; CHECK:       bb24:
; CHECK-NEXT:    unreachable
; CHECK:       bb27:
; CHECK-NEXT:    unreachable
;
bb:
  br i1 undef, label %bb3, label %bb4

bb3:                                              ; preds = %bb
  br label %bb4

bb4:                                              ; preds = %bb3, %bb
; the point of the logic above is just to get a multi-value range for %temp.
  %temp = phi i8 [ 8, %bb3 ], [ 10, %bb ]
  %temp9 = zext i8 %temp to i32
  %temp10 = add nsw i32 %temp9, -17
  %temp11 = icmp ult i32 %temp10, -15
  br i1 %temp11, label %bb27, label %bb12

bb12:                                             ; preds = %bb8
  br label %bb13

bb13:                                             ; preds = %bb12
  %temp14 = zext i8 %temp to i16
  br label %bb16

bb16:                                             ; preds = %bb22, %bb15
  %temp17 = phi i16 [ %temp23, %bb22 ], [ %quotient, %bb13 ]
  %temp18 = icmp eq i16 %temp17, %temp14
  br i1 %temp18, label %bb19, label %bb20

bb19:                                             ; preds = %bb16
  unreachable

bb20:                                             ; preds = %bb16
  %temp21 = icmp ult i16 %temp17, %temp14
  br i1 %temp21, label %bb24, label %bb22

bb22:                                             ; preds = %bb20
  %temp23 = sub i16 %temp17, %step
  br label %bb16

bb24:                                             ; preds = %bb20
  unreachable

bb27:                                             ; preds = %bb8
  unreachable

}

