; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -passes='print<scalar-evolution>' < %s -disable-output 2>&1 | FileCheck %s

; HIR prefers to see the LLVM IR for "select" (as an unknown blob)
; rather than "umin_seq".
; Suppress this recognition when the pre_loopopt attribute exists.

define i1 @logical_or(i1 %x, i1 %y) #0 {
; CHECK-LABEL: 'logical_or'
; CHECK-NEXT:  Classifying expressions for: @logical_or
; CHECK-NEXT:    %r = select i1 %x, i1 true, i1 %y
; CHECK-NEXT:    -->  %r U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @logical_or
;
  %r = select i1 %x, i1 true, i1 %y
  ret i1 %r
}

define i1 @logical_and(i1 %x, i1 %y) #0 {
; CHECK-LABEL: 'logical_and'
; CHECK-NEXT:  Classifying expressions for: @logical_and
; CHECK-NEXT:    %r = select i1 %x, i1 %y, i1 false
; CHECK-NEXT:    -->  %r U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @logical_and
;
  %r = select i1 %x, i1 %y, i1 false
  ret i1 %r
}

define i1 @select_x_or_false(i1 %c, i1 %x) #0 {
; CHECK-LABEL: 'select_x_or_false'
; CHECK-NEXT:  Classifying expressions for: @select_x_or_false
; CHECK-NEXT:    %r = select i1 %c, i1 %x, i1 false
; CHECK-NEXT:    -->  %r U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @select_x_or_false
;
  %r = select i1 %c, i1 %x, i1 false
  ret i1 %r
}

define i1 @select_false_or_x(i1 %c, i1 %x) #0 {
; CHECK-LABEL: 'select_false_or_x'
; CHECK-NEXT:  Classifying expressions for: @select_false_or_x
; CHECK-NEXT:    %r = select i1 %c, i1 false, i1 %x
; CHECK-NEXT:    -->  %r U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @select_false_or_x
;
  %r = select i1 %c, i1 false, i1 %x
  ret i1 %r
}

define i1 @select_x_or_true(i1 %c, i1 %x) #0 {
; CHECK-LABEL: 'select_x_or_true'
; CHECK-NEXT:  Classifying expressions for: @select_x_or_true
; CHECK-NEXT:    %r = select i1 %c, i1 %x, i1 true
; CHECK-NEXT:    -->  %r U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @select_x_or_true
;
  %r = select i1 %c, i1 %x, i1 true
  ret i1 %r
}

define i1 @select_true_or_x(i1 %c, i1 %x) #0 {
; CHECK-LABEL: 'select_true_or_x'
; CHECK-NEXT:  Classifying expressions for: @select_true_or_x
; CHECK-NEXT:    %r = select i1 %c, i1 true, i1 %x
; CHECK-NEXT:    -->  %r U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @select_true_or_x
;
  %r = select i1 %c, i1 true, i1 %x
  ret i1 %r
}

; check that umin_seq is emitted without loopopt (this is tested with llorg
; testing also)
define i1 @logical_or_no_loopopt(i1 %x, i1 %y) {
; CHECK-LABEL: 'logical_or_no_loopopt'
; CHECK-NEXT:  Classifying expressions for: @logical_or
; CHECK-NEXT:    %r = select i1 %x, i1 true, i1 %y
; CHECK-NEXT:    --> (true + ((true + %x) umin_seq (true + %y))) U: full-set S: full-set
; CHECK-NEXT:  Determining loop execution counts for: @logical_or
  %r = select i1 %x, i1 true, i1 %y
  ret i1 %r
}

attributes #0 = {"pre_loopopt"}
