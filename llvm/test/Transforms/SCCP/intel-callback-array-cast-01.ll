; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; This test case checks that the interprocedural sparse conditional constant
; propagation passes when the beginning of an array is casted to a pointer
; and it is used inside a callback.

; RUN: opt -ipsccp -S %s | FileCheck %s --check-prefix NOOPAQUE
; RUN: opt -passes=ipsccp -S %s | FileCheck %s --check-prefix NOOPAQUE
; RUN: opt -opaque-pointers -ipsccp -S %s | FileCheck %s --check-prefix OPAQUE
; RUN: opt -opaque-pointers -passes=ipsccp -S %s | FileCheck %s --check-prefix OPAQUE

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%TestStruct = type { [16 x i8], [16 x i8], i32 }
@globArray = internal global [1000 x %TestStruct] zeroinitializer

; Check that @globArray was casted correctly and %Arr was replaced with
; %bc_const in the GEP %dummy
define internal void @callback(i8* %ID, [1000 x %TestStruct]* %Arr) {
; NOOPAQUE-LABEL: @callback(
; NOOPAQUE-NEXT:  entry:
; NOOPAQUE-NEXT:    [[BC_CONST:%.*]] = bitcast %TestStruct* getelementptr inbounds ([1000 x %TestStruct], [1000 x %TestStruct]* @globArray, i64 0, i64 0) to [1000 x %TestStruct]*
; NOOPAQUE-NEXT:    [[DUMMY:%.*]] = getelementptr [1000 x %TestStruct], [1000 x %TestStruct]* [[BC_CONST]], i64 0, i64 0
; NOOPAQUE-NEXT:    ret void
;
; OPAQUE-LABEL: @callback(
; OPAQUE-NEXT:  entry:
; OPAQUE-NEXT:    ret void
;
entry:
  %dummy = getelementptr [1000 x %TestStruct], [1000 x %TestStruct]* %Arr, i64 0, i64 0
  ret void
}

; Check that the parameter in the call site for @callback was updated with the
; correct type
define internal void @foo(%TestStruct* %Arr) {
; NOOPAQUE-LABEL: @foo(
; NOOPAQUE-NEXT:  entry:
; NOOPAQUE-NEXT:    call void (i32, void (i8*, ...)*, ...) @broker(i32 3, void (i8*, ...)* bitcast (void (i8*, [1000 x %TestStruct]*)* @callback to void (i8*, ...)*), %TestStruct* getelementptr inbounds ([1000 x %TestStruct], [1000 x %TestStruct]* @globArray, i64 0, i64 0))
; NOOPAQUE-NEXT:    ret void
;
; OPAQUE-LABEL: @foo(
; OPAQUE-NEXT:  entry:
; OPAQUE-NEXT:    call void (i32, ptr, ...) @broker(i32 3, ptr @callback, ptr @globArray)
; OPAQUE-NEXT:    ret void
;
entry:
  call void (i32, void (i8*, ...)*, ...) @broker(i32 3, void (i8*, ...)* bitcast (void (i8*, [1000 x %TestStruct]*)* @callback to void (i8*, ...)*), %TestStruct* %Arr)
  ret void
}

define void @bar() {
; NOOPAQUE-LABEL: @bar(
; NOOPAQUE-NEXT:  entry:
; NOOPAQUE-NEXT:    call void @foo(%TestStruct* getelementptr inbounds ([1000 x %TestStruct], [1000 x %TestStruct]* @globArray, i64 0, i64 0))
; NOOPAQUE-NEXT:    ret void
;
; OPAQUE-LABEL: @bar(
; OPAQUE-NEXT:  entry:
; OPAQUE-NEXT:    call void @foo(ptr @globArray)
; OPAQUE-NEXT:    ret void
;
entry:
  call void @foo(%TestStruct* getelementptr inbounds ([1000 x %TestStruct], [1000 x %TestStruct]* bitcast ([1000 x %TestStruct]* @globArray to [1000 x %TestStruct]*), i64 0, i64 0))
  ret void
}

declare !callback !0 void @broker(i32, void (i8*, ...)*, ...)

!0 = !{!1}
!1 = !{i64 1, i64 -1, i1 true}
