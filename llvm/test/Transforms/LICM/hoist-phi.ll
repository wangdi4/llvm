; NOTE: Assertions have been autogenerated by utils/update_test_checks.py

; RUN: opt -S -passes=licm < %s | FileCheck %s -check-prefixes=CHECK,CHECK-DISABLED
; RUN: opt -S -passes=licm -licm-control-flow-hoisting=1 < %s | FileCheck %s -check-prefixes=CHECK,CHECK-ENABLED
; RUN: opt -S -passes=licm -licm-control-flow-hoisting=0 < %s | FileCheck %s -check-prefixes=CHECK,CHECK-DISABLED
; RUN: opt -passes='require<opt-remark-emit>,loop-mssa(licm)' -S < %s | FileCheck %s -check-prefixes=CHECK,CHECK-DISABLED

; RUN: opt -passes='require<opt-remark-emit>,loop-mssa(licm)' -licm-control-flow-hoisting=1 -verify-memoryssa -S < %s | FileCheck %s -check-prefixes=CHECK,CHECK-ENABLED
; Enable run below when adding promotion. e.g. "store i32 %phi, ptr %p" is promoted to phi.lcssa.
; opt -passes='require<opt-remark-emit>,loop-mssa(licm)' -licm-control-flow-hoisting=0 -verify-memoryssa -S < %s | FileCheck %s -check-prefixes=CHECK,CHECK-DISABLED

; INTEL_CUSTOMIZATION
; This output differs significantly from llorg. phi folding to select is not
; performed in xmain for many cases.

define void @triangle_phi(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@triangle_phi(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF]] ], [ [[X]], [[LOOP]] ]
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[LOOP]], label [[END:%.*]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i32 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@triangle_phi(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF_LICM]] ], [ [[X]], [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[LOOP]], label [[END:%.*]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    ret void
;
entry:
  br label %loop



loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %then

if:
  %add = add i32 %x, 1
  br label %then

then:
  %phi = phi i32 [ %add, %if ], [ %x, %loop ]
  store i32 %phi, ptr %p
  %cmp2 = icmp ne i32 %phi, 0
  br i1 %cmp2, label %loop, label %end

end:
  ret void
}

define void @diamond_phi(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@diamond_phi(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF]] ], [ [[SUB]], [[ELSE]] ]
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[LOOP]], label [[END:%.*]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i32 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@diamond_phi(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       else.licm:
; CHECK-ENABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF_LICM]] ], [ [[SUB]], [[ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[LOOP]], label [[END:%.*]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    ret void
;
entry:
  br label %loop




loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %else

if:
  %add = add i32 %x, 1
  br label %then

else:
  %sub = sub i32 %x, 1
  br label %then

then:
  %phi = phi i32 [ %add, %if ], [ %sub, %else ]
  store i32 %phi, ptr %p
  %cmp2 = icmp ne i32 %phi, 0
  br i1 %cmp2, label %loop, label %end

end:
  ret void
}

; TODO: This is currently too complicated for us to be able to hoist the phi.
define void @three_way_phi(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@three_way_phi(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[ADD]], 0
; CHECK-DISABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF:%.*]], label [[THEN]]
; CHECK-DISABLED:       if.if:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[LOOP]] ], [ [[ADD]], [[IF]] ], [ [[SUB]], [[IF_IF]] ]
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END:%.*]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i32 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@three_way_phi(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[ADD]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF:%.*]], label [[THEN]]
; CHECK-ENABLED:       if.if:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[LOOP]] ], [ [[ADD]], [[IF]] ], [ [[SUB]], [[IF_IF]] ]
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END:%.*]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i32 [ [[PHI]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    store i32 [[PHI_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    ret void
;



entry:
  br label %loop

loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %then

if:
  %add = add i32 %x, 1
  %cmp2 = icmp sgt i32 %add, 0
  br i1 %cmp2, label %if.if, label %then

if.if:
  %sub = sub i32 %x, 1
  br label %then

then:
  %phi = phi i32 [ 0, %loop ], [ %add, %if ], [ %sub, %if.if ]
  store i32 %phi, ptr %p
  %cmp3 = icmp ne i32 %phi, 0
  br i1 %cmp3, label %loop, label %end

end:
  ret void
}

; TODO: This is currently too complicated for us to be able to hoist the phi.
define void @tree_phi(i32 %x, ptr %p) {
; CHECK-LABEL: define {{[^@]+}}@tree_phi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[ADD]], 0
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK:       if:
; CHECK-NEXT:    br i1 [[CMP2]], label [[IF_IF:%.*]], label [[IF_ELSE:%.*]]
; CHECK:       if.if:
; CHECK-NEXT:    br label [[THEN:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    br label [[THEN]]
; CHECK:       else:
; CHECK-NEXT:    br label [[THEN]]
; CHECK:       then:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF_IF]] ], [ 0, [[IF_ELSE]] ], [ [[SUB]], [[ELSE]] ]
; CHECK-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    [[PHI_LCSSA:%.*]] = phi i32 [ [[PHI]], [[THEN]] ]
; CHECK-NEXT:    store i32 [[PHI_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-NEXT:    ret void
;

entry:
  br label %loop

loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %else

if:
  %add = add i32 %x, 1
  %cmp2 = icmp sgt i32 %add, 0
  br i1 %cmp2, label %if.if, label %if.else

if.if:
  br label %then

if.else:
  br label %then

else:
  %sub = sub i32 %x, 1
  br label %then

then:
  %phi = phi i32 [ %add, %if.if ], [ 0, %if.else ], [ %sub, %else ]
  store i32 %phi, ptr %p
  %cmp3 = icmp ne i32 %phi, 0
  br i1 %cmp3, label %loop, label %end

end:
  ret void
}

; TODO: We can hoist the first phi, but not the second.
define void @phi_phi(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@phi_phi(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[ADD]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF:%.*]], label [[IF_ELSE:%.*]]
; CHECK-DISABLED:       if.if:
; CHECK-DISABLED-NEXT:    br label [[IF_THEN:%.*]]
; CHECK-DISABLED:       if.else:
; CHECK-DISABLED-NEXT:    br label [[IF_THEN]]
; CHECK-DISABLED:       if.then:
; CHECK-DISABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ [[ADD]], [[IF_IF]] ], [ 0, [[IF_ELSE]] ]
; CHECK-DISABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ [[PHI1]], [[IF_THEN]] ], [ [[SUB]], [[ELSE]] ]
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI2]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END:%.*]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI2_LCSSA:%.*]] = phi i32 [ [[PHI2]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI2_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@phi_phi(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[ADD]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF_LICM:%.*]], label [[IF_ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.if.licm:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN_LICM:%.*]]
; CHECK-ENABLED:       if.else.licm:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN_LICM]]
; CHECK-ENABLED:       if.then.licm:
; CHECK-ENABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ [[ADD]], [[IF_IF_LICM]] ], [ 0, [[IF_ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF:%.*]], label [[IF_ELSE:%.*]]
; CHECK-ENABLED:       if.if:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN:%.*]]
; CHECK-ENABLED:       if.else:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN]]
; CHECK-ENABLED:       if.then:
; CHECK-ENABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ [[PHI1]], [[IF_THEN]] ], [ [[SUB]], [[ELSE]] ]
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI2]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END:%.*]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI2_LCSSA:%.*]] = phi i32 [ [[PHI2]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    store i32 [[PHI2_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    ret void
;




entry:
  br label %loop

loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %else

if:
  %add = add i32 %x, 1
  %cmp2 = icmp sgt i32 %add, 0
  br i1 %cmp2, label %if.if, label %if.else

if.if:
  br label %if.then

if.else:
  br label %if.then

if.then:
  %phi1 = phi i32 [ %add, %if.if ], [ 0, %if.else ]
  br label %then

else:
  %sub = sub i32 %x, 1
  br label %then

then:
  %phi2 = phi i32 [ %phi1, %if.then ], [ %sub, %else ]
  store i32 %phi2, ptr %p
  %cmp3 = icmp ne i32 %phi2, 0
  br i1 %cmp3, label %loop, label %end

end:
  ret void
}

; Check that we correctly duplicate empty control flow.
define i8 @empty_triangle_phi(i32 %x, i32 %y) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@empty_triangle_phi(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[Y:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF]] ], [ 1, [[LOOP]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[END:%.*]], label [[LOOP]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@empty_triangle_phi(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF_LICM]] ], [ 1, [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[Y:%.*]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[END:%.*]], label [[LOOP]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
entry:
  br label %loop



loop:
  %cmp1 = icmp eq i32 %x, 0
  br i1 %cmp1, label %if, label %then

if:
  br label %then

then:
  %phi = phi i8 [ 0, %if ], [ 1, %loop ]
  %cmp2 = icmp eq i32 %y, 0
  br i1 %cmp2, label %end, label %loop

end:
  ret i8 %phi
}

define i8 @empty_diamond_phi(i32 %x, i32 %y) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@empty_diamond_phi(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[Y:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF]] ], [ 1, [[ELSE]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[END:%.*]], label [[LOOP]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@empty_diamond_phi(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       else.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF_LICM]] ], [ 1, [[ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[Y:%.*]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[END:%.*]], label [[LOOP]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
entry:
  br label %loop




loop:
  %cmp1 = icmp eq i32 %x, 0
  br i1 %cmp1, label %if, label %else

if:
  br label %then

else:
  br label %then

then:
  %phi = phi i8 [ 0, %if ], [ 1, %else ]
  %cmp2 = icmp eq i32 %y, 0
  br i1 %cmp2, label %end, label %loop

end:
  ret i8 %phi
}

; Check that we correctly handle the case that the first thing we try to hoist is a phi.
define i8 @empty_triangle_phi_first(i32 %x, i1 %cond) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@empty_triangle_phi_first(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[COND:%.*]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF]] ], [ 1, [[LOOP]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@empty_triangle_phi_first(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    br i1 [[COND:%.*]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF_LICM]] ], [ 1, [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
entry:
  br label %loop



loop:
  br i1 %cond, label %if, label %then

if:
  br label %then

then:
  %phi = phi i8 [ 0, %if ], [ 1, %loop ]
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %end, label %loop

end:
  ret i8 %phi
}

define i8 @empty_diamond_phi_first(i32 %x, i1 %cond) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@empty_diamond_phi_first(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[COND:%.*]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF]] ], [ 1, [[ELSE]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@empty_diamond_phi_first(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    br i1 [[COND:%.*]], label [[IF_LICM:%.*]], label [[ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       else.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF_LICM]] ], [ 1, [[ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
entry:
  br label %loop




loop:
  br i1 %cond, label %if, label %else

if:
  br label %then

else:
  br label %then

then:
  %phi = phi i8 [ 0, %if ], [ 1, %else ]
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %end, label %loop

end:
  ret i8 %phi
}

define i8 @empty_triangle_phi_first_empty_loop_head(i32 %x, i1 %cond) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@empty_triangle_phi_first_empty_loop_head(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br label [[TEST:%.*]]
; CHECK-DISABLED:       test:
; CHECK-DISABLED-NEXT:    br i1 [[COND:%.*]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF]] ], [ 1, [[TEST]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@empty_triangle_phi_first_empty_loop_head(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    br i1 [[COND:%.*]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF_LICM]] ], [ 1, [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br label [[TEST:%.*]]
; CHECK-ENABLED:       test:
; CHECK-ENABLED-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
entry:
  br label %loop



loop:
  br label %test

test:
  br i1 %cond, label %if, label %then

if:
  br label %then

then:
  %phi = phi i8 [ 0, %if ], [ 1, %test ]
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %end, label %loop

end:
  ret i8 %phi
}

define i8 @empty_diamond_phi_first_empty_loop_head(i32 %x, i1 %cond) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@empty_diamond_phi_first_empty_loop_head(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br label [[TEST:%.*]]
; CHECK-DISABLED:       test:
; CHECK-DISABLED-NEXT:    br i1 [[COND:%.*]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF]] ], [ 1, [[ELSE]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@empty_diamond_phi_first_empty_loop_head(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    br i1 [[COND:%.*]], label [[IF_LICM:%.*]], label [[ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       else.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i8 [ 0, [[IF_LICM]] ], [ 1, [[ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br label [[TEST:%.*]]
; CHECK-ENABLED:       test:
; CHECK-ENABLED-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[LOOP]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI_LCSSA:%.*]] = phi i8 [ [[PHI]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    ret i8 [[PHI_LCSSA]]
;
entry:
  br label %loop




loop:
  br label %test

test:
  br i1 %cond, label %if, label %else

if:
  br label %then

else:
  br label %then

then:
  %phi = phi i8 [ 0, %if ], [ 1, %else ]
  %cmp = icmp eq i32 %x, 0
  br i1 %cmp, label %end, label %loop

end:
  ret i8 %phi
}

; The phi is on one branch of a diamond while simultaneously at the end of a
; triangle. Check that we duplicate the triangle and not the diamond.
define void @triangle_diamond(ptr %ptr, i32 %x, i32 %y) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@triangle_diamond(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[Y:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[IF_THEN:%.*]], label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[IF]] ], [ 127, [[LOOP]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI]], ptr [[PTR:%.*]], align 4
; CHECK-DISABLED-NEXT:    br label [[END:%.*]]
; CHECK-DISABLED:       if.then:
; CHECK-DISABLED-NEXT:    br label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@triangle_diamond(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[Y:%.*]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[IF_LICM]] ], [ 127, [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_THEN:%.*]], label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[PTR:%.*]], align 4
; CHECK-ENABLED-NEXT:    br label [[END:%.*]]
; CHECK-ENABLED:       if.then:
; CHECK-ENABLED-NEXT:    br label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop



loop:
  %cmp1 = icmp ne i32 %x, 0
  br i1 %cmp1, label %if, label %then

if:
  %cmp2 = icmp ne i32 %y, 0
  br i1 %cmp2, label %if.then, label %then

then:
  %phi = phi i32 [ 0, %if ], [ 127, %loop ]
  store i32 %phi, ptr %ptr
  br label %end

if.then:
  br label %end

end:
  br label %loop
}

; As the previous, but the end of the diamond is the head of the loop.
define void @triangle_diamond_backedge(ptr %ptr, i32 %x, i32 %y) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@triangle_diamond_backedge(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[Y:%.*]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[BACKEDGE:%.*]], label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[IF]] ], [ 127, [[LOOP]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI]], ptr [[PTR:%.*]], align 4
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-DISABLED:       loop.backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
; CHECK-DISABLED:       backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@triangle_diamond_backedge(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[Y:%.*]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[IF_LICM]] ], [ 127, [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[BACKEDGE:%.*]], label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[PTR:%.*]], align 4
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-ENABLED:       loop.backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
; CHECK-ENABLED:       backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE]]
;
entry:
  br label %loop



loop:
  %cmp1 = icmp ne i32 %x, 0
  br i1 %cmp1, label %if, label %then

if:
  %cmp2 = icmp ne i32 %y, 0
  br i1 %cmp2, label %backedge, label %then

then:
  %phi = phi i32 [ 0, %if ], [ 127, %loop ]
  store i32 %phi, ptr %ptr
  br label %loop

backedge:
  br label %loop
}

; TODO: The inner diamonds can be hoisted, but not currently the outer diamond
define void @diamonds_inside_diamond(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@diamonds_inside_diamond(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[X]], -10
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[X]], 10
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF:%.*]], label [[IF_ELSE:%.*]]
; CHECK-DISABLED:       if.if:
; CHECK-DISABLED-NEXT:    br label [[IF_THEN:%.*]]
; CHECK-DISABLED:       if.else:
; CHECK-DISABLED-NEXT:    br label [[IF_THEN]]
; CHECK-DISABLED:       if.then:
; CHECK-DISABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[IF_IF]] ], [ 1, [[IF_ELSE]] ]
; CHECK-DISABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[ELSE_IF:%.*]], label [[ELSE_ELSE:%.*]]
; CHECK-DISABLED:       else.if:
; CHECK-DISABLED-NEXT:    br label [[ELSE_THEN:%.*]]
; CHECK-DISABLED:       else.else:
; CHECK-DISABLED-NEXT:    br label [[ELSE_THEN]]
; CHECK-DISABLED:       else.then:
; CHECK-DISABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ 2, [[ELSE_IF]] ], [ 3, [[ELSE_ELSE]] ]
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI3:%.*]] = phi i32 [ [[PHI1]], [[IF_THEN]] ], [ [[PHI2]], [[ELSE_THEN]] ]
; CHECK-DISABLED-NEXT:    [[CMP4:%.*]] = icmp ne i32 [[PHI3]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP4]], label [[LOOP]], label [[END:%.*]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI3_LCSSA:%.*]] = phi i32 [ [[PHI3]], [[THEN]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI3_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@diamonds_inside_diamond(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp slt i32 [[X]], -10
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[ELSE_IF_LICM:%.*]], label [[ELSE_ELSE_LICM:%.*]]
; CHECK-ENABLED:       else.if.licm:
; CHECK-ENABLED-NEXT:    br label [[ELSE_THEN_LICM:%.*]]
; CHECK-ENABLED:       else.else.licm:
; CHECK-ENABLED-NEXT:    br label [[ELSE_THEN_LICM]]
; CHECK-ENABLED:       else.then.licm:
; CHECK-ENABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ 2, [[ELSE_IF_LICM]] ], [ 3, [[ELSE_ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 [[X]], 10
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF_LICM:%.*]], label [[IF_ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.if.licm:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN_LICM:%.*]]
; CHECK-ENABLED:       if.else.licm:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN_LICM]]
; CHECK-ENABLED:       if.then.licm:
; CHECK-ENABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[IF_IF_LICM]] ], [ 1, [[IF_ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_IF:%.*]], label [[IF_ELSE:%.*]]
; CHECK-ENABLED:       if.if:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN:%.*]]
; CHECK-ENABLED:       if.else:
; CHECK-ENABLED-NEXT:    br label [[IF_THEN]]
; CHECK-ENABLED:       if.then:
; CHECK-ENABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[ELSE_IF:%.*]], label [[ELSE_ELSE:%.*]]
; CHECK-ENABLED:       else.if:
; CHECK-ENABLED-NEXT:    br label [[ELSE_THEN:%.*]]
; CHECK-ENABLED:       else.else:
; CHECK-ENABLED-NEXT:    br label [[ELSE_THEN]]
; CHECK-ENABLED:       else.then:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    [[PHI3:%.*]] = phi i32 [ [[PHI1]], [[IF_THEN]] ], [ [[PHI2]], [[ELSE_THEN]] ]
; CHECK-ENABLED-NEXT:    [[CMP4:%.*]] = icmp ne i32 [[PHI3]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP4]], label [[LOOP]], label [[END:%.*]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI3_LCSSA:%.*]] = phi i32 [ [[PHI3]], [[THEN]] ]
; CHECK-ENABLED-NEXT:    store i32 [[PHI3_LCSSA]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    ret void
;
entry:
  br label %loop







loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %else

if:
  %cmp2 = icmp sgt i32 %x, 10
  br i1 %cmp2, label %if.if, label %if.else

if.if:
  br label %if.then

if.else:
  br label %if.then

if.then:
  %phi1 = phi i32 [ 0, %if.if ], [ 1, %if.else ]
  br label %then

else:
  %cmp3 = icmp slt i32 %x, -10
  br i1 %cmp3, label %else.if, label %else.else

else.if:
  br label %else.then

else.else:
  br label %else.then

else.then:
  %phi2 = phi i32 [ 2, %else.if ], [ 3, %else.else ]
  br label %then

then:
  %phi3 = phi i32 [ %phi1, %if.then ], [ %phi2, %else.then ]
  store i32 %phi3, ptr %p
  %cmp4 = icmp ne i32 %phi3, 0
  br i1 %cmp4, label %loop, label %end

end:
  ret void
}

; We can hoist blocks that contain an edge that exits the loop by ignoring that
; edge in the hoisted block.
define void @triangle_phi_loopexit(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@triangle_phi_loopexit(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X:%.*]], 1
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 10, [[ADD]]
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[THEN]], label [[END:%.*]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF]] ], [ [[X]], [[LOOP]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@triangle_phi_loopexit(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X:%.*]], 1
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 10, [[ADD]]
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF_LICM]] ], [ [[X]], [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[THEN]], label [[END:%.*]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    ret void
;
; xmain does not canonicalize cmp,sgt,0 to "sle"
; %cmp1 = icmp sgt i32...
; %cmp1.not = xor i1 %cmp1...
entry:
  br label %loop

loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %then

if:
  %add = add i32 %x, 1
  %cmp2 = icmp sgt i32 10, %add
  br i1 %cmp2, label %then, label %end

then:
  %phi = phi i32 [ %add, %if ], [ %x, %loop ]
  store i32 %phi, ptr %p
  %cmp3 = icmp ne i32 %phi, 0
  br i1 %cmp3, label %loop, label %end

end:
  ret void
}

define void @diamond_phi_oneloopexit(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@diamond_phi_oneloopexit(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X:%.*]], 1
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-DISABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 10, [[ADD]]
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF]] ], [ [[SUB]], [[ELSE]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@diamond_phi_oneloopexit(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X:%.*]], 1
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 10, [[ADD]]
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       else.licm:
; CHECK-ENABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X]], 1
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF_LICM]] ], [ [[SUB]], [[ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[LOOP]], label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    ret void
;
entry:
  br label %loop




loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %else

if:
  %add = add i32 %x, 1
  %cmp2 = icmp sgt i32 10, %add
  br i1 %cmp2, label %then, label %end

else:
  %sub = sub i32 %x, 1
  br label %then

then:
  %phi = phi i32 [ %add, %if ], [ %sub, %else ]
  store i32 %phi, ptr %p
  %cmp3 = icmp ne i32 %phi, 0
  br i1 %cmp3, label %loop, label %end

end:
  ret void
}

define void @diamond_phi_twoloopexit(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@diamond_phi_twoloopexit(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X:%.*]], 1
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp sgt i32 10, [[SUB]]
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 10, [[ADD]]
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[THEN]], label [[END]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF]] ], [ [[SUB]], [[ELSE]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    [[CMP4:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-DISABLED-NEXT:    br i1 [[CMP4]], label [[LOOP]], label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    ret void
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@diamond_phi_twoloopexit(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[SUB:%.*]] = sub i32 [[X:%.*]], 1
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 1
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp sgt i32 [[X]], 0
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp sgt i32 10, [[SUB]]
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp sgt i32 10, [[ADD]]
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       else.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[ADD]], [[IF_LICM]] ], [ [[SUB]], [[ELSE_LICM]] ]
; CHECK-ENABLED-NEXT:    [[CMP4:%.*]] = icmp ne i32 [[PHI]], 0
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[THEN:%.*]], label [[END:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[THEN]], label [[END]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    br i1 [[CMP4]], label [[LOOP]], label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    ret void
;
entry:
  br label %loop




loop:
  %cmp1 = icmp sgt i32 %x, 0
  br i1 %cmp1, label %if, label %else

if:
  %add = add i32 %x, 1
  %cmp2 = icmp sgt i32 10, %add
  br i1 %cmp2, label %then, label %end

else:
  %sub = sub i32 %x, 1
  %cmp3 = icmp sgt i32 10, %sub
  br i1 %cmp3, label %then, label %end

then:
  %phi = phi i32 [ %add, %if ], [ %sub, %else ]
  store i32 %phi, ptr %p
  %cmp4 = icmp ne i32 %phi, 0
  br i1 %cmp4, label %loop, label %end

end:
  ret void
}

; The store cannot be hoisted, so add and shr cannot be hoisted into a
; conditional block.
define void @conditional_use(i32 %x, ptr %p) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@conditional_use(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[COND:%.*]] = icmp ugt i32 [[X:%.*]], 0
; CHECK-DISABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 5
; CHECK-DISABLED-NEXT:    [[SHR:%.*]] = ashr i32 [[ADD]], 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    store i32 [[SHR]], ptr [[P:%.*]], align 4
; CHECK-DISABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-DISABLED:       else:
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@conditional_use(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[COND:%.*]] = icmp ugt i32 [[X:%.*]], 0
; CHECK-ENABLED-NEXT:    [[ADD:%.*]] = add i32 [[X]], 5
; CHECK-ENABLED-NEXT:    [[SHR:%.*]] = ashr i32 [[ADD]], 1
; CHECK-ENABLED-NEXT:    br i1 [[COND]], label [[IF_LICM:%.*]], label [[ELSE_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       else.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[COND]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    store i32 [[SHR]], ptr [[P:%.*]], align 4
; CHECK-ENABLED-NEXT:    br label [[THEN:%.*]]
; CHECK-ENABLED:       else:
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop

loop:
  %cond = icmp ugt i32 %x, 0
  br i1 %cond, label %if, label %else

if:
  %add = add i32 %x, 5
  %shr = ashr i32 %add, 1
  store i32 %shr, ptr %p, align 4
  br label %then

else:
  br label %then

then:
  br label %loop
}

; A diamond with two triangles on the left and one on the right. This test is
; to check that we have a unique loop preheader when we hoist the store (and so
; don't fail an assertion).
define void @triangles_in_diamond(ptr %ptr) {
; CHECK-LABEL: define {{[^@]+}}@triangles_in_diamond(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 0, ptr [[PTR:%.*]], align 4
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 undef, label [[LEFT_TRIANGLE_1:%.*]], label [[RIGHT_TRIANGLE:%.*]]
; CHECK:       left_triangle_1:
; CHECK-NEXT:    br i1 undef, label [[LEFT_TRIANGLE_1_IF:%.*]], label [[LEFT_TRIANGLE_2:%.*]]
; CHECK:       left_triangle_1_if:
; CHECK-NEXT:    br label [[LEFT_TRIANGLE_2]]
; CHECK:       left_triangle_2:
; CHECK-NEXT:    br i1 undef, label [[LEFT_TRIANGLE_2_IF:%.*]], label [[LEFT_TRIANGLE_2_THEN:%.*]]
; CHECK:       left_triangle_2_if:
; CHECK-NEXT:    br label [[LEFT_TRIANGLE_2_THEN]]
; CHECK:       left_triangle_2_then:
; CHECK-NEXT:    br label [[LOOP_END:%.*]]
; CHECK:       right_triangle:
; CHECK-NEXT:    br i1 undef, label [[RIGHT_TRIANGLE_IF:%.*]], label [[RIGHT_TRIANGLE_THEN:%.*]]
; CHECK:       right_triangle.if:
; CHECK-NEXT:    br label [[RIGHT_TRIANGLE_THEN]]
; CHECK:       right_triangle.then:
; CHECK-NEXT:    br label [[LOOP_END]]
; CHECK:       loop.end:
; CHECK-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop

loop:
  br i1 undef, label %left_triangle_1, label %right_triangle

left_triangle_1:
  br i1 undef, label %left_triangle_1_if, label %left_triangle_2

left_triangle_1_if:
  br label %left_triangle_2

left_triangle_2:
  br i1 undef, label %left_triangle_2_if, label %left_triangle_2_then

left_triangle_2_if:
  br label %left_triangle_2_then

left_triangle_2_then:
  br label %loop.end

right_triangle:
  br i1 undef, label %right_triangle.if, label %right_triangle.then

right_triangle.if:
  br label %right_triangle.then

right_triangle.then:
  br label %loop.end

loop.end:
  store i32 0, ptr %ptr, align 4
  br label %loop
}

; %cmp dominates its used after being hoisted, but not after %brmerge is rehoisted
define void @rehoist(ptr %this, i32 %x) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@rehoist(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[SUB:%.*]] = add nsw i32 [[X:%.*]], -1
; CHECK-DISABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 0, [[SUB]]
; CHECK-DISABLED-NEXT:    [[BRMERGE:%.*]] = or i1 [[CMP]], true
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-DISABLED:       if1:
; CHECK-DISABLED-NEXT:    call void [[THIS:%.*]](ptr [[THIS]])
; CHECK-DISABLED-NEXT:    br label [[THEN1:%.*]]
; CHECK-DISABLED:       else1:
; CHECK-DISABLED-NEXT:    br label [[THEN1]]
; CHECK-DISABLED:       then1:
; CHECK-DISABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[ELSE2:%.*]]
; CHECK-DISABLED:       else2:
; CHECK-DISABLED-NEXT:    br i1 [[BRMERGE]], label [[IF3:%.*]], label [[END]]
; CHECK-DISABLED:       if3:
; CHECK-DISABLED-NEXT:    br label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@rehoist(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[SUB:%.*]] = add nsw i32 [[X:%.*]], -1
; CHECK-ENABLED-NEXT:    [[CMP:%.*]] = icmp eq i32 0, [[SUB]]
; CHECK-ENABLED-NEXT:    [[BRMERGE:%.*]] = or i1 [[CMP]], true
; CHECK-ENABLED-NEXT:    br i1 [[CMP]], label [[END_LICM:%.*]], label [[ELSE2_LICM:%.*]]
; CHECK-ENABLED:       else2.licm:
; CHECK-ENABLED-NEXT:    br label [[END_LICM]]
; CHECK-ENABLED:       end.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-ENABLED:       if1:
; CHECK-ENABLED-NEXT:    call void [[THIS:%.*]](ptr [[THIS]])
; CHECK-ENABLED-NEXT:    br label [[THEN1:%.*]]
; CHECK-ENABLED:       else1:
; CHECK-ENABLED-NEXT:    br label [[THEN1]]
; CHECK-ENABLED:       then1:
; CHECK-ENABLED-NEXT:    br i1 [[CMP]], label [[END:%.*]], label [[ELSE2:%.*]]
; CHECK-ENABLED:       else2:
; CHECK-ENABLED-NEXT:    br i1 [[BRMERGE]], label [[IF3:%.*]], label [[END]]
; CHECK-ENABLED:       if3:
; CHECK-ENABLED-NEXT:    br label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  %sub = add nsw i32 %x, -1
  br label %loop

loop:
  br i1 undef, label %if1, label %else1

if1:
  call void %this(ptr %this)
  br label %then1

else1:
  br label %then1

then1:
  %cmp = icmp eq i32 0, %sub
  br i1 %cmp, label %end, label %else2

else2:
  %brmerge = or i1 %cmp, true
  br i1 %brmerge, label %if3, label %end

if3:
  br label %end

end:
  br label %loop
}

; A test case that uses empty blocks in a way that can cause control flow
; hoisting to get confused.
define void @empty_blocks_multiple_conditional_branches(float %arg, ptr %ptr) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@empty_blocks_multiple_conditional_branches(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[DIV2:%.*]] = fmul float [[ARG:%.*]], 2.000000e+00
; CHECK-DISABLED-NEXT:    [[DIV1:%.*]] = fmul float [[ARG]], 4.000000e+00
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[BACKEDGE2:%.*]], label [[COND1:%.*]]
; CHECK-DISABLED:       cond1:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[COND1_IF:%.*]], label [[COND1_ELSE:%.*]]
; CHECK-DISABLED:       cond1.else:
; CHECK-DISABLED-NEXT:    br label [[COND3:%.*]]
; CHECK-DISABLED:       cond1.if:
; CHECK-DISABLED-NEXT:    br label [[COND1_IF_NEXT:%.*]]
; CHECK-DISABLED:       cond1.if.next:
; CHECK-DISABLED-NEXT:    br label [[COND2:%.*]]
; CHECK-DISABLED:       cond2:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[COND2_IF:%.*]], label [[COND2_THEN:%.*]]
; CHECK-DISABLED:       cond2.if:
; CHECK-DISABLED-NEXT:    br label [[COND2_THEN]]
; CHECK-DISABLED:       cond2.then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi float [ 0.000000e+00, [[COND2]] ], [ [[DIV1]], [[COND2_IF]] ]
; CHECK-DISABLED-NEXT:    store float [[PHI]], ptr [[PTR:%.*]], align 4
; CHECK-DISABLED-NEXT:    br label [[BACKEDGE2]]
; CHECK-DISABLED:       cond3:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[COND3_THEN:%.*]], label [[COND3_IF:%.*]]
; CHECK-DISABLED:       cond3.if:
; CHECK-DISABLED-NEXT:    store float [[DIV2]], ptr [[PTR]], align 4
; CHECK-DISABLED-NEXT:    br label [[COND3_THEN]]
; CHECK-DISABLED:       cond3.then:
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-DISABLED:       loop.backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
; CHECK-DISABLED:       backedge2:
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@empty_blocks_multiple_conditional_branches(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[DIV2:%.*]] = fmul float [[ARG:%.*]], 2.000000e+00
; CHECK-ENABLED-NEXT:    br i1 undef, label [[COND3_THEN_LICM:%.*]], label [[COND3_IF_LICM:%.*]]
; CHECK-ENABLED:       cond3.if.licm:
; CHECK-ENABLED-NEXT:    br label [[COND3_THEN_LICM]]
; CHECK-ENABLED:       cond3.then.licm:
; CHECK-ENABLED-NEXT:    [[DIV1:%.*]] = fmul float [[ARG]], 4.000000e+00
; CHECK-ENABLED-NEXT:    br i1 undef, label [[COND2_IF_LICM:%.*]], label [[COND2_THEN_LICM:%.*]]
; CHECK-ENABLED:       cond2.if.licm:
; CHECK-ENABLED-NEXT:    br label [[COND2_THEN_LICM]]
; CHECK-ENABLED:       cond2.then.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi float [ 0.000000e+00, [[COND3_THEN_LICM]] ], [ [[DIV1]], [[COND2_IF_LICM]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[BACKEDGE2:%.*]], label [[COND1:%.*]]
; CHECK-ENABLED:       cond1:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[COND1_IF:%.*]], label [[COND1_ELSE:%.*]]
; CHECK-ENABLED:       cond1.else:
; CHECK-ENABLED-NEXT:    br label [[COND3:%.*]]
; CHECK-ENABLED:       cond1.if:
; CHECK-ENABLED-NEXT:    br label [[COND1_IF_NEXT:%.*]]
; CHECK-ENABLED:       cond1.if.next:
; CHECK-ENABLED-NEXT:    br label [[COND2:%.*]]
; CHECK-ENABLED:       cond2:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[COND2_IF:%.*]], label [[COND2_THEN:%.*]]
; CHECK-ENABLED:       cond2.if:
; CHECK-ENABLED-NEXT:    br label [[COND2_THEN]]
; CHECK-ENABLED:       cond2.then:
; CHECK-ENABLED-NEXT:    store float [[PHI]], ptr [[PTR:%.*]], align 4
; CHECK-ENABLED-NEXT:    br label [[BACKEDGE2]]
; CHECK-ENABLED:       cond3:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[COND3_THEN:%.*]], label [[COND3_IF:%.*]]
; CHECK-ENABLED:       cond3.if:
; CHECK-ENABLED-NEXT:    store float [[DIV2]], ptr [[PTR]], align 4
; CHECK-ENABLED-NEXT:    br label [[COND3_THEN]]
; CHECK-ENABLED:       cond3.then:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-ENABLED:       loop.backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
; CHECK-ENABLED:       backedge2:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE]]
;
entry:
  br label %loop

; The exact path to the phi isn't checked here, because it depends on whether
; cond2 or cond3 is hoisted first

loop:
  br i1 undef, label %backedge2, label %cond1

cond1:
  br i1 undef, label %cond1.if, label %cond1.else

cond1.else:
  br label %cond3

cond1.if:
  br label %cond1.if.next

cond1.if.next:
  br label %cond2

cond2:
  %div1 = fmul float %arg, 4.000000e+00
  br i1 undef, label %cond2.if, label %cond2.then

cond2.if:
  br label %cond2.then

cond2.then:
  %phi = phi float [ 0.000000e+00, %cond2 ], [ %div1, %cond2.if ]
  store float %phi, ptr %ptr
  br label %backedge2

cond3:
  br i1 undef, label %cond3.then, label %cond3.if

cond3.if:
  %div2 = fmul float %arg, 2.000000e+00
  store float %div2, ptr %ptr
  br label %cond3.then

cond3.then:
  br label %loop

backedge2:
  br label %loop
}

; We can't do much here, so mainly just check that we don't crash.
define void @many_path_phi(ptr %ptr1, ptr %ptr2) {
; CHECK-LABEL: define {{[^@]+}}@many_path_phi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr [[PTR2:%.*]], i32 2
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, ptr [[PTR2]], i32 2
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[PHI2:%.*]], [[END:%.*]] ]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ugt i32 [[PHI1]], 3
; CHECK-NEXT:    br i1 [[CMP1]], label [[COND2:%.*]], label [[COND1:%.*]]
; CHECK:       cond1:
; CHECK-NEXT:    br i1 undef, label [[END]], label [[COND1_ELSE:%.*]]
; CHECK:       cond1.else:
; CHECK-NEXT:    [[VAL2:%.*]] = load i32, ptr [[GEP2]], align 4
; CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[VAL2]], 13
; CHECK-NEXT:    br i1 [[CMP2]], label [[COND1_END:%.*]], label [[END]]
; CHECK:       cond1.end:
; CHECK-NEXT:    br label [[END]]
; CHECK:       cond2:
; CHECK-NEXT:    br i1 undef, label [[END]], label [[COND2_ELSE:%.*]]
; CHECK:       cond2.else:
; CHECK-NEXT:    [[VAL3:%.*]] = load i32, ptr [[GEP3]], align 4
; CHECK-NEXT:    [[CMP3:%.*]] = icmp eq i32 [[VAL3]], 13
; CHECK-NEXT:    br i1 [[CMP3]], label [[COND2_END:%.*]], label [[END]]
; CHECK:       cond2.end:
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    [[PHI2]] = phi i32 [ 1, [[COND1]] ], [ 2, [[COND1_ELSE]] ], [ 3, [[COND1_END]] ], [ 4, [[COND2]] ], [ 5, [[COND2_ELSE]] ], [ 6, [[COND2_END]] ]
; CHECK-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop

loop:
  %phi1 = phi i32 [ 0, %entry ], [ %phi2, %end ]
  %cmp1 = icmp ugt i32 %phi1, 3
  br i1 %cmp1, label %cond2, label %cond1

cond1:
  br i1 undef, label %end, label %cond1.else

cond1.else:
  %gep2 = getelementptr inbounds i32, ptr %ptr2, i32 2
  %val2 = load i32, ptr %gep2, align 4
  %cmp2 = icmp eq i32 %val2, 13
  br i1 %cmp2, label %cond1.end, label %end

cond1.end:
  br label %end

cond2:
  br i1 undef, label %end, label %cond2.else

cond2.else:
  %gep3 = getelementptr inbounds i32, ptr %ptr2, i32 2
  %val3 = load i32, ptr %gep3, align 4
  %cmp3 = icmp eq i32 %val3, 13
  br i1 %cmp3, label %cond2.end, label %end

cond2.end:
  br label %end

end:
  %phi2 = phi i32 [ 1, %cond1 ], [ 2, %cond1.else ], [ 3, %cond1.end ], [ 4, %cond2 ], [ 5, %cond2.else ], [ 6, %cond2.end ]
  br label %loop
}

; Check that we correctly handle the hoisting of %gep when theres a critical
; edge that branches to the preheader.
define void @crit_edge(ptr %ptr, i32 %idx, i1 %cond1, i1 %cond2) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@crit_edge(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[GEP:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[IDX:%.*]]
; CHECK-DISABLED-NEXT:    br label [[PREHEADER:%.*]]
; CHECK-DISABLED:       preheader:
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[COND1:%.*]], label [[THEN:%.*]], label [[IF:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-DISABLED-NEXT:    br label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[VAL]], [[IF]] ], [ 0, [[LOOP]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI]], ptr [[PTR]], align 4
; CHECK-DISABLED-NEXT:    br i1 [[COND2:%.*]], label [[LOOP]], label [[CRIT_EDGE:%.*]]
; CHECK-DISABLED:       crit_edge:
; CHECK-DISABLED-NEXT:    br label [[PREHEADER]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@crit_edge(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[GEP:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i32 [[IDX:%.*]]
; CHECK-ENABLED-NEXT:    br label [[PREHEADER:%.*]]
; CHECK-ENABLED:       preheader:
; CHECK-ENABLED-NEXT:    br i1 [[COND1:%.*]], label [[THEN_LICM:%.*]], label [[IF_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[COND1]], label [[THEN:%.*]], label [[IF:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-ENABLED-NEXT:    br label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i32 [ [[VAL]], [[IF]] ], [ 0, [[LOOP]] ]
; CHECK-ENABLED-NEXT:    store i32 [[PHI]], ptr [[PTR]], align 4
; CHECK-ENABLED-NEXT:    br i1 [[COND2:%.*]], label [[LOOP]], label [[CRIT_EDGE:%.*]]
; CHECK-ENABLED:       crit_edge:
; CHECK-ENABLED-NEXT:    br label [[PREHEADER]]
;
entry:
  br label %preheader

preheader:
  br label %loop

loop:
  br i1 %cond1, label %then, label %if

if:
  %gep = getelementptr inbounds i32, ptr %ptr, i32 %idx
  %val = load i32, ptr %gep
  br label %then

then:
  %phi = phi i32 [ %val, %if ], [ 0, %loop ]
  store i32 %phi, ptr %ptr
  br i1 %cond2, label %loop, label %crit_edge

crit_edge:
  br label %preheader
}

; Check that the conditional sub is correctly hoisted from the inner loop to the
; preheader of the outer loop.
define void @hoist_from_innermost_loop(i32 %nx, ptr %ptr) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@hoist_from_innermost_loop(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[SUB:%.*]] = sub nsw i32 0, [[NX:%.*]]
; CHECK-DISABLED-NEXT:    br label [[OUTER_LOOP:%.*]]
; CHECK-DISABLED:       outer_loop:
; CHECK-DISABLED-NEXT:    br label [[MIDDLE_LOOP:%.*]]
; CHECK-DISABLED:       middle_loop:
; CHECK-DISABLED-NEXT:    br label [[INNER_LOOP:%.*]]
; CHECK-DISABLED:       inner_loop:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[INNER_LOOP_END:%.*]], label [[IF:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    store i32 [[SUB]], ptr [[PTR:%.*]], align 4
; CHECK-DISABLED-NEXT:    br label [[INNER_LOOP_END]]
; CHECK-DISABLED:       inner_loop_end:
; CHECK-DISABLED-NEXT:    br i1 false, label [[INNER_LOOP]], label [[MIDDLE_LOOP_END:%.*]]
; CHECK-DISABLED:       middle_loop_end:
; CHECK-DISABLED-NEXT:    br i1 false, label [[MIDDLE_LOOP]], label [[OUTER_LOOP_END:%.*]]
; CHECK-DISABLED:       outer_loop_end:
; CHECK-DISABLED-NEXT:    br label [[OUTER_LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@hoist_from_innermost_loop(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[SUB:%.*]] = sub nsw i32 0, [[NX:%.*]]
; CHECK-ENABLED-NEXT:    br label [[OUTER_LOOP:%.*]]
; CHECK-ENABLED:       outer_loop:
; CHECK-ENABLED-NEXT:    br label [[MIDDLE_LOOP:%.*]]
; CHECK-ENABLED:       middle_loop:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[INNER_LOOP_END_LICM:%.*]], label [[IF_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[INNER_LOOP_END_LICM]]
; CHECK-ENABLED:       inner_loop_end.licm:
; CHECK-ENABLED-NEXT:    br label [[INNER_LOOP:%.*]]
; CHECK-ENABLED:       inner_loop:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[INNER_LOOP_END:%.*]], label [[IF:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    store i32 [[SUB]], ptr [[PTR:%.*]], align 4
; CHECK-ENABLED-NEXT:    br label [[INNER_LOOP_END]]
; CHECK-ENABLED:       inner_loop_end:
; CHECK-ENABLED-NEXT:    br i1 false, label [[INNER_LOOP]], label [[MIDDLE_LOOP_END:%.*]]
; CHECK-ENABLED:       middle_loop_end:
; CHECK-ENABLED-NEXT:    br i1 false, label [[MIDDLE_LOOP]], label [[OUTER_LOOP_END:%.*]]
; CHECK-ENABLED:       outer_loop_end:
; CHECK-ENABLED-NEXT:    br label [[OUTER_LOOP]]
;
entry:
  br label %outer_loop

outer_loop:
  br label %middle_loop

middle_loop:
  br label %inner_loop

inner_loop:
  br i1 undef, label %inner_loop_end, label %if

if:
  %sub = sub nsw i32 0, %nx
  store i32 %sub, ptr %ptr, align 4
  br label %inner_loop_end

inner_loop_end:
  br i1 undef, label %inner_loop, label %middle_loop_end

middle_loop_end:
  br i1 undef, label %middle_loop, label %outer_loop_end

outer_loop_end:
  br label %outer_loop
}

; We have a diamond starting from %if, but %if.if is also reachable from %loop,
; so %gep should not be conditionally hoisted.
define void @diamond_with_extra_in_edge(ptr %ptr1, ptr %ptr2, i32 %arg) {
; CHECK-LABEL: define {{[^@]+}}@diamond_with_extra_in_edge(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ne i32 0, [[ARG:%.*]]
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[PTR1:%.*]], i32 4
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[PHI2:%.*]], [[THEN:%.*]] ]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ugt i32 16, [[PHI1]]
; CHECK-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[IF_IF:%.*]]
; CHECK:       if:
; CHECK-NEXT:    br i1 [[CMP2]], label [[IF_IF]], label [[IF_ELSE:%.*]]
; CHECK:       if.if:
; CHECK-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-NEXT:    br label [[THEN]]
; CHECK:       if.else:
; CHECK-NEXT:    br label [[THEN]]
; CHECK:       then:
; CHECK-NEXT:    [[PHI2]] = phi i32 [ [[VAL]], [[IF_IF]] ], [ [[PHI1]], [[IF_ELSE]] ]
; CHECK-NEXT:    store i32 [[PHI2]], ptr [[PTR2:%.*]], align 4
; CHECK-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop

loop:
  %phi1 = phi i32 [ 0, %entry ], [ %phi2, %then ]
  %cmp1 = icmp ugt i32 16, %phi1
  br i1 %cmp1, label %if, label %if.if

if:
  %cmp2 = icmp ne i32 0, %arg
  br i1 %cmp2, label %if.if, label %if.else

if.if:
  %gep = getelementptr i32, ptr %ptr1, i32 4
  %val = load i32, ptr %gep, align 4
  br label %then

if.else:
  br label %then

then:
  %phi2 = phi i32 [ %val, %if.if ], [ %phi1, %if.else ]
  store i32 %phi2, ptr %ptr2, align 4
  br label %loop
}

; %loop/%if/%then form a triangle, but %loop/%if/%then/%end also form a diamond.
; The triangle should be picked for conditional hoisting.
define void @both_triangle_and_diamond(ptr %ptr1, ptr %ptr2, i32 %arg) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@both_triangle_and_diamond(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 0, [[ARG:%.*]]
; CHECK-DISABLED-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[PTR1:%.*]], i32 4
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[PHI3:%.*]], [[END:%.*]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-DISABLED:       if:
; CHECK-DISABLED-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp ugt i32 16, [[PHI1]]
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[END]], label [[THEN]]
; CHECK-DISABLED:       then:
; CHECK-DISABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ 0, [[IF]] ], [ 1, [[LOOP]] ]
; CHECK-DISABLED-NEXT:    br label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI3]] = phi i32 [ [[PHI2]], [[THEN]] ], [ [[VAL]], [[IF]] ]
; CHECK-DISABLED-NEXT:    store i32 [[PHI3]], ptr [[PTR2:%.*]], align 4
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@both_triangle_and_diamond(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 0, [[ARG:%.*]]
; CHECK-ENABLED-NEXT:    [[GEP:%.*]] = getelementptr i32, ptr [[PTR1:%.*]], i32 4
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_LICM:%.*]], label [[THEN_LICM:%.*]]
; CHECK-ENABLED:       if.licm:
; CHECK-ENABLED-NEXT:    br label [[THEN_LICM]]
; CHECK-ENABLED:       then.licm:
; CHECK-ENABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ 0, [[IF_LICM]] ], [ 1, [[ENTRY:%.*]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[THEN_LICM]] ], [ [[PHI3:%.*]], [[END:%.*]] ]
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK-ENABLED:       if:
; CHECK-ENABLED-NEXT:    [[VAL:%.*]] = load i32, ptr [[GEP]], align 4
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp ugt i32 16, [[PHI1]]
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[END]], label [[THEN]]
; CHECK-ENABLED:       then:
; CHECK-ENABLED-NEXT:    br label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI3]] = phi i32 [ [[PHI2]], [[THEN]] ], [ [[VAL]], [[IF]] ]
; CHECK-ENABLED-NEXT:    store i32 [[PHI3]], ptr [[PTR2:%.*]], align 4
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop



loop:
  %phi1 = phi i32 [ 0, %entry ], [ %phi3, %end ]
  %cmp1 = icmp ne i32 0, %arg
  br i1 %cmp1, label %if, label %then

if:
  %gep = getelementptr i32, ptr %ptr1, i32 4
  %val = load i32, ptr %gep, align 4
  %cmp2 = icmp ugt i32 16, %phi1
  br i1 %cmp2, label %end, label %then

then:
  %phi2 = phi i32 [ 0, %if ], [ 1, %loop ]
  br label %end

end:
  %phi3 = phi i32 [ %phi2, %then ], [ %val, %if ]
  store i32 %phi3, ptr %ptr2, align 4
  br label %loop
}

; We shouldn't duplicate the branch at the end of %loop and should instead hoist
; %val to %entry.
define i32 @same_destination_branch(i32 %arg1, i32 %arg2) {
; CHECK-LABEL: define {{[^@]+}}@same_destination_branch(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[ARG2:%.*]], 0
; CHECK-NEXT:    [[VAL:%.*]] = add i32 [[ARG1:%.*]], 1
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD:%.*]], [[THEN:%.*]] ]
; CHECK-NEXT:    [[ADD]] = add i32 [[PHI]], 1
; CHECK-NEXT:    br i1 [[CMP1]], label [[IF:%.*]], label [[IF]]
; CHECK:       if:
; CHECK-NEXT:    br label [[THEN]]
; CHECK:       then:
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ne i32 [[VAL]], [[PHI]]
; CHECK-NEXT:    br i1 [[CMP2]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    [[VAL_LCSSA:%.*]] = phi i32 [ [[VAL]], [[THEN]] ]
; CHECK-NEXT:    ret i32 [[VAL_LCSSA]]
;
entry:
  br label %loop

loop:
  %phi = phi i32 [ 0, %entry ], [ %add, %then ]
  %add = add i32 %phi, 1
  %cmp1 = icmp ne i32 %arg2, 0
  br i1 %cmp1, label %if, label %if

if:
  %val = add i32 %arg1, 1
  br label %then

then:
  %cmp2 = icmp ne i32 %val, %phi
  br i1 %cmp2, label %loop, label %end

end:
  ret i32 %val
}

; Diamond-like control flow but the left/right blocks actually have the same
; destinations.
; TODO: We could potentially hoist all of phi2-4, but currently only hoist phi2.
define i32 @diamond_like_same_destinations(i32 %arg1, i32 %arg2) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@diamond_like_same_destinations(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[ARG1:%.*]], 0
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp ugt i32 [[ARG2:%.*]], 2
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp ugt i32 [[ARG2]], 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[ADD:%.*]], [[LOOPEND:%.*]] ]
; CHECK-DISABLED-NEXT:    [[ADD]] = add i32 [[PHI1]], 1
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[LEFT1:%.*]], label [[RIGHT1:%.*]]
; CHECK-DISABLED:       left1:
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[LEFT2:%.*]], label [[RIGHT2:%.*]]
; CHECK-DISABLED:       right1:
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[LEFT2]], label [[RIGHT2]]
; CHECK-DISABLED:       left2:
; CHECK-DISABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ 0, [[LEFT1]] ], [ 1, [[RIGHT1]] ]
; CHECK-DISABLED-NEXT:    br label [[LOOPEND]]
; CHECK-DISABLED:       right2:
; CHECK-DISABLED-NEXT:    [[PHI3:%.*]] = phi i32 [ 2, [[LEFT1]] ], [ 3, [[RIGHT1]] ]
; CHECK-DISABLED-NEXT:    br label [[LOOPEND]]
; CHECK-DISABLED:       loopend:
; CHECK-DISABLED-NEXT:    [[PHI4:%.*]] = phi i32 [ [[PHI2]], [[LEFT2]] ], [ [[PHI3]], [[RIGHT2]] ]
; CHECK-DISABLED-NEXT:    [[CMP4:%.*]] = icmp ne i32 [[PHI1]], 32
; CHECK-DISABLED-NEXT:    br i1 [[CMP4]], label [[LOOP]], label [[END:%.*]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    [[PHI4_LCSSA:%.*]] = phi i32 [ [[PHI4]], [[LOOPEND]] ]
; CHECK-DISABLED-NEXT:    ret i32 [[PHI4_LCSSA]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@diamond_like_same_destinations(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp ne i32 [[ARG1:%.*]], 0
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp ugt i32 [[ARG2:%.*]], 2
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp ugt i32 [[ARG2]], 1
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[LEFT1_LICM:%.*]], label [[RIGHT1_LICM:%.*]]
; CHECK-ENABLED:       left1.licm:
; CHECK-ENABLED-NEXT:    br label [[LEFT2_LICM:%.*]]
; CHECK-ENABLED:       right1.licm:
; CHECK-ENABLED-NEXT:    br label [[LEFT2_LICM]]
; CHECK-ENABLED:       left2.licm:
; CHECK-ENABLED-NEXT:    [[PHI2:%.*]] = phi i32 [ 0, [[LEFT1_LICM]] ], [ 1, [[RIGHT1_LICM]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    [[PHI1:%.*]] = phi i32 [ 0, [[LEFT2_LICM]] ], [ [[ADD:%.*]], [[LOOPEND:%.*]] ]
; CHECK-ENABLED-NEXT:    [[ADD]] = add i32 [[PHI1]], 1
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[LEFT1:%.*]], label [[RIGHT1:%.*]]
; CHECK-ENABLED:       left1:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[LEFT2:%.*]], label [[RIGHT2:%.*]]
; CHECK-ENABLED:       right1:
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[LEFT2]], label [[RIGHT2]]
; CHECK-ENABLED:       left2:
; CHECK-ENABLED-NEXT:    br label [[LOOPEND]]
; CHECK-ENABLED:       right2:
; CHECK-ENABLED-NEXT:    [[PHI3:%.*]] = phi i32 [ 2, [[LEFT1]] ], [ 3, [[RIGHT1]] ]
; CHECK-ENABLED-NEXT:    br label [[LOOPEND]]
; CHECK-ENABLED:       loopend:
; CHECK-ENABLED-NEXT:    [[PHI4:%.*]] = phi i32 [ [[PHI2]], [[LEFT2]] ], [ [[PHI3]], [[RIGHT2]] ]
; CHECK-ENABLED-NEXT:    [[CMP4:%.*]] = icmp ne i32 [[PHI1]], 32
; CHECK-ENABLED-NEXT:    br i1 [[CMP4]], label [[LOOP]], label [[END:%.*]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    [[PHI4_LCSSA:%.*]] = phi i32 [ [[PHI4]], [[LOOPEND]] ]
; CHECK-ENABLED-NEXT:    ret i32 [[PHI4_LCSSA]]
;
entry:
  br label %loop




loop:
  %phi1 = phi i32 [ 0, %entry ], [ %add, %loopend ]
  %add = add i32 %phi1, 1
  %cmp1 = icmp ne i32 %arg1, 0
  br i1 %cmp1, label %left1, label %right1

left1:
  %cmp2 = icmp ugt i32 %arg2, 1
  br i1 %cmp2, label %left2, label %right2

right1:
  %cmp3 = icmp ugt i32 %arg2, 2
  br i1 %cmp3, label %left2, label %right2

left2:
  %phi2 = phi i32 [ 0, %left1 ], [ 1, %right1 ]
  br label %loopend

right2:
  %phi3 = phi i32 [ 2, %left1 ], [ 3, %right1 ]
  br label %loopend

loopend:
  %phi4 = phi i32 [ %phi2, %left2 ], [ %phi3, %right2 ]
  %cmp4 = icmp ne i32 %phi1, 32
  br i1 %cmp4, label %loop, label %end

end:
  ret i32 %phi4
}

; A phi with multiple incoming values for the same block due to a branch with
; two destinations that are actually the same. We can't hoist this.
; TODO: This could be hoisted by erasing one of the incoming values.
define i32 @phi_multiple_values_same_block(i32 %arg) {
; CHECK-LABEL: define {{[^@]+}}@phi_multiple_values_same_block(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[ARG:%.*]], 4
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    br i1 [[CMP]], label [[IF:%.*]], label [[THEN:%.*]]
; CHECK:       if:
; CHECK-NEXT:    br i1 undef, label [[THEN]], label [[THEN]]
; CHECK:       then:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[ARG]], [[LOOP]] ], [ 1, [[IF]] ], [ 1, [[IF]] ]
; CHECK-NEXT:    br i1 true, label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    [[PHI_LCSSA:%.*]] = phi i32 [ [[PHI]], [[THEN]] ]
; CHECK-NEXT:    ret i32 [[PHI_LCSSA]]
;
entry:
  br label %loop

loop:
  %cmp = icmp sgt i32 %arg, 4
  br i1 %cmp, label %if, label %then

if:
  br i1 undef, label %then, label %then

then:
  %phi = phi i32 [ %arg, %loop ], [ 1, %if ], [ 1, %if ]
  br i1 undef, label %exit, label %loop

exit:
  ret i32 %phi
}

; %phi is conditionally used in %d, and the store that %d is used in cannot be
; hoisted. This means that we have to rehoist %d, but have to make sure to
; rehoist it after %phi.
define i64 @phi_conditional_use(i32 %f, ptr %g) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@phi_conditional_use(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[F:%.*]], 1
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[F]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK-DISABLED:       if.then:
; CHECK-DISABLED-NEXT:    br label [[IF_END]]
; CHECK-DISABLED:       if.end:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi i64 [ 0, [[LOOP]] ], [ 1, [[IF_THEN]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[LOOP_BACKEDGE:%.*]], label [[IF_THEN2:%.*]]
; CHECK-DISABLED:       if.then2:
; CHECK-DISABLED-NEXT:    [[D:%.*]] = getelementptr inbounds i32, ptr [[G:%.*]], i64 [[PHI]]
; CHECK-DISABLED-NEXT:    store i32 1, ptr [[D]], align 4
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-DISABLED:       loop.backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@phi_conditional_use(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[F:%.*]], 1
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[F]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_END_LICM:%.*]], label [[IF_THEN_LICM:%.*]]
; CHECK-ENABLED:       if.then.licm:
; CHECK-ENABLED-NEXT:    br label [[IF_END_LICM]]
; CHECK-ENABLED:       if.end.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ 1, [[IF_THEN_LICM]] ]
; CHECK-ENABLED-NEXT:    [[D:%.*]] = getelementptr inbounds i32, ptr [[G:%.*]], i64 [[PHI]]
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[LOOP_BACKEDGE_LICM:%.*]], label [[IF_THEN2_LICM:%.*]]
; CHECK-ENABLED:       if.then2.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE_LICM]]
; CHECK-ENABLED:       loop.backedge.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK-ENABLED:       if.then:
; CHECK-ENABLED-NEXT:    br label [[IF_END]]
; CHECK-ENABLED:       if.end:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[LOOP_BACKEDGE:%.*]], label [[IF_THEN2:%.*]]
; CHECK-ENABLED:       if.then2:
; CHECK-ENABLED-NEXT:    store i32 1, ptr [[D]], align 4
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-ENABLED:       loop.backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  %cmp1 = icmp eq i32 %f, 1
  %cmp2 = icmp eq i32 %f, 0
  br label %loop





loop:
  br i1 %cmp1, label %if.end, label %if.then

if.then:
  br label %if.end

if.end:
  %phi = phi i64 [ 0, %loop ], [ 1, %if.then ]
  br i1 %cmp2, label %loop.backedge, label %if.then2

if.then2:
  %d = getelementptr inbounds i32, ptr %g, i64 %phi
  store i32 1, ptr %d, align 4
  br label %loop.backedge

loop.backedge:
  br label %loop
}

; As above, but we have two such phis
define i64 @phi_conditional_use_twice(i32 %f, ptr %g) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@phi_conditional_use_twice(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[F:%.*]], 1
; CHECK-DISABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[F]], 0
; CHECK-DISABLED-NEXT:    [[CMP3:%.*]] = icmp sgt i32 [[F]], 0
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 [[CMP1]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK-DISABLED:       if.then:
; CHECK-DISABLED-NEXT:    br label [[IF_END]]
; CHECK-DISABLED:       if.end:
; CHECK-DISABLED-NEXT:    [[PHI1:%.*]] = phi i64 [ 0, [[LOOP]] ], [ 1, [[IF_THEN]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP2]], label [[IF_END2:%.*]], label [[IF_THEN2:%.*]]
; CHECK-DISABLED:       if.then2:
; CHECK-DISABLED-NEXT:    [[D:%.*]] = getelementptr inbounds i32, ptr [[G:%.*]], i64 [[PHI1]]
; CHECK-DISABLED-NEXT:    store i32 1, ptr [[D]], align 4
; CHECK-DISABLED-NEXT:    br label [[IF_END2]]
; CHECK-DISABLED:       if.end2:
; CHECK-DISABLED-NEXT:    [[PHI2:%.*]] = phi i64 [ 2, [[IF_END]] ], [ 3, [[IF_THEN2]] ]
; CHECK-DISABLED-NEXT:    br i1 [[CMP3]], label [[LOOP_BACKEDGE:%.*]], label [[IF_THEN3:%.*]]
; CHECK-DISABLED:       if.then3:
; CHECK-DISABLED-NEXT:    [[E:%.*]] = getelementptr inbounds i32, ptr [[G]], i64 [[PHI2]]
; CHECK-DISABLED-NEXT:    store i32 1, ptr [[E]], align 4
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-DISABLED:       loop.backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@phi_conditional_use_twice(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[F:%.*]], 1
; CHECK-ENABLED-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[F]], 0
; CHECK-ENABLED-NEXT:    [[CMP3:%.*]] = icmp sgt i32 [[F]], 0
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_END_LICM:%.*]], label [[IF_THEN_LICM:%.*]]
; CHECK-ENABLED:       if.then.licm:
; CHECK-ENABLED-NEXT:    br label [[IF_END_LICM]]
; CHECK-ENABLED:       if.end.licm:
; CHECK-ENABLED-NEXT:    [[PHI1:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ 1, [[IF_THEN_LICM]] ]
; CHECK-ENABLED-NEXT:    [[D:%.*]] = getelementptr inbounds i32, ptr [[G:%.*]], i64 [[PHI1]]
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_END2_LICM:%.*]], label [[IF_THEN2_LICM:%.*]]
; CHECK-ENABLED:       if.then2.licm:
; CHECK-ENABLED-NEXT:    br label [[IF_END2_LICM]]
; CHECK-ENABLED:       if.end2.licm:
; CHECK-ENABLED-NEXT:    [[PHI2:%.*]] = phi i64 [ 2, [[IF_END_LICM]] ], [ 3, [[IF_THEN2_LICM]] ]
; CHECK-ENABLED-NEXT:    [[E:%.*]] = getelementptr inbounds i32, ptr [[G]], i64 [[PHI2]]
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[LOOP_BACKEDGE_LICM:%.*]], label [[IF_THEN3_LICM:%.*]]
; CHECK-ENABLED:       if.then3.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE_LICM]]
; CHECK-ENABLED:       loop.backedge.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 [[CMP1]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; CHECK-ENABLED:       if.then:
; CHECK-ENABLED-NEXT:    br label [[IF_END]]
; CHECK-ENABLED:       if.end:
; CHECK-ENABLED-NEXT:    br i1 [[CMP2]], label [[IF_END2:%.*]], label [[IF_THEN2:%.*]]
; CHECK-ENABLED:       if.then2:
; CHECK-ENABLED-NEXT:    store i32 1, ptr [[D]], align 4
; CHECK-ENABLED-NEXT:    br label [[IF_END2]]
; CHECK-ENABLED:       if.end2:
; CHECK-ENABLED-NEXT:    br i1 [[CMP3]], label [[LOOP_BACKEDGE:%.*]], label [[IF_THEN3:%.*]]
; CHECK-ENABLED:       if.then3:
; CHECK-ENABLED-NEXT:    store i32 1, ptr [[E]], align 4
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-ENABLED:       loop.backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  %cmp1 = icmp eq i32 %f, 1
  %cmp2 = icmp eq i32 %f, 0
  %cmp3 = icmp sgt i32 %f, 0
  br label %loop







loop:
  br i1 %cmp1, label %if.end, label %if.then

if.then:
  br label %if.end

if.end:
  %phi1 = phi i64 [ 0, %loop ], [ 1, %if.then ]
  br i1 %cmp2, label %if.end2, label %if.then2

if.then2:
  %d = getelementptr inbounds i32, ptr %g, i64 %phi1
  store i32 1, ptr %d, align 4
  br label %if.end2

if.end2:
  %phi2 = phi i64 [ 2, %if.end ], [ 3, %if.then2 ]
  br i1 %cmp3, label %loop.backedge, label %if.then3

if.then3:
  %e = getelementptr inbounds i32, ptr %g, i64 %phi2
  store i32 1, ptr %e, align 4
  br label %loop.backedge

loop.backedge:
  br label %loop
}

; The order that we hoist instructions from the loop is different to the textual
; order in the function. Check that we can rehoist this correctly.
define void @rehoist_wrong_order_1(ptr %ptr) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@rehoist_wrong_order_1(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 2
; CHECK-DISABLED-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 3
; CHECK-DISABLED-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-DISABLED:       if1:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP1]], align 4
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-DISABLED:       else1:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP2]], align 4
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF2:%.*]], label [[LOOP_BACKEDGE]]
; CHECK-DISABLED:       if2:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF3:%.*]], label [[END:%.*]]
; CHECK-DISABLED:       if3:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP3]], align 4
; CHECK-DISABLED-NEXT:    br label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-DISABLED:       loop.backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@rehoist_wrong_order_1(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 2
; CHECK-ENABLED-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 3
; CHECK-ENABLED-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 1
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF1_LICM:%.*]], label [[ELSE1_LICM:%.*]]
; CHECK-ENABLED:       if1.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE_LICM:%.*]]
; CHECK-ENABLED:       else1.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE_LICM]]
; CHECK-ENABLED:       loop.backedge.licm:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF3_LICM:%.*]], label [[END_LICM:%.*]]
; CHECK-ENABLED:       if3.licm:
; CHECK-ENABLED-NEXT:    br label [[END_LICM]]
; CHECK-ENABLED:       end.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-ENABLED:       if1:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP1]], align 4
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-ENABLED:       else1:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP2]], align 4
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF2:%.*]], label [[LOOP_BACKEDGE]]
; CHECK-ENABLED:       if2:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF3:%.*]], label [[END:%.*]]
; CHECK-ENABLED:       if3:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP3]], align 4
; CHECK-ENABLED-NEXT:    br label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-ENABLED:       loop.backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop






loop:
  br i1 undef, label %if1, label %else1

if1:
  %gep1 = getelementptr inbounds i32, ptr %ptr, i64 1
  store i32 0, ptr %gep1, align 4
  br label %loop.backedge

else1:
  %gep2 = getelementptr inbounds i32, ptr %ptr, i64 2
  store i32 0, ptr %gep2, align 4
  br i1 undef, label %if2, label %loop.backedge

if2:
  br i1 undef, label %if3, label %end

if3:
  %gep3 = getelementptr inbounds i32, ptr %ptr, i64 3
  store i32 0, ptr %gep3, align 4
  br label %end

end:
  br label %loop.backedge

loop.backedge:
  br label %loop

}

define void @rehoist_wrong_order_2(ptr %ptr) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@rehoist_wrong_order_2(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 2
; CHECK-DISABLED-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, ptr [[GEP2]], i64 3
; CHECK-DISABLED-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-DISABLED:       if1:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP1]], align 4
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-DISABLED:       else1:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP2]], align 4
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF2:%.*]], label [[LOOP_BACKEDGE]]
; CHECK-DISABLED:       if2:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF3:%.*]], label [[END:%.*]]
; CHECK-DISABLED:       if3:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP3]], align 4
; CHECK-DISABLED-NEXT:    br label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-DISABLED:       loop.backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@rehoist_wrong_order_2(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 2
; CHECK-ENABLED-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, ptr [[GEP2]], i64 3
; CHECK-ENABLED-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 1
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF1_LICM:%.*]], label [[ELSE1_LICM:%.*]]
; CHECK-ENABLED:       if1.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE_LICM:%.*]]
; CHECK-ENABLED:       else1.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE_LICM]]
; CHECK-ENABLED:       loop.backedge.licm:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF3_LICM:%.*]], label [[END_LICM:%.*]]
; CHECK-ENABLED:       if3.licm:
; CHECK-ENABLED-NEXT:    br label [[END_LICM]]
; CHECK-ENABLED:       end.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-ENABLED:       if1:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP1]], align 4
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE:%.*]]
; CHECK-ENABLED:       else1:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP2]], align 4
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF2:%.*]], label [[LOOP_BACKEDGE]]
; CHECK-ENABLED:       if2:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF3:%.*]], label [[END:%.*]]
; CHECK-ENABLED:       if3:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP3]], align 4
; CHECK-ENABLED-NEXT:    br label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-ENABLED:       loop.backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop






loop:
  br i1 undef, label %if1, label %else1

if1:
  %gep1 = getelementptr inbounds i32, ptr %ptr, i64 1
  store i32 0, ptr %gep1, align 4
  br label %loop.backedge

else1:
  %gep2 = getelementptr inbounds i32, ptr %ptr, i64 2
  store i32 0, ptr %gep2, align 4
  br i1 undef, label %if2, label %loop.backedge

if2:
  br i1 undef, label %if3, label %end

if3:
  %gep3 = getelementptr inbounds i32, ptr %gep2, i64 3
  store i32 0, ptr %gep3, align 4
  br label %end

end:
  br label %loop.backedge

loop.backedge:
  br label %loop
}

define void @rehoist_wrong_order_3(ptr %ptr) {
; CHECK-DISABLED-LABEL: define {{[^@]+}}@rehoist_wrong_order_3(
; CHECK-DISABLED-NEXT:  entry:
; CHECK-DISABLED-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 2
; CHECK-DISABLED-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 1
; CHECK-DISABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-DISABLED:       loop:
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-DISABLED:       if1:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP1]], align 4
; CHECK-DISABLED-NEXT:    br label [[IF2:%.*]]
; CHECK-DISABLED:       else1:
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP2]], align 4
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF2]], label [[LOOP_BACKEDGE:%.*]]
; CHECK-DISABLED:       if2:
; CHECK-DISABLED-NEXT:    [[PHI:%.*]] = phi ptr [ [[GEP1]], [[IF1]] ], [ [[GEP2]], [[ELSE1]] ]
; CHECK-DISABLED-NEXT:    br i1 undef, label [[IF3:%.*]], label [[END:%.*]]
; CHECK-DISABLED:       if3:
; CHECK-DISABLED-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, ptr [[PHI]], i64 3
; CHECK-DISABLED-NEXT:    store i32 0, ptr [[GEP3]], align 4
; CHECK-DISABLED-NEXT:    br label [[END]]
; CHECK-DISABLED:       end:
; CHECK-DISABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-DISABLED:       loop.backedge:
; CHECK-DISABLED-NEXT:    br label [[LOOP]]
;
; CHECK-ENABLED-LABEL: define {{[^@]+}}@rehoist_wrong_order_3(
; CHECK-ENABLED-NEXT:  entry:
; CHECK-ENABLED-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, ptr [[PTR:%.*]], i64 2
; CHECK-ENABLED-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 1
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF1_LICM:%.*]], label [[ELSE1_LICM:%.*]]
; CHECK-ENABLED:       if1.licm:
; CHECK-ENABLED-NEXT:    br label [[IF2_LICM:%.*]]
; CHECK-ENABLED:       else1.licm:
; CHECK-ENABLED-NEXT:    br label [[IF2_LICM]]
; CHECK-ENABLED:       if2.licm:
; CHECK-ENABLED-NEXT:    [[PHI:%.*]] = phi ptr [ [[GEP1]], [[IF1_LICM]] ], [ [[GEP2]], [[ELSE1_LICM]] ]
; CHECK-ENABLED-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, ptr [[PHI]], i64 3
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF3_LICM:%.*]], label [[END_LICM:%.*]]
; CHECK-ENABLED:       if3.licm:
; CHECK-ENABLED-NEXT:    br label [[END_LICM]]
; CHECK-ENABLED:       end.licm:
; CHECK-ENABLED-NEXT:    br label [[LOOP:%.*]]
; CHECK-ENABLED:       loop:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF1:%.*]], label [[ELSE1:%.*]]
; CHECK-ENABLED:       if1:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP1]], align 4
; CHECK-ENABLED-NEXT:    br label [[IF2:%.*]]
; CHECK-ENABLED:       else1:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP2]], align 4
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF2]], label [[LOOP_BACKEDGE:%.*]]
; CHECK-ENABLED:       if2:
; CHECK-ENABLED-NEXT:    br i1 undef, label [[IF3:%.*]], label [[END:%.*]]
; CHECK-ENABLED:       if3:
; CHECK-ENABLED-NEXT:    store i32 0, ptr [[GEP3]], align 4
; CHECK-ENABLED-NEXT:    br label [[END]]
; CHECK-ENABLED:       end:
; CHECK-ENABLED-NEXT:    br label [[LOOP_BACKEDGE]]
; CHECK-ENABLED:       loop.backedge:
; CHECK-ENABLED-NEXT:    br label [[LOOP]]
;
entry:
  br label %loop






loop:
  br i1 undef, label %if1, label %else1

if1:
  %gep1 = getelementptr inbounds i32, ptr %ptr, i64 1
  store i32 0, ptr %gep1, align 4
  br label %if2

else1:
  %gep2 = getelementptr inbounds i32, ptr %ptr, i64 2
  store i32 0, ptr %gep2, align 4
  br i1 undef, label %if2, label %loop.backedge

if2:
  %phi = phi ptr [ %gep1, %if1 ], [ %gep2, %else1 ]
  br i1 undef, label %if3, label %end

if3:
  %gep3 = getelementptr inbounds i32, ptr %phi, i64 3
  store i32 0, ptr %gep3, align 4
  br label %end

end:
  br label %loop.backedge

loop.backedge:
  br label %loop
}
; end INTEL_CUSTOMIZATION
