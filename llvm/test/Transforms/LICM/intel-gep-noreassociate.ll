; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -S -passes=licm < %s | FileCheck %s

; The GEPs should not be hoisted by LICM when HIR is enabled (or really at
; all.) This causes performance regressions, because computing GEPs are
; faster than using up a register in many cases.

declare void @use(ptr)
declare i32 @get.i32()
declare ptr @get.ptr()

define void @only_one_inbounds(ptr %ptr, i1 %c, i32 %arg) #0 {
; CHECK-LABEL: define void @only_one_inbounds
; CHECK-SAME: (ptr [[PTR:%.*]], i1 [[C:%.*]], i32 [[ARG:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARG_EXT:%.*]] = zext i32 [[ARG]] to i64
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[VAL:%.*]] = call i32 @get.i32()
; CHECK-NEXT:    [[VAL_EXT:%.*]] = zext i32 [[VAL]] to i64
; CHECK-NEXT:    [[PTR2:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 [[VAL_EXT]]
; CHECK-NEXT:    [[PTR3:%.*]] = getelementptr i8, ptr [[PTR2]], i64 [[ARG_EXT]]
; CHECK-NEXT:    call void @use(ptr [[PTR3]])
; CHECK-NEXT:    br i1 [[C]], label [[LOOP]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %arg.ext = zext i32 %arg to i64
  br label %loop

loop:
  %val = call i32 @get.i32()
  %val.ext = zext i32 %val to i64
  %ptr2 = getelementptr inbounds i8, ptr %ptr, i64 %val.ext
  %ptr3 = getelementptr i8, ptr %ptr2, i64 %arg.ext
  call void @use(ptr %ptr3)
  br i1 %c, label %loop, label %exit

exit:
  ret void
}

attributes #0 = { nounwind uwtable "loopopt-pipeline"="light" }
