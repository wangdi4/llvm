; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -aa-pipeline="basic-aa,tbaa" -passes=licm -S -licm-speculate-max-insts=4 %s | FileCheck %s
; Check that related load speculation doesn't stop working after hoisting
; instructions more than licm-speculate-max-insts because of losing TBAA info
; This test is derived from intel-specul-load.ll

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.thing = type { i32, [512 x i8], i32, i32 }
%struct.thing_small = type { i32, i32, i32 }

define dso_local noundef i32 @speculate_many_instrs(ptr noundef %p, ptr noundef %q, i1 noundef zeroext %cond) local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local noundef i32 @speculate_many_instrs
; CHECK-SAME: (ptr noundef [[P:%.*]], ptr noundef [[Q:%.*]], i1 noundef zeroext [[COND:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_THING:%.*]], ptr [[P]], i64 0, i32 2, !intel-tbaa !3
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X]], align 4, !tbaa [[TBAA3:![0-9]+]]
; CHECK-NEXT:    [[Y:%.*]] = getelementptr inbounds [[STRUCT_THING_SMALL:%.*]], ptr [[Q]], i64 0, i32 2, !intel-tbaa !9
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[Y]], align 4, !tbaa [[TBAA9:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[Z:%.*]] = getelementptr inbounds [[STRUCT_THING]], ptr [[P]], i64 0, i32 3
; CHECK-NEXT:    [[LOAD_1:%.*]] = load i32, ptr [[Z]], align 4
; CHECK-NEXT:    [[LOAD_2:%.*]] = load i32, ptr [[Z]], align 4
; CHECK-NEXT:    [[LOAD_3:%.*]] = load i32, ptr [[Z]], align 4
; CHECK-NEXT:    [[LOAD_4:%.*]] = load i32, ptr [[Z]], align 4
; CHECK-NEXT:    [[LOAD_5:%.*]] = load i32, ptr [[Z]], align 4
; CHECK-NEXT:    [[LOAD_6:%.*]] = load i32, ptr [[Z]], align 4
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[SUM1_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[SUM1_1:%.*]], [[FOR_INC:%.*]] ]
; CHECK-NEXT:    [[SUM2_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[SUM2_1:%.*]], [[FOR_INC]] ]
; CHECK-NEXT:    [[SUM3_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[SUM3_1:%.*]], [[FOR_INC]] ]
; CHECK-NEXT:    [[SUM4_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[SUM4_1:%.*]], [[FOR_INC]] ]
; CHECK-NEXT:    [[SUM5_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[SUM5_1:%.*]], [[FOR_INC]] ]
; CHECK-NEXT:    [[SUM6_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[SUM6_1:%.*]], [[FOR_INC]] ]
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[INC:%.*]], [[FOR_INC]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_0]], 100
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[SUM1_0_LCSSA:%.*]] = phi i32 [ [[SUM1_0]], [[FOR_COND]] ]
; CHECK-NEXT:    [[SUM2_0_LCSSA:%.*]] = phi i32 [ [[SUM2_0]], [[FOR_COND]] ]
; CHECK-NEXT:    [[SUM4_0_LCSSA:%.*]] = phi i32 [ [[SUM4_0]], [[FOR_COND]] ]
; CHECK-NEXT:    [[SUM5_0_LCSSA:%.*]] = phi i32 [ [[SUM5_0]], [[FOR_COND]] ]
; CHECK-NEXT:    [[SUM6_0_LCSSA:%.*]] = phi i32 [ [[SUM6_0]], [[FOR_COND]] ]
; CHECK-NEXT:    [[ACC12:%.*]] = add i32 [[SUM1_0_LCSSA]], [[SUM2_0_LCSSA]]
; CHECK-NEXT:    [[ACC34:%.*]] = add i32 [[SUM4_0_LCSSA]], [[SUM4_0_LCSSA]]
; CHECK-NEXT:    [[ACC56:%.*]] = add i32 [[SUM5_0_LCSSA]], [[SUM6_0_LCSSA]]
; CHECK-NEXT:    [[ACC1234:%.*]] = add i32 [[ACC12]], [[ACC34]]
; CHECK-NEXT:    [[ACC123456:%.*]] = add i32 [[ACC1234]], [[ACC56]]
; CHECK-NEXT:    ret i32 [[ACC123456]]
; CHECK:       for.body:
; CHECK-NEXT:    [[ADD1:%.*]] = add nsw i32 [[SUM1_0]], [[TMP2]]
; CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[SUM2_0]], [[TMP2]]
; CHECK-NEXT:    [[ADD3:%.*]] = add nsw i32 [[SUM3_0]], [[TMP2]]
; CHECK-NEXT:    [[ADD4:%.*]] = add nsw i32 [[SUM4_0]], [[TMP2]]
; CHECK-NEXT:    [[ADD5:%.*]] = add nsw i32 [[SUM5_0]], [[TMP2]]
; CHECK-NEXT:    [[ADD6:%.*]] = add nsw i32 [[SUM6_0]], [[TMP2]]
; CHECK-NEXT:    br i1 [[COND]], label [[IF_THEN:%.*]], label [[FOR_INC]]
; CHECK:       if.then:
; CHECK-NEXT:    [[ADD1_1:%.*]] = add nsw i32 [[ADD1]], [[LOAD_1]]
; CHECK-NEXT:    [[ADD2_1:%.*]] = add nsw i32 [[ADD2]], [[LOAD_2]]
; CHECK-NEXT:    [[ADD3_1:%.*]] = add nsw i32 [[ADD3]], [[LOAD_3]]
; CHECK-NEXT:    [[ADD4_1:%.*]] = add nsw i32 [[ADD4]], [[LOAD_4]]
; CHECK-NEXT:    [[ADD5_1:%.*]] = add nsw i32 [[ADD5]], [[LOAD_5]]
; CHECK-NEXT:    [[ADD6_1:%.*]] = add nsw i32 [[ADD6]], [[LOAD_6]]
; CHECK-NEXT:    br label [[FOR_INC]]
; CHECK:       for.inc:
; CHECK-NEXT:    [[SUM1_1]] = phi i32 [ [[ADD1_1]], [[IF_THEN]] ], [ [[ADD1]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[SUM2_1]] = phi i32 [ [[ADD2_1]], [[IF_THEN]] ], [ [[ADD2]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[SUM3_1]] = phi i32 [ [[ADD3_1]], [[IF_THEN]] ], [ [[ADD3]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[SUM4_1]] = phi i32 [ [[ADD4_1]], [[IF_THEN]] ], [ [[ADD4]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[SUM5_1]] = phi i32 [ [[ADD5_1]], [[IF_THEN]] ], [ [[ADD5]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[SUM6_1]] = phi i32 [ [[ADD6_1]], [[IF_THEN]] ], [ [[ADD6]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_0]], 1
; CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP11:![0-9]+]]
;
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %sum1.0 = phi i32 [ 0, %entry ], [ %sum1.1, %for.inc ]
  %sum2.0 = phi i32 [ 0, %entry ], [ %sum2.1, %for.inc ]
  %sum3.0 = phi i32 [ 0, %entry ], [ %sum3.1, %for.inc ]
  %sum4.0 = phi i32 [ 0, %entry ], [ %sum4.1, %for.inc ]
  %sum5.0 = phi i32 [ 0, %entry ], [ %sum5.1, %for.inc ]
  %sum6.0 = phi i32 [ 0, %entry ], [ %sum6.1, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 100
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  %acc12 = add i32 %sum1.0, %sum2.0
  %acc34 = add i32 %sum4.0, %sum4.0
  %acc56 = add i32 %sum5.0, %sum6.0
  %acc1234 = add i32 %acc12, %acc34
  %acc123456 = add i32 %acc1234, %acc56
  ret i32 %acc123456

for.body:                                         ; preds = %for.cond
  %x = getelementptr inbounds %struct.thing, ptr %p, i64 0, i32 2, !intel-tbaa !3
  %0 = load i32, ptr %x, align 4, !tbaa !3
  %y = getelementptr inbounds %struct.thing_small, ptr %q, i64 0, i32 2, !intel-tbaa !13
  %1 = load i32, ptr %y, align 4, !tbaa !13
  %2 = add nsw i32 %0, %1
  %add1 = add nsw i32 %sum1.0, %2
  %add2 = add nsw i32 %sum2.0, %2
  %add3 = add nsw i32 %sum3.0, %2
  %add4 = add nsw i32 %sum4.0, %2
  %add5 = add nsw i32 %sum5.0, %2
  %add6 = add nsw i32 %sum6.0, %2
  br i1 %cond, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %z = getelementptr inbounds %struct.thing, ptr %p, i64 0, i32 3, !intel-tbaa !9
  %load.1 = load i32, ptr %z, align 4, !tbaa !9
  %load.2 = load i32, ptr %z, align 4, !tbaa !9
  %load.3 = load i32, ptr %z, align 4, !tbaa !9
  %load.4 = load i32, ptr %z, align 4, !tbaa !9
  %load.5 = load i32, ptr %z, align 4, !tbaa !9
  %load.6 = load i32, ptr %z, align 4, !tbaa !9
  %add1.1 = add nsw i32 %add1, %load.1
  %add2.1 = add nsw i32 %add2, %load.2
  %add3.1 = add nsw i32 %add3, %load.3
  %add4.1 = add nsw i32 %add4, %load.4
  %add5.1 = add nsw i32 %add5, %load.5
  %add6.1 = add nsw i32 %add6, %load.6
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %sum1.1 = phi i32 [ %add1.1, %if.then ], [ %add1, %for.body ]
  %sum2.1 = phi i32 [ %add2.1, %if.then ], [ %add2, %for.body ]
  %sum3.1 = phi i32 [ %add3.1, %if.then ], [ %add3, %for.body ]
  %sum4.1 = phi i32 [ %add4.1, %if.then ], [ %add4, %for.body ]
  %sum5.1 = phi i32 [ %add5.1, %if.then ], [ %add5, %for.body ]
  %sum6.1 = phi i32 [ %add6.1, %if.then ], [ %add6, %for.body ]
  %inc = add nuw nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !10
}

attributes #0 = { mustprogress nounwind uwtable "approx-func-fp-math"="true" "denormal-fp-math"="preserve-sign,preserve-sign" "loopopt-pipeline"="light" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "pre_loopopt" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "unsafe-fp-math"="true" }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!2 = !{!"Intel(R) oneAPI DPC++/C++ Compiler 2023.1.0 (2023.x.0.YYYYMMDD)"}
!3 = !{!4, !5, i64 516}
!4 = !{!"struct@_ZTS5thing", !5, i64 0, !8, i64 4, !5, i64 516, !5, i64 520}
!5 = !{!"int", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C++ TBAA"}
!8 = !{!"array@_ZTSA512_c", !6, i64 0}
!9 = !{!4, !5, i64 520}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
!12 = !{!"struct@_ZTS11thing_small", !5, i64 0, !5, i64 4, !5, i64 8}
!13 = !{!12, !5, i64 8}
