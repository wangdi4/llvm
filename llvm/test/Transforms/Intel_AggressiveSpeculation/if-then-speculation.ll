; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes aggressive-speculation -S < %s | FileCheck %s

; Check we can merge two calls in if/else blocks, speculating the rest of the
; instructions. The @wrapbar function is analyzed to understand that it is
; equivalent to calling @bar.
define i32 @mergeable(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @mergeable
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[ARG:%.*]] = add nsw i32 [[N]], 9
; CHECK-NEXT:    [[ARG1_HOIST:%.*]] = select i1 [[TOBOOL_NOT]], i32 [[ARG1]], i32 [[ARG]], !unpredictable !0
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @bar(i32 [[ARG1_HOIST]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 [[CALL1]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %arg = add nsw i32 %n, 9
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @wrapbar(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Simpler case: check we can speculate if/else blocks, but with no calls
; involved.
define i32 @mergeable_nocalls(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @mergeable_nocalls
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    [[SUM1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[PROD1:%.*]] = mul nsw i32 [[SUM1]], [[N]]
; CHECK-NEXT:    [[SUM:%.*]] = add nsw i32 [[N]], 9
; CHECK-NEXT:    [[PROD:%.*]] = mul nsw i32 [[SUM]], [[M]]
; CHECK-NEXT:    [[PROD1_PROD:%.*]] = select i1 [[TOBOOL_NOT]], i32 [[PROD1]], i32 [[PROD]], !unpredictable !0
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 [[PROD1_PROD]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %sum = add nsw i32 %n, 9
  %prod = mul nsw i32 %sum, %m
  br label %if.end

if.else:
  %sum1 = add nsw i32 %m, 4
  %prod1 = mul nsw i32 %sum1, %n
  br label %if.end

if.end:
  %r.0 = phi i32 [ %prod, %if.then ], [ %prod1, %if.else ]
  ret i32 %r.0
}

; Ensure we don't merge when calls do not have equivalent call sites.
define i32 @not_mergeable(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @not_mergeable
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]], !unpredictable !0
; CHECK:       if.then:
; CHECK-NEXT:    [[ARG:%.*]] = add nsw i32 [[N]], 9
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @bar(i32 [[ARG]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @notbar(i32 [[ARG1]])
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[R_0:%.*]] = phi i32 [ [[CALL]], [[IF_THEN]] ], [ [[CALL1]], [[IF_ELSE]] ]
; CHECK-NEXT:    ret i32 [[R_0]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %arg = add nsw i32 %n, 9
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @notbar(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Ensure we do nothing without "unpredictable" metadata.
define i32 @not_unpredictable(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @not_unpredictable
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[ARG:%.*]] = add nsw i32 [[N]], 9
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @bar(i32 [[ARG]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @bar(i32 [[ARG1]])
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[R_0:%.*]] = phi i32 [ [[CALL]], [[IF_THEN]] ], [ [[CALL1]], [[IF_ELSE]] ]
; CHECK-NEXT:    ret i32 [[R_0]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:
  %arg = add nsw i32 %n, 9
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @bar(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Check when we don't merge when we have 2 calls in one block and only 1 in the
; other.
define i32 @too_many_calls(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @too_many_calls
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]], !unpredictable !0
; CHECK:       if.then:
; CHECK-NEXT:    [[ARG:%.*]] = tail call i32 @notbar(i32 [[M]])
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @bar(i32 [[ARG]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @notbar(i32 [[ARG1]])
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[R_0:%.*]] = phi i32 [ [[CALL]], [[IF_THEN]] ], [ [[CALL1]], [[IF_ELSE]] ]
; CHECK-NEXT:    ret i32 [[R_0]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %arg = tail call i32 @notbar(i32 %m)
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @notbar(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Check that we only generate selects for operands which differ between call
; sites.
define i32 @merge_without_select(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @merge_without_select
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    [[SUM:%.*]] = add nsw i32 [[M]], [[N]]
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[ARG:%.*]] = add nsw i32 [[N]], 9
; CHECK-NEXT:    [[ARG1_HOIST:%.*]] = select i1 [[TOBOOL_NOT]], i32 [[ARG1]], i32 [[ARG]], !unpredictable !0
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @bar3(i32 [[ARG1_HOIST]], i32 1024, i32 [[SUM]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 [[CALL1]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  %sum = add nsw i32 %m, %n
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %arg = add nsw i32 %n, 9
  %call = tail call i32 @bar3(i32 %arg, i32 1024, i32 %sum)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @bar3(i32 %arg1, i32 1024, i32 %sum)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Check that we don't speculate loads which may not be dereferenceable.
define i32 @cant_speculate_load(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @cant_speculate_load
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]], !unpredictable !0
; CHECK:       if.then:
; CHECK-NEXT:    [[ARG:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @bar(i32 [[ARG]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @bar(i32 [[ARG1]])
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[R_0:%.*]] = phi i32 [ [[CALL]], [[IF_THEN]] ], [ [[CALL1]], [[IF_ELSE]] ]
; CHECK-NEXT:    ret i32 [[R_0]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %arg = load i32, ptr %a, align 4
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @bar(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Check that we do speculate a load given appropriate align/dereferenceable attributes.
define i32 @can_speculate_load(ptr nocapture readnone align 8 dereferenceable(8) %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @can_speculate_load
; CHECK-SAME: (ptr nocapture readnone align 8 dereferenceable(8) [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[ARG:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    [[ARG1_HOIST:%.*]] = select i1 [[TOBOOL_NOT]], i32 [[ARG1]], i32 [[ARG]], !unpredictable !0
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @bar(i32 [[ARG1_HOIST]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 [[CALL1]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %arg = load i32, ptr %a, align 4
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @bar(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Check that we can also speculate a load based not on its own attributes, but
; based on some dominating access.

%pair = type { i32, i32 }

define i32 @speculate_same_alloc(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @speculate_same_alloc
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[FIRSTP:%.*]] = getelementptr inbounds [[PAIR:%.*]], ptr [[A]], i64 0, i32 0, !intel-tbaa !1
; CHECK-NEXT:    [[FIRSTV:%.*]] = load i32, ptr [[FIRSTP]], align 4, !tbaa [[TBAA1:![0-9]+]]
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[FIRSTV]], 0
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[SECONDP:%.*]] = getelementptr inbounds [[PAIR]], ptr [[A]], i64 0, i32 1
; CHECK-NEXT:    [[ARG:%.*]] = load i32, ptr [[SECONDP]], align 4
; CHECK-NEXT:    [[ARG1_HOIST:%.*]] = select i1 [[TOBOOL_NOT]], i32 [[ARG1]], i32 [[ARG]], !unpredictable !0
; CHECK-NEXT:    [[CALL1:%.*]] = tail call i32 @bar(i32 [[ARG1_HOIST]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 [[CALL1]]
;
entry:
  %firstP = getelementptr inbounds %pair, ptr %a, i64 0, i32 0, !intel-tbaa !5
  %firstV = load i32, ptr %firstP, align 4, !tbaa !5
  %tobool.not = icmp eq i32 %firstV, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %secondP = getelementptr inbounds %pair, ptr %a, i64 0, i32 1, !intel-tbaa !6
  %arg = load i32, ptr %secondP, align 4, !tbaa !6
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call i32 @bar(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

; Check that we do not merge calls with different calling conventions.
define i32 @wrong_callingconv(ptr nocapture readnone %a, i32 %m, i32 %n) {
; CHECK-LABEL: define i32 @wrong_callingconv
; CHECK-SAME: (ptr nocapture readnone [[A:%.*]], i32 [[M:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[M]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label [[IF_ELSE:%.*]], label [[IF_THEN:%.*]], !unpredictable !0
; CHECK:       if.then:
; CHECK-NEXT:    [[ARG:%.*]] = add nsw i32 [[N]], 9
; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 @bar(i32 [[ARG]])
; CHECK-NEXT:    br label [[IF_END:%.*]]
; CHECK:       if.else:
; CHECK-NEXT:    [[ARG1:%.*]] = add nsw i32 [[M]], 4
; CHECK-NEXT:    [[CALL1:%.*]] = tail call fastcc i32 @wrapbar_fast(i32 [[ARG1]])
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[R_0:%.*]] = phi i32 [ [[CALL]], [[IF_THEN]] ], [ [[CALL1]], [[IF_ELSE]] ]
; CHECK-NEXT:    ret i32 [[R_0]]
;
entry:
  %tobool.not = icmp eq i32 %m, 0
  br i1 %tobool.not, label %if.else, label %if.then, !unpredictable !0

if.then:
  %arg = add nsw i32 %n, 9
  %call = tail call i32 @bar(i32 %arg)
  br label %if.end

if.else:
  %arg1 = add nsw i32 %m, 4
  %call1 = tail call fastcc i32 @wrapbar_fast(i32 %arg1)
  br label %if.end

if.end:
  %r.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %r.0
}

define i32 @wrapbar(i32 %a1) {
; CHECK-LABEL: define i32 @wrapbar
; CHECK-SAME: (i32 [[A1:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C1:%.*]] = call i32 @bar(i32 [[A1]])
; CHECK-NEXT:    ret i32 [[C1]]
;
entry:
  %c1 = call i32 @bar(i32 %a1)
  ret i32 %c1
}

define fastcc i32 @wrapbar_fast(i32 %a1) {
entry:
  %c1 = call i32 @bar(i32 %a1)
  ret i32 %c1
}

declare i32 @bar3(i32 %0, i32 %1, i32 %2)
declare i32 @bar(i32 %0)
declare i32 @notbar(i32 %0)

attributes #0 = { noinline }

!0 = !{}
!5 = !{!1, !2, i64 4}
!1 = !{!"struct@_ZTSN14CoeffVLCStreamIL18OptimizationTarget1EE27GolombCombinationCodeParamsE", !2, i64 0, !2, i64 4, !2, i64 8}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C++ TBAA"}
!6 = !{!1, !2, i64 8}
