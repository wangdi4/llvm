; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -instcombine -S | FileCheck %s

; Basic tets:
; R1 = (A - X) * Y
; R2 = (B - X) * Y
;  =>
; R0 = X * Y
; R1 = A * Y - R0
; R2 = B * Y - R0
; That may seems like doing additional multiplication, but
; R1 and R2 computations can be turned into FMA-like instruction.
; According to instruction tables, latencies and throughput of
; vsubss, vmulss and vfmsubXXXss are equal. So after generating
; FMSub instructions we win 1 operation.

define i1 @basic_test(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @basic_test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; No combine (values must come from loads)
define i1 @basic_test_no_loads(float %A, float %B, float %X, float %Y) {
; CHECK-LABEL: @basic_test_no_loads(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[SUB1:%.*]] = fsub fast float [[A:%.*]], [[X:%.*]]
; CHECK-NEXT:    [[MUL1:%.*]] = fmul fast float [[SUB1]], [[Y:%.*]]
; CHECK-NEXT:    [[SUB2:%.*]] = fsub fast float [[B:%.*]], [[X]]
; CHECK-NEXT:    [[MUL2:%.*]] = fmul fast float [[SUB2]], [[Y]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[MUL1]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[MUL2]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; No combine (fmul should have fast attribute)
define i1 @no_fast_attrib_on_mul(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @no_fast_attrib_on_mul(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[SUB1:%.*]] = fsub fast float [[A]], [[X]]
; CHECK-NEXT:    [[MUL1:%.*]] = fmul float [[SUB1]], [[Y]]
; CHECK-NEXT:    [[SUB2:%.*]] = fsub fast float [[B]], [[X]]
; CHECK-NEXT:    [[MUL2:%.*]] = fmul fast float [[SUB2]], [[Y]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[MUL1]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[MUL2]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; No combine (fsub should have fast attribute)
define i1 @no_fast_attrib_on_sub(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @no_fast_attrib_on_sub(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[SUB1:%.*]] = fsub fast float [[A]], [[X]]
; CHECK-NEXT:    [[MUL1:%.*]] = fmul fast float [[SUB1]], [[Y]]
; CHECK-NEXT:    [[SUB2:%.*]] = fsub float [[B]], [[X]]
; CHECK-NEXT:    [[MUL2:%.*]] = fmul fast float [[SUB2]], [[Y]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[MUL1]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[MUL2]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; No combine (Y should have only 2 users)
define i1 @Y_has_other_users(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @Y_has_other_users(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[SUB1:%.*]] = fsub fast float [[A]], [[X]]
; CHECK-NEXT:    [[MUL1:%.*]] = fmul fast float [[SUB1]], [[Y]]
; CHECK-NEXT:    [[SUB2:%.*]] = fsub fast float [[B]], [[X]]
; CHECK-NEXT:    [[MUL2:%.*]] = fmul fast float [[SUB2]], [[Y]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[MUL1]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[MUL2]], 2.000000e+00
; CHECK-NEXT:    [[CMP3:%.*]] = fcmp fast olt float [[Y]], 3.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    [[RET2:%.*]] = or i1 [[RET]], [[CMP3]]
; CHECK-NEXT:    ret i1 [[RET2]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %cmp3 = fcmp fast olt float %Y, 3.000000e+00
  %ret = or i1 %cmp1, %cmp2
  %ret2 = or i1 %ret, %cmp3
  ret i1 %ret2
}

; No combine (fsub should have single user)
define i1 @sub1_has_other_users(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @sub1_has_other_users(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[SUB1:%.*]] = fsub fast float [[A]], [[X]]
; CHECK-NEXT:    [[MUL1:%.*]] = fmul fast float [[SUB1]], [[Y]]
; CHECK-NEXT:    [[SUB2:%.*]] = fsub fast float [[B]], [[X]]
; CHECK-NEXT:    [[MUL2:%.*]] = fmul fast float [[SUB2]], [[Y]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[MUL1]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[MUL2]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    [[CMP3:%.*]] = fcmp fast olt float [[SUB1]], 3.000000e+00
; CHECK-NEXT:    [[RET2:%.*]] = or i1 [[RET]], [[CMP3]]
; CHECK-NEXT:    ret i1 [[RET2]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  %cmp3 = fcmp fast olt float %sub1, 3.000000e+00
  %ret2 = or i1 %ret, %cmp3
  ret i1 %ret2
}

; No combine (fsub should have single user)
define i1 @sub2_has_other_users(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @sub2_has_other_users(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[SUB1:%.*]] = fsub fast float [[A]], [[X]]
; CHECK-NEXT:    [[MUL1:%.*]] = fmul fast float [[SUB1]], [[Y]]
; CHECK-NEXT:    [[SUB2:%.*]] = fsub fast float [[B]], [[X]]
; CHECK-NEXT:    [[MUL2:%.*]] = fmul fast float [[SUB2]], [[Y]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[MUL1]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[MUL2]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    [[CMP3:%.*]] = fcmp fast olt float [[SUB2]], 3.000000e+00
; CHECK-NEXT:    [[RET2:%.*]] = or i1 [[RET]], [[CMP3]]
; CHECK-NEXT:    ret i1 [[RET2]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  %cmp3 = fcmp fast olt float %sub2, 3.000000e+00
  %ret2 = or i1 %ret, %cmp3
  ret i1 %ret2
}

; Combine:
; R1 = (X - A) * Y
; R2 = (X - B) * Y
define i1 @swap_operands1(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @swap_operands1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP0]], [[TMP3]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %X, %A
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %X, %B
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = (X - A) * Y
; R2 = (B - X) * Y
define i1 @swap_operands2(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @swap_operands2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %X, %A
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = (A - X) * Y
; R2 = (X - B) * Y
define i1 @swap_operands3(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @swap_operands3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP0]], [[TMP3]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %X, %B
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = (A - X) * Y
; R2 = Y * (B - X)
define i1 @swap_operands4(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @swap_operands4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %Y, %sub2
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = Y * (A - X)
; R2 = (B - X) * Y
define i1 @swap_operands5(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @swap_operands5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %Y, %sub1
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = Y * (A - X)
; R2 = Y * (B - X)
define i1 @swap_operands6(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @swap_operands6(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %Y, %sub1
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %Y, %sub2
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; This test checks that the algorithm will insert R0 such that
; both operands of it would be available.
define i1 @placing_R0_at_the_right_place(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @placing_R0_at_the_right_place(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %Y = load float, float* %ptrY
  %X = load float, float* %ptrX
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; This test checks that the algorithm will insert R0 such that
; both operands of it would be available.
; R1 and R2 are in different BBs.
define i1 @placing_R0_at_the_right_place2(i1 %cond, float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @placing_R0_at_the_right_place2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    br label [[BB3:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fsub fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    [[RET:%.*]] = phi i1 [ [[CMP1]], [[BB1]] ], [ [[CMP2]], [[BB2]] ]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  br i1 %cond, label %bb1 ,label %bb2

bb1:
  %A = load float, float* %ptrA
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  br label %bb3

bb2:
  %B = load float, float* %ptrB
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  br label %bb3

bb3:
  %ret = phi i1 [%cmp1, %bb1], [%cmp2, %bb2]
  ret i1 %ret
}

; We do the same transformation for additions
; R1 = (A + X) * Y
; R2 = (B + X) * Y
define i1 @basic_test_add(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @basic_test_add(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fadd fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fadd fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fadd fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fadd fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; We also handle mixed sub and add instructions.
; R1 = (A - X) * Y
; R2 = (B + X) * Y
define i1 @mixed_sub_and_add(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: @mixed_sub_and_add(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = load float, float* [[PTRA:%.*]], align 4
; CHECK-NEXT:    [[B:%.*]] = load float, float* [[PTRB:%.*]], align 4
; CHECK-NEXT:    [[X:%.*]] = load float, float* [[PTRX:%.*]], align 4
; CHECK-NEXT:    [[Y:%.*]] = load float, float* [[PTRY:%.*]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[X]], [[Y]]
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast float [[A]], [[Y]]
; CHECK-NEXT:    [[TMP2:%.*]] = fsub fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = fmul fast float [[B]], [[Y]]
; CHECK-NEXT:    [[TMP4:%.*]] = fadd fast float [[TMP3]], [[TMP0]]
; CHECK-NEXT:    [[CMP1:%.*]] = fcmp fast olt float [[TMP2]], 1.000000e+00
; CHECK-NEXT:    [[CMP2:%.*]] = fcmp fast olt float [[TMP4]], 2.000000e+00
; CHECK-NEXT:    [[RET:%.*]] = or i1 [[CMP1]], [[CMP2]]
; CHECK-NEXT:    ret i1 [[RET]]
;
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fadd fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}
