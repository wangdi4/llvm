; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Check calls to fmod functions are converted to frem instructions correctly.
;
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

define float @nofast_var(float %a, float %b) {
; CHECK-LABEL: @nofast_var(
; CHECK-NEXT:    [[CALL:%.*]] = tail call float @fmodf(float [[A:%.*]], float [[B:%.*]])
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float %b)
  ret float %call
}

define float @nofast_zero(float %a) {
; CHECK-LABEL: @nofast_zero(
; CHECK-NEXT:    [[CALL:%.*]] = tail call float @fmodf(float [[A:%.*]], float 0.000000e+00)
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 0.0)
  ret float %call
}

define float @nofast_nonint(float %a) {
; CHECK-LABEL: @nofast_nonint(
; CHECK-NEXT:    [[CALL:%.*]] = frem float [[A:%.*]], 4.500000e+00
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 4.5)
  ret float %call
}

define float @nofast_int(float %a) {
; CHECK-LABEL: @nofast_int(
; CHECK-NEXT:    [[CALL:%.*]] = frem float [[A:%.*]], 4.000000e+00
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 4.0)
  ret float %call
}

define float @fast_var(float %a, float %b) {
; CHECK-LABEL: @fast_var(
; CHECK-NEXT:    [[CALL:%.*]] = frem float [[A:%.*]], [[B:%.*]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float %b) #0
  ret float %call
}

define float @fast_zero(float %a) {
; CHECK-LABEL: @fast_zero(
; CHECK-NEXT:    [[CALL:%.*]] = frem float [[A:%.*]], 0.000000e+00
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 0.0) #0
  ret float %call
}

define float @fast_nonint(float %a) {
; CHECK-LABEL: @fast_nonint(
; CHECK-NEXT:    [[CALL:%.*]] = frem float [[A:%.*]], 4.500000e+00
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 4.5) #0
  ret float %call
}

define float @fast_int(float %a) {
; CHECK-LABEL: @fast_int(
; CHECK-NEXT:    [[CALL:%.*]] = frem float [[A:%.*]], 4.000000e+00
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 4.0) #0
  ret float %call
}

define float @strict_var(float %a, float %b) {
; CHECK-LABEL: @strict_var(
; CHECK-NEXT:    [[CALL:%.*]] = tail call float @fmodf(float [[A:%.*]], float [[B:%.*]]) #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float %b) #1
  ret float %call
}

define float @strict_zero(float %a) {
; CHECK-LABEL: @strict_zero(
; CHECK-NEXT:    [[CALL:%.*]] = tail call float @fmodf(float [[A:%.*]], float 0.000000e+00) #[[ATTR0]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 0.0) #1
  ret float %call
}

define float @strict_nonint(float %a) {
; CHECK-LABEL: @strict_nonint(
; CHECK-NEXT:    [[CALL:%.*]] = tail call float @fmodf(float [[A:%.*]], float 4.500000e+00) #[[ATTR0]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 4.5) #1
  ret float %call
}

define float @strict_int(float %a) {
; CHECK-LABEL: @strict_int(
; CHECK-NEXT:    [[CALL:%.*]] = tail call float @fmodf(float [[A:%.*]], float 4.000000e+00) #[[ATTR0]]
; CHECK-NEXT:    ret float [[CALL]]
;
  %call = tail call float @fmodf(float %a, float 4.0) #1
  ret float %call
}

declare float @fmodf(float, float)

attributes #0 = { readnone }
attributes #1 = { strictfp }
