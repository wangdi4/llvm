; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes="instcombine" -S < %s | FileCheck %s
; RUN: opt -passes="instcombine" -S -opaque-pointers < %s | FileCheck %s

; Define variables for typed or opaque pointers
; CHECK-LABEL: %pointers = type
; CHECK-SAME: { [[I8_P:.*]] }
%pointers = type { i8* }
@pointers = global %pointers zeroinitializer

define void @simplify_for_cpystr_test(i8* align 32 %dst, i8* align 32 %src, i8* %dst2, i8* %src2) {
; CHECK-LABEL: @simplify_for_cpystr_test(
; CHECK-NEXT:    call void @llvm.memmove.{{.*}}([[I8_P]] noundef nonnull align 32 dereferenceable(16) [[DST:%.*]], [[I8_P]] noundef nonnull align 32 dereferenceable(16) [[SRC:%.*]], i64 16, i1 false)
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, [[I8_P]] [[DST]], i64 16
; CHECK-NEXT:    call void @llvm.memmove.{{.*}}([[I8_P]] noundef nonnull align 32 dereferenceable(16) [[DST]], [[I8_P]] noundef nonnull align 32 dereferenceable(16) [[SRC]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memset.{{.*}}([[I8_P]] noundef nonnull align 16 dereferenceable(16) [[TMP1]], i8 32, i64 16, i1 false)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, [[I8_P]] [[DST]], i64 17
; CHECK-NEXT:    call void @llvm.memmove.{{.*}}([[I8_P]] noundef nonnull align 32 dereferenceable(17) [[DST]], [[I8_P]] noundef nonnull align 32 dereferenceable(17) [[SRC]], i64 17, i1 false)
; CHECK-NEXT:    call void @llvm.memset.{{.*}}([[I8_P]] noundef nonnull align 1 dereferenceable(15) [[TMP2]], i8 0, i64 15, i1 false)
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, [[I8_P]] [[DST]], i64 18
; CHECK-NEXT:    call void @llvm.memmove.{{.*}}([[I8_P]] noundef nonnull align 32 dereferenceable(18) [[DST]], [[I8_P]] noundef nonnull align 32 dereferenceable(18) [[SRC]], i64 18, i1 false)
; CHECK-NEXT:    call void @llvm.memset.{{.*}}([[I8_P]] noundef nonnull align 2 dereferenceable(14) [[TMP3]], i8 32, i64 14, i1 false)
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, [[I8_P]] [[DST2:%.*]], i64 18
; CHECK-NEXT:    call void @llvm.memmove.{{.*}}([[I8_P]] noundef nonnull align 1 dereferenceable(18) [[DST2]], [[I8_P]] noundef nonnull align 1 dereferenceable(18) [[SRC2:%.*]], i64 18, i1 false)
; CHECK-NEXT:    call void @llvm.memset.{{.*}}([[I8_P]] noundef nonnull align 1 dereferenceable(14) [[TMP4]], i8 32, i64 14, i1 false)
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, [[I8_P]] [[DST2]], i64 18
; CHECK-NEXT:    call void @llvm.memmove.{{.*}}([[I8_P]] [[DST2]], [[I8_P]] [[SRC2]], i64 18, i1 true)
; CHECK-NEXT:    call void @llvm.memset.{{.*}}([[I8_P]] [[TMP5]], i8 32, i64 14, i1 true)
; CHECK-NEXT:    ret void
;
  call void @llvm.for.cpystr.i64.i64.i64(i8* %dst, i64 16, i8* %src, i64 32, i64 0, i1 0)
  call void @llvm.for.cpystr.i64.i64.i64(i8* %dst, i64 32, i8* %src, i64 16, i64 0, i1 0)
  call void @llvm.for.cpystr.i64.i64.i64(i8* %dst, i64 32, i8* %src, i64 17, i64 1, i1 0)
  call void @llvm.for.cpystr.i64.i64.i64(i8* %dst, i64 32, i8* %src, i64 18, i64 0, i1 0)
  call void @llvm.for.cpystr.i64.i64.i64(i8* %dst2, i64 32, i8* %src2, i64 18, i64 0, i1 0)
  call void @llvm.for.cpystr.i64.i64.i64(i8* %dst2, i64 32, i8* %src2, i64 18, i64 0, i1 1)
  ret void
}

declare void @llvm.for.cpystr.i64.i64.i64(i8*, i64, i8*, i64, i64, i1)
