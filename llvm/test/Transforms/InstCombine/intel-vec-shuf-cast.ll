; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=instcombine -S %s | FileCheck %s

; Recognize vector-extend, cast, vector-extract as just "cast".

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"


@loc = dso_local global i8 0, align 1

define dso_local i8 @i1x8_to_i8(<8 x i1> %input) {
; CHECK-LABEL: @i1x8_to_i8(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i1> [[INPUT:%.*]] to i8
; CHECK-NEXT:    store <8 x i1> [[INPUT]], ptr @loc, align 1
; CHECK-NEXT:    ret i8 [[TMP0]]
;
entry:
  %0 = shufflevector <8 x i1> %input, <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = bitcast <16 x i1> %0 to <2 x i8>
  %output = extractelement <2 x i8> %1, i64 0  ; result is "i8"
  store i8 %output, ptr @loc, align 1
  ret i8 %output
}

define dso_local i64 @i8x8_to_i64(<8 x i8> %input) {
; CHECK-LABEL: @i8x8_to_i64(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x i8> [[INPUT:%.*]] to i64
; CHECK-NEXT:    ret i64 [[TMP0]]
;
entry:
  %0 = shufflevector <8 x i8> %input, <8 x i8> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = bitcast <16 x i8> %0 to <2 x i64>
  %output = extractelement <2 x i64> %1, i64 0  ; result is "i64"
  ret i64 %output
}

; The shuffle doesn't do an exact copy to the result (index 5 is repeated)
define dso_local i8 @bad_case1(<8 x i1> %input) {
; CHECK-LABEL: @bad_case1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x i1> [[INPUT:%.*]], <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 5, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i1> [[TMP0]] to <2 x i8>
; CHECK-NEXT:    [[OUTPUT:%.*]] = extractelement <2 x i8> [[TMP1]], i64 0
; CHECK-NEXT:    ret i8 [[OUTPUT]]
;
entry:
  %0 = shufflevector <8 x i1> %input, <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 5, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = bitcast <16 x i1> %0 to <2 x i8>
  %output = extractelement <2 x i8> %1, i64 0  ; result is "i8"
  ret i8 %output
}

; The shuffle doesn't do an exact copy to the result (missing index 7)
define dso_local i8 @bad_case2(<8 x i1> %input) {
; CHECK-LABEL: @bad_case2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x i1> [[INPUT:%.*]], <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i1> [[TMP0]] to <2 x i8>
; CHECK-NEXT:    [[OUTPUT:%.*]] = extractelement <2 x i8> [[TMP1]], i64 0
; CHECK-NEXT:    ret i8 [[OUTPUT]]
;
entry:
  %0 = shufflevector <8 x i1> %input, <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = bitcast <16 x i1> %0 to <2 x i8>
  %output = extractelement <2 x i8> %1, i64 0  ; result is "i8"
  ret i8 %output
}

; The output size (i16) doesn't match the input (8xi1)
define dso_local i16 @bad_case3(<8 x i1> %input) {
; CHECK-LABEL: @bad_case3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x i1> [[INPUT:%.*]], <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i1> [[TMP0]] to <1 x i16>
; CHECK-NEXT:    [[OUTPUT:%.*]] = extractelement <1 x i16> [[TMP1]], i64 0
; CHECK-NEXT:    ret i16 [[OUTPUT]]
;
entry:
  %0 = shufflevector <8 x i1> %input, <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = bitcast <16 x i1> %0 to <1 x i16>
  %output = extractelement <1 x i16> %1, i64 0  ; result is "i16"
  ret i16 %output
}

; The wrong element is extracted.
define dso_local i8 @bad_case4(<8 x i1> %input) {
; CHECK-LABEL: @bad_case4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x i1> [[INPUT:%.*]], <8 x i1> poison, <16 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0>
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <16 x i1> [[TMP0]] to <2 x i8>
; CHECK-NEXT:    [[OUTPUT:%.*]] = extractelement <2 x i8> [[TMP1]], i64 1
; CHECK-NEXT:    ret i8 [[OUTPUT]]
;
entry:
  %0 = shufflevector <8 x i1> %input, <8 x i1> poison, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0>
  %1 = bitcast <16 x i1> %0 to <2 x i8>
  %output = extractelement <2 x i8> %1, i64 1  ; result is "i8"
  ret i8 %output
}

; Scalable vector.
define dso_local i8 @bad_case5(<vscale x 8 x i1> %input) {
; CHECK-LABEL: @bad_case5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <vscale x 8 x i1> [[INPUT:%.*]], <vscale x 8 x i1> poison, <vscale x 16 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <vscale x 16 x i1> [[TMP0]] to <vscale x 2 x i8>
; CHECK-NEXT:    [[OUTPUT:%.*]] = extractelement <vscale x 2 x i8> [[TMP1]], i64 1
; CHECK-NEXT:    ret i8 [[OUTPUT]]
;
entry:
  ; mask must be 0/undef
  %0 = shufflevector <vscale x 8 x i1> %input, <vscale x 8 x i1> poison, <vscale x 16 x i32> zeroinitializer
  %1 = bitcast <vscale x 16 x i1> %0 to <vscale x 2 x i8>
  %output = extractelement <vscale x 2 x i8> %1, i64 1  ; result is "i8"
  ret i8 %output
}


!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
