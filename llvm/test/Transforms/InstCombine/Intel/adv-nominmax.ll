; INTEL_FEATURE_SW_ADVANCED
; REQUIRES: intel_feature_sw_advanced
; RUN: opt < %s -enable-intel-advanced-opts=true -passes=instcombine -S | FileCheck %s

; This comment must be inside the adv guards.
; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2

; Checks that min/max intrinsic recognition is disabled when:
; 1) AVX2 advanced opts are enabled, and AVX512 is disabled
; 2) AVX512 is enabled, and loopopt has not run yet.

target triple = "i686-pc-linux-gnu"

; AVX512 before loopopt
define void @avx512prehir(ptr %x, ptr %y) #0 {
; CHECK-LABEL: define void @avx512prehir
; CHECK-SAME: (ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP_1_I:%.*]] = load i32, ptr [[Y]], align 4
; CHECK-NEXT:    [[TMP_3_I:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[TMP_4_I:%.*]] = icmp slt i32 [[TMP_1_I]], [[TMP_3_I]]
; CHECK-NEXT:    [[TMP_4:%.*]] = select i1 [[TMP_4_I]], i32 [[TMP_1_I]], i32 [[TMP_3_I]]
; CHECK-NEXT:    store i32 [[TMP_4]], ptr [[X]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %tmp.1.i = load i32, ptr %y         ; <i32> [#uses=1]
  %tmp.3.i = load i32, ptr %x         ; <i32> [#uses=1]
  %tmp.4.i = icmp slt i32 %tmp.1.i, %tmp.3.i              ; <i1> [#uses=1]
  %retval.i = select i1 %tmp.4.i, ptr %y, ptr %x                ; <ptr> [#uses=1]
  %tmp.4 = load i32, ptr %retval.i            ; <i32> [#uses=1]
  store i32 %tmp.4, ptr %x
  ret void
}

; AVX2 (only) enabled, before loopopt
define void @avx2prehir(ptr %x, ptr %y) #1 {
; CHECK-LABEL: define void @avx2prehir
; CHECK-SAME: (ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP_2:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[TMP_3_I:%.*]] = load i32, ptr [[Y]], align 4
; CHECK-NEXT:    [[TMP_4_I:%.*]] = icmp slt i32 [[TMP_2]], [[TMP_3_I]]
; CHECK-NEXT:    [[TMP_6:%.*]] = select i1 [[TMP_4_I]], i32 [[TMP_3_I]], i32 [[TMP_2]]
; CHECK-NEXT:    store i32 [[TMP_6]], ptr [[Y]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %tmp.0 = alloca i32             ; <ptr> [#uses=2]
  %tmp.2 = load i32, ptr %x           ; <i32> [#uses=2]
  store i32 %tmp.2, ptr %tmp.0
  %tmp.3.i = load i32, ptr %y         ; <i32> [#uses=1]
  %tmp.4.i = icmp slt i32 %tmp.2, %tmp.3.i                ; <i1> [#uses=1]
  %retval.i = select i1 %tmp.4.i, ptr %y, ptr %tmp.0            ; <ptr> [#uses=1]
  %tmp.6 = load i32, ptr %retval.i            ; <i32> [#uses=1]
  store i32 %tmp.6, ptr %y
  ret void
}

; AVX2 (only) enabled, after loopopt
define void @avx2posthir(ptr %x, ptr %y) #2 {
; CHECK-LABEL: define void @avx2posthir
; CHECK-SAME: (ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP_2:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[TMP_3_I:%.*]] = load i32, ptr [[Y]], align 4
; CHECK-NEXT:    [[TMP_4_I:%.*]] = icmp slt i32 [[TMP_2]], [[TMP_3_I]]
; CHECK-NEXT:    [[TMP_6:%.*]] = select i1 [[TMP_4_I]], i32 [[TMP_3_I]], i32 [[TMP_2]]
; CHECK-NEXT:    store i32 [[TMP_6]], ptr [[Y]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %tmp.0 = alloca i32             ; <ptr> [#uses=2]
  %tmp.2 = load i32, ptr %x           ; <i32> [#uses=2]
  store i32 %tmp.2, ptr %tmp.0
  %tmp.3.i = load i32, ptr %y         ; <i32> [#uses=1]
  %tmp.4.i = icmp slt i32 %tmp.2, %tmp.3.i                ; <i1> [#uses=1]
  %retval.i = select i1 %tmp.4.i, ptr %y, ptr %tmp.0            ; <ptr> [#uses=1]
  %tmp.6 = load i32, ptr %retval.i            ; <i32> [#uses=1]
  store i32 %tmp.6, ptr %y
  ret void
}

; AVX512, after loopopt
define void @avx512posthir(ptr %x, ptr %y) #3 {
; CHECK-LABEL: define void @avx512posthir
; CHECK-SAME: (ptr [[X:%.*]], ptr [[Y:%.*]]) #[[ATTR3:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP_1_I:%.*]] = load i32, ptr [[Y]], align 4
; CHECK-NEXT:    [[TMP_3_I:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[TMP_4:%.*]] = call i32 @llvm.smin.i32(i32 [[TMP_1_I]], i32 [[TMP_3_I]])
; CHECK-NEXT:    store i32 [[TMP_4]], ptr [[X]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %tmp.1.i = load i32, ptr %y         ; <i32> [#uses=1]
  %tmp.3.i = load i32, ptr %x         ; <i32> [#uses=1]
  %tmp.4.i = icmp slt i32 %tmp.1.i, %tmp.3.i              ; <i1> [#uses=1]
  %retval.i = select i1 %tmp.4.i, ptr %y, ptr %x                ; <ptr> [#uses=1]
  %tmp.4 = load i32, ptr %retval.i            ; <i32> [#uses=1]
  store i32 %tmp.4, ptr %x
  ret void
}

attributes #0 = { "pre_loopopt" "target-cpu"="skylake-avx512" "target-features"="+avx512f,+avx512vl,+avx512dq"}
attributes #1 = { "pre_loopopt" "target-cpu"="haswell" "target-features"="+adx,+aes,+avx,+avx2"}
attributes #2 = { "target-cpu"="haswell" "target-features"="+adx,+aes,+avx,+avx2"}
attributes #3 = { "target-cpu"="skylake-avx512" "target-features"="+avx512f,+avx512vl,+avx512dq"}
; end INTEL_FEATURE_SW_ADVANCED
