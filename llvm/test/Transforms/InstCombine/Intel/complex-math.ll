; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --check-globals
; RUN: opt -passes="instcombine<max-iterations=2>" < %s -S -inst-combine-complex | FileCheck %s

; Check that we match the simple expansions of complex multiplication and
; division, whether the target complex value is made by returning a struct,
; vector, or by storing into memory.

%complex.double = type {double, double}

define %complex.double @struct_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @struct_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    [[X:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[Y:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[X]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[Y]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %x = fsub double %ac, %bd
  %y = fadd double %ad, %bc
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define <2 x double> @vector_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @vector_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1]]
; CHECK-NEXT:    ret <2 x double> [[TMP5]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %x = fsub double %ac, %bd
  %y = fadd double %ad, %bc
  %res = insertelement <2 x double> zeroinitializer, double %x, i32 0
  %res.1 = insertelement <2 x double> %res, double %y, i32 1
  ret <2 x double> %res.1
}

define void @memory_mul(double %a, double %b, double %c, double %d, ptr %dest) {
; CHECK-LABEL: @memory_mul(
; CHECK-NEXT:    [[AC:%.*]] = fmul double [[A:%.*]], [[C:%.*]]
; CHECK-NEXT:    [[BD:%.*]] = fmul double [[B:%.*]], [[D:%.*]]
; CHECK-NEXT:    [[AD:%.*]] = fmul double [[A]], [[D]]
; CHECK-NEXT:    [[BC:%.*]] = fmul double [[B]], [[C]]
; CHECK-NEXT:    [[X:%.*]] = fsub double [[AC]], [[BD]]
; CHECK-NEXT:    [[Y:%.*]] = fadd double [[AD]], [[BC]]
; CHECK-NEXT:    [[DEST_IMAG:%.*]] = getelementptr [[COMPLEX_DOUBLE:%.*]], ptr [[DEST:%.*]], i64 0, i32 1
; CHECK-NEXT:    store double [[X]], ptr [[DEST]], align 8
; CHECK-NEXT:    store double [[Y]], ptr [[DEST_IMAG]], align 8
; CHECK-NEXT:    ret void
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %x = fsub double %ac, %bd
  %y = fadd double %ad, %bc
  %dest.imag = getelementptr %complex.double, ptr %dest, i64 0, i32 1
  store double %x, ptr %dest
  store double %y, ptr %dest.imag
  ret void
}

define %complex.double @fast_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fast_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call fast <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1]]
; CHECK-NEXT:    [[X:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[Y:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[X]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[Y]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul fast double %a, %c
  %bd = fmul fast double %b, %d
  %ad = fmul fast double %a, %d
  %bc = fmul fast double %b, %c
  %x = fsub fast double %ac, %bd
  %y = fadd fast double %ad, %bc
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define %complex.double @fastish_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fastish_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call ninf <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1]]
; CHECK-NEXT:    [[X:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[Y:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[X]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[Y]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul fast double %a, %c
  %bd = fmul nnan ninf nsz double %b, %d
  %ad = fmul ninf arcp contract double %a, %d
  %bc = fmul reassoc nsz ninf double %b, %c
  %x = fsub ninf arcp afn double %ac, %bd
  %y = fadd afn nnan ninf double %ad, %bc
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define %complex.double @struct_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @struct_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    [[X:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[Y:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[X]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[Y]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %cc = fmul double %c, %c
  %dd = fmul double %d, %d
  %scale = fadd double %cc, %dd
  %x_noscale = fadd double %ac, %bd
  %y_noscale = fsub double %bc, %ad
  %x = fdiv double %x_noscale, %scale
  %y = fdiv double %y_noscale, %scale
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define <2 x double> @vector_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @vector_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2]]
; CHECK-NEXT:    ret <2 x double> [[TMP5]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %cc = fmul double %c, %c
  %dd = fmul double %d, %d
  %scale = fadd double %cc, %dd
  %x_noscale = fadd double %ac, %bd
  %y_noscale = fsub double %bc, %ad
  %x = fdiv double %x_noscale, %scale
  %y = fdiv double %y_noscale, %scale
  %res = insertelement <2 x double> zeroinitializer, double %x, i32 0
  %res.1 = insertelement <2 x double> %res, double %y, i32 1
  ret <2 x double> %res.1
}

define void @memory_div(double %a, double %b, double %c, double %d, ptr %dest) {
; CHECK-LABEL: @memory_div(
; CHECK-NEXT:    [[AC:%.*]] = fmul double [[A:%.*]], [[C:%.*]]
; CHECK-NEXT:    [[BD:%.*]] = fmul double [[B:%.*]], [[D:%.*]]
; CHECK-NEXT:    [[AD:%.*]] = fmul double [[A]], [[D]]
; CHECK-NEXT:    [[BC:%.*]] = fmul double [[B]], [[C]]
; CHECK-NEXT:    [[CC:%.*]] = fmul double [[C]], [[C]]
; CHECK-NEXT:    [[DD:%.*]] = fmul double [[D]], [[D]]
; CHECK-NEXT:    [[SCALE:%.*]] = fadd double [[CC]], [[DD]]
; CHECK-NEXT:    [[X_NOSCALE:%.*]] = fadd double [[AC]], [[BD]]
; CHECK-NEXT:    [[Y_NOSCALE:%.*]] = fsub double [[BC]], [[AD]]
; CHECK-NEXT:    [[X:%.*]] = fdiv double [[X_NOSCALE]], [[SCALE]]
; CHECK-NEXT:    [[Y:%.*]] = fdiv double [[Y_NOSCALE]], [[SCALE]]
; CHECK-NEXT:    [[DEST_IMAG:%.*]] = getelementptr [[COMPLEX_DOUBLE:%.*]], ptr [[DEST:%.*]], i64 0, i32 1
; CHECK-NEXT:    store double [[X]], ptr [[DEST]], align 8
; CHECK-NEXT:    store double [[Y]], ptr [[DEST_IMAG]], align 8
; CHECK-NEXT:    ret void
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %cc = fmul double %c, %c
  %dd = fmul double %d, %d
  %scale = fadd double %cc, %dd
  %x_noscale = fadd double %ac, %bd
  %y_noscale = fsub double %bc, %ad
  %x = fdiv double %x_noscale, %scale
  %y = fdiv double %y_noscale, %scale
  %dest.imag = getelementptr %complex.double, ptr %dest, i64 0, i32 1
  store double %x, ptr %dest
  store double %y, ptr %dest.imag
  ret void
}

define %complex.double @fast_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fast_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call fast <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2]]
; CHECK-NEXT:    [[X:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[Y:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[X]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[Y]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul fast double %a, %c
  %bd = fmul fast double %b, %d
  %ad = fmul fast double %a, %d
  %bc = fmul fast double %b, %c
  %cc = fmul fast double %c, %c
  %dd = fmul fast double %d, %d
  %scale = fadd fast double %cc, %dd
  %x_noscale = fadd fast double %ac, %bd
  %y_noscale = fsub fast double %bc, %ad
  %x = fdiv fast double %x_noscale, %scale
  %y = fdiv fast double %y_noscale, %scale
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define %complex.double @fastish_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fastish_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call arcp <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2]]
; CHECK-NEXT:    [[X:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[Y:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[X]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[Y]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul arcp contract double %a, %c
  %bd = fmul arcp afn ninf reassoc double %b, %d
  %ad = fmul arcp afn ninf double %a, %d
  %bc = fmul arcp nsz reassoc double %b, %c
  %cc = fmul arcp nsz afn double %c, %c
  %dd = fmul arcp nsz double %d, %d
  %scale = fadd arcp nsz contract nnan reassoc double %cc, %dd
  %x_noscale = fadd arcp nsz contract ninf nnan double %ac, %bd
  %y_noscale = fsub arcp nsz contract reassoc double %bc, %ad
  %x = fdiv arcp ninf nnan reassoc double %x_noscale, %scale
  %y = fdiv arcp nnan double %y_noscale, %scale
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

;.
; CHECK: attributes #[[ATTR0:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(none) }
; CHECK: attributes #[[ATTR1]] = { "complex-limited-range" }
; CHECK: attributes #[[ATTR2]] = { "complex-limited-range" "complex-no-scale" }
;.
