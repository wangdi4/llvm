; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -opaque-pointers=0 -passes='default<O2>' -S < %s | FileCheck %s --match-full-lines
; RUN: opt -opaque-pointers=0 -passes='default<O3>' -S < %s | FileCheck %s --match-full-lines

; This test verifies that there are no issues for the cases where two different
; types with similar layout are created inplace in the same place. Particularly,
; any GVN/CSE-like optimization on GEPs must drop !intel-tbaa annotations. Note,
; that "--match-full-lines" *must* be in the RUN lines so that any unexpected
; !intel-tbaa could be caught by the FlyCheck.

%struct.Outer1 = type { i32, %struct.Inner }
%struct.Outer2 = type { float, %struct.Inner }
%struct.Inner = type { [10 x i32] }

declare i32 @foo(i32 *) nounwind readonly
declare void @createOuter1(%struct.Outer1 *)
declare void @createOuter2(%struct.Outer2 *)

define i32 @bar(i8* %p) {
; CHECK-LABEL: define i32 @bar(i8* %p) local_unnamed_addr {
; CHECK-NEXT:    [[OUTER1_PTR:%.*]] = bitcast i8* [[P:%.*]] to %struct.Outer1*
; CHECK-NEXT:    tail call void @createOuter1(%struct.Outer1* [[OUTER1_PTR]])
; CHECK-NEXT:    [[OUTER1_INNER_ELEM:%.*]] = getelementptr inbounds i8, i8* [[P]], i64 16
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8* [[OUTER1_INNER_ELEM]] to i32*
; CHECK-NEXT:    [[A:%.*]] = tail call i32 @foo(i32* nonnull [[TMP1]])
; CHECK-NEXT:    [[OUTER2_PTR:%.*]] = bitcast i8* [[P]] to %struct.Outer2*
; CHECK-NEXT:    tail call void @createOuter2(%struct.Outer2* [[OUTER2_PTR]])
; CHECK-NEXT:    [[B:%.*]] = tail call i32 @foo(i32* nonnull [[TMP1]])
; CHECK-NEXT:    [[RET:%.*]] = add i32 [[B]], [[A]]
; CHECK-NEXT:    ret i32 [[RET]]
;
  %Outer1.ptr = bitcast i8* %p to %struct.Outer1*
  tail call void @createOuter1(%struct.Outer1* %Outer1.ptr)
  %Outer1.Inner.elem = getelementptr inbounds %struct.Outer1, %struct.Outer1* %Outer1.ptr, i32 0, i32 1, i32 0, i32 3, !intel-tbaa !8
  %a = tail call i32 @foo(i32* %Outer1.Inner.elem)

  %Outer2.ptr = bitcast i8* %p to %struct.Outer2*
  tail call void @createOuter2(%struct.Outer2* %Outer2.ptr)
  %Outer2.Inner.elem = getelementptr inbounds %struct.Outer2, %struct.Outer2* %Outer2.ptr, i32 0, i32 1, i32 0, i32 3, !intel-tbaa !9
  %b = tail call i32 @foo(i32* %Outer2.Inner.elem)
  %ret = add i32 %a, %b
  ret i32 %ret
}

!0 = !{!"Simple C++ TBAA"}
!1 = !{!"omnipotent char", !0, i64 0}
!2 = !{!"int", !1, i64 0}
!3 = !{!"float", !1, i64 0}
!4 = !{!"array@typeinfo name for int [10]", !2, i64 0}
!5 = !{!"struct@typeinfo name for Inner", !4, i64 0}
!6 = !{!"struct@typeinfo name for Outer1", !2, i64 0, !5, i64 4}
!7 = !{!"struct@typeinfo name for Outer2", !3, i64 0, !5, i64 4}

!8 = !{!6, !2, i64 4} ; Outer1::Inner::array::elem
!9 = !{!7, !2, i64 4} ; Outer2::Inner::array::elem
