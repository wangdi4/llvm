; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; This checks that loop-load-elim is preserving loop structure under NPM
; RUN: opt %s -passes='loop-load-elim,instcombine' -S | FileCheck %s
; RUN: opt %s -bugpoint-enable-legacy-pm -instcombine -S | FileCheck %s
; RUN: opt %s -passes='lto<O3>' -S | FileCheck --check-prefix=LTOO3 %s

; Make sure we don't sink this invariant fdiv into the loop.
define void @fmul_loop_invariant_fdiv(ptr %a, float %x) {
; CHECK-LABEL: @fmul_loop_invariant_fdiv(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = fdiv fast float 1.000000e+00, [[X:%.*]]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_08:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext nneg i32 [[I_08]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[A:%.*]], i64 [[IDXPROM]]
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = fmul fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    store float [[TMP2]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_08]], 1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[INC]], 1024
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
; LTOO3-LABEL: @fmul_loop_invariant_fdiv(
; LTOO3-NEXT:  entry:
; LTOO3-NEXT:    [[TMP0:%.*]] = fdiv fast float 1.000000e+00, [[X:%.*]]
; LTOO3-NEXT:    br label [[FOR_BODY:%.*]]
; LTOO3:       for.cond.cleanup:
; LTOO3-NEXT:    ret void
; LTOO3:       for.body:
; LTOO3-NEXT:    [[I_08:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; LTOO3-NEXT:    [[IDXPROM:%.*]] = zext nneg i32 [[I_08]] to i64
; LTOO3-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[A:%.*]], i64 [[IDXPROM]]
; LTOO3-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; LTOO3-NEXT:    [[TMP2:%.*]] = fmul fast float [[TMP1]], [[TMP0]]
; LTOO3-NEXT:    store float [[TMP2]], ptr [[ARRAYIDX]], align 4
; LTOO3-NEXT:    [[INC]] = add nuw nsw i32 [[I_08]], 1
; LTOO3-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[INC]], 1024
; LTOO3-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  %0 = fdiv fast float 1.000000e+00, %x
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.08 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %idxprom = zext i32 %i.08 to i64
  %arrayidx = getelementptr inbounds float, ptr %a, i64 %idxprom
  %1 = load float, ptr %arrayidx, align 4
  %2 = fmul fast float %1, %0
  store float %2, ptr %arrayidx, align 4
  %inc = add nuw nsw i32 %i.08, 1
  %cmp.not = icmp eq i32 %inc, 1024
  br i1 %cmp.not, label %for.cond.cleanup, label %for.body
}

@gb = global [ 100 x i32 ] zeroinitializer
@ga = global [ 100 x float ] zeroinitializer
; 26359:
; Same case as above, but we force some store-forwarding to happen first.
; loop-load-elim was not preserving loops, causing the fmul restriction to
; be lost (or crash).
define void @fmul_loop_invariant_sfwd(float %x) {
; CHECK-LABEL: @fmul_loop_invariant_sfwd(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = fdiv fast float 1.000000e+00, [[X:%.*]]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_08:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[IDXPROM:%.*]] = zext nneg i32 [[I_08]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [100 x float], ptr @ga, i64 0, i64 [[IDXPROM]]
; CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = fmul fast float [[TMP1]], [[TMP0]]
; CHECK-NEXT:    store float [[TMP2]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[IDXPLUS1:%.*]] = add nuw nsw i64 [[IDXPROM]], 1
; CHECK-NEXT:    [[STOREPTR:%.*]] = getelementptr inbounds [100 x i32], ptr @gb, i64 0, i64 [[IDXPLUS1]]
; CHECK-NEXT:    store i32 [[I_08]], ptr [[STOREPTR]], align 4
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_08]], 1
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[INC]], 1024
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
; LTOO3-LABEL: @fmul_loop_invariant_sfwd(
; LTOO3-NEXT:  entry:
; LTOO3-NEXT:    [[TMP0:%.*]] = fdiv fast float 1.000000e+00, [[X:%.*]]
; LTOO3-NEXT:    br label [[FOR_BODY:%.*]]
; LTOO3:       for.cond.cleanup:
; LTOO3-NEXT:    ret void
; LTOO3:       for.body:
; LTOO3-NEXT:    [[I_08:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; LTOO3-NEXT:    [[IDXPROM:%.*]] = zext nneg i32 [[I_08]] to i64
; LTOO3-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [100 x float], ptr @ga, i64 0, i64 [[IDXPROM]]
; LTOO3-NEXT:    [[TMP1:%.*]] = load float, ptr [[ARRAYIDX]], align 4
; LTOO3-NEXT:    [[TMP2:%.*]] = fmul fast float [[TMP1]], [[TMP0]]
; LTOO3-NEXT:    store float [[TMP2]], ptr [[ARRAYIDX]], align 4
; LTOO3-NEXT:    [[IDXPLUS1:%.*]] = add nuw nsw i64 [[IDXPROM]], 1
; LTOO3-NEXT:    [[STOREPTR:%.*]] = getelementptr inbounds [100 x i32], ptr @gb, i64 0, i64 [[IDXPLUS1]]
; LTOO3-NEXT:    store i32 [[I_08]], ptr [[STOREPTR]], align 4
; LTOO3-NEXT:    [[INC]] = add nuw nsw i32 [[I_08]], 1
; LTOO3-NEXT:    [[CMP_NOT:%.*]] = icmp eq i32 [[INC]], 1024
; LTOO3-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  %0 = fdiv fast float 1.000000e+00, %x
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret void

for.body:                                         ; preds = %entry, %for.body
  %i.08 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %idxprom = zext i32 %i.08 to i64
  %arrayidx = getelementptr inbounds [100 x float], ptr @ga, i64 0, i64 %idxprom
  %1 = load float, ptr %arrayidx, align 4
  %2 = fmul fast float %1, %0
  store float %2, ptr %arrayidx, align 4
  %loadptr = getelementptr inbounds [100 x i32], ptr @gb, i64 0, i64 %idxprom
  ; can forward this to next iter
  %deadload = load i32, ptr %loadptr, align 4
  %idxplus1 = add nuw nsw i64 %idxprom, 1
  %storeptr = getelementptr inbounds [100 x i32], ptr @gb, i64 0, i64 %idxplus1
  store i32 %i.08, ptr %storeptr, align 4
  %inc = add nuw nsw i32 %i.08, 1
  %cmp.not = icmp eq i32 %inc, 1024
  br i1 %cmp.not, label %for.cond.cleanup, label %for.body
}

