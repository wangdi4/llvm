; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3

; CMPLRLLVM-52673, CMPLRLLVM-52690:
; Suppress IC folding the add+gep sequence into gep,gep. This causes
; performance problems.
; If the sequence is in a loop, LSR may create an extra phi for the GEP.
; BasicAA's base pointer analysis may also get the wrong value for the base, if
; there are 2 pointers instead of 1.
; Also exposes some defects downstream (CMPLRLLVM-52646, GSE-6648)

; RUN: opt < %s -passes=instcombine -S | FileCheck %s
target datalayout = "E-p:64:64:64-p1:32:32:32-a0:0:8-f32:32:32-f64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-v64:64:64-v128:128:128"
target triple = "i686-pc-linux-gnu"

define void @test0(i64 %j, ptr %e) #0 {
; CHECK-LABEL: define void @test0(
; CHECK-SAME: i64 [[J:%.*]], ptr [[E:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[H:%.*]] = add i64 [[J]], 1
; CHECK-NEXT:    [[T8:%.*]] = getelementptr double, ptr [[E]], i64 [[H]]
; CHECK-NEXT:    store <2 x double> zeroinitializer, ptr [[T8]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %h = add i64 %j, 1
  %t8 = getelementptr double, ptr %e, i64 %h
  store <2 x double> zeroinitializer, ptr %t8, align 8
  ret void
}

define void @test0_omp(i64 %j, ptr %e) #1 {
; CHECK-LABEL: define void @test0_omp(
; CHECK-SAME: i64 [[J:%.*]], ptr [[E:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[H:%.*]] = add i64 [[J]], 1
; CHECK-NEXT:    [[T8:%.*]] = getelementptr double, ptr [[E]], i64 [[H]]
; CHECK-NEXT:    store <2 x double> zeroinitializer, ptr [[T8]], align 8
; CHECK-NEXT:    ret void
;
entry:
  %h = add i64 %j, 1
  %t8 = getelementptr double, ptr %e, i64 %h
  store <2 x double> zeroinitializer, ptr %t8, align 8
  ret void
}


attributes #0 = { "loopopt-pipeline"="light" }
attributes #1 = { "contains-openmp-target"="true" "may-have-openmp-directive"="true" }

