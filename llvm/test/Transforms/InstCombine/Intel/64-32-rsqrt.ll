; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes=instcombine %s | FileCheck %s

; For "fast" math and the "unsafe-fp-math" attribute, we can convert:
;
; (float)(C/sqrt((double)f))
; =>
; (float)C / sqrtf(f)
;
; if "C" is equivalent in "float" type.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nounwind uwtable
define dso_local float @rsqrt(float noundef %f) local_unnamed_addr #0 {
; CHECK-LABEL: @rsqrt(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call fast float @llvm.sqrt.f32(float [[F:%.*]])
; CHECK-NEXT:    [[CONV1:%.*]] = fdiv fast float 1.000000e+00, [[TMP0]]
; CHECK-NEXT:    ret float [[CONV1]]
;
entry:
  %conv = fpext float %f to double
  %0 = call fast double @llvm.sqrt.f64(double %conv)
  %div = fdiv fast double 1.000000e+00, %0
  %conv1 = fptrunc double %div to float
  ret float %conv1
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare double @llvm.sqrt.f64(double) #1

; Function Attrs: nounwind uwtable
define dso_local float @rsqrt2(float noundef %f) local_unnamed_addr #0 {
; CHECK-LABEL: @rsqrt2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call fast float @llvm.sqrt.f32(float [[F:%.*]])
; CHECK-NEXT:    [[CONV1:%.*]] = fdiv fast float 2.000000e+00, [[TMP0]]
; CHECK-NEXT:    ret float [[CONV1]]
;
entry:
  %conv = fpext float %f to double
  %0 = call fast double @llvm.sqrt.f64(double %conv)
  %div = fdiv fast double 2.000000e+00, %0
  %conv1 = fptrunc double %div to float
  ret float %conv1
}


; Function Attrs: nounwind uwtable
define dso_local float @rsqrtnounsafe(float noundef %f) local_unnamed_addr {
; CHECK-LABEL: @rsqrtnounsafe(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F:%.*]] to double
; CHECK-NEXT:    [[TMP0:%.*]] = call fast double @llvm.sqrt.f64(double [[CONV]])
; CHECK-NEXT:    [[DIV:%.*]] = fdiv fast double 1.000000e+00, [[TMP0]]
; CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[DIV]] to float
; CHECK-NEXT:    ret float [[CONV1]]
;
entry:
; check for "unsafe-fp-math" attribute also
  %conv = fpext float %f to double
  %0 = call fast double @llvm.sqrt.f64(double %conv)
  %div = fdiv fast double 1.000000e+00, %0
  %conv1 = fptrunc double %div to float
  ret float %conv1
}

; Function Attrs: nounwind uwtable
define dso_local float @rsqrtnoc(double noundef %d, float noundef %f) local_unnamed_addr #0 {
; CHECK-LABEL: @rsqrtnoc(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F:%.*]] to double
; CHECK-NEXT:    [[TMP0:%.*]] = call fast double @llvm.sqrt.f64(double [[CONV]])
; CHECK-NEXT:    [[DIV:%.*]] = fdiv fast double [[D:%.*]], [[TMP0]]
; CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[DIV]] to float
; CHECK-NEXT:    ret float [[CONV1]]
;
entry:
; numerator must be a constant
  %conv = fpext float %f to double
  %0 = call fast double @llvm.sqrt.f64(double %conv)
  %div = fdiv fast double %d, %0
  %conv1 = fptrunc double %div to float
  ret float %conv1
}

; Function Attrs: nounwind uwtable
define dso_local double @rsqrtdouble(float noundef %f) local_unnamed_addr #0 {
; CHECK-LABEL: @rsqrtdouble(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F:%.*]] to double
; CHECK-NEXT:    [[TMP0:%.*]] = call fast double @llvm.sqrt.f64(double [[CONV]])
; CHECK-NEXT:    [[DIV:%.*]] = fdiv fast double 1.000000e+00, [[TMP0]]
; CHECK-NEXT:    ret double [[DIV]]
;
entry:
; result must be an fptrunc
  %conv = fpext float %f to double
  %0 = call fast double @llvm.sqrt.f64(double %conv)
  %div = fdiv fast double 1.000000e+00, %0
  ret double %div
}

; Function Attrs: nounwind uwtable
define dso_local float @rsqrtbignum(float noundef %f) local_unnamed_addr #0 {
; CHECK-LABEL: @rsqrtbignum(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F:%.*]] to double
; CHECK-NEXT:    [[TMP0:%.*]] = call fast double @llvm.sqrt.f64(double [[CONV]])
; CHECK-NEXT:    [[DIV:%.*]] = fdiv fast double 0x6974E718D7D7625A, [[TMP0]]
; CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[DIV]] to float
; CHECK-NEXT:    ret float [[CONV1]]
;
entry:
; C must fit in 32 bits (example is 1e200)
  %conv = fpext float %f to double
  %0 = call fast double @llvm.sqrt.f64(double %conv)
  %div = fdiv fast double 0x6974E718D7D7625A, %0
  %conv1 = fptrunc double %div to float
  ret float %conv1
}

attributes #0 = { nounwind uwtable "unsafe-fp-math"="true" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
