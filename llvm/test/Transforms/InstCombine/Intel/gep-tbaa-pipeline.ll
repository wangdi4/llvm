; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes='default<O2>' -S < %s | FileCheck %s
; RUN: opt -passes='default<O3>' -S < %s | FileCheck %s

; This test verifies that there are no issues for the cases where two different
; types with similar layout are created inplace in the same place. Particularly,
; any GVN/CSE-like optimization on GEPs must drop !intel-tbaa annotations. Note,
; that "--match-full-lines" *must* be in the RUN lines so that any unexpected
; !intel-tbaa could be caught by the FlyCheck.

%struct.Outer1 = type { i32, %struct.Inner }
%struct.Outer2 = type { float, %struct.Inner }
%struct.Inner = type { [10 x i32] }

declare i32 @foo(ptr) nounwind readonly
declare void @createOuter1(ptr)
declare void @createOuter2(ptr)

define i32 @bar(ptr %p) {
; CHECK-LABEL: @bar(
; CHECK-NEXT:    tail call void @createOuter1(ptr [[P:%.*]])
; CHECK-NEXT:    [[OUTER1_INNER_ELEM:%.*]] = getelementptr inbounds [[STRUCT_OUTER1:%.*]], ptr [[P]], i64 0, i32 1, i32 0, i64 3
; CHECK-NEXT:    [[A:%.*]] = tail call i32 @foo(ptr nonnull [[OUTER1_INNER_ELEM]])
; CHECK-NEXT:    tail call void @createOuter2(ptr [[P]])
; CHECK-NEXT:    [[B:%.*]] = tail call i32 @foo(ptr nonnull [[OUTER1_INNER_ELEM]])
; CHECK-NEXT:    [[RET:%.*]] = add i32 [[B]], [[A]]
; CHECK-NEXT:    ret i32 [[RET]]
;
  tail call void @createOuter1(ptr %p)
  %Outer1.Inner.elem = getelementptr inbounds %struct.Outer1, ptr %p, i32 0, i32 1, i32 0, i32 3, !intel-tbaa !8
  %a = tail call i32 @foo(ptr %Outer1.Inner.elem)

  tail call void @createOuter2(ptr %p)
  %Outer2.Inner.elem = getelementptr inbounds %struct.Outer2, ptr %p, i32 0, i32 1, i32 0, i32 3, !intel-tbaa !9
  %b = tail call i32 @foo(ptr %Outer2.Inner.elem)
  %ret = add i32 %a, %b
  ret i32 %ret
}

!0 = !{!"Simple C++ TBAA"}
!1 = !{!"omnipotent char", !0, i64 0}
!2 = !{!"int", !1, i64 0}
!3 = !{!"float", !1, i64 0}
!4 = !{!"array@typeinfo name for int [10]", !2, i64 0}
!5 = !{!"struct@typeinfo name for Inner", !4, i64 0}
!6 = !{!"struct@typeinfo name for Outer1", !2, i64 0, !5, i64 4}
!7 = !{!"struct@typeinfo name for Outer2", !3, i64 0, !5, i64 4}

!8 = !{!6, !2, i64 4} ; Outer1::Inner::array::elem
!9 = !{!7, !2, i64 4} ; Outer2::Inner::array::elem
