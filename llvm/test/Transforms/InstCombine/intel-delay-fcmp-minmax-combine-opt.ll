; NOTE: Assertions have been autogenerated by utils/update_test_checks.py

; RUN: opt -passes=instcombine,slp-vectorizer,instcombine -mtriple=i686-linux -mattr=+avx512f,+avx512vl,+avx512dq -enable-intel-advanced-opts=true -mattr=-prefer-256-bit %s -S 2>&1 | FileCheck %s --check-prefixes=ENABLE
; RUN: opt -passes=instcombine,slp-vectorizer,instcombine -disable-fcmp-min-max-combine=true -mtriple=i686-linux -mattr=+avx512f,+avx512vl,+avx512dq -enable-intel-advanced-opts=true -mattr=-prefer-256-bit %s -S 2>&1 | FileCheck %s --check-prefixes=DISABLE

define dso_local i32 @delayFCmpMinMaxOpt(float* %in0, float* %in1) {
; ENABLE-LABEL: @delayFCmpMinMaxOpt(
; ENABLE-NEXT:  entry:
; ENABLE-NEXT:    [[A:%.*]] = load float, float* [[IN0:%.*]], align 4
; ENABLE-NEXT:    [[B_PTR:%.*]] = getelementptr inbounds float, float* [[IN0]], i64 1
; ENABLE-NEXT:    [[B:%.*]] = load float, float* [[B_PTR]], align 4
; ENABLE-NEXT:    [[C_PTR:%.*]] = getelementptr inbounds float, float* [[IN0]], i64 2
; ENABLE-NEXT:    [[C:%.*]] = load float, float* [[C_PTR]], align 4
; ENABLE-NEXT:    [[D_PTR:%.*]] = getelementptr inbounds float, float* [[IN0]], i64 3
; ENABLE-NEXT:    [[D:%.*]] = load float, float* [[D_PTR]], align 4
; ENABLE-NEXT:    [[M:%.*]] = load float, float* [[IN1:%.*]], align 4
; ENABLE-NEXT:    [[CMP_B0:%.*]] = fcmp fast oge float [[B]], [[A]]
; ENABLE-NEXT:    [[TMP0:%.*]] = select i1 [[CMP_B0]], float [[B]], float [[A]]
; ENABLE-NEXT:    [[CMP_C0:%.*]] = fcmp fast oge float [[C]], [[TMP0]]
; ENABLE-NEXT:    [[TMP1:%.*]] = select i1 [[CMP_C0]], float [[C]], float [[TMP0]]
; ENABLE-NEXT:    [[CMP_D0:%.*]] = fcmp fast oge float [[D]], [[TMP1]]
; ENABLE-NEXT:    [[TMP2:%.*]] = select i1 [[CMP_D0]], float [[D]], float [[TMP1]]
; ENABLE-NEXT:    [[CMP_A0:%.*]] = fcmp fast olt float [[M]], [[TMP2]]
; ENABLE-NEXT:    br i1 [[CMP_A0]], label [[EXIT:%.*]], label [[IF_ZERO:%.*]]
; ENABLE:       if.zero:
; ENABLE-NEXT:    [[CMP_ZERO_A:%.*]] = fcmp fast ole float [[A]], [[B]]
; ENABLE-NEXT:    [[TMP3:%.*]] = select i1 [[CMP_ZERO_A]], float [[A]], float [[B]]
; ENABLE-NEXT:    [[CMP_ZERO_B:%.*]] = fcmp fast ole float [[TMP3]], [[C]]
; ENABLE-NEXT:    [[TMP4:%.*]] = select i1 [[CMP_ZERO_B]], float [[TMP3]], float [[C]]
; ENABLE-NEXT:    [[CMP_ZERO_C:%.*]] = fcmp fast ole float [[TMP4]], [[D]]
; ENABLE-NEXT:    [[TMP5:%.*]] = select i1 [[CMP_ZERO_C]], float [[TMP4]], float [[D]]
; ENABLE-NEXT:    [[CMP_ZERO_D:%.*]] = fcmp fast olt float [[TMP5]], 0.000000e+00
; ENABLE-NEXT:    br i1 [[CMP_ZERO_D]], label [[EXIT]], label [[SUCC:%.*]]
; ENABLE:       succ:
; ENABLE-NEXT:    br label [[EXIT]]
; ENABLE:       exit:
; ENABLE-NEXT:    [[RETVAL:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ 0, [[IF_ZERO]] ], [ 1, [[SUCC]] ]
; ENABLE-NEXT:    ret i32 [[RETVAL]]
;
; DISABLE-LABEL: @delayFCmpMinMaxOpt(
; DISABLE-NEXT:  entry:
; DISABLE-NEXT:    [[TMP0:%.*]] = bitcast float* [[IN0:%.*]] to <4 x float>*
; DISABLE-NEXT:    [[TMP1:%.*]] = load <4 x float>, <4 x float>* [[TMP0]], align 4
; DISABLE-NEXT:    [[M:%.*]] = load float, float* [[IN1:%.*]], align 4
; DISABLE-NEXT:    [[TMP2:%.*]] = insertelement <4 x float> poison, float [[M]], i32 0
; DISABLE-NEXT:    [[TMP3:%.*]] = shufflevector <4 x float> [[TMP2]], <4 x float> undef, <4 x i32> zeroinitializer
; DISABLE-NEXT:    [[TMP4:%.*]] = fcmp fast ogt <4 x float> [[TMP1]], [[TMP3]]
; DISABLE-NEXT:    [[TMP5:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP4]])
; DISABLE-NEXT:    br i1 [[TMP5]], label [[EXIT:%.*]], label [[IF_ZERO:%.*]]
; DISABLE:       if.zero:
; DISABLE-NEXT:    [[TMP6:%.*]] = fcmp fast olt <4 x float> [[TMP1]], zeroinitializer
; DISABLE-NEXT:    [[TMP7:%.*]] = call i1 @llvm.vector.reduce.or.v4i1(<4 x i1> [[TMP6]])
; DISABLE-NEXT:    br i1 [[TMP7]], label [[EXIT]], label [[SUCC:%.*]]
; DISABLE:       succ:
; DISABLE-NEXT:    br label [[EXIT]]
; DISABLE:       exit:
; DISABLE-NEXT:    [[RETVAL:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ 0, [[IF_ZERO]] ], [ 1, [[SUCC]] ]
; DISABLE-NEXT:    ret i32 [[RETVAL]]
;
entry:
  %a_ptr = getelementptr inbounds float, float* %in0, i64 0
  %a = load float, float* %a_ptr, align 4
  %b_ptr = getelementptr inbounds float, float* %in0, i64 1
  %b = load float, float* %b_ptr, align 4
  %c_ptr = getelementptr inbounds float, float* %in0, i64 2
  %c = load float, float* %c_ptr, align 4
  %d_ptr = getelementptr inbounds float, float* %in0, i64 3
  %d = load float, float* %d_ptr, align 4
  %m_ptr = getelementptr inbounds float, float* %in1, i64 0
  %m = load float, float* %m_ptr, align 4
  %cmp.a0 = fcmp fast ogt float %a, %m
  %cmp.b0 = fcmp fast ogt float %b, %m
  %or.cond.b0 = or i1 %cmp.b0, %cmp.a0
  %cmp.c0 = fcmp fast ogt float %c, %m
  %or.cond.c0 = or i1 %cmp.c0, %or.cond.b0
  %cmp.d0 = fcmp fast ogt float %d, %m
  %or.cond.d0 = or i1 %cmp.d0, %or.cond.c0
  br i1 %or.cond.d0, label %exit, label %if.zero

if.zero:                                         ; preds = %entry
  %cmp.zero.a = fcmp fast olt float %a, 0.000000e+00
  %cmp.zero.b = fcmp fast olt float %b, 0.000000e+00
  %or.cond.0 = or i1 %cmp.zero.a, %cmp.zero.b
  %cmp.zero.c = fcmp fast olt float %c, 0.000000e+00
  %or.cond.1 = or i1 %or.cond.0, %cmp.zero.c
  %cmp.zero.d = fcmp fast olt float %d, 0.000000e+00
  %or.cond.2 = or i1 %or.cond.1, %cmp.zero.d
  br i1 %or.cond.2, label %exit, label %succ

succ:                                             ; preds = %if.zero
  br label %exit

exit:                                             ; preds = %entry, %if.zero, %succ
  %retval = phi i32 [ 0, %entry ], [ 0, %if.zero ], [ 1, %succ ]
  ret i32 %retval
}

