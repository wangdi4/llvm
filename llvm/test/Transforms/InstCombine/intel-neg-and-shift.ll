; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -opaque-pointers=0 -passes="instcombine" < %s -S | FileCheck %s

; This test checks this optimization
; (neg (and (lshr X, C), 1)) -> (ashr (shl X, (BitWidth - C - 1)), (BitWidth - 1))

define i32 @test1(i32 %x) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:    [[TMP1:%.*]] = shl i32 [[X:%.*]], 24
; CHECK-NEXT:    [[C:%.*]] = ashr i32 [[TMP1]], 31
; CHECK-NEXT:    ret i32 [[C]]
;
  %a = lshr i32 %x, 7
  %b = and i32 %a, 1
  %c = sub i32 0, %b
  ret i32 %c
}

define <2 x i32> @test2(<2 x i32> %x) {
; CHECK-LABEL: @test2(
; CHECK-NEXT:    [[TMP1:%.*]] = shl <2 x i32> [[X:%.*]], <i32 24, i32 24>
; CHECK-NEXT:    [[C:%.*]] = ashr <2 x i32> [[TMP1]], <i32 31, i32 31>
; CHECK-NEXT:    ret <2 x i32> [[C]]
;
  %a = lshr <2 x i32> %x, <i32 7, i32 7>
  %b = and <2 x i32> %a, <i32 1, i32 1>
  %c = sub <2 x i32> zeroinitializer, %b
  ret <2 x i32> %c
}

; Make sure we don't do the transform if the 'and' has an additional use.
define i32 @test3(i32 %x, i32* %p) {
; CHECK-LABEL: @test3(
; CHECK-NEXT:    [[A:%.*]] = lshr i32 [[X:%.*]], 7
; CHECK-NEXT:    [[B:%.*]] = and i32 [[A]], 1
; CHECK-NEXT:    [[C:%.*]] = sub nsw i32 0, [[B]]
; CHECK-NEXT:    store i32 [[B]], i32* [[P:%.*]], align 4
; CHECK-NEXT:    ret i32 [[C]]
;
  %a = lshr i32 %x, 7
  %b = and i32 %a, 1
  %c = sub i32 0, %b
  store i32 %b, i32* %p
  ret i32 %c
}

; We can still do the transform if the lshr has an additional use. The transform
; replaces the and/neg and reduces the dependency length.
define i32 @test4(i32 %x, i32* %p) {
; CHECK-LABEL: @test4(
; CHECK-NEXT:    [[A:%.*]] = lshr i32 [[X:%.*]], 7
; CHECK-NEXT:    [[TMP1:%.*]] = shl i32 [[X]], 24
; CHECK-NEXT:    [[C:%.*]] = ashr i32 [[TMP1]], 31
; CHECK-NEXT:    store i32 [[A]], i32* [[P:%.*]], align 4
; CHECK-NEXT:    ret i32 [[C]]
;
  %a = lshr i32 %x, 7
  %b = and i32 %a, 1
  %c = sub i32 0, %b
  store i32 %a, i32* %p
  ret i32 %c
}
