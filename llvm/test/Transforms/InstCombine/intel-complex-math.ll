; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --check-globals
; RUN: opt < %s -instcombine -S -inst-combine-complex | FileCheck %s

; Check that we match the simple expansions of complex multiplication and
; division, whether the target complex value is made by returning a struct,
; vector, or by storing into memory.

%complex.double = type {double, double}

define %complex.double @struct_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @struct_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[TMP6]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[TMP7]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %x = fsub double %ac, %bd
  %y = fadd double %ad, %bc
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define <2 x double> @vector_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @vector_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1]]
; CHECK-NEXT:    ret <2 x double> [[TMP5]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %x = fsub double %ac, %bd
  %y = fadd double %ad, %bc
  %res = insertelement <2 x double> zeroinitializer, double %x, i32 0
  %res.1 = insertelement <2 x double> %res, double %y, i32 1
  ret <2 x double> %res.1
}

define void @memory_mul(double %a, double %b, double %c, double %d, %complex.double* %dest) {
; CHECK-LABEL: @memory_mul(
; CHECK-NEXT:    [[DEST_REAL:%.*]] = getelementptr [[COMPLEX_DOUBLE:%.*]], %complex.double* [[DEST:%.*]], i64 0, i32 0
; CHECK-NEXT:    [[DEST_IMAG:%.*]] = getelementptr [[COMPLEX_DOUBLE]], %complex.double* [[DEST]], i64 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    store double [[TMP6]], double* [[DEST_REAL]], align 8
; CHECK-NEXT:    store double [[TMP7]], double* [[DEST_IMAG]], align 8
; CHECK-NEXT:    ret void
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %x = fsub double %ac, %bd
  %y = fadd double %ad, %bc
  %dest.real = getelementptr %complex.double, %complex.double* %dest, i64 0, i32 0
  %dest.imag = getelementptr %complex.double, %complex.double* %dest, i64 0, i32 1
  store double %x, double* %dest.real
  store double %y, double* %dest.imag
  ret void
}

define %complex.double @fast_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fast_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call fast <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[TMP6]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[TMP7]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul fast double %a, %c
  %bd = fmul fast double %b, %d
  %ad = fmul fast double %a, %d
  %bc = fmul fast double %b, %c
  %x = fsub fast double %ac, %bd
  %y = fadd fast double %ad, %bc
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define %complex.double @fastish_mul(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fastish_mul(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call ninf <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR1]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[TMP6]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[TMP7]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul fast double %a, %c
  %bd = fmul nnan ninf nsz double %b, %d
  %ad = fmul ninf arcp contract double %a, %d
  %bc = fmul reassoc nsz ninf double %b, %c
  %x = fsub ninf arcp afn double %ac, %bd
  %y = fadd afn nnan ninf double %ad, %bc
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define %complex.double @struct_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @struct_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[TMP6]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[TMP7]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %cc = fmul double %c, %c
  %dd = fmul double %d, %d
  %scale = fadd double %cc, %dd
  %x_noscale = fadd double %ac, %bd
  %y_noscale = fsub double %bc, %ad
  %x = fdiv double %x_noscale, %scale
  %y = fdiv double %y_noscale, %scale
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define <2 x double> @vector_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @vector_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2]]
; CHECK-NEXT:    ret <2 x double> [[TMP5]]
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %cc = fmul double %c, %c
  %dd = fmul double %d, %d
  %scale = fadd double %cc, %dd
  %x_noscale = fadd double %ac, %bd
  %y_noscale = fsub double %bc, %ad
  %x = fdiv double %x_noscale, %scale
  %y = fdiv double %y_noscale, %scale
  %res = insertelement <2 x double> zeroinitializer, double %x, i32 0
  %res.1 = insertelement <2 x double> %res, double %y, i32 1
  ret <2 x double> %res.1
}

define void @memory_div(double %a, double %b, double %c, double %d, %complex.double* %dest) {
; CHECK-LABEL: @memory_div(
; CHECK-NEXT:    [[DEST_REAL:%.*]] = getelementptr [[COMPLEX_DOUBLE:%.*]], %complex.double* [[DEST:%.*]], i64 0, i32 0
; CHECK-NEXT:    [[DEST_IMAG:%.*]] = getelementptr [[COMPLEX_DOUBLE]], %complex.double* [[DEST]], i64 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    store double [[TMP6]], double* [[DEST_REAL]], align 8
; CHECK-NEXT:    store double [[TMP7]], double* [[DEST_IMAG]], align 8
; CHECK-NEXT:    ret void
;
  %ac = fmul double %a, %c
  %bd = fmul double %b, %d
  %ad = fmul double %a, %d
  %bc = fmul double %b, %c
  %cc = fmul double %c, %c
  %dd = fmul double %d, %d
  %scale = fadd double %cc, %dd
  %x_noscale = fadd double %ac, %bd
  %y_noscale = fsub double %bc, %ad
  %x = fdiv double %x_noscale, %scale
  %y = fdiv double %y_noscale, %scale
  %dest.real = getelementptr %complex.double, %complex.double* %dest, i64 0, i32 0
  %dest.imag = getelementptr %complex.double, %complex.double* %dest, i64 0, i32 1
  store double %x, double* %dest.real
  store double %y, double* %dest.imag
  ret void
}

define %complex.double @fast_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fast_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call fast <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[TMP6]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[TMP7]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul fast double %a, %c
  %bd = fmul fast double %b, %d
  %ad = fmul fast double %a, %d
  %bc = fmul fast double %b, %c
  %cc = fmul fast double %c, %c
  %dd = fmul fast double %d, %d
  %scale = fadd fast double %cc, %dd
  %x_noscale = fadd fast double %ac, %bd
  %y_noscale = fsub fast double %bc, %ad
  %x = fdiv fast double %x_noscale, %scale
  %y = fdiv fast double %y_noscale, %scale
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

define %complex.double @fastish_div(double %a, double %b, double %c, double %d) {
; CHECK-LABEL: @fastish_div(
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x double> poison, double [[A:%.*]], i64 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x double> [[TMP1]], double [[B:%.*]], i64 1
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> poison, double [[C:%.*]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[D:%.*]], i64 1
; CHECK-NEXT:    [[TMP5:%.*]] = call arcp <2 x double> @llvm.intel.complex.fdiv.v2f64(<2 x double> [[TMP2]], <2 x double> [[TMP4]]) #[[ATTR2]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x double> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP5]], i64 1
; CHECK-NEXT:    [[RES:%.*]] = insertvalue [[COMPLEX_DOUBLE:%.*]] zeroinitializer, double [[TMP6]], 0
; CHECK-NEXT:    [[RES_1:%.*]] = insertvalue [[COMPLEX_DOUBLE]] [[RES]], double [[TMP7]], 1
; CHECK-NEXT:    ret [[COMPLEX_DOUBLE]] [[RES_1]]
;
  %ac = fmul arcp contract double %a, %c
  %bd = fmul arcp afn ninf reassoc double %b, %d
  %ad = fmul arcp afn ninf double %a, %d
  %bc = fmul arcp nsz reassoc double %b, %c
  %cc = fmul arcp nsz afn double %c, %c
  %dd = fmul arcp nsz double %d, %d
  %scale = fadd arcp nsz contract nnan reassoc double %cc, %dd
  %x_noscale = fadd arcp nsz contract ninf nnan double %ac, %bd
  %y_noscale = fsub arcp nsz contract reassoc double %bc, %ad
  %x = fdiv arcp ninf nnan reassoc double %x_noscale, %scale
  %y = fdiv arcp nnan double %y_noscale, %scale
  %res = insertvalue %complex.double zeroinitializer, double %x, 0
  %res.1 = insertvalue %complex.double %res, double %y, 1
  ret %complex.double %res.1
}

;.
; CHECK: attributes #[[ATTR0:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(none) }
; CHECK: attributes #[[ATTR1]] = { "complex-limited-range" }
; CHECK: attributes #[[ATTR2]] = { "complex-limited-range" "complex-no-scale" }
;.
