; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; INTEL_CUSTOMIZATION
; RUN: opt --opaque-pointers -passes=instcombine -S < %s | FileCheck %s
; added --opaque-pointers
; gep 0,0 is not removed in xmain
; end INTEL_CUSTOMIZATION

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"

declare void @llvm.memcpy.p0.p0.i64(ptr nocapture, ptr nocapture, i64, i1) nounwind

; Verify that instcombine preserves TBAA tags when converting a memcpy into
; a scalar load and store.

%struct.test1 = type { float }

define void @test1(ptr nocapture %a, ptr nocapture %b) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds { i32 }, ptr [[B:%.*]], i64 0, i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds { i32 }, ptr [[A:%.*]], i64 0, i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP0]], align 4, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    store i32 [[TMP2]], ptr [[TMP1]], align 4, !tbaa [[TBAA0]]
; CHECK-NEXT:    ret void
;
entry:
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 4 %a, ptr align 4 %b, i64 4, i1 false), !tbaa.struct !3
  ret void
}

%struct.test2 = type { ptr }

define ptr @test2() {
; CHECK-LABEL: @test2(
; CHECK-NEXT:    [[TMP:%.*]] = alloca [[STRUCT_TEST2:%.*]], align 8
; CHECK-NEXT:    store i64 poison, ptr null, align 4294967296
; CHECK-NEXT:    ret ptr [[TMP]]
;
  %tmp = alloca %struct.test2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %tmp, ptr align 8 undef, i64 8, i1 false), !tbaa.struct !4
  %tmp3 = load ptr, ptr %tmp
  ret ptr %tmp
}

; INTEL
; tbaa.struct tags that point to non-scalars should not be converted to tbaa.
; They should stay in tbaa.struct form.

%struct.thing = type { [1 x %struct.thing2] }
%struct.thing2 = type { i32, i32 }

@p = dso_local global %struct.thing* null, align 8

define dso_local i64 @test3_intel(%struct.thing* %t) {
; CHECK-LABEL: @test3_intel(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr @p, align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[TMP0]], align 4, !tbaa.struct !3
; CHECK-NEXT:    ret i64 [[TMP1]]
;

entry:
  %retval = alloca %struct.thing, align 4
  %t.addr = alloca %struct.thing*, align 8
  store %struct.thing* %t, %struct.thing** %t.addr, align 8, !tbaa !2
  %0 = load %struct.thing*, %struct.thing** @p, align 8, !tbaa !2
  %1 = bitcast %struct.thing* %retval to i8*
  %2 = bitcast %struct.thing* %0 to i8*
  call void @llvm.memcpy.p0.p0.i64(i8* align 4 %1, i8* align 4 %2, i64 8, i1 false), !tbaa.struct !6
  %coerce.dive = getelementptr inbounds %struct.thing, %struct.thing* %retval, i32 0, i32 0
  %3 = bitcast [1 x %struct.thing2]* %coerce.dive to i64*
  %4 = load i64, i64* %3, align 4
  ret i64 %4
}

; CHECK: !0 = !{!1, !1, i64 0}
; CHECK: !1 = !{!"float", !2}

!0 = !{!"Simple C/C++ TBAA"}
!1 = !{!"omnipotent char", !0}
!2 = !{!5, !5, i64 0}
!3 = !{i64 0, i64 4, !2}
!4 = !{i64 0, i64 8, null}
!5 = !{!"float", !0}

; INTEL
; Add some non-scalar nodes in tbaa.struct form.
!6 = !{i64 0, i64 8, !7}
!7 = !{!8, !8, i64 0}
!8 = !{!"array@_ZTSA1_6thing2", !9, i64 0}
!9 = !{!"struct@_ZTS6thing2", !10, i64 0, !10, i64 4}
!10 = !{!"int", !4, i64 0}
