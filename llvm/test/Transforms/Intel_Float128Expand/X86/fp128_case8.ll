; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -S -mtriple=x86_64-unknown-unknown -float128-expand -intel-libirc-allowed | FileCheck %s

%eh.ThrowInfo = type { i32, i32, i32, i32 }

; Function Attrs: noinline norecurse optnone uwtable
define dso_local i32 @main(fp128 %x) #0 personality i8* bitcast (i32 (...)* @__CxxFrameHandler3 to i8*) {
; CHECK-LABEL: @main(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = alloca fp128, align 16
; CHECK-NEXT:    [[TMP1:%.*]] = alloca fp128, align 16
; CHECK-NEXT:    [[TMP2:%.*]] = alloca fp128, align 16
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[TMP:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I3:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast fp128* [[TMP2]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 16, i8* [[TMP3]])
; CHECK-NEXT:    store fp128 [[X:%.*]], fp128* [[TMP2]], align 16
; CHECK-NEXT:    store i32 0, i32* [[RETVAL]], align 4
; CHECK-NEXT:    store i32 1, i32* [[TMP]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i32* [[TMP]] to i8*
; CHECK-NEXT:    invoke void @_CxxThrowException(i8* [[TMP4]], %eh.ThrowInfo* null)
; CHECK-NEXT:    to label [[UNREACHABLE:%.*]] unwind label [[CATCH_DISPATCH:%.*]]
; CHECK:       catch.dispatch:
; CHECK-NEXT:    [[TMP5:%.*]] = catchswitch within none [label %catch] unwind label [[CATCH_DISPATCH1:%.*]]
; CHECK:       catch.dispatch1:
; CHECK-NEXT:    [[TMP6:%.*]] = catchswitch within none [label %catch2] unwind to caller
; CHECK:       catch2:
; CHECK-NEXT:    [[TMP7:%.*]] = catchpad within [[TMP6]] [i32 0, i32* %i3]
; CHECK-NEXT:    store i32 2, i32* [[RETVAL]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast fp128* [[TMP0]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 16, i8* [[TMP8]])
; CHECK-NEXT:    call void @__addq(fp128* [[TMP0]], fp128* [[TMP2]], fp128* [[TMP2]])
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast fp128* [[TMP2]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 16, i8* [[TMP9]])
; CHECK-NEXT:    [[TMP10:%.*]] = load fp128, fp128* [[TMP0]], align 16
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast fp128* [[TMP0]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 16, i8* [[TMP11]])
; CHECK-NEXT:    catchret from [[TMP7]] to label [[CATCHRET_DEST4:%.*]]
; CHECK:       catch:
; CHECK-NEXT:    [[TMP12:%.*]] = catchpad within [[TMP5]] [i32 0, i32* %i]
; CHECK-NEXT:    store i32 1, i32* [[RETVAL]], align 4
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast fp128* [[TMP1]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 16, i8* [[TMP13]])
; CHECK-NEXT:    call void @__addq(fp128* [[TMP1]], fp128* [[TMP2]], fp128* [[TMP2]])
; CHECK-NEXT:    [[TMP14:%.*]] = bitcast fp128* [[TMP2]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 16, i8* [[TMP14]])
; CHECK-NEXT:    [[TMP15:%.*]] = load fp128, fp128* [[TMP1]], align 16
; CHECK-NEXT:    [[TMP16:%.*]] = bitcast fp128* [[TMP1]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 16, i8* [[TMP16]])
; CHECK-NEXT:    catchret from [[TMP12]] to label [[CATCHRET_DEST:%.*]]
; CHECK:       catchret.dest:
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       try.cont:
; CHECK-NEXT:    br label [[TRY_CONT5:%.*]]
; CHECK:       catchret.dest4:
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       try.cont5:
; CHECK-NEXT:    store i32 0, i32* [[RETVAL]], align 4
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, i32* [[RETVAL]], align 4
; CHECK-NEXT:    ret i32 [[TMP17]]
; CHECK:       unreachable:
; CHECK-NEXT:    unreachable
;
entry:
  %retval = alloca i32, align 4
  %tmp = alloca i32, align 4
  %i = alloca i32, align 4
  %i3 = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 1, i32* %tmp, align 4
  %0 = bitcast i32* %tmp to i8*
  invoke void @_CxxThrowException(i8* %0, %eh.ThrowInfo* null) #1
  to label %unreachable unwind label %catch.dispatch

catch.dispatch:                                   ; preds = %entry
  %1 = catchswitch within none [label %catch] unwind label %catch.dispatch1

catch.dispatch1:                                  ; preds = %catch.dispatch
  %2 = catchswitch within none [label %catch2] unwind to caller

catch2:                                           ; preds = %catch.dispatch1
  %3 = catchpad within %2 [i32 0, i32* %i3]
  store i32 2, i32* %retval, align 4
  %4 = fadd fp128 %x, %x
  catchret from %3 to label %catchret.dest4

catch:                                            ; preds = %catch.dispatch
  %5 = catchpad within %1 [i32 0, i32* %i]
  store i32 1, i32* %retval, align 4
  %6 = fadd fp128 %x, %x
  catchret from %5 to label %catchret.dest

catchret.dest:                                    ; preds = %catch
  br label %return

try.cont:                                         ; No predecessors!
  br label %try.cont5

catchret.dest4:                                   ; preds = %catch2
  br label %return

try.cont5:                                        ; preds = %try.cont
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %try.cont5, %catchret.dest4, %catchret.dest
  %7 = load i32, i32* %retval, align 4
  ret i32 %7

unreachable:                                      ; preds = %entry
  unreachable
}

declare dso_local void @_CxxThrowException(i8*, %eh.ThrowInfo*)

declare dso_local i32 @__CxxFrameHandler3(...)
