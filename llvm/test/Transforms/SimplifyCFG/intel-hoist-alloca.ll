; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2

; RUN: opt -passes="simplifycfg<hoist-common-insts>" -S < %s | FileCheck %s

; Verify that allocas are hoisted to the top block when possible.
; Non-entry allocas ("dynamic allocas") are expensive on Windows.
; They require a call to _chkstk, to avoid page faults.

target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-windows-msvc19.29.30146"

; The i64 alloca should be hoisted.
define fastcc i64 @Sr(i1 %0) {
; CHECK-LABEL: define fastcc i64 @Sr
; CHECK-SAME: (i1 [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = alloca i64, align 8
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP5:%.*]], label [[TMP3:%.*]]
; CHECK:       common.ret:
; CHECK-NEXT:    ret i64 0
; CHECK:       3:
; CHECK-NEXT:    [[TMP4:%.*]] = alloca i32, i32 0, align 4
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       5:
; CHECK-NEXT:    [[TMP6:%.*]] = alloca i64, i32 0, align 8
; CHECK-NEXT:    br label [[COMMON_RET]]
;
  br i1 %0, label %5, label %2

common.ret:                                       ; preds = %5, %2
  ret i64 0

2:                                                ; preds = %1
  %3 = alloca i64, align 8
  %4 = alloca i32, i32 0, align 4
  br label %common.ret

5:                                                ; preds = %1
  %6 = alloca i64, align 8
  %7 = alloca i64, i32 0, align 8
  br label %common.ret
}

; The i64 alloca should be hoisted.
; The stacksave should also be hoisted, as it comes before the allocas.
define fastcc i64 @save1(i1 %0) {
; CHECK-LABEL: define fastcc i64 @save1
; CHECK-SAME: (i1 [[TMP0:%.*]]) {
; CHECK-NEXT:    [[S2:%.*]] = call ptr @llvm.stacksave()
; CHECK-NEXT:    [[TMP2:%.*]] = alloca i64, align 8
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP5:%.*]], label [[TMP3:%.*]]
; CHECK:       common.ret:
; CHECK-NEXT:    call void @llvm.stackrestore(ptr [[S2]])
; CHECK-NEXT:    ret i64 0
; CHECK:       3:
; CHECK-NEXT:    [[TMP4:%.*]] = alloca i32, i32 0, align 4
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       5:
; CHECK-NEXT:    [[TMP6:%.*]] = alloca i64, i32 0, align 8
; CHECK-NEXT:    br label [[COMMON_RET]]
;
  br i1 %0, label %5, label %2

common.ret:                                       ; preds = %5, %2
  %merge = phi ptr [ %s1, %2 ], [ %s2, %5 ]
  call void @llvm.stackrestore(ptr %merge)
  ret i64 0

2:                                                ; preds = %1
  %s1 = call ptr @llvm.stacksave()
  %3 = alloca i64, align 8
  %4 = alloca i32, i32 0, align 4
  br label %common.ret

5:                                                ; preds = %1
  %s2 = call ptr @llvm.stacksave()
  %6 = alloca i64, align 8
  %7 = alloca i64, i32 0, align 8
  br label %common.ret
}

; The stacksave cannot be moved past the alloca i32.
; The alloca i64 cannot be moved past the stacksave.
; No motion should occur here.
define fastcc i64 @neg(i1 %0) {
; CHECK-LABEL: define fastcc i64 @neg
; CHECK-SAME: (i1 [[TMP0:%.*]]) {
; CHECK-NEXT:    br i1 [[TMP0]], label [[TMP5:%.*]], label [[TMP2:%.*]]
; CHECK:       common.ret:
; CHECK-NEXT:    [[MERGE:%.*]] = phi ptr [ [[S1:%.*]], [[TMP2]] ], [ [[S2:%.*]], [[TMP5]] ]
; CHECK-NEXT:    call void @llvm.stackrestore(ptr [[MERGE]])
; CHECK-NEXT:    ret i64 0
; CHECK:       2:
; CHECK-NEXT:    [[TMP3:%.*]] = alloca i32, i32 0, align 4
; CHECK-NEXT:    [[S1]] = call ptr @llvm.stacksave()
; CHECK-NEXT:    [[TMP4:%.*]] = alloca i64, align 8
; CHECK-NEXT:    br label [[COMMON_RET:%.*]]
; CHECK:       5:
; CHECK-NEXT:    [[S2]] = call ptr @llvm.stacksave()
; CHECK-NEXT:    [[TMP6:%.*]] = alloca i64, align 8
; CHECK-NEXT:    br label [[COMMON_RET]]
;
  br i1 %0, label %5, label %2

common.ret:                                       ; preds = %5, %2
  %merge = phi ptr [ %s1, %2 ], [ %s2, %5 ]
  call void @llvm.stackrestore(ptr %merge)
  ret i64 0

2:                                                ; preds = %1
  %3 = alloca i32, i32 0, align 4
  %s1 = call ptr @llvm.stacksave()
  %4 = alloca i64, align 8
  br label %common.ret

5:                                                ; preds = %1
  %s2 = call ptr @llvm.stacksave()
  %6 = alloca i64, align 8
  br label %common.ret
}

declare ptr @llvm.stacksave()
declare void @llvm.stackrestore(ptr)

