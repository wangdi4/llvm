; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt %s -S -passes=simplifycfg | FileCheck %s

define double @gamma_pow(double %value, double %gamma) {
;
; CHECK:  define double @gamma_pow(double [[VALUE0:%.*]], double [[GAMMA0:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP0:%.*]] = fcmp fast olt double [[VALUE0]], 0.000000e+00
; CHECK-NEXT:    br i1 [[CMP0]], label [[COND_END0:%.*]], label [[COND_FALSE0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  cond.false:
; CHECK-NEXT:    [[TMP0:%.*]] = call fast double @llvm.pow.f64(double [[VALUE0]], double [[GAMMA0]])
; CHECK-NEXT:    br label [[COND_END0]]
; CHECK-EMPTY:
; CHECK-NEXT:  cond.end:
; CHECK-NEXT:    [[COND0:%.*]] = phi fast double [ [[TMP0]], [[COND_FALSE0]] ], [ [[VALUE0]], [[ENTRY0:%.*]] ]
; CHECK-NEXT:    ret double [[COND0]]
; CHECK-NEXT:  }
;
entry:
  %cmp = fcmp fast olt double %value, 0.000000e+00
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %0 = call fast double @llvm.pow.f64(double %value, double %gamma)
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi fast double [ %0, %cond.false ], [ %value, %entry ]
  ret double %cond
}

define double @_Z9gamma_powdd(double %value, double %gamma) {
;
; CHECK:  define double @_Z9gamma_powdd(double [[VALUE0:%.*]], double [[GAMMA0:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VALUE_ADDR0:%.*]] = alloca double, align 8
; CHECK-NEXT:    [[GAMMA_ADDR0:%.*]] = alloca double, align 8
; CHECK-NEXT:    store double [[VALUE0]], ptr [[VALUE_ADDR0]], align 8
; CHECK-NEXT:    store double [[GAMMA0]], ptr [[GAMMA_ADDR0]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load double, ptr [[VALUE_ADDR0]], align 8
; CHECK-NEXT:    [[CMP0:%.*]] = fcmp fast olt double [[TMP0]], 0.000000e+00
; CHECK-NEXT:    br i1 [[CMP0]], label [[COND_TRUE0:%.*]], label [[COND_FALSE0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  cond.true:
; CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr [[VALUE_ADDR0]], align 8
; CHECK-NEXT:    br label [[COND_END0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  cond.false:
; CHECK-NEXT:    [[TMP2:%.*]] = load double, ptr [[VALUE_ADDR0]], align 8
; CHECK-NEXT:    [[TMP3:%.*]] = load double, ptr [[GAMMA_ADDR0]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = call fast double @llvm.pow.f64(double [[TMP2]], double [[TMP3]])
; CHECK-NEXT:    br label [[COND_END0]]
; CHECK-EMPTY:
; CHECK-NEXT:  cond.end:
; CHECK-NEXT:    [[COND0:%.*]] = phi fast double [ [[TMP1]], [[COND_TRUE0]] ], [ [[TMP4]], [[COND_FALSE0]] ]
; CHECK-NEXT:    ret double [[COND0]]
; CHECK-NEXT:  }
;
entry:
  %value.addr = alloca double
  %gamma.addr = alloca double
  store double %value, ptr %value.addr
  store double %gamma, ptr %gamma.addr
  %0 = load double, ptr %value.addr
  %cmp = fcmp fast olt double %0, 0.000000e+00
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load double, ptr %value.addr
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load double, ptr %value.addr
  %3 = load double, ptr %gamma.addr
  %4 = call fast double @llvm.pow.f64(double %2, double %3)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi fast double [ %1, %cond.true ], [ %4, %cond.false ]
  ret double %cond
}

declare double @llvm.pow.f64(double, double) #3
attributes #3 = { nounwind readnone speculatable willreturn }
