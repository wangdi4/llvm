; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S | FileCheck %s

%0 = type { ptr, ptr }
%1 = type { ptr }
%2 = type { ptr, ptr }

define void @eggs(i1 %arg, i1 %arg16, ptr %arg17, ptr %arg18, ptr %arg19) {
; CHECK-LABEL: @eggs(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br i1 [[ARG:%.*]], label [[BB20:%.*]], label [[BB21:%.*]]
; CHECK:       bb20:
; CHECK-NEXT:    call void @wombat()
; CHECK-NEXT:    unreachable
; CHECK:       bb21:
<<<<<<< HEAD
; CHECK-NEXT:    [[I:%.*]] = icmp eq %0* [[ARG17:%.*]], null
; INTEL_CUSTOMIZATION
; D109054 is preventing DCE of control flow. We would like to see removal of
; the branch and related conditional computation.
; CHECK-NEXT:    call void @hoge()
; CHECK-NEXT:    [[I27:%.*]] = getelementptr inbounds %0, %0* [[ARG19:%.*]], i64 0, i32 0
; end INTEL_CUSTOMIZATION
; CHECK-NEXT:    [[I28:%.*]] = load %1*, %1** [[I27]], align 8
; CHECK-NEXT:    call void @pluto.1(%1* [[I28]])
=======
; CHECK-NEXT:    [[I:%.*]] = icmp eq ptr [[ARG17:%.*]], null
; CHECK-NEXT:    [[TMP0:%.*]] = xor i1 [[I]], true
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])
; CHECK-NEXT:    call void @hoge()
; CHECK-NEXT:    [[TMP1:%.*]] = xor i1 [[ARG16:%.*]], true
; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP1]])
; CHECK-NEXT:    [[I28:%.*]] = load ptr, ptr [[ARG19:%.*]], align 8
; CHECK-NEXT:    call void @pluto.1(ptr [[I28]])
>>>>>>> 8979ae42769e529b0f6fce3268492ffb49bd54b9
; CHECK-NEXT:    call void @pluto()
; CHECK-NEXT:    ret void
;
bb:
  br i1 %arg, label %bb20, label %bb21

bb20:                                             ; preds = %bb
  call void @wombat()
  br label %bb24

bb21:                                             ; preds = %bb
  %i = icmp eq ptr %arg17, null
  br i1 %i, label %bb24, label %bb22

bb22:                                             ; preds = %bb21
  call void @hoge()
  br i1 %arg16, label %bb24, label %bb23

bb23:                                             ; preds = %bb22
  br label %bb24

bb24:                                             ; preds = %bb23, %bb22, %bb21, %bb20
  %i25 = phi i1 [ false, %bb21 ], [ false, %bb20 ], [ false, %bb23 ], [ false, %bb22 ]
  %i26 = phi ptr [ null, %bb21 ], [ null, %bb20 ], [ %arg19, %bb23 ], [ null, %bb22 ]
  %i28 = load ptr, ptr %i26, align 8
  call void @pluto.1(ptr %i28)
  br i1 %i25, label %bb30, label %bb29

bb29:                                             ; preds = %bb24
  call void @pluto()
  ret void

bb30:                                             ; preds = %bb24
  call void @spam()
  ret void
}

; INTEL_CUSTOMIZATION
; The "if.else" block is UB because of the null address (in the phi).
; The branch in land.lhs.true, and related computation should be removed.
; After D109054, an assume is inserted which prevents dead code removal. This
; has a knock-on effect on codesize heuristics and causes indvars to insert a
; phi and perform LSR on the dead code.

; CHECK-LABEL: loop_with_ub
; CHECK-NOT: xor i1 %cmp3
; CHECK-NOT: llvm.assume
define dso_local void @loop_with_ub(i32* %b, i32** %a) local_unnamed_addr #99 {
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc
  ret void

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds i32, i32* %b, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %1 = and i32 %0, 3
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %for.body.if.else_crit_edge, label %land.lhs.true

for.body.if.else_crit_edge:                       ; preds = %for.body
  %arrayidx7.phi.trans.insert = getelementptr inbounds i32*, i32** %a, i64 %indvars.iv
  %.pre = load i32*, i32** %arrayidx7.phi.trans.insert, align 8
  br label %if.else

land.lhs.true:                                    ; preds = %for.body
  %arrayidx2 = getelementptr inbounds i32*, i32** %a, i64 %indvars.iv
  %2 = load i32*, i32** %arrayidx2, align 8
  %cmp3.not = icmp eq i32* %2, null
  br i1 %cmp3.not, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i32 6, i32* %2, align 4
  br label %for.inc

if.else:                                          ; preds = %for.body.if.else_crit_edge, %land.lhs.true
  %3 = phi i32* [ %.pre, %for.body.if.else_crit_edge ], [ null, %land.lhs.true ]
  store i32 666, i32* %3, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.then, %if.else
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 256
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !llvm.loop !99
}

!99 = !{!"llvm.loop.mustprogress"}

attributes #99 = { mustprogress nofree norecurse nosync nounwind uwtable }
; end INTEL_CUSTOMIZATION

declare void @wombat()
declare void @pluto()
declare void @spam()
declare void @hoge()
declare void @pluto.1(ptr)
