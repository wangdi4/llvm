; NOTE: Assertions have been autogenerated by utils/update_test_checks.py ;INTEL
; RUN: opt -passes=simplifycfg -simplifycfg-require-and-preserve-domtree=1 -S %s | FileCheck --match-full-lines %s

; The branch in %cont has !annotation metadata. Make sure generated AND
; has !annotation metadata.

define i32 @test_preserve_and(ptr %a, ptr %b, ptr %c, ptr %d) {
; CHECK-LABEL: @test_preserve_and( ;INTEL
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[A:%.*]], [[B:%.*]], !annotation !0
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[C:%.*]], [[D:%.*]], !annotation !0
; CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[C_1]], i1 [[C_2]], i1 false, !annotation !0
; CHECK-NEXT:    br i1 [[OR_COND]], label [[CONT1:%.*]], label [[TRAP:%.*]], !annotation !0
; CHECK:       trap: ;INTEL
; CHECK-NEXT:    call void @fn1()
; CHECK-NEXT:    unreachable
; CHECK:       cont1: ;INTEL
; CHECK-NEXT:    call void @fn2()
; CHECK-NEXT:    ret i32 0
;
entry:
  %c.1 = icmp ult ptr %a, %b, !annotation !0
  br i1 %c.1, label %cont, label %trap, !annotation !0

cont:                                             ; preds = %entry
  %c.2 = icmp uge ptr %c, %d, !annotation !0
  br i1 %c.2, label %cont1, label %trap, !annotation !0

trap:                                             ; preds = %cont, %entry
  call void @fn1()
  unreachable

cont1:                                            ; preds = %cont
  call void @fn2()
  ret i32 0
}

; INTEL_CUSTOMIZATION
; xmain is not simplifying xors in simplifycfg. This is OK as IC will take
; care of it.
; end INTEL_CUSTOMIZATION

; The branch in %cont has !annotation metadata. Make sure generated OR
; has !annotation metadata.
define i32 @test_preserve_or(ptr %a, ptr %b, ptr %c, ptr %d) {
; CHECK-LABEL: @test_preserve_or( ;INTEL
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[A:%.*]], [[B:%.*]], !annotation !0 ;INTEL
; CHECK-NEXT:    [[C_1_NOT:%.*]] = xor i1 [[C_1]], true, !annotation !0 ;INTEL
; CHECK-NEXT:    [[C_1_NOT1:%.*]] = xor i1 [[C_1_NOT]], true, !annotation !0 ;INTEL
; CHECK-NEXT:    [[C_2:%.*]] = icmp uge ptr [[C:%.*]], [[D:%.*]], !annotation !0
; CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[C_1_NOT1]], i1 true, i1 [[C_2]], !annotation !0 ;INTEL
; CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT1:%.*]], !annotation !0
; CHECK:       trap: ;INTEL
; CHECK-NEXT:    call void @fn1()
; CHECK-NEXT:    unreachable
; CHECK:       cont1: ;INTEL
; CHECK-NEXT:    call void @fn2()
; CHECK-NEXT:    ret i32 0
;
entry:
  %c.1 = icmp ult ptr %a, %b, !annotation !0
  br i1 %c.1, label %cont, label %trap, !annotation !0

cont:                                             ; preds = %entry
  %c.2 = icmp uge ptr %c, %d, !annotation !0
  br i1 %c.2, label %trap, label %cont1, !annotation !0

trap:                                             ; preds = %cont, %entry
  call void @fn1()
  unreachable

cont1:                                            ; preds = %cont
  call void @fn2()
  ret i32 0
}

; The branch in %cont has !annotation metadata. Make sure generated negation
; and OR have !annotation metadata.
define i32 @test_preserve_or_not(ptr %a, ptr %b, ptr %c, ptr %d) {
; CHECK-LABEL: @test_preserve_or_not( ;INTEL
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[A:%.*]], [[B:%.*]], !annotation !0
; CHECK-NEXT:    [[C_2:%.*]] = xor i1 [[C_1]], true
; CHECK-NEXT:    [[C_2_NOT:%.*]] = xor i1 [[C_2]], true, !annotation !0
; CHECK-NEXT:    [[C_2_NOT1:%.*]] = xor i1 [[C_2_NOT]], true, !annotation !0 ;INTEL
; CHECK-NEXT:    [[C_3:%.*]] = icmp uge ptr [[C:%.*]], [[D:%.*]], !annotation !0
; CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[C_2_NOT1]], i1 true, i1 [[C_3]], !annotation !0 ;INTEL
; CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT1:%.*]], !annotation !0
; CHECK:       trap: ;INTEL
; CHECK-NEXT:    call void @fn1()
; CHECK-NEXT:    unreachable
; CHECK:       cont1: ;INTEL
; CHECK-NEXT:    call void @fn2()
; CHECK-NEXT:    ret i32 0
;
entry:
  %c.1 = icmp ult ptr %a, %b, !annotation !0
  %c.2 = xor i1 %c.1, true
  br i1 %c.2, label %cont, label %trap, !annotation !0

cont:                                             ; preds = %entry
  %c.3 = icmp uge ptr %c, %d, !annotation !0
  br i1 %c.3, label %trap, label %cont1, !annotation !0

trap:                                             ; preds = %cont, %entry
  call void @fn1()
  unreachable

cont1:                                            ; preds = %cont
  call void @fn2()
  ret i32 0
}


; The branch in %cont has no !annotation metadata. Make sure generated negation
; and OR do not have !annotation metadata.
define i32 @test_or_not_no_annotation(ptr %a, ptr %b, ptr %c, ptr %d) {
; CHECK-LABEL: @test_or_not_no_annotation( ;INTEL
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C_1:%.*]] = icmp ult ptr [[A:%.*]], [[B:%.*]], !annotation !0
; CHECK-NEXT:    [[C_2:%.*]] = xor i1 [[C_1]], true
; CHECK-NEXT:    [[C_2_NOT:%.*]] = xor i1 [[C_2]], true
; CHECK-NEXT:    [[C_2_NOT1:%.*]] = xor i1 [[C_2_NOT]], true ;INTEL
; CHECK-NEXT:    [[C_3:%.*]] = icmp uge ptr [[C:%.*]], [[D:%.*]], !annotation !0
; CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[C_2_NOT1]], i1 true, i1 [[C_3]] ;INTEL
; CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT1:%.*]], !annotation !0
; CHECK:       trap: ;INTEL
; CHECK-NEXT:    call void @fn1()
; CHECK-NEXT:    unreachable
; CHECK:       cont1: ;INTEL
; CHECK-NEXT:    call void @fn2()
; CHECK-NEXT:    ret i32 0
;
entry:
  %c.1 = icmp ult ptr %a, %b, !annotation !0
  %c.2 = xor i1 %c.1, true
  br i1 %c.2, label %cont, label %trap, !annotation !0

cont:                                             ; preds = %entry
  %c.3 = icmp uge ptr %c, %d, !annotation !0
  br i1 %c.3, label %trap, label %cont1

trap:                                             ; preds = %cont, %entry
  call void @fn1()
  unreachable

cont1:                                            ; preds = %cont
  call void @fn2()
  ret i32 0
}

declare void @fn1()
declare void @fn2()

!0 = !{!"foo"}
