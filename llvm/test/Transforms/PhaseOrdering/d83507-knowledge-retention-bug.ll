; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; INTEL_CUSTOMIZATION
; RUN: opt -O1                   -enable-knowledge-retention -S < %s  | FileCheck %s --check-prefixes=OLDPM
; RUN: opt -passes='default<O1>' -enable-knowledge-retention -S < %s  | FileCheck %s --check-prefixes=NEWPM
; end INTEL_CUSTOMIZATION

%0 = type { %0* }

define %0* @f1() local_unnamed_addr {
; INTEL_CUSTOMIZATION
; update_test_checks is using hardcoded block names, which are different due
; slightly different code in JumpThreading.

; OLDPM-LABEL: @f1(
; OLDPM-NEXT:  bb6:
; OLDPM-NEXT:    ret %0* undef
;
; NEWPM-LABEL: @f1(
; NEWPM-NEXT:  bb:
; NEWPM-NEXT:    br label [[BB3:%.*]]
; NEWPM:       bb3:
; NEWPM-NEXT:    [[I1:%.*]] = phi %0* [ [[I5:%.*]], [[BB3]] ], [ undef, [[BB:%.*]] ]
; NEWPM-NEXT:    call void @llvm.assume(i1 true) [ "nonnull"(%0* [[I1]]) ]
; NEWPM-NEXT:    [[I4:%.*]] = getelementptr inbounds [[TMP0:%.*]], %0* [[I1]], i64 0, i32 0
; NEWPM-NEXT:    [[I5]] = load %0*, %0** [[I4]], align 8
; NEWPM-NEXT:    [[I2:%.*]] = icmp eq %0* [[I5]], null
; NEWPM-NEXT:    br i1 [[I2]], label [[BB6:%.*]], label [[BB3]]
; NEWPM:       bb6:
; NEWPM-NEXT:    ret %0* undef
;
; end INTEL_CUSTOMIZATION
bb:
  br label %bb1

bb1:
  %i = phi %0* [ undef, %bb ], [ %i5, %bb3 ]
  %i2 = icmp eq %0* %i, null
  br i1 %i2, label %bb6, label %bb3

bb3:
  call void @llvm.assume(i1 true) [ "nonnull"(%0* %i) ]
  %i4 = getelementptr inbounds %0, %0* %i, i64 0, i32 0
  %i5 = load %0*, %0** %i4, align 8
  br label %bb1

bb6:
  ret %0* undef
}

declare void @llvm.assume(i1)
