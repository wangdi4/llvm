; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=cleanup-fakeloads -S < %s | FileCheck %s
; RUN: opt -passes=tbaa-prop -S < %s | FileCheck %s

; This test checks that TbaaMDPropagation and CleanupFakeLoads
; passes do not analyze unreachable code.
; For the reference see CMPLRLLVM-7142 and https://reviews.llvm.org/D69865

define void @test(i1 %arg) {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[ARG:%.*]], label [[IF_THEN:%.*]], label [[RET_BB:%.*]]
; CHECK:       unreachable.bb:
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr inbounds i8, i8* [[GEP]], i64 1, !intel-tbaa !0
; CHECK-NEXT:    [[TMP0:%.*]] = call i8* @llvm.intel.fakeload.p0i8(i8* [[GEP]], metadata !0)
; CHECK-NEXT:    [[TMP1:%.*]] = call i8* @llvm.intel.fakeload.p0i8(i8* [[TMP1]], metadata !0)
; CHECK-NEXT:    br i1 [[ARG]], label [[IF_THEN]], label [[RET_BB]]
; CHECK:       if.then:
; CHECK-NEXT:    br label [[RET_BB]]
; CHECK:       ret.bb:
; CHECK-NEXT:    ret void
;
entry:
  br i1 %arg, label %if.then, label %ret.bb

unreachable.bb:                                   ; No predecessors!
  ; This is a broken but unreachable code.
  ; Passes should tolerate this by not analyzing unreachable blocks.
  %gep = getelementptr inbounds i8, i8* %gep, i64 1, !intel-tbaa !0
  %0 = call i8* @llvm.intel.fakeload.p0i8(i8* %gep, metadata !0)
  %1 = call i8* @llvm.intel.fakeload.p0i8(i8* %1, metadata !0)
  br i1 %arg, label %if.then, label %ret.bb

if.then:                                          ; preds = %unreachable.bb, %entry
  br label %ret.bb

ret.bb:                                           ; preds = %if.then, %unreachable.bb, %entry
  ret void
}

declare i8* @llvm.intel.fakeload.p0i8(i8*, metadata)

!0 = !{!1, !1, i64 0}
!1 = !{!"unspecified pointer", !2, i64 0}
!2 = !{!"omnipotent char", !3, i64 0}
!3 = !{!"Simple C++ TBAA"}
