; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; "-match-full-lines" is needed so that any additional metadata would cause a fail.
; RUN: opt -S -tbaa-prop < %s | FileCheck %s --match-full-lines

%struct.Outer = type { %struct.Inner, %struct.Inner }
%struct.Inner = type { [10 x i32] }

; Test !intel-tbaa metadata combining and propagation.
define i32 @test_merge(%struct.Outer* %o) {
; CHECK-LABEL: define i32 @test_merge(%struct.Outer* %o) {
; CHECK-NEXT:    [[INNER2:%.*]] = getelementptr inbounds [[STRUCT_OUTER:%.*]], %struct.Outer* [[O:%.*]], i32 0, i32 1, !intel-tbaa !0
; CHECK-NEXT:    [[INNER2_ARRAY:%.*]] = getelementptr inbounds [[STRUCT_INNER:%.*]], %struct.Inner* [[INNER2]], i32 0, i32 0, !intel-tbaa !7
; CHECK-NEXT:    [[INNER2_ARRAY_ELEM:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[INNER2_ARRAY]], i32 0, i32 7, !intel-tbaa !8
; CHECK-NEXT:    [[LD:%.*]] = load i32, i32* [[INNER2_ARRAY_ELEM]], align 4, !tbaa !9
; CHECK-NEXT:    ret i32 [[LD]]
;
  %inner2 = getelementptr inbounds %struct.Outer, %struct.Outer* %o, i32 0, i32 1, !intel-tbaa !7
  %inner2.array = getelementptr inbounds %struct.Inner, %struct.Inner* %inner2, i32 0, i32 0, !intel-tbaa !8
  %inner2.array.elem = getelementptr inbounds [10 x i32], [10 x i32]* %inner2.array, i32 0, i32 7, !intel-tbaa !9
  %ld = load i32, i32* %inner2.array.elem, !tbaa !10
  ret i32 %ld
}

; Test merging of the GEPs with missing !intel-tbaa annotation in the middle of
; the GEPs chain.
define i32 @test_no_merge(%struct.Outer* %o) {
; CHECK-LABEL: define i32 @test_no_merge(%struct.Outer* %o) {
; CHECK-NEXT:    [[INNER1:%.*]] = getelementptr inbounds [[STRUCT_OUTER:%.*]], %struct.Outer* [[O:%.*]], i32 0, i32 0, !intel-tbaa !10
; CHECK-NEXT:    [[INNER1_ARRAY:%.*]] = getelementptr inbounds [[STRUCT_INNER:%.*]], %struct.Inner* [[INNER1]], i32 0, i32 0
; CHECK-NEXT:    [[INNER1_ARRAY_ELEM:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[INNER1_ARRAY]], i32 0, i32 7, !intel-tbaa !8
; CHECK-NEXT:    [[LD:%.*]] = load i32, i32* [[INNER1_ARRAY_ELEM]], align 4, !tbaa !8
; CHECK-NEXT:    ret i32 [[LD]]
;
  %inner1 = getelementptr inbounds %struct.Outer, %struct.Outer* %o, i32 0, i32 0, !intel-tbaa !6
  %inner1.array = getelementptr inbounds %struct.Inner, %struct.Inner* %inner1, i32 0, i32 0
  %inner1.array.elem = getelementptr inbounds [10 x i32], [10 x i32]* %inner1.array, i32 0, i32 7, !intel-tbaa !9
  %ld = load i32, i32* %inner1.array.elem, !tbaa !10
  ret i32 %ld
}

; Test that no !intel-tbaa metadata gets propagated if the load does not have
; !tbaa attached.
define i32 @test_no_propagation(%struct.Outer* %o) {
; CHECK-LABEL: define i32 @test_no_propagation(%struct.Outer* %o) {
; CHECK-NEXT:    [[INNER1:%.*]] = getelementptr inbounds [[STRUCT_OUTER:%.*]], %struct.Outer* [[O:%.*]], i32 0, i32 0, !intel-tbaa !10
; CHECK-NEXT:    [[INNER1_ARRAY:%.*]] = getelementptr inbounds [[STRUCT_INNER:%.*]], %struct.Inner* [[INNER1]], i32 0, i32 0, !intel-tbaa !7
; CHECK-NEXT:    [[INNER1_ARRAY_ELEM:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[INNER1_ARRAY]], i32 0, i32 7, !intel-tbaa !8
; CHECK-NEXT:    [[LD:%.*]] = load i32, i32* [[INNER1_ARRAY_ELEM]], align 4
; CHECK-NEXT:    ret i32 [[LD]]
;
  %inner1 = getelementptr inbounds %struct.Outer, %struct.Outer* %o, i32 0, i32 0, !intel-tbaa !6
  %inner1.array = getelementptr inbounds %struct.Inner, %struct.Inner* %inner1, i32 0, i32 0, !intel-tbaa !8
  %inner1.array.elem = getelementptr inbounds [10 x i32], [10 x i32]* %inner1.array, i32 0, i32 7, !intel-tbaa !9
  ; TODO: create some recursive type instead of the char* pointer such that
  ; !tbaa annotation was a proper sub-path of the !intel-tbaa annotation on the
  ; GEP. Is it even possible?
  %ld = load i32, i32* %inner1.array.elem
  ret i32 %ld
}

; Verify that !intel-tbaa propagation happens only via the pointer operand of
; the store.
define void @test_ptr_store([10 x i32]* %array, i32** %ptr) {
; CHECK-LABEL: define void @test_ptr_store([10 x i32]* %array, i32** %ptr) {
; CHECK-NEXT:    [[ARRAY_ELEM:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[ARRAY:%.*]], i32 0, i32 7, !intel-tbaa !8
; CHECK-NEXT:    store i32* [[ARRAY_ELEM]], i32** [[PTR:%.*]], !tbaa !11
; CHECK-NEXT:    ret void
;
  %array.elem = getelementptr inbounds [10 x i32], [10 x i32]* %array, i32 0, i32 7, !intel-tbaa !9
  store i32* %array.elem, i32** %ptr, !tbaa !1
  ret void
}

; Verify that load's !tbaa metadata is not changed to a less precise one.
define i32 @test_less_precise(%struct.Inner* %inner) {
; CHECK-LABEL: define i32 @test_less_precise(%struct.Inner* %inner) {
; CHECK-NEXT:    [[INNER_ARRAY:%.*]] = getelementptr inbounds [[STRUCT_INNER:%.*]], %struct.Inner* [[INNER:%.*]], i32 0, i32 0, !intel-tbaa !7
; CHECK-NEXT:    [[INNER_ARRAY_ELEM:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[INNER_ARRAY]], i32 0, i32 7, !intel-tbaa !8
; CHECK-NEXT:    [[LD:%.*]] = load i32, i32* [[INNER_ARRAY_ELEM]], align 4, !intel-tbaa !9
; CHECK-NEXT:    ret i32 [[LD]]
;
  %inner.array = getelementptr inbounds %struct.Inner, %struct.Inner* %inner, i32 0, i32 0, !intel-tbaa !8
  %inner.array.elem = getelementptr inbounds [10 x i32], [10 x i32]* %inner.array, i32 0, i32 7, !intel-tbaa !9
  %ld = load i32, i32* %inner.array.elem, !intel-tbaa !11
  ret i32 %ld
}

define i32* @test_fakeload(%struct.Outer* %o) {
; CHECK-LABEL: define i32* @test_fakeload(%struct.Outer* %o) {
; CHECK-NEXT:    [[INNER2:%.*]] = getelementptr inbounds [[STRUCT_OUTER:%.*]], %struct.Outer* [[O:%.*]], i32 0, i32 1, !intel-tbaa !0
; CHECK-NEXT:    [[INNER2_ARRAY:%.*]] = getelementptr inbounds [[STRUCT_INNER:%.*]], %struct.Inner* [[INNER2]], i32 0, i32 0, !intel-tbaa !7
; CHECK-NEXT:    [[INNER2_ARRAY_ELEM:%.*]] = getelementptr inbounds [10 x i32], [10 x i32]* [[INNER2_ARRAY]], i32 0, i32 7, !intel-tbaa !8
; CHECK-NEXT:    [[FAKE:%.*]] = tail call i32* @llvm.intel.fakeload.p0i32(i32* [[INNER2_ARRAY_ELEM]], metadata !9)
; CHECK-NEXT:    ret i32* [[FAKE]]
;
  %inner2 = getelementptr inbounds %struct.Outer, %struct.Outer* %o, i32 0, i32 1, !intel-tbaa !7
  %inner2.array = getelementptr inbounds %struct.Inner, %struct.Inner* %inner2, i32 0, i32 0, !intel-tbaa !8
  %inner2.array.elem = getelementptr inbounds [10 x i32], [10 x i32]* %inner2.array, i32 0, i32 7, !intel-tbaa !9
  %fake = tail call i32* @llvm.intel.fakeload.p0i32(i32 *%inner2.array.elem, metadata !9)
  ret i32* %fake
}

declare i32* @llvm.intel.fakeload.p0i32(i32*, metadata)

; CHECK: !0 = !{!1, !2, i64 40}
; CHECK: !1 = !{!"struct@typeinfo name for Outer", !2, i64 0, !2, i64 40}
; CHECK: !2 = !{!"struct@typeinfo name for Inner", !3, i64 0}
; CHECK: !3 = !{!"array@typeinfo name for int [10]", !4, i64 0}
; CHECK: !4 = !{!"int", !5, i64 0}
; CHECK: !5 = !{!"omnipotent char", !6, i64 0}
; CHECK: !6 = !{!"Simple C++ TBAA"}
; CHECK: !7 = !{!2, !3, i64 0}
; CHECK: !8 = !{!3, !4, i64 0}
; CHECK: !9 = !{!1, !4, i64 40}
; CHECK: !10 = !{!1, !2, i64 0}
; CHECK: !11 = !{!12, !12, i64 0, i64 0}
; CHECK: !12 = !{!"omnipotent char", !6}

!0 = !{!"Simple C++ TBAA"}
!1 = !{!"omnipotent char", !0, i64 0}
!2 = !{!"int", !1, i64 0}
!3 = !{!"array@typeinfo name for int [10]", !2, i64 0}
!4 = !{!"struct@typeinfo name for Inner", !3, i64 0}
!5 = !{!"struct@typeinfo name for Outer", !4, i64 0, !4, i64 40}

!6 = !{!5, !4, i64 0}  ; Outer::Inner1
!7 = !{!5, !4, i64 40} ; Outer::Inner2
!8 = !{!4, !3, i64 0}  ; Inner::array
!9 = !{!3, !2, i64 0}  ; array::element

!10 = !{!2, !2, i64 0}  ; int* access
!11 = !{!5, !2, i64 40} ; Outer::Inner2::array::element
