; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -opaque-pointers -tbaa-prop -S %s | FileCheck %s

; Various cases where the fakeload has non-conforming TBAA data and should not
; be propagated to the load.

define void @nonscalar(ptr %p) {
; CHECK-LABEL: @nonscalar(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[P:%.*]], align 8, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    ret void
;
; The TBAA MD for struct should be removed after the fakeload is removed.

; !0 has a non-scalar access type.
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !0)
  %2 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}


define void @indirectnonscalar(ptr %p) {
; Same as above, but some recursion is needed to tested whether !10's access
; type is a scalar or not.
; CHECK-LABEL: @indirectnonscalar(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[P:%.*]], align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    ret void
;
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !10)
  %2 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}

define void @typemismatch(ptr %p) {
; Loads of 2 different types.
; CHECK-LABEL: @typemismatch(
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P:%.*]], align 8, !tbaa [[TBAA4:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    ret void
;
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !11)
  %2 = load ptr, ptr %1, align 8, !tbaa !6
  %3 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}

define void @scalar(ptr %p) {
; Propagation is OK.
; CHECK-LABEL: @scalar(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[P:%.*]], align 8, !tbaa [[TBAA6:![0-9]+]]
; CHECK-NEXT:    ret void
;
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !11)
  %2 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare ptr @llvm.intel.fakeload.p0(ptr, metadata) #4

attributes #0 = { nounwind }
attributes #1 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { inaccessiblememonly nofree nosync nounwind willreturn }
attributes #3 = { argmemonly nofree nosync nounwind willreturn }
attributes #4 = { nounwind readnone speculatable }

; CHECK-NOT: arrayofstruct
; CHECK-NOT: strofaos
; CHECK-DAG: [[TBAA_PTR:![0-9]+]]{{.*}}pointer
; CHECK-DAG: [[TBAA_INT:![0-9]+]]{{.*}}int
; CHECK-DAG: [[TBAA_STRUCT:![0-9]+]]{{.*}}okstruct
; CHECK-DAG: [[TBAA0]] = !{[[TBAA_INT]], [[TBAA_INT]]
; CHECK-DAG: [[TBAA4]] = !{[[TBAA_PTR]], [[TBAA_PTR]]
; CHECK-DAG: [[TBAA6]] = !{[[TBAA_STRUCT]], [[TBAA_INT]]

!0 = !{!1, !1, i64 0}
!1 = !{!"okstruct", !2, i64 0, !2, i64 4}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C++ TBAA"}
!5 = !{!"pointer@char", !3, i64 0}
!6 = !{!5, !5, i64 0}
!7 = !{!2, !2, i64 0}
!8 = !{!"arrayofstruct", !1, i64 0}
!9 = !{!"strofaos", !8, i64 0}
!10 = !{!9, !8, i64 0}
!11 = !{!1, !2, i64 0}
