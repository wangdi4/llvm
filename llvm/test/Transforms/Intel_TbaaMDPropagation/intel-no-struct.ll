; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes="tbaa-prop" -S %s | FileCheck %s

; Various cases where the fakeload has non-conforming TBAA data and should not
; be propagated to the load.
; "non-conforming" means that the access type is not a scalar. intel-tbaa MD
; tracks pointee types, which can be structs or arrays. LLVM tbaa MD tracks
; loads and stores with scalar result types.

define void @nonscalar(ptr %p) {
; CHECK-LABEL: @nonscalar(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[P:%.*]], align 8, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    ret void
;
; The TBAA MD for struct should be removed after the fakeload is removed.

; !0 has a non-scalar access type.
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !0)
  %2 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}


define void @indirectnonscalar(ptr %p) {
; Same as above, but some recursion is needed to tested whether !10's access
; type is a scalar or not.
; CHECK-LABEL: @indirectnonscalar(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[P:%.*]], align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    ret void
;
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !10)
  %2 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}

define void @typemismatch(ptr %p) {
; Loads of 2 different types.
; CHECK-LABEL: @typemismatch(
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P:%.*]], align 8, !tbaa [[TBAA4:![0-9]+]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[P]], align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    ret void
;
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !11)
  %2 = load ptr, ptr %1, align 8, !tbaa !6
  %3 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}

; GEP and fakeload, both with 2 different non-scalar access types.
define void @badgep(ptr %arg) {
; CHECK-LABEL: @badgep(
; CHECK-NEXT:    [[TMP:%.*]] = getelementptr inbounds i32, ptr [[ARG:%.*]], i64 1, !intel-tbaa [[TBAA6:![0-9]+]]
; CHECK-NEXT:    ret void
;
  %tmp = getelementptr inbounds i32, ptr %arg, i64 1, !intel-tbaa !12
  %tmp2 = call ptr @llvm.intel.fakeload.p0(ptr %tmp, metadata !0)
;  %ld = load i32, ptr %tmp2, align 8, !tbaa !11
  ret void
}

define void @scalar(ptr %p) {
; Propagation is OK.
; CHECK-LABEL: @scalar(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[P:%.*]], align 8, !tbaa [[TBAA8:![0-9]+]]
; CHECK-NEXT:    ret void
;
  %1 = call ptr @llvm.intel.fakeload.p0(ptr %p, metadata !11)
  %2 = load i32, ptr %1, align 8, !tbaa !7
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare ptr @llvm.intel.fakeload.p0(ptr, metadata) #4

attributes #0 = { nounwind }
attributes #1 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { inaccessiblememonly nofree nosync nounwind willreturn }
attributes #3 = { argmemonly nofree nosync nounwind willreturn }
attributes #4 = { nounwind readnone speculatable }

; update_test_checks will remove these lines, need to re-copy them after.
; CHECK-NOT: arrayofstruct
; CHECK-NOT: strofaos

; CHECK-DAG: [[TBAA0]] = !{[[TBAA_INT:![0-9]+]], [[TBAA_INT]]
; CHECK-DAG: [[TBAA_INT]]{{.*}}int
; CHECK-DAG: [[TBAA4]] = !{[[TBAA_PTR:![0-9]+]], [[TBAA_PTR]]
; CHECK-DAG: [[TBAA_PTR]]{{.*}}pointer
; CHECK-DAG: [[TBAA6]] = !{[[TBAA_STRUCT_S1:!7]], [[TBAA_STRUCT_S1]]
; CHECK-DAG: [[TBAA_STRUCT_S1]]{{.*}}s1

!0 = !{!1, !1, i64 0}
!1 = !{!"okstruct", !2, i64 0, !2, i64 4}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C++ TBAA"}
!5 = !{!"pointer@char", !3, i64 0}
!6 = !{!5, !5, i64 0}
!7 = !{!2, !2, i64 0}
!8 = !{!"arrayofstruct", !1, i64 0}
!9 = !{!"strofaos", !8, i64 0}
!10 = !{!9, !8, i64 0}
!11 = !{!1, !2, i64 0}
!12 = !{!13, !13, i64 0}
!13 = !{!"s1", !2, i64 4, !2, i64 8, !2, i64 12}
