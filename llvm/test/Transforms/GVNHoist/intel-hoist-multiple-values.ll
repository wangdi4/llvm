; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2

; RUN: opt -S -passes=gvn-hoist < %s | FileCheck %s

; Check that all 3 fragments are hoisted to entry and merged into one
define float @foo(float %a, float %b, i1 %c1, i1 %c2) {
; CHECK-LABEL: define float @foo
; CHECK-SAME: (float [[A:%.*]], float [[B:%.*]], i1 [[C1:%.*]], i1 [[C2:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[D:%.*]] = fsub float [[B]], [[A]]
; CHECK-NEXT:    [[E:%.*]] = fadd float [[D]], [[A]]
; CHECK-NEXT:    [[F:%.*]] = fdiv float [[E]], [[A]]
; CHECK-NEXT:    [[G:%.*]] = fmul float [[F]], [[A]]
; CHECK-NEXT:    br i1 [[C1]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[BB1_1:%.*]]
; CHECK:       bb1.1:
; CHECK-NEXT:    ret float [[G]]
; CHECK:       bb2:
; CHECK-NEXT:    ret float [[G]]
; CHECK:       default:
; CHECK-NEXT:    unreachable
;
entry:
  br i1 %c1, label %bb1, label %bb2

bb1:
  %d = fsub float %b, %a
  %e = fadd float %d, %a
  %f = fdiv float %e, %a
  %g = fmul float %f, %a
  br label %bb1.1

bb1.1:
  %d1 = fsub float %b, %a
  %e1 = fadd float %d1, %a
  %f1 = fdiv float %e1, %a
  %g1 = fmul float %f1, %a
  ret float %g1

bb2:
  %h = fsub float %b, %a
  %i = fadd float %h, %a
  %j = fdiv float %i, %a
  %k = fmul float %j, %a
  ret float %k

default:
  unreachable
}

@c1 = global i1 true
@c2 = global i1 true
@c3 = global i1 true
@c4 = global i1 true
@c5 = global i1 true

declare void @f(float) readonly nounwind willreturn

; Currently we can't handle more distant instructions with the same VN due to
; the limit on number of BBs to visit.
define float @deep(float %a, float %b) {
; CHECK-LABEL: define float @deep
; CHECK-SAME: (float [[A:%.*]], float [[B:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C1_LOAD:%.*]] = load i1, ptr @c1, align 1
; CHECK-NEXT:    [[D1_1:%.*]] = fsub float [[B]], [[A]]
; CHECK-NEXT:    br i1 [[C1_LOAD]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[C2_LOAD:%.*]] = load i1, ptr @c2, align 1
; CHECK-NEXT:    br i1 [[C2_LOAD]], label [[BB1_1:%.*]], label [[BB1_1_IF:%.*]]
; CHECK:       bb1.1:
; CHECK-NEXT:    call void @f(float [[D1_1]])
; CHECK-NEXT:    br label [[BB1_1_IF]]
; CHECK:       bb1.1.if:
; CHECK-NEXT:    [[C3_LOAD:%.*]] = load i1, ptr @c3, align 1
; CHECK-NEXT:    br i1 [[C3_LOAD]], label [[BB1_2:%.*]], label [[BB1_2_IF:%.*]]
; CHECK:       bb1.2:
; CHECK-NEXT:    call void @f(float [[D1_1]])
; CHECK-NEXT:    br label [[BB1_2_IF]]
; CHECK:       bb1.2.if:
; CHECK-NEXT:    [[C4_LOAD:%.*]] = load i1, ptr @c4, align 1
; CHECK-NEXT:    br i1 [[C4_LOAD]], label [[BB1_3:%.*]], label [[BB1_3_IF:%.*]]
; CHECK:       bb1.3:
; CHECK-NEXT:    call void @f(float [[D1_1]])
; CHECK-NEXT:    br label [[BB1_3_IF]]
; CHECK:       bb1.3.if:
; CHECK-NEXT:    [[C5_LOAD:%.*]] = load i1, ptr @c5, align 1
; CHECK-NEXT:    br i1 [[C5_LOAD]], label [[BB1_4:%.*]], label [[BB1_RET:%.*]]
; CHECK:       bb1.4:
; CHECK-NEXT:    call void @f(float [[D1_1]])
; CHECK-NEXT:    br label [[BB1_RET]]
; CHECK:       bb1.ret:
; CHECK-NEXT:    ret float [[D1_1]]
; CHECK:       bb2:
; CHECK-NEXT:    ret float [[D1_1]]
;
entry:
  %c1.load = load i1, ptr @c1
  br i1 %c1.load, label %bb1, label %bb2

bb1:
  %c2.load = load i1, ptr @c2
  %d1.1 = fsub float %b, %a
  br i1 %c2.load, label %bb1.1, label %bb1.1.if

bb1.1:
  call void @f(float %d1.1)
  br label %bb1.1.if

bb1.1.if:
  %c3.load = load i1, ptr @c3
  %d1.2 = fsub float %b, %a
  br i1 %c3.load, label %bb1.2, label %bb1.2.if

bb1.2:
  call void @f(float %d1.2)
  br label %bb1.2.if

bb1.2.if:
  %c4.load = load i1, ptr @c4
  %d1.3 = fsub float %b, %a
  br i1 %c4.load, label %bb1.3, label %bb1.3.if

bb1.3:
  call void @f(float %d1.3)
  br label %bb1.3.if

bb1.3.if:
  %c5.load = load i1, ptr @c5
  %d1.4 = fsub float %b, %a
  br i1 %c5.load, label %bb1.4, label %bb1.ret

bb1.4:
  call void @f(float %d1.4)
  br label %bb1.ret

bb1.ret:
  %d1.5 = fsub float %b, %a
  ret float %d1.5

bb2:
  %d2 = fsub float %b, %a
  ret float %d2
}
