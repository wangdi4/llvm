; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -enable-new-pm=0 -opaque-pointers -fold-loads-to-gather -S -mtriple=x86_64-- -mcpu=skylake | FileCheck %s --check-prefixes=CHECK

define <4 x i32> @gather_i32_i32(<4 x i32> %offset, i32 addrspace(1)* %base) nounwind {
; CHECK-LABEL: @gather_i32_i32(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr ptr addrspace(1), ptr addrspace(1) [[BASE:%.*]], <4 x i32> [[OFFSET:%.*]]
; CHECK-NEXT:    [[I3:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p1(<4 x ptr addrspace(1)> [[TMP1]], i32 4, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> undef)
; CHECK-NEXT:    ret <4 x i32> [[I3]]
;
  %E0 = extractelement <4 x i32> %offset, i64 0
  %GEP0 = getelementptr inbounds i32, i32 addrspace(1)* %base, i32 %E0
  %V0 = load i32, i32 addrspace(1)* %GEP0, align 4
  %I0 = insertelement <4 x i32> undef, i32 %V0, i32 0
  %E1 = extractelement <4 x i32> %offset, i64 1
  %GEP1 = getelementptr inbounds i32, i32 addrspace(1)* %base, i32 %E1
  %V1 = load i32, i32 addrspace(1)* %GEP1, align 4
  %I1 = insertelement <4 x i32> %I0, i32 %V1, i32 1
  %E2 = extractelement <4 x i32> %offset, i64 2
  %GEP2 = getelementptr inbounds i32, i32 addrspace(1)* %base, i32 %E2
  %V2 = load i32, i32 addrspace(1)* %GEP2, align 4
  %I2 = insertelement <4 x i32> %I1, i32 %V2, i32 2
  %E3 = extractelement <4 x i32> %offset, i64 3
  %GEP3 = getelementptr inbounds i32, i32 addrspace(1)* %base, i32 %E3
  %V3 = load i32, i32 addrspace(1)* %GEP3, align 4
  %I3 = insertelement <4 x i32> %I2, i32 %V3, i32 3
  ret <4 x i32> %I3
}

define <4 x i32> @gather_i32_ext_i32(<4 x i32> %offset, i32 addrspace(1)* %base) nounwind {
; CHECK-LABEL: @gather_i32_ext_i32(
; CHECK-NEXT:    [[TMP1:%.*]] = zext <4 x i32> [[OFFSET:%.*]] to <4 x i64>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr ptr addrspace(1), ptr addrspace(1) [[BASE:%.*]], <4 x i64> [[TMP1]]
; CHECK-NEXT:    [[I3:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p1(<4 x ptr addrspace(1)> [[TMP2]], i32 4, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> undef)
; CHECK-NEXT:    ret <4 x i32> [[I3]]
;
  %E0 = extractelement <4 x i32> %offset, i64 0
  %Ext0 = zext i32 %E0 to i64
  %GEP0 = getelementptr inbounds i32, i32 addrspace(1)* %base, i64 %Ext0
  %V0 = load i32, i32 addrspace(1)* %GEP0, align 4
  %I0 = insertelement <4 x i32> undef, i32 %V0, i32 0
  %E1 = extractelement <4 x i32> %offset, i64 1
  %Ext1 = zext i32 %E1 to i64
  %GEP1 = getelementptr inbounds i32, i32 addrspace(1)* %base, i64 %Ext1
  %V1 = load i32, i32 addrspace(1)* %GEP1, align 4
  %I1 = insertelement <4 x i32> %I0, i32 %V1, i32 1
  %E2 = extractelement <4 x i32> %offset, i64 2
  %Ext2 = zext i32 %E2 to i64
  %GEP2 = getelementptr inbounds i32, i32 addrspace(1)* %base, i64 %Ext2
  %V2 = load i32, i32 addrspace(1)* %GEP2, align 4
  %I2 = insertelement <4 x i32> %I1, i32 %V2, i32 2
  %E3 = extractelement <4 x i32> %offset, i64 3
  %Ext3 = zext i32 %E3 to i64
  %GEP3 = getelementptr inbounds i32, i32 addrspace(1)* %base, i64 %Ext3
  %V3 = load i32, i32 addrspace(1)* %GEP3, align 4
  %I3 = insertelement <4 x i32> %I2, i32 %V3, i32 3
  ret <4 x i32> %I3
}

define <4 x double> @gather_i64_f64(<4 x i64> %offset, double addrspace(1)* %base) nounwind {
; CHECK-LABEL: @gather_i64_f64(
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr ptr addrspace(1), ptr addrspace(1) [[BASE:%.*]], <4 x i64> [[OFFSET:%.*]]
; CHECK-NEXT:    [[I3:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p1(<4 x ptr addrspace(1)> [[TMP1]], i32 4, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
; CHECK-NEXT:    ret <4 x double> [[I3]]
;
  %E0 = extractelement <4 x i64> %offset, i64 0
  %GEP0 = getelementptr inbounds double, double addrspace(1)* %base, i64 %E0
  %V0 = load double, double addrspace(1)* %GEP0, align 4
  %I0 = insertelement <4 x double> undef, double %V0, i32 0
  %E1 = extractelement <4 x i64> %offset, i64 1
  %GEP1 = getelementptr inbounds double, double addrspace(1)* %base, i64 %E1
  %V1 = load double, double addrspace(1)* %GEP1, align 4
  %I1 = insertelement <4 x double> %I0, double %V1, i32 1
  %E2 = extractelement <4 x i64> %offset, i64 2
  %GEP2 = getelementptr inbounds double, double addrspace(1)* %base, i64 %E2
  %V2 = load double, double addrspace(1)* %GEP2, align 4
  %I2 = insertelement <4 x double> %I1, double %V2, i32 2
  %E3 = extractelement <4 x i64> %offset, i64 3
  %GEP3 = getelementptr inbounds double, double addrspace(1)* %base, i64 %E3
  %V3 = load double, double addrspace(1)* %GEP3, align 4
  %I3 = insertelement <4 x double> %I2, double %V3, i32 3
  ret <4 x double> %I3
}

define <4 x double> @gather_i32_ext_f64(<4 x i32> %offset, double addrspace(1)* %base) nounwind {
; CHECK-LABEL: @gather_i32_ext_f64(
; CHECK-NEXT:    [[TMP1:%.*]] = zext <4 x i32> [[OFFSET:%.*]] to <4 x i64>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr ptr addrspace(1), ptr addrspace(1) [[BASE:%.*]], <4 x i64> [[TMP1]]
; CHECK-NEXT:    [[I3:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p1(<4 x ptr addrspace(1)> [[TMP2]], i32 4, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
; CHECK-NEXT:    ret <4 x double> [[I3]]
;
  %E0 = extractelement <4 x i32> %offset, i64 0
  %Ext0 = zext i32 %E0 to i64
  %GEP0 = getelementptr inbounds double, double addrspace(1)* %base, i64 %Ext0
  %V0 = load double, double addrspace(1)* %GEP0, align 4
  %I0 = insertelement <4 x double> undef, double %V0, i32 0
  %E1 = extractelement <4 x i32> %offset, i64 1
  %Ext1 = zext i32 %E1 to i64
  %GEP1 = getelementptr inbounds double, double addrspace(1)* %base, i64 %Ext1
  %V1 = load double, double addrspace(1)* %GEP1, align 4
  %I1 = insertelement <4 x double> %I0, double %V1, i32 1
  %E2 = extractelement <4 x i32> %offset, i64 2
  %Ext2 = zext i32 %E2 to i64
  %GEP2 = getelementptr inbounds double, double addrspace(1)* %base, i64 %Ext2
  %V2 = load double, double addrspace(1)* %GEP2, align 4
  %I2 = insertelement <4 x double> %I1, double %V2, i32 2
  %E3 = extractelement <4 x i32> %offset, i64 3
  %Ext3 = zext i32 %E3 to i64
  %GEP3 = getelementptr inbounds double, double addrspace(1)* %base, i64 %Ext3
  %V3 = load double, double addrspace(1)* %GEP3, align 4
  %I3 = insertelement <4 x double> %I2, double %V3, i32 3
  ret <4 x double> %I3
}
