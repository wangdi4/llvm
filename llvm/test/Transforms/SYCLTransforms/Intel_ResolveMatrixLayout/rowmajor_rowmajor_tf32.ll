; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -opaque-pointers=0 -passes=sycl-kernel-resolve-matrix-layout -S %s | FileCheck %s
; RUN: opt -opaque-pointers=0 -passes=sycl-kernel-resolve-matrix-layout -enable-debugify -S %s 2>&1 | FileCheck %s -check-prefix=DEBUGIFY

define void @test_load_store_same_addrspace_tf32(float addrspace(4)* %ptrB, i64 %strideB, i32* %dst) {
; CHECK-LABEL: @test_load_store_same_addrspace_tf32(
; CHECK-NEXT:  enrty:
; CHECK-NEXT:    [[B:%.*]] = call <256 x float> @llvm.experimental.matrix.load.v256f32.p4f32(float addrspace(4)* [[PTRB:%.*]], i64 [[STRIDEB:%.*]], i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.unnecessary")
; CHECK-NEXT:    call void @llvm.experimental.matrix.store.v256f32.p4f32(<256 x float> [[B]], float addrspace(4)* [[PTRB]], i64 [[STRIDEB]], i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.unnecessary")
; CHECK-NEXT:    ret void
;
enrty:
  %B = call <256 x float> @llvm.experimental.matrix.load.v256f32.p4f32(float addrspace(4)* %ptrB, i64 %strideB, i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.unnecessary")
  call void @llvm.experimental.matrix.store.v256f32.p4f32(<256 x float> %B, float addrspace(4)* %ptrB, i64 %strideB, i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.unnecessary")
  ret void
}

define void @test_load_store_same_addrspace_tf32_with_use(float addrspace(4)* %ptrB, i64 %strideB, i32* %dst) {
; CHECK-LABEL: @test_load_store_same_addrspace_tf32_with_use(
; CHECK-NEXT:  enrty:
; CHECK-NEXT:    [[B:%.*]] = call <256 x float> @llvm.experimental.matrix.load.v256f32.p4f32(float addrspace(4)* [[PTRB:%.*]], i64 [[STRIDEB:%.*]], i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.b")
; CHECK-NEXT:    call void @llvm.experimental.matrix.store.v256f32.p4f32(<256 x float> [[B]], float addrspace(4)* [[PTRB]], i64 [[STRIDEB]], i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.b")
; CHECK-NEXT:    ret void
;
enrty:
  %B = call <256 x float> @llvm.experimental.matrix.load.v256f32.p4f32(float addrspace(4)* %ptrB, i64 %strideB, i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.b")
  call void @llvm.experimental.matrix.store.v256f32.p4f32(<256 x float> %B, float addrspace(4)* %ptrB, i64 %strideB, i1 false, i32 16, i32 16, metadata !"matrix.rowmajor", metadata !"matrix.rowmajor", metadata !"scope.subgroup", metadata !"matrix.use.b")
  ret void
}

declare <128 x float> @llvm.experimental.matrix.load.v128f32.p4f32(float addrspace(4)*, i64, i1, i32, i32, metadata, metadata, metadata, metadata)
declare <256 x float> @llvm.experimental.matrix.load.v256f32.p4f32(float addrspace(4)*, i64, i1, i32, i32, metadata, metadata, metadata, metadata)
declare <128 x float> @llvm.experimental.matrix.mad.v128f32.v128f32.v256f32(<128 x float>, metadata, <256 x float>, metadata, <128 x float>, metadata, i32, i32, i32, metadata)
declare void @llvm.experimental.matrix.store.v256f32.p4f32(<256 x float>, float addrspace(4)*, i64, i1, i32, i32, metadata, metadata, metadata, metadata)

; DEBUGIFY: PASS
