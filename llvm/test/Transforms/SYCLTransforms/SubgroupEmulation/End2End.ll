; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -dpcpp-vect-info=%p/../Inputs/VectInfo64.gen -passes='dpcpp-kernel-sg-emu-builtin,dpcpp-kernel-sg-emu-barrier-propagate,dpcpp-kernel-sg-emu-barrier-simplify,dpcpp-kernel-sg-emu-value-widen,dpcpp-kernel-sg-emu-loop-construct' -S %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

define void @test(i32 %a) !kernel_has_sub_groups !1 !sg_emu_size !2 {
; CHECK-LABEL: @test(
; CHECK-NEXT:  sg.loop.exclude:
; CHECK-NEXT:    [[SG_LID_PTR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[SG_LOOP_SRC_PTR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    br label [[ENTRY:%.*]]
; CHECK:       entry:
; CHECK-NEXT:    store i32 0, i32* [[SG_LID_PTR]], align 4
; CHECK-NEXT:    store i32 1, i32* [[SG_LOOP_SRC_PTR]], align 4
; CHECK-NEXT:    br label [[SG_DUMMY_SPLIT_3:%.*]]
; CHECK:       sg.dummy.split.3:
; CHECK-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <16 x i32> poison, i32 [[A:%.*]], i32 0
; CHECK-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <16 x i32> [[DOTSPLATINSERT]], <16 x i32> poison, <16 x i32> zeroinitializer
; CHECK-NEXT:    [[SG_SIZE_:%.*]] = call i32 @_Z18get_sub_group_sizev()
; CHECK-NEXT:    [[TMP0:%.*]] = zext i32 [[SG_SIZE_]] to i64
; CHECK-NEXT:    [[DOTSPLATINSERT1:%.*]] = insertelement <16 x i64> poison, i64 [[TMP0]], i32 0
; CHECK-NEXT:    [[DOTSPLAT2:%.*]] = shufflevector <16 x i64> [[DOTSPLATINSERT1]], <16 x i64> poison, <16 x i32> zeroinitializer
; CHECK-NEXT:    [[MASK_I1:%.*]] = icmp ult <16 x i64> <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, [[DOTSPLAT2]]
; CHECK-NEXT:    [[MASK_I32:%.*]] = sext <16 x i1> [[MASK_I1]] to <16 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = call <16 x i32> @_Z13sub_group_allDv16_iDv16_j(<16 x i32> [[DOTSPLAT]], <16 x i32> [[MASK_I32]])
; CHECK-NEXT:    br label [[SG_DUMMY_BB_:%.*]]
; CHECK:       sg.dummy.bb.:
; CHECK-NEXT:    store i32 0, i32* [[SG_LID_PTR]], align 4
; CHECK-NEXT:    store i32 0, i32* [[SG_LOOP_SRC_PTR]], align 4
; CHECK-NEXT:    br label [[SG_DUMMY_SPLIT_:%.*]]
; CHECK:       sg.dummy.split.:
; CHECK-NEXT:    ret void
;
entry:
  %call = tail call i32 @_Z13sub_group_alli(i32 %a)
  ret void
}

declare i32 @_Z13sub_group_alli(i32)

!sycl.kernels = !{!0}

!0 = !{void (i32)* @test}
!1 = !{i1 true}
!2 = !{i32 16}
