; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=sycl-kernel-wgloop-creator %s -S | FileCheck %s
; RUN: opt -passes=sycl-kernel-wgloop-creator %s -S -enable-debugify -disable-output 2>&1 | FileCheck -check-prefix=DEBUGIFY %s

; Check that peeling loop is generated for masked kernel.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn writeonly
define dso_local void @test(ptr addrspace(1) nocapture noundef writeonly %dst) local_unnamed_addr #0 !kernel_arg_addr_space !2 !kernel_arg_access_qual !3 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !5 !kernel_arg_name !6 !kernel_arg_host_accessible !7 !kernel_arg_pipe_depth !8 !kernel_arg_pipe_io !5 !kernel_arg_buffer_location !5 !no_barrier_path !9 !kernel_has_sub_groups !9 !vectorized_kernel !10 !vectorized_masked_kernel !11 !vectorized_width !2 !arg_type_null_val !17 {
; CHECK-LABEL: @test(
; CHECK:       entry:
; CHECK-NEXT:    [[EARLY_EXIT_CALL:%.*]] = call [7 x i64] @WG.boundaries.test(ptr addrspace(1) [[DST:%.*]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = trunc i64 [[TMP1]] to i1
; CHECK-NEXT:    br i1 [[TMP2]], label [[WGLOOPSENTRY:%.*]], label [[EXIT:%.*]]
; CHECK:       WGLoopsEntry:
; CHECK-NEXT:    [[INIT_GID_DIM0:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 1
; CHECK-NEXT:    [[LOOP_SIZE_DIM0:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 2
; CHECK-NEXT:    [[MAX_GID_DIM0:%.*]] = add i64 [[INIT_GID_DIM0]], [[LOOP_SIZE_DIM0]]
; CHECK-NEXT:    [[INIT_GID_DIM1:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 3
; CHECK-NEXT:    [[LOOP_SIZE_DIM1:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 4
; CHECK-NEXT:    [[MAX_GID_DIM1:%.*]] = add i64 [[INIT_GID_DIM1]], [[LOOP_SIZE_DIM1]]
; CHECK-NEXT:    [[INIT_GID_DIM2:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 5
; CHECK-NEXT:    [[LOOP_SIZE_DIM2:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 6
; CHECK-NEXT:    [[MAX_GID_DIM2:%.*]] = add i64 [[INIT_GID_DIM2]], [[LOOP_SIZE_DIM2]]
; CHECK-NEXT:    [[VECTOR_SIZE:%.*]] = ashr i64 [[LOOP_SIZE_DIM0]], 4
; CHECK-NEXT:    [[NUM_VECTOR_WI:%.*]] = shl i64 [[VECTOR_SIZE]], 4
; CHECK-NEXT:    [[MAX_VECTOR_GID:%.*]] = add i64 [[NUM_VECTOR_WI]], [[INIT_GID_DIM0]]
; CHECK-NEXT:    [[SCALAR_SIZE:%.*]] = sub i64 [[LOOP_SIZE_DIM0]], [[NUM_VECTOR_WI]]
; CHECK-NEXT:    br label [[VECT_IF:%.*]]
; CHECK:       vect_if:
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i64 [[VECTOR_SIZE]], 0
; CHECK-NEXT:    br i1 [[TMP3]], label [[DIM_2_VECTOR_PRE_HEAD:%.*]], label [[MASKED_VECT_IF:%.*]]
; CHECK:       dim_2_vector_pre_head:
; CHECK-NEXT:    br label [[DIM_1_VECTOR_PRE_HEAD:%.*]]
; CHECK:       dim_1_vector_pre_head:
; CHECK-NEXT:    [[DIM_2_VECTOR_IND_VAR:%.*]] = phi i64 [ [[INIT_GID_DIM2]], [[DIM_2_VECTOR_PRE_HEAD]] ], [ [[DIM_2_VECTOR_INC_IND_VAR:%.*]], [[DIM_1_VECTOR_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[DIM_0_VECTOR_PRE_HEAD:%.*]]
; CHECK:       dim_0_vector_pre_head:
; CHECK-NEXT:    [[DIM_1_VECTOR_IND_VAR:%.*]] = phi i64 [ [[INIT_GID_DIM1]], [[DIM_1_VECTOR_PRE_HEAD]] ], [ [[DIM_1_VECTOR_INC_IND_VAR:%.*]], [[DIM_0_VECTOR_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[ENTRYVECTOR_FUNC:%.*]]
; CHECK:       entryvector_func:
; CHECK-NEXT:    [[DIM_0_VECTOR_IND_VAR:%.*]] = phi i64 [ [[INIT_GID_DIM0]], [[DIM_0_VECTOR_PRE_HEAD]] ], [ [[DIM_0_VECTOR_INC_IND_VAR:%.*]], [[ENTRYVECTOR_FUNC]] ]
; CHECK-NEXT:    [[SEXTVECTOR_FUNC:%.*]] = shl i64 [[DIM_0_VECTOR_IND_VAR]], 32
; CHECK-NEXT:    [[DOTEXTRACT_0_VECTOR_FUNC:%.*]] = ashr exact i64 [[SEXTVECTOR_FUNC]], 32
; CHECK-NEXT:    [[SCALAR_GEPVECTOR_FUNC:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[DST]], i64 [[DOTEXTRACT_0_VECTOR_FUNC]]
; CHECK-NEXT:    store <16 x i32> zeroinitializer, ptr addrspace(1) [[SCALAR_GEPVECTOR_FUNC]], align 4
; CHECK-NEXT:    [[DIM_0_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_0_VECTOR_IND_VAR]], 16
; CHECK-NEXT:    [[DIM_0_VECTOR_CMP_TO_MAX:%.*]] = icmp sge i64 [[DIM_0_VECTOR_INC_IND_VAR]], [[MAX_VECTOR_GID]]
; CHECK-NEXT:    br i1 [[DIM_0_VECTOR_CMP_TO_MAX]], label [[DIM_0_VECTOR_EXIT]], label [[ENTRYVECTOR_FUNC]]
; CHECK:       dim_0_vector_exit:
; CHECK-NEXT:    [[DIM_1_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_1_VECTOR_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_1_VECTOR_CMP_TO_MAX:%.*]] = icmp sge i64 [[DIM_1_VECTOR_INC_IND_VAR]], [[MAX_GID_DIM1]]
; CHECK-NEXT:    br i1 [[DIM_1_VECTOR_CMP_TO_MAX]], label [[DIM_1_VECTOR_EXIT]], label [[DIM_0_VECTOR_PRE_HEAD]]
; CHECK:       dim_1_vector_exit:
; CHECK-NEXT:    [[DIM_2_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_2_VECTOR_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_2_VECTOR_CMP_TO_MAX:%.*]] = icmp sge i64 [[DIM_2_VECTOR_INC_IND_VAR]], [[MAX_GID_DIM2]]
; CHECK-NEXT:    br i1 [[DIM_2_VECTOR_CMP_TO_MAX]], label [[DIM_2_VECTOR_EXIT:%.*]], label [[DIM_1_VECTOR_PRE_HEAD]]
; CHECK:       dim_2_vector_exit:
; CHECK-NEXT:    br label [[MASKED_VECT_IF]]
; CHECK:       masked_vect_if:
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i64 [[SCALAR_SIZE]], 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[MASK_GENERATE:%.*]], label [[RET:%.*]]
; CHECK:       mask_generate:
; CHECK-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <16 x i64> poison, i64 [[SCALAR_SIZE]], i64 0
; CHECK-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <16 x i64> [[DOTSPLATINSERT]], <16 x i64> poison, <16 x i32> zeroinitializer
; CHECK-NEXT:    [[MASK_I1:%.*]] = icmp ult <16 x i64> <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, [[DOTSPLAT]]
; CHECK-NEXT:    [[MASK_I32:%.*]] = sext <16 x i1> [[MASK_I1]] to <16 x i32>
; CHECK-NEXT:    br label [[DIM_2_VECTOR_PRE_HEAD11:%.*]]
; CHECK:       dim_2_vector_pre_head11:
; CHECK-NEXT:    br label [[DIM_1_VECTOR_PRE_HEAD6:%.*]]
; CHECK:       dim_1_vector_pre_head6:
; CHECK-NEXT:    [[DIM_2_VECTOR_IND_VAR13:%.*]] = phi i64 [ [[INIT_GID_DIM2]], [[DIM_2_VECTOR_PRE_HEAD11]] ], [ [[DIM_2_VECTOR_INC_IND_VAR14:%.*]], [[DIM_1_VECTOR_EXIT7:%.*]] ]
; CHECK-NEXT:    br label [[DIM_0_VECTOR_PRE_HEAD1:%.*]]
; CHECK:       dim_0_vector_pre_head1:
; CHECK-NEXT:    [[DIM_1_VECTOR_IND_VAR8:%.*]] = phi i64 [ [[INIT_GID_DIM1]], [[DIM_1_VECTOR_PRE_HEAD6]] ], [ [[DIM_1_VECTOR_INC_IND_VAR9:%.*]], [[DIM_0_VECTOR_EXIT2:%.*]] ]
; CHECK-NEXT:    br label [[MASKED_KERNEL_ENTRY:%.*]]
; CHECK:       masked_kernel_entry:
; CHECK-NEXT:    [[DIM_0_VECTOR_IND_VAR3:%.*]] = phi i64 [ [[MAX_VECTOR_GID]], [[DIM_0_VECTOR_PRE_HEAD1]] ], [ [[DIM_0_VECTOR_INC_IND_VAR4:%.*]], [[MASKED_KERNEL_ENTRY]] ]
; CHECK-NEXT:    [[SEXT:%.*]] = shl i64 [[DIM_0_VECTOR_IND_VAR3]], 32
; CHECK-NEXT:    [[DOTEXTRACT_0_:%.*]] = ashr exact i64 [[SEXT]], 32
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne <16 x i32> [[MASK_I32]], zeroinitializer
; CHECK-NEXT:    [[SCALAR_GEP5:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[DST]], i64 [[DOTEXTRACT_0_]]
; CHECK-NEXT:    call void @llvm.masked.store.v16i32.p1(<16 x i32> zeroinitializer, ptr addrspace(1) [[SCALAR_GEP5]], i32 4, <16 x i1> [[TMP6]])
; CHECK-NEXT:    [[DIM_0_VECTOR_INC_IND_VAR4]] = add nuw nsw i64 [[DIM_0_VECTOR_IND_VAR3]], 16
; CHECK-NEXT:    [[DIM_0_VECTOR_CMP_TO_MAX5:%.*]] = icmp sge i64 [[DIM_0_VECTOR_INC_IND_VAR4]], [[MAX_GID_DIM0]]
; CHECK-NEXT:    br i1 [[DIM_0_VECTOR_CMP_TO_MAX5]], label [[DIM_0_VECTOR_EXIT2]], label [[MASKED_KERNEL_ENTRY]], !llvm.loop [[LOOP12:![0-9]+]]
; CHECK:       dim_0_vector_exit2:
; CHECK-NEXT:    [[DIM_1_VECTOR_INC_IND_VAR9]] = add nuw nsw i64 [[DIM_1_VECTOR_IND_VAR8]], 1
; CHECK-NEXT:    [[DIM_1_VECTOR_CMP_TO_MAX10:%.*]] = icmp sge i64 [[DIM_1_VECTOR_INC_IND_VAR9]], [[MAX_GID_DIM1]]
; CHECK-NEXT:    br i1 [[DIM_1_VECTOR_CMP_TO_MAX10]], label [[DIM_1_VECTOR_EXIT7]], label [[DIM_0_VECTOR_PRE_HEAD1]], !llvm.loop [[LOOP14:![0-9]+]]
; CHECK:       dim_1_vector_exit7:
; CHECK-NEXT:    [[DIM_2_VECTOR_INC_IND_VAR14]] = add nuw nsw i64 [[DIM_2_VECTOR_IND_VAR13]], 1
; CHECK-NEXT:    [[DIM_2_VECTOR_CMP_TO_MAX15:%.*]] = icmp sge i64 [[DIM_2_VECTOR_INC_IND_VAR14]], [[MAX_GID_DIM2]]
; CHECK-NEXT:    br i1 [[DIM_2_VECTOR_CMP_TO_MAX15]], label [[DIM_2_VECTOR_EXIT12:%.*]], label [[DIM_1_VECTOR_PRE_HEAD6]], !llvm.loop [[LOOP15:![0-9]+]]
; CHECK:       dim_2_vector_exit12:
; CHECK-NEXT:    br label [[RET]]
; CHECK:       ret:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %call = tail call i64 @_Z13get_global_idj(i32 noundef 0) #3
  %arrayidx = getelementptr inbounds i32, ptr addrspace(1) %dst, i64 %call
  store i32 0, ptr addrspace(1) %arrayidx, align 4, !tbaa !12
  ret void
}

; Function Attrs: convergent mustprogress nofree nounwind readnone willreturn
declare i64 @_Z13get_global_idj(i32 noundef) local_unnamed_addr #1

define [7 x i64] @WG.boundaries.test(ptr addrspace(1) %0) {
entry:
  %1 = call i64 @_Z14get_local_sizej(i32 0)
  %2 = call i64 @get_base_global_id.(i32 0)
  %3 = call i64 @_Z14get_local_sizej(i32 1)
  %4 = call i64 @get_base_global_id.(i32 1)
  %5 = call i64 @_Z14get_local_sizej(i32 2)
  %6 = call i64 @get_base_global_id.(i32 2)
  %7 = insertvalue [7 x i64] undef, i64 %1, 2
  %8 = insertvalue [7 x i64] %7, i64 %2, 1
  %9 = insertvalue [7 x i64] %8, i64 %3, 4
  %10 = insertvalue [7 x i64] %9, i64 %4, 3
  %11 = insertvalue [7 x i64] %10, i64 %5, 6
  %12 = insertvalue [7 x i64] %11, i64 %6, 5
  %13 = insertvalue [7 x i64] %12, i64 1, 0
  ret [7 x i64] %13
}

declare i64 @_Z14get_local_sizej(i32)

declare i64 @get_base_global_id.(i32)

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn writeonly
define dso_local void @_ZGVeN16u_test(ptr addrspace(1) nocapture noundef writeonly %dst) local_unnamed_addr #0 !kernel_arg_addr_space !2 !kernel_arg_access_qual !3 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !5 !kernel_arg_name !6 !kernel_arg_host_accessible !7 !kernel_arg_pipe_depth !8 !kernel_arg_pipe_io !5 !kernel_arg_buffer_location !5 !no_barrier_path !9 !kernel_has_sub_groups !7 !vectorized_width !16 !vectorization_dimension !8 !can_unite_workgroups !7 !scalar_kernel !1 {
entry:
  %call = tail call i64 @_Z13get_global_idj(i32 noundef 0) #3
  %sext = shl i64 %call, 32
  %.extract.0. = ashr exact i64 %sext, 32
  %scalar.gep = getelementptr inbounds i32, ptr addrspace(1) %dst, i64 %.extract.0.
  store <16 x i32> zeroinitializer, ptr addrspace(1) %scalar.gep, align 4
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn writeonly
define dso_local void @_ZGVeM16u_test(ptr addrspace(1) nocapture noundef writeonly %dst, <16 x i32> %mask) local_unnamed_addr #0 !kernel_arg_addr_space !2 !kernel_arg_access_qual !3 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !5 !kernel_arg_name !6 !kernel_arg_host_accessible !7 !kernel_arg_pipe_depth !8 !kernel_arg_pipe_io !5 !kernel_arg_buffer_location !5 !no_barrier_path !9 !kernel_has_sub_groups !7 !vectorized_kernel !10 !vectorized_width !16 !vectorization_dimension !8 !can_unite_workgroups !7 !scalar_kernel !1 {
entry:
  %call = tail call i64 @_Z13get_global_idj(i32 noundef 0) #3
  %sext = shl i64 %call, 32
  %.extract.0. = ashr exact i64 %sext, 32
  %0 = icmp ne <16 x i32> %mask, zeroinitializer
  %scalar.gep5 = getelementptr inbounds i32, ptr addrspace(1) %dst, i64 %.extract.0.
  call void @llvm.masked.store.v16i32.p1(<16 x i32> zeroinitializer, ptr addrspace(1) %scalar.gep5, i32 4, <16 x i1> %0)
  ret void
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn writeonly
declare void @llvm.masked.store.v16i32.p1(<16 x i32>, ptr addrspace(1), i32 immarg, <16 x i1>) #2

attributes #0 = { convergent mustprogress nofree norecurse nounwind willreturn writeonly "vector-variants"="_ZGVeN16u_test,_ZGVeM16u_test" }
attributes #1 = { convergent mustprogress nofree nounwind readnone willreturn }
attributes #2 = { argmemonly nofree nosync nounwind willreturn writeonly }
attributes #3 = { convergent nounwind readnone willreturn }

!opencl.ocl.version = !{!0}
!opencl.spir.version = !{!0}
!sycl.kernels = !{!1}

!0 = !{i32 1, i32 2}
!1 = !{ptr @test}
!2 = !{i32 1}
!3 = !{!"none"}
!4 = !{!"int*"}
!5 = !{!""}
!6 = !{!"dst"}
!7 = !{i1 false}
!8 = !{i32 0}
!9 = !{i1 true}
!10 = !{ptr @_ZGVeN16u_test}
!11 = !{ptr @_ZGVeM16u_test}
!12 = !{!13, !13, i64 0}
!13 = !{!"int", !14, i64 0}
!14 = !{!"omnipotent char", !15, i64 0}
!15 = !{!"Simple C/C++ TBAA"}
!16 = !{i32 16}
!17 = !{ptr addrspace(1) null}

; DEBUGIFY-COUNT-72: WARNING: Instruction with empty DebugLoc in function test
; DEBUGIFY: WARNING: Missing line 1
; DEBUGIFY: WARNING: Missing line 2
; DEBUGIFY: WARNING: Missing line 3
; DEBUGIFY: WARNING: Missing line 4
; DEBUGIFY: WARNING: Missing line 24
; DEBUGIFY: WARNING: Missing variable 1
; DEBUGIFY: WARNING: Missing variable 2
; DEBUGIFY-NOT: WARNING
