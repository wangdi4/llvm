; RUN: opt -passes='sycl-kernel-prepare-args' -S %s -enable-debugify -disable-output 2>&1 | FileCheck  -check-prefix=DEBUGIFY %s
; RUN: opt -passes='sycl-kernel-prepare-args' -S %s | FileCheck %s

; ----------------------------------------------------
; The test IR is generated by the code below
; ----------------------------------------------------
;__kernel void test(__global int *result, __local int *data) {
;    __local int temp[16];
;    __private int ptemp[16];
;    int lid = get_local_id(0);
;    temp[lid] = lid;
;    ptemp[lid] = lid;
;    work_group_barrier(CLK_LOCAL_MEM_FENCE);
;    result[lid] = temp[lid] + data[lid] + ptemp[lid+1];
;}

; Function Attrs: convergent norecurse nounwind
declare dso_local void @__test_before.AddImplicitArgs(ptr addrspace(1) nocapture noundef writeonly align 4, ptr addrspace(3) nocapture noundef readonly align 4)

; Function Attrs: convergent mustprogress nofree nounwind willreturn memory(none)
declare i64 @_Z12get_local_idj(i32 noundef)

; Function Attrs: convergent nounwind
declare void @_Z18work_group_barrierj(i32 noundef)

; Function Attrs: convergent norecurse nounwind memory(readwrite)
declare dso_local void @___ZGVeN16uu_test_before.AddImplicitArgs(ptr addrspace(1) nocapture noundef writeonly align 4, ptr addrspace(3) nocapture noundef readonly align 4)

; Function Attrs: convergent norecurse nounwind
define dso_local void @test(ptr addrspace(1) nocapture noundef writeonly align 4 %result, ptr addrspace(3) nocapture noundef readonly align 4 %data, ptr addrspace(3) noalias %pLocalMemBase, ptr noalias %pWorkDim, ptr noalias %pWGId, [4 x i64] %BaseGlbId, ptr noalias %pSpecialBuf, ptr noalias %RuntimeHandle) !kernel_arg_addr_space !2 !kernel_arg_access_qual !3 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !5 !kernel_arg_name !6 !kernel_arg_host_accessible !7 !kernel_arg_pipe_depth !8 !kernel_arg_pipe_io !5 !kernel_arg_buffer_location !5 !arg_type_null_val !9 !no_barrier_path !10 !kernel_has_sub_groups !10 !kernel_has_global_sync !10 !kernel_execution_length !11 !max_wg_dimensions !12 !local_buffer_size !13 !barrier_buffer_size !13 !private_memory_size !14 {
; CHECK-LABEL: define dso_local void @test(
; CHECK-SAME: ptr noalias [[UNIFORMARGS:%.*]], ptr noalias [[PWGID:%.*]], ptr noalias [[RUNTIMEHANDLE:%.*]])

;; get heap memory address
; CHECK:         [[TMP:%[0-9]+]] = getelementptr ptr, ptr %pWGId, i32 3
; CHECK-NEXT:    [[PHEAPMEM:%.*]] = load ptr, ptr [[TMP]], align 1
;; cmp heap memory pointer with null
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq ptr [[PHEAPMEM]], null
;;;; local argument
; CHECK:         [[TMP1:%.*]] = getelementptr i8, ptr [[UNIFORMARGS]], i32 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr [[TMP1]], align 4
;; select alloca size
; CHECK-NEXT:    [[TMP4:%.*]] = select i1 [[TMP3]], i64 [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP5:%.*]] = alloca i8, i64 [[TMP4]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr [[PHEAPMEM]], i64 0
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP3]], ptr [[TMP5]], ptr [[TMP6]]
; CHECK-NEXT:    [[EXPLICIT_1:%.*]] = addrspacecast ptr [[TMP7]] to ptr addrspace(3)
; CHECK-NEXT:    [[TMP8:%.*]] = add i64 [[TMP2]], 0

;;;; local array
; CHECK:         [[TMP9:%.*]] = select i1 [[TMP3]], i64 [[ARRAY_SIZE:.*]], i64 0
; CHECK-NEXT:    [[TMP10:%.*]] = alloca i8, i64 [[TMP9]], align 128
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr [[PHEAPMEM]], i64 [[TMP8]]
; CHECK-NEXT:    [[TMP12:%.*]] = select i1 [[TMP3]], ptr [[TMP10]], ptr [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = addrspacecast ptr [[TMP12]] to ptr addrspace(3)
; CHECK-NEXT:    [[PLOCALMEMBASE:%.*]] = getelementptr i8, ptr addrspace(3) [[TMP13]], i32 128
; CHECK-NEXT:    [[TMP14:%.*]] = add i64 [[ARRAY_SIZE]], [[TMP8]]

;;;; special buffer
; CHECK:         [[TMP33:%.*]] = select i1 [[TMP3]], i64 [[BARRIERBUFFERSIZE:%.*]], i64 0
; CHECK-NEXT:    [[TMP34:%.*]] = alloca i8, i64 [[TMP33]], align 128
; CHECK-NEXT:    [[TMP35:%.*]] = getelementptr i8, ptr [[PHEAPMEM]], i64 [[TMP14]]
; CHECK-NEXT:    [[PSPECIALBUF:%.*]] = select i1 [[TMP3]], ptr [[TMP34]], ptr [[TMP35]]
;
entry:
  %0 = getelementptr i8, ptr addrspace(3) %pLocalMemBase, i32 0
  %1 = getelementptr { i64, [3 x i64], [3 x i64], [2 x [3 x i64]], [3 x i64], ptr, ptr, [3 x i64], [2 x [3 x i64]], [3 x i64] }, ptr %pWorkDim, i32 0, i32 9, i32 0
  %InternalNumGroups_0 = load i64, ptr %1, align 1
  %2 = getelementptr i64, ptr %pWGId, i32 0
  %GroupID_0 = load i64, ptr %2, align 1
  %3 = add nsw i64 %GroupID_0, 1
  %4 = icmp eq i64 %InternalNumGroups_0, %3
  %5 = zext i1 %4 to i32
  %6 = getelementptr { i64, [3 x i64], [3 x i64], [2 x [3 x i64]], [3 x i64], ptr, ptr, [3 x i64], [2 x [3 x i64]], [3 x i64] }, ptr %pWorkDim, i32 0, i32 8, i32 %5, i32 0
  %InternalLocalSize_0 = load i64, ptr %6, align 1
  br label %SyncBB2

SyncBB2:                                          ; preds = %Dispatch17, %entry
  %LocalId_02223 = phi i64 [ 0, %entry ], [ %7, %Dispatch17 ]
  %pCurrSBIndex.0 = phi i64 [ 0, %entry ], [ %9, %Dispatch17 ]
  %SB_LocalId_Offset14 = add nuw i64 %pCurrSBIndex.0, 0
  %pSB_LocalId15 = getelementptr inbounds i8, ptr %pSpecialBuf, i64 %SB_LocalId_Offset14
  %conv = trunc i64 %LocalId_02223 to i32
  %sext = shl i64 %LocalId_02223, 32
  %idxprom = ashr exact i64 %sext, 32
  %arrayidx = getelementptr inbounds [16 x i32], ptr addrspace(3) %0, i64 0, i64 %idxprom
  store i32 %conv, ptr addrspace(3) %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds [16 x i32], ptr %pSB_LocalId15, i64 0, i64 %idxprom
  store i32 %conv, ptr %arrayidx2, align 4
  %7 = add nuw i64 %LocalId_02223, 1
  %8 = icmp ult i64 %7, %InternalLocalSize_0
  br i1 %8, label %Dispatch17, label %SyncBB1

Dispatch17:                                       ; preds = %SyncBB2
  %9 = add nuw i64 %pCurrSBIndex.0, 64
  br label %SyncBB2

SyncBB1:                                          ; preds = %SyncBB2, %Dispatch
  %LocalId_02125 = phi i64 [ %13, %Dispatch ], [ 0, %SyncBB2 ]
  %pCurrSBIndex.1 = phi i64 [ %15, %Dispatch ], [ 0, %SyncBB2 ]
  %SB_LocalId_Offset = add nuw i64 %pCurrSBIndex.1, 0
  %pSB_LocalId = getelementptr inbounds i8, ptr %pSpecialBuf, i64 %SB_LocalId_Offset
  %sext.copy = shl i64 %LocalId_02125, 32
  %idxprom.copy = ashr exact i64 %sext.copy, 32
  %arrayidx.copy = getelementptr inbounds [16 x i32], ptr addrspace(3) %0, i64 0, i64 %idxprom.copy
  %conv.copy = trunc i64 %LocalId_02125 to i32
  %10 = load i32, ptr addrspace(3) %arrayidx.copy, align 4
  %arrayidx6 = getelementptr inbounds i32, ptr addrspace(3) %data, i64 %idxprom.copy
  %11 = load i32, ptr addrspace(3) %arrayidx6, align 4
  %add = add nsw i32 %11, %10
  %add7 = add nsw i32 %conv.copy, 1
  %idxprom8 = sext i32 %add7 to i64
  %arrayidx9 = getelementptr inbounds [16 x i32], ptr %pSB_LocalId, i64 0, i64 %idxprom8
  %12 = load i32, ptr %arrayidx9, align 4
  %add10 = add nsw i32 %add, %12
  %arrayidx12 = getelementptr inbounds i32, ptr addrspace(1) %result, i64 %idxprom.copy
  store i32 %add10, ptr addrspace(1) %arrayidx12, align 4
  %13 = add nuw i64 %LocalId_02125, 1
  %14 = icmp ult i64 %13, %InternalLocalSize_0
  br i1 %14, label %Dispatch, label %SyncBB0

Dispatch:                                         ; preds = %SyncBB1
  %15 = add nuw i64 %pCurrSBIndex.1, 64
  br label %SyncBB1

SyncBB0:                                          ; preds = %SyncBB1
  %.lcssa26 = phi i64 [ %13, %SyncBB1 ]
  ret void
}

!sycl.kernels = !{!1}

!0 = !{i32 3, i32 0}
!1 = distinct !{ptr @test}
!2 = !{i32 1, i32 3}
!3 = !{!"none", !"none"}
!4 = !{!"int*", !"int*"}
!5 = !{!"", !""}
!6 = !{!"result", !"data"}
!7 = !{i1 false, i1 false}
!8 = !{i32 0, i32 0}
!9 = !{ptr addrspace(1) null, ptr addrspace(3) null}
!10 = !{i1 false}
!11 = !{i32 24}
!12 = !{i32 64}
!13 = !{i32 72}
!14 = !{!15, !15, i64 0}
!15 = !{!"Simple C/C++ TBAA"}

; DEBUGIFY-NOT: WARNING
; DEBUGIFY-COUNT-55: WARNING: Instruction with empty DebugLoc in function {{.*}}
; DEBUGIFY-NOT: WARNING
