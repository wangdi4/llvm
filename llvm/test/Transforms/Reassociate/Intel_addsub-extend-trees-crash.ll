; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes="addsub-reassoc" < %s -S | FileCheck %s
; REQUIRES: asserts

; The code below caused assertion to fire after making attempt
; to extend trees. The pass algorithm iterates over trees inside cluster
; and extends these trees converting leaves that are shared among all the
; trees into their nodes. Expectation is that each tree in the cluster
; should grow by exactly same degree and that is what is being checked
; with the assert statement.
; The problem turned out related to tree size limitation set (64 by default)
; in order to keep compile time reasonable. Since trees in a cluster can
; be different in size once their size becomes close to the limit
; the bigger one grows less then the other(s) when it hits the limit
; during growt attempt.

define hidden i32 @test() unnamed_addr {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ADD8_I94:%.*]] = add i32 undef, undef
; CHECK-NEXT:    [[I:%.*]] = add i32 undef, [[ADD8_I94]]
; CHECK-NEXT:    [[I1:%.*]] = add i32 [[I]], undef
; CHECK-NEXT:    [[I2:%.*]] = add i32 undef, undef
; CHECK-NEXT:    [[I3:%.*]] = add i32 [[I2]], [[I1]]
; CHECK-NEXT:    [[I4:%.*]] = add i32 [[I3]], undef
; CHECK-NEXT:    [[I5:%.*]] = add i32 undef, undef
; CHECK-NEXT:    [[I6:%.*]] = add i32 [[I5]], [[I1]]
; CHECK-NEXT:    [[I7:%.*]] = add i32 [[I6]], [[I4]]
; CHECK-NEXT:    [[I8:%.*]] = add i32 [[I7]], undef
; CHECK-NEXT:    [[I9:%.*]] = shl i32 [[I6]], 1
; CHECK-NEXT:    [[I10:%.*]] = add i32 undef, [[I9]]
; CHECK-NEXT:    [[I11:%.*]] = add i32 [[I10]], [[I4]]
; CHECK-NEXT:    [[I12:%.*]] = add i32 [[I11]], [[I8]]
; CHECK-NEXT:    [[I13:%.*]] = add i32 [[I12]], undef
; CHECK-NEXT:    [[I14:%.*]] = add i32 undef, [[I13]]
; CHECK-NEXT:    [[I15:%.*]] = add i32 [[I14]], undef
; CHECK-NEXT:    [[I16:%.*]] = add i32 undef, [[I15]]
; CHECK-NEXT:    [[I17:%.*]] = add i32 [[I16]], undef
; CHECK-NEXT:    [[I18:%.*]] = add i32 undef, undef
; CHECK-NEXT:    [[I19:%.*]] = add i32 [[I18]], [[I15]]
; CHECK-NEXT:    [[I20:%.*]] = add i32 [[I19]], [[I17]]
; CHECK-NEXT:    [[I21:%.*]] = add i32 [[I20]], undef
; CHECK-NEXT:    [[I22:%.*]] = shl i32 [[I19]], 1
; CHECK-NEXT:    [[I23:%.*]] = add i32 undef, [[I22]]
; CHECK-NEXT:    [[I24:%.*]] = add i32 [[I23]], [[I17]]
; CHECK-NEXT:    [[I25:%.*]] = add i32 undef, [[I24]]
; CHECK-NEXT:    ret i32 [[I25]]
;
entry:
  %add8.i94 = add i32 undef, undef
  %i = add i32 undef, %add8.i94
  %i1 = add i32 %i, undef
  %i2 = add i32 undef, undef
  %i3 = add i32 %i2, %i1
  %i4 = add i32 %i3, undef
  %i5 = add i32 undef, undef
  %i6 = add i32 %i5, %i1
  %i7 = add i32 %i6, %i4
  %i8 = add i32 %i7, undef
  %i9 = shl i32 %i6, 1
  %i10 = add i32 undef, %i9
  %i11 = add i32 %i10, %i4
  %i12 = add i32 %i11, %i8
  %i13 = add i32 %i12, undef
  %i14 = add i32 undef, %i13
  %i15 = add i32 %i14, undef
  %i16 = add i32 undef, %i15
  %i17 = add i32 %i16, undef
  %i18 = add i32 undef, undef
  %i19 = add i32 %i18, %i15
  %i20 = add i32 %i19, %i17
  %i21 = add i32 %i20, undef
  %i22 = shl i32 %i19, 1
  %i23 = add i32 undef, %i22
  %i24 = add i32 %i23, %i17
  %i25 = add i32 undef, %i24
  ret i32 %i25
}
