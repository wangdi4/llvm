; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes="addsub-reassoc" < %s -S | FileCheck %s -check-prefix=CHECK

; RUN: opt -passes="addsub-reassoc" < %s -addsub-reassoc-max-distributed-instructions=0 -S | FileCheck %s -check-prefix=DISTDISABLED
; RUN: opt -passes="addsub-reassoc" < %s -addsub-reassoc-canonicalize-group=false -S | FileCheck %s -check-prefix=NOGROUPCAN
; RUN: opt -passes="addsub-reassoc" < %s -addsub-reassoc-max-distributed-instructions=3 -S | FileCheck %s -check-prefix=MULTIPLE

; Test case to imprint current state of support for expressions that involve applying
; distributivity property while performing reassociation on arithmetic ops.
; The only supported opcode for now in this regard is shift left by a constant
; and is only applied to "+"/"-" expressions.

define void @test0(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) {
; In this test the whole add/sub tree is inside parenthesis (see comment to IR)
; hence no distribution regardless of whether is enabled or disabled.
; CHECK-LABEL: @test0(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CHAIN_0_4:%.*]] = sub i32 [[E:%.*]], [[C:%.*]]
; CHECK-NEXT:    [[CHAIN_0_3:%.*]] = sub i32 [[CHAIN_0_4]], [[B:%.*]]
; CHECK-NEXT:    [[CHAIN_0_2:%.*]] = sub i32 [[CHAIN_0_3]], [[D:%.*]]
; CHECK-NEXT:    [[CHAIN_0_:%.*]] = sub i32 [[CHAIN_0_2]], [[A:%.*]]
; CHECK-NEXT:    [[TRUNK_1_:%.*]] = sub i32 0, [[CHAIN_0_]]
; CHECK-NEXT:    [[I5:%.*]] = shl i32 [[TRUNK_1_]], 16
; CHECK-NEXT:    [[I11:%.*]] = shl i32 [[CHAIN_0_]], 16
; CHECK-NEXT:    ret void
;
; DISTDISABLED-LABEL: @test0(
; DISTDISABLED-NEXT:  entry:
; DISTDISABLED-NEXT:    [[CHAIN_0_4:%.*]] = sub i32 [[E:%.*]], [[C:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_0_3:%.*]] = sub i32 [[CHAIN_0_4]], [[B:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_0_2:%.*]] = sub i32 [[CHAIN_0_3]], [[D:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_0_:%.*]] = sub i32 [[CHAIN_0_2]], [[A:%.*]]
; DISTDISABLED-NEXT:    [[TRUNK_1_:%.*]] = sub i32 0, [[CHAIN_0_]]
; DISTDISABLED-NEXT:    [[I5:%.*]] = shl i32 [[TRUNK_1_]], 16
; DISTDISABLED-NEXT:    [[I11:%.*]] = shl i32 [[CHAIN_0_]], 16
; DISTDISABLED-NEXT:    ret void
;
entry:
; The only difference between these two expressions is sign.
; Applying distributivity actually isn't invloved here.

  %i1 = sub i32 %d, %e
  %i2 = add i32 %i1, %a
  %i3 = add i32 %i2, %b
  %i4 = add i32 %i3, %c
  %i5 = shl i32 %i4, 16        ; ( +d -e +a +b +c) << 16

  %i7 = sub i32 %e, %a
  %i8 = sub i32 %i7, %b
  %i9 = sub i32 %i8, %c
  %i10 = sub i32 %i9, %d
  %i11 = shl i32 %i10, 16      ; ( +e -a -b -c -d) << 16

  ret void
}


define void @test1(i32 %N, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) {
; CHECK-LABEL: @test1(
; In this test add/sub tree starts with "N +" and the rest elements represent
; add/sub of terminals with additional (distributed) left shift op.
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CHAIN_1_:%.*]] = shl i32 [[A:%.*]], 16
; CHECK-NEXT:    [[CHAIN_1_3:%.*]] = shl i32 [[E:%.*]], 16
; CHECK-NEXT:    [[CHAIN_1_5:%.*]] = shl i32 [[B:%.*]], 16
; CHECK-NEXT:    [[CHAIN_1_7:%.*]] = shl i32 [[C:%.*]], 16
; CHECK-NEXT:    [[CHAIN_1_9:%.*]] = shl i32 [[D:%.*]], 16
; CHECK-NEXT:    [[CHAIN_1_10:%.*]] = add i32 [[N:%.*]], [[CHAIN_1_9]]
; CHECK-NEXT:    [[CHAIN_1_8:%.*]] = add i32 [[CHAIN_1_10]], [[CHAIN_1_7]]
; CHECK-NEXT:    [[CHAIN_1_6:%.*]] = add i32 [[CHAIN_1_8]], [[CHAIN_1_5]]
; CHECK-NEXT:    [[CHAIN_1_4:%.*]] = sub i32 [[CHAIN_1_6]], [[CHAIN_1_3]]
; CHECK-NEXT:    [[CHAIN_1_2:%.*]] = add i32 [[CHAIN_1_4]], [[CHAIN_1_]]
; CHECK-NEXT:    ret void
;
; With pull-ins disabled the only add/sub tree that pass does affect is
; one inside the parenthesis (see comment to IR).
; DISTDISABLED-LABEL: @test1(
; DISTDISABLED-NEXT:  entry:
; DISTDISABLED-NEXT:    [[CHAIN_1_4:%.*]] = sub i32 [[E:%.*]], [[C:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_1_3:%.*]] = sub i32 [[CHAIN_1_4]], [[B:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_1_2:%.*]] = sub i32 [[CHAIN_1_3]], [[D:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_1_:%.*]] = sub i32 [[CHAIN_1_2]], [[A:%.*]]
; DISTDISABLED-NEXT:    [[TRUNK_5_:%.*]] = sub i32 0, [[CHAIN_1_]]
; DISTDISABLED-NEXT:    [[I5:%.*]] = shl i32 [[TRUNK_5_]], 16
; DISTDISABLED-NEXT:    [[I6:%.*]] = add i32 [[I5]], [[N:%.*]]
; DISTDISABLED-NEXT:    [[I11:%.*]] = shl i32 [[CHAIN_1_]], 16
; DISTDISABLED-NEXT:    [[I12:%.*]] = sub i32 [[N]], [[I11]]
; DISTDISABLED-NEXT:    ret void
;
entry:
; Similar to test0 but but the expression tree starts
; with either "+" or "-" (instructions %i6 and %i12).
; The left shift is then distributed over the rest part
; of the expression to form an add-sub tree.
; If we disable this feature the only expression inside parenthesis
; is changed.
; These two are equivalent:
;   N + ( +d -e +a +b +c) << 16
;   N - ( +e -a -b -c -d) << 16

  %i1 = sub i32 %d, %e
  %i2 = add i32 %i1, %a
  %i3 = add i32 %i2, %b
  %i4 = add i32 %i3, %c
  %i5 = shl i32 %i4, 16
  %i6 = add i32 %i5, %N

  %i7 = sub i32 %e, %a
  %i8 = sub i32 %i7, %b
  %i9 = sub i32 %i8, %c
  %i10 = sub i32 %i9, %d
  %i11 = shl i32 %i10, 16
  %i12 = sub i32 %N, %i11

  ret void
}

define void @test_mem3(i32* %p, i32 %N, i32 %d, i32 %e) {
; CHECK-LABEL: @test_mem3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; CHECK-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; CHECK-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; CHECK-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; CHECK-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; CHECK-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; CHECK-NEXT:    [[CHAIN_2_:%.*]] = shl i32 [[E:%.*]], 16
; CHECK-NEXT:    [[CHAIN_2_3:%.*]] = shl i32 [[D:%.*]], 16
; CHECK-NEXT:    [[CHAIN_2_6:%.*]] = shl i32 [[A]], 16
; CHECK-NEXT:    [[CHAIN_2_8:%.*]] = shl i32 [[B]], 16
; CHECK-NEXT:    [[CHAIN_2_10:%.*]] = shl i32 [[C]], 16
; Load-related additives go first due to "canonicalization".
; CHECK-NEXT:    [[CHAIN_2_9:%.*]] = add i32 [[CHAIN_2_10]], [[CHAIN_2_8]]
; CHECK-NEXT:    [[CHAIN_2_7:%.*]] = add i32 [[CHAIN_2_9]], [[CHAIN_2_6]]
; CHECK-NEXT:    [[CHAIN_2_5:%.*]] = add i32 [[CHAIN_2_7]], [[N:%.*]]
; CHECK-NEXT:    [[CHAIN_2_4:%.*]] = add i32 [[CHAIN_2_5]], [[CHAIN_2_3]]
; CHECK-NEXT:    [[CHAIN_2_2:%.*]] = sub i32 [[CHAIN_2_4]], [[CHAIN_2_]]
; CHECK-NEXT:    ret void
;
; NOGROUPCAN-LABEL: @test_mem3(
; NOGROUPCAN-NEXT:  entry:
; NOGROUPCAN-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; NOGROUPCAN-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; NOGROUPCAN-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; NOGROUPCAN-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; NOGROUPCAN-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; NOGROUPCAN-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; NOGROUPCAN-NEXT:    [[CHAIN_2_:%.*]] = shl i32 [[A]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_2_3:%.*]] = shl i32 [[E:%.*]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_2_5:%.*]] = shl i32 [[B]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_2_7:%.*]] = shl i32 [[C]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_2_9:%.*]] = shl i32 [[D:%.*]], 16
; With "canonicalization" disabled there is no specific ordering for load-related additives
; NOGROUPCAN-NEXT:    [[CHAIN_2_10:%.*]] = add i32 [[N:%.*]], [[CHAIN_2_9]]
; NOGROUPCAN-NEXT:    [[CHAIN_2_8:%.*]] = add i32 [[CHAIN_2_10]], [[CHAIN_2_7]]
; NOGROUPCAN-NEXT:    [[CHAIN_2_6:%.*]] = add i32 [[CHAIN_2_8]], [[CHAIN_2_5]]
; NOGROUPCAN-NEXT:    [[CHAIN_2_4:%.*]] = sub i32 [[CHAIN_2_6]], [[CHAIN_2_3]]
; NOGROUPCAN-NEXT:    [[CHAIN_2_2:%.*]] = add i32 [[CHAIN_2_4]], [[CHAIN_2_]]
; NOGROUPCAN-NEXT:    ret void
;
entry:
; All {a,b,c,d,e} form a single group with two uses with opposite ops (i.e. +/-)
; N + ( +d -e +a +b +c) << 16
; N - ( +e -a -b -c -d) << 16

; The expresion is same as in test1 but {a,b,c} here are loads.
; Output expression is going to be rearranged so that loads go first.

  %g1 = getelementptr inbounds i32, i32* %p, i32 0
  %a = load i32, i32* %g1, align 4

  %g2 = getelementptr inbounds i32, i32* %p, i32 1
  %b = load i32, i32* %g2, align 4

  %g3 = getelementptr inbounds i32, i32* %p, i32 2
  %c = load i32, i32* %g3, align 4

  %i1 = sub i32 %d, %e
  %i2 = add i32 %i1, %a
  %i3 = add i32 %i2, %b
  %i4 = add i32 %i3, %c
  %i5 = shl i32 %i4, 16
  %i6 = add i32 %i5, %N

  %i7 = sub i32 %e, %a
  %i8 = sub i32 %i7, %b
  %i9 = sub i32 %i8, %c
  %i10 = sub i32 %i9, %d
  %i11 = shl i32 %i10, 16
  %i12 = sub i32 %N, %i11

  ret void
}

define void @test_mem5(i32* %p, i32 %N) {
; CHECK-LABEL: @test_mem5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; CHECK-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; CHECK-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; CHECK-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; CHECK-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; CHECK-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; CHECK-NEXT:    [[G4:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 3
; CHECK-NEXT:    [[D:%.*]] = load i32, i32* [[G4]], align 4
; CHECK-NEXT:    [[G5:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 4
; CHECK-NEXT:    [[E:%.*]] = load i32, i32* [[G5]], align 4
; CHECK-NEXT:    [[CHAIN_3_2:%.*]] = shl i32 [[A]], 16
; CHECK-NEXT:    [[CHAIN_3_4:%.*]] = shl i32 [[B]], 16
; CHECK-NEXT:    [[CHAIN_3_6:%.*]] = shl i32 [[C]], 16
; CHECK-NEXT:    [[CHAIN_3_8:%.*]] = shl i32 [[E]], 16
; CHECK-NEXT:    [[CHAIN_3_10:%.*]] = shl i32 [[D]], 16
; CHECK-NEXT:    [[CHAIN_3_9:%.*]] = sub i32 [[CHAIN_3_10]], [[CHAIN_3_8]]
; CHECK-NEXT:    [[CHAIN_3_7:%.*]] = add i32 [[CHAIN_3_9]], [[CHAIN_3_6]]
; CHECK-NEXT:    [[CHAIN_3_5:%.*]] = add i32 [[CHAIN_3_7]], [[CHAIN_3_4]]
; CHECK-NEXT:    [[CHAIN_3_3:%.*]] = add i32 [[CHAIN_3_5]], [[CHAIN_3_2]]
; CHECK-NEXT:    [[CHAIN_3_:%.*]] = add i32 [[CHAIN_3_3]], [[N:%.*]]
; CHECK-NEXT:    ret void
;
; NOGROUPCAN-LABEL: @test_mem5(
; NOGROUPCAN-NEXT:  entry:
; NOGROUPCAN-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; NOGROUPCAN-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; NOGROUPCAN-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; NOGROUPCAN-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; NOGROUPCAN-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; NOGROUPCAN-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; NOGROUPCAN-NEXT:    [[G4:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 3
; NOGROUPCAN-NEXT:    [[D:%.*]] = load i32, i32* [[G4]], align 4
; NOGROUPCAN-NEXT:    [[G5:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 4
; NOGROUPCAN-NEXT:    [[E:%.*]] = load i32, i32* [[G5]], align 4
; NOGROUPCAN-NEXT:    [[CHAIN_3_:%.*]] = shl i32 [[A]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_3_3:%.*]] = shl i32 [[E]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_3_5:%.*]] = shl i32 [[B]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_3_7:%.*]] = shl i32 [[C]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_3_9:%.*]] = shl i32 [[D]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_3_10:%.*]] = add i32 [[N:%.*]], [[CHAIN_3_9]]
; NOGROUPCAN-NEXT:    [[CHAIN_3_8:%.*]] = add i32 [[CHAIN_3_10]], [[CHAIN_3_7]]
; NOGROUPCAN-NEXT:    [[CHAIN_3_6:%.*]] = add i32 [[CHAIN_3_8]], [[CHAIN_3_5]]
; NOGROUPCAN-NEXT:    [[CHAIN_3_4:%.*]] = sub i32 [[CHAIN_3_6]], [[CHAIN_3_3]]
; NOGROUPCAN-NEXT:    [[CHAIN_3_2:%.*]] = add i32 [[CHAIN_3_4]], [[CHAIN_3_]]
; NOGROUPCAN-NEXT:    ret void
;
entry:
; The expression is basically same as in test_mem3 but here {a,b,c,d,e} are all loads.
; Output expression is going to be rearranged to have loads processed first
; All {a,b,c,d,e} form a single group with two uses with opposite ops (i.e. +/-)
; N + ( +d -e +a +b +c) << 16
; N - ( +e -a -b -c -d) << 16

  %g1 = getelementptr inbounds i32, i32* %p, i32 0
  %a = load i32, i32* %g1, align 4

  %g2 = getelementptr inbounds i32, i32* %p, i32 1
  %b = load i32, i32* %g2, align 4

  %g3 = getelementptr inbounds i32, i32* %p, i32 2
  %c = load i32, i32* %g3, align 4

  %g4 = getelementptr inbounds i32, i32* %p, i32 3
  %d = load i32, i32* %g4, align 4

  %g5 = getelementptr inbounds i32, i32* %p, i32 4
  %e = load i32, i32* %g5, align 4

  %i1 = sub i32 %d, %e
  %i2 = add i32 %i1, %a
  %i3 = add i32 %i2, %b
  %i4 = add i32 %i3, %c
  %i5 = shl i32 %i4, 16
  %i6 = add i32 %i5, %N

  %i7 = sub i32 %e, %a
  %i8 = sub i32 %i7, %b
  %i9 = sub i32 %i8, %c
  %i10 = sub i32 %i9, %d
  %i11 = shl i32 %i10, 16
  %i12 = sub i32 %N, %i11

  ret void
}

define void @test2_mem5(i32* %p, i32 %N) {
; CHECK-LABEL: @test2_mem5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; CHECK-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; CHECK-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; CHECK-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; CHECK-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; CHECK-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; CHECK-NEXT:    [[G4:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 3
; CHECK-NEXT:    [[D:%.*]] = load i32, i32* [[G4]], align 4
; CHECK-NEXT:    [[G5:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 4
; CHECK-NEXT:    [[E:%.*]] = load i32, i32* [[G5]], align 4
; CHECK-NEXT:    [[CHAIN_4_:%.*]] = shl i32 [[A]], 16
; CHECK-NEXT:    [[CHAIN_4_3:%.*]] = shl i32 [[B]], 16
; CHECK-NEXT:    [[CHAIN_4_5:%.*]] = shl i32 [[C]], 16
; CHECK-NEXT:    [[CHAIN_4_4:%.*]] = add i32 [[CHAIN_4_5]], [[CHAIN_4_3]]
; CHECK-NEXT:    [[CHAIN_4_2:%.*]] = add i32 [[CHAIN_4_4]], [[CHAIN_4_]]
; CHECK-NEXT:    [[CHAIN_5_7:%.*]] = shl i32 [[E]], 16
; CHECK-NEXT:    [[CHAIN_5_9:%.*]] = shl i32 [[D]], 16
; CHECK-NEXT:    [[CHAIN_5_8:%.*]] = sub i32 [[CHAIN_5_9]], [[CHAIN_5_7]]
; CHECK-NEXT:    [[CHAIN_5_:%.*]] = add i32 [[CHAIN_5_8]], [[N:%.*]]
; CHECK-NEXT:    [[TRUNK_9_:%.*]] = add i32 [[CHAIN_5_]], [[CHAIN_4_2]]
; CHECK-NEXT:    [[TRUNK_8_:%.*]] = sub i32 [[CHAIN_5_]], [[CHAIN_4_2]]
; CHECK-NEXT:    ret void
;
; DISTDISABLED-LABEL: @test2_mem5(
; DISTDISABLED-NEXT:  entry:
; DISTDISABLED-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; DISTDISABLED-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; DISTDISABLED-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; DISTDISABLED-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; DISTDISABLED-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; DISTDISABLED-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; DISTDISABLED-NEXT:    [[G4:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 3
; DISTDISABLED-NEXT:    [[D:%.*]] = load i32, i32* [[G4]], align 4
; DISTDISABLED-NEXT:    [[G5:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 4
; DISTDISABLED-NEXT:    [[E:%.*]] = load i32, i32* [[G5]], align 4
; DISTDISABLED-NEXT:    [[CHAIN_4_2:%.*]] = add i32 [[C]], [[B]]
; DISTDISABLED-NEXT:    [[CHAIN_4_:%.*]] = add i32 [[CHAIN_4_2]], [[A]]
; DISTDISABLED-NEXT:    [[CHAIN_5_:%.*]] = sub i32 [[E]], [[D]]
; DISTDISABLED-NEXT:    [[TRUNK_17_:%.*]] = sub i32 [[CHAIN_4_]], [[CHAIN_5_]]
; DISTDISABLED-NEXT:    [[I5:%.*]] = shl i32 [[TRUNK_17_]], 16
; DISTDISABLED-NEXT:    [[I6:%.*]] = add i32 [[I5]], [[N:%.*]]
; DISTDISABLED-NEXT:    [[TRUNK_15_:%.*]] = add i32 [[CHAIN_5_]], [[CHAIN_4_]]
; DISTDISABLED-NEXT:    [[I11:%.*]] = shl i32 [[TRUNK_15_]], 16
; DISTDISABLED-NEXT:    [[I12:%.*]] = sub i32 [[N]], [[I11]]
; DISTDISABLED-NEXT:    ret void
;
; NOGROUPCAN-LABEL: @test2_mem5(
; NOGROUPCAN-NEXT:  entry:
; NOGROUPCAN-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; NOGROUPCAN-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; NOGROUPCAN-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; NOGROUPCAN-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; NOGROUPCAN-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; NOGROUPCAN-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; NOGROUPCAN-NEXT:    [[G4:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 3
; NOGROUPCAN-NEXT:    [[D:%.*]] = load i32, i32* [[G4]], align 4
; NOGROUPCAN-NEXT:    [[G5:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 4
; NOGROUPCAN-NEXT:    [[E:%.*]] = load i32, i32* [[G5]], align 4
; NOGROUPCAN-NEXT:    [[CHAIN_4_:%.*]] = shl i32 [[A]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_4_3:%.*]] = shl i32 [[B]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_4_5:%.*]] = shl i32 [[C]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_4_4:%.*]] = add i32 [[CHAIN_4_5]], [[CHAIN_4_3]]
; NOGROUPCAN-NEXT:    [[CHAIN_4_2:%.*]] = add i32 [[CHAIN_4_4]], [[CHAIN_4_]]
; NOGROUPCAN-NEXT:    [[CHAIN_5_:%.*]] = shl i32 [[E]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_5_8:%.*]] = shl i32 [[D]], 16
; NOGROUPCAN-NEXT:    [[CHAIN_5_9:%.*]] = add i32 [[N:%.*]], [[CHAIN_5_8]]
; NOGROUPCAN-NEXT:    [[CHAIN_5_7:%.*]] = sub i32 [[CHAIN_5_9]], [[CHAIN_5_]]
; NOGROUPCAN-NEXT:    [[TRUNK_9_:%.*]] = add i32 [[CHAIN_5_7]], [[CHAIN_4_2]]
; NOGROUPCAN-NEXT:    [[TRUNK_8_:%.*]] = sub i32 [[CHAIN_5_7]], [[CHAIN_4_2]]
; NOGROUPCAN-NEXT:    ret void
;
entry:
; {a,b,c} form one group: (a +b +c) and {d,e} another one: (d -e)
; 1: N + ( +d -e +a +b +c) << 16   <= eq =>  N + ({a +b +c} + {d - e}) << 16
; 2: N - ( +e +a +b +c -d) << 16   <= eq =>  N - ({a +b +c} - {d - e}) << 16

  %g1 = getelementptr inbounds i32, i32* %p, i32 0
  %a = load i32, i32* %g1, align 4

  %g2 = getelementptr inbounds i32, i32* %p, i32 1
  %b = load i32, i32* %g2, align 4

  %g3 = getelementptr inbounds i32, i32* %p, i32 2
  %c = load i32, i32* %g3, align 4

  %g4 = getelementptr inbounds i32, i32* %p, i32 3
  %d = load i32, i32* %g4, align 4

  %g5 = getelementptr inbounds i32, i32* %p, i32 4
  %e = load i32, i32* %g5, align 4

; 1: N + ( +d -e +a +b +c) << 16
  %i1 = sub i32 %d, %e
  %i2 = add i32 %i1, %a
  %i3 = add i32 %i2, %b
  %i4 = add i32 %i3, %c
  %i5 = shl i32 %i4, 16
  %i6 = add i32 %i5, %N

; 2: N - ( +e +a +b +c -d) << 16
  %i7 = add i32 %e, %a
  %i8 = add i32 %i7, %b
  %i9 = add i32 %i8, %c
  %i10 = sub i32 %i9, %d
  %i11 = shl i32 %i10, 16
  %i12 = sub i32 %N, %i11

  ret void
}

define void @test1_(i32 %N, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) {
; CHECK-LABEL: @test1_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[I1:%.*]] = sub i32 [[D:%.*]], [[E:%.*]]
; CHECK-NEXT:    [[I2:%.*]] = add i32 [[I1]], [[A:%.*]]
; CHECK-NEXT:    [[I3:%.*]] = add i32 [[I2]], [[B:%.*]]
; CHECK-NEXT:    [[I4:%.*]] = add i32 [[I3]], [[C:%.*]]
; CHECK-NEXT:    [[I5:%.*]] = shl i32 [[I4]], 16
; CHECK-NEXT:    [[I6:%.*]] = add i32 [[I5]], [[N:%.*]]
; CHECK-NEXT:    [[I7:%.*]] = sub i32 [[E]], [[A]]
; CHECK-NEXT:    [[I8:%.*]] = sub i32 [[I7]], [[B]]
; CHECK-NEXT:    [[I9:%.*]] = sub i32 [[I8]], [[C]]
; CHECK-NEXT:    [[I10:%.*]] = sub i32 [[I9]], [[D]]
; CHECK-NEXT:    [[I11:%.*]] = shl i32 [[I10]], 16
; CHECK-NEXT:    [[I12:%.*]] = add i32 [[I11]], [[N]]
; CHECK-NEXT:    ret void
;
; DISTDISABLED-LABEL: @test1_(
; DISTDISABLED-NEXT:  entry:
; DISTDISABLED-NEXT:    [[CHAIN_6_4:%.*]] = sub i32 [[E:%.*]], [[C:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_6_3:%.*]] = sub i32 [[CHAIN_6_4]], [[B:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_6_2:%.*]] = sub i32 [[CHAIN_6_3]], [[D:%.*]]
; DISTDISABLED-NEXT:    [[CHAIN_6_:%.*]] = sub i32 [[CHAIN_6_2]], [[A:%.*]]
; DISTDISABLED-NEXT:    [[TRUNK_21_:%.*]] = sub i32 0, [[CHAIN_6_]]
; DISTDISABLED-NEXT:    [[I5:%.*]] = shl i32 [[TRUNK_21_]], 16
; DISTDISABLED-NEXT:    [[I6:%.*]] = add i32 [[I5]], [[N:%.*]]
; DISTDISABLED-NEXT:    [[I11:%.*]] = shl i32 [[CHAIN_6_]], 16
; DISTDISABLED-NEXT:    [[I12:%.*]] = add i32 [[I11]], [[N]]
; DISTDISABLED-NEXT:    ret void
;
entry:
; All {a,b,c,d,e} form a single group with two uses with opposite ops (i.e. +/-)
; N + ( +d -e +a +b +c) << 16
; N + ( +e -a -b -c -d) << 16

; This test is similar to test1 but flipping sign makes the two above
; not completely equivalent. One would expect this to be transformed
; into  N + G, N - G but the pass failed to do so. (cost calculation issue?).

  %i1 = sub i32 %d, %e
  %i2 = add i32 %i1, %a
  %i3 = add i32 %i2, %b
  %i4 = add i32 %i3, %c
  %i5 = shl i32 %i4, 16
  %i6 = add i32 %i5, %N

  %i7 = sub i32 %e, %a
  %i8 = sub i32 %i7, %b
  %i9 = sub i32 %i8, %c
  %i10 = sub i32 %i9, %d
  %i11 = shl i32 %i10, 16
  %i12 = add i32 %i11, %N

  ret void
}

define void @test_3shifts(i32 %N, i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) {
; CHECK-LABEL: @test_3shifts(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[I1:%.*]] = add i32 [[D:%.*]], [[A:%.*]]
; CHECK-NEXT:    [[I2:%.*]] = sub i32 [[I1]], [[E:%.*]]
; CHECK-NEXT:    [[I3:%.*]] = shl i32 [[I2]], 16
; CHECK-NEXT:    [[I4:%.*]] = shl i32 [[B:%.*]], 16
; CHECK-NEXT:    [[I5:%.*]] = shl i32 [[C:%.*]], 16
; CHECK-NEXT:    [[I6:%.*]] = add i32 [[I3]], [[I4]]
; CHECK-NEXT:    [[I7:%.*]] = add i32 [[I6]], [[I5]]
; CHECK-NEXT:    [[I8:%.*]] = add i32 [[N:%.*]], [[I7]]
; CHECK-NEXT:    [[I9:%.*]] = sub i32 [[E]], [[A]]
; CHECK-NEXT:    [[I10:%.*]] = sub i32 [[I9]], [[B]]
; CHECK-NEXT:    [[I11:%.*]] = shl i32 [[I10]], 16
; CHECK-NEXT:    [[I12:%.*]] = shl i32 [[C]], 16
; CHECK-NEXT:    [[I13:%.*]] = shl i32 [[D]], 16
; CHECK-NEXT:    [[I14:%.*]] = add i32 [[I11]], [[I12]]
; CHECK-NEXT:    [[I15:%.*]] = add i32 [[I14]], [[I13]]
; CHECK-NEXT:    [[I16:%.*]] = sub i32 [[N]], [[I15]]
; CHECK-NEXT:    ret void
;
; MULTIPLE-LABEL: @test_3shifts(
; MULTIPLE-NEXT:  entry:
; MULTIPLE-NEXT:    [[CHAIN_7_:%.*]] = shl i32 [[A:%.*]], 16
; MULTIPLE-NEXT:    [[CHAIN_7_3:%.*]] = shl i32 [[E:%.*]], 16
; MULTIPLE-NEXT:    [[CHAIN_7_5:%.*]] = shl i32 [[B:%.*]], 16
; MULTIPLE-NEXT:    [[CHAIN_7_6:%.*]] = add i32 [[N:%.*]], [[CHAIN_7_5]]
; MULTIPLE-NEXT:    [[CHAIN_7_4:%.*]] = sub i32 [[CHAIN_7_6]], [[CHAIN_7_3]]
; MULTIPLE-NEXT:    [[CHAIN_7_2:%.*]] = add i32 [[CHAIN_7_4]], [[CHAIN_7_]]
; MULTIPLE-NEXT:    [[CHAIN_8_:%.*]] = shl i32 [[C:%.*]], 16
; MULTIPLE-NEXT:    [[CHAIN_8_9:%.*]] = shl i32 [[D:%.*]], 16
; MULTIPLE-NEXT:    [[CHAIN_8_8:%.*]] = add i32 [[CHAIN_8_9]], [[CHAIN_8_]]
; MULTIPLE-NEXT:    [[TRUNK_13_:%.*]] = add i32 [[CHAIN_8_8]], [[CHAIN_7_2]]
; MULTIPLE-NEXT:    [[TRUNK_12_:%.*]] = sub i32 [[CHAIN_7_2]], [[CHAIN_8_8]]
; MULTIPLE-NEXT:    ret void
;
entry:
; These two are equivalent.
; 1: N + (d -e +a +b +c) << 16
; 2: N - (e -a -b -c -d) << 16
; If represented as
; 1: N + ((d -e +a) << 16 + b << 16 + c << 16)
; 2: N - ((e -a -b) << 16 + c << 16 + d << 16)
; Without applying distributivity property wrt left shift the groups cannot be found
; By default the pass is limitted to pull-in only one left shift occurence.
; So it only kicks in when allowance is increased to 3 or more.

; 1: N + ((d -e +a) << 16 + b << 16 + c << 16)
  %i1 = add i32 %d, %a
  %i2 = sub i32 %i1, %e
  %i3 = shl i32 %i2, 16        ; (+d +a -e) << 16
  %i4 = shl i32 %b, 16         ; b << 16
  %i5 = shl i32 %c, 16         ; c << 16

  %i6 = add i32 %i3, %i4
  %i7 = add i32 %i6, %i5
  %i8 = add i32 %N, %i7

; 2: N - (( e -a -b) << 16 + c << 16 + d << 16)
  %i9 = sub i32 %e, %a
  %i10 = sub i32 %i9, %b
  %i11 = shl i32 %i10, 16      ; ( e -a -b) << 16
  %i12 = shl i32 %c, 16        ; c << 16
  %i13 = shl i32 %d, 16        ; d << 16

  %i14 = add i32 %i11, %i12
  %i15 = add i32 %i14, %i13
  %i16 = sub i32 %N, %i15

  ret void
}

define void @test_2shifts(i32* noalias nocapture readonly %p, i32 %N, i32 %x,i32 %y,i32 %z) {
; CHECK-LABEL: @test_2shifts(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; CHECK-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; CHECK-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; CHECK-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; CHECK-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; CHECK-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; CHECK-NEXT:    [[G4:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 3
; CHECK-NEXT:    [[D:%.*]] = load i32, i32* [[G4]], align 4
; CHECK-NEXT:    [[G5:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 4
; CHECK-NEXT:    [[E:%.*]] = load i32, i32* [[G5]], align 4
; CHECK-NEXT:    [[I1:%.*]] = add i32 [[D]], [[A]]
; CHECK-NEXT:    [[I2:%.*]] = sub i32 [[I1]], [[E]]
; CHECK-NEXT:    [[I3:%.*]] = shl i32 [[I2]], 16
; CHECK-NEXT:    [[I4:%.*]] = add i32 [[B]], [[C]]
; CHECK-NEXT:    [[I5:%.*]] = shl i32 [[I4]], 16
; CHECK-NEXT:    [[I6:%.*]] = add i32 [[I3]], [[I5]]
; CHECK-NEXT:    [[I7:%.*]] = add i32 [[N:%.*]], [[I6]]
; CHECK-NEXT:    [[I8:%.*]] = add i32 [[A]], [[B]]
; CHECK-NEXT:    [[I9:%.*]] = sub i32 [[I8]], [[E]]
; CHECK-NEXT:    [[I10:%.*]] = shl i32 [[I9]], 16
; CHECK-NEXT:    [[I11:%.*]] = add i32 [[C]], [[D]]
; CHECK-NEXT:    [[I12:%.*]] = shl i32 [[I11]], 16
; CHECK-NEXT:    [[I13:%.*]] = add i32 [[I10]], [[I12]]
; CHECK-NEXT:    [[I14:%.*]] = sub i32 [[N]], [[I13]]
; CHECK-NEXT:    ret void
;
; MULTIPLE-LABEL: @test_2shifts(
; MULTIPLE-NEXT:  entry:
; MULTIPLE-NEXT:    [[G1:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i32 0
; MULTIPLE-NEXT:    [[A:%.*]] = load i32, i32* [[G1]], align 4
; MULTIPLE-NEXT:    [[G2:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 1
; MULTIPLE-NEXT:    [[B:%.*]] = load i32, i32* [[G2]], align 4
; MULTIPLE-NEXT:    [[G3:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 2
; MULTIPLE-NEXT:    [[C:%.*]] = load i32, i32* [[G3]], align 4
; MULTIPLE-NEXT:    [[G4:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 3
; MULTIPLE-NEXT:    [[D:%.*]] = load i32, i32* [[G4]], align 4
; MULTIPLE-NEXT:    [[G5:%.*]] = getelementptr inbounds i32, i32* [[P]], i32 4
; MULTIPLE-NEXT:    [[E:%.*]] = load i32, i32* [[G5]], align 4
; MULTIPLE-NEXT:    [[I1:%.*]] = add i32 [[D]], [[A]]
; MULTIPLE-NEXT:    [[I2:%.*]] = sub i32 [[I1]], [[E]]
; MULTIPLE-NEXT:    [[I3:%.*]] = shl i32 [[I2]], 16
; MULTIPLE-NEXT:    [[I4:%.*]] = add i32 [[B]], [[C]]
; MULTIPLE-NEXT:    [[I5:%.*]] = shl i32 [[I4]], 16
; MULTIPLE-NEXT:    [[I6:%.*]] = add i32 [[I3]], [[I5]]
; MULTIPLE-NEXT:    [[I7:%.*]] = add i32 [[N:%.*]], [[I6]]
; MULTIPLE-NEXT:    [[I8:%.*]] = add i32 [[A]], [[B]]
; MULTIPLE-NEXT:    [[I9:%.*]] = sub i32 [[I8]], [[E]]
; MULTIPLE-NEXT:    [[I10:%.*]] = shl i32 [[I9]], 16
; MULTIPLE-NEXT:    [[I11:%.*]] = add i32 [[C]], [[D]]
; MULTIPLE-NEXT:    [[I12:%.*]] = shl i32 [[I11]], 16
; MULTIPLE-NEXT:    [[I13:%.*]] = add i32 [[I10]], [[I12]]
; MULTIPLE-NEXT:    [[I14:%.*]] = sub i32 [[N]], [[I13]]
; MULTIPLE-NEXT:    ret void
;
entry:
  %g1 = getelementptr inbounds i32, i32* %p, i32 0
  %a = load i32, i32* %g1, align 4

  %g2 = getelementptr inbounds i32, i32* %p, i32 1
  %b = load i32, i32* %g2, align 4

  %g3 = getelementptr inbounds i32, i32* %p, i32 2
  %c = load i32, i32* %g3, align 4

  %g4 = getelementptr inbounds i32, i32* %p, i32 3
  %d = load i32, i32* %g4, align 4

  %g5 = getelementptr inbounds i32, i32* %p, i32 4
  %e = load i32, i32* %g5, align 4

; Test these two expressions:
; 1: N + ((+d +a -e) << 16 + (+b +c) << 16) ; equivalent to N + (+d -e +a +b +c) << 16
; 2: N - ((-e +a +b) << 16 + (+c +d) << 16) ; equivalent to N - (+d -e +a +b +c) << 16
; Ideally to be transformed into N + G and N - G
; It's not enabled by default.
; But even if enabled the pass does not kick in (probably same issue as with test1_)

; 1: N + ((+d +a -e) << 16 + (+b +c) << 16) ; equivalent to N + (+d -e +a +b +c) << 16
  %i1 = add i32 %d, %a
  %i2 = sub i32 %i1, %e
  %i3 = shl i32 %i2, 16        ; ( +d +a -e) << 16

  %i4 = add i32 %b, %c
  %i5 = shl i32 %i4, 16        ; (+b +c) << 16

  %i6 = add i32 %i3, %i5
  %i7 = add i32 %N, %i6

; 2: N - ((-e +a +b) << 16 + (+c +d) << 16) ; equivalent to N - (+d -e +a +b +c) << 16
  %i8 = add i32 %a, %b
  %i9 = sub i32 %i8, %e
  %i10 = shl i32 %i9, 16       ; ( -e +a +b) << 16

  %i11 = add i32 %c, %d
  %i12 = shl i32 %i11, 16      ; (+c +d) << 16

  %i13 = add i32 %i10, %i12
  %i14 = sub i32 %N, %i13

  ret void
}

