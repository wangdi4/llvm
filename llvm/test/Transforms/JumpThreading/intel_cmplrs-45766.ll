; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes="jump-threading" -S -distant-jump-threading -jump-thread-loop-header < %s | FileCheck %s

; Previously we crashed due to following the %tmp5 phi to reach the %tmp2 phi.
; This would cause bb4 to be a subregion top and subregion bottom which we
; can't currently handle.

define void @foo() {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP:%.*]] = phi i32 [ 45, [[BB:%.*]] ], [ 0, [[BB10:%.*]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = phi i32 [ 0, [[BB]] ], [ [[TMP2]], [[BB10]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = shl i32 [[TMP]], 1
; CHECK-NEXT:    br label [[BB4:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    [[TMP5:%.*]] = phi i32 [ [[TMP3]], [[BB1]] ], [ [[TMP2]], [[BB4]] ]
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ugt i32 undef, [[TMP]]
; CHECK-NEXT:    br i1 [[TMP6]], label [[BB7:%.*]], label [[BB4]]
; CHECK:       bb7:
; CHECK-NEXT:    switch i32 [[TMP5]], label [[BB9:%.*]] [
; CHECK-NEXT:    i32 66, label [[BB10]]
; CHECK-NEXT:    i32 0, label [[BB8:%.*]]
; CHECK-NEXT:    ]
; CHECK:       bb8:
; CHECK-NEXT:    unreachable
; CHECK:       bb9:
; CHECK-NEXT:    unreachable
; CHECK:       bb10:
; CHECK-NEXT:    br label [[BB1]]
;
bb:
  br label %bb1

bb1:                                              ; preds = %bb10, %bb
  %tmp = phi i32 [ 45, %bb ], [ 0, %bb10 ]
  %tmp2 = phi i32 [ 0, %bb ], [ %tmp2, %bb10 ]
  %tmp3 = shl i32 %tmp, 1
  br label %bb4

bb4:                                              ; preds = %bb4, %bb1
  %tmp5 = phi i32 [ %tmp3, %bb1 ], [ %tmp2, %bb4 ]
  %tmp6 = icmp ugt i32 undef, %tmp
  br i1 %tmp6, label %bb7, label %bb4

bb7:                                              ; preds = %bb4
  switch i32 %tmp5, label %bb9 [
  i32 66, label %bb10
  i32 0, label %bb8
  ]

bb8:                                              ; preds = %bb7
  unreachable

bb9:                                              ; preds = %bb7
  unreachable

bb10:                                             ; preds = %bb7
  br label %bb1
}

; This test case crashed threading sw.bb to sw.bb5. We cloned for.inc, but
; deleted the only incoming value for the phi there. This created an empty
; phi that got erased and invalidated an iterator. We no longer erase empty
; phis, preventing the invalidation.

@g_1 = external local_unnamed_addr global i32, align 4
@g_2 = external local_unnamed_addr global i32, align 4

define void @_Z3foov() {
; CHECK-LABEL: @_Z3foov(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @g_2, align 4
; CHECK-NEXT:    switch i32 [[TMP0]], label [[SW_EPILOG:%.*]] [
; CHECK-NEXT:    i32 0, label [[SW_BB:%.*]]
; CHECK-NEXT:    i32 2, label [[SW_BB]]
; CHECK-NEXT:    ]
; CHECK:       sw.bb:
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @g_1, align 4
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[TOBOOL]], label [[FOR_COND_THREAD:%.*]], label [[IF_THEN:%.*]]
; CHECK:       for.cond.thread:
; CHECK-NEXT:    [[TOBOOL21:%.*]] = icmp eq i32 [[TMP0]], 0
; CHECK-NEXT:    br i1 [[TOBOOL21]], label [[CLEANUP12:%.*]], label [[IF_THEN3_THREAD:%.*]]
; CHECK:       if.then3.thread:
; CHECK-NEXT:    br label [[SW_BB5:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    unreachable
; CHECK:       sw.epilog:
; CHECK-NEXT:    [[DOTPR:%.*]] = load i32, ptr @g_1, align 4
; CHECK-NEXT:    br label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TOBOOL2:%.*]] = icmp eq i32 [[TMP0]], 0
; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 false, [[TOBOOL2]]
; CHECK-NEXT:    br i1 [[OR_COND]], label [[CLEANUP12]], label [[IF_THEN3:%.*]]
; CHECK:       if.then3:
; CHECK-NEXT:    switch i32 [[DOTPR]], label [[CLEANUP10_THREAD:%.*]] [
; CHECK-NEXT:    i32 0, label [[SW_BB5]]
; CHECK-NEXT:    i32 1, label [[FOR_INC:%.*]]
; CHECK-NEXT:    ]
; CHECK:       sw.bb5:
; CHECK-NEXT:    br label [[CLEANUP10_THREAD]]
; CHECK:       cleanup10.thread:
; CHECK-NEXT:    br label [[CLEANUP12]]
; CHECK:       for.inc:
; CHECK-NEXT:    [[CLEANUP_DEST_SLOT_1:%.*]] = phi i32 [ 5, [[IF_THEN3]] ]
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       cleanup12:
; CHECK-NEXT:    ret void
;
entry:
  %0 = load i32, ptr @g_2, align 4
  switch i32 %0, label %sw.epilogthread-pre-split [
  i32 0, label %sw.bb
  i32 2, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry
  %1 = load i32, ptr @g_1, align 4
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %sw.epilog, label %if.then

if.then:                                          ; preds = %sw.bb
  unreachable

sw.epilogthread-pre-split:                        ; preds = %entry
  %.pr = load i32, ptr @g_1, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.epilogthread-pre-split, %sw.bb
  %2 = phi i32 [ %.pr, %sw.epilogthread-pre-split ], [ %1, %sw.bb ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %tobool2 = icmp eq i32 %0, 0
  %or.cond = or i1 false, %tobool2
  br i1 %or.cond, label %cleanup12, label %if.then3

if.then3:                                         ; preds = %for.cond
  switch i32 %2, label %sw.epilog8 [
  i32 0, label %sw.bb5
  i32 1, label %for.inc
  ]

sw.bb5:                                           ; preds = %if.then3
  br label %cleanup10.thr_comm

sw.epilog8:                                       ; preds = %if.then3
  br label %cleanup10.thr_comm

cleanup10.thr_comm:                               ; preds = %sw.bb5, %sw.epilog8
  br label %cleanup10.thread

cleanup10.thread:                                 ; preds = %cleanup10.thr_comm
  br label %cleanup12

for.inc:                                          ; preds = %if.then3
  %cleanup.dest.slot.1 = phi i32 [ 5, %if.then3 ]
  br label %for.cond

cleanup12:                                        ; preds = %cleanup10.thread, %for.cond
  ret void
}
