; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -sroa -S -o - < %s | FileCheck %s
; RUN: opt -passes=sroa < %s -S | FileCheck %s

; If alloca is for private structure variable used inside SIMD region, it can be promoted
%struct.S = type { double, double }

define void @test1() {
; CHECK-LABEL: @test1(
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.SIMD"() ]
; CHECK-NEXT:    ret void
;
  %s = alloca %struct.S
  %tmp = bitcast %struct.S* %s to i8*
  %xPos = getelementptr inbounds %struct.S, %struct.S* %s, i64 0, i32 0
  %yPos = getelementptr inbounds %struct.S, %struct.S* %s, i64 0, i32 1
  %tmp1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE"(%struct.S* %s) ]
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %tmp)
  store double 1.000000e+00, double* %xPos
  store double 2.000000e+00, double* %yPos
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %tmp)
  call void @llvm.directive.region.exit(token %tmp1) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; If alloca is used not in SIMD region, it won't be promoted
define void @test2() {
; CHECK-LABEL: @test2(
; CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%[^ ,]+]]
; CHECK-NEXT:    [[TMP:%.*]] = bitcast %struct.S* [[S]] to i8*
; CHECK-NEXT:    [[XPOS:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i64 0, i32 0
; CHECK-NEXT:    [[YPOS:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i64 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PARALLEL"(), "QUAL.OMP.PRIVATE"(%struct.S* [[S]]) ]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull [[TMP]])
; CHECK-NEXT:    store double 1.000000e+00, double* [[XPOS]]
; CHECK-NEXT:    store double 2.000000e+00, double* [[YPOS]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull [[TMP]])
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.PARALLEL"() ]
; CHECK-NEXT:    ret void
;
  %s = alloca %struct.S
  %tmp = bitcast %struct.S* %s to i8*
  %xPos = getelementptr inbounds %struct.S, %struct.S* %s, i64 0, i32 0
  %yPos = getelementptr inbounds %struct.S, %struct.S* %s, i64 0, i32 1
  %tmp1 = call token @llvm.directive.region.entry() [ "DIR.OMP.PARALLEL"(), "QUAL.OMP.PRIVATE"(%struct.S* %s) ]
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %tmp)
  store double 1.000000e+00, double* %xPos
  store double 2.000000e+00, double* %yPos
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %tmp)
  call void @llvm.directive.region.exit(token %tmp1) [ "DIR.OMP.END.PARALLEL"() ]
  ret void
}

; If alloca is used in SIMD region but not for private variable, it won't be promoted
define void @test3() {
; CHECK-LABEL: @test3(
; CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%[^ ,]+]]
; CHECK-NEXT:    [[TMP:%.*]] = bitcast %struct.S* [[S]] to i8*
; CHECK-NEXT:    [[XPOS:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i64 0, i32 0
; CHECK-NEXT:    [[YPOS:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i64 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(%struct.S* [[S]]) ]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull [[TMP]])
; CHECK-NEXT:    store double 1.000000e+00, double* [[XPOS]]
; CHECK-NEXT:    store double 2.000000e+00, double* [[YPOS]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull [[TMP]])
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.SIMD"() ]
; CHECK-NEXT:    ret void
;
  %s = alloca %struct.S
  %tmp = bitcast %struct.S* %s to i8*
  %xPos = getelementptr inbounds %struct.S, %struct.S* %s, i64 0, i32 0
  %yPos = getelementptr inbounds %struct.S, %struct.S* %s, i64 0, i32 1
  %tmp1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(%struct.S* %s) ]
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %tmp)
  store double 1.000000e+00, double* %xPos
  store double 2.000000e+00, double* %yPos
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %tmp)
  call void @llvm.directive.region.exit(token %tmp1) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
