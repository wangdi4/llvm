; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=sroa < %s -S | FileCheck %s

; If alloca is for private structure variable used inside SIMD region, it can be promoted
%struct.S = type { double, double }

define void @test1() {
; CHECK-LABEL: @test1(
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.SIMD"() ]
; CHECK-NEXT:    ret void
;
  %s = alloca %struct.S
  %yPos = getelementptr inbounds %struct.S, ptr %s, i64 0, i32 1
  %tmp1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE"(ptr %s) ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %s)
  store double 1.000000e+00, ptr %s
  store double 2.000000e+00, ptr %yPos
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %s)
  call void @llvm.directive.region.exit(token %tmp1) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; If alloca is used not in SIMD region, it won't be promoted
define void @test2() {
; CHECK-LABEL: @test2(
; CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 8
; CHECK-NEXT:    [[YPOS:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S]], i64 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PARALLEL"(), "QUAL.OMP.PRIVATE"(ptr [[S]]) ]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr nonnull [[S]])
; CHECK-NEXT:    store double 1.000000e+00, ptr [[S]], align 8
; CHECK-NEXT:    store double 2.000000e+00, ptr [[YPOS]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr nonnull [[S]])
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.PARALLEL"() ]
; CHECK-NEXT:    ret void
;
  %s = alloca %struct.S
  %yPos = getelementptr inbounds %struct.S, ptr %s, i64 0, i32 1
  %tmp1 = call token @llvm.directive.region.entry() [ "DIR.OMP.PARALLEL"(), "QUAL.OMP.PRIVATE"(ptr %s) ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %s)
  store double 1.000000e+00, ptr %s
  store double 2.000000e+00, ptr %yPos
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %s)
  call void @llvm.directive.region.exit(token %tmp1) [ "DIR.OMP.END.PARALLEL"() ]
  ret void
}

; If alloca is used in SIMD region but not for private variable, it won't be promoted
define void @test3() {
; CHECK-LABEL: @test3(
; CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 8
; CHECK-NEXT:    [[YPOS:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S]], i64 0, i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(ptr [[S]]) ]
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr nonnull [[S]])
; CHECK-NEXT:    store double 1.000000e+00, ptr [[S]], align 8
; CHECK-NEXT:    store double 2.000000e+00, ptr [[YPOS]], align 8
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr nonnull [[S]])
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.SIMD"() ]
; CHECK-NEXT:    ret void
;
  %s = alloca %struct.S
  %yPos = getelementptr inbounds %struct.S, ptr %s, i64 0, i32 1
  %tmp1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(ptr %s) ]
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %s)
  store double 1.000000e+00, ptr %s
  store double 2.000000e+00, ptr %yPos
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %s)
  call void @llvm.directive.region.exit(token %tmp1) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
