; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -passes='loop-unroll,sroa' --sroa-max-alloca-slices=16 -S -o - < %s | FileCheck %s

; Same as "huge-size.ll", but we expect the limit to be ignored because of
; the loopopt attribute. This test also demonstrates optimizations that are
; made possible without the limit.

define void @huge_size() #0 {
; CHECK-LABEL: define void @huge_size(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  start:
; CHECK-NEXT:    br label [[LOOP_1:%.*]]
; CHECK:       loop.1:
; CHECK-NEXT:    br label [[LOOP_2:%.*]]
; CHECK:       loop.2:
; CHECK-NEXT:    br label [[LOOP_3:%.*]]
; CHECK:       loop.3:
; CHECK-NEXT:    ret void
;
start:
  %array       = alloca [5 x [5 x [5 x { i64, i64 }]]], align 8
  %array.sub.1 = alloca [5 x [5 x { i64, i64 }]], align 8
  %array.sub.2 = alloca [5 x { i64, i64 }], align 8
  br label %loop.1

; Set up %array.sub.2
loop.1:
  %ind.1 = phi i64 [ 0, %start ], [ %ind.1.next, %loop.1 ]
  %gep.1 = getelementptr [5 x { i64, i64 }], ptr %array.sub.2, i64 0, i64 %ind.1
  store i64 0, ptr %gep.1, align 8
  %ind.1.next = add i64 %ind.1, 1
  %loop1.cond = icmp ult i64 %ind.1.next, 5
  br i1 %loop1.cond, label %loop.1, label %loop.2

; Set up %array.sub.1
loop.2:
  %ind.2 = phi i64 [ 0, %loop.1 ], [ %ind.2.next, %loop.2 ]
  %gep.2 = getelementptr [5 x [5 x { i64, i64 }]], ptr %array.sub.1, i64 0, i64 %ind.2
  call void @llvm.memcpy.p0.p0.i64(ptr %gep.2, ptr %array.sub.2, i64 160, i1 false)
  %ind.2.next = add i64 %ind.2, 1
  %loop.2.cond = icmp ult i64 %ind.2.next, 5
  br i1 %loop.2.cond, label %loop.2, label %loop.3

; Set up %array
loop.3:
  %ind.3 = phi i64 [ 0, %loop.2 ], [ %ind.3.next, %loop.3 ]
  %gep.3 = getelementptr [5 x [5 x [5 x { i64, i64 }]]], ptr %array, i64 0, i64 %ind.3
  call void @llvm.memcpy.p0.p0.i64(ptr %gep.3, ptr %array.sub.1, i64 1600, i1 false)
  %ind.3.next = add i64 %ind.3, 1
  %loop.3.cond = icmp ult i64 %ind.3.next, 5
  br i1 %loop.3.cond, label %loop.3, label %exit

exit:
  ret void
}

declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)

attributes #0 = { mustprogress norecurse uwtable "loopopt-pipeline"="full" }
