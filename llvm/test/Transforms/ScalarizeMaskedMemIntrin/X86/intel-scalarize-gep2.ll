; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -opaque-pointers=0 -S -enable-intel-advanced-opts -passes=scalarize-masked-mem-intrin -mtriple=x86_64-unknown-unknown -mattr=+avx2 < %s | FileCheck %s
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

declare void @llvm.masked.scatter.v8i32.v8p0i32(<8 x i32> %0, <8 x i32*> %1, i32 immarg %2, <8 x i1> %3)

define void @scalar() {
; CHECK-LABEL: @scalar(
; CHECK-NEXT:    [[LOC:%.*]] = alloca <16 x i32>, align 64
; CHECK-NEXT:    [[LOC_BC:%.*]] = bitcast <16 x i32>* [[LOC]] to <2 x i32>*
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 0, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR0]], align 8
; CHECK-NEXT:    [[PTR1:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 1, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR1]], align 8
; CHECK-NEXT:    [[PTR2:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 2, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR2]], align 8
; CHECK-NEXT:    [[PTR3:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 3, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR3]], align 8
; CHECK-NEXT:    [[PTR4:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 4, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR4]], align 8
; CHECK-NEXT:    [[PTR5:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 5, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR5]], align 8
; CHECK-NEXT:    [[PTR6:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 6, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR6]], align 8
; CHECK-NEXT:    [[PTR7:%.*]] = getelementptr <2 x i32>, <2 x i32>* [[LOC_BC]], i64 7, i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR7]], align 8
; CHECK-NEXT:    ret void
;
  %loc = alloca <16 x i32>, align 64
  %loc.bc = bitcast <16 x i32>* %loc to <2 x i32>*
  %mm_vectorGEP37 = getelementptr <2 x i32>, <2 x i32>* %loc.bc, <8 x i64> <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7>, <8 x i64> zeroinitializer
  call void @llvm.masked.scatter.v8i32.v8p0i32(<8 x i32> zeroinitializer, <8 x i32*> %mm_vectorGEP37, i32 8, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>)
  ret void
}

define void @vector(<8 x i32*> %loc.bc, i64 %val) {
; CHECK-LABEL: @vector(
; CHECK-NEXT:    [[BROADCAST:%.*]] = insertelement <8 x i64> undef, i64 [[VAL:%.*]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <8 x i64> [[BROADCAST]], <8 x i64> undef, <8 x i32> zeroinitializer
; CHECK-NEXT:    [[MM_VECTORGEP37:%.*]] = getelementptr i32, <8 x i32*> [[LOC_BC:%.*]], <8 x i64> [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[PTR0:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 0
; CHECK-NEXT:    store i32 0, i32* [[PTR0]], align 8
; CHECK-NEXT:    [[PTR1:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 1
; CHECK-NEXT:    store i32 0, i32* [[PTR1]], align 8
; CHECK-NEXT:    [[PTR2:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 2
; CHECK-NEXT:    store i32 0, i32* [[PTR2]], align 8
; CHECK-NEXT:    [[PTR3:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 3
; CHECK-NEXT:    store i32 0, i32* [[PTR3]], align 8
; CHECK-NEXT:    [[PTR4:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 4
; CHECK-NEXT:    store i32 0, i32* [[PTR4]], align 8
; CHECK-NEXT:    [[PTR5:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 5
; CHECK-NEXT:    store i32 0, i32* [[PTR5]], align 8
; CHECK-NEXT:    [[PTR6:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 6
; CHECK-NEXT:    store i32 0, i32* [[PTR6]], align 8
; CHECK-NEXT:    [[PTR7:%.*]] = extractelement <8 x i32*> [[MM_VECTORGEP37]], i64 7
; CHECK-NEXT:    store i32 0, i32* [[PTR7]], align 8
; CHECK-NEXT:    ret void
;
  %broadcast = insertelement <8 x i64> undef, i64 %val, i64 0
  %broadcast.splat = shufflevector <8 x i64> %broadcast, <8 x i64> undef, <8 x i32> zeroinitializer
  %mm_vectorGEP37 = getelementptr i32, <8 x i32*> %loc.bc, <8 x i64> %broadcast.splat
  call void @llvm.masked.scatter.v8i32.v8p0i32(<8 x i32> zeroinitializer, <8 x i32*> %mm_vectorGEP37, i32 8, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>)
  ret void
}
