; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -disable-output -enable-vplan-outer-loop-hir -print-before=hir-vplan-vec -print-after=hir-vplan-vec -hir-details -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,print<hir>,hir-vplan-vec,print<hir>" -disable-output -enable-vplan-outer-loop-hir -hir-details -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
;
; LIT test to check livein/liveout information of generated vector loop.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@larr2 = dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16
@larr1 = dso_local local_unnamed_addr global [100 x i64] zeroinitializer, align 16

; Function Attrs: nofree norecurse nosync nounwind uwtable
define dso_local void @foo(i64 %n1, i64 %n2) local_unnamed_addr #0 {
; CHECK:       + LiveIn symbases: 9, 10, 16, 17
; CHECK-NEXT:  + LiveOut symbases:
; CHECK-NEXT:  + Loop metadata: No
; CHECK-NEXT:  + DO i64 i1 = 0, 99, 1   <DO_LOOP> <simd>
; CHECK-NEXT:  |   %sum.024 = 0;
; CHECK-NEXT:  |   <LVAL-REG> i64 0 {sb:3}
; CHECK-NEXT:  |
; CHECK-NEXT:  |
; CHECK-NEXT:  |   + Ztt: No
; CHECK-NEXT:  |   + NumExits: 1
; CHECK-NEXT:  |   + Innermost: Yes
; CHECK-NEXT:  |   + HasSignedIV: Yes
; CHECK-NEXT:  |   + LiveIn symbases: 3, 9, 10
; CHECK-NEXT:  |   + LiveOut symbases: 3
; CHECK-NEXT:  |   + Loop metadata: No
; CHECK-NEXT:  |   + DO i64 i2 = 0, 99, 1   <DO_LOOP>
; CHECK-NEXT:  |   |   %0 = (@larr2)[0][i2 + 2 * %n2][i1];
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR i64 %0 {sb:11}
; CHECK-NEXT:  |   |   <RVAL-REG> {al:8}(LINEAR [100 x [100 x i64]]* @larr2)[i64 0][LINEAR i64 i2 + 2 * %n2][LINEAR i64 i1] inbounds  {sb:20}
; CHECK-NEXT:  |   |      <BLOB> LINEAR [100 x [100 x i64]]* @larr2 {sb:9}
; CHECK-NEXT:  |   |      <BLOB> LINEAR i64 %n2 {sb:10}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   %sum.024 = %0  +  %sum.024;
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR i64 %sum.024 {sb:3}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR i64 %0 {sb:11}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR i64 %sum.024 {sb:3}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   + END LOOP
; CHECK-NEXT:  |
; CHECK-NEXT:  |   (@larr1)[0][i1 + 2 * %n2 + %n1] = %sum.024;
; CHECK-NEXT:  |   <LVAL-REG> {al:8}(LINEAR [100 x i64]* @larr1)[i64 0][LINEAR i64 i1 + 2 * %n2 + %n1] inbounds  {sb:21}
; CHECK-NEXT:  |      <BLOB> LINEAR i64 %n1 {sb:17}
; CHECK-NEXT:  |      <BLOB> LINEAR [100 x i64]* @larr1 {sb:16}
; CHECK-NEXT:  |      <BLOB> LINEAR i64 %n2 {sb:10}
; CHECK-NEXT:  |   <RVAL-REG> NON-LINEAR i64 %sum.024 {sb:3}
; CHECK-NEXT:  |
; CHECK-NEXT:  + END LOOP
;
; CHECK:       + LiveIn symbases: 9, 10, 16, 17
; CHECK-NEXT:  + LiveOut symbases:
; CHECK-NEXT:  + Loop metadata:
; CHECK-NEXT:  + DO i64 i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:  |   %.copy = 0;
; CHECK-NEXT:  |   <LVAL-REG> NON-LINEAR <4 x i64> %.copy {sb:22}
; CHECK-NEXT:  |
; CHECK-NEXT:  |   %phi.temp = %.copy;
; CHECK-NEXT:  |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK-NEXT:  |   <RVAL-REG> NON-LINEAR <4 x i64> %.copy {sb:22}
; CHECK-NEXT:  |
; CHECK-NEXT:  |   %phi.temp4 = 0;
; CHECK-NEXT:  |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp4 {sb:24}
; CHECK-NEXT:  |
; CHECK-NEXT:  |
; CHECK-NEXT:  |   + Ztt: No
; CHECK-NEXT:  |   + NumExits: 1
; CHECK-NEXT:  |   + Innermost: Yes
; CHECK-NEXT:  |   + HasSignedIV: No
; CHECK-NEXT:  |   + LiveIn symbases: 9, 10, 23, 24
; CHECK-NEXT:  |   + LiveOut symbases: 30
; CHECK-NEXT:  |   + Loop metadata: No
; CHECK-NEXT:  |   + UNKNOWN LOOP i2
; CHECK-NEXT:  |   |   <i2 = 0>
; CHECK-NEXT:  |   |   [[BB0:BB[0-9]+]].46:
; CHECK-NEXT:  |   |   %extract.0. = extractelement 2 * %n2 + %phi.temp4,  0;
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR i64 %extract.0. {sb:27}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR <4 x i64> 2 * %n2 + %phi.temp4 {sb:2}
; CHECK-NEXT:  |   |      <BLOB> LINEAR i64 %n2 {sb:10}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR <4 x i64> %phi.temp4 {sb:24}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   %.vec = (<4 x i64>*)(@larr2)[0][%extract.0.][i1];
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR <4 x i64> %.vec {sb:28}
; CHECK-NEXT:  |   |   <RVAL-REG> {al:8}(<4 x i64>*)(LINEAR [100 x [100 x i64]]* @larr2)[i64 0][NON-LINEAR i64 %extract.0.][LINEAR i64 i1] inbounds  {sb:20}
; CHECK-NEXT:  |   |      <BLOB> LINEAR [100 x [100 x i64]]* @larr2 {sb:9}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR i64 %extract.0. {sb:27}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   %.vec6 = %phi.temp4 + 1 <= 99;
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR <4 x i1> %.vec6 {sb:29}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR <4 x i64> %phi.temp4 + 1 {sb:2}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR <4 x i64> %phi.temp4 {sb:24}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   %phi.temp = %phi.temp + %.vec;
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR <4 x i64> %phi.temp + %.vec {sb:2}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR <4 x i64> %.vec {sb:28}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   %phi.temp4 = %phi.temp4 + 1;
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp4 {sb:24}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR <4 x i64> %phi.temp4 + 1 {sb:2}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR <4 x i64> %phi.temp4 {sb:24}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   %phi.temp9 = %phi.temp + %.vec;
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp9 {sb:30}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR <4 x i64> %phi.temp + %.vec {sb:2}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK-NEXT:  |   |      <BLOB> NON-LINEAR <4 x i64> %.vec {sb:28}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   %unifcond = extractelement %.vec6,  0;
; CHECK-NEXT:  |   |   <LVAL-REG> NON-LINEAR i1 %unifcond {sb:31}
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR <4 x i1> %.vec6 {sb:29}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   if (%unifcond == 1)
; CHECK-NEXT:  |   |   <RVAL-REG> NON-LINEAR i1 %unifcond {sb:31}
; CHECK-NEXT:  |   |
; CHECK-NEXT:  |   |   {
; CHECK-NEXT:  |   |      <i2 = i2 + 1>
; CHECK-NEXT:  |   |      goto [[BB0]].46;
; CHECK-NEXT:  |   |   }
; CHECK-NEXT:  |   + END LOOP
; CHECK-NEXT:  |
; CHECK-NEXT:  |   (<4 x i64>*)(@larr1)[0][i1 + 2 * %n2 + %n1] = %phi.temp9;
; CHECK-NEXT:  |   <LVAL-REG> {al:8}(<4 x i64>*)(LINEAR [100 x i64]* @larr1)[i64 0][LINEAR i64 i1 + 2 * %n2 + %n1] inbounds  {sb:21}
; CHECK-NEXT:  |      <BLOB> LINEAR [100 x i64]* @larr1 {sb:16}
; CHECK-NEXT:  |      <BLOB> LINEAR i64 %n2 {sb:10}
; CHECK-NEXT:  |      <BLOB> LINEAR i64 %n1 {sb:17}
; CHECK-NEXT:  |   <RVAL-REG> NON-LINEAR <4 x i64> %phi.temp9 {sb:30}
; CHECK-NEXT:  |
; CHECK-NEXT:  + END LOOP
;
entry:
  %mul = shl nsw i64 %n2, 1
  %add7 = add nsw i64 %mul, %n1
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.end
  %l1.025 = phi i64 [ 0, %entry ], [ %inc11, %for.end ]
  br label %for.body3

for.body3:                                        ; preds = %for.cond1.preheader, %for.body3
  %sum.024 = phi i64 [ 0, %for.cond1.preheader ], [ %add5, %for.body3 ]
  %l2.023 = phi i64 [ 0, %for.cond1.preheader ], [ %inc, %for.body3 ]
  %add = add nsw i64 %l2.023, %mul
  %arrayidx4 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @larr2, i64 0, i64 %add, i64 %l1.025
  %0 = load i64, i64* %arrayidx4, align 8
  %add5 = add nsw i64 %0, %sum.024
  %inc = add nuw nsw i64 %l2.023, 1
  %exitcond.not = icmp eq i64 %inc, 100
  br i1 %exitcond.not, label %for.end, label %for.body3

for.end:                                          ; preds = %for.body3
  %add5.lcssa = phi i64 [ %add5, %for.body3 ]
  %add8 = add nsw i64 %add7, %l1.025
  %arrayidx9 = getelementptr inbounds [100 x i64], [100 x i64]* @larr1, i64 0, i64 %add8
  store i64 %add5.lcssa, i64* %arrayidx9, align 8
  %inc11 = add nuw nsw i64 %l1.025, 1
  %exitcond26.not = icmp eq i64 %inc11, 100
  br i1 %exitcond26.not, label %for.end12, label %for.cond1.preheader

for.end12:                                        ; preds = %for.end
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
