; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -disable-output -enable-vplan-outer-loop-hir -print-before=hir-vplan-vec -print-after=hir-vplan-vec -hir-details -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,print<hir>,hir-vplan-vec,print<hir>" -disable-output -enable-vplan-outer-loop-hir -hir-details -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
;
; LIT test to check livein/liveout information of generated vector loop.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@larr2 = dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16
@larr1 = dso_local local_unnamed_addr global [100 x i64] zeroinitializer, align 16

; Function Attrs: nofree norecurse nosync nounwind uwtable
define dso_local void @foo(i64 %n1, i64 %n2) local_unnamed_addr #0 {
; CHECK:       + LiveIn symbases: 9, 10, 16, 17
; CHECK:       + LiveOut symbases:
; CHECK:       + Loop metadata: No
; CHECK:       + DO i64 i1 = 0, 99, 1   <DO_LOOP> <simd>
; CHECK:       |   %sum.024 = 0;
; CHECK:       |   <LVAL-REG> i64 0 {sb:3}
; CHECK:       |   + LiveIn symbases: 3, 9, 10
; CHECK:       |   + LiveOut symbases: 3
; CHECK:       |   + Loop metadata: No
; CHECK:       |   + DO i64 i2 = 0, 99, 1   <DO_LOOP>
; CHECK:       |   |   %0 = (@larr2)[0][i2 + 2 * %n2][i1];
; CHECK:       |   |      <BLOB> LINEAR [100 x [100 x i64]]* @larr2 {sb:9}
; CHECK:       |   |      <BLOB> LINEAR i64 %n2 {sb:10}
; CHECK:       |   |   %sum.024 = %0  +  %sum.024;
; CHECK:       |   |   <LVAL-REG> NON-LINEAR i64 %sum.024 {sb:3}
; CHECK:       |   |   <RVAL-REG> NON-LINEAR i64 %sum.024 {sb:3}
; CHECK:       |   + END LOOP
; CHECK:       |   (@larr1)[0][i1 + 2 * %n2 + %n1] = %sum.024;
; CHECK:       |      <BLOB> LINEAR i64 %n1 {sb:17}
; CHECK:       |      <BLOB> LINEAR [100 x i64]* @larr1 {sb:16}
; CHECK:       |      <BLOB> LINEAR i64 %n2 {sb:10}
; CHECK:       |   <RVAL-REG> NON-LINEAR i64 %sum.024 {sb:3}
; CHECK:       + END LOOP
;
; CHECK:       + LiveIn symbases: 9, 10, 16, 17
; CHECK:       + LiveOut symbases:
; CHECK:       + Loop metadata:
; CHECK:       + DO i64 i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK:       |   %.copy = 0;
; CHECK:       |   %phi.temp = %.copy;
; CHECK:       |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK:       |   %phi.temp4 = 0;
; CHECK:       |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp4 {sb:24}
; CHECK:       |   + LiveIn symbases: 9, 10, 23, 24
; CHECK:       |   + LiveOut symbases: 29
; CHECK:       |   + Loop metadata:
; CHECK:       |   + DO i64 i2 = 0, 99, 1   <DO_LOOP> <novectorize>
; CHECK:       |   |   %.vec = (<4 x i64>*)(@larr2)[0][i2 + 2 * %n2][i1];
; CHECK:       |   |      <BLOB> LINEAR [100 x [100 x i64]]* @larr2 {sb:9}
; CHECK:       |   |   %.vec6 = i2 + 1 < 100;
; CHECK:       |   |   %phi.temp = %phi.temp + %.vec;
; CHECK:       |   |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK:       |   |      <BLOB> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK:       |   |   %phi.temp4 = i2 + 1;
; CHECK:       |   |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp4 {sb:24}
; CHECK:       |   |   %phi.temp9 = %phi.temp + %.vec;
; CHECK:       |   |   <LVAL-REG> NON-LINEAR <4 x i64> %phi.temp9 {sb:29}
; CHECK:       |   |      <BLOB> NON-LINEAR <4 x i64> %phi.temp {sb:23}
; CHECK:       |   + END LOOP
; CHECK:       |   (<4 x i64>*)(@larr1)[0][i1 + 2 * %n2 + %n1] = %phi.temp9;
; CHECK:       |      <BLOB> LINEAR [100 x i64]* @larr1 {sb:16}
; CHECK:       |      <BLOB> LINEAR i64 %n2 {sb:10}
; CHECK:       |      <BLOB> LINEAR i64 %n1 {sb:17}
; CHECK:       |   <RVAL-REG> NON-LINEAR <4 x i64> %phi.temp9 {sb:29}
; CHECK:       + END LOOP
;
entry:
  %mul = shl nsw i64 %n2, 1
  %add7 = add nsw i64 %mul, %n1
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.end
  %l1.025 = phi i64 [ 0, %entry ], [ %inc11, %for.end ]
  br label %for.body3

for.body3:                                        ; preds = %for.cond1.preheader, %for.body3
  %sum.024 = phi i64 [ 0, %for.cond1.preheader ], [ %add5, %for.body3 ]
  %l2.023 = phi i64 [ 0, %for.cond1.preheader ], [ %inc, %for.body3 ]
  %add = add nsw i64 %l2.023, %mul
  %arrayidx4 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @larr2, i64 0, i64 %add, i64 %l1.025
  %0 = load i64, i64* %arrayidx4, align 8
  %add5 = add nsw i64 %0, %sum.024
  %inc = add nuw nsw i64 %l2.023, 1
  %exitcond.not = icmp eq i64 %inc, 100
  br i1 %exitcond.not, label %for.end, label %for.body3

for.end:                                          ; preds = %for.body3
  %add5.lcssa = phi i64 [ %add5, %for.body3 ]
  %add8 = add nsw i64 %add7, %l1.025
  %arrayidx9 = getelementptr inbounds [100 x i64], [100 x i64]* @larr1, i64 0, i64 %add8
  store i64 %add5.lcssa, i64* %arrayidx9, align 8
  %inc11 = add nuw nsw i64 %l1.025, 1
  %exitcond26.not = icmp eq i64 %inc11, 100
  br i1 %exitcond26.not, label %for.end12, label %for.cond1.preheader

for.end12:                                        ; preds = %for.end
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
