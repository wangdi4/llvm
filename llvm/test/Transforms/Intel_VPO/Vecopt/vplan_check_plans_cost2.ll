; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -mattr=+avx512f -passes=vplan-vec -vplan-print-after-evaluator -vplan-enable-peeling -vplan-enable-general-peeling-cost-model -disable-output -vplan-enable-masked-vectorized-remainder=0 -vplan-enable-non-masked-vectorized-remainder=0 %s 2>&1 | FileCheck %s --check-prefix=SCALAR-PEEL-REMAINDER

; RUN: opt -S -mattr=+avx512f -passes=vplan-vec -vplan-print-after-evaluator -vplan-enable-peeling -vplan-enable-general-peeling-cost-model  -vplan-enable-vectorized-peel -disable-output -vplan-enable-masked-vectorized-remainder=0 -vplan-enable-non-masked-vectorized-remainder=0 %s 2>&1 | FileCheck %s --check-prefix=VECTOR-PEEL

; RUN: opt -S -mattr=+avx512f -passes=vplan-vec -vplan-print-after-evaluator -vplan-enable-peeling -vplan-enable-general-peeling-cost-model  -vplan-enable-vectorized-peel -vplan-enable-masked-vectorized-remainder -vplan-masked-remainder-gain-threshold=0 -disable-output -vplan-enable-non-masked-vectorized-remainder=0 %s 2>&1 | FileCheck %s --check-prefix=MASKED-PEEL-REMAINDER
target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "x86_64-unknown-linux-gnu"

define void @test2(i64* %array) {
; SCALAR-PEEL-REMAINDER-LABEL:  Evaluators for VF=2
; SCALAR-PEEL-REMAINDER-NEXT:  The peel loop is scalar (dynamic) with estimated trip count 1. The scalar cost is 3(1 x 3).
; SCALAR-PEEL-REMAINDER-NEXT:  The main loop is vectorized with vector factor 2. The vector cost is 584151(194717 x 3 + 0).
; SCALAR-PEEL-REMAINDER-NEXT:  The remainder loop is scalar with estimated trip count 1. The scalar cost is 3(1 x 3).
; SCALAR-PEEL-REMAINDER-NEXT:  Evaluators for VF=4
; SCALAR-PEEL-REMAINDER-NEXT:  The peel loop is scalar (dynamic) with estimated trip count 3. The scalar cost is 9(3 x 3).
; SCALAR-PEEL-REMAINDER-NEXT:  The main loop is vectorized with vector factor 4. The vector cost is 292074(97358 x 3 + 0).
; SCALAR-PEEL-REMAINDER-NEXT:  The remainder loop is scalar with estimated trip count 3. The scalar cost is 9(3 x 3).
; SCALAR-PEEL-REMAINDER-NEXT:  Evaluators for VF=8
; SCALAR-PEEL-REMAINDER-NEXT:  The peel loop is scalar (dynamic) with estimated trip count 7. The scalar cost is 21(7 x 3).
; SCALAR-PEEL-REMAINDER-NEXT:  The main loop is vectorized with vector factor 8. The vector cost is 146034(48678 x 3 + 0).
; SCALAR-PEEL-REMAINDER-NEXT:  The remainder loop is scalar with estimated trip count 7. The scalar cost is 21(7 x 3).
;
; VECTOR-PEEL-LABEL:  Evaluators for VF=2
; VECTOR-PEEL-NEXT:  The peel loop is scalar (dynamic) with estimated trip count 1. The scalar cost is 3(1 x 3).
; VECTOR-PEEL-NEXT:  The main loop is vectorized with vector factor 2. The vector cost is 584151(194717 x 3 + 0).
; VECTOR-PEEL-NEXT:  The remainder loop is scalar with estimated trip count 1. The scalar cost is 3(1 x 3).
; VECTOR-PEEL-NEXT:  Evaluators for VF=4
; VECTOR-PEEL-NEXT:  The peel loop is scalar (dynamic) with estimated trip count 3. The scalar cost is 9(3 x 3).
; VECTOR-PEEL-NEXT:  The main loop is vectorized with vector factor 4. The vector cost is 292074(97358 x 3 + 0).
; VECTOR-PEEL-NEXT:  The remainder loop is scalar with estimated trip count 3. The scalar cost is 9(3 x 3).
; VECTOR-PEEL-NEXT:  Evaluators for VF=8
; VECTOR-PEEL-NEXT:  The peel loop (dynamic) has estimated trip count 7 and it is vectorized with a mask. The vector cost is 12.
; VECTOR-PEEL-NEXT:  The main loop is vectorized with vector factor 8. The vector cost is 146034(48678 x 3 + 0).
; VECTOR-PEEL-NEXT:  The remainder loop is scalar with estimated trip count 7. The scalar cost is 21(7 x 3).
;
; MASKED-PEEL-REMAINDER-LABEL:  Evaluators for VF=2
; MASKED-PEEL-REMAINDER-NEXT:  The peel loop is scalar (dynamic) with estimated trip count 1. The scalar cost is 3(1 x 3).
; MASKED-PEEL-REMAINDER-NEXT:  The main loop is vectorized with vector factor 2. The vector cost is 584151(194717 x 3 + 0).
; MASKED-PEEL-REMAINDER-NEXT:  The remainder loop is scalar with estimated trip count 1. The scalar cost is 3(1 x 3).
; MASKED-PEEL-REMAINDER-NEXT:  Evaluators for VF=4
; MASKED-PEEL-REMAINDER-NEXT:  The peel loop is scalar (dynamic) with estimated trip count 3. The scalar cost is 9(3 x 3).
; MASKED-PEEL-REMAINDER-NEXT:  The main loop is vectorized with vector factor 4. The vector cost is 292074(97358 x 3 + 0).
; MASKED-PEEL-REMAINDER-NEXT:  The remainder loop has estimated trip count 3 and it is vectorized with a mask. The vector cost is 8.
; MASKED-PEEL-REMAINDER-NEXT:  Evaluators for VF=8
; MASKED-PEEL-REMAINDER-NEXT:  The peel loop (dynamic) has estimated trip count 7 and it is vectorized with a mask. The vector cost is 12.
; MASKED-PEEL-REMAINDER-NEXT:  The main loop is vectorized with vector factor 8. The vector cost is 146034(48678 x 3 + 0).
; MASKED-PEEL-REMAINDER-NEXT:  The remainder loop has estimated trip count 7 and it is vectorized with a mask. The vector cost is 8.
;
entry:
  br label %preheader

preheader:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header
header:
  %iv = phi i64 [ 0, %preheader ], [ %iv.next, %latch ]
  %ptr = getelementptr inbounds i64, i64* %array, i64 %iv
  store i64 %iv, i64* %ptr, align 8
  br label %latch

latch:
  %iv.next = add nsw i64 %iv, 1
  %bottom_test = icmp eq i64 %iv.next, 389435
  br i1 %bottom_test, label %loopexit, label %header

loopexit:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret void
}

declare token @llvm.directive.region.entry() nounwind
declare void @llvm.directive.region.exit(token) nounwind

