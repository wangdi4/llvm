; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; RUN: opt -S -passes=vplan-vec %s 2>&1 | FileCheck  %s
;
; Test to check correct placement of original trip count instruction. The test used
; to crash before a fix in CG with new scheme to create OriginalTripCount in the
; original loop preheader instead of in a new basic block.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nounwind uwtable
define dso_local i64 @foo(ptr nocapture %larr, i32 %n1) local_unnamed_addr #0 {
; CHECK:  define dso_local i64 @foo(ptr nocapture [[LARR0:%.*]], i32 [[N10:%.*]]) local_unnamed_addr {
; CHECK:         [[DIV0:%.*]] = sdiv i64 [[TC_0390:%.*]], 2
; CHECK:       VPlannedBB:
; CHECK-NEXT:    [[TMP0:%.*]] = and i64 [[DIV0]], 4294967292
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 0, [[TMP0]]
; CHECK:       VPlannedBB6:
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[DIV0]], [[TMP2:%.*]]

entry:
  %l1.linear.iv = alloca i64, align 8
  %conv = sext i32 %n1 to i64
  %cmp37 = icmp sgt i32 %n1, 0
  br i1 %cmp37, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %omp.precond.end
  %l2.040 = phi i64 [ %inc, %omp.precond.end ], [ 0, %for.body.preheader ]
  %tc.039 = phi i64 [ %div, %omp.precond.end ], [ %conv, %for.body.preheader ]
  %l1.038 = phi i64 [ %l1.2, %omp.precond.end ], [ undef, %for.body.preheader ]
  %div = sdiv i64 %tc.039, 2
  %cmp8.not30 = icmp slt i64 %tc.039, 2
  br i1 %cmp8.not30, label %omp.precond.end, label %omp.inner.for.body.lr.ph

omp.inner.for.body.lr.ph:                         ; preds = %for.body
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4), "QUAL.OMP.LINEAR:IV.TYPED"(ptr %l1.linear.iv, i32 0, i32 1, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body.lr.ph, %omp.inner.for.body
  %.omp.iv.local.031 = phi i64 [ 0, %omp.inner.for.body.lr.ph ], [ %add13, %omp.inner.for.body ]
  %ptridx = getelementptr inbounds i64, ptr %larr, i64 %.omp.iv.local.031
  %1 = load i64, ptr %ptridx, align 8
  %add11 = add nsw i64 %1, 1
  store i64 %add11, ptr %ptridx, align 8
  %add13 = add nuw nsw i64 %.omp.iv.local.031, 1
  %exitcond.not = icmp eq i64 %add13, %div
  br i1 %exitcond.not, label %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge, label %omp.inner.for.body

omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge: ; preds = %omp.inner.for.body
  store i64 %div, ptr %l1.linear.iv, align 8
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:                               ; preds = %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.1, %for.body
  %l1.2 = phi i64 [ %l1.038, %for.body ], [ %div, %DIR.OMP.END.SIMD.1 ]
  %inc = add nuw nsw i64 %l2.040, 1
  %exitcond42.not = icmp eq i64 %inc, %conv
  br i1 %exitcond42.not, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %omp.precond.end
  %l1.2.lcssa = phi i64 [ %l1.2, %omp.precond.end ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %l1.0.lcssa = phi i64 [ undef, %entry ], [ %l1.2.lcssa, %for.end.loopexit ]
  ret i64 %l1.0.lcssa
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1


