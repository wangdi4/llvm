; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt < %s -disable-output -opaque-pointers -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -vplan-print-after-plain-cfg -disable-vplan-codegen | FileCheck %s
; RUN: opt < %s -disable-output -opaque-pointers -passes='hir-ssa-deconstruction,hir-vplan-vec' -vplan-print-after-plain-cfg -disable-vplan-codegen | FileCheck %s
%S = type { ptr }

define void @foo(ptr %p1, ptr %p2) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: foo:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%p1}
; CHECK-DAG:     [[VP1:%.*]] = {%p2}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript ptr [[P10:%.*]] i64 [[VP2]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_1:%.*]] = subscript ptr [[P20:%.*]] i64 [[VP2]]
; This bitcast crashes in the VPlan HIR CG.
; CHECK-NEXT:     ptr [[VP4:%.*]] = bitcast ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     store ptr [[VP_SUBSCRIPT]] ptr [[VP4]]
; CHECK-NEXT:     i64 [[VP3]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i1 [[VP5:%.*]] = icmp slt i64 [[VP3]] i64 6
; CHECK-NEXT:     br i1 [[VP5]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 2) ]
  br label %header

header:
  %iv = phi i64 [0, %entry], [%iv.next, %latch]
  %gep1 = getelementptr %S, ptr %p1, i64 %iv
  %gep2 = getelementptr %S, ptr %p2, i64 %iv
  store ptr %gep1, ptr %gep2
  br label %latch

latch:
  %iv.next = add nsw nuw i64 %iv, 1
  %cmp = icmp eq i64 %iv.next, 6
  br i1 %cmp, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @bar(ptr %p1, ptr %p2) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: bar:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%p1}
; CHECK-DAG:     [[VP1:%.*]] = {%p2}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CHECK-NEXT:     double [[VP_LOAD:%.*]] = load ptr [[P10:%.*]]
; CHECK-NEXT:     double [[VP4:%.*]] = fadd double [[VP_LOAD]] double [[VP_LOAD]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript ptr [[P20:%.*]] i64 [[VP2]]
; CHECK-NEXT:     ptr [[VP5:%.*]] = bitcast ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     store double [[VP4]] ptr [[VP5]]
; CHECK-NEXT:     i64 [[VP3]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i1 [[VP6:%.*]] = icmp slt i64 [[VP3]] i64 32
; CHECK-NEXT:     br i1 [[VP6]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 2) ]
  br label %header

header:
  %iv = phi i64 [0, %entry], [%iv.next, %latch]
  %gep1 = getelementptr %S, ptr %p1, i64 %iv
  %ld = load double, ptr %p1
  %add = fadd double %ld, %ld
  %gep2 = getelementptr %S, ptr %p2, i64 %iv
  store double %add, ptr %gep2
  br label %latch

latch:
  %iv.next = add nsw nuw i64 %iv, 1
  %cmp = icmp eq i64 %iv.next, 32
  br i1 %cmp, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
