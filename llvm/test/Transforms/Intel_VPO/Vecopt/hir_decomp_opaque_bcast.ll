; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt < %s -disable-output -opaque-pointers -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -vplan-print-after-plain-cfg -hir-details 2>&1 | FileCheck %s
%S = type { ptr }

define void @foo(ptr %p1, ptr %p2) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: foo:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%p1}
; CHECK-DAG:     [[VP1:%.*]] = {%p2}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript ptr [[P10:%.*]] i64 [[VP2]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_1:%.*]] = subscript ptr [[P20:%.*]] i64 [[VP2]]
; CHECK-NEXT:     store ptr [[VP_SUBSCRIPT]] ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i64 [[VP3]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i1 [[VP4:%.*]] = icmp slt i64 [[VP3]] i64 32
; CHECK-NEXT:     br i1 [[VP4]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
; CHECK:       BEGIN REGION { modified }
; CHECK-NEXT:        + Ztt: No
; CHECK-NEXT:        + NumExits: 1
; CHECK-NEXT:        + Innermost: Yes
; CHECK-NEXT:        + HasSignedIV: Yes
; CHECK-NEXT:        + LiveIn symbases: 7, 8
; CHECK-NEXT:        + LiveOut symbases:
; CHECK-NEXT:        + Loop metadata: !llvm.loop
; CHECK-NEXT:        + DO i64 i1 = 0, 31, 2   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   (<2 x ptr>*)([[P20]])[i1] = &((<2 x ptr>)([[P10]])[i1 + <i64 0, i64 1>])
; CHECK-NEXT:        |   <LVAL-REG> {al:8}(<2 x ptr>*)(LINEAR ptr [[P20]])[LINEAR i64 i1] {sb:11}
; CHECK-NEXT:        |      <BLOB> LINEAR ptr [[P20]] {sb:8}
; CHECK-NEXT:        |   <RVAL-REG> &((<2 x ptr>)(LINEAR ptr [[P10]])[LINEAR <2 x i64> i1 + <i64 0, i64 1>]) {sb:12}
; CHECK-NEXT:        |      <BLOB> LINEAR ptr [[P10]] {sb:7}
; CHECK-NEXT:        |
; CHECK-NEXT:        + END LOOP
; CHECK:             ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 2) ]
  br label %header

header:
  %iv = phi i64 [0, %entry], [%iv.next, %latch]
  %gep1 = getelementptr %S, ptr %p1, i64 %iv
  %gep2 = getelementptr %S, ptr %p2, i64 %iv
  store ptr %gep1, ptr %gep2
  br label %latch

latch:
  %iv.next = add nsw nuw i64 %iv, 1
  %cmp = icmp eq i64 %iv.next, 32
  br i1 %cmp, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @bar(ptr %p1, ptr %p2) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: bar:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%p1}
; CHECK-DAG:     [[VP1:%.*]] = {%p2}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[P10:%.*]]
; CHECK-NEXT:     double [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     double [[VP4:%.*]] = fadd double [[VP_LOAD]] double [[VP_LOAD]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript ptr [[P20:%.*]] i64 [[VP2]]
; CHECK-NEXT:     store double [[VP4]] ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP3]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i1 [[VP5:%.*]] = icmp slt i64 [[VP3]] i64 32
; CHECK-NEXT:     br i1 [[VP5]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
; CHECK:       BEGIN REGION { modified }
; CHECK-NEXT:        + Ztt: No
; CHECK-NEXT:        + NumExits: 1
; CHECK-NEXT:        + Innermost: Yes
; CHECK-NEXT:        + HasSignedIV: Yes
; CHECK-NEXT:        + LiveIn symbases: 6, 10
; CHECK-NEXT:        + LiveOut symbases:
; CHECK-NEXT:        + Loop metadata: !llvm.loop
; CHECK-NEXT:        + DO i64 i1 = 0, 31, 2   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTUNIFLOAD0:%.*]] = ([[P10]])[0]
; CHECK-NEXT:        |   <LVAL-REG> NON-LINEAR double [[DOTUNIFLOAD0]] {sb:15}
; CHECK-NEXT:        |   <RVAL-REG> {al:8}(LINEAR ptr [[P10]])[i32 0] inbounds  {sb:13}
; CHECK-NEXT:        |      <BLOB> LINEAR ptr [[P10]] {sb:6}
; CHECK-NEXT:        |
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = [[DOTUNIFLOAD0]]  +  [[DOTUNIFLOAD0]]
; CHECK-NEXT:        |   <LVAL-REG> NON-LINEAR <2 x double> [[DOTVEC0]] {sb:16}
; CHECK-NEXT:        |   <RVAL-REG> NON-LINEAR <2 x double> [[DOTUNIFLOAD0]] {sb:15}
; CHECK-NEXT:        |   <RVAL-REG> NON-LINEAR <2 x double> [[DOTUNIFLOAD0]] {sb:15}
; CHECK-NEXT:        |
; CHECK-NEXT:        |   (<2 x double>*)([[P20]])[i1] = [[DOTVEC0]]
; CHECK-NEXT:        |   <LVAL-REG> {al:8}(<2 x double>*)(LINEAR ptr [[P20]])[LINEAR i64 i1] {sb:13}
; CHECK-NEXT:        |      <BLOB> LINEAR ptr [[P20]] {sb:10}
; CHECK-NEXT:        |   <RVAL-REG> NON-LINEAR <2 x double> [[DOTVEC0]] {sb:16}
; CHECK-NEXT:        |
; CHECK-NEXT:        + END LOOP
; CHECK:             ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 2) ]
  br label %header

header:
  %iv = phi i64 [0, %entry], [%iv.next, %latch]
  %gep1 = getelementptr %S, ptr %p1, i64 %iv
  %ld = load double, ptr %p1
  %add = fadd double %ld, %ld
  %gep2 = getelementptr %S, ptr %p2, i64 %iv
  store double %add, ptr %gep2
  br label %latch

latch:
  %iv.next = add nsw nuw i64 %iv, 1
  %cmp = icmp eq i64 %iv.next, 32
  br i1 %cmp, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
