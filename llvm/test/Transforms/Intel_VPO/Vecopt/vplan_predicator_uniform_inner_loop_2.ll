; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: asserts
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2 -disable-output -vplan-print-after-linearization -enable-vp-value-codegen=0 | FileCheck %s --check-prefixes=CHECK,CHECK-LLVM
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2 -disable-output -vplan-print-after-linearization -enable-vp-value-codegen=1 | FileCheck %s --check-prefixes=CHECK,CHECK-VPVALUE

; Check that we have proper bypasses of the inner loop when it should not be entered.

define void @foo(i32 %n1, i32 %n2) {
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    REGION: [[REGION0:region[0-9]+]] (BP: NULL)
; CHECK-NEXT:    [[BB0:BB[0-9]+]] (BP: NULL) :
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]] (BP: NULL) :
; CHECK-LLVM-NEXT:       <Empty Block>
; CHECK-VPVALUE-NEXT:     [DA: Divergent] i64 [[VP0:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-VPVALUE-NEXT:     [DA: Uniform]   i64 [[VP1:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]] (BP: NULL) :
; CHECK-LLVM-NEXT:     [DA: Divergent] i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ],  [ i64 0, [[BB1]] ]
; CHECK-VPVALUE-NEXT:     [DA: Divergent] i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ],  [ i64 [[VP0]], [[BB1]] ]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP2:%.*]] = trunc i64 [[VP_INDVARS_IV]] to i32
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]] (BP: NULL) :
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:     Condition(external): i1 [[CMP10:%.*]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB5:BB[0-9]+]](i1 [[CMP10]]), [[BB6:BB[0-9]+]](!i1 [[CMP10]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]] (BP: NULL) :
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]] (BP: NULL) :
; CHECK-NEXT:       [DA: Uniform]   i32 [[VP_I1_014:%.*]] = phi  [ i32 [[VP_INC:%.*]], [[BB8:BB[0-9]+]] ],  [ i32 0, [[BB5]] ]
; CHECK-NEXT:       [DA: Uniform]   i32 [[VP_CALL:%.*]] = call i32 (...)* @baz
; CHECK-NEXT:       [DA: Uniform]   i32 [[VP_INC]] = add i32 [[VP_I1_014]] i32 1
; CHECK-NEXT:       [DA: Uniform]   i1 [[VP_EXITCOND:%.*]] = icmp i32 [[VP_INC]] i32 1024
; CHECK-NEXT:      SUCCESSORS(1):[[BB8]]
; CHECK-NEXT:      PREDECESSORS(2): [[BB8]] [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]] (BP: NULL) :
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:       Condition([[BB7]]): [DA: Uniform]   i1 [[VP_EXITCOND]] = icmp i32 [[VP_INC]] i32 1024
; CHECK-NEXT:      SUCCESSORS(2):[[BB7]](i1 [[VP_EXITCOND]]), [[BB9:BB[0-9]+]](!i1 [[VP_EXITCOND]])
; CHECK-NEXT:      PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB9]] (BP: NULL) :
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[BB6]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]] (BP: NULL) :
; CHECK-LLVM-NEXT:     [DA: Divergent] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 1
; CHECK-VPVALUE-NEXT:  [DA: Divergent] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP1]]
; CHECK-NEXT:     [DA: Uniform]   i1 [[VP_EXITCOND15:%.*]] = icmp i64 [[VP_INDVARS_IV_NEXT]] i64 1024
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB9]] [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]] (BP: NULL) :
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:     Condition([[BB6]]): [DA: Uniform]   i1 [[VP_EXITCOND15]] = icmp i64 [[VP_INDVARS_IV_NEXT]] i64 1024
; CHECK-NEXT:    SUCCESSORS(2):[[BB10:BB[0-9]+]](i1 [[VP_EXITCOND15]]), [[BB2]](!i1 [[VP_EXITCOND15]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]] (BP: NULL) :
; CHECK-LLVM-NEXT:        <Empty Block>
; CHECK-VPVALUE-NEXT:     [DA: Uniform]   i64 [[VP3:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]] (BP: NULL) :
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    END Region([[REGION0]])
;
outer.for.lr.ph:
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %outer.for.lr.ph
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  br label %DIR.OMP.SIMD.2

DIR.OMP.SIMD.2:                                   ; preds = %DIR.OMP.SIMD.1
  %cmp1 = icmp sgt i32 %n1, %n2
  br label %outer.for

outer.for:                               ; preds = %outer.for.inc, %DIR.OMP.SIMD.2
  %indvars.iv = phi i64 [ %indvars.iv.next, %outer.for.inc ], [ 0, %DIR.OMP.SIMD.2 ]
  %1 = trunc i64 %indvars.iv to i32
  br i1 %cmp1, label %for.body.preheader, label %outer.for.inc

for.body.preheader:                               ; preds = %outer.for
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i1.014 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %call = call i32 (...) @baz() #1
  %inc = add nuw nsw i32 %i1.014, 1
  %exitcond = icmp ult i32 %inc, 1024
  br i1 %exitcond, label %for.body, label %outer.for.inc.loopexit

outer.for.inc.loopexit:                       ; preds = %for.body
  br label %outer.for.inc

outer.for.inc:                                ; preds = %outer.for.inc.loopexit, %outer.for
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond15 = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond15, label %DIR.OMP.END.SIMD.4, label %outer.for

DIR.OMP.END.SIMD.4:                               ; preds = %outer.for.inc
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %DIR.OMP.END.SIMD.4
  ret void
}
; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

declare i32 @baz(...) readonly nounwind
