; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: asserts
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2 -disable-output -vplan-print-after-linearization | FileCheck %s

; Check that we have proper bypasses of the inner loop when it should not be entered.

define void @foo(i32 %n1, i32 %n2) {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    REGION: [[REGION0:region[0-9]+]]
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Divergent] i64 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     [DA: Uniform]   i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Divergent] i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ],  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP0:%.*]] = trunc i64 [[VP_INDVARS_IV]] to i32
; CHECK-NEXT:     Condition(external): i1 [[CMP10:%.*]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB4:BB[0-9]+]](i1 [[CMP10]]), [[BB3]](!i1 [[CMP10]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Uniform]   i32 [[VP_I1_014:%.*]] = phi  [ i32 [[VP_INC:%.*]], [[BB5]] ],  [ i32 0, [[BB4]] ]
; CHECK-NEXT:       [DA: Uniform]   i32 [[VP_CALL:%.*]] = call i32 (...)* @baz
; CHECK-NEXT:       [DA: Uniform]   i32 [[VP_INC]] = add i32 [[VP_I1_014]] i32 1
; CHECK-NEXT:       [DA: Uniform]   i1 [[VP_EXITCOND:%.*]] = icmp i32 [[VP_INC]] i32 1024
; CHECK-NEXT:      SUCCESSORS(2):[[BB5]](i1 [[VP_EXITCOND]]), [[BB6:BB[0-9]+]](!i1 [[VP_EXITCOND]])
; CHECK-NEXT:      PREDECESSORS(2): [[BB5]] [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Divergent] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uniform]   i1 [[VP_EXITCOND15:%.*]] = icmp i64 [[VP_INDVARS_IV_NEXT]] i64 1024
; CHECK-NEXT:    SUCCESSORS(2):[[BB7:BB[0-9]+]](i1 [[VP_EXITCOND15]]), [[BB2]](!i1 [[VP_EXITCOND15]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB6]] [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Uniform]   i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    END Region([[REGION0]])
;
outer.for.lr.ph:
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %outer.for.lr.ph
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  br label %DIR.OMP.SIMD.2

DIR.OMP.SIMD.2:                                   ; preds = %DIR.OMP.SIMD.1
  %cmp1 = icmp sgt i32 %n1, %n2
  br label %outer.for

outer.for:                               ; preds = %outer.for.inc, %DIR.OMP.SIMD.2
  %indvars.iv = phi i64 [ %indvars.iv.next, %outer.for.inc ], [ 0, %DIR.OMP.SIMD.2 ]
  %1 = trunc i64 %indvars.iv to i32
  br i1 %cmp1, label %for.body.preheader, label %outer.for.inc

for.body.preheader:                               ; preds = %outer.for
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i1.014 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %call = call i32 (...) @baz() #1
  %inc = add nuw nsw i32 %i1.014, 1
  %exitcond = icmp ult i32 %inc, 1024
  br i1 %exitcond, label %for.body, label %outer.for.inc.loopexit

outer.for.inc.loopexit:                       ; preds = %for.body
  br label %outer.for.inc

outer.for.inc:                                ; preds = %outer.for.inc.loopexit, %outer.for
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond15 = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond15, label %DIR.OMP.END.SIMD.4, label %outer.for

DIR.OMP.END.SIMD.4:                               ; preds = %outer.for.inc
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %DIR.OMP.END.SIMD.4
  ret void
}
; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

declare i32 @baz(...) readonly nounwind
