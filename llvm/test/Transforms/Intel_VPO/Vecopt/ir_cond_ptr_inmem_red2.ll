; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check we correctly parse in memory reductions which are
; conditionally updated by their pointers when pointers come through aliases
; ouside of the loop.

; The source test looks like
;
; int r = 0, r2 = 0;
; int *pr = m ? &r : &r2;
; #pragma omp simd reduction(+:r,r2)
; for (int i=0; i < 1000; i++) {
;   *pr += a[i];
; }
;
; RUN: opt -disable-output -passes=vplan-vec -vplan-force-vf=2 -vplan-print-after-vpentity-instrs %s 2>&1 | FileCheck %s
;
define dso_local i32 @_Z3zooPiS_(i1 %m, ptr nocapture noundef readonly %a) {
;
; CHECK-LABEL: VPlan IR for: _Z3zooPiS_:omp.inner.for.body
; loop preheader
; CHECK:     ptr [[VP_R2_RED:%.*]] = allocate-priv i32, OrigAlign = 4
; CHECK:     ptr [[VP_R_RED:%.*]] = allocate-priv i32, OrigAlign = 4
; CHECK:     ptr [[VP_RA_RED:%.*]] = getelementptr inbounds i32, ptr [[R_RED0:%.*]] i32 0
; CHECK:     i32 [[VP_LOAD:%.*]] = load ptr [[R_RED0]]
; CHECK:     i32 [[VP_R_REDRED_INIT:%.*]] = reduction-init i32 0 i32 [[VP_LOAD]]
; CHECK:     store i32 [[VP_R_REDRED_INIT]] ptr [[VP_R_RED]]
; CHECK:     ptr [[VP_R2A_RED:%.*]] = getelementptr inbounds i32, ptr [[R2_RED0:%.*]] i32 0
; CHECK:     i32 [[VP_LOAD_1:%.*]] = load ptr [[R2_RED0]]
; CHECK:     i32 [[VP_R2_REDRED_INIT:%.*]] = reduction-init i32 0 i32 [[VP_LOAD_1]]
; CHECK:     store i32 [[VP_R2_REDRED_INIT]] ptr [[VP_R2_RED]]
; loop body
; CHECK:     ptr [[VP_PR_PRIV_0:%.*]] = select i1 [[M0:%.*]] ptr [[VP_RA_RED]] ptr [[VP_R2A_RED]]
; CHECK:     store i32 [[VP_ADD7:%.*]] ptr [[VP_PR_PRIV_0]]
; loop exit
; CHECK:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_R_RED]]
; CHECK:     i32 [[VP_R_REDRED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_LOAD_2]]
; CHECK:     store i32 [[VP_R_REDRED_FINAL]] ptr [[R_RED0]]
; CHECK:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_R2_RED]]
; CHECK:     i32 [[VP_R2_REDRED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_LOAD_3]]
; CHECK:     store i32 [[VP_R2_REDRED_FINAL]] ptr [[R2_RED0]]
;
DIR.OMP.SIMD.216:
  %r2.red = alloca i32, align 4
  %r.red = alloca i32, align 4
  %i.linear.iv = alloca i32, align 4
  store i32 0, ptr %r2.red, align 4
  store i32 0, ptr %r.red, align 4
  %ra.red = getelementptr inbounds i32, ptr %r.red, i32 0
  %r2a.red = getelementptr inbounds i32, ptr %r2.red, i32 0
  br label %omp.inner.for.body.lr.ph

omp.inner.for.body.lr.ph:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD:TYPED"(ptr %r.red, i32 0, i32 1), "QUAL.OMP.REDUCTION.ADD:TYPED"(ptr %r2.red, i32 0, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:
  %indvars.iv = phi i64 [ 0, %omp.inner.for.body.lr.ph ], [ %indvars.iv.next, %if.end ]
  br label %if.end

if.end:
  %pr.priv.0 = select i1 %m, ptr %ra.red, ptr %r2a.red
  %arrayidx5 = getelementptr inbounds i32, ptr %a, i64 %indvars.iv
  %ld4 = load i32, ptr %arrayidx5, align 4
  %ld5 = load i32, ptr %pr.priv.0, align 4
  %add7 = add nsw i32 %ld5, %ld4
  store i32 %add7, ptr %pr.priv.0, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1000
  br i1 %exitcond.not, label %omp.inner.for.cond.DIR.OMP.END.SIMD.4.loopexit_crit_edge, label %omp.inner.for.body

omp.inner.for.cond.DIR.OMP.END.SIMD.4.loopexit_crit_edge:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:
  %ld6 = load i32, ptr %r.red, align 4
  %ld7 = load i32, ptr %r2.red, align 4
  %r = add i32 %ld6, %ld7
  ret i32 %r
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
