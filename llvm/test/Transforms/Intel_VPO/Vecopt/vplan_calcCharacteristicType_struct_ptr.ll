; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -disable-output -passes=vplan-vec -print-after=vplan-vec < %s 2>&1 | FileCheck %s

; Check that argument that is pointer to a structure does not crash calculation
; of mask type for a void function call.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.S = type { double, i32 }

; Function Attrs: uwtable
define dso_local <4 x i32> @_ZGVbN4v__Z3gooi(<4 x i32> %c) local_unnamed_addr {
; CHECK-LABEL: @_ZGVbN4v__Z3gooi(
entry:
  %a = alloca %struct.S, align 8
  %vec.c = alloca <4 x i32>, align 16
  %vec.retval = alloca <4 x i32>, align 16
  %vec.c.cast = bitcast <4 x i32>* %vec.c to i32*
  %ret.cast = bitcast <4 x i32>* %vec.retval to i32*
  store <4 x i32> %c, <4 x i32>* %vec.c, align 16
  br label %simd.begin.region

simd.begin.region:                                ; preds = %entry
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4), "QUAL.OMP.PRIVATE:TYPED"(%struct.S* %a, %struct.S zeroinitializer, i32 1) ]
  br label %simd.loop

simd.loop:                                        ; preds = %simd.loop.exit, %simd.begin.region
  %index = phi i32 [ 0, %simd.begin.region ], [ %indvar, %simd.loop.exit ]
  %vec.c.cast.gep = getelementptr i32, i32* %vec.c.cast, i32 %index
  %vec.c.elem = load i32, i32* %vec.c.cast.gep, align 4
  %tobool = icmp eq i32 %vec.c.elem, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %simd.loop
; Check that call is generated with mask of <4 x i64> type, with needed conversion
; CHECK:         [[WIDE_LOAD:%.*]] = load <4 x i32>, <4 x i32>* [[TMP0:%.*]], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <4 x i32> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    [[TMP2:%.*]] = xor <4 x i1> [[TMP1]], <i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    br label [[VPLANNEDBB4:%.*]]
; CHECK:       VPlannedBB3:
; CHECK-NEXT:    [[MASKEXT:%.*]] = sext <4 x i1> [[TMP2]] to <4 x i64>
; CHECK-NEXT:    call void @_ZGVbM4v__Z3fooP1S(<4 x %struct.S*> nonnull [[A_VEC_BASE_ADDR:%.*]], <4 x i64> [[MASKEXT]])
  call void @_Z3fooP1S(%struct.S* nonnull %a)
  %k = getelementptr inbounds %struct.S, %struct.S* %a, i64 0, i32 1
  %.pre = load i32, i32* %k, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %simd.loop
  %0 = phi i32 [ %.pre, %if.then ], [ 1, %simd.loop ]
  br label %simd.loop.exit

simd.loop.exit:                                   ; preds = %if.end
  %indvar = add nuw i32 %index, 1
  %vl.cond = icmp ult i32 %indvar, 4
  br i1 %vl.cond, label %simd.loop, label %simd.end.region

simd.end.region:                                  ; preds = %simd.loop.exit
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:                                           ; preds = %simd.end.region
  %vec.ret = load <4 x i32>, <4 x i32>* %vec.retval, align 16
  ret <4 x i32> %vec.ret
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

declare dso_local void @_Z3fooP1S(%struct.S*) #2

attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" "vector-variants"="_ZGVbN4v__Z3fooP1S,_ZGVcN4v__Z3fooP1S,_ZGVdN4v__Z3fooP1S,_ZGVeN4v__Z3fooP1S,_ZGVbM4v__Z3fooP1S,_ZGVcM4v__Z3fooP1S,_ZGVdM4v__Z3fooP1S,_ZGVeM4v__Z3fooP1S" }
