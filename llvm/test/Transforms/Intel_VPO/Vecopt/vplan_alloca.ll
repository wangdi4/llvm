; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -VPlanDriver -disable-output -vplan-print-after-linearization -vplan-force-vf=2 | FileCheck %s --check-prefix=LLVM
; RUN: opt < %s -S -VPlanDriver -vplan-force-vf=2 | FileCheck %s --check-prefix=LLVM-CG

; RUN: opt < %s -hir-framework -VPlanDriverHIR -disable-output -vplan-print-after-linearization -vplan-force-vf=2  | FileCheck %s --check-prefix=HIR
; RUN: opt < %s -S -hir-framework -VPlanDriverHIR  -vplan-force-vf=2  | FileCheck %s --check-prefix=HIR-CG

; Check that alloca is determined as divergent and correctly serialized (and
; uses are properly updated in the generated code). Note, that it's hard to
; simply widen due to runtime ArraySize and alignment properties, so the
; serialization is a reasonable choice.

define dso_local void @func(i32 %n) local_unnamed_addr {
; LLVM-LABEL:  After predication and linearization
; LLVM:     [DA: Divergent] i64 [[VP_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; LLVM:     [DA: Divergent] i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ],  [ i64 [[VP_IV_IND_INIT]], [[BB1:BB[0-9]+]] ]
; LLVM:     [DA: Divergent] [256 x i8]* [[VP_A_VAR:%.*]] = alloca i64 [[VP_IV]]
;
; LLVM-CG-LABEL:  vector.body:
; LLVM-CG-NEXT:    [[INDEX0:%.*]] = phi i64 [ 0, [[VECTOR_PH0:%.*]] ], [ [[INDEX_NEXT0:%.*]], [[PRED_ALLOCA_CONTINUE30:%.*]] ]
; LLVM-CG-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ [[TMP18:%.*]], [[PRED_ALLOCA_CONTINUE30]] ], [ 0, [[VECTOR_PH0]] ]
; LLVM-CG-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i64> [ [[TMP17:%.*]], [[PRED_ALLOCA_CONTINUE30]] ], [ <i64 0, i64 1>, [[VECTOR_PH0]] ]
; LLVM-CG-NEXT:    [[VEC_PHI_EXTRACT_1_0:%.*]] = extractelement <2 x i64> [[VEC_PHI0]], i32 1
; LLVM-CG-NEXT:    [[TMP0:%.*]] = icmp eq <2 x i64> [[VEC_PHI0]], <i64 42, i64 42>
; LLVM-CG-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr inbounds [256 x i8]*, [256 x i8]** [[STORAGE0:%.*]], i64 [[UNI_PHI0]]
; LLVM-CG-NEXT:    [[PREDICATE0:%.*]] = extractelement <2 x i1> [[TMP0]], i64 0
; LLVM-CG-NEXT:    [[TMP1:%.*]] = icmp eq i1 [[PREDICATE0]], true
; LLVM-CG-NEXT:    br i1 [[TMP1]], label [[PRED_ALLOCA_IF0:%.*]], label [[TMP4:%.*]]
; LLVM-CG-EMPTY:
; LLVM-CG-NEXT:  pred.alloca.if:
; LLVM-CG-NEXT:    [[TMP2:%.*]] = alloca [256 x i8], i64 [[UNI_PHI0]], align 16
; LLVM-CG-NEXT:    [[TMP3:%.*]] = insertelement <2 x [256 x i8]*> undef, [256 x i8]* [[TMP2]], i32 0
; LLVM-CG-NEXT:    br label [[TMP4]]
; LLVM-CG-EMPTY:
; LLVM-CG-NEXT:  4:
; LLVM-CG-NEXT:    [[TMP5:%.*]] = phi <2 x [256 x i8]*> [ undef, [[VECTOR_BODY0:%.*]] ], [ [[TMP3]], [[PRED_ALLOCA_IF0]] ]
; LLVM-CG-NEXT:    br label [[PRED_ALLOCA_CONTINUE0:%.*]]
; LLVM-CG-EMPTY:
; LLVM-CG-NEXT:  pred.alloca.continue:
; LLVM-CG-NEXT:    [[PREDICATE10:%.*]] = extractelement <2 x i1> [[TMP0]], i64 1
; LLVM-CG-NEXT:    [[TMP6:%.*]] = icmp eq i1 [[PREDICATE10]], true
; LLVM-CG-NEXT:    br i1 [[TMP6]], label [[PRED_ALLOCA_IF20:%.*]], label [[TMP9:%.*]]
; LLVM-CG-EMPTY:
; LLVM-CG-NEXT:  pred.alloca.if2:
; LLVM-CG-NEXT:    [[TMP7:%.*]] = alloca [256 x i8], i64 [[VEC_PHI_EXTRACT_1_0]], align 16
; LLVM-CG-NEXT:    [[TMP8:%.*]] = insertelement <2 x [256 x i8]*> [[TMP5]], [256 x i8]* [[TMP7]], i32 1
; LLVM-CG-NEXT:    br label [[TMP9]]
; LLVM-CG-EMPTY:
; LLVM-CG-NEXT:  9:
; LLVM-CG-NEXT:    [[TMP10:%.*]] = phi <2 x [256 x i8]*> [ [[TMP5]], [[PRED_ALLOCA_CONTINUE0]] ], [ [[TMP8]], [[PRED_ALLOCA_IF20]] ]
; LLVM-CG-NEXT:    br label [[PRED_ALLOCA_CONTINUE30]]
; LLVM-CG-EMPTY:
; LLVM-CG-NEXT:  pred.alloca.continue3:
; LLVM-CG-NEXT:    [[TMP11:%.*]] = bitcast [256 x i8]** [[SCALAR_GEP0]] to <2 x [256 x i8]*>*
; LLVM-CG-NEXT:    call void @llvm.masked.store.v2p0a256i8.p0v2p0a256i8(<2 x [256 x i8]*> [[TMP10]], <2 x [256 x i8]*>* [[TMP11]], i32 8, <2 x i1> [[TMP0]])
; LLVM-CG-NEXT:    [[TMP12:%.*]] = alloca [256 x i8], align 16
; LLVM-CG-NEXT:    [[TMP13:%.*]] = insertelement <2 x [256 x i8]*> undef, [256 x i8]* [[TMP12]], i32 0
; LLVM-CG-NEXT:    [[TMP14:%.*]] = alloca [256 x i8], align 16
; LLVM-CG-NEXT:    [[TMP15:%.*]] = insertelement <2 x [256 x i8]*> [[TMP13]], [256 x i8]* [[TMP14]], i32 1
; LLVM-CG-NEXT:    [[TMP16:%.*]] = bitcast [256 x i8]** [[SCALAR_GEP0]] to <2 x [256 x i8]*>*
; LLVM-CG-NEXT:    store <2 x [256 x i8]*> [[TMP15]], <2 x [256 x i8]*>* [[TMP16]], align 8
;
; HIR-LABEL:  After predication and linearization
; HIR:     [DA: Divergent] i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT:%.*]], [[BB1:BB[0-9]+]] ],  [ i64 [[VP3:%.*]], [[BB3:BB[0-9]+]] ]
; HIR:     [DA: Divergent] [256 x i8]* [[VP6:%.*]] = alloca i64 [[VP2]]
;
; Ensure we correctly bailout from vectorization
; HIR-CG-NOT: <2 x
entry:
  %conv = zext i32 %n to i64
  %storage = alloca [256 x i8]*, i64 %conv, align 16
  br label %for.body.preheader

for.body.preheader:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %iv = phi i64 [ %iv.next, %endif ], [ 0, %for.body.preheader ]
  %varying = icmp eq i64 %iv, 42
  ;; Store to unit-strided memory to ensure vector of allocas is built correctly
  ;; after serialization, which, in turn, verifies correct DA results.
  %gep = getelementptr inbounds [256 x i8]*, [256 x i8]** %storage, i64 %iv
  br i1 %varying, label %if.then, label %endif

if.then:
  %a.var = alloca [256 x i8], i64 %iv, align 16
  store [256 x i8]* %a.var , [256 x i8]** %gep, align 8
  br label %endif

endif:
  %a.uni = alloca [256 x i8], align 16
  store [256 x i8]* %a.uni , [256 x i8]** %gep, align 8

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, %conv
  br i1 %exitcond, label %loopexit, label %for.body

loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  br label %exit

exit:
  ret void
}

declare token @llvm.directive.region.entry() nounwind
declare void @llvm.directive.region.exit(token) nounwind
