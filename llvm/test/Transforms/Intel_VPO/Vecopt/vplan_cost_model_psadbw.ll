; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR \
; RUN:     -mattr=+avx2 -disable-output -vplan-cost-model-use-gettype \
; RUN:     -vplan-cost-model-print-analysis-for-vf=1 | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"

@a = dso_local local_unnamed_addr global [1024 x i8] zeroinitializer, align 64
@b = dso_local local_unnamed_addr global [1024 x i8] zeroinitializer, align 64

define dso_local i32 @_Z3foov(i32 %t) {
;
; CHECK-LABEL:  HIR Cost Model for VPlan _Z3foov.19 with VF = 1:
; CHECK-NEXT:  Total Cost: 0, PSADBW pattern adjustment: -13
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]], total cost: 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB1:BB[0-9]+]], total cost: 0
; CHECK-NEXT:    Cost Unknown for i32 [[VP__RED_INIT:%.*]] = reduction-init i32 0 i32 [[S_0100:%.*]] ( PSADBW )
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB2:BB[0-9]+]], total cost: 11
; CHECK-NEXT:    Cost Unknown for i32 [[VP0:%.*]] = phi  [ i32 [[VP__RED_INIT]], [[BB1]] ],  [ i32 [[VP1:%.*]], [[BB2]] ] ( PSADBW )
; CHECK-NEXT:    Cost Unknown for i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i8]* @a i64 0 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i8 [[VP4:%.*]] = load i8* [[VP_SUBSCRIPT]]
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i8]* @b i64 0 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i8 [[VP5:%.*]] = load i8* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:    Cost 1 for i32 [[VP6:%.*]] = zext i8 [[VP4]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP7:%.*]] = zext i8 [[VP5]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP8:%.*]] = mul i32 [[VP7]] i32 -1 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP9:%.*]] = add i32 [[VP6]] i32 [[VP8]] ( PSADBW )
; CHECK-NEXT:    Cost 2 for i32 [[VP10:%.*]] = abs i32 [[VP9]] ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP1]] = add i32 [[VP10]] i32 [[VP0]] ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP3]] = add i64 [[VP2]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:    Cost 1 for i1 [[VP11:%.*]] = icmp i64 [[VP3]] i64 1023
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB3:BB[0-9]+]], total cost: 0
; CHECK-NEXT:    Cost Unknown for i32 [[VP__RED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP1]] ( PSADBW )
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB4:BB[0-9]+]], total cost: 0
;
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %add.lcssa = phi i32 [ %add, %for.body ]
  ret i32 %add.lcssa

for.body:                                         ; preds = %for.body, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %s.010 = phi i32 [ %t, %entry ], [ %add, %for.body ]
  %arrayidx = getelementptr inbounds [1024 x i8], [1024 x i8]* @a, i64 0, i64 %indvars.iv
  %0 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %0 to i32
  %arrayidx2 = getelementptr inbounds [1024 x i8], [1024 x i8]* @b, i64 0, i64 %indvars.iv
  %1 = load i8, i8* %arrayidx2, align 1
  %conv3 = zext i8 %1 to i32
  %sub = sub nsw i32 %conv, %conv3
  %2 = icmp slt i32 %sub, 0
  %neg = sub nsw i32 0, %sub
  %3 = select i1 %2, i32 %neg, i32 %sub
  %add = add nuw nsw i32 %3, %s.010
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.cond.cleanup, label %for.body
}

; unrolled case with 64-bit acc.  Essential for eembc/denbench tests.
define dso_local i32 @_Z3goov() {
;
; CHECK-LABEL:  HIR Cost Model for VPlan _Z3goov.60 with VF = 1:
; CHECK-NEXT:  Total Cost: 0, PSADBW pattern adjustment: -53
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]], total cost: 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB1:BB[0-9]+]], total cost: 0
; CHECK-NEXT:    Cost Unknown for i64 [[VP__RED_INIT:%.*]] = reduction-init i64 0 i64 [[S_0620:%.*]] ( PSADBW )
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB2:BB[0-9]+]], total cost: 52
; CHECK-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__RED_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB2]] ] ( PSADBW )
; CHECK-NEXT:    Cost Unknown for i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CHECK-NEXT:    Cost Unknown for i64 [[VP4:%.*]] = hir-copy i64 [[VP0]] , OriginPhiId: -1
; CHECK-NEXT:    Cost 1 for i64 [[VP5:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i8]* @a i64 0 i64 [[VP5]]
; CHECK-NEXT:    Cost 1 for i8 [[VP6:%.*]] = load i8* [[VP_SUBSCRIPT]]
; CHECK-NEXT:    Cost 1 for i64 [[VP7:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i8]* @b i64 0 i64 [[VP7]]
; CHECK-NEXT:    Cost 1 for i8 [[VP8:%.*]] = load i8* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:    Cost 1 for i32 [[VP9:%.*]] = zext i8 [[VP6]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP10:%.*]] = zext i8 [[VP8]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP11:%.*]] = mul i32 [[VP10]] i32 -1 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP12:%.*]] = add i32 [[VP9]] i32 [[VP11]] ( PSADBW )
; CHECK-NEXT:    Cost 2 for i32 [[VP13:%.*]] = abs i32 [[VP12]] ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP14:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i64 [[VP15:%.*]] = add i64 [[VP14]] i64 1
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i8]* @a i64 0 i64 [[VP15]]
; CHECK-NEXT:    Cost 1 for i8 [[VP16:%.*]] = load i8* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:    Cost 1 for i64 [[VP17:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i64 [[VP18:%.*]] = add i64 [[VP17]] i64 1
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [1024 x i8]* @b i64 0 i64 [[VP18]]
; CHECK-NEXT:    Cost 1 for i8 [[VP19:%.*]] = load i8* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:    Cost 1 for i32 [[VP20:%.*]] = zext i8 [[VP16]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP21:%.*]] = zext i8 [[VP19]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP22:%.*]] = mul i32 [[VP21]] i32 -1 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP23:%.*]] = add i32 [[VP20]] i32 [[VP22]] ( PSADBW )
; CHECK-NEXT:    Cost 2 for i32 [[VP24:%.*]] = abs i32 [[VP23]] ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP25:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i64 [[VP26:%.*]] = add i64 [[VP25]] i64 2
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [1024 x i8]* @a i64 0 i64 [[VP26]]
; CHECK-NEXT:    Cost 1 for i8 [[VP27:%.*]] = load i8* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:    Cost 1 for i64 [[VP28:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i64 [[VP29:%.*]] = add i64 [[VP28]] i64 2
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds [1024 x i8]* @b i64 0 i64 [[VP29]]
; CHECK-NEXT:    Cost 1 for i8 [[VP30:%.*]] = load i8* [[VP_SUBSCRIPT_5]]
; CHECK-NEXT:    Cost 1 for i32 [[VP31:%.*]] = zext i8 [[VP27]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP32:%.*]] = zext i8 [[VP30]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP33:%.*]] = mul i32 [[VP32]] i32 -1 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP34:%.*]] = add i32 [[VP31]] i32 [[VP33]] ( PSADBW )
; CHECK-NEXT:    Cost 2 for i32 [[VP35:%.*]] = abs i32 [[VP34]] ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP36:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i64 [[VP37:%.*]] = add i64 [[VP36]] i64 3
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_6:%.*]] = subscript inbounds [1024 x i8]* @a i64 0 i64 [[VP37]]
; CHECK-NEXT:    Cost 1 for i8 [[VP38:%.*]] = load i8* [[VP_SUBSCRIPT_6]]
; CHECK-NEXT:    Cost 1 for i64 [[VP39:%.*]] = mul i64 4 i64 [[VP2]]
; CHECK-NEXT:    Cost 1 for i64 [[VP40:%.*]] = add i64 [[VP39]] i64 3
; CHECK-NEXT:    Cost 0 for i8* [[VP_SUBSCRIPT_7:%.*]] = subscript inbounds [1024 x i8]* @b i64 0 i64 [[VP40]]
; CHECK-NEXT:    Cost 1 for i8 [[VP41:%.*]] = load i8* [[VP_SUBSCRIPT_7]]
; CHECK-NEXT:    Cost 1 for i32 [[VP42:%.*]] = zext i8 [[VP38]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP43:%.*]] = zext i8 [[VP41]] to i32 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP44:%.*]] = mul i32 [[VP43]] i32 -1 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i32 [[VP45:%.*]] = add i32 [[VP42]] i32 [[VP44]] ( PSADBW )
; CHECK-NEXT:    Cost 2 for i32 [[VP46:%.*]] = abs i32 [[VP45]] ( PSADBW )
; CHECK-NEXT:    Cost 0 for i64 [[VP47:%.*]] = zext i32 [[VP35]] to i64 ( PSADBW )
; CHECK-NEXT:    Cost 0 for i64 [[VP48:%.*]] = zext i32 [[VP24]] to i64 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP49:%.*]] = add i64 [[VP47]] i64 [[VP48]] ( PSADBW )
; CHECK-NEXT:    Cost 0 for i64 [[VP50:%.*]] = zext i32 [[VP13]] to i64 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP51:%.*]] = add i64 [[VP49]] i64 [[VP50]] ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP52:%.*]] = add i64 [[VP51]] i64 [[VP4]]
; CHECK-NEXT:    Cost 0 for i64 [[VP53:%.*]] = zext i32 [[VP46]] to i64 ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP1]] = add i64 [[VP52]] i64 [[VP53]] ( PSADBW )
; CHECK-NEXT:    Cost 1 for i64 [[VP3]] = add i64 [[VP2]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:    Cost 1 for i1 [[VP54:%.*]] = icmp i64 [[VP3]] i64 255
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB3:BB[0-9]+]], total cost: 0
; CHECK-NEXT:    Cost Unknown for i64 [[VP__RED_FINAL:%.*]] = reduction-final{u_add} i64 [[VP1]] ( PSADBW )
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB4:BB[0-9]+]], total cost: 0
;
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %s.062 = phi i64 [ 0, %entry ], [ %add40, %for.body ]
  %arrayidx = getelementptr inbounds [1024 x i8], [1024 x i8]* @a, i64 0, i64 %indvars.iv
  %0 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %0 to i32
  %arrayidx2 = getelementptr inbounds [1024 x i8], [1024 x i8]* @b, i64 0, i64 %indvars.iv
  %1 = load i8, i8* %arrayidx2, align 1
  %conv3 = zext i8 %1 to i32
  %sub = sub nsw i32 %conv, %conv3
  %2 = icmp slt i32 %sub, 0
  %neg = sub nsw i32 0, %sub
  %3 = select i1 %2, i32 %neg, i32 %sub
  %conv4 = zext i32 %3 to i64
  %add = add i64 %s.062, %conv4
  %4 = or i64 %indvars.iv, 1
  %arrayidx7 = getelementptr inbounds [1024 x i8], [1024 x i8]* @a, i64 0, i64 %4
  %5 = load i8, i8* %arrayidx7, align 1
  %conv8 = zext i8 %5 to i32
  %arrayidx11 = getelementptr inbounds [1024 x i8], [1024 x i8]* @b, i64 0, i64 %4
  %6 = load i8, i8* %arrayidx11, align 1
  %conv12 = zext i8 %6 to i32
  %sub13 = sub nsw i32 %conv8, %conv12
  %7 = icmp slt i32 %sub13, 0
  %neg58 = sub nsw i32 0, %sub13
  %8 = select i1 %7, i32 %neg58, i32 %sub13
  %conv15 = zext i32 %8 to i64
  %add16 = add i64 %add, %conv15
  %9 = or i64 %indvars.iv, 2
  %arrayidx19 = getelementptr inbounds [1024 x i8], [1024 x i8]* @a, i64 0, i64 %9
  %10 = load i8, i8* %arrayidx19, align 2
  %conv20 = zext i8 %10 to i32
  %arrayidx23 = getelementptr inbounds [1024 x i8], [1024 x i8]* @b, i64 0, i64 %9
  %11 = load i8, i8* %arrayidx23, align 2
  %conv24 = zext i8 %11 to i32
  %sub25 = sub nsw i32 %conv20, %conv24
  %12 = icmp slt i32 %sub25, 0
  %neg59 = sub nsw i32 0, %sub25
  %13 = select i1 %12, i32 %neg59, i32 %sub25
  %conv27 = zext i32 %13 to i64
  %add28 = add i64 %add16, %conv27
  %14 = or i64 %indvars.iv, 3
  %arrayidx31 = getelementptr inbounds [1024 x i8], [1024 x i8]* @a, i64 0, i64 %14
  %15 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %15 to i32
  %arrayidx35 = getelementptr inbounds [1024 x i8], [1024 x i8]* @b, i64 0, i64 %14
  %16 = load i8, i8* %arrayidx35, align 1
  %conv36 = zext i8 %16 to i32
  %sub37 = sub nsw i32 %conv32, %conv36
  %17 = icmp slt i32 %sub37, 0
  %neg60 = sub nsw i32 0, %sub37
  %18 = select i1 %17, i32 %neg60, i32 %sub37
  %conv39 = zext i32 %18 to i64
  %add40 = add i64 %add28, %conv39
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 4
  %cmp = icmp ult i64 %indvars.iv, 1020
  br i1 %cmp, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  %add40.lcssa = phi i64 [ %add40, %for.body ]
  %conv42 = trunc i64 %add40.lcssa to i32
  ret i32 %conv42
}
