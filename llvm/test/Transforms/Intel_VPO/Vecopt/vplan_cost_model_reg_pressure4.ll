; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=16 \
; RUN:     -mattr=+avx2 2>&1 | FileCheck %s --check-prefix=VPLAN-CM-AVX2

; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=16 \
; RUN:     -mattr=+avx512f 2>&1 | FileCheck %s --check-prefix=VPLAN-CM-AVX512

; Expensive load/store operations in the loop should not induce register
; pressure high enough to cause spill/fills if they are not serialized.
; For the first run scatter is disabled which makes RP high.
; For the second run scatter is allowed and RP is expected to drop.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "i586-unknown-linux-gnu"

@e = dso_local local_unnamed_addr global [1024 x i64] zeroinitializer, align 16
@d = dso_local local_unnamed_addr global [1024 x i64] zeroinitializer, align 16
@c = dso_local local_unnamed_addr global [1024 x i64] zeroinitializer, align 16
@b = dso_local local_unnamed_addr global [1024 x i64] zeroinitializer, align 16
@a = dso_local local_unnamed_addr global [1024 x i64] zeroinitializer, align 16

define dso_local void @foo() {
; VPLAN-CM-AVX2-LABEL:  HIR Cost Model for VPlan foo.25 with VF = 16:
; VPLAN-CM-AVX2-NEXT:  Total VPlan Cost: 1292000
; VPLAN-CM-AVX2-NEXT:  VPlan Base Cost before adjustments: 476000
; VPLAN-CM-AVX2-NEXT:  VPlan Base Cost includes Total VPlan GS Cost: 320000
; VPLAN-CM-AVX2-NEXT:  Total VPlan GS Cost is bumped: +640000
; VPLAN-CM-AVX2-NEXT:  Total VPlan spill/fill cost: +176000
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]], total cost: 0
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB1]], total cost: 0
; VPLAN-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB2]], total cost: 476000
; VPLAN-CM-AVX2-NEXT:  total cost includes GS Cost: 320000
; VPLAN-CM-AVX2-NEXT:  Block Vector spill/fill approximate cost (not included into total cost): 176000
; VPLAN-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB2]] ]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i64]* @a i64 0 i64 [[VP0]]
; VPLAN-CM-AVX2-NEXT:    Cost 4000 for i64 [[VP_LOAD:%.*]] = load i64* [[VP_SUBSCRIPT]]
; VPLAN-CM-AVX2-NEXT:    Cost 4000 for i64 [[VP2:%.*]] = mul i64 [[VP_LOAD]] i64 2
; VPLAN-CM-AVX2-NEXT:    Cost 32000 for i64 [[VP3:%.*]] = mul i64 2 i64 [[VP0]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i64]* @b i64 0 i64 [[VP3]]
; VPLAN-CM-AVX2-NEXT:    Cost 80000 for store i64 [[VP2]] i64* [[VP_SUBSCRIPT_1]] ( GS )
; VPLAN-CM-AVX2-NEXT:    Cost 4000 for i64 [[VP4:%.*]] = mul i64 [[VP_LOAD]] i64 4
; VPLAN-CM-AVX2-NEXT:    Cost 32000 for i64 [[VP5:%.*]] = mul i64 3 i64 [[VP0]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i64]* @c i64 0 i64 [[VP5]]
; VPLAN-CM-AVX2-NEXT:    Cost 80000 for store i64 [[VP4]] i64* [[VP_SUBSCRIPT_2]] ( GS )
; VPLAN-CM-AVX2-NEXT:    Cost 8000 for i64 [[VP6:%.*]] = mul i64 [[VP_LOAD]] i64 5
; VPLAN-CM-AVX2-NEXT:    Cost 32000 for i64 [[VP7:%.*]] = mul i64 4 i64 [[VP0]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [1024 x i64]* @d i64 0 i64 [[VP7]]
; VPLAN-CM-AVX2-NEXT:    Cost 80000 for store i64 [[VP6]] i64* [[VP_SUBSCRIPT_3]] ( GS )
; VPLAN-CM-AVX2-NEXT:    Cost 32000 for i64 [[VP8:%.*]] = mul i64 5 i64 [[VP0]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [1024 x i64]* @e i64 0 i64 [[VP8]]
; VPLAN-CM-AVX2-NEXT:    Cost 80000 for store i64 [[VP_LOAD]] i64* [[VP_SUBSCRIPT_4]] ( GS )
; VPLAN-CM-AVX2-NEXT:    Cost 4000 for i64 [[VP1]] = add i64 [[VP0]] i64 [[VP__IND_INIT_STEP]]
; VPLAN-CM-AVX2-NEXT:    Cost 4000 for i1 [[VP9:%.*]] = icmp sle i64 [[VP1]] i64 1023
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br i1 [[VP9]], [[BB2]], [[BB3:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB3]], total cost: 0
; VPLAN-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 live-in0 i64 1
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB4]], total cost: 0
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br <External Block>
;
; VPLAN-CM-AVX512-LABEL:  HIR Cost Model for VPlan foo.25 with VF = 16:
; VPLAN-CM-AVX512-NEXT:  Total VPlan Cost: 510000
; VPLAN-CM-AVX512-NEXT:  VPlan Base Cost before adjustments: 222000
; VPLAN-CM-AVX512-NEXT:  VPlan Base Cost includes Total VPlan GS Cost: 144000
; VPLAN-CM-AVX512-NEXT:  Total VPlan GS Cost is bumped: +288000
; VPLAN-CM-AVX512-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]], total cost: 0
; VPLAN-CM-AVX512-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; VPLAN-CM-AVX512-NEXT:  Analyzing VPBasicBlock [[BB1]], total cost: 0
; VPLAN-CM-AVX512-NEXT:    Cost Unknown for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-CM-AVX512-NEXT:    Cost Unknown for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-CM-AVX512-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; VPLAN-CM-AVX512-NEXT:  Analyzing VPBasicBlock [[BB2]], total cost: 222000
; VPLAN-CM-AVX512-NEXT:  total cost includes GS Cost: 144000
; VPLAN-CM-AVX512-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB2]] ]
; VPLAN-CM-AVX512-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i64]* @a i64 0 i64 [[VP0]]
; VPLAN-CM-AVX512-NEXT:    Cost 2000 for i64 [[VP_LOAD:%.*]] = load i64* [[VP_SUBSCRIPT]]
; VPLAN-CM-AVX512-NEXT:    Cost 2000 for i64 [[VP2:%.*]] = mul i64 [[VP_LOAD]] i64 2
; VPLAN-CM-AVX512-NEXT:    Cost 16000 for i64 [[VP3:%.*]] = mul i64 2 i64 [[VP0]]
; VPLAN-CM-AVX512-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i64]* @b i64 0 i64 [[VP3]]
; VPLAN-CM-AVX512-NEXT:    Cost 36000 for store i64 [[VP2]] i64* [[VP_SUBSCRIPT_1]] ( GS )
; VPLAN-CM-AVX512-NEXT:    Cost 2000 for i64 [[VP4:%.*]] = mul i64 [[VP_LOAD]] i64 4
; VPLAN-CM-AVX512-NEXT:    Cost 16000 for i64 [[VP5:%.*]] = mul i64 3 i64 [[VP0]]
; VPLAN-CM-AVX512-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i64]* @c i64 0 i64 [[VP5]]
; VPLAN-CM-AVX512-NEXT:    Cost 36000 for store i64 [[VP4]] i64* [[VP_SUBSCRIPT_2]] ( GS )
; VPLAN-CM-AVX512-NEXT:    Cost 4000 for i64 [[VP6:%.*]] = mul i64 [[VP_LOAD]] i64 5
; VPLAN-CM-AVX512-NEXT:    Cost 16000 for i64 [[VP7:%.*]] = mul i64 4 i64 [[VP0]]
; VPLAN-CM-AVX512-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [1024 x i64]* @d i64 0 i64 [[VP7]]
; VPLAN-CM-AVX512-NEXT:    Cost 36000 for store i64 [[VP6]] i64* [[VP_SUBSCRIPT_3]] ( GS )
; VPLAN-CM-AVX512-NEXT:    Cost 16000 for i64 [[VP8:%.*]] = mul i64 5 i64 [[VP0]]
; VPLAN-CM-AVX512-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [1024 x i64]* @e i64 0 i64 [[VP8]]
; VPLAN-CM-AVX512-NEXT:    Cost 36000 for store i64 [[VP_LOAD]] i64* [[VP_SUBSCRIPT_4]] ( GS )
; VPLAN-CM-AVX512-NEXT:    Cost 2000 for i64 [[VP1]] = add i64 [[VP0]] i64 [[VP__IND_INIT_STEP]]
; VPLAN-CM-AVX512-NEXT:    Cost 2000 for i1 [[VP9:%.*]] = icmp sle i64 [[VP1]] i64 1023
; VPLAN-CM-AVX512-NEXT:    Cost 0 for br i1 [[VP9]], [[BB2]], [[BB3:BB[0-9]+]]
; VPLAN-CM-AVX512-NEXT:  Analyzing VPBasicBlock [[BB3]], total cost: 0
; VPLAN-CM-AVX512-NEXT:    Cost Unknown for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 live-in0 i64 1
; VPLAN-CM-AVX512-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; VPLAN-CM-AVX512-NEXT:  Analyzing VPBasicBlock [[BB4]], total cost: 0
; VPLAN-CM-AVX512-NEXT:    Cost 0 for br <External Block>
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %arrayidx1 = getelementptr inbounds [1024 x i64], [1024 x i64]* @a, i64 0, i64 %indvars.iv
  %step2 = mul i64 %indvars.iv, 2
  %arrayidx2 = getelementptr inbounds [1024 x i64], [1024 x i64]* @b, i64 0, i64 %step2
  %step3 = mul i64 %indvars.iv, 3
  %arrayidx3 = getelementptr inbounds [1024 x i64], [1024 x i64]* @c, i64 0, i64 %step3
  %step4 = mul i64 %indvars.iv, 4
  %arrayidx4 = getelementptr inbounds [1024 x i64], [1024 x i64]* @d, i64 0, i64 %step4
  %step5 = mul i64 %indvars.iv, 5
  %arrayidx5 = getelementptr inbounds [1024 x i64], [1024 x i64]* @e, i64 0, i64 %step5

  %load = load i64, i64* %arrayidx1, align 4
  %add1 = add nsw nuw i64 %load, %load
  %add2 = add nsw nuw i64 %add1, %add1
  %add3 = add nsw nuw i64 %add2, %load
  store i64 %add1, i64* %arrayidx2, align 4
  store i64 %add2, i64* %arrayidx3, align 4
  store i64 %add3, i64* %arrayidx4, align 4
  store i64 %load, i64* %arrayidx5, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  ret void
}
