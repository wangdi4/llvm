; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: asserts
; RUN: opt < %s -vplan-func-vec -enable-vplan-func-vec-all-zero-bypass -print-after-vplan-func-vec-all-zero-bypass -disable-output -S 2>&1 | FileCheck %s
; RUN: opt < %s -passes="vplan-func-vec" -enable-vplan-func-vec-all-zero-bypass -print-after-vplan-func-vec-all-zero-bypass -disable-output -S 2>&1 | FileCheck %s

declare i32 @llvm.vplan.laneid()

; Function Attrs: nounwind uwtable
define dso_local void @foo(i32* nocapture readonly %a, i32 %n) local_unnamed_addr #0 {
;
; CHECK-LABEL:  VPlan after all zero bypass:
; CHECK-NEXT:  VPlan IR for: foo
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_CMP4:%.*]] = icmp i32 [[N0:%.*]] i32 7
; CHECK-NEXT:     [DA: Div] i32* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP0:%.*]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_CMP1:%.*]] = icmp i32 [[VP0]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):all.zero.bypass.begin9
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    all.zero.bypass.begin9:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_ALL_ZERO_CHECK:%.*]] = all-zero-check i1 [[VP_CMP1]]
; CHECK-NEXT:    SUCCESSORS(2):all.zero.bypass.end11(i1 [[VP_ALL_ZERO_CHECK]]), [[BB2:BB[0-9]+]](!i1 [[VP_ALL_ZERO_CHECK]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_CMP1]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_X:%.*]] = add i32 [[VP_LANE]] i32 42
; CHECK-NEXT:      SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): all.zero.bypass.begin9
; CHECK-EMPTY:
;
; FIXME: Test shows incorrect formation of an all-zero bypass region around BB3.
;
; CHECK-NEXT:      [[BB3]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:       Condition([[BB0]]): [DA: Uni] i1 [[VP_CMP4]] = icmp i32 [[N0]] i32 7
; CHECK-NEXT:      SUCCESSORS(2):[[BB4:BB[0-9]+]](i1 [[VP_CMP4]]), [[BB5:BB[0-9]+]](!i1 [[VP_CMP4]])
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB4]]:
; CHECK-NEXT:         <Empty Block>
; CHECK-NEXT:        SUCCESSORS(1):[[BB5]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):all.zero.bypass.end11
; CHECK-NEXT:      PREDECESSORS(2): [[BB3]] [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    all.zero.bypass.end11:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB5]] all.zero.bypass.begin9
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] void [[VP2:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): all.zero.bypass.end11
;
;        entry
;          |
;        div.if (D)
;       /     |
; div.if.then |
;       \     |
;        uni.if (U)
;       /      |
;  uni.if.then |
;       \      |
;      uni.if.end
;           |
;         exit
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %cmp4 = icmp slt i32 %n, 7
  %arrayidx = getelementptr inbounds i32, i32* %a, i32 %lane
  %0 = load i32, i32* %arrayidx, align 4
  br label %div.if

div.if:
  %cmp1 = icmp eq i32 %0, 3
  br i1 %cmp1, label %div.if.then, label %uni.if

div.if.then:
  %x = add i32 %lane, 42
  br label %uni.if

uni.if:
  br i1 %cmp4, label %uni.if.then, label %uni.if.end

uni.if.then:
  br label %uni.if.end

uni.if.end:
  br label %exit

exit:
  ret void
}
