; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check that we don't crash when a reduction has two external uses.
;
; RUN: opt -disable-output -enable-new-pm=0 -vplan-vec -vplan-print-after-vpentity-instrs -vplan-entities-dump -print-after=vplan-vec %s 2>&1 | FileCheck %s
; RUN: opt -disable-output -passes="vplan-vec" -vplan-print-after-vpentity-instrs -vplan-entities-dump -print-after=vplan-vec %s 2>&1 | FileCheck %s

define i32 @foo(i32 %N) {
;
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: foo:omp.inner.for.body.#{{[0-9]+}}
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i32 0 Step: i32 1 StartVal: i32 0 EndVal: i32 -2147483648 BinOp: i32 [[VP_ADD3:%.*]] = add i32 [[VP_STOREMERGE10:%.*]] i32 [[VP_STOREMERGE10_IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP_STOREMERGE10]], i32 [[VP_ADD3]], i32 [[VP_STOREMERGE10_IND_INIT:%.*]], i32 [[VP_STOREMERGE10_IND_INIT_STEP]], i32 [[VP_STOREMERGE10_IND_FINAL:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i32 [[VP_STOREMERGE10_IND_INIT]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_STOREMERGE10_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i32 [[VP_STOREMERGE10]] = phi  [ i32 [[VP_ADD3]], [[BB3]] ],  [ i32 [[VP_STOREMERGE10_IND_INIT]], [[BB2]] ]
; CHECK-NEXT:     br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP_ADD3]] = add i32 [[VP_STOREMERGE10]] i32 [[VP_STOREMERGE10_IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP_CMP:%.*]] = icmp slt i32 [[VP_STOREMERGE10]] i32 [[N0:%.*]]
; CHECK-NEXT:     br i1 [[VP_CMP]], [[BB0]], [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     i32 [[VP_STOREMERGE10_IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0     [[ADD3_LCSSA20:%.*]] = phi i32 [ [[ADD30:%.*]], [[OMP_INNER_FOR_INC0:%.*]] ] i32 [[VP_STOREMERGE10_IND_FINAL]] -> i32 [[ADD30]]
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1     [[ADD3_LCSSA0:%.*]] = phi i32 [ [[ADD30]], [[OMP_INNER_FOR_INC0]] ] i32 [[VP_STOREMERGE10_IND_FINAL]] -> i32 [[ADD30]]
;
; ====== Generated code ========
; CHECK:       define i32 @foo(i32 [[N0]]) {
; CHECK:       VPlannedBB6:
; CHECK-NEXT:    [[TMP8:%.*]] = mul i32 1, [[TMP3:%.*]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i32 0, [[TMP8]]
;
; CHECK:       final.merge:
; CHECK-NEXT:    [[UNI_PHI120:%.*]] = phi i32 [ [[ADD30:%.*]], [[VPLANNEDBB110:%.*]] ], [ [[TMP9]], [[VPLANNEDBB80:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI130:%.*]] = phi i32 [ [[ADD30]], [[VPLANNEDBB110:%.*]] ], [ [[TMP9]], [[VPLANNEDBB80]] ]
; CHECK-NEXT:    br label [[OMP_INNER_FOR_COND_OMP_LOOP_EXIT_CRIT_EDGE0:%.*]]
;
; CHECK:       omp.inner.for.inc:
; CHECK-NEXT:    [[ADD30]] = add nuw nsw i32 [[STOREMERGE100:%.*]], 1
; CHECK-NEXT:    [[CMP0:%.*]] = icmp slt i32 [[STOREMERGE100]], [[N0:%.*]]
; CHECK-NEXT:    br i1 [[CMP0]], label [[OMP_INNER_FOR_BODY0:%.*]], label [[VPLANNEDBB110]]
;
; CHECK:       omp.inner.for.cond.omp.loop.exit_crit_edge:
; CHECK-NEXT:    [[ADD3_LCSSA0:%.*]] = phi i32 [ [[UNI_PHI130]], [[FINAL_MERGE0:%.*]] ]
; CHECK-NEXT:    [[ADD3_LCSSA20:%.*]] = phi i32 [ [[UNI_PHI120]], [[FINAL_MERGE0]] ]
;
entry:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 8) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.inc, %entry
  %storemerge10 = phi i32 [ %add3, %omp.inner.for.inc ], [ 0, %entry ]
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %for.body
  %add3 = add nuw nsw i32 %storemerge10, 1
  %cmp = icmp slt i32 %storemerge10, %N
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.omp.loop.exit_crit_edge

omp.inner.for.cond.omp.loop.exit_crit_edge:       ; preds = %omp.inner.for.inc
  %add3.lcssa = phi i32 [ %add3, %omp.inner.for.inc ]
  %add3.lcssa2 = phi i32 [ %add3, %omp.inner.for.inc ]
  %sum = add nuw nsw i32 %add3.lcssa, %add3.lcssa2
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  ret i32 %sum
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
