; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-initial-transforms -disable-output -vplan-force-vf=2 < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-initial-transforms -disable-output -vplan-force-vf=2 < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-initial-transforms -disable-output -vplan-force-vf=2 < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-initial-transforms -disable-output -vplan-force-vf=2 < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s

; Verify that VPlan H-CFG builder is able to build the H-CFG for a simple HIR
; multi-exit loop.

; Input Loop:
; <19>      + DO i1 = 0, %len_limit + -2, 1   <DO_MULTI_EXIT_LOOP>  <MAX_TC_EST = 4294967295>
; <2>       |   %len_best.011.out = i1 + 1;
; <6>       |   %0 = (%cur)[i1 + -1 * zext.i32.i64(%delta2) + 1];
; <7>       |   %1 = (%cur)[i1 + 1];
; <9>       |   if (%0 != %1)
; <9>       |   {
; <11>      |      goto for.end.loopexit;
; <9>       |   }
; <19>      + END LOOP

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @peel_example(i32 %delta2, i32 %len_limit, i32* nocapture readonly %cur) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after initial VPlan transforms:
; CHECK-NEXT:  VPlan IR for: peel_example:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%cur}
; CHECK-DAG:     [[VP1:%.*]] = {%len_limit + -2}
; CHECK-DAG:     [[VP2:%.*]] = {-1 * zext.i32.i64(%delta2) + 1}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP3:%.*]] = add i32 [[VP1]] i32 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i32 [[VP4:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP5:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32 [[VP6:%.*]] = add i32 [[VP4]] i32 1
; CHECK-NEXT:     i32 [[VP7:%.*]] = hir-copy i32 [[VP6]] , OriginPhiId: -1
; CHECK-NEXT:     i64 [[VP8:%.*]] = zext i32 [[VP4]] to i64
; CHECK-NEXT:     i64 [[VP9:%.*]] = add i64 [[VP2]] i64 [[VP8]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[CUR0:%.*]] i64 [[VP9]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP11:%.*]] = zext i32 [[VP6]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[CUR0]] i64 [[VP11]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i1 [[VP12:%.*]] = icmp ne i32 [[VP_LOAD]] i32 [[VP_LOAD_1]]
; CHECK-NEXT:     br i1 [[VP12]], [[BB4:BB[0-9]+]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP5]] = add i32 [[VP4]] i32 1
; CHECK-NEXT:       i1 [[VP13:%.*]] = icmp slt i32 [[VP5]] i32 [[VP3]]
; CHECK-NEXT:       br i1 [[VP13]], [[BB2]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB3]]
; CHECK-NEXT:       br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       br for.end.loopexit
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP7]] -> [[VP14:%.*]] = {%len_best.011.out}
;
entry:
  %cmp10 = icmp eq i32 %len_limit, 1
  br i1 %cmp10, label %for.end, label %for.body.lr.ph

for.body.lr.ph:
  %idx.ext1 = zext i32 %delta2 to i64
  %idx.neg = sub nsw i64 0, %idx.ext1
  br label %for.body

for.body:
  %len_best.011 = phi i32 [ 1, %for.body.lr.ph ], [ %inc, %for.inc ]
  %idx.ext = zext i32 %len_best.011 to i64
  %add.ptr = getelementptr inbounds i32, i32* %cur, i64 %idx.ext
  %add.ptr2 = getelementptr inbounds i32, i32* %add.ptr, i64 %idx.neg
  %0 = load i32, i32* %add.ptr2
  %1 = load i32, i32* %add.ptr
  %cmp3 = icmp eq i32 %0, %1
  br i1 %cmp3, label %for.inc, label %for.end.loopexit

for.inc:
  %inc = add i32 %len_best.011, 1
  %cmp = icmp eq i32 %inc, %len_limit
  br i1 %cmp, label %for.end.loopexit, label %for.body

for.end.loopexit:
  %len_best.0.lcssa.ph = phi i32 [ %len_limit, %for.inc ], [ %len_best.011, %for.body ]
  br label %for.end

for.end:
  %len_best.0.lcssa = phi i32 [ 1, %entry ], [ %len_best.0.lcssa.ph, %for.end.loopexit ]
  ret i32 %len_best.0.lcssa
}
