; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -vplan-print-after-hcfg -disable-output -vplan-force-vf=2 < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,vplan-driver-hir" -vplan-print-after-hcfg -disable-output -vplan-force-vf=2 < %s 2>&1 | FileCheck %s

; Verify that VPlan H-CFG builder is able to build the H-CFG for a simple HIR
; multi-exit loop.

; Input Loop:
; <19>      + DO i1 = 0, %len_limit + -2, 1   <DO_MULTI_EXIT_LOOP>  <MAX_TC_EST = 4294967295>
; <2>       |   %len_best.011.out = i1 + 1;
; <6>       |   %0 = (%cur)[i1 + -1 * zext.i32.i64(%delta2) + 1];
; <7>       |   %1 = (%cur)[i1 + 1];
; <9>       |   if (%0 != %1)
; <9>       |   {
; <11>      |      goto for.end.loopexit;
; <9>       |   }
; <19>      + END LOOP

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @peel_example(i32 %delta2, i32 %len_limit, i32* nocapture readonly %cur) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after building H-CFG:
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%len_limit + -2}
; CHECK-DAG:     [[VP1:%.*]] = {-1 * zext.i32.i64(%delta2) + 1}
; CHECK-DAG:     [[VP2:%.*]] = {%cur}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     i32 [[VP3:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP4:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     i32 [[VP5:%.*]] = add i32 [[VP3]] i32 1
; CHECK-NEXT:     i32 [[VP6:%.*]] = hir-copy i32 [[VP5]] , OriginPhiId: -1
; CHECK-NEXT:     i64 [[VP7:%.*]] = zext i32 [[VP3]] to i64
; CHECK-NEXT:     i64 [[VP8:%.*]] = add i64 [[VP1]] i64 [[VP7]]
; CHECK-NEXT:     i32* [[VP9:%.*]] = subscript inbounds i32* [[CUR0:%.*]] i64 [[VP8]]
; CHECK-NEXT:     i32 [[VP10:%.*]] = load i32* [[VP9]]
; CHECK-NEXT:     i32 [[VP11:%.*]] = add i32 [[VP3]] i32 1
; CHECK-NEXT:     i64 [[VP12:%.*]] = zext i32 [[VP11]] to i64
; CHECK-NEXT:     i32* [[VP13:%.*]] = subscript inbounds i32* [[CUR0]] i64 [[VP12]]
; CHECK-NEXT:     i32 [[VP14:%.*]] = load i32* [[VP13]]
; CHECK-NEXT:     i1 [[VP15:%.*]] = icmp ne i32 [[VP10]] i32 [[VP14]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB4:BB[0-9]+]](i1 [[VP15]]), [[BB3]](!i1 [[VP15]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]:
; CHECK-NEXT:       i32 [[VP4]] = add i32 [[VP3]] i32 1
; CHECK-NEXT:       i1 [[VP16:%.*]] = icmp sle i32 [[VP4]] i32 [[VP0]]
; CHECK-NEXT:      SUCCESSORS(2):[[BB2]](i1 [[VP16]]), [[BB5:BB[0-9]+]](!i1 [[VP16]])
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       br for.end.loopexit
; CHECK-NEXT:      SUCCESSORS(1):[[BB6]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB4]] [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
;
entry:
  %cmp10 = icmp eq i32 %len_limit, 1
  br i1 %cmp10, label %for.end, label %for.body.lr.ph

for.body.lr.ph:
  %idx.ext1 = zext i32 %delta2 to i64
  %idx.neg = sub nsw i64 0, %idx.ext1
  br label %for.body

for.body:
  %len_best.011 = phi i32 [ 1, %for.body.lr.ph ], [ %inc, %for.inc ]
  %idx.ext = zext i32 %len_best.011 to i64
  %add.ptr = getelementptr inbounds i32, i32* %cur, i64 %idx.ext
  %add.ptr2 = getelementptr inbounds i32, i32* %add.ptr, i64 %idx.neg
  %0 = load i32, i32* %add.ptr2
  %1 = load i32, i32* %add.ptr
  %cmp3 = icmp eq i32 %0, %1
  br i1 %cmp3, label %for.inc, label %for.end.loopexit

for.inc:
  %inc = add i32 %len_best.011, 1
  %cmp = icmp eq i32 %inc, %len_limit
  br i1 %cmp, label %for.end.loopexit, label %for.body

for.end.loopexit:
  %len_best.0.lcssa.ph = phi i32 [ %len_limit, %for.inc ], [ %len_best.011, %for.body ]
  br label %for.end

for.end:
  %len_best.0.lcssa = phi i32 [ 1, %entry ], [ %len_best.0.lcssa.ph, %for.end.loopexit ]
  ret i32 %len_best.0.lcssa
}
