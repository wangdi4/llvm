; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -vplan-vec -disable-vplan-predicator -vplan-force-vf=4 < %s | FileCheck %s

; Outer loop vectorization
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"


;#pragma omp simd
;  for (int i=0; i < iCount; i++) {
;    A[i] = c;
;    for (int j=1; i< jCount; i++) {
;      A[i] += B[j] + i;
;    }
;  }

; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK:        [[SCALAR_GEP:%.*]] = getelementptr i32, i32* [[A:%.*]], i64 [[UNI_PHI:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = trunc <4 x i64> [[VEC_PHI:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32* [[SCALAR_GEP]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> [[BROADCAST_SPLAT:%.*]], <4 x i32>* [[TMP5]], align 4
; CHECK-NEXT:    br i1 [[CMP116:%.*]], label %[[VPLANNEDBB4:.*]], label %[[VPLANNEDBB5:.*]]
; CHECK:       VPlannedBB4:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT20:%.*]] = insertelement <4 x i32> poison, i32 [[C:%.*]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT21:%.*]] = shufflevector <4 x i32> [[BROADCAST_SPLATINSERT20]], <4 x i32> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    br label %[[VPLANNEDBB6:.*]]
; CHECK:       VPlannedBB6:
; CHECK-NEXT:    [[UNI_PHI7:%.*]] = phi i64 [ [[TMP9:%.*]], %[[VPLANNEDBB6]] ], [ 0, %[[VPLANNEDBB4]] ]
; CHECK-NEXT:    [[VEC_PHI8:%.*]] = phi <4 x i32> [ [[TMP8:%.*]], %[[VPLANNEDBB6]] ], [ [[BROADCAST_SPLAT21]], %[[VPLANNEDBB4]] ]
; CHECK-NEXT:    [[SCALAR_GEP9:%.*]] = getelementptr i32, i32* [[B:%.*]], i64 [[UNI_PHI7]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, i32* [[SCALAR_GEP9]], align 4
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT10:%.*]] = insertelement <4 x i32> poison, i32 [[TMP6]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT11:%.*]] = shufflevector <4 x i32> [[BROADCAST_SPLATINSERT10]], <4 x i32> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP7:%.*]] = add <4 x i32> [[BROADCAST_SPLAT11]], [[TMP4]]
; CHECK-NEXT:    [[TMP8]] = add <4 x i32> [[TMP7]], [[VEC_PHI8]]
; CHECK:         br i1 [[TMP10:%.*]], label %[[VPLANNEDBB12:.*]], label %[[VPLANNEDBB6]]
; CHECK:       VPlannedBB12:
; CHECK-NEXT:    [[VEC_PHI13:%.*]] = phi <4 x i32> [ [[TMP8]], %[[VPLANNEDBB6]] ]
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast i32* [[SCALAR_GEP]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> [[VEC_PHI13]], <4 x i32>* [[TMP11]], align 4
;
define void @foo(i32* noalias nocapture %A, i32* noalias nocapture readonly %B, i32 %iCount, i32 %jCount, i32 %c) local_unnamed_addr #0 {
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %DIR.QUAL.LIST.END.2

DIR.QUAL.LIST.END.2:                              ; preds = %0
  %cmp18 = icmp sgt i32 %iCount, 0
  br i1 %cmp18, label %outer_loop.ph, label %.outer

outer_loop.ph:                                         ; preds = %DIR.QUAL.LIST.END.2
  %cmp116 = icmp sgt i32 %jCount, 0
  %wide.trip.count25 = zext i32 %iCount to i64
  %wide.trip.count = zext i32 %jCount to i64
  br label %outer_1

outer_1:                                      ; preds = %outer_2, %outer_loop.ph
  %indvars.iv23 = phi i64 [ 0, %outer_loop.ph ], [ %indvars.iv.next24, %outer_2 ]
  %arrayidx = getelementptr i32, i32* %A, i64 %indvars.iv23
  %iv.i = trunc i64 %indvars.iv23 to i32
  store i32 %c, i32* %arrayidx, align 4
  br i1 %cmp116, label %inner.preheader, label %outer_2

inner.preheader:                                 ; preds = %1
  br label %inner_loop


inner_loop:                                           ; preds = %inner.preheader, %inner_loop
  %indvars.iv = phi i64 [ %indvars.iv.next, %inner_loop ], [ 0, %inner.preheader ]
  %A_val = phi i32 [ %add6, %inner_loop ], [ %c, %inner.preheader ]
  %arrayidx3 = getelementptr i32, i32* %B, i64 %indvars.iv
  %B_val = load i32, i32* %arrayidx3, align 4
  %add = add i32 %B_val, %iv.i
  %add6 = add i32 %add, %A_val
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %inner_loop_exit, label %inner_loop

inner_loop_exit:                                      ; preds = %inner_loop
  %add6.lcssa = phi i32 [ %add6, %inner_loop ]
  store i32 %add6.lcssa, i32* %arrayidx, align 4
  br label %outer_2

outer_2:                                      ; preds = %inner_loop_exit, %1
  %indvars.iv.next24 = add nuw nsw i64 %indvars.iv23, 1
  %exitcond26 = icmp eq i64 %indvars.iv.next24, %wide.trip.count25
  br i1 %exitcond26, label %.outer.loopexit, label %outer_1

.outer.loopexit:                           ; preds = %2
  br label %.outer

.outer:                                    ; preds = %.outer.loopexit, %DIR.QUAL.LIST.END.2
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  br label %DIR.QUAL.LIST.END.4

DIR.QUAL.LIST.END.4:                              ; preds = %.outer
  ret void

}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1


