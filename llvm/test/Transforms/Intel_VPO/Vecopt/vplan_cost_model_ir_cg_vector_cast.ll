; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -passes=vplan-vec -mattr=+avx2 -disable-output %s -vplan-cost-model-print-analysis-for-vf=4 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @foo(<2 x i32>* nocapture readonly %p) {
;
; CHECK-LABEL:  Cost Model for VPlan foo:header.#{{[0-9]+}} with VF = 4:
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-NEXT:  [[BB0]]: base cost: 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-NEXT:    Cost 0 for i64 [[VP_IV_IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; CHECK-NEXT:    Cost 0 for i64 [[VP_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:    Cost 0 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; CHECK-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-NEXT:  [[BB1]]: base cost: 0
; CHECK-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 4 resulted Cost = 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-NEXT:    Cost Unknown for i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_IV_NEXT:%.*]], [[BB2]] ]
; CHECK-NEXT:    Cost 0 for <2 x i32>* [[VP_GEP:%.*]] = getelementptr inbounds <2 x i32>* [[P0:%.*]] i64 [[VP_IV]]
; CHECK-NEXT:    Cost 1.1875 for <2 x i32> [[VP_LD:%.*]] = load <2 x i32>* [[VP_GEP]]
; CHECK-NEXT:    Cost 5 for <2 x i64> [[VP_SEXT:%.*]] = sext <2 x i32> [[VP_LD]] to <2 x i64>
; CHECK-NEXT:    Cost 5 for <2 x i64> [[VP_ZEXT:%.*]] = zext <2 x i32> [[VP_LD]] to <2 x i64>
; CHECK-NEXT:    Cost 4 for <2 x i8> [[VP_TRUNC:%.*]] = trunc <2 x i32> [[VP_LD]] to <2 x i8>
; CHECK-NEXT:    Cost 0 for <2 x i32*> [[VP_ITOPTR:%.*]] = inttoptr <2 x i64> [[VP_SEXT]] to <2 x i32*>
; CHECK-NEXT:    Cost 0 for <2 x i64> [[VP_PTRTOI:%.*]] = ptrtoint <2 x i32*> [[VP_ITOPTR]] to <2 x i64>
; CHECK-NEXT:    Cost 1 for <2 x float> [[VP_SITOFP:%.*]] = sitofp <2 x i32> [[VP_LD]] to <2 x float>
; CHECK-NEXT:    Cost 2 for <2 x float> [[VP_UITOFP:%.*]] = uitofp <2 x i32> [[VP_LD]] to <2 x float>
; CHECK-NEXT:    Cost 3 for <2 x double> [[VP_SIFPEX:%.*]] = fpext <2 x float> [[VP_SITOFP]] to <2 x double>
; CHECK-NEXT:    Cost 3 for <2 x double> [[VP_UIFPEX:%.*]] = fpext <2 x float> [[VP_UITOFP]] to <2 x double>
; CHECK-NEXT:    Cost 1 for <2 x i32> [[VP_FPTOSI:%.*]] = fptosi <2 x float> [[VP_SITOFP]] to <2 x i32>
; CHECK-NEXT:    Cost 3 for <2 x i32> [[VP_FPTOUI:%.*]] = fptoui <2 x float> [[VP_UITOFP]] to <2 x i32>
; CHECK-NEXT:    Cost 3 for <2 x float> [[VP_SIFPTR:%.*]] = fptrunc <2 x double> [[VP_SIFPEX]] to <2 x float>
; CHECK-NEXT:    Cost 3 for <2 x float> [[VP_UIFPTR:%.*]] = fptrunc <2 x double> [[VP_UIFPEX]] to <2 x float>
; CHECK-NEXT:    Cost 1 for i64 [[VP_IV_NEXT]] = add i64 [[VP_IV]] i64 [[VP_IV_IND_INIT_STEP]]
; CHECK-NEXT:    Cost 4 for i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    Cost 0 for br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB3:BB[0-9]+]], [[BB2]]
; CHECK-NEXT:  [[BB2]]: base cost: 39.1875
; CHECK-NEXT:  Base Cost: 39.1875
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-NEXT:    Cost 0 for i64 [[VP_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-NEXT:  [[BB3]]: base cost: 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-NEXT:    Cost 0 for br <External Block>
; CHECK-NEXT:  [[BB4]]: base cost: 0
; CHECK-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 4 resulted Cost = 0
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %gep = getelementptr inbounds <2 x i32>, <2 x i32>* %p, i64 %iv
  %ld = load <2 x i32>, <2 x i32>* %gep
  %sext = sext <2 x i32> %ld to <2 x i64>
  %zext = zext <2 x i32> %ld to <2 x i64>
  %trunc = trunc <2 x i32> %ld to <2 x i8>
  %itoptr = inttoptr <2 x i64> %sext to <2 x i32*>
  %ptrtoi = ptrtoint <2 x i32*> %itoptr to <2 x i64>
  %sitofp = sitofp <2 x i32> %ld to <2 x float>
  %uitofp = uitofp <2 x i32> %ld to <2 x float>
  %sifpex = fpext <2 x float> %sitofp to <2 x double>
  %uifpex = fpext <2 x float> %uitofp to <2 x double>
  %fptosi = fptosi <2 x float> %sitofp to <2 x i32>
  %fptoui = fptoui <2 x float> %uitofp to <2 x i32>
  %sifptr = fptrunc <2 x double> %sifpex to <2 x float>
  %uifptr = fptrunc <2 x double> %uifpex to <2 x float>
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1024
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
