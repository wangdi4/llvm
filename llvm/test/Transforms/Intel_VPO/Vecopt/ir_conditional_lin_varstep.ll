; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; Test for that induction which has updates under conditions is processed correctly
; (i.e. induction init/final are processed correctly).
; REQUIRES: asserts
; RUN: opt -passes=vplan-vec -vplan-force-vf=2 -vplan-entities-dump -vplan-dump-induction-init-details -vplan-print-after-vpentity-instrs -vplan-dump-plan-da -S < %s 2>&1 | FileCheck %s
;
; CHECK:      VPlan after insertion of VPEntities instructions:
; CHECK:      IntInduction(+) Start: i64 %k.iv.b Step: i64 %step StartVal: ? EndVal: ? BinOp: i64 [[VP_IND_PHI:%.*]] = phi  [ i64 [[VP_IND_ADD1:%.*]], BB3 ],  [ i64 [[VP_IND_ADD0:%.*]], BB4 ] need close form
; CHECK-NEXT:   Linked values: i64 [[VP_PHI_NEXT:%.*]], i64 [[VP_IND_PHI]], i64 [[VP_IND_INIT:%.*]], i64 [[VP_IND_NEXT:%.*]], i64 [[VP_IND_FINAL:%.*]],
; CHECK:      BB1: # preds: BB7
; CHECK:        i64 [[VP_IND_INIT:%.*]] = induction-init{add, StartVal: ?, EndVal: ?} i64 %k.iv.b i64 %step
; CHECK-NEXT:   i64 [[VP_STEP_INIT:%.*]] = induction-init-step{add} i64 %step
; CHECK:      BB2: # preds: BB1, BB5
; CHECK:        i64 [[VP_PHI_NEXT]] = phi  [ i64 [[VP_IND_INIT]], BB1 ],  [ i64 [[VP_IND_NEXT]], BB5 ]
; CHECK:        i1 [[VP_STEP_CMP:%.*]] = icmp eq i64 [[VP_STEP:%.*]] i64 [[VP_PHI_NEXT]]
; CHECK-NEXT:   br i1 [[VP_STEP_CMP]], BB3, BB4
; CHECK:      BB4: # preds: BB2
; CHECK-NEXT:   i64 [[VP_IND_ADD0]] = add i64 [[VP_PHI_NEXT]] i64 %step
; CHECK:      BB3: # preds: BB2
; CHECK-NEXT:   i64 [[VP_IND_ADD1]] = add i64 [[VP_PHI_NEXT]] i64 %step
; CHECK:      BB6: # preds: BB5
; CHECK:        i64 [[VP_IND_FINAL]] = induction-final{add} i64 %k.iv.b i64 %step
;
; CHECK: Printing Divergence info for foo2:for.body.#1
; CHECK: Basic Block: BB1
; CHECK: Divergent: [Shape: Random] i64 [[VP_IND_INIT:%.*]] = induction-init{add, StartVal: ?, EndVal: ?} i64 live-in0 i64 %step
; CHECK: Uniform: [Shape: Uniform] i64 [[VP_STEP_INIT:%.*]] = induction-init-step{add} i64 %step
; CHECK: Basic Block: BB4
; CHECK: Divergent: [Shape: Random] i64 [[VP_IND_ADD:%.*]] = add i64 [[VP_PHI_NEXT:%.*]] i64 %step
; CHECK: Basic Block: BB3
; CHECK: Divergent: [Shape: Random] i64 [[VP_IND_ADD1:%.*]] = add i64 [[VP_PHI_NEXT]] i64 %step
; CHECK: Basic Block: BB6
; CHECK: Uniform: [Shape: Uniform] i64 [[VP_IND_FINAL:%.*]] = induction-final{add} i64 %k.iv.b i64 %step
;
; CHECK:      define void @foo2(i64 %N, i64 noundef %step) local_unnamed_addr {
; CHECK:      VPlannedBB1:
; CHECK-NEXT:   [[VP_BCAST_SPLATINSERT:%.*]] = insertelement <2 x i64> poison, i64 %step, i64 0
; CHECK-NEXT:   [[VP_BCAST_SPLAT:%.*]] = shufflevector <2 x i64> [[VP_BCAST_SPLATINSERT]], <2 x i64> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:   br label %VPlannedBB2
; CHECK:      VPlannedBB2:                                      ; preds = %VPlannedBB1
; CHECK:        [[VP_STEP_WIDE:%.*]] = mul <2 x i64> [[VP_BCAST_SPLAT]], <i64 0, i64 1>
; CHECK-NEXT:   [[VP_IV_START_WIDE:%.*]] = add <2 x i64> [[VP_IV_START_BCAST_SPLAT:%.*]], [[VP_STEP_WIDE:%.*]]
; CHECK-NEXT:   [[VP_STEP_WIDE1:%.*]] = mul i64 %step, 2
; CHECK-NEXT:   [[VP_STEP_INIT_SPLATINSERT:%.*]] = insertelement <2 x i64> poison, i64 [[VP_STEP_WIDE1]], i64 0
; CHECK-NEXT:   [[VP_STEP_INIT_SPLAT:%.*]] = shufflevector <2 x i64> [[VP_STEP_INIT_SPLATINSERT]], <2 x i64> poison, <2 x i32> zeroinitializer
; CHECK:     VPlannedBB7:                                      ; preds = %vector.body
; CHECK-NEXT:   [[VP_VEC_PHI_NEXT0:%.*]] = add nuw nsw <2 x i64> [[VP_VEC_PHI:%.*]], [[VP_BCAST_SPLAT]]
; CHECK-NEXT:   br label %VPlannedBB8
; CHECK-EMPTY:
; CHECK-NEXT: VPlannedBB8:                                      ; preds = %VPlannedBB7
; CHECK-NEXT:   [[VP_VEC_PHI_NEXT1:%.*]] = add nuw nsw <2 x i64> [[VP_VEC_PHI]], [[VP_BCAST_SPLAT]]
; CHECK-NEXT:   br label %VPlannedBB9
; CHECK-EMPTY:
; CHECK-NEXT: VPlannedBB9:                                      ; preds = %VPlannedBB8
; CHECK-NEXT:   [[VP_PREDBLEND:%.*]] = select <2 x i1> %10, <2 x i64> [[VP_VEC_PHI_NEXT1]], <2 x i64> [[VP_VEC_PHI_NEXT0]]
; CHECK-NEXT:   [[VP_VEC_PHI_NEXT:%.*]] = add <2 x i64> [[VP_VEC_PHI]], [[VP_STEP_INIT_SPLAT]]
; CHECK-NEXT:   [[VP_UNI_PHI_NEXT:%.*]] = add i64 [[VP_UNI_PHI:%.*]], [[VP_STEP_WIDE1]]
; CHECK:      VPlannedBB10:                                     ; preds = %VPlannedBB9
; CHECK:        [[VP_STEP_NEXT:%.*]] = mul i64 %step, [[VP_TRIP_COUNT:%.*]]
;
define void @foo2(i64 %N, i64 noundef %step) local_unnamed_addr #0 {
entry:
  %k = alloca i64, align 4
  store i64 0, i64* %k, align 4
  br label %reg.entry

reg.entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LINEAR:TYPED"(i64* %k, i32 0, i32 1, i64 %step) ]
  br label %for.body.lr.ph

for.body.lr.ph:
  %k.iv.b = load i64, i64* %k, align 4
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %latch ]
  %k.iv = phi i64 [ %k.iv.b, %for.body.lr.ph ], [ %k.iv.next, %latch ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %ee = icmp eq i64 %indvars.iv.next, %k.iv
  br i1 %ee, label %then, label %else

then:
  %k.iv.n1 = add nuw nsw i64 %k.iv, %step
  br label %latch
else:
  %k.iv.n2 = add nuw nsw i64 %k.iv, %step
  br label %latch

latch:
  %k.iv.next = phi i64 [%k.iv.n1, %then ], [%k.iv.n2, %else ]
  %exitcond = icmp eq i64 %indvars.iv.next, %N
  br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body

for.cond.cleanup.loopexit:
  %lcssa.k = phi i64 [%k.iv.next, %latch]
  br label %for.cond.cleanup

for.cond.cleanup:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

