; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -opaque-pointers=0 -passes="vplan-vec" -S -vplan-vec-scenario="n1;v16;m16" -vplan-print-after-vpentity-instrs -vplan-print-after-create-masked-vplan -vplan-enable-masked-variant -vplan-enable-peel-rem-strip=0 -vplan-print-after-final-cond-transform < %s  2>&1 | FileCheck %s

; RUN: opt -disable-output -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -vplan-vec-scenario="n1;v16;m16" -vplan-print-after-vpentity-instrs -vplan-print-after-create-masked-vplan -vplan-print-after-final-cond-transform -vplan-enable-masked-variant-hir -vplan-enable-peel-rem-strip=0 < %s  2>&1 | FileCheck %s --check-prefix=HIR

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"
define i32 @main() {
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK:          i32* [[VP_XP:%.*]] = allocate-priv i32*, OrigAlign = 4
;
; CHECK:          i32 [[VP_IV:%.*]] = phi  [ i32 [[VP_IV_IND_INIT:%.*]], [[BB1:BB[0-9]+]] ],  [ i32 [[VP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 [[VP_IV_IND_INIT_STEP:%.*]]
;
; CHECK:          i32 [[VP_X:%.*]] = add i32 [[VP_IV]] i32 1
;
; CHECK:          i32 [[VP_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_X_PRIV_FINAL:%.*]] = private-final-uc i32 [[VP_X]]
; CHECK-NEXT:     i8* [[VP_XP_BCAST:%.*]] = bitcast i32* [[VP_XP]]
; CHECK-NEXT:     call i64 4 i8* [[VP_XP_BCAST]] void (i64, i8*)* @llvm.lifetime.end.p0i8 
; CHECK-NEXT:     br [[BB5:BB[0-9]+]]
;
; CHECK:       VPlan after emitting masked variant:
; CHECK-NEXT:  VPlan IR for: main:header.#{{[0-9]+}}.cloned.masked
; CHECK-NEXT:    [[BB6:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i32* [[VP2:%.*]] = allocate-priv i32*, OrigAlign = 4
; CHECK-NEXT:     [DA: Div] i8* [[VP3:%.*]] = bitcast i32* [[VP2]]
; CHECK-NEXT:     [DA: Div] call i64 4 i8* [[VP3]] void (i64, i8*)* @llvm.lifetime.start.p0i8
; CHECK-NEXT:     [DA: Div] i32 [[VP4:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP5:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_NORM_UB:%.*]] = sub i32 128 i32 live-in1
; CHECK-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]], new_latch
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_1:%.*]] = phi  [ i32 [[VP4]], [[BB7]] ],  [ i32 [[VP_IV_NEXT_1:%.*]], new_latch ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_NEW_IND:%.*]] = add i32 [[VP_IV_1]] i32 live-in1
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = icmp ult i32 [[VP_IV_1]] i32 [[VP_NORM_UB]]
; CHECK-NEXT:     [DA: Div] br i1 [[VP6]], [[BB9:BB[0-9]+]], new_latch
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:       [DA: Uni] br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_X_1:%.*]] = add i32 [[VP_NEW_IND]] i32 1
; CHECK-NEXT:       [DA: Uni] br new_latch
; CHECK:         new_latch:
; CHECK-NEXT:     [DA: Div] i32 [[VP7:%.*]] = phi  [ i32 [[VP_X_1]], [[BB10]] ],  [ i32 live-in0, [[BB8]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_NEXT_1]] = add i32 [[VP_IV_1]] i32 [[VP5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = icmp ult i32 [[VP_IV_NEXT_1]] i32 [[VP_NORM_UB]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP9:%.*]] = all-zero-check i1 [[VP8]]
;
; CHECK:          [DA: Uni] i32 [[VP10:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP11:%.*]] = private-final-masked i32 [[VP7]] i1 [[VP6]] i32 live-in0
; CHECK-NEXT:     [DA: Div] i8* [[VP12:%.*]] = bitcast i32* [[VP2]]
; CHECK-NEXT:     [DA: Div] call i64 4 i8* [[VP12]] void (i64, i8*)* @llvm.lifetime.end.p0i8
; CHECK-NEXT:     [DA: Uni] br [[BB12:BB[0-9]+]]
; CHECK:       External Uses:
; CHECK-NEXT:  Id: 0     [[X_LCSSA0:%.*]] = phi i32 [ [[X0:%.*]], [[LATCH0:%.*]] ] i32 [[VP11]] -> i32 [[X0]]
;
; CHECK-LABEL: VPlan after private finalization instructions transformation:
; CHECK:           new_latch:
; CHECK-NEXT:       [DA: Div] i32 [[VP__BLEND_BB310:%.*]] = blend [ i32 [[VP14:%.*]], i1 true ], [ i32 [[VP_X_1]], i1 [[VP6]] ]
; CHECK-NEXT:       [DA: Div] i32 [[VP_IV_NEXT_1]] = add i32 [[VP_IV_1]] i32 [[VP5]]
; CHECK-NEXT:       [DA: Div] i1 [[VP8]] = icmp ult i32 [[VP_IV_NEXT_1]] i32 [[VP_NORM_UB]]
; CHECK-NEXT:       [DA: Uni] i1 [[VP9]] = all-zero-check i1 [[VP8]]
; CHECK:            [DA: Uni] i32 [[VP10]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:       [DA: Uni] i1 [[VP18:%.*]] = all-zero-check i1 [[VP6]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP18]], [[BB14:BB[0-9]+]], [[BB15:BB[0-9]+]]
;
; CHECK:             [[BB15]]: # preds: [[BB11:BB[0-9]+]]
; CHECK-NEXT:         [DA: Uni] i32 [[VP11]] = private-final-masked i32 [[VP__BLEND_BB310]] i1 [[VP6]] i32 [[VP14]]
; CHECK-NEXT:         [DA: Uni] br [[BB14]]
;
; CHECK:           [[BB14]]: # preds: [[BB15]], [[BB11]]
; CHECK-NEXT:       [DA: Uni] i32 [[VP19:%.*]] = phi  [ i32 [[VP14]], [[BB11]] ],  [ i32 [[VP11]], [[BB15]] ]
; CHECK-NEXT:       [DA: Div] i8* [[VP12]] = bitcast i32* [[VP2]]
; CHECK-NEXT:       [DA: Div] call i64 4 i8* [[VP12]] void (i64, i8*)* @llvm.lifetime.end.p0i8
; CHECK-NEXT:       [DA: Uni] br [[BB12]]
;
;========= generated code
; CHECK:  define i32 @main() {
; CHECK:       VPlannedBB21:
; CHECK-NEXT:    [[TMP16:%.*]] = bitcast <16 x i1> [[TMP9:%.*]] to i16
; CHECK-NEXT:    [[TMP17:%.*]] = icmp eq i16 [[TMP16]], 0
; CHECK-NEXT:    br i1 [[TMP17]], label [[VPLANNEDBB220:%.*]], label [[VPLANNEDBB230:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB23:
; CHECK-NEXT:    [[TMP18:%.*]] = bitcast <16 x i1> [[TMP9]] to i16
; CHECK-NEXT:    [[CTLZ0:%.*]] = call i16 @llvm.ctlz.i16(i16 [[TMP18]], i1 true)
; CHECK-NEXT:    [[TMP19:%.*]] = sub i16 15, [[CTLZ0]]
; CHECK-NEXT:    [[PRIV_EXTRACT0:%.*]] = extractelement <16 x i32> [[PREDBLEND0:%.*]], i16 [[TMP19]]
; CHECK-NEXT:    br label [[VPLANNEDBB220]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB22:
; CHECK-NEXT:    [[UNI_PHI240:%.*]] = phi i32 [ [[UNI_PHI80:%.*]], [[VPLANNEDBB210:%.*]] ], [ [[PRIV_EXTRACT0]], [[VPLANNEDBB230]] ]
; CHECK:       final.merge:
; CHECK-NEXT:    [[UNI_PHI260:%.*]] = phi i32 [ [[UNI_PHI240]], [[VPLANNEDBB250:%.*]] ], [ [[EXTRACTED_PRIV0:%.*]], [[VPLANNEDBB70:%.*]] ]
; CHECK:         br label [[LOOPEXIT0:%.*]]
; CHECK:       loopexit:
; CHECK-NEXT:    [[X_LCSSA0]] = phi i32 [ [[UNI_PHI260]], [[FINAL_MERGE0:%.*]] ]
; CHECK-NEXT:    store i32 [[X_LCSSA0]], i32* [[XP0:%.*]], align 4
;
; HIR-LABEL:  VPlan after insertion of VPEntities instructions:
; HIR:          i32* [[VP_XP:%.*]] = allocate-priv i32*, OrigAlign = 4
; HIR-NEXT:     i32 [[VP__IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; HIR-NEXT:     i32 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
;
; HIR:          i32 [[VP4:%.*]] = add i32 [[VP2:%.*]] i32 1
;
; HIR:          i32 [[VP__PRIV_FINAL:%.*]] = private-final-uc i32 [[VP4]]
;
; HIR-LABEL:  VPlan after emitting masked variant
; HIR-NEXT:  VPlan IR for: main:HIR.#{{[0-9]+}}.cloned.masked
;
; HIR:          [DA: Div] i32* [[VP7:%.*]] = allocate-priv i32*, OrigAlign = 4
; HIR:          [DA: Div] i1 [[VP12:%.*]] = icmp ult i32 [[VP10:%.*]] i32 [[VP_NORM_UB:%.*]]
; HIR:          [DA: Div] i32 [[VP13:%.*]] = add i32 [[VP_NEW_IND:%.*]] i32 1
; HIR:          [DA: Div] i32 [[VP14:%.*]] = phi  [ i32 [[VP13]], [[BB8:.*]] ],  [ i32 live-in0, [[BB7:.*]] ]
; HIR:          [DA: Uni] i32 [[VP18:%.*]] = private-final-masked i32 [[VP14]] i1 [[VP12]] i32 live-in0
;
; HIR:       VPlan after private finalization instructions transformation:
; HIR:            [DA: Div] i32* [[VP_XP]] = allocate-priv i32*, OrigAlign = 4
; HIR:            [DA: Uni] i32 [[VP__PRIV_FINAL]] = private-final-uc i32 [[VP4]]
;
; HIR:            [DA: Div] i32* [[VP7]] = allocate-priv i32*, OrigAlign = 4
; HIR:           [[BB7:BB[0-9]+]]: # preds: [[BB6:BB[0-9]+]], new_latch
; HIR:            [DA: Div] i32 [[VP10]] = phi  [ i32 [[VP8:%.*]], [[BB6]] ],  [ i32 [[VP11:%.*]], new_latch ]
; HIR:            [DA: Div] i32 [[VP_NEW_IND]] = add i32 [[VP10]] i32 [[VP21:%.*]]
; HIR:            [DA: Div] i1 [[VP12]] = icmp ult i32 [[VP10]] i32 [[VP_NORM_UB]]
; HIR:            [DA: Div] i1 [[VP22:%.*]] = block-predicate i1 [[VP12]]
; HIR-NEXT:       [DA: Div] i32 [[VP13]] = add i32 [[VP_NEW_IND]] i32 1
;
; HIR:           new_latch:
; HIR-NEXT:       [DA: Div] i32 [[VP__BLEND_BB12:%.*]] = blend [ i32 [[VP20:%.*]], i1 true ], [ i32 [[VP13]], i1 [[VP12]] ]
; HIR-NEXT:       [DA: Div] i32 [[VP11]] = add i32 [[VP10]] i32 [[VP9:%.*]]
;
; HIR:            [DA: Uni] i32 [[VP17:%.*]] = induction-final{add} i32 0 i32 1
; HIR-NEXT:       [DA: Uni] i1 [[VP23:%.*]] = all-zero-check i1 [[VP12]]
; HIR-NEXT:       [DA: Uni] br i1 [[VP23]], [[BB12:BB[0-9]+]], [[BB13:BB[0-9]+]]
; HIR-EMPTY:
; HIR-NEXT:        [[BB13]]:
; HIR-NEXT:         [DA: Uni] i32 [[VP18]] = private-final-masked i32 [[VP__BLEND_BB12]] i1 [[VP12]] i32 [[VP20]]
; HIR-NEXT:         [DA: Uni] br [[BB12]]
; HIR-EMPTY:
; HIR-NEXT:      [[BB12]]:
; HIR-NEXT:       [DA: Uni] i32 [[VP24:%.*]] = phi  [ i32 [[VP20]], [[BB9:BB[0-9]+]] ],  [ i32 [[VP18]], [[BB13]] ]
;
; === generated code
; HIR-LABEL: Function: main
; HIR-EMPTY:
; HIR:       BEGIN REGION { modified }
; HIR:             + DO i1 = 0, 127, 16   <DO_LOOP> <simd-vectorized> <novectorize>
; HIR-NEXT:        |   [[LIVEOUTCOPY40:%.*]] = i1 + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> + 1
; HIR-NEXT:        + END LOOP
;
; HIR:             [[X0:%.*]] = extractelement [[LIVEOUTCOPY40]],  15
;
; HIR:             + DO i1 = 0, [[LOOP_UB0:%.*]], 16   <DO_LOOP> <vector-remainder> <nounroll> <novectorize>
; HIR-NEXT:        |   [[DOTVEC170:%.*]] = i1 + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> <u [[DOTVEC150:%.*]]
; HIR-NEXT:        |   [[SELECT0:%.*]] = ([[DOTVEC170]] == <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>) ? i1 + [[PHI_TEMP20:%.*]] + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> + 1 : [[PHI_TEMP0:%.*]];
; HIR-NEXT:        |   [[DOTVEC180:%.*]] = i1 + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> + 16 <u [[DOTVEC150]]
; HIR-NEXT:        |   [[TMP0:%.*]] = bitcast.<16 x i1>.i16([[DOTVEC180]])
; HIR-NEXT:        |   [[CMP0:%.*]] = [[TMP0]] == 0
; HIR-NEXT:        |   [[ALL_ZERO_CHECK0:%.*]] = [[CMP0]]
; HIR-NEXT:        + END LOOP
;
; HIR:             [[TMP1:%.*]] = bitcast.<16 x i1>.i16([[DOTVEC170]])
; HIR-NEXT:        [[CMP190:%.*]] = [[TMP1]] == 0
; HIR-NEXT:        [[ALL_ZERO_CHECK200:%.*]] = [[CMP190]]
; HIR-NEXT:        [[PHI_TEMP210:%.*]] = [[PHI_TEMP0]]
; HIR-NEXT:        if ([[CMP190]] == 1)
; HIR-NEXT:        {
; HIR-NEXT:           goto [[BB12:BB[0-9]+]].80
; HIR-NEXT:        }
; HIR-NEXT:        [[BSFINTMASK0:%.*]] = bitcast.<16 x i1>.i16([[DOTVEC170]])
; HIR-NEXT:        [[BSF0:%.*]] = @llvm.ctlz.i16([[BSFINTMASK0]],  1)
; HIR-NEXT:        [[EXT_LANE0:%.*]] = 15  -  [[BSF0]]
; HIR-NEXT:        [[PHI_TEMP0]] = extractelement [[SELECT0]],  [[EXT_LANE0]]
; HIR-NEXT:        [[PHI_TEMP210]] = [[PHI_TEMP0]]
; HIR-NEXT:        [[BB12]].80:
; HIR-NEXT:        [[X0]] = [[PHI_TEMP210]]
; HIR-NEXT:        [[PHI_TEMP80:%.*]] = [[PHI_TEMP210]]
; HIR-NEXT:        [[PHI_TEMP100:%.*]] = 128
; HIR-NEXT:        final.merge.51:
; HIR-NEXT:        ([[XP0:%.*]])[0] = [[X0]]
; HIR-NEXT:  END REGION
entry:
  %xp = alloca i32, align 4
  br label %preheader

preheader:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LASTPRIVATE:TYPED"(i32* %xp, i32 0, i32 1)]
  br label %header
header:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %latch ]
  %iv.next = add nsw i32 %iv, 1
  br label %latch

latch:
  %x = add nsw i32 %iv, 1
  %bottom_test = icmp eq i32 %iv.next, 128
  br i1 %bottom_test, label %loopexit, label %header

loopexit:
  %x.lcssa = phi i32 [%x, %latch]
  store i32 %x.lcssa, i32* %xp
  br label %endloop

endloop:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret i32 %x.lcssa
}

declare token @llvm.directive.region.entry() nounwind
declare void @llvm.directive.region.exit(token) nounwind
