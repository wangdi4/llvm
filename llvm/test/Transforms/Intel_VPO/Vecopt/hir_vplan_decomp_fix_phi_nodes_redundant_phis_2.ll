; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to verify that redundant PHIs that blend the value of PHI itself as incoming
; value along one of the edges are removed by VPlan HIR decomposer. These are emitted
; due to inaccuracies in HIR's DDG edge information and lead to formation of broken
; SSA in VPlan IR emitted by decomposer.

; Incoming HIR
; <0>          BEGIN REGION { }
; <2>                %0 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD() ]
; <57>
; <57>               + DO i1 = 0, 299, 1   <DO_LOOP> <simd>
; <8>                |   %r2l.priv.0235.i = 1.000000e+00;
; <58>               |
; <58>               |   + DO i2 = 0, 199, 1   <DO_LOOP>
; <59>               |   |   + DO i3 = 0, 99, 1   <DO_LOOP>
; <16>               |   |   |   if (%cond1 != 0)
; <16>               |   |   |   {
; <60>               |   |   |      + DO i4 = 0, 49, 1   <DO_LOOP>
; <24>               |   |   |      |   %mul23.i = 4.000000e+00  *  %r2l.priv.0235.i;
; <60>               |   |   |      + END LOOP
; <16>               |   |   |   }
; <59>               |   |   + END LOOP
; <59>               |   |
; <39>               |   |   %mul63.i = 5.000000e+00  *  %r2l.priv.0235.i;
; <41>               |   |   %r2l.priv.0235.i = 2.000000e+00;
; <58>               |   + END LOOP
; <57>               + END LOOP
; <57>
; <55>               @llvm.directive.region.exit(%0); [ DIR.OMP.END.SIMD() ]
; <56>               ret ;
; <0>          END REGION

; For this example, DDG reports that there are 2 reaching definitions for %r2l.priv.0235.i
; in node <24>. However it should be only one value which is defined in i2 loop's header.
; A redundant PHI that blends its own value is emitted and it can be removed and replaced.

; RUN: opt -passes="hir-ssa-deconstruction,hir-vplan-vec" -vplan-print-after-plain-cfg -disable-vplan-codegen -disable-output < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"
target device_triples = "spir64"

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #0

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #0

define dso_local void @foo(i1 %cond1) local_unnamed_addr #1 {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: foo:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {if (%cond1 != 0)}
; CHECK-DAG:     [[VP1:%.*]] = {%r2l.priv.0235.i}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB3]] ]
; CHECK-NEXT:     double [[VP4:%.*]] = hir-copy double 1.000000e+00 , OriginPhiId: -1
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]], [[BB6:BB[0-9]+]]
; CHECK-NEXT:     double [[VP5:%.*]] = phi  [ double [[VP4]], [[BB4]] ],  [ double [[VP6:%.*]], [[BB6]] ]
; CHECK-NEXT:     i64 [[VP7:%.*]] = phi  [ i64 0, [[BB4]] ],  [ i64 [[VP8:%.*]], [[BB6]] ]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB5]]
; CHECK-NEXT:     br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]], [[BB9:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP9:%.*]] = phi  [ i64 0, [[BB7]] ],  [ i64 [[VP10:%.*]], [[BB9]] ]
; CHECK-NEXT:     br i1 [[VP0]], [[BB10:BB[0-9]+]], [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB10]]: # preds: [[BB8]]
; CHECK-NEXT:       br [[BB11:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB11]]: # preds: [[BB10]]
; CHECK-NEXT:       br [[BB12:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB12]]: # preds: [[BB11]], [[BB12]]
; CHECK-NEXT:       i64 [[VP11:%.*]] = phi  [ i64 0, [[BB11]] ],  [ i64 [[VP12:%.*]], [[BB12]] ]
; CHECK-NEXT:       double [[VP13:%.*]] = fmul double 4.000000e+00 double [[VP5]]
; CHECK-NEXT:       i64 [[VP12]] = add i64 [[VP11]] i64 1
; CHECK-NEXT:       i1 [[VP14:%.*]] = icmp slt i64 [[VP12]] i64 50
; CHECK-NEXT:       br i1 [[VP14]], [[BB12]], [[BB13:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB13]]: # preds: [[BB12]]
; CHECK-NEXT:       br [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB13]], [[BB8]]
; CHECK-NEXT:     i64 [[VP10]] = add i64 [[VP9]] i64 1
; CHECK-NEXT:     i1 [[VP15:%.*]] = icmp slt i64 [[VP10]] i64 100
; CHECK-NEXT:     br i1 [[VP15]], [[BB8]], [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB9]]
; CHECK-NEXT:     double [[VP16:%.*]] = fmul double 5.000000e+00 double [[VP5]]
; CHECK-NEXT:     double [[VP6]] = hir-copy double 2.000000e+00 , OriginPhiId: -1
; CHECK-NEXT:     i64 [[VP8]] = add i64 [[VP7]] i64 1
; CHECK-NEXT:     i1 [[VP17:%.*]] = icmp slt i64 [[VP8]] i64 200
; CHECK-NEXT:     br i1 [[VP17]], [[BB5]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB6]]
; CHECK-NEXT:     i64 [[VP3]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i1 [[VP18:%.*]] = icmp slt i64 [[VP3]] i64 300
; CHECK-NEXT:     br i1 [[VP18]], [[BB2]], [[BB14:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB15:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]: # preds: [[BB14]]
; CHECK-NEXT:     br <External Block>
;
entry:
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %entry
  %0 = call token @llvm.directive.region.entry() #0 [ "DIR.OMP.SIMD"() ]
  br label %i1.header

i1.header:                                        ; preds = %i1.latch, %DIR.OMP.SIMD.1
  %i1.iv = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %i1.iv.next, %i1.latch ]
  %i1.iv.next = add nsw i64 %i1.iv, 1
  br label %i2.header

i2.header:                                        ; preds = %i2.latch, %i1.header
  %i2.iv = phi i64 [ 0, %i1.header ], [ %i2.iv.next, %i2.latch ]
  %r2l.priv.0235.i = phi double [ 1.000000e+00, %i1.header ], [ 2.000000e+00, %i2.latch ]
  %i2.iv.next = add nsw i64 %i2.iv, 1
  br label %i3.header

i3.header:                                        ; preds = %i3.latch, %i2.header
  %i3.iv = phi i64 [ 0, %i2.header ], [ %i3.iv.next, %i3.latch ]
  %i3.iv.next = add nsw i64 %i3.iv, 1
  br i1 %cond1, label %i4.preheader, label %i3.latch

i4.preheader:                                     ; preds = %i3.header
  br label %i4.header

i4.header:                                        ; preds = %i4.preheader, %i4.header
  %i4.iv = phi i64 [ 0, %i4.preheader ], [ %i4.iv.next, %i4.header ]
  %i4.iv.next = add nsw i64 %i4.iv, 1
  %mul23.i = fmul fast double 4.000000e+00, %r2l.priv.0235.i
  %i4.exitcond = icmp eq i64 %i4.iv.next, 50
  br i1 %i4.exitcond, label %i4.loopexit, label %i4.header

i4.loopexit:                                      ; preds = %i4.header
  br label %i3.latch

i3.latch:                                         ; preds = %i4.loopexit, %i3.header
  %i3.exitcond = icmp eq i64 %i3.iv.next, 100
  br i1 %i3.exitcond, label %i2.latch, label %i3.header

i2.latch:                                         ; preds = %i3.latch
  %mul63.i = fmul fast double 5.000000e+00, %r2l.priv.0235.i
  %i2.exitcond = icmp eq i64 %i2.iv.next, 200
  br i1 %i2.exitcond, label %i2.loopexit, label %i2.header

i2.loopexit:                                      ; preds = %i2.latch
  br label %i1.latch

i1.latch:                                         ; preds = %i2.loopexit
  %i1.exitcond = icmp eq i64 %i1.iv.next, 300
  br i1 %i1.exitcond, label %exit, label %i1.header

exit:                                             ; preds = %i1.latch
  call void @llvm.directive.region.exit(token %0) #0 [ "DIR.OMP.END.SIMD"() ]
  ret void
}
