; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of VPlan IR and generated vector HIR for incoming
; loop containing a liveout value that is updated conditionally. In this case
; the liveout variable(%nz.061) is not live-in to the target loop, but live-in
; to the parent loop region.

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -print-after=hir-vec-dir-insert -hir-details < %s 2>&1 -disable-output | FileCheck %s --check-prefix=INPUT
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -vplan-print-after-plain-cfg -print-after=hir-vplan-vec -hir-details < %s 2>&1 -disable-output | FileCheck %s

; Checks for incoming HIR
; INPUT-LABEL: BEGIN REGION { }
; INPUT:           + LiveIn symbases: 3, 8, 12
; INPUT:           + LiveOut symbases: 5
; INPUT:           + DO i64 i1 = 0, 62, 1   <DO_LOOP>
; INPUT:           |   %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
; INPUT:           |
; INPUT:           |   + Innermost: Yes
; INPUT:           |   + LiveIn symbases: 8, 12
; INPUT:           |   + LiveOut symbases: 3
; INPUT:           |   + DO i64 i2 = 0, -1 * i1 + 62, 1   <DO_LOOP>  <MAX_TC_EST = 63>   <LEGAL_MAX_TC = 63>
; INPUT:           |   |   %2 = (%zo)[0][i2 + 1][0];
; INPUT:           |   |   if (%2 == 0)
; INPUT:           |   |   {
; INPUT:           |   |      %3 = (%s1)[0][i2 + 1];
; INPUT:           |   |      (%s1)[0][i2 + 1] = %3 + -1;
; INPUT:           |   |   }
; INPUT:           |   |   else
; INPUT:           |   |   {
; INPUT:           |   |      %nz.061 = 0;
; INPUT:           |   |      <LVAL-REG> i32 0 {sb:3}
; INPUT:           |   |
; INPUT:           |   |   }
; INPUT:           |   + END LOOP
; INPUT:           |
; INPUT:           |   @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
; INPUT:           |
; INPUT:           |   %nz.061.out = %nz.061;
; INPUT:           |   <LVAL-REG> NON-LINEAR i32 %nz.061.out {sb:5}
; INPUT:           |   <RVAL-REG> NON-LINEAR i32 %nz.061 {sb:3}
; INPUT:           |
; INPUT:           + END LOOP
; INPUT-NEXT:  END REGION

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nofree nounwind uwtable
define dso_local i32 @main() local_unnamed_addr {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: main:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%nz.061}
; CHECK-DAG:     [[VP1:%.*]] = {-1 * i1 + 62}
; CHECK-DAG:     [[VP2:%.*]] = {%zo}
; CHECK-DAG:     [[VP3:%.*]] = {%s1}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[UB_INC:%.*]] = add i64 [[VP1]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i32 [[VP4:%.*]] = phi  [ i32 [[NZ_0610:%.*]], [[BB1]] ],  [ i32 [[VP5:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP8:%.*]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [100 x [100 x i32]]* [[ZO0:%.*]] i64 0 i64 [[VP8]] i64 0
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i1 [[VP9:%.*]] = icmp eq i32 [[VP_LOAD]] i32 0
; CHECK-NEXT:     br i1 [[VP9]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP10:%.*]] = hir-copy i32 0 , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       i64 [[VP11:%.*]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [100 x i32]* [[S10:%.*]] i64 0 i64 [[VP11]]
; CHECK-NEXT:       i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:       i32 [[VP12:%.*]] = add i32 [[VP_LOAD_1]] i32 -1
; CHECK-NEXT:       i64 [[VP13:%.*]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [100 x i32]* [[S10]] i64 0 i64 [[VP13]]
; CHECK-NEXT:       store i32 [[VP12]] i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     i32 [[VP5]] = phi  [ i32 [[VP4]], [[BB4]] ],  [ i32 [[VP10]], [[BB5]] ]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP14:%.*]] = icmp slt i64 [[VP7]] i64 [[UB_INC]]
; CHECK-NEXT:     br i1 [[VP14]], [[BB2]], [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP5]] -> [[VP15:%.*]] = {%nz.061}

; Checks for vector HIR
; CHECK-LABEL:   BEGIN REGION { modified }
; CHECK:              + DO i64 i1 = 0, 62, 1   <DO_LOOP>
; CHECK:              |   %tgu = (-1 * i1 + 63)/u4;
; CHECK:              |   if (0 <u 4 * %tgu)
; CHECK:              |   {
; CHECK:              |      %phi.temp = %nz.061;
; CHECK:              |      <RVAL-REG> NON-LINEAR <4 x i32> %nz.061 {sb:3}
; CHECK:              |      %phi.temp2 = -1;
; CHECK:              |
; CHECK:              |      + DO i64 i2 = 0, 4 * %tgu + -1, 4   <DO_LOOP>  <MAX_TC_EST = 15>   <LEGAL_MAX_TC = 15> <auto-vectorized> <nounroll> <novectorize>
; CHECK:              |      |   %.vec7 = undef;
; CHECK:              |      |   %.vec = (<4 x i32>*)(%zo)[0][i2 + <i64 0, i64 1, i64 2, i64 3> + 1][0];
; CHECK:              |      |   %.vec4 = %.vec == 0;
; CHECK:              |      |   %.vec5 = %.vec4  ^  -1;
; CHECK:              |      |   %.copy6 = 0;
; CHECK:              |      |   %.vec7 = (<4 x i32>*)(%s1)[0][i2 + 1], Mask = @{%.vec4};
; CHECK:              |      |   (<4 x i32>*)(%s1)[0][i2 + 1] = %.vec7 + -1, Mask = @{%.vec4};
; CHECK:              |      |   %select = (%.vec4 == <i1 true, i1 true, i1 true, i1 true>) ? %phi.temp2 : i2 + <i64 0, i64 1, i64 2, i64 3>;
; CHECK:              |      |   %select8 = (%.vec4 == <i1 true, i1 true, i1 true, i1 true>) ? %phi.temp : %.copy6;
; CHECK:              |      |   %phi.temp = %select8;
; CHECK:              |      |   %phi.temp2 = %select;
; CHECK:              |      + END LOOP
; CHECK:              |
; CHECK:              |      %.vec11 = %select != -1;
; CHECK:              |      %2 = bitcast.<4 x i1>.i4(%.vec11);
; CHECK:              |      %cmp12 = %2 == 0;
; CHECK:              |      %all.zero.check = %cmp12;
; CHECK:              |      %phi.temp13 = %nz.061;
; CHECK:              |      if (%cmp12 == 1)
; CHECK:              |      {
; CHECK:              |         goto BB10.73;
; CHECK:              |      }
; CHECK:              |      %priv.idx.max = @llvm.vector.reduce.smax.v4i64(%select);
; CHECK:              |      %priv.idx.cmp = %select == %priv.idx.max;
; CHECK:              |      %bsfintmask = bitcast.<4 x i1>.i4(%priv.idx.cmp);
; CHECK:              |      %bsf = @llvm.cttz.i4(%bsfintmask,  1);
; CHECK:              |      %nz.061 = extractelement %select8,  %bsf;
; CHECK:              |      <LVAL-REG> NON-LINEAR i32 %nz.061 {sb:3}
; CHECK:              |      %phi.temp13 = %nz.061;
; CHECK:              |      BB10.73:
; CHECK:              |   }
;
entry:
  %zo = alloca [100 x [100 x i32]], align 16
  %s1 = alloca [100 x i32], align 16
  %0 = bitcast [100 x [100 x i32]]* %zo to i8*
  call void @llvm.lifetime.start.p0i8(i64 40000, i8* nonnull %0)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 16 dereferenceable(40000) %0, i8 0, i64 40000, i1 false)
  %1 = bitcast [100 x i32]* %s1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 400, i8* nonnull %1)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 16 dereferenceable(400) %1, i8 0, i64 400, i1 false)
  br label %outer.header

outer.header:                              ; preds = %for.inc14, %entry
  %indvars.iv63 = phi i64 [ 64, %entry ], [ %indvars.iv.next64, %for.inc14 ]
  %nz.061 = phi i32 [ 1, %entry ], [ %nz.2.lcssa, %for.inc14 ]
  br label %for.body4

for.body4:                                        ; preds = %outer.header, %for.inc
  %indvars.iv = phi i64 [ 1, %outer.header ], [ %indvars.iv.next, %for.inc ]
  %nz.159 = phi i32 [ %nz.061, %outer.header ], [ %nz.2, %for.inc ]
  %arrayidx6 = getelementptr inbounds [100 x [100 x i32]], [100 x [100 x i32]]* %zo, i64 0, i64 %indvars.iv, i64 0
  %2 = load i32, i32* %arrayidx6, align 16
  %cmp9 = icmp eq i32 %2, 0
  br i1 %cmp9, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body4
  %arrayidx13 = getelementptr inbounds [100 x i32], [100 x i32]* %s1, i64 0, i64 %indvars.iv
  %3 = load i32, i32* %arrayidx13, align 4
  %sub = add i32 %3, -1
  store i32 %sub, i32* %arrayidx13, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body4, %if.then
  %nz.2 = phi i32 [ %nz.159, %if.then ], [ 0, %for.body4 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %indvars.iv63
  br i1 %exitcond.not, label %for.inc14, label %for.body4

for.inc14:                                        ; preds = %for.inc
  %nz.2.lcssa = phi i32 [ %nz.2, %for.inc ]
  %indvars.iv.next64 = add nsw i64 %indvars.iv63, -1
  %cmp = icmp ugt i64 %indvars.iv.next64, 1
  br i1 %cmp, label %outer.header, label %for.end15

for.end15:                                        ; preds = %for.inc14
  %nz.2.lcssa.lcssa = phi i32 [ %nz.2.lcssa, %for.inc14 ]
  call void @llvm.lifetime.end.p0i8(i64 400, i8* nonnull %1)
  call void @llvm.lifetime.end.p0i8(i64 40000, i8* nonnull %0)
  ret i32 0
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: argmemonly nofree nosync nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg)
