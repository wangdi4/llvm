; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of VPlan IR and generated vector HIR for incoming
; loop containing a liveout value that is updated conditionally. In this case
; the liveout variable(%nz.061) is not live-in to the target loop, but live-in
; to the parent loop region.

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -print-after=hir-vec-dir-insert -hir-details < %s 2>&1 -disable-output | FileCheck %s --check-prefix=INPUT
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -vplan-print-after-plain-cfg -print-after=hir-vplan-vec -hir-details < %s 2>&1 -disable-output | FileCheck %s --check-prefixes=CHECK,MERGED-CFG

; Checks for incoming HIR
; INPUT-LABEL: BEGIN REGION { }
; INPUT:           + LiveIn symbases: 3, 8, 12
; INPUT:           + LiveOut symbases: 5
; INPUT:           + DO i64 i1 = 0, 62, 1   <DO_LOOP>
; INPUT:           |   %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
; INPUT:           |
; INPUT:           |   + Innermost: Yes
; INPUT:           |   + LiveIn symbases: 8, 12
; INPUT:           |   + LiveOut symbases: 3
; INPUT:           |   + DO i64 i2 = 0, -1 * i1 + 62, 1   <DO_LOOP>  <MAX_TC_EST = 63>   <LEGAL_MAX_TC = 63>
; INPUT:           |   |   %2 = (%zo)[0][i2 + 1][0];
; INPUT:           |   |   if (%2 == 0)
; INPUT:           |   |   {
; INPUT:           |   |      %3 = (%s1)[0][i2 + 1];
; INPUT:           |   |      (%s1)[0][i2 + 1] = %3 + -1;
; INPUT:           |   |   }
; INPUT:           |   |   else
; INPUT:           |   |   {
; INPUT:           |   |      %nz.061 = 0;
; INPUT:           |   |      <LVAL-REG> i32 0 {sb:3}
; INPUT:           |   |
; INPUT:           |   |   }
; INPUT:           |   + END LOOP
; INPUT:           |
; INPUT:           |   @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
; INPUT:           |
; INPUT:           |   %nz.061.out = %nz.061;
; INPUT:           |   <LVAL-REG> NON-LINEAR i32 %nz.061.out {sb:5}
; INPUT:           |   <RVAL-REG> NON-LINEAR i32 %nz.061 {sb:3}
; INPUT:           |
; INPUT:           + END LOOP
; INPUT-NEXT:  END REGION

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nofree nounwind uwtable
define dso_local i32 @main() local_unnamed_addr {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: main:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%nz.061}
; CHECK-DAG:     [[VP1:%.*]] = {-1 * i1 + 62}
; CHECK-DAG:     [[VP2:%.*]] = {%zo}
; CHECK-DAG:     [[VP3:%.*]] = {%s1}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[UB_INC:%.*]] = add i64 [[VP1]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i32 [[VP4:%.*]] = phi  [ i32 [[NZ_0610:%.*]], [[BB1]] ],  [ i32 [[VP5:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP8:%.*]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [100 x [100 x i32]]* [[ZO0:%.*]] i64 0 i64 [[VP8]] i64 0
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i1 [[VP9:%.*]] = icmp eq i32 [[VP_LOAD]] i32 0
; CHECK-NEXT:     br i1 [[VP9]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP10:%.*]] = hir-copy i32 0 , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       i64 [[VP11:%.*]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [100 x i32]* [[S10:%.*]] i64 0 i64 [[VP11]]
; CHECK-NEXT:       i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:       i32 [[VP12:%.*]] = add i32 [[VP_LOAD_1]] i32 -1
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [100 x i32]* [[S10]] i64 0 i64 [[VP11]]
; CHECK-NEXT:       store i32 [[VP12]] i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     i32 [[VP5]] = phi  [ i32 [[VP4]], [[BB4]] ],  [ i32 [[VP10]], [[BB5]] ]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP14:%.*]] = icmp slt i64 [[VP7]] i64 [[UB_INC]]
; CHECK-NEXT:     br i1 [[VP14]], [[BB2]], [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP5]] -> [[VP15:%.*]] = {%nz.061}

; Checks for vector HIR
; CHECK-LABEL:   BEGIN REGION { modified }
; CHECK:              + DO i64 i1 = 0, 62, 1   <DO_LOOP>
; MERGED-CFG:         |      [[VEC:%.*]] = 0 == [[VEC_TC:%.*]];
; MERGED-CFG:         |      [[EXTRACT:%.*]] = extractelement [[VEC]],  0;
; CHECK:              |      [[PHI_TEMP:%.*]] = %nz.061;
; CHECK:              |      <RVAL-REG> NON-LINEAR <4 x i32> %nz.061 {sb:3}
; CHECK:              |      [[PHI_TEMP2:%.*]] = -1;
; CHECK:              |
; CHECK:              |      + DO i64 i2 = 0, {{.*}}, 4   <DO_LOOP>  <MAX_TC_EST = 15>   <LEGAL_MAX_TC = 15> <auto-vectorized> <nounroll> <novectorize>
; CHECK:              |      |   [[VEC7:%.*]] = undef;
; CHECK:              |      |   [[VEC:%.*]] = (<4 x i32>*)(%zo)[0][i2 + <i64 0, i64 1, i64 2, i64 3> + 1][0];
; CHECK:              |      |   [[VEC4:%.*]] = [[VEC]] == 0;
; CHECK:              |      |   [[VEC5:%.*]] = [[VEC4]]  ^  -1;
; CHECK:              |      |   [[COPY6:%.*]] = 0;
; CHECK:              |      |   [[VEC7:%.*]] = (<4 x i32>*)(%s1)[0][i2 + 1], Mask = @{[[VEC4]]};
; CHECK:              |      |   (<4 x i32>*)(%s1)[0][i2 + 1] = [[VEC7]] + -1, Mask = @{[[VEC4]]};
; CHECK:              |      |   [[SELECT:%.*]] = ([[VEC4]] == <i1 true, i1 true, i1 true, i1 true>) ? [[PHI_TEMP2]] : i2 + <i64 0, i64 1, i64 2, i64 3>;
; CHECK:              |      |   [[SELECT8:%.*]] = ([[VEC4]] == <i1 true, i1 true, i1 true, i1 true>) ? [[PHI_TEMP]] : [[COPY6]];
; CHECK:              |      |   [[PHI_TEMP]] = [[SELECT8]];
; CHECK:              |      |   [[PHI_TEMP2]] = [[SELECT]];
; CHECK:              |      + END LOOP
; CHECK:              |
; CHECK:              |      [[VEC11:%.*]] = [[SELECT]] != -1;
; CHECK:              |      [[DOT2:%.*]] = bitcast.<4 x i1>.i4([[VEC11]]);
; CHECK:              |      [[CMP12:%.*]] = [[DOT2]] == 0;
; CHECK:              |      [[ALL_ZERO_CHECK:%.*]] = [[CMP12]];
; CHECK:              |      [[PHI_TEMP13:%.*]] = %nz.061;
; CHECK:              |      if ([[CMP12]] == 1)
; CHECK:              |      {
; CHECK:              |         goto [[MERGE:BB.*]];
; CHECK:              |      }
; CHECK:              |      [[PRIV_IDX_MAX:%.*]] = @llvm.vector.reduce.smax.v4i64([[SELECT]]);
; CHECK:              |      [[PRIV_IDX_CMP:%.*]] = [[SELECT]] == [[PRIV_IDX_MAX]];
; CHECK:              |      [[BSFINTMASK:%.*]] = bitcast.<4 x i1>.i4([[PRIV_IDX_CMP]]);
; CHECK:              |      [[BSF:%.*]] = @llvm.cttz.i4([[BSFINTMASK]],  1);
; CHECK:              |      %nz.061 = extractelement [[SELECT8]],  [[BSF]];
; CHECK:              |      <LVAL-REG> NON-LINEAR i32 %nz.061 {sb:3}
; CHECK:              |      [[PHI_TEMP13:%.*]] = %nz.061;
; CHECK:              |      [[MERGE]]:
;
entry:
  %zo = alloca [100 x [100 x i32]], align 16
  %s1 = alloca [100 x i32], align 16
  %0 = bitcast [100 x [100 x i32]]* %zo to i8*
  call void @llvm.lifetime.start.p0i8(i64 40000, i8* nonnull %0)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 16 dereferenceable(40000) %0, i8 0, i64 40000, i1 false)
  %1 = bitcast [100 x i32]* %s1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 400, i8* nonnull %1)
  call void @llvm.memset.p0i8.i64(i8* noundef nonnull align 16 dereferenceable(400) %1, i8 0, i64 400, i1 false)
  br label %outer.header

outer.header:                              ; preds = %for.inc14, %entry
  %indvars.iv63 = phi i64 [ 64, %entry ], [ %indvars.iv.next64, %for.inc14 ]
  %nz.061 = phi i32 [ 1, %entry ], [ %nz.2.lcssa, %for.inc14 ]
  br label %for.body4

for.body4:                                        ; preds = %outer.header, %for.inc
  %indvars.iv = phi i64 [ 1, %outer.header ], [ %indvars.iv.next, %for.inc ]
  %nz.159 = phi i32 [ %nz.061, %outer.header ], [ %nz.2, %for.inc ]
  %arrayidx6 = getelementptr inbounds [100 x [100 x i32]], [100 x [100 x i32]]* %zo, i64 0, i64 %indvars.iv, i64 0
  %2 = load i32, i32* %arrayidx6, align 16
  %cmp9 = icmp eq i32 %2, 0
  br i1 %cmp9, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body4
  %arrayidx13 = getelementptr inbounds [100 x i32], [100 x i32]* %s1, i64 0, i64 %indvars.iv
  %3 = load i32, i32* %arrayidx13, align 4
  %sub = add i32 %3, -1
  store i32 %sub, i32* %arrayidx13, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body4, %if.then
  %nz.2 = phi i32 [ %nz.159, %if.then ], [ 0, %for.body4 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %indvars.iv63
  br i1 %exitcond.not, label %for.inc14, label %for.body4

for.inc14:                                        ; preds = %for.inc
  %nz.2.lcssa = phi i32 [ %nz.2, %for.inc ]
  %indvars.iv.next64 = add nsw i64 %indvars.iv63, -1
  %cmp = icmp ugt i64 %indvars.iv.next64, 1
  br i1 %cmp, label %outer.header, label %for.end15

for.end15:                                        ; preds = %for.inc14
  %nz.2.lcssa.lcssa = phi i32 [ %nz.2.lcssa, %for.inc14 ]
  call void @llvm.lifetime.end.p0i8(i64 400, i8* nonnull %1)
  call void @llvm.lifetime.end.p0i8(i64 40000, i8* nonnull %0)
  ret i32 0
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: argmemonly nofree nosync nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg)
