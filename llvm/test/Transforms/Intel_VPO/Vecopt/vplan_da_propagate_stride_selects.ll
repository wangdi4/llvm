; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check that DA propagates stride information for selects with external uniform conditions generating
; a strided VectorShape.

; RUN: opt -VPlanDriver -vplan-dump-da -vplan-force-vf=2 -disable-output %s 2>&1 | FileCheck %s

; REQUIRES: asserts


define void @foo([1024 x i32]* %src, [1024 x i32]* %dest, i1 %cond) {
; CHECK:       Printing Divergence info for Loop at depth 1 containing: [[BB0:BB[0-9]+]]<header><latch><exiting>
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB0]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i64 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i64 0, [[BB1:BB[0-9]+]] ],  [ i64 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB0]] ]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_IND_INIT:%.*]], [[BB1]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB0]] ]
; CHECK-NEXT:  Divergent: [Shape: Strided, Stride: i64 4] i32* [[VP_ARRAYIDX1:%.*]] = getelementptr inbounds [1024 x i32]* [[SRC0:%.*]] i64 0 i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:  Divergent: [Shape: Strided, Stride: i64 4] i32* [[VP_ARRAYIDX2:%.*]] = getelementptr inbounds [1024 x i32]* [[SRC0]] i64 1 i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:  Divergent: [Shape: Strided, Stride: i64 4] i32* [[VP_SELECT_SRC:%.*]] = select i1 [[COND0:%.*]] i32* [[VP_ARRAYIDX1]] i32* [[VP_ARRAYIDX2]]
; CHECK-NEXT:  Divergent: [Shape: Random] i32 [[VP_LOAD:%.*]] = load i32* [[VP_SELECT_SRC]]
; CHECK-NEXT:  Divergent: [Shape: Strided, Stride: i64 4] i32* [[VP_ARRAYIDX3:%.*]] = getelementptr inbounds [1024 x i32]* [[DEST0:%.*]] i64 0 i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:  Divergent: [Shape: Strided, Stride: i64 2] i64 [[VP_IV_2_TIMES:%.*]] = mul i64 [[VP_INDVARS_IV]] i64 2
; CHECK-NEXT:  Divergent: [Shape: Strided, Stride: i64 8] i32* [[VP_ARRAYIDX4:%.*]] = getelementptr inbounds [1024 x i32]* [[DEST0]] i64 1 i64 [[VP_IV_2_TIMES]]
; CHECK-NEXT:  Divergent: [Shape: Strided, Stride: ?] i32* [[VP_SELECT_DEST:%.*]] = select i1 [[COND0]] i32* [[VP_ARRAYIDX3]] i32* [[VP_ARRAYIDX4]]
; CHECK-NEXT:  Divergent: [Shape: Random] store i32 [[VP_LOAD]] i32* [[VP_SELECT_DEST]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i64 [[VP_VECTOR_LOOP_IV_NEXT]] = add i64 [[VP_VECTOR_LOOP_IV]] i64 [[VP_VF:%.*]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i64 [[VP_VECTOR_LOOP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB2:BB[0-9]+]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %entry, %omp.inner.for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %omp.inner.for.body ]
  %arrayidx1 = getelementptr inbounds [1024 x i32], [1024 x i32]* %src, i64 0, i64 %indvars.iv
  %arrayidx2 = getelementptr inbounds [1024 x i32], [1024 x i32]* %src, i64 1, i64 %indvars.iv
  %select.src = select i1 %cond, i32* %arrayidx1, i32* %arrayidx2
  %load = load i32, i32* %select.src, align 8
  %arrayidx3 = getelementptr inbounds [1024 x i32], [1024 x i32]* %dest, i64 0, i64 %indvars.iv
  %iv.2.times = mul i64 %indvars.iv, 2
  %arrayidx4 = getelementptr inbounds [1024 x i32], [1024 x i32]* %dest, i64 1, i64 %iv.2.times
  %select.dest = select i1 %cond, i32* %arrayidx3, i32* %arrayidx4
  store i32 %load, i32* %select.dest, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %omp.inner.for.body, label %omp.loop.exit

omp.loop.exit:                                    ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.QUAL.LIST.END.1

DIR.QUAL.LIST.END.1:                              ; preds = %omp.loop.exit
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry()

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token)

