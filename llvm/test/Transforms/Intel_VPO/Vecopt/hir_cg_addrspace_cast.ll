; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -disable-output -print-after=hir-vplan-vec < %s 2>&1 | FileCheck %s
; RUN: opt -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -disable-output < %s 2>&1 | FileCheck %s

define void @foo(i64 *%p) {
; CHECK-LABEL:  Function: foo
; CHECK:       BEGIN REGION { modified }
; CHECK-NEXT:        + DO i1 = 0, 127, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = addrspacecast.<4 x i64*>.<4 x i64 addrspace(4)*>(&((<4 x i64*>)([[P0:%.*]])[i1 + <i64 0, i64 1, i64 2, i64 3>]))
; CHECK-NEXT:        |   [[EXTRACT_0_0:%.*]] = extractelement [[DOTVEC0]],  0
; CHECK-NEXT:        |   (<4 x i64>*)([[EXTRACT_0_0]])[0] = i1 + <i64 0, i64 1, i64 2, i64 3>
; CHECK-NEXT:        + END LOOP
; CHECK:             ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  %gep = getelementptr i64, i64 *%p, i64 %iv
  %cast = addrspacecast i64 * %gep to i64 addrspace(4) *
  store i64 %iv, i64 addrspace(4)* %cast


  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 128
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
