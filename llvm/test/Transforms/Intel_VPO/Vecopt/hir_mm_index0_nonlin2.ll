; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check whether non-linear index is processed w/o assertion.
; REQUIRES: asserts
; RUN: opt -disable-output -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -vplan-entities-dump -enable-mmindex=1  -disable-nonlinear-mmindex=0 -vplan-print-after-vpentity-instrs -vplan-print-after-plain-cfg -print-after=hir-vplan-vec -vplan-force-vf=4 -S < %s 2>&1 | FileCheck %s

; source code
;int ordering[1000];
;int  maxloc (int m) {
;    int best = -111111111;
;    int tmp = 0;
;    int val = 0;
;    for (int i=0; i< m; i++) {
;        if (ordering[i] > best) {
;            best = ordering[i];
;            tmp = i;
;            val = ordering[i]+2;
;        }
;    }
;    return tmp + best+val;
;}
;
; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @maxloc(i32 %m, i32* nocapture readonly %ordering) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: maxloc:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%val.025}
; CHECK-DAG:     [[VP1:%.*]] = {%best.023}
; CHECK-DAG:     [[VP2:%.*]] = {sext.i32.i64(%m) + -1}
; CHECK-DAG:     [[VP3:%.*]] = {%ordering}
; CHECK-DAG:     [[VP4:%.*]] = {%tmp.024}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   signed (SIntMax) Start: i32 [[BEST_0230:%.*]] Exit: i32 [[VP5:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP6:%.*]], i32 [[VP5]],
; CHECK-EMPTY:
; CHECK-NEXT:   signed (SIntMin) Start: i32 [[TMP_0240:%.*]] Exit: i32 [[VP7:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP8:%.*]], i32 [[VP7]],
; CHECK-NEXT:  IsLinearIndex: 0 Parent exit: i32 [[VP5]]
; CHECK-NEXT:   signed (SIntMin) Start: i32 [[VAL_0250:%.*]] Exit: i32 [[VP9:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP10:%.*]], i32 [[VP9]],
; CHECK-NEXT:  IsLinearIndex: 0 Parent exit: i32 [[VP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: ? BinOp: i64 [[VP11:%.*]] = add i64 [[VP12:%.*]] i64 1
; CHECK-NEXT:    Linked values: i64 [[VP12]], i64 [[VP11]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i64 [[UB_INC:%.*]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB0]]
; CHECK-NEXT:     i32 [[VP10]] = phi  [ i32 [[VAL_0250]], [[BB2]] ],  [ i32 [[VP9]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP8]] = phi  [ i32 [[TMP_0240]], [[BB2]] ],  [ i32 [[VP7]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP6]] = phi  [ i32 [[BEST_0230]], [[BB2]] ],  [ i32 [[VP5]], [[BB0]] ]
; CHECK-NEXT:     i64 [[VP12]] = phi  [ i64 0, [[BB2]] ],  [ i64 [[VP11]], [[BB0]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[ORDERING0:%.*]] i64 [[VP12]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i32 [[VP13:%.*]] = trunc i64 [[VP12]] to i32
; CHECK-NEXT:     i1 [[VP14:%.*]] = icmp sgt i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i32 [[VP7]] = select i1 [[VP14]] i32 [[VP13]] i32 [[VP8]]
; CHECK-NEXT:     i32 [[VP15:%.*]] = add i32 [[VP_LOAD]] i32 2
; CHECK-NEXT:     i1 [[VP16:%.*]] = icmp sgt i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i32 [[VP9]] = select i1 [[VP16]] i32 [[VP15]] i32 [[VP10]]
; CHECK-NEXT:     i1 [[VP17:%.*]] = icmp sgt i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i32 [[VP5]] = select i1 [[VP17]] i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i64 [[VP11]] = add i64 [[VP12]] i64 1
; CHECK-NEXT:     i1 [[VP18:%.*]] = icmp slt i64 [[VP11]] i64 [[UB_INC]]
; CHECK-NEXT:     br i1 [[VP18]], [[BB0]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP7]] -> [[VP19:%.*]] = {%tmp.024}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1   i32 [[VP9]] -> [[VP20:%.*]] = {%val.025}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 2   i32 [[VP5]] -> [[VP21:%.*]] = {%best.023}
;
; CHECK:       VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: maxloc:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0]] = {%val.025}
; CHECK-DAG:     [[VP1]] = {%best.023}
; CHECK-DAG:     [[VP2]] = {sext.i32.i64(%m) + -1}
; CHECK-DAG:     [[VP3]] = {%ordering}
; CHECK-DAG:     [[VP4]] = {%tmp.024}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   signed (SIntMax) Start: i32 [[BEST_0230]] Exit: i32 [[VP5]]
; CHECK-NEXT:    Linked values: i32 [[VP6]], i32 [[VP5]], i32 [[VP_MINMAX_RED_INIT:%.*]], i32 [[VP_MINMAX_RED_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK-NEXT:   signed (SIntMin) Start: i32 [[TMP_0240]] Exit: i32 [[VP7]]
; CHECK-NEXT:    Linked values: i32 [[VP8]], i32 [[VP7]], i32 [[VP_IDX_RED_INIT:%.*]], i32 [[VP_IDX_RED_FINAL:%.*]],
; CHECK-NEXT:  IsLinearIndex: 0 Parent exit: i64 [[VP22:%.*]]
; CHECK-NEXT:   signed (SIntMin) Start: i32 [[VAL_0250]] Exit: i32 [[VP9]]
; CHECK-NEXT:    Linked values: i32 [[VP10]], i32 [[VP9]], i32 [[VP_IDX_RED_INIT_1:%.*]], i32 [[VP_IDX_RED_FINAL_1:%.*]],
; CHECK-NEXT:  IsLinearIndex: 0 Parent exit: i64 [[VP22]]
; CHECK-NEXT:   signed (SIntMin) Start: i64 9223372036854775807 Exit: i64 [[VP22]]
; CHECK-NEXT:    Linked values: i64 [[VP23:%.*]], i64 [[VP22]], i64 [[VP_MONO_IDX_RED_INIT:%.*]], i64 [[VP_MONO_IDX_RED_FINAL:%.*]],
; CHECK-NEXT:  IsLinearIndex: 1 Parent exit: i32 [[VP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: ? BinOp: i64 [[VP11]] = add i64 [[VP12]] i64 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP12]], i64 [[VP11]], i64 [[VP__IND_INIT:%.*]], i64 [[VP__IND_INIT_STEP]], i64 [[VP__IND_FINAL:%.*]],
; CHECK:         [[BB1]]: # preds:
; CHECK-NEXT:     br [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i64 [[UB_INC]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i32 [[VP_MINMAX_RED_INIT]] = reduction-init i32 [[BEST_0230]]
; CHECK-NEXT:     i64 [[VP_MONO_IDX_RED_INIT]] = reduction-init i64 9223372036854775807
; CHECK-NEXT:     i32 [[VP_IDX_RED_INIT]] = reduction-init i32 [[TMP_0240]]
; CHECK-NEXT:     i32 [[VP_IDX_RED_INIT_1]] = reduction-init i32 [[VAL_0250]]
; CHECK-NEXT:     i64 [[VP__IND_INIT]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     i64 [[VP__IND_INIT_STEP]] = induction-init-step{add} i64 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB0]]
; CHECK-NEXT:     i32 [[VP10]] = phi  [ i32 [[VP_IDX_RED_INIT_1]], [[BB2]] ],  [ i32 [[VP9]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP8]] = phi  [ i32 [[VP_IDX_RED_INIT]], [[BB2]] ],  [ i32 [[VP7]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP6]] = phi  [ i32 [[VP_MINMAX_RED_INIT]], [[BB2]] ],  [ i32 [[VP5]], [[BB0]] ]
; CHECK-NEXT:     i64 [[VP12]] = phi  [ i64 [[VP__IND_INIT]], [[BB2]] ],  [ i64 [[VP11]], [[BB0]] ]
; CHECK-NEXT:     i64 [[VP23]] = phi  [ i64 [[VP_MONO_IDX_RED_INIT]], [[BB2]] ],  [ i64 [[VP22]], [[BB0]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT]] = subscript inbounds i32* [[ORDERING0]] i64 [[VP12]]
; CHECK-NEXT:     i32 [[VP_LOAD]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i32 [[VP13]] = trunc i64 [[VP12]] to i32
; CHECK-NEXT:     i1 [[VP14]] = icmp sgt i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i64 [[VP22]] = select i1 [[VP14]] i64 [[VP12]] i64 [[VP23]]
; CHECK-NEXT:     i32 [[VP7]] = select i1 [[VP14]] i32 [[VP13]] i32 [[VP8]]
; CHECK-NEXT:     i32 [[VP15]] = add i32 [[VP_LOAD]] i32 2
; CHECK-NEXT:     i1 [[VP16]] = icmp sgt i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i32 [[VP9]] = select i1 [[VP16]] i32 [[VP15]] i32 [[VP10]]
; CHECK-NEXT:     i1 [[VP17]] = icmp sgt i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i32 [[VP5]] = select i1 [[VP17]] i32 [[VP_LOAD]] i32 [[VP6]]
; CHECK-NEXT:     i64 [[VP11]] = add i64 [[VP12]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP18]] = icmp slt i64 [[VP11]] i64 [[UB_INC]]
; CHECK-NEXT:     br i1 [[VP18]], [[BB0]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP_MINMAX_RED_FINAL]] = reduction-final{u_smax} i32 [[VP5]]
; CHECK-NEXT:     i64 [[VP_MONO_IDX_RED_FINAL]] = reduction-final{s_smin} i64 [[VP22]] i32 [[VP5]] i32 [[VP_MINMAX_RED_FINAL]]
; CHECK-NEXT:     i32 [[VP_IDX_RED_FINAL]] = reduction-final{s_smin} i32 [[VP7]] i64 [[VP22]] i64 [[VP_MONO_IDX_RED_FINAL]]
; CHECK-NEXT:     i32 [[VP_IDX_RED_FINAL_1]] = reduction-final{s_smin} i32 [[VP9]] i64 [[VP22]] i64 [[VP_MONO_IDX_RED_FINAL]]
; CHECK-NEXT:     i64 [[VP__IND_FINAL]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     br [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP_IDX_RED_FINAL]] -> [[VP19]] = {%tmp.024}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1   i32 [[VP_IDX_RED_FINAL_1]] -> [[VP20]] = {%val.025}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 2   i32 [[VP_MINMAX_RED_FINAL]] -> [[VP21]] = {%best.023}
;
;CHECK:       BEGIN REGION { modified }
;CHECK:                + END LOOP
;CHECK:                %[[best023:.*]] = @llvm.vector.reduce.smax.v4i32(%.[[vec14:.*]]);
;CHECK-NEXT:           %[[idxblend:.*]] = (%[[best023]] == %.[[vec14]]) ? %.[[vec11:.*]] : <i64 9223372036854775807, i64 9223372036854775807, i64 9223372036854775807, i64 9223372036854775807>;
;CHECK-NEXT:           %[[vecreduce19:.*]] = @llvm.vector.reduce.smin.v4i64(%[[idxblend]]);
;CHECK-NEXT:           %[[mmidxcmp:.*]] = %[[vecreduce19]] == %.[[vec11]];
;CHECK-NEXT:           %bsfintmask = bitcast.<4 x i1>.i4(%[[mmidxcmp]]);
;CHECK-NEXT:           %bsf = @llvm.cttz.i4(%bsfintmask,  1);
;CHECK-NEXT:           %[[tmp024:.*]] = extractelement %.[[vec12:.*]], %bsf;
;CHECK-NEXT:           %[[mmidxcmp20:.*]] = %[[vecreduce19]] == %.[[vec11]];
;CHECK-NEXT:           %[[bsfintmask21:.*]] = bitcast.<4 x i1>.i4(%[[mmidxcmp20]]);
;CHECK-NEXT:           %[[bsf22:.*]] = @llvm.cttz.i4(%[[bsfintmask21]],  1);
;CHECK-NEXT:           %[[val025:.*]] = extractelement %.[[vec13:.*]],  %[[bsf22]];
;CHECK:             }
;CHECK:             + DO i1 = {{.*}}, sext.i32.i64(%m) + -1, 1   <DO_LOOP>
;CHECK-NEXT:        |   [[TMP0:%.*]] = (%ordering)[i1];
;CHECK-NEXT:        |   %[[tmp024]] = ([[TMP0]] > %[[best023]]) ? i1 : %[[tmp024]];
;CHECK-NEXT:        |   %[[val025]] = ([[TMP0]] > %[[best023]]) ? [[TMP0]] + 2 : %[[val025]];
;CHECK-NEXT:        |   %[[best023]] = ([[TMP0]] > %[[best023]]) ? [[TMP0]] : %[[best023]];
;CHECK-NEXT:        + END LOOP
;CHECK:       END REGION
entry:
  %cmp22 = icmp sgt i32 %m, 0
  br i1 %cmp22, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = sext i32 %m to i64
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %val.025 = phi i32 [ 0, %for.body.preheader ], [ %spec.select21, %for.body ]
  %tmp.024 = phi i32 [ 0, %for.body.preheader ], [ %spec.select20, %for.body ]
  %best.023 = phi i32 [ -111111111, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %ordering, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %cmp1 = icmp sgt i32 %0, %best.023
  %add = add nsw i32 %0, 2
  %spec.select = select i1 %cmp1, i32 %0, i32 %best.023
; This instriction causes having non-linear index
  %trunc = trunc i64 %indvars.iv to i32
  %spec.select20 = select i1 %cmp1, i32 %trunc, i32 %tmp.024
  %spec.select21 = select i1 %cmp1, i32 %add, i32 %val.025
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %for.body
  %spec.select.lcssa = phi i32 [ %spec.select, %for.body ]
  %spec.select20.lcssa = phi i32 [ %spec.select20, %for.body ]
  %spec.select21.lcssa = phi i32 [ %spec.select21, %for.body ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %best.0.lcssa = phi i32 [ -111111111, %entry ], [ %spec.select.lcssa, %for.end.loopexit ]
  %tmp.0.lcssa = phi i32 [ 0, %entry ], [ %spec.select20.lcssa, %for.end.loopexit ]
  %val.0.lcssa = phi i32 [ 0, %entry ], [ %spec.select21.lcssa, %for.end.loopexit ]
  %add6 = add nsw i32 %tmp.0.lcssa, %best.0.lcssa
  %add7 = add nsw i32 %add6, %val.0.lcssa
  ret i32 %add6
};
attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+avx,+avx2,+bmi,+bmi2,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" "unsafe-fp-math"="false" "use-soft-float"="false" }

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"icx (ICX) dev.8.x.0"}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}

