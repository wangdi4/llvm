; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Verify that VPlan handles non-vectorizable PHIs like those producing
; StructType via serialization.
; RUN: opt -vplan-vec -vplan-force-vf=2 -S < %s | FileCheck %s

define void @foo(i32** %uni) {
; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK:         [[SERIAL_CMPXCHG:%.*]] = cmpxchg i32* [[TMP0:%.*]], i32 [[TMP1:%.*]], i32 [[TMP2:%.*]] seq_cst seq_cst, align 4
; CHECK-NEXT:    [[SERIAL_CMPXCHG3:%.*]] = cmpxchg i32* [[TMP0]], i32 [[TMP1]], i32 [[TMP2]] seq_cst seq_cst, align 4

; CHECK:       VPlannedBB6:
; CHECK-NEXT:    [[SERIAL_PHI:%.*]] = phi { i32, i1 } [ [[SERIAL_CMPXCHG]], [[VPLANNEDBB5:%.*]] ], [ [[TMP20:%.*]], [[VPLANNEDBB18:%.*]] ]
; CHECK-NEXT:    [[SERIAL_PHI7:%.*]] = phi { i32, i1 } [ [[SERIAL_CMPXCHG3]], [[VPLANNEDBB5]] ], [ [[TMP23:%.*]], [[VPLANNEDBB18]] ]

; CHECK:       VPlannedBB10:
; CHECK:         [[SERIAL_EXTRACTVALUE11:%.*]] = extractvalue { i32, i1 } [[SERIAL_PHI]], 0
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x i32> undef, i32 [[SERIAL_EXTRACTVALUE11]], i32 0
; CHECK-NEXT:    [[SERIAL_EXTRACTVALUE12:%.*]] = extractvalue { i32, i1 } [[SERIAL_PHI7]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = insertelement <2 x i32> [[TMP10]], i32 [[SERIAL_EXTRACTVALUE12]], i32 1

; CHECK:       pred.cmpxchg.if:
; CHECK-NEXT:    [[SERIAL_CMPXCHG13:%.*]] = cmpxchg i32* [[TMP16:%.*]], i32 [[SERIAL_EXTRACTVALUE11]], i32 [[DOTEXTRACT_0_:%.*]] seq_cst seq_cst, align 4
; CHECK-NEXT:    br label [[TMP19:%.*]]
; CHECK:       19:
; CHECK-NEXT:    [[TMP20]] = phi { i32, i1 } [ undef, [[PRED_LOAD_CONTINUE:%.*]] ], [ [[SERIAL_CMPXCHG13]], [[PRED_CMPXCHG_IF:%.*]] ]
; CHECK-NEXT:    br label [[PRED_CMPXCHG_CONTINUE:%.*]]

; CHECK:       pred.cmpxchg.if26:
; CHECK-NEXT:    [[SERIAL_CMPXCHG15:%.*]] = cmpxchg i32* [[TMP16]], i32 [[SERIAL_EXTRACTVALUE12]], i32 [[DOTEXTRACT_1_i:%.*]] seq_cst seq_cst, align 4
; CHECK-NEXT:    br label [[TMP22:%.*]]
; CHECK:       22:
; CHECK-NEXT:    [[TMP23]] = phi { i32, i1 } [ undef, [[PRED_CMPXCHG_CONTINUE]] ], [ [[SERIAL_CMPXCHG15]], [[PRED_CMPXCHG_IF26:%.*]] ]
; CHECK-NEXT:    br label [[PRED_CMPXCHG_CONTINUE27:%.*]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %for.exit ]
  %uni.ld = load i32*, i32** %uni, align 8
  %uni.ld.ld = load i32, i32* %uni.ld, align 4
  %add = add nsw i32 %uni.ld.ld, 1
  %xchg1 = cmpxchg i32* %uni.ld, i32 %uni.ld.ld, i32 %add seq_cst seq_cst, align 4
  %cmp.not = extractvalue { i32, i1 } %xchg1, 1
  br i1 %cmp.not, label %for.exit, label %inner.loop.ph

inner.loop.ph:
  br label %inner.loop

inner.loop:
  %phi = phi { i32, i1 } [ %xchg1, %inner.loop.ph ], [ %xchg.update, %inner.loop ]
  %phi.extract = extractvalue { i32, i1 } %phi, 0
  %uni.ld.1 = load i32*, i32** %uni, align 8
  %add.1 = add nsw i32 %phi.extract, 1
  %xchg.update = cmpxchg i32* %uni.ld.1, i32 %phi.extract, i32 %add.1 seq_cst seq_cst, align 4
  %cmp.not.1 = extractvalue { i32, i1 } %xchg.update, 1
  br i1 %cmp.not.1, label %inner.loop.exit, label %inner.loop

inner.loop.exit:
  br label %for.exit

for.exit:
  %iv.next = add i64 %iv, 1
  %exitcond.not = icmp eq i64 %iv.next, 1024
  br i1 %exitcond.not, label %exit, label %for.body

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1
