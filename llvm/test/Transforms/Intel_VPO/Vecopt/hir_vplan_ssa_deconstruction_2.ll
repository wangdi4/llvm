; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; Test to check correctness of VPlan pseudo SSA deconstruction transform and
; vector CG for a slightly complex control flow involving uniform and divergent
; conditions.
;       for.body<---+
;          |        |
;         BB0 (U)   |
;       /     \     |
;     BB1 (D)  |    |
;    /   \     |    |
;   /     \    |    |
;  BB3   BB2   |    |
;   \    /    /     |
;    BB4<----+      |
;     |             |
;    Latch----------+

; Incoming HIR
;   BEGIN REGION { }
;         %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
;
;         + DO i1 = 0, 99, 1   <DO_LOOP>
;         |   %ld = (%arr)[i1];
;         |   %merge.phi = %ld;
;         |   if (%n1 != 0)
;         |   {
;         |      %0 = %ld  +  0.000000e+00;
;         |      (%arr)[i1] = %0;
;         |      if (%ld == 0.000000e+00)
;         |      {
;         |         %1 = %0  +  1.000000e+00;
;         |         (%arr)[i1] = %1;
;         |         %merge.phi = %1;
;         |      }
;         |      else
;         |      {
;         |         %2 = %0  +  2.000000e+00;
;         |         (%arr)[i1] = %2;
;         |         %merge.phi = %2;
;         |      }
;         |   }
;         |   %red.phi = %merge.phi  +  %red.phi; <Safe Reduction>
;         + END LOOP
;
;         @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
;   END REGION


; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -vplan-force-linearization-hir=false -vplan-force-vf=4 -print-after=VPlanDriverHIR -vplan-print-after-ssa-deconstruction -disable-output < %s 2>&1 | FileCheck %s

define void @foo(float* noalias nocapture %arr, i32 %n1) {
; CHECK-LABEL:  After VPlan SSA deconstruction
; CHECK-NEXT:  VPlan IR for: Initial VPlan for VF=4
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] float [[VP__RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-NEXT:     [DA: Div] i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] float [[VP0:%.*]] = phi  [ float [[VP__RED_INIT]], [[BB1]] ],  [ float [[VP1:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] float* [[VP4:%.*]] = getelementptr inbounds float* [[ARR0:%.*]] i64 [[VP2]]
; CHECK-NEXT:     [DA: Div] float [[VP5:%.*]] = load float* [[VP4]]
; CHECK-NEXT:     [DA: Div] float [[VP6:%.*]] =  call float [[VP5]] float (float)* @llvm.ssa.copy.f32
; CHECK-NEXT:     [DA: Uni] i1 [[VP7:%.*]] = icmp i32 [[N10:%.*]] i32 0
; CHECK-NEXT:     [DA: Div] float [[VP8:%.*]] = hir-copy float [[VP0]] , OriginPhiId: 0
; CHECK-NEXT:     [DA: Div] float [[VP9:%.*]] = hir-copy float [[VP6]] , OriginPhiId: 1
; CHECK-NEXT:    SUCCESSORS(2):[[BB4:BB[0-9]+]](i1 [[VP7]]), [[BB3]](!i1 [[VP7]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       [DA: Div] float [[VP10:%.*]] = fadd float [[VP5]] float 0.000000e+00
; CHECK-NEXT:       [DA: Div] float* [[VP11:%.*]] = getelementptr inbounds float* [[ARR0]] i64 [[VP2]]
; CHECK-NEXT:       [DA: Div] store float [[VP10]] float* [[VP11]]
; CHECK-NEXT:       [DA: Div] i1 [[VP12:%.*]] = fcmp float [[VP5]] float 0.000000e+00
; CHECK-NEXT:       [DA: Div] i1 [[VP__NOT:%.*]] = not i1 [[VP12]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP13:%.*]] = block-predicate i1 [[VP__NOT]]
; CHECK-NEXT:       [DA: Div] float [[VP14:%.*]] = fadd float [[VP10]] float 2.000000e+00
; CHECK-NEXT:       [DA: Div] float* [[VP15:%.*]] = getelementptr inbounds float* [[ARR0]] i64 [[VP2]]
; CHECK-NEXT:       [DA: Div] store float [[VP14]] float* [[VP15]]
; CHECK-NEXT:       [DA: Div] float [[VP16:%.*]] = call float [[VP14]] float (float)* @llvm.ssa.copy.f32
; CHECK-NEXT:      SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP17:%.*]] = block-predicate i1 [[VP12]]
; CHECK-NEXT:       [DA: Div] float [[VP18:%.*]] = fadd float [[VP10]] float 1.000000e+00
; CHECK-NEXT:       [DA: Div] float* [[VP19:%.*]] = getelementptr inbounds float* [[ARR0]] i64 [[VP2]]
; CHECK-NEXT:       [DA: Div] store float [[VP18]] float* [[VP19]]
; CHECK-NEXT:       [DA: Div] float [[VP20:%.*]] = call float [[VP18]] float (float)* @llvm.ssa.copy.f32
; CHECK-NEXT:      SUCCESSORS(1):[[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]:
; CHECK-NEXT:       [DA: Div] float [[VP21:%.*]] = blend [ float [[VP0]], i1 [[VP__NOT]] ], [ float [[VP0]], i1 [[VP12]] ]
; CHECK-NEXT:       [DA: Div] float [[VP22:%.*]] = blend [ float [[VP16]], i1 [[VP__NOT]] ], [ float [[VP20]], i1 [[VP12]] ]
; CHECK-NEXT:       [DA: Div] float [[VP23:%.*]] = hir-copy float [[VP21]] , OriginPhiId: 0
; CHECK-NEXT:       [DA: Div] float [[VP24:%.*]] = hir-copy float [[VP22]] , OriginPhiId: 1
; CHECK-NEXT:      SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] float [[VP25:%.*]] = phi  [ float [[VP8]], [[BB2]] ],  [ float [[VP23]], [[BLEND_BB0]] ]
; CHECK-NEXT:     [DA: Div] float [[VP26:%.*]] = phi  [ float [[VP9]], [[BB2]] ],  [ float [[VP24]], [[BLEND_BB0]] ]
; CHECK-NEXT:     [DA: Div] float [[VP1]] = fadd float [[VP26]] float [[VP25]]
; CHECK-NEXT:     [DA: Div] i64 [[VP3]] = add i64 [[VP2]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP27:%.*]] = icmp i64 [[VP3]] i64 99
; CHECK-NEXT:    SUCCESSORS(2):[[BB2]](i1 [[VP27]]), [[BB7:BB[0-9]+]](!i1 [[VP27]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB2]] [[BLEND_BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Uni] float [[VP__RED_FINAL:%.*]] = reduction-final{fadd} float [[VP1]] float [[RED_PHI0:%.*]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:  *** IR Dump After VPlan Vectorization Driver HIR ***
; CHECK-NEXT:  Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:  <0>          BEGIN REGION { modified }
; CHECK-NEXT:  <37>               [[RED_VAR0:%.*]] = 0.000000e+00
; CHECK-NEXT:  <36>
; CHECK-NEXT:  <36>               + DO i1 = 0, 99, 4   <DO_LOOP> <novectorize>
; CHECK-NEXT:  <63>               |   [[DOTVEC90:%.*]] = undef
; CHECK-NEXT:  <59>               |   [[MERGE_PHI_IN_VEC0:%.*]] = undef
; CHECK-NEXT:  <56>               |   [[DOTVEC70:%.*]] = undef
; CHECK-NEXT:  <38>               |   [[BB2]].{{[0-9]+}}:
; CHECK-NEXT:  <39>               |   [[LD_VEC0:%.*]] = (<4 x float>*)([[ARR0]])[i1]
; CHECK-NEXT:  <40>               |   [[MERGE_PHI_IN_VEC0]] = [[LD_VEC0]]
; CHECK-NEXT:  <41>               |   [[WIDE_CMP_0:%.*]] = [[N10]] != 0
; CHECK-NEXT:  <42>               |   [[PHI_TEMP0:%.*]] = [[RED_VAR0]]
; CHECK-NEXT:  <43>               |   [[PHI_TEMP30:%.*]] = [[MERGE_PHI_IN_VEC0]]
; CHECK-NEXT:  <44>               |   [[UNIFCOND0:%.*]] = extractelement [[WIDE_CMP_0]],  0
; CHECK-NEXT:  <45>               |   if ([[UNIFCOND0]] == 1)
; CHECK-NEXT:  <45>               |   {
; CHECK-NEXT:  <46>               |      goto [[BB4]].{{[0-9]+}}
; CHECK-NEXT:  <45>               |   }
; CHECK-NEXT:  <45>               |   else
; CHECK-NEXT:  <45>               |   {
; CHECK-NEXT:  <47>               |      goto [[BB3]].{{[0-9]+}}
; CHECK-NEXT:  <45>               |   }
; CHECK-NEXT:  <48>               |   [[BB4]].{{[0-9]+}}:
; CHECK-NEXT:  <49>               |   [[DOTVEC0:%.*]] = [[LD_VEC0]]  +  0.000000e+00
; CHECK-NEXT:  <50>               |   (<4 x float>*)([[ARR0]])[i1] = [[DOTVEC0]]
; CHECK-NEXT:  <51>               |   [[WIDE_CMP_50:%.*]] = [[LD_VEC0]] == 0.000000e+00
; CHECK-NEXT:  <52>               |   [[DOTVEC60:%.*]] = [[WIDE_CMP_50]]  ^  -1
; CHECK-NEXT:  <53>               |   goto [[BB5]].{{[0-9]+}}
; CHECK-NEXT:  <54>               |   [[BB5]].{{[0-9]+}}:
; CHECK-NEXT:  <55>               |   [[DOTVEC70]] = [[DOTVEC0]]  +  2.000000e+00
; CHECK-NEXT:  <57>               |   (<4 x float>*)([[ARR0]])[i1] = [[DOTVEC70]]
; CHECK-NEXT:  <58>               |   [[MERGE_PHI_IN_VEC0]] = [[DOTVEC70]]
; CHECK-NEXT:  <60>               |   goto [[BB6]].{{[0-9]+}}
; CHECK-NEXT:  <61>               |   [[BB6]].{{[0-9]+}}:
; CHECK-NEXT:  <62>               |   [[DOTVEC90]] = [[DOTVEC0]]  +  1.000000e+00
; CHECK-NEXT:  <64>               |   (<4 x float>*)([[ARR0]])[i1] = [[DOTVEC90]]
; CHECK-NEXT:  <65>               |   [[MERGE_PHI_IN_VEC0]] = [[DOTVEC90]]
; CHECK-NEXT:  <66>               |   goto [[BLEND_BB0]].{{[0-9]+}}
; CHECK-NEXT:  <67>               |   [[BLEND_BB0]].{{[0-9]+}}:
; CHECK-NEXT:  <68>               |   [[PHI_TEMP0]] = [[RED_VAR0]]
; CHECK-NEXT:  <69>               |   [[PHI_TEMP30]] = [[MERGE_PHI_IN_VEC0]]
; CHECK-NEXT:  <70>               |   goto [[BB3]].{{[0-9]+}}
; CHECK-NEXT:  <71>               |   [[BB3]].{{[0-9]+}}:
; CHECK-NEXT:  <72>               |   [[RED_VAR0]] = [[PHI_TEMP30]]  +  [[RED_VAR0]]
; CHECK-NEXT:  <36>               + END LOOP
; CHECK-NEXT:  <36>
; CHECK-NEXT:  <73>               [[RED_PHI0]] = @llvm.experimental.vector.reduce.v2.fadd.f32.v4f32([[RED_PHI0]],  [[RED_VAR0]])
; CHECK-NEXT:  <0>          END REGION
;


entry:
  %tobool = icmp eq i32 %n1, 0
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %red.phi = phi float [0.0, %entry], [%red.add, %for.inc]
  %arrayidx = getelementptr inbounds float, float* %arr, i64 %indvars.iv
  %ld = load float, float* %arrayidx, align 4
  %div.cond = fcmp oeq float %ld, 0.0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %0 = fadd float %ld, 0.0
  store float %0, float* %arrayidx, align 4
  br i1 %div.cond, label %div.then, label %div.else

div.then:
  %1 = fadd float %0, 1.0
  store float %1, float* %arrayidx, align 4
  br label %for.inc

div.else:
  %2 = fadd float %0, 2.0
  store float %2, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %merge.phi = phi float [%ld, %for.body], [%1, %div.then], [%2, %div.else]
  %red.add = fadd fast float %merge.phi, %red.phi
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  ret void
}
