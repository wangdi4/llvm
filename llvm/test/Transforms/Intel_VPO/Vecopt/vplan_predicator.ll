; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt -S -vplan-func-vec -print-after-vplan-func-vec-predicator < %s -disable-output | FileCheck %s
; RUN: opt -S -passes="vplan-func-vec" -print-after-vplan-func-vec-predicator < %s -disable-output | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @test_uniform_edge_to_divergent_block(i32* %a, i32 %b) local_unnamed_addr {
; CHECK-LABEL:  VPlan IR for: test_uniform_edge_to_divergent_block
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM_NOT:%.*]] = not i1 [[VP_BB0_UNIFORM]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_BB0_UNIFORM]], [[BB2:BB[0-9]+]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:       [DA: Uni] br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB1]], [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT_PHI_BB4:%.*]] = phi  [ i1 false, [[BB1]] ],  [ i1 [[VP_BB1_VARYING_NOT]], [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = or i1 [[VP_BB0_UNIFORM_NOT]] i1 [[VP_BB1_VARYING_NOT_PHI_BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;          entry
;           |
;         BB0 (U)
;       /     \
;     BB1 (D)  |
;    /   \    /
;   /     \ /
;  BB3   BB2
;   \    /
;    BB4
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_two_linearized_pathes_merge(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_two_linearized_pathes_merge
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_BB0_UNIFORM]], [[BB2:BB[0-9]+]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:       [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:       [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:       [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB1_VARYING]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB1_VARYING_NOT]] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:       [DA: Uni] br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB8]], [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_PHI_BB5:%.*]] = phi  [ i1 false, [[BB8]] ],  [ i1 [[VP_BB2_VARYING]], [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT]], [[BB8]] ],  [ i1 false, [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 [[VP_BB1_VARYING_NOT]], [[BB8]] ],  [ i1 false, [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = or i1 [[VP_BB2_VARYING_PHI_BB5]] i1 [[VP_BB1_VARYING_NOT_PHI_BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT_PHI_BB5]] i1 [[VP4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;           entry
;            |
;           BB0 (U)
;          /    \
;         /      \
;      BB1 (D)   BB2 (D)
;     /   \      /  \
;  BB3     +    /    \
;  |  \    |   /      \
;  |    BB4    |      |
;  |      \    /      |
;  |        BB5       BB6
;  \         \       /
;   \         \     /
;    +-------> exit
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb4

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb5, label %bb6

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %exit, label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %exit

bb6:
  %bb6.add = add i32 %ld, 6
  br label %exit

exit:
  ret void
}

define void @test_separate_blend_bb_for_2_div_plus_uniform(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_separate_blend_bb_for_2_div_plus_uniform
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_BB0_UNIFORM]], [[BB2:BB[0-9]+]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:       [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]: # preds: [[BB5]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB5:%.*]] = blend [ i32 2, i1 [[VP_BB1_VARYING_NOT]] ], [ i32 3, i1 [[VP_BB1_VARYING]] ]
; CHECK-NEXT:       [DA: Div] br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB1]], [[BLEND_BB0]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_PHI_BLEND_BB5]], [[BLEND_BB0]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;        entry
;          |
;         BB0 (U)
;       /     \
;     BB1 (D)  |
;    /   \     |
;   /     \    |
;  BB3   BB2   |
;   \    /    /
;    BB4<----+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb4

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %phi = phi i32 [ 0, %bb0 ], [ 2, %bb2 ], [ 3, %bb3 ]
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_two_blend_bbs(i32* %a, i32 %b)  local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_two_blend_bbs
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_BB0_UNIFORM]], [[BB2:BB[0-9]+]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Uni] i1 [[VP_BB4_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_BB4_UNIFORM]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB5]]: # preds: [[BB3]]
; CHECK-NEXT:         [DA: Div] i1 [[VP_BB5_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:         [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:         [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:         [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB5_VARYING]]
; CHECK-NEXT:         [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:         [DA: Uni] br [[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BLEND_BB0]]: # preds: [[BB6]]
; CHECK-NEXT:         [DA: Div] i32 [[VP_PHI_BLEND_BB7:%.*]] = blend [ i32 5, i1 true ], [ i32 6, i1 [[VP_BB5_VARYING]] ]
; CHECK-NEXT:         [DA: Div] br [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:       [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB1:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB1]]: # preds: [[BB8]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB8:%.*]] = blend [ i32 2, i1 [[VP_BB1_VARYING_NOT]] ], [ i32 3, i1 [[VP_BB1_VARYING]] ]
; CHECK-NEXT:       [DA: Div] br [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]], [[BLEND_BB0]], [[BLEND_BB1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 4, [[BB3]] ],  [ i32 [[VP_PHI_BLEND_BB7]], [[BLEND_BB0]] ],  [ i32 [[VP_PHI_BLEND_BB8]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;       entry
;          |
;         BB0 (U)
;       /     \
;     BB1 (D)  BB4 (U)
;    /   \      /  \
;   /     \    /    BB5 (D)
;  BB3   BB2  |    / |
;   \     |   | BB6  |
;    \    |   | /    /
;     \   |  / /    /
;      \  | / /    /
;       +>BB7<----+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb4

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb7

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb7

bb4:
  %bb4.uniform = or i1 %uniform, true
  %bb4.add = add i32 %ld, 4
  br i1 %bb4.uniform, label %bb7, label %bb5

bb5:
  %bb5.varying = or i1 %varying, true
  %bb5.add = add i32 %ld, 5
  br i1 %bb5.varying, label %bb6, label %bb7

bb6:
  %bb6.add = add i32 %ld, 6
  br label %bb7

bb7:
  %phi = phi i32 [5, %bb5], [ 3, %bb3 ], [ 4, %bb4 ],[ 6, %bb6 ], [ 2, %bb2 ]
  %bb7.add = add i32 %ld, 7
  ret void
}

define dso_local void @test_divergent_loop_with_double_top_test(i32 %N, i32 *%a, i32 %mask_out_loop) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_divergent_loop_with_double_top_test
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_SKIP_LOOP:%.*]] = icmp eq i32 [[VP_LANE]] i32 [[MASK_OUT_LOOP0:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_SKIP_LOOP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST:%.*]] = icmp eq i32 [[N0:%.*]] i32 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST_NOT:%.*]] = not i1 [[VP_SECOND_TEST]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST_NOT_1:%.*]] = not i1 [[VP_SECOND_TEST]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT:%.*]] = and i1 [[VP_SKIP_LOOP]] i1 [[VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]], [[BB5:BB[0-9]+]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV:%.*]] = phi  [ i32 [[VP_IV_NEXT:%.*]], [[BB5]] ],  [ i32 0, [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK:%.*]] = phi  [ i1 [[VP_SECOND_TEST_NOT_1]], [[BB3]] ],  [ i1 [[VP_LOOP_MASK_NEXT:%.*]], [[BB5]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_LIVE_OUT_PREV:%.*]] = phi  [ i32 undef, [[BB3]] ],  [ i32 [[VP_IV_LIVE_OUT_BLEND:%.*]], [[BB5]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_LOOP_MASK:%.*]] = and i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] i32* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i32* [[A0:%.*]] i32 [[VP_IV]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LD:%.*]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SOME_CMP:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND:%.*]] = icmp eq i32 [[VP_IV_NEXT]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Uni] br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_LIVE_OUT_BLEND]] = select i1 [[VP_LOOP_MASK]] i32 [[VP_IV]] i32 [[VP_IV_LIVE_OUT_PREV]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND_NOT:%.*]] = not i1 [[VP_EXITCOND]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK_NEXT]] = and i1 [[VP_EXITCOND_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP5:%.*]] = all-zero-check i1 [[VP_LOOP_MASK_NEXT]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP5]], [[BB8:BB[0-9]+]], [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_USE:%.*]] = phi  [ i32 [[VP_IV_LIVE_OUT_BLEND]], [[BB5]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;       entry
;       /     \
;     bb1      \
;    /  \       \
;   +   bb2      +
;   |    |       |
;   |  header<+  |
;   |   | +---+  |
;   +   |        |
;    \  |        |
;     +->exit <--+
  %lane = call i32 @llvm.vplan.laneid()
  %skip_loop = icmp eq i32 %lane, %mask_out_loop
  br i1 %skip_loop, label %bb1, label %exit

bb1:
  %second.test = icmp eq i32 %N, 0
  br i1 %second.test, label %exit, label %bb2

bb2:
  br label %header

header:
  %iv = phi i32 [ %iv.next, %header ], [ 0, %bb2 ]
  %arrayidx = getelementptr inbounds i32, i32* %a, i32 %iv
  %ld = load i32, i32* %arrayidx
  %some_cmp = icmp eq i32 %ld, 42
  %iv.next = add nuw nsw i32 %iv, 1
  %exitcond = icmp eq i32 %iv.next, %lane
  br i1 %exitcond, label %bb3, label %header

bb3:
  %phi_use = phi i32 [ %iv, %header ]
  br label %exit

exit:
  ret void
}

define void @test_single_succ_single_pred_edge(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_single_succ_single_pred_edge
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;       entry
;          |
;         BB0 (D)
;       /    \
;     BB1    BB2
;      |      |
;      |      |
;     BB3    /
;      |    /
;     BB4<-+
; Test checks predicate of the BB3, because BB1-BB3 edge is both single
; successor for BB1 and single predecessor for BB3.
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.add = add i32 %ld, 1
  br label %bb3

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_use_dom_instead_of_direct_succ(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_use_dom_instead_of_direct_succ
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_BB6_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB6_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB4_BR_VP_BB6_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING_NOT:%.*]] = not i1 [[VP_BB7_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB7_VARYING_NOT:%.*]] = and i1 [[VP_BB4_BR_VP_BB6_VARYING]] i1 [[VP_BB7_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB7_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB8_ADD:%.*]] = add i32 [[VP_LD]] i32 8
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:     [DA: Uni] br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB9_BR_VP_BB2_VARYING_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB9_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB11:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]: # preds: [[BB10]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB9_BR_VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:     [DA: Uni] br [[BB12:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]: # preds: [[BB11]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB9_BR_VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Uni] br [[BB13:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]: # preds: [[BB12]]
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = or i1 [[VP_BB4_BR_VP_BB6_VARYING]] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP7]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:     [DA: Uni] br [[BB14:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]: # preds: [[BB13]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;           entry
;             |
;            BB0 (D)
;          /    \
;        BB1 (D) \
;       /  \      BB6 (D)-+
;      +    \       |     |
;      |    BB2    BB7 (D)|
;      |    /  \    |\    |
;      |  BB4  BB3  + BB8 |
;      |    \  /   /   |  |
;      |    BB5<--+    |  |
;      +     | \       |  +
;       \    |  +------+ /
;        \   |          /
;         +-> exit <---+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb6

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %exit, label %bb2

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb4, label %bb3

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb5

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %exit

bb6:
  %bb6.varying = or i1 %varying, true
  %bb6.add = add i32 %ld, 6
  br i1 %bb6.varying, label %bb7, label %exit

bb7:
  %bb7.varying = or i1 %varying, true
  %bb7.add = add i32 %ld, 7
  br i1 %bb7.varying, label %bb5, label %bb8

bb8:
  %bb8.add = add i32 %ld, 8
  br label %bb5

exit:
  ret void
}

define void @test_triple_pred_in_single_linearized_flow(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_triple_pred_in_single_linearized_flow
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB3_BR_VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
; NOTE: Dependent on order of children visiting in RPOT. If BB0-BB2 is changed
; to BB-BB3 the issue isn't reproducible.
; By the time BB2 is processed, edges BB0-BB2 and BB1-BB2 are RemovedDivergent
; and BB2 is disconnected from the linearized BB0-BB1-BB3 chain. The test checks
; that exactly one BB3-BB2 edge is added when connecting BB2 to the linearized
; CFG.
;       entry
; (False) |
;  +----BB0 (D)
;  |    / (True)
;  |  BB1 (D)
;  | /   \
;  |/     \
;  BB2   BB3
;   \    /
;     BB4
;     |
;    exit
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb2, label %bb3

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %exit

exit:
  ret void
}

define void @test_linearized_chain(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_linearized_chain
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB4_BR_VP_BB2_VARYING]] i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
; "White-box" test. Assumes the linearization process visit blocks in order:
; BB0, BB2, BB1. While visiting BB2, edge BB0->BB1 is dropped and at the time
; BB1 is visited we need to attach it directly to BB2. Ensure that unprocessed
; edges from BB2 are not causing crashes (we used to assert for a number of
; outgoing edges inside the linearized chain, but didn't limit it to the blocks
; for which at least once successor was processed).
;       entry
;          |
;         BB0 (D)
;       /     \
;     BB1     BB2
;      \     / |
;       \   /  +
;        BB3  /
;         |  /
;         | /
;        BB4
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.add = add i32 %ld, 1
  br label %bb3

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb3, label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_reuse_idom(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_reuse_idom
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_B00_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB4_BR_VP_BB2_VARYING]] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB3_VARYING:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:     [DA: Uni] br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:     [DA: Uni] br [[BB11:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]: # preds: [[BB10]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
; Check BB6's predicate. Ideally, it should re-use the one from BB3.
;          entry
;            |
;           BB0 (D)
;         /    \
;      BB1 (D)  \
;      /  \      \
;     /    \    BB2 (D)
;     +     \  /   \
;     |      BB3 (D)\
;     |     /  \     +
;     |    /    \    |
;     |   BB5   BB4  |
;     |    \    /    +
;     +     BB6     /
;      \     |     /
;       +-->BB7<--+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %b00.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb7, label %bb3

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb3, label %bb7

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %bb5, label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb6

bb5:
  %bb5.add = add i32 %ld, 5
  br label %bb6

bb6:
  %bb6.add = add i32 %ld, 6
  br label %bb7

bb7:
  %bb7.add = add i32 %ld, 7
  ret void
}

define void @test_blend_splitting_for_early_path_join(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_blend_splitting_for_early_path_join
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_BB0_UNIFORM]], [[BB2:BB[0-9]+]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:       [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:       [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB2_VARYING_NOT]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]: # preds: [[BB5]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB6:%.*]] = blend [ i32 [[VP_BB2_ADD]], i1 true ], [ i32 [[VP_BB3_ADD]], i1 [[VP_BB2_VARYING_NOT]] ]
; CHECK-NEXT:       [DA: Div] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING_NOT:%.*]] = not i1 [[VP_BB4_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:       [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT:%.*]] = and i1 [[VP_BB1_VARYING_NOT]] i1 [[VP_BB4_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB1:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB1]]: # preds: [[BB8]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB8:%.*]] = blend [ i32 [[VP_BB1_ADD]], i1 true ], [ i32 [[VP_BB4_ADD]], i1 [[VP_BB1_VARYING_NOT]] ]
; CHECK-NEXT:       [DA: Div] br [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BLEND_BB0]], [[BLEND_BB1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_PHI_BB7:%.*]] = phi  [ i32 [[VP_PHI_BLEND_BB6]], [[BLEND_BB0]] ],  [ i32 [[VP_PHI_BLEND_BB8]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT_PHI_BB7:%.*]] = phi  [ i1 false, [[BLEND_BB0]] ],  [ i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT_PHI_BB7:%.*]] = phi  [ i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT]], [[BLEND_BB0]] ],  [ i1 false, [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT_PHI_BB7]] i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT_PHI_BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_BLEND_BB7:%.*]] = blend [ i32 [[VP_PHI_PHI_BB7]], i1 true ], [ i32 [[VP_BB5_ADD]], i1 [[VP2]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;          entry
;            |
;           BB0 (U)-----+
;         /              \
;      BB1 (D)            BB2 (D)
;      /  \              /  \
;     /    \            /   BB3 (D)
;     +     \          /  /   \
;     |      BB4 (D)- / -/---->BB5
;     |        \     /  /     |
;     |         \   +  /      |
;     |          \  | /       |
;     |           \ v/        |
;     +---------> BB6 <-------+
; After linearization (approximate, might be different in actual implementation)
; should be like this:
;           entry
;             |
;            BB0
;           /  \
;         BB1  BB2
;          |    |
;         BB4  BB3
;          |    |
;    Blend_1_4  Blend_2_3
;           \   /
;            BB5 RealPhi = [ Blend_1_4, BB4 ], [ Blend_2_3, BB3]
;             |
;            BB6 BlendForOrigPhi (RealPhi, BB5Def) (*)
; (*) can't have a blend with 5 incoming values, none of def1/def4/def2/def3
; would dominate that point.
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb6, label %bb4

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb6, label %bb3

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %bb6, label %bb5

bb4:
  %bb4.varying = or i1 %varying, true
  %bb4.add = add i32 %ld, 4
  br i1 %bb4.varying, label %bb6, label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %bb6

bb6:
  %phi = phi i32 [ %bb1.add, %bb1 ], [ %bb4.add, %bb4 ], [ %bb2.add, %bb2 ], [ %bb3.add, %bb3 ], [ %bb5.add, %bb5 ]
  %bb6.add = add i32 %ld, 6
  ret void
}

define void @test_no_blend_in_uniform_control_flow(i32 %b) {
; Make sure that workaround for CG's block-merge doesn't cause issues in blends
; transformation for bb1 - we shouldn't be doing anything to it for this uniform
; control flow (used to crash).
;
;             entry
;               |
;             header<+
;            /  |    |
;          bb0  |    |
;          / |  |    |
;        bb1 |  +    |
;         \  | /     |
;         latch------+
;           |
;         exit
; CHECK-LABEL:  VPlan IR for: test_no_blend_in_uniform_control_flow
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]], [[BB2:BB[0-9]+]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_IV_NEXT:%.*]], [[BB2]] ]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_UNIFORM]], [[BB3:BB[0-9]+]], [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_UNIFORM]], [[BB4:BB[0-9]+]], [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:       [DA: Uni] i32 [[VP_NO_BLEND_PHI:%.*]] = phi  [ i32 [[VP_IV]], [[BB3]] ]
; CHECK-NEXT:       [DA: Uni] br [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3]], [[BB4]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_THREE:%.*]] = phi  [ i32 [[VP_IV]], [[BB1]] ],  [ i32 [[VP_IV]], [[BB3]] ],  [ i32 [[VP_IV]], [[BB4]] ]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_COND:%.*]] = icmp eq i32 [[VP_IV_NEXT]] i32 42
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_COND]], [[BB5:BB[0-9]+]], [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %uniform = icmp eq i32 %b,  42
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %latch ]
  br i1 %uniform, label %bb0, label %latch

bb0:
  br i1 %uniform, label %bb1, label %latch

bb1:
  %no.blend.phi = phi i32 [ %iv, %bb0 ]
  br label %latch

latch:
  %three = phi i32 [ %iv, %header ], [ %iv, %bb0 ], [ %iv, %bb1 ]
  %iv.next = add nsw nuw i32 %iv, 1
  %cond = icmp eq i32 %iv.next, 42
  br i1 %cond, label %exit, label %header

exit:
  ret void
}

define void @test_not_of_phi() {
; CHECK-LABEL:  VPlan IR for: test_not_of_phi
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LANE]] i32 3
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_COND_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %varying = icmp eq i32 %lane,  3
  br label %bb0

bb0:
  %cond = phi i1 [ %varying, %entry ]
  %some = phi i32 [ 0, %entry ]
  br i1 %cond, label %bb1, label %bb2

bb1:
  br label %exit

bb2:
  br label %exit

exit:
  ret void
}

define void @no_blend_on_edge(i32 %b) {
; CHECK-LABEL:  VPlan IR for: no_blend_on_edge
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i32 [[VP_LANE]] i32 3
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_UNIFORM]], [[BB1:BB[0-9]+]], [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB0]]
; CHECK-NEXT:       [DA: Uni] i32 [[VP_DEF1:%.*]] = add i32 [[B0]] i32 1
; CHECK-NEXT:       [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:       [DA: Uni] i32 [[VP_DEF2:%.*]] = add i32 [[B0]] i32 2
; CHECK-NEXT:       [DA: Uni] br [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]], [[BB3]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_P_PHI_BB2:%.*]] = phi  [ i32 undef, [[BB0]] ],  [ i32 [[VP_DEF1]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_PHI_BB2:%.*]] = phi  [ i1 false, [[BB0]] ],  [ i1 [[VP_VARYING]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = or i1 [[VP_UNIFORM]] i1 [[VP_VARYING_PHI_BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP1]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_DEF3:%.*]] = add i32 [[B0]] i32 3
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_P_BLEND_BB2:%.*]] = blend [ i32 [[VP_P_PHI_BB2]], i1 true ], [ i32 [[VP_DEF3]], i1 [[VP1]] ]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  Before linearization | After
;      entry (U)        |     entry
;     /    \            |      |  |
;    /      \           |      | bb1
;  bb3<-bb2<-bb1        |      |  |
;     \     /           |      | bb2
;      \   /            |      | /
;       bb4             |      bb3 ;  merge-phi = phi [undef, %def1]
;                       |       |
;                       |      bb4 ; blend merge-phi, true, %def3, bb3.pred
  %lane = call i32 @llvm.vplan.laneid()
  %varying = icmp eq i32 %lane,  3
  %uniform = icmp eq i32 %b,  42
  br i1 %uniform, label %bb3, label %bb1

bb1:
  %def1 = add i32 %b, 1
  br i1 %varying, label %bb2, label %bb4

bb2:
  %def2 = add i32 %b, 2
  br label %bb3

bb3:
  %def3 = add i32 %b, 3
  br label %bb4

bb4:
  %p = phi i32 [ %def1, %bb1 ], [ %def3, %bb3]
  ret void
}

define void @uniform_br_under_outer_mask_1(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_1
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING]] i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  if (%varying) {
;    if (external-uniform) {
;      Can preserve uniform CF.
;    }
;  }
;           D
;          / \
;         U   +
;        /|   |
;       o |   |
;        \|   | If U is preserved then the left edge needs to be preserved.
;         o   +
;          \ /
;           o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if, label %exit

if:
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_2(i1 *%uniform.ptr) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_2
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = load i1* [[UNIFORM_PTR0:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  %uniform =
;  if (%varying) {
;    if (%uniform) {
;      Still can preserve uniform CF because %uniform is always defined.
;    }
;  }
;           D
;          / \
;         U   +
;        /|   |
;       o |   |
;        \|   | If U is preserved then the left edge needs to be preserved.
;         o   +
;          \ /
;           o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  %uniform = load i1, i1 *%uniform.ptr
  br i1 %varying, label %if, label %exit

if:
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_3(i1 *%uniform.ptr) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_3
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = load i1* [[UNIFORM_PTR0:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  if (%varying) {
;    %conditionally.uniform =
;    if (%conditionally.uniform) {
;       Cannot trivially preserve uniform CF. The condition might never be
;       defined (%varying == 0 on all lanes) resulting in a branch based on
;       undef.
;    }
;  }
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if, label %exit

if:
  %uniform = load i1, i1 *%uniform.ptr
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_4(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_4
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;    /   \
;    |    U
;    |   /|
;    +  o +
;     \ |/    If U is preserved then middle edge needs to be preserved.
;       o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %exit

if.then:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_5(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_5
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;    /   \
;   +     U
;   |    / \
;   |   o   o
;   |   |   |  If U is preserved then two right edges need to be preserved.
;   |   o   o
;   +    \ /
;    \    o
;     \  /
;       o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %if.then2

if.then2:
  br label %if.end

if.else:
  br label %if.else2

if.else2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_6(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_6
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;    /   \
;    |    U
;    |   / \
;    |  o   o
;    |  |   |  If U is preserved then right 2 edges need to be preserved.
;    |  o   o
;    +  |  /
;     \ | /
;       o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %if.then2

if.then2:
  br label %exit

if.else:
  br label %if.else2

if.else2:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_7(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_7
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_ELSE_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_ELSE_VARYING_NOT:%.*]] = not i1 [[VP_ELSE_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_ELSE_VARYING_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] i1 [[VP_ELSE_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_ELSE_VARYING:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] i1 [[VP_ELSE_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING_NOT:%.*]] = not i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_THEN_VARYING_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_THEN_VARYING:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = or i1 [[VP_BB5_BR_VP_ELSE_VARYING_NOT]] i1 [[VP_BB4_BR_VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP3]]
; CHECK-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_BB5_BR_VP_ELSE_VARYING]] i1 [[VP_BB4_BR_VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;   /   \
;  +     U
;  |    / \
;  |   D   D
;  |   | X |
;  +   o   o
;   \   \ /
;    \   o
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  %then.varying = call i1 @varying(i32 %lane)
  br i1 %then.varying, label %bb1, label %bb2

if.else:
  %else.varying = call i1 @varying(i32 %lane)
  br i1 %else.varying, label %bb1, label %bb2

bb1:
  br label %if.end

bb2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_8(i1 %uniform, i1 %u.then, i1 %u.else) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_8
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U_THEN_NOT:%.*]] = not i1 [[U_THEN0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U_ELSE_NOT:%.*]] = not i1 [[U_ELSE0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_U_ELSE_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] i1 [[VP_U_ELSE_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_U_ELSE:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] i1 [[U_ELSE0]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_U_THEN_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM]] i1 [[VP_U_THEN_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_U_THEN:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM]] i1 [[U_THEN0]]
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = or i1 [[VP_BB5_BR_VP_U_ELSE_NOT]] i1 [[VP_BB4_BR_VP_U_THEN_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP3]]
; CHECK-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_BB5_BR_VP_U_ELSE]] i1 [[VP_BB4_BR_VP_U_THEN]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;   /   \
;  +     U
;  |    / \
;  |   U   U
;  |   | X |
;  +   o   o
;   \   \ /
;    \   o
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br i1 %u.then, label %bb1, label %bb2

if.else:
  br i1 %u.else, label %bb1, label %bb2

bb1:
  br label %if.end

bb2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_9(i1 %uniform, i1 %u.else) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_9
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U_ELSE_NOT:%.*]] = not i1 [[U_ELSE0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_U_ELSE_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] i1 [[VP_U_ELSE_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_U_ELSE:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] i1 [[U_ELSE0]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING_NOT:%.*]] = not i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_THEN_VARYING_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_THEN_VARYING:%.*]] = and i1 [[VP_BB3_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = or i1 [[VP_BB5_BR_VP_U_ELSE_NOT]] i1 [[VP_BB4_BR_VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP3]]
; CHECK-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_BB5_BR_VP_U_ELSE]] i1 [[VP_BB4_BR_VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;   /   \
;  +     U
;  |    / \
;  |   D   U
;  |   | X |
;  +   o   o
;   \   \ /
;    \   o
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  %then.varying = call i1 @varying(i32 %lane)
  br i1 %then.varying, label %bb1, label %bb2

if.else:
  br i1 %u.else, label %bb1, label %bb2

bb1:
  br label %if.end

bb2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_10(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_10
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING2:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING2_NOT:%.*]] = not i1 [[VP_VARYING2]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_VARYING2_NOT:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_VARYING2_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB3_BR_VP_UNIFORM]] i1 [[VP_BB2_BR_VP_VARYING2_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = or i1 [[VP_VARYING_NOT]] i1 [[VP_BB2_BR_VP_VARYING2_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP4]]
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;     /  \
;    D    U
;    | \ /|
;    |  o |
;    |   \|
;    |    o
;    +   /
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb0, label %if

bb0:
  %varying2 = call i1 @varying(i32 %lane)
  br i1 %varying2, label %exit, label %if.then

if:
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_11(i1 %u0, i1 %u1) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_11
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U0_NOT:%.*]] = not i1 [[U00:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_U1:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[U10:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_U0_NOT:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_U0_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB3_BR_VP_U1]] i1 [[VP_BB2_BR_VP_U0_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;     / \
;    U   U
;    |\ /|
;    + o +
;     \|/
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if0, label %if1

if0:
  br i1 %u0, label %exit, label %bb

if1:
  br i1 %u1, label %bb, label %exit

bb:
  br label %exit

exit:
  ret void
}

declare i1 @varying(i32)
declare i32 @llvm.vplan.laneid()
