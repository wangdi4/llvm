; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt -S -vplan-func-vec -print-after-vplan-func-vec-predicator < %s -disable-output | FileCheck %s
; RUN: opt -S -passes="vplan-func-vec" -print-after-vplan-func-vec-predicator < %s -disable-output | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @test_uniform_edge_to_divergent_block(i32* %a, i32 %b) local_unnamed_addr {
; CHECK-LABEL:  VPlan IR for: test_uniform_edge_to_divergent_block
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM_NOT:%.*]] = not i1 [[VP_BB0_UNIFORM]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(2):[[BB2:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB3:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:      SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_PHI_BB4:%.*]] = phi  [ i1 false, [[BB1]] ],  [ i1 [[VP_BB1_VARYING]], [[BB2]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT_PHI_BB4:%.*]] = phi  [ i1 false, [[BB1]] ],  [ i1 [[VP_BB1_VARYING_NOT]], [[BB2]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = or i1 [[VP_BB0_UNIFORM_NOT]] i1 [[VP_BB1_VARYING_NOT_PHI_BB4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP0]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB1_VARYING_PHI_BB4]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] void [[VP3:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
;
entry:
;          entry
;           |
;         BB0 (U)
;       /     \
;     BB1 (D)  |
;    /   \    /
;   /     \ /
;  BB3   BB2
;   \    /
;    BB4
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_two_linearized_pathes_merge(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_two_linearized_pathes_merge
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(2):[[BB2:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB3:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:      SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:      SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:      SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB1_VARYING]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB1_VARYING_NOT]] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:      SUCCESSORS(1):[[BB5]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_PHI_BB5:%.*]] = phi  [ i1 false, [[BB8]] ],  [ i1 [[VP_BB2_VARYING]], [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT]], [[BB8]] ],  [ i1 false, [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 [[VP_BB1_VARYING_NOT]], [[BB8]] ],  [ i1 false, [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = or i1 [[VP_BB2_VARYING_PHI_BB5]] i1 [[VP_BB1_VARYING_NOT_PHI_BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT_PHI_BB5]] i1 [[VP4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB8]] [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] void [[VP7:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
;
entry:
;           entry
;            |
;           BB0 (U)
;          /    \
;         /      \
;      BB1 (D)   BB2 (D)
;     /   \      /  \
;  BB3     +    /    \
;  |  \    |   /      \
;  |    BB4    |      |
;  |      \    /      |
;  |        BB5       BB6
;  \         \       /
;   \         \     /
;    +-------> exit
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb4

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb5, label %bb6

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %exit, label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %exit

bb6:
  %bb6.add = add i32 %ld, 6
  br label %exit

exit:
  ret void
}

define void @test_separate_blend_bb_for_2_div_plus_uniform(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_separate_blend_bb_for_2_div_plus_uniform
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(2):[[BB2:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB3:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:      SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:      SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:      SUCCESSORS(1):[[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]:
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB5:%.*]] = blend [ i32 2, i1 [[VP_BB1_VARYING_NOT]] ], [ i32 3, i1 [[VP_BB1_VARYING]] ]
; CHECK-NEXT:      SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_PHI_BLEND_BB5]], [[BLEND_BB0]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] void [[VP2:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BLEND_BB0]]
;
entry:
;        entry
;          |
;         BB0 (U)
;       /     \
;     BB1 (D)  |
;    /   \     |
;   /     \    |
;  BB3   BB2   |
;   \    /    /
;    BB4<----+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb4

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %phi = phi i32 [ 0, %bb0 ], [ 2, %bb2 ], [ 3, %bb3 ]
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_two_blend_bbs(i32* %a, i32 %b)  local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_two_blend_bbs
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(2):[[BB2:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB3:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]:
; CHECK-NEXT:       [DA: Uni] i1 [[VP_BB4_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:      SUCCESSORS(2):[[BB4:BB[0-9]+]](i1 [[VP_BB4_UNIFORM]]), [[BB5:BB[0-9]+]](!i1 [[VP_BB4_UNIFORM]])
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB5]]:
; CHECK-NEXT:         [DA: Div] i1 [[VP_BB5_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:         [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:        SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB6]]:
; CHECK-NEXT:         [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB5_VARYING]]
; CHECK-NEXT:         [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:        SUCCESSORS(1):[[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BLEND_BB0]]:
; CHECK-NEXT:         [DA: Div] i32 [[VP_PHI_BLEND_BB7:%.*]] = blend [ i32 5, i1 true ], [ i32 6, i1 [[VP_BB5_VARYING]] ]
; CHECK-NEXT:        SUCCESSORS(1):[[BB4]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:      SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:      SUCCESSORS(1):[[BLEND_BB1:blend.bb[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB1]]:
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB8:%.*]] = blend [ i32 2, i1 [[VP_BB1_VARYING_NOT]] ], [ i32 3, i1 [[VP_BB1_VARYING]] ]
; CHECK-NEXT:      SUCCESSORS(1):[[BB4]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 4, [[BB3]] ],  [ i32 [[VP_PHI_BLEND_BB7]], [[BLEND_BB0]] ],  [ i32 [[VP_PHI_BLEND_BB8]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:     [DA: Div] void [[VP3:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(3): [[BB3]] [[BLEND_BB0]] [[BLEND_BB1]]
;
entry:
;       entry
;          |
;         BB0 (U)
;       /     \
;     BB1 (D)  BB4 (U)
;    /   \      /  \
;   /     \    /    BB5 (D)
;  BB3   BB2  |    / |
;   \     |   | BB6  |
;    \    |   | /    /
;     \   |  / /    /
;      \  | / /    /
;       +>BB7<----+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb4

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb7

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb7

bb4:
  %bb4.uniform = or i1 %uniform, true
  %bb4.add = add i32 %ld, 4
  br i1 %bb4.uniform, label %bb7, label %bb5

bb5:
  %bb5.varying = or i1 %varying, true
  %bb5.add = add i32 %ld, 5
  br i1 %bb5.varying, label %bb6, label %bb7

bb6:
  %bb6.add = add i32 %ld, 6
  br label %bb7

bb7:
  %phi = phi i32 [5, %bb5], [ 3, %bb3 ], [ 4, %bb4 ],[ 6, %bb6 ], [ 2, %bb2 ]
  %bb7.add = add i32 %ld, 7
  ret void
}

define dso_local void @test_divergent_loop_with_double_top_test(i32 %N, i32 *%a, i32 %mask_out_loop) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_divergent_loop_with_double_top_test
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_SKIP_LOOP:%.*]] = icmp i32 [[VP_LANE]] i32 [[MASK_OUT_LOOP0:%.*]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_SKIP_LOOP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST:%.*]] = icmp i32 [[N0:%.*]] i32 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST_NOT:%.*]] = not i1 [[VP_SECOND_TEST]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST_NOT_1:%.*]] = not i1 [[VP_SECOND_TEST]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT:%.*]] = and i1 [[VP_SKIP_LOOP]] i1 [[VP_SECOND_TEST_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_LIVE_OUT_PREV:%.*]] = phi  [ i32 undef, [[BB3]] ],  [ i32 [[VP_IV_LIVE_OUT_BLEND:%.*]], [[BB5:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV:%.*]] = phi  [ i32 [[VP_IV_NEXT:%.*]], [[BB5]] ],  [ i32 0, [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK:%.*]] = phi  [ i1 [[VP_SECOND_TEST_NOT_1]], [[BB3]] ],  [ i1 [[VP_LOOP_MASK_NEXT:%.*]], [[BB5]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_LOOP_MASK:%.*]] = and i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] i32* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i32* [[A0:%.*]] i32 [[VP_IV]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LD:%.*]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SOME_CMP:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND:%.*]] = icmp i32 [[VP_IV_NEXT]] i32 [[VP_LANE]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND_NOT:%.*]] = not i1 [[VP_EXITCOND]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK_NEXT]] = and i1 [[VP_EXITCOND_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP5:%.*]] = all-zero-check i1 [[VP_LOOP_MASK_NEXT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_LIVE_OUT_BLEND]] = select i1 [[VP_LOOP_MASK]] i32 [[VP_IV]] i32 [[VP_IV_LIVE_OUT_PREV]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB8:BB[0-9]+]](i1 [[VP5]]), [[BB4]](!i1 [[VP5]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_USE:%.*]] = phi  [ i32 [[VP_IV_LIVE_OUT_BLEND]], [[BB5]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] void [[VP7:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
;
entry:
;       entry
;       /     \
;     bb1      \
;    /  \       \
;   +   bb2      +
;   |    |       |
;   |  header<+  |
;   |   | +---+  |
;   +   |        |
;    \  |        |
;     +->exit <--+
  %lane = call i32 @llvm.vplan.laneid()
  %skip_loop = icmp eq i32 %lane, %mask_out_loop
  br i1 %skip_loop, label %bb1, label %exit

bb1:
  %second.test = icmp eq i32 %N, 0
  br i1 %second.test, label %exit, label %bb2

bb2:
  br label %header

header:
  %iv = phi i32 [ %iv.next, %header ], [ 0, %bb2 ]
  %arrayidx = getelementptr inbounds i32, i32* %a, i32 %iv
  %ld = load i32, i32* %arrayidx
  %some_cmp = icmp eq i32 %ld, 42
  %iv.next = add nuw nsw i32 %iv, 1
  %exitcond = icmp eq i32 %iv.next, %lane
  br i1 %exitcond, label %bb3, label %header

bb3:
  %phi_use = phi i32 [ %iv, %header ]
  br label %exit

exit:
  ret void
}

define void @test_single_succ_single_pred_edge(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_single_succ_single_pred_edge
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] void [[VP3:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
;
entry:
;       entry
;          |
;         BB0 (D)
;       /    \
;     BB1    BB2
;      |      |
;      |      |
;     BB3    /
;      |    /
;     BB4<-+
; Test checks predicate of the BB3, because BB1-BB3 edge is both single
; successor for BB1 and single predecessor for BB3.
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.add = add i32 %ld, 1
  br label %bb3

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_use_dom_instead_of_direct_succ(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_use_dom_instead_of_direct_succ
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:    SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_BB6_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB6_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB4_BR_VP_BB6_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING_NOT:%.*]] = not i1 [[VP_BB7_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB7_VARYING_NOT:%.*]] = and i1 [[VP_BB4_BR_VP_BB6_VARYING]] i1 [[VP_BB7_VARYING_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB7_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB8_ADD:%.*]] = add i32 [[VP_LD]] i32 8
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB9_BR_VP_BB2_VARYING_NOT:%.*]] = and i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB9_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB9_BR_VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB12:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB9_BR_VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB13:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = or i1 [[VP_BB4_BR_VP_BB6_VARYING]] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP7]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB14:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]:
; CHECK-NEXT:     [DA: Div] void [[VP9:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB13]]
;
entry:
;           entry
;             |
;            BB0 (D)
;          /    \
;        BB1 (D) \
;       /  \      BB6 (D)-+
;      +    \       |     |
;      |    BB2    BB7 (D)|
;      |    /  \    |\    |
;      |  BB4  BB3  + BB8 |
;      |    \  /   /   |  |
;      |    BB5<--+    |  |
;      +     | \       |  +
;       \    |  +------+ /
;        \   |          /
;         +-> exit <---+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb6

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %exit, label %bb2

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb4, label %bb3

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb5

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %exit

bb6:
  %bb6.varying = or i1 %varying, true
  %bb6.add = add i32 %ld, 6
  br i1 %bb6.varying, label %bb7, label %exit

bb7:
  %bb7.varying = or i1 %varying, true
  %bb7.add = add i32 %ld, 7
  br i1 %bb7.varying, label %bb5, label %bb8

bb8:
  %bb8.add = add i32 %ld, 8
  br label %bb5

exit:
  ret void
}

define void @test_triple_pred_in_single_linearized_flow(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_triple_pred_in_single_linearized_flow
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB3_BR_VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] void [[VP4:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
;
entry:
; NOTE: Dependent on order of children visiting in RPOT. If BB0-BB2 is changed
; to BB-BB3 the issue isn't reproducible.
; By the time BB2 is processed, edges BB0-BB2 and BB1-BB2 are RemovedDivergent
; and BB2 is disconnected from the linearized BB0-BB1-BB3 chain. The test checks
; that exactly one BB3-BB2 edge is added when connecting BB2 to the linearized
; CFG.
;       entry
; (False) |
;  +----BB0 (D)
;  |    / (True)
;  |  BB1 (D)
;  | /   \
;  |/     \
;  BB2   BB3
;   \    /
;     BB4
;     |
;    exit
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb2, label %bb3

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %exit

exit:
  ret void
}

define void @test_linearized_chain(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_linearized_chain
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB4_BR_VP_BB2_VARYING]] i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:     [DA: Div] void [[VP4:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
;
entry:
; "White-box" test. Assumes the linearization process visit blocks in order:
; BB0, BB2, BB1. While visiting BB2, edge BB0->BB1 is dropped and at the time
; BB1 is visited we need to attach it directly to BB2. Ensure that unprocessed
; edges from BB2 are not causing crashes (we used to assert for a number of
; outgoing edges inside the linearized chain, but didn't limit it to the blocks
; for which at least once successor was processed).
;       entry
;          |
;         BB0 (D)
;       /     \
;     BB1     BB2
;      \     / |
;       \   /  +
;        BB3  /
;         |  /
;         | /
;        BB4
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.add = add i32 %ld, 1
  br label %bb3

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb3, label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  ret void
}

define void @test_reuse_idom(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_reuse_idom
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_B00_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB4_BR_VP_BB2_VARYING]] i1 [[VP_BB3_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB3_VARYING:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:     [DA: Div] void [[VP7:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
;
entry:
; Check BB6's predicate. Ideally, it should re-use the one from BB3.
;          entry
;            |
;           BB0 (D)
;         /    \
;      BB1 (D)  \
;      /  \      \
;     /    \    BB2 (D)
;     +     \  /   \
;     |      BB3 (D)\
;     |     /  \     +
;     |    /    \    |
;     |   BB5   BB4  |
;     |    \    /    +
;     +     BB6     /
;      \     |     /
;       +-->BB7<--+
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %b00.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb7, label %bb3

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb3, label %bb7

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %bb5, label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb6

bb5:
  %bb5.add = add i32 %ld, 5
  br label %bb6

bb6:
  %bb6.add = add i32 %ld, 6
  br label %bb7

bb7:
  %bb7.add = add i32 %ld, 7
  ret void
}

define void @test_blend_splitting_for_early_path_join(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  VPlan IR for: test_blend_splitting_for_early_path_join
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(2):[[BB2:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB3:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:      SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:      SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB2_VARYING_NOT]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]:
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB6:%.*]] = blend [ i32 [[VP_BB2_ADD]], i1 true ], [ i32 [[VP_BB3_ADD]], i1 [[VP_BB2_VARYING_NOT]] ]
; CHECK-NEXT:      SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING_NOT:%.*]] = not i1 [[VP_BB4_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:      SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT:%.*]] = and i1 [[VP_BB1_VARYING_NOT]] i1 [[VP_BB4_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BLEND_BB1:blend.bb[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB1]]:
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB8:%.*]] = blend [ i32 [[VP_BB1_ADD]], i1 true ], [ i32 [[VP_BB4_ADD]], i1 [[VP_BB1_VARYING_NOT]] ]
; CHECK-NEXT:      SUCCESSORS(1):[[BB6]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_PHI_BB7:%.*]] = phi  [ i32 [[VP_PHI_BLEND_BB6]], [[BLEND_BB0]] ],  [ i32 [[VP_PHI_BLEND_BB8]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT_PHI_BB7:%.*]] = phi  [ i1 false, [[BLEND_BB0]] ],  [ i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT_PHI_BB7:%.*]] = phi  [ i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT]], [[BLEND_BB0]] ],  [ i1 false, [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB6_BR_VP_BB3_VARYING_NOT_PHI_BB7]] i1 [[VP_BB8_BR_VP_BB4_VARYING_NOT_PHI_BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BLEND_BB0]] [[BLEND_BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_BLEND_BB7:%.*]] = blend [ i32 [[VP_BB5_ADD]], i1 [[VP2]] ], [ i32 [[VP_PHI_PHI_BB7]], i1 [[VP2]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:     [DA: Div] void [[VP4:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
;
entry:
;          entry
;            |
;           BB0 (U)-----+
;         /              \
;      BB1 (D)            BB2 (D)
;      /  \              /  \
;     /    \            /   BB3 (D)
;     +     \          /  /   \
;     |      BB4 (D)- / -/---->BB5
;     |        \     /  /     |
;     |         \   +  /      |
;     |          \  | /       |
;     |           \ v/        |
;     +---------> BB6 <-------+
; After linearization (approximate, might be different in actual implementation)
; should be like this:
;           entry
;             |
;            BB0
;           /  \
;         BB1  BB2
;          |    |
;         BB4  BB3
;          |    |
;    Blend_1_4  Blend_2_3
;           \   /
;            BB5 RealPhi = [ Blend_1_4, BB4 ], [ Blend_2_3, BB3]
;             |
;            BB6 BlendForOrigPhi (RealPhi, BB5Def) (*)
; (*) can't have a blend with 5 incoming values, none of def1/def4/def2/def3
; would dominate that point.
  %lane = call i32 @llvm.vplan.laneid()
  %gep = getelementptr i32, i32 *%a, i32 %lane
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb6, label %bb4

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb6, label %bb3

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %bb6, label %bb5

bb4:
  %bb4.varying = or i1 %varying, true
  %bb4.add = add i32 %ld, 4
  br i1 %bb4.varying, label %bb6, label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %bb6

bb6:
  %phi = phi i32 [ %bb1.add, %bb1 ], [ %bb4.add, %bb4 ], [ %bb2.add, %bb2 ], [ %bb3.add, %bb3 ], [ %bb5.add, %bb5 ]
  %bb6.add = add i32 %ld, 6
  ret void
}

define void @test_no_blend_in_uniform_control_flow(i32 %b) {
; Make sure that workaround for CG's block-merge doesn't cause issues in blends
; transformation for bb1 - we shouldn't be doing anything to it for this uniform
; control flow (used to crash).
;
;             entry
;               |
;             header<+
;            /  |    |
;          bb0  |    |
;          / |  |    |
;        bb1 |  +    |
;         \  | /     |
;         latch------+
;           |
;         exit
; CHECK-LABEL:  VPlan IR for: test_no_blend_in_uniform_control_flow
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_IV_NEXT:%.*]], [[BB2:BB[0-9]+]] ]
; CHECK-NEXT:     Condition([[BB0]]): [DA: Uni] i1 [[VP_UNIFORM]] = icmp i32 [[B0]] i32 42
; CHECK-NEXT:    SUCCESSORS(2):[[BB3:BB[0-9]+]](i1 [[VP_UNIFORM]]), [[BB2]](!i1 [[VP_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB0]] [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:       Condition([[BB0]]): [DA: Uni] i1 [[VP_UNIFORM]] = icmp i32 [[B0]] i32 42
; CHECK-NEXT:      SUCCESSORS(2):[[BB4:BB[0-9]+]](i1 [[VP_UNIFORM]]), [[BB2]](!i1 [[VP_UNIFORM]])
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       [DA: Uni] i32 [[VP_NO_BLEND_PHI:%.*]] = phi  [ i32 [[VP_IV]], [[BB3]] ]
; CHECK-NEXT:      SUCCESSORS(1):[[BB2]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_THREE:%.*]] = phi  [ i32 [[VP_IV]], [[BB1]] ],  [ i32 [[VP_IV]], [[BB3]] ],  [ i32 [[VP_IV]], [[BB4]] ]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_COND:%.*]] = icmp i32 [[VP_IV_NEXT]] i32 42
; CHECK-NEXT:    SUCCESSORS(2):[[BB5:BB[0-9]+]](i1 [[VP_COND]]), [[BB1]](!i1 [[VP_COND]])
; CHECK-NEXT:    PREDECESSORS(3): [[BB1]] [[BB3]] [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] void [[VP0:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %uniform = icmp eq i32 %b,  42
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %latch ]
  br i1 %uniform, label %bb0, label %latch

bb0:
  br i1 %uniform, label %bb1, label %latch

bb1:
  %no.blend.phi = phi i32 [ %iv, %bb0 ]
  br label %latch

latch:
  %three = phi i32 [ %iv, %header ], [ %iv, %bb0 ], [ %iv, %bb1 ]
  %iv.next = add nsw nuw i32 %iv, 1
  %cond = icmp eq i32 %iv.next, 42
  br i1 %cond, label %exit, label %header

exit:
  ret void
}

define void @test_not_of_phi() {
; CHECK-LABEL:  VPlan IR for: test_not_of_phi
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LANE]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_COND_BLEND_BB1:%.*]] = blend [ i1 [[VP_VARYING]], i1 true ]
; FIXME: This breaks the requirement for phis to be grouped at the top of BB.
; CHECK-NEXT:     [DA: Div] i1 [[VP_COND_NOT:%.*]] = not i1 [[VP_COND_BLEND_BB1]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_SOME:%.*]] = phi  [ i32 0, [[BB0]] ]
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB3:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_COND_BLEND_BB1]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] void [[VP2:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %varying = icmp eq i32 %lane,  3
  br label %bb0

bb0:
  %cond = phi i1 [ %varying, %entry ]
  %some = phi i32 [ 0, %entry ]
  br i1 %cond, label %bb1, label %bb2

bb1:
  br label %exit

bb2:
  br label %exit

exit:
  ret void
}

declare i32 @llvm.vplan.laneid()
