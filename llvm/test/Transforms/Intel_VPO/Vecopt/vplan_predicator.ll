; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; FIXME: CodeGen is disabled due to Predicator issue exposed by @test_blend_splitting_for_early_path_join.

; RUN: opt -S < %s -VPlanDriver -disable-output -vplan-print-after-linearization -disable-vplan-codegen | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @test_uniform_edge_to_divergent_block(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM_NOT:%.*]] = not i1 [[VP_BB0_UNIFORM]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB5:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB6:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB6]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_PHI_BB6:%.*]] = phi  [ i1 [[VP_BB5_BR_VP_BB1_VARYING]], [[BB7]] ],  [ i1 false, [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT_PHI_BB6:%.*]] = phi  [ i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]], [[BB7]] ],  [ i1 false, [[BB4]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = or i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT_PHI_BB6]] i1 [[VP_BB0_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP0]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB7]] [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING_PHI_BB6]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB10:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;       for.body<---+
;          |        |
;         BB0 (U)   |
;       /     \     |
;     BB1 (D)  |    |
;    /   \    /     |
;   /     \ /       |
;  BB3   BB2        |
;   \    /          |
;    BB4            |
;     |             |
;    Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define void @test_two_linearized_pathes_merge(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM_NOT:%.*]] = not i1 [[VP_BB0_UNIFORM]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB5:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB6:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB6_BR_VP_BB2_VARYING_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM_NOT]] i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB6_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_UNIFORM_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB6_BR_VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:      SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB10]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB11]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB12:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB12]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB9_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB5_BR_VP_BB1_VARYING]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB13:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB13]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB9_BR_VP_BB3_VARYING_NOT]] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:      SUCCESSORS(1):[[BB9]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_BR_VP_BB2_VARYING_PHI_BB7:%.*]] = phi  [ i1 false, [[BB13]] ],  [ i1 [[VP_BB6_BR_VP_BB2_VARYING]], [[BB8]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT_PHI_BB7:%.*]] = phi  [ i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]], [[BB13]] ],  [ i1 false, [[BB8]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB9_BR_VP_BB3_VARYING_NOT_PHI_BB7:%.*]] = phi  [ i1 [[VP_BB9_BR_VP_BB3_VARYING_NOT]], [[BB13]] ],  [ i1 false, [[BB8]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = or i1 [[VP_BB6_BR_VP_BB2_VARYING_PHI_BB7]] i1 [[VP_BB9_BR_VP_BB3_VARYING_NOT_PHI_BB7]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT_PHI_BB7]] i1 [[VP4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB13]] [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB14:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB15:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB14]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;         for.body<-------+
;            |            |
;           BB0 (U)       |
;          /    \         |
;         /      \        |
;      BB1 (D)   BB2 (D)  |
;     /   \      /  \     |
;  BB3     +    /    \    |
;  |  \    |   /      \   |
;  |    BB4    |      |   |
;  |      \    /      |   |
;  |        BB5       BB6 |
;  \         \        /   |
;   \         \     /     |
;    +----------Latch-----+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb4

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb5, label %bb6

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %latch, label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %latch

bb6:
  %bb6.add = add i32 %ld, 6
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define void @test_separate_blend_bb_for_2_div_plus_uniform(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:    SUCCESSORS(2):[[BB5:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB6:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:      SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB9]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:      SUCCESSORS(1):[[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]:
; CHECK-NEXT:       [DA: Div] i32 [[VP2:%.*]] = blend [ i32 2, i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]] ], [ i32 3, i1 [[VP_BB5_BR_VP_BB1_VARYING]] ]
; CHECK-NEXT:      SUCCESSORS(1):[[BB6]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 0, [[BB4]] ],  [ i32 [[VP2]], [[BLEND_BB0]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB4]] [[BLEND_BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB10:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;       for.body<---+
;          |        |
;         BB0 (U)   |
;       /     \     |
;     BB1 (D)  |    |
;    /   \     |    |
;   /     \    |    |
;  BB3   BB2   |    |
;   \    /    /     |
;    BB4<----+      |
;     |             |
;    Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb4

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %phi = phi i32 [ 0, %bb0 ], [ 2, %bb2 ], [ 3, %bb3 ]
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define void @test_two_blend_bbs(i32* %a, i32 %b)  local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM_NOT:%.*]] = not i1 [[VP_BB0_UNIFORM]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB5:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB6:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]:
; CHECK-NEXT:       [DA: Uni] i1 [[VP_BB4_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:       [DA: Uni] i1 [[VP_BB4_UNIFORM_NOT:%.*]] = not i1 [[VP_BB4_UNIFORM]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Uni] i1 [[VP_BB6_BR_VP_BB4_UNIFORM_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM_NOT]] i1 [[VP_BB4_UNIFORM_NOT]]
; CHECK-NEXT:       Condition([[BB6]]): [DA: Uni] i1 [[VP_BB4_UNIFORM]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:      SUCCESSORS(2):[[BB8:BB[0-9]+]](i1 [[VP_BB4_UNIFORM]]), [[BB9:BB[0-9]+]](!i1 [[VP_BB4_UNIFORM]])
; CHECK-NEXT:      PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB9]]:
; CHECK-NEXT:         [DA: Div] i1 [[VP_BB5_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:         [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:        SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB10]]:
; CHECK-NEXT:         [DA: Div] i1 [[VP_BB8_BR_VP_BB5_VARYING:%.*]] = and i1 [[VP_BB6_BR_VP_BB4_UNIFORM_NOT]] i1 [[VP_BB5_VARYING]]
; CHECK-NEXT:        SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB11]]:
; CHECK-NEXT:         [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB8_BR_VP_BB5_VARYING]]
; CHECK-NEXT:         [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:        SUCCESSORS(1):[[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BLEND_BB0]]:
; CHECK-NEXT:         [DA: Div] i32 [[VP1:%.*]] = blend [ i32 5, i1 true ], [ i32 6, i1 [[VP_BB8_BR_VP_BB5_VARYING]] ]
; CHECK-NEXT:        SUCCESSORS(1):[[BB8]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB12:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB12]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB13:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB13]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:      SUCCESSORS(1):[[BB14:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB14]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:      SUCCESSORS(1):[[BLEND_BB1:blend.bb[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB13]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB1]]:
; CHECK-NEXT:       [DA: Div] i32 [[VP4:%.*]] = blend [ i32 2, i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]] ], [ i32 3, i1 [[VP_BB5_BR_VP_BB1_VARYING]] ]
; CHECK-NEXT:      SUCCESSORS(1):[[BB8]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB14]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 4, [[BB7]] ],  [ i32 [[VP1]], [[BLEND_BB0]] ],  [ i32 [[VP4]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(3): [[BB7]] [[BLEND_BB0]] [[BLEND_BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB15:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB16:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB16]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB15]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;       for.body<------------+
;          |                 |
;         BB0 (U)            |
;       /     \              |
;     BB1 (D)  BB4 (U)       |
;    /   \      /  \         |
;   /     \    /    BB5 (D)  |
;  BB3   BB2  |    / |       |
;   \     |   | BB6  |       |
;    \    |   | /    /       |
;     \   |  / /    /        |
;      \  | / /    /         |
;       +>BB7<----+          |
;         |                  |
;          Latch-------------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb4

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb7

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb7

bb4:
  %bb4.uniform = or i1 %uniform, true
  %bb4.add = add i32 %ld, 4
  br i1 %bb4.uniform, label %bb7, label %bb5

bb5:
  %bb5.varying = or i1 %varying, true
  %bb5.add = add i32 %ld, 5
  br i1 %bb5.varying, label %bb6, label %bb7

bb6:
  %bb6.add = add i32 %ld, 6
  br label %bb7

bb7:
  %phi = phi i32 [5, %bb5], [ 3, %bb3 ], [ 4, %bb4 ],[ 6, %bb6 ], [ 2, %bb2 ]
  %bb7.add = add i32 %ld, 7
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define dso_local void @test_divergent_inner_loop_with_double_top_test(i64 %N, i64 *%a, i64 %mask_out_inner_loop) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_OUTER_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_OUTER_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VF:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop outer.loop.header
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i64 [[VP_OUTER_IV:%.*]] = phi  [ i64 [[VP_OUTER_IV_NEXT:%.*]], [[BB3]] ],  [ i64 [[VP_OUTER_IV_IND_INIT]], [[BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_SKIP_LOOP:%.*]] = icmp i64 [[VP_OUTER_IV]] i64 [[MASK_OUT_INNER_LOOP0:%.*]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_SKIP_LOOP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_CMP216:%.*]] = icmp i64 [[N0:%.*]] i64 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_CMP216_NOT:%.*]] = not i1 [[VP_CMP216]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_CMP216_NOT_1:%.*]] = not i1 [[VP_CMP216]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_CMP216_NOT:%.*]] = and i1 [[VP_SKIP_LOOP]] i1 [[VP_CMP216_NOT_1]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP216_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_INNER_IV_LIVE_OUT_PREV:%.*]] = phi  [ i64 [[VP_INNER_IV_LIVE_OUT_BLEND:%.*]], [[BB8:BB[0-9]+]] ],  [ i64 undef, [[BB6]] ]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_INNER_IV:%.*]] = phi  [ i64 [[VP_INNER_IV_NEXT:%.*]], [[BB8]] ],  [ i64 0, [[BB6]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK:%.*]] = phi  [ i1 [[VP_CMP216_NOT]], [[BB6]] ],  [ i1 [[VP_LOOP_MASK_NEXT:%.*]], [[BB8]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP216_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB8]] [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP216_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB11_BR_VP_LOOP_MASK:%.*]] = and i1 [[VP_BB3_BR_VP_CMP216_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB11_BR_VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] i64* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i64* [[A0:%.*]] i64 [[VP_INNER_IV]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_LD:%.*]] = load i64* [[VP_ARRAYIDX]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SOME_CMP:%.*]] = icmp i64 [[VP_LD]] i64 42
; CHECK-NEXT:     [DA: Uni] i64 [[VP_INNER_IV_NEXT]] = add i64 [[VP_INNER_IV]] i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB12:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP216_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND:%.*]] = icmp i64 [[VP_INNER_IV_NEXT]] i64 [[VP_OUTER_IV]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND_NOT:%.*]] = not i1 [[VP_EXITCOND]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK_NEXT]] = and i1 [[VP_EXITCOND_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Div] i64 [[VP_INNER_IV_LIVE_OUT_BLEND]] = select i1 [[VP_LOOP_MASK]] i64 [[VP_INNER_IV]] i64 [[VP_INNER_IV_LIVE_OUT_PREV]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP6:%.*]] = all-zero-check i1 [[VP_LOOP_MASK_NEXT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB8]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP216_NOT]]
; CHECK-NEXT:     Condition([[BB12]]): [DA: Uni] i1 [[VP6]] = all-zero-check i1 [[VP_LOOP_MASK_NEXT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB13:BB[0-9]+]](i1 [[VP6]]), [[BB7]](!i1 [[VP6]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_PHI_USE:%.*]] = blend [ i64 [[VP_INNER_IV_LIVE_OUT_BLEND]], i1 [[VP_BB3_BR_VP_CMP216_NOT]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP216_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_OUTER_IV_NEXT]] = add i64 [[VP_OUTER_IV]] i64 [[VP_OUTER_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_LOOP_IV_NEXT]] = add i64 [[VP_VECTOR_LOOP_IV]] i64 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i64 [[VP_VECTOR_LOOP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB14:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB13]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]:
; CHECK-NEXT:     [DA: Uni] i64 [[VP_OUTER_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB15:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB14]]
;
entry:
;       entry
;         |
;        bb0
;         |
;  +->outer.loop.header
;  |      |          |
;  |     bb1------+  |
;  |      |       |  |
;  |     bb2      |  |
;  |      |       |  |
;  |  inner.loop  |  |
;  |      |       |  |
;  |     bb3      |  |
;  |      |       |  |
;  +--outer.loop.latch
;         |
;        bb4
;         |
;        exit
  %cmp18 = icmp sgt i64 %N, 0
  br i1 %cmp18, label %bb0, label %exit

bb0:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %outer.loop.header

outer.loop.header:
  %outer.iv = phi i64 [ %outer.iv.next, %outer.loop.latch ], [ 0, %bb0 ]
  %skip_loop = icmp eq i64 %outer.iv, %mask_out_inner_loop
  br i1 %skip_loop, label %bb1, label %outer.loop.latch

bb1:
  %cmp216 = icmp eq i64 %N, 0
  br i1 %cmp216, label %outer.loop.latch, label %bb2

bb2:
  br label %inner.loop

inner.loop:
  %inner.iv = phi i64 [ %inner.iv.next, %inner.loop ], [ 0, %bb2 ]
  %arrayidx = getelementptr inbounds i64, i64* %a, i64 %inner.iv
  %ld = load i64, i64* %arrayidx
  %some_cmp = icmp eq i64 %ld, 42
  %inner.iv.next = add nuw nsw i64 %inner.iv, 1
  %exitcond = icmp eq i64 %inner.iv.next, %outer.iv
  br i1 %exitcond, label %bb3, label %inner.loop

bb3:
  %phi_use = phi i64 [ %inner.iv, %inner.loop ]
  br label %outer.loop.latch

outer.loop.latch:
  %outer.iv.next = add nuw nsw i64 %outer.iv, 1
  %outer_exit_cond = icmp eq i64 %outer.iv.next, %N
  br i1 %outer_exit_cond, label %bb4, label %outer.loop.header

bb4:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  br label %exit

exit:
  ret void
}

define void @test_single_succ_single_pred_edge(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB9:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;       for.body<---+
;          |        |
;         BB0 (D)   |
;       /    \      |
;     BB1    BB2    |
;      |      |     |
;      |      |     |
;     BB3    /      |
;      |    /       |
;     BB4<-+        |
;     |             |
;    Latch----------+
; Test checks predicate of the BB3, because BB1-BB3 edge is both single
; successor for BB1 and single predecessor for BB3.
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.add = add i32 %ld, 1
  br label %bb3

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define void @test_use_dom_instead_of_direct_succ(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_BR_VP_BB6_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB6_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB6_BR_VP_BB6_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING_NOT:%.*]] = not i1 [[VP_BB7_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_BR_VP_BB7_VARYING_NOT:%.*]] = and i1 [[VP_BB6_BR_VP_BB6_VARYING]] i1 [[VP_BB7_VARYING_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB7_BR_VP_BB7_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB8_ADD:%.*]] = add i32 [[VP_LD]] i32 8
; CHECK-NEXT:    SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB12:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB13:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB10_BR_VP_BB2_VARYING_NOT:%.*]] = and i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB10_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB14:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB10_BR_VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB15:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB13]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB10_BR_VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB16:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB14]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB16]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = or i1 [[VP_BB6_BR_VP_BB6_VARYING]] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP7]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB15]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB17:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB16]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB17]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB18:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB18]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB17]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;          for.body<-----------+
;             |                |
;            BB0 (D)           |
;          /    \              |
;        BB1 (D) \             |
;       /  \      BB6 (D)-+    |
;      +    \       |     |    |
;      |    BB2    BB7 (D)|    |
;      |    /  \    |\    |    |
;      |  BB4  BB3  + BB8 |    |
;      |    \  /   /   |  |    |
;      |    BB5<--+    |  |    |
;      +     | \       |  +    |
;       \    |  +------+ /     |
;        \   |          /      |
;         +-> Latch___BB-------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb6

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %latch, label %bb2

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb4, label %bb3

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb5

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %latch

bb6:
  %bb6.varying = or i1 %varying, true
  %bb6.add = add i32 %ld, 6
  br i1 %bb6.varying, label %bb7, label %latch

bb7:
  %bb7.varying = or i1 %varying, true
  %bb7.add = add i32 %ld, 7
  br i1 %bb7.varying, label %bb5, label %bb8

bb8:
  %bb8.add = add i32 %ld, 8
  br label %bb5

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define void @test_triple_pred_in_single_linearized_flow(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB5_BR_VP_BB1_VARYING]] i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB10:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
; NOTE: Dependent on order of children visiting in RPOT. If BB0-BB2 is changed
; to BB-BB3 the issue isn't reproducible.
; By the time BB2 is processed, edges BB0-BB2 and BB1-BB2 are RemovedDivergent
; and BB2 is disconnected from the linearized BB0-BB1-BB3 chain. The test checks
; that exactly one BB3-BB2 edge is added when connecting BB2 to the linearized
; CFG.
;      Header <-----+
; (False) |         |
;  +----BB0 (D)     |
;  |    / (True)    |
;  |  BB1 (D)       |
;  | /   \          |
;  |/     \         |
;  BB2   BB3        |
;   \    /          |
;     BB4           |
;     |             |
;    Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb2, label %bb3

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define void @test_linearized_chain(i32* %a, i32 %b) local_unnamed_addr {
;
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB6_BR_VP_BB2_VARYING]] i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB10:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
; "White-box" test. Assumes the linearization process visit blocks in order:
; BB0, BB2, BB1. While visiting BB2, edge BB0->BB1 is dropped and at the time
; BB1 is visited we need to attach it directly to BB2. Ensure that unprocessed
; edges from BB2 are not causing crashes (we used to assert for a number of
; outgoing edges inside the linearized chain, but didn't limit it to the blocks
; for which at least once successor was processed).
;       for.body<---+
;          |        |
;         BB0 (D)   |
;       /     \     |
;     BB1     BB2   |
;      \     / |    |
;       \   /  +    |
;        BB3  /     |
;         |  /      |
;         | /       |
;        BB4        |
;         |         |
;       Latch-------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.add = add i32 %ld, 1
  br label %bb3

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb3, label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

define void @test_reuse_idom(i32* %a, i32 %b) local_unnamed_addr {
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_B00_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB6_BR_VP_BB2_VARYING]] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_BR_VP_BB3_VARYING:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB7_BR_VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:    SUCCESSORS(1):[[BB12:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB7_BR_VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB13:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:    SUCCESSORS(1):[[BB14:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB7_ADD:%.*]] = add i32 [[VP_LD]] i32 7
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB13]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB15:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB14]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB16:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB16]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB15]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
; Check BB6's predicate. Ideally, it should re-use the one from BB3.
;       for.body<----------+
;            |             |
;           BB0 (D)        |
;         /    \           |
;      BB1 (D)  \          |
;      /  \      \         |
;     /    \    BB2 (D)    |
;     +     \  /   \       |
;     |      BB3 (D)\      |
;     |     /  \     +     |
;     |    /    \    |     |
;     |   BB5   BB4  |     |
;     |    \    /    +     |
;     +     BB6     /      |
;      \     |     /       |
;       +-->BB7<--+        |
;            |             |
;           Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.varying = or i1 %varying, true
  %b00.add = add i32 %ld, 0
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb7, label %bb3

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb3, label %bb7

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %bb5, label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %bb6

bb5:
  %bb5.add = add i32 %ld, 5
  br label %bb6

bb6:
  %bb6.add = add i32 %ld, 6
  br label %bb7

bb7:
  %bb7.add = add i32 %ld, 7
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

; FIXME: Enable VPlan CodeGen once predicator is fixed for this test!
define void @test_blend_splitting_for_early_path_join(i32* %a, i32 %b) local_unnamed_addr {
; CHECK-LABEL:  After predication and linearization
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV:%.*]] = phi  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_GEP:%.*]] = getelementptr i32* [[A0:%.*]] i32 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LD:%.*]] = load i32* [[VP_GEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp i32 [[VP_LD]] i32 42
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB3]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = or i1 [[VP_UNIFORM]] i1 true
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB0_ADD:%.*]] = add i32 [[VP_LD]] i32 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM_NOT:%.*]] = not i1 [[VP_BB0_UNIFORM]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB5:BB[0-9]+]](i1 [[VP_BB0_UNIFORM]]), [[BB6:BB[0-9]+]](!i1 [[VP_BB0_UNIFORM]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB2_ADD:%.*]] = add i32 [[VP_LD]] i32 2
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB6_BR_VP_BB2_VARYING_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM_NOT]] i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB6_BR_VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB3_ADD:%.*]] = add i32 [[VP_LD]] i32 3
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB9]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB6_BR_VP_BB2_VARYING_NOT]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB1_ADD:%.*]] = add i32 [[VP_LD]] i32 1
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB11]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_UNIFORM]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB12:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB12]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING:%.*]] = or i1 [[VP_VARYING]] i1 true
; CHECK-NEXT:       [DA: Div] i32 [[VP_BB4_ADD:%.*]] = add i32 [[VP_LD]] i32 4
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING_NOT:%.*]] = not i1 [[VP_BB4_VARYING]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB13:BB[0-9]+]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB13]]:
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB10_BR_VP_BB4_VARYING_NOT:%.*]] = and i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB4_VARYING_NOT]]
; CHECK-NEXT:      SUCCESSORS(1):[[BB10]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT_PHI_BB9:%.*]] = phi  [ i1 false, [[BB13]] ],  [ i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT]], [[BB9]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB10_BR_VP_BB4_VARYING_NOT_PHI_BB9:%.*]] = phi  [ i1 [[VP_BB10_BR_VP_BB4_VARYING_NOT]], [[BB13]] ],  [ i1 false, [[BB9]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB10_BR_VP_BB4_VARYING_NOT_PHI_BB9]] i1 [[VP_BB8_BR_VP_BB3_VARYING_NOT_PHI_BB9]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB5_ADD:%.*]] = add i32 [[VP_LD]] i32 5
; CHECK-NEXT:    SUCCESSORS(1):[[BB14:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB13]] [[BB9]]
; CHECK-EMPTY:
;
; FIXME: That shouldn't be a huge blend-phi because not all the incoming values
; dominate this blend. We should be introducing more blends when different
; divergent paths merge together via IDF-based algorithm, most probably.
; See details below in the ASCII drawing of the linearized control flow.
;
; CHECK-NEXT:    [[BB14]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = blend [ i32 [[VP_BB2_ADD]], i1 true ], [ i32 [[VP_BB3_ADD]], i1 [[VP_BB6_BR_VP_BB2_VARYING_NOT]] ], [ i32 [[VP_BB1_ADD]], i1 true ], [ i32 [[VP_BB4_ADD]], i1 [[VP_BB5_BR_VP_BB1_VARYING_NOT]] ], [ i32 [[VP_BB5_ADD]], i1 [[VP2]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_BB6_ADD:%.*]] = add i32 [[VP_LD]] i32 6
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB15:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB14]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB16:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB16]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB15]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;       for.body<-------------------+
;            |                      |
;           BB0 (U)-----+           |
;         /              \          |
;      BB1 (D)            BB2 (D)   |
;      /  \              /  \       |
;     /    \            /   BB3 (D) |
;     +     \          /  /   \     |
;     |      BB4 (D)- / -/---->BB5  |
;     |        \     /  /     |     |
;     |         \   +  /      |     |
;     |          \  | /       |     |
;     |           \ v/        |     |
;     +---------> BB6 <-------+     |
;                  |                |
;                 Latch-------------+
; After linearization (approximate, might be different in actual implementation)
; should be like this:
;           for.body
;             |
;            BB0
;           /  \
;         BB1  BB2
;          |    |
;         BB4  BB3
;          |    |
;    Blend_1_4  Blend_2_3
;           \   /
;            BB5 RealPhi = [ Blend_1_4, BB4 ], [ Blend_2_3, BB3]
;             |
;            BB6 BlendForOrigPhi (RealPhi, BB5Def, BB6Def) (*)
;             |
;           Latch
; (*) can't have a blend with 5 incoming values, none of def1/def4/def2/def3
; would dominate that point.
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  %varying = icmp eq i32 %ld,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = or i1 %varying, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.varying, label %bb6, label %bb4

bb2:
  %bb2.varying = or i1 %varying, true
  %bb2.add = add i32 %ld, 2
  br i1 %bb2.varying, label %bb6, label %bb3

bb3:
  %bb3.varying = or i1 %varying, true
  %bb3.add = add i32 %ld, 3
  br i1 %bb3.varying, label %bb6, label %bb5

bb4:
  %bb4.varying = or i1 %varying, true
  %bb4.add = add i32 %ld, 4
  br i1 %bb4.varying, label %bb6, label %bb5

bb5:
  %bb5.add = add i32 %ld, 5
  br label %bb6

bb6:
  %phi = phi i32 [ %bb1.add, %bb1 ], [ %bb4.add, %bb4 ], [ %bb2.add, %bb2 ], [ %bb3.add, %bb3 ], [ %bb5.add, %bb5 ]
  %bb6.add = add i32 %ld, 6
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}
declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)
