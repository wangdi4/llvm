; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -enable-vp-value-codegen-hir -vplan-force-vf=4 -hir-cg -simplifycfg -sroa -print-after=VPlanDriverHIR -print-after=sroa -disable-output < %s 2>&1 | FileCheck %s
;
; LIT test where the address corresponding to a unit stride ref is a blob. When
; generating a widened memory reference of the form blob[0], the type of 0 needs
; to remain scalar so that we generate a wide load/store. The test here checks
; that we do not generate a gather/scatter. The test here converts a unit strided
; pointer to int, adds 8 to this int value, and converts the add result back to
; a pointer. The converted pointer value is still unit strided.  VPValue based
; code generation currently uses an extract instruction to get the scalar pointer
; for lane 0 to use in wide load/store. However, when creating the memref uni.idx[0]
; we were incorrectly setting the type of 0 to <VF x i64> causing a gather/scatter
; to lane 0 address.
;
; Scalar HIR:
;         DO i1 = 0, 99, 1   <DO_LOOP>
;            %conv.int = ptrtoint.i64*.i64(&((%larr)[i1]));
;            %conv.ptr = inttoptr.i64.i64*(%conv.int + 8);
;            (%conv.ptr)[0] = i1;
;         END LOOP
;
define dso_local void @foo(i64* nocapture %larr) local_unnamed_addr #0 {
; CHECK-LABEL:  *** IR Dump After VPlan Vectorization Driver HIR ***
; CHECK:       + DO i1 = 0, 99, 4   <DO_LOOP> <novectorize>
; CHECK-NEXT:  |   %.vec = ptrtoint.<4 x i64*>.<4 x i64>(&((<4 x i64*>)(%larr)[i1 + <i64 0, i64 1, i64 2, i64 3>]));
; CHECK-NEXT:  |   %.vec1 = inttoptr.<4 x i64>.<4 x i64*>(%.vec + 8);
; CHECK-NEXT:  |   %uni.idx = extractelement %.vec1,  0;
; CHECK-NEXT:  |   (<4 x i64>*)(%uni.idx)[0] = i1 + <i64 0, i64 1, i64 2, i64 3>;
; CHECK-NEXT:  + END LOOP
;
; CHECK:  *** IR Dump After SROA ***
;
; CHECK:  define dso_local void @foo(i64* nocapture [[LARR0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP_160:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  loop.16:
; CHECK-NEXT:    [[I1_I64_00:%.*]] = phi i64 [ 0, [[ENTRY0:%.*]] ], [ [[NEXTIVLOOP_160:%.*]], [[LOOP_160]] ]
; CHECK-NEXT:    [[DOTSPLATINSERT0:%.*]] = insertelement <4 x i64*> undef, i64* [[LARR0]], i32 0
; CHECK-NEXT:    [[DOTSPLAT0:%.*]] = shufflevector <4 x i64*> [[DOTSPLATINSERT0]], <4 x i64*> undef, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[DOTSPLATINSERT20:%.*]] = insertelement <4 x i64> undef, i64 [[I1_I64_00]], i32 0
; CHECK-NEXT:    [[DOTSPLAT30:%.*]] = shufflevector <4 x i64> [[DOTSPLATINSERT20]], <4 x i64> undef, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP0:%.*]] = add <4 x i64> <i64 0, i64 1, i64 2, i64 3>, [[DOTSPLAT30]]
; CHECK-NEXT:    [[ARRAYIDX0:%.*]] = getelementptr inbounds i64, <4 x i64*> [[DOTSPLAT0]], <4 x i64> [[TMP0]]
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint <4 x i64*> [[ARRAYIDX0]] to <4 x i64>
; CHECK-NEXT:    [[TMP2:%.*]] = add <4 x i64> [[TMP1]], <i64 8, i64 8, i64 8, i64 8>
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr <4 x i64> [[TMP2]] to <4 x i64*>
; CHECK-NEXT:    [[UNI_IDX40:%.*]] = extractelement <4 x i64*> [[TMP3]], i64 0
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i64* [[UNI_IDX40]] to <4 x i64>*
; CHECK-NEXT:    [[DOTSPLATINSERT50:%.*]] = insertelement <4 x i64> undef, i64 [[I1_I64_00]], i32 0
; CHECK-NEXT:    [[DOTSPLAT60:%.*]] = shufflevector <4 x i64> [[DOTSPLATINSERT50]], <4 x i64> undef, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = add <4 x i64> <i64 0, i64 1, i64 2, i64 3>, [[DOTSPLAT60]]
; CHECK-NEXT:    store <4 x i64> [[TMP5]], <4 x i64>* [[TMP4]], align 4
; CHECK-NEXT:    [[NEXTIVLOOP_160]] = add nuw nsw i64 [[I1_I64_00]], 4
; CHECK-NEXT:    [[CONDLOOP_160:%.*]] = icmp sle i64 [[NEXTIVLOOP_160]], 99
; CHECK-NEXT:    br i1 [[CONDLOOP_160]], label [[LOOP_160]], label [[AFTERLOOP_160:%.*]], !llvm.loop !0
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %l1.05 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds i64, i64* %larr, i64 %l1.05
  %conv.int = ptrtoint i64* %arrayidx to i64
  %conv.add = add i64 %conv.int, 8
  %conv.ptr = inttoptr i64 %conv.add to i64*
  store i64 %l1.05, i64* %conv.ptr, align 8
  %inc = add nuw nsw i64 %l1.05, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  ret void
}
