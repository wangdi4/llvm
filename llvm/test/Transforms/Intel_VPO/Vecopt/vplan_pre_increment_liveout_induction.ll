; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of VPlan CG for an induction whose
; live-out last value is computed before increment.

; RUN: opt -S -VPlanDriver -vplan-print-after-vpentity-instrs -vplan-force-vf=2 %s | FileCheck %s

define dso_local i32 @foo(i64 %n) local_unnamed_addr {
; CHECK-LABEL:  VPlan after insertion VPEntities instructions:
; CHECK:          i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     i32 [[VP_OTHER_IV_IND_FINAL:%.*]] = induction-final{add} i32 42 i32 3, LastValPreInc = 1
;
; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VECTOR_PH0:%.*]] ], [ [[TMP4:%.*]], [[VECTOR_BODY0:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI10:%.*]] = phi i64 [ 0, [[VECTOR_PH0]] ], [ [[TMP1:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i64> [ <i64 0, i64 1>, [[VECTOR_PH0]] ], [ [[TMP0:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[UNI_PHI20:%.*]] = phi i32 [ 42, [[VECTOR_PH0]] ], [ [[TMP3:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI30:%.*]] = phi <2 x i32> [ <i32 42, i32 45>, [[VECTOR_PH0]] ], [ [[TMP2:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[TMP0]] = add nuw nsw <2 x i64> [[VEC_PHI0]], <i64 2, i64 2>
; CHECK-NEXT:    [[TMP1]] = add nuw nsw i64 [[UNI_PHI10]], 2
; CHECK-NEXT:    [[TMP2]] = add <2 x i32> [[VEC_PHI30]], <i32 6, i32 6>
; CHECK-NEXT:    [[TMP3]] = add i32 [[UNI_PHI20]], 6
; CHECK-NEXT:    [[TMP4]] = add i64 [[UNI_PHI0]], 2
; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i64 [[TMP4]], [[N_VEC0:%.*]]
; CHECK-NEXT:    br i1 [[TMP5]], label [[VPLANNEDBB0:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    [[TMP6:%.*]] = mul i64 1, [[N_VEC0]]
; CHECK-NEXT:    [[TMP7:%.*]] = add i64 0, [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = sub i64 [[N_VEC0]], 1
; CHECK-NEXT:    [[CAST_CRD0:%.*]] = trunc i64 [[TMP8]] to i32
; CHECK-NEXT:    [[TMP9:%.*]] = mul i32 3, [[CAST_CRD0]]
; CHECK-NEXT:    [[TMP10:%.*]] = add i32 42, [[TMP9]]
;
entry:
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %entry
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.1
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %indvars.iv.next, %omp.inner.for.body ]
  %other.iv = phi i32 [ 42, %DIR.OMP.SIMD.1 ], [ %other.iv.next, %omp.inner.for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %other.iv.next = add i32 %other.iv, 3
  %exitcond = icmp eq i64 %indvars.iv.next, %n
  br i1 %exitcond, label %DIR.OMP.END.SIMD.3, label %omp.inner.for.body

DIR.OMP.END.SIMD.3:                               ; preds = %omp.inner.for.body
  %other.iv.lcssa = phi i32 [ %other.iv, %omp.inner.for.body ]
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  ret i32 %other.iv.lcssa
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry()

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token)
