; NOTE: Assertions have been autogenerated by utils/update_test_checks.py

; This test check whether we correctly handle (serialize) function call when
; the input argument is a scalar private and SOA-layout is enabled.
; RUN: opt -S -VPlanDriver -vplan-enable-soa=true %s | FileCheck %s

declare i32 @test_call(i32*)

define void @scalar_soa() {
; CHECK-LABEL: @scalar_soa(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[PRIV:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[PRIV_VEC:%.*]] = alloca <2 x i32>, align 8
; CHECK-NEXT:    [[PRIV_VEC_BC:%.*]] = bitcast <2 x i32>* [[PRIV_VEC]] to i32*
; CHECK-NEXT:    [[PRIV_VEC_BASE_ADDR:%.*]] = getelementptr i32, i32* [[PRIV_VEC_BC]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[PRIV_VEC_BASE_ADDR_EXTRACT_1_:%.*]] = extractelement <2 x i32*> [[PRIV_VEC_BASE_ADDR]], i32 1
; CHECK-NEXT:    [[PRIV_VEC_BASE_ADDR_EXTRACT_0_:%.*]] = extractelement <2 x i32*> [[PRIV_VEC_BASE_ADDR]], i32 0
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[TMP3:%.*]], [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ <i64 0, i64 1>, [[VECTOR_PH]] ], [ [[TMP2:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = call i32 @test_call(i32* [[PRIV_VEC_BASE_ADDR_EXTRACT_0_]])
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @test_call(i32* [[PRIV_VEC_BASE_ADDR_EXTRACT_1_]])
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, <2 x i32>* [[PRIV_VEC]], align 4
; CHECK-NEXT:    [[TMP2]] = add nuw nsw <2 x i64> [[VEC_PHI]], <i64 2, i64 2>
; CHECK-NEXT:    [[TMP3]] = add nuw nsw i64 [[UNI_PHI]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ult i64 [[TMP3]], 1024
; CHECK-NEXT:    br i1 [[TMP4]], label [[VECTOR_BODY]], label [[VPLANNEDBB3:%.*]], !llvm.loop [[LOOP0:![0-9]+]]
;

entry:
  %priv = alloca i32, align 4
  br label %SIMD.BEGIN

SIMD.BEGIN:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 2), "QUAL.OMP.PRIVATE"(i32* %priv) ]
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ 0, %SIMD.BEGIN ], [ %indvars.iv.next, %for.body ]
  %call = call i32 @test_call(i32* %priv)
  %ld = load i32, i32* %priv
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.body, label %omp.loop.exit

omp.loop.exit:
  br label %SIMD.END

SIMD.END:                               ; preds = %omp.loop.exit
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %EXIT

EXIT:
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry()

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token)
