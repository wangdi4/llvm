; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; Test to check for correct propagation of SOA through merging phi.
;
; RUN: opt -disable-output -passes=vplan-vec -vplan-force-vf=2 -vplan-enable-soa -vplan-enable-soa-phis -vplan-dump-da-shapes -vplan-print-after-early-peephole %s 2>&1 | FileCheck %s

define void @merge_nonuniform_strided_soa_geps() {
; CHECK-LABEL:  VPlan after Peephole transformation before predicator:
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_ARR_SOA_PRIV64:%.*]] = allocate-priv [1024 x i64], OrigAlign = 4
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_UNI_ELSE:%.*]] = getelementptr inbounds [1024 x i64], ptr [[VP_ARR_SOA_PRIV64]] i64 0 i64 1
; CHECK:     [DA: [Shape: SOA Strided, Stride: VF x i64 8]] ptr [[VP_STR_IF:%.*]] = getelementptr inbounds [1024 x i64], ptr [[VP_ARR_SOA_PRIV64]] i64 0 i64 [[VP_IV1:%.*]]
; CHECK:     [DA: [Shape: SOA Random]] ptr [[VP_PHI_MIX_UNI:%.*]] = phi  [ ptr [[VP_UNI_ELSE]], [[BB5:BB[0-9]+]] ],  [ ptr [[VP_STR_IF]], [[BB4:BB[0-9]+]] ]
; CHECK:     [DA: [Shape: Random]] i64 [[VP_LD:%.*]] = load ptr [[VP_PHI_MIX_UNI]]
; CHECK:     [DA: [Shape: SOA Random]] ptr [[VP_GEP_MIX_UNI:%.*]] = getelementptr inbounds i64, ptr [[VP_PHI_MIX_UNI]] i64 [[VP_LD]]
;
entry:
  %arr.soa.priv64 = alloca [1024 x i64], align 4
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr.soa.priv64, i64 zeroinitializer, i64 1024)]
  br label %simd.loop.preheader

simd.loop.preheader:
  br label %simd.loop

simd.loop:
  %iv1 = phi i64 [ 0, %simd.loop.preheader ], [ %iv1.next, %simd.check.phi]
  br i1 true, label %bb1, label %bb2
bb1:
  %str.if = getelementptr inbounds [1024 x i64], ptr %arr.soa.priv64, i64 0, i64 %iv1
  br label %simd.check.phi
bb2:
  %uni.else = getelementptr inbounds [1024 x i64], ptr %arr.soa.priv64, i64 0, i64 1
  %ld.else = load i64, ptr %uni.else, align 4
  br label %simd.check.phi
simd.check.phi:
  %phi.mix.uni = phi i64* [%uni.else, %bb2], [%str.if, %bb1]
  %ld = load i64, ptr %phi.mix.uni, align 4
  %gep.mix.uni = getelementptr inbounds i64, ptr %phi.mix.uni, i64 %ld
  %ld.phi.derived = load i64, ptr %gep.mix.uni, align 4
  %iv1.next = add nuw nsw i64 %iv1, 1
  %cmp = icmp ult i64 %iv1.next, 1024
  br i1 %cmp, label %simd.loop, label %simd.end
simd.end:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @merge_uniform_strided_soa_geps() {
; CHECK-LABEL:  VPlan after Peephole transformation before predicator:
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_ARR_SOA_PRIV64:%.*]] = allocate-priv [1024 x i64], OrigAlign = 4
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_UNI_ELSE:%.*]] = getelementptr inbounds [1024 x i64], ptr [[VP_ARR_SOA_PRIV64]] i64 0 i64 1
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_STR_IF:%.*]] = getelementptr inbounds [1024 x i64], ptr [[VP_ARR_SOA_PRIV64]] i64 0 i64 2
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_PHI_MIX_UNI:%.*]] = phi  [ ptr [[VP_UNI_ELSE]], [[BB5:BB[0-9]+]] ],  [ ptr [[VP_STR_IF]], [[BB4:BB[0-9]+]] ]
; CHECK:     [DA: [Shape: Random]] i64 [[VP_LD:%.*]] = load ptr [[VP_PHI_MIX_UNI]]
; CHECK:     [DA: [Shape: SOA Random]] ptr [[VP_GEP_MIX_UNI:%.*]] = getelementptr inbounds i64, ptr [[VP_PHI_MIX_UNI]] i64 [[VP_LD]]
;
entry:
  %arr.soa.priv64 = alloca [1024 x i64], align 4
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr.soa.priv64, i64 zeroinitializer, i64 1024)]
  br label %simd.loop.preheader

simd.loop.preheader:
  br label %simd.loop

simd.loop:
  %iv1 = phi i64 [ 0, %simd.loop.preheader ], [ %iv1.next, %simd.check.phi]
  br i1 true, label %bb1, label %bb2
bb1:
  %str.if = getelementptr inbounds [1024 x i64], ptr %arr.soa.priv64, i64 0, i64 2
  br label %simd.check.phi
bb2:
  %uni.else = getelementptr inbounds [1024 x i64], ptr %arr.soa.priv64, i64 0, i64 1
  %ld.else = load i64, ptr %uni.else, align 4
  br label %simd.check.phi
simd.check.phi:
  %phi.mix.uni = phi i64* [%uni.else, %bb2], [%str.if, %bb1]
  %ld = load i64, ptr %phi.mix.uni, align 4
  %gep.mix.uni = getelementptr inbounds i64, ptr %phi.mix.uni, i64 %ld
  %ld.phi.derived = load i64, ptr %gep.mix.uni, align 4
  %iv1.next = add nuw nsw i64 %iv1, 1
  %cmp = icmp ult i64 %iv1.next, 1024
  br i1 %cmp, label %simd.loop, label %simd.end
simd.end:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @merge_safe_2soa_geps() {
; CHECK-LABEL:  VPlan after Peephole transformation before predicator:
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_BRR_SOA_PRIV64:%.*]] = allocate-priv [1024 x i64], OrigAlign = 4
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_ARR_SOA_PRIV64:%.*]] = allocate-priv [1024 x i64], OrigAlign = 4
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_UNI_ELSE:%.*]] = getelementptr inbounds [1024 x i64], ptr [[VP_BRR_SOA_PRIV64]] i64 0 i64 2
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_STR_IF:%.*]] = getelementptr inbounds [1024 x i64], ptr [[VP_ARR_SOA_PRIV64]] i64 0 i64 1
; CHECK:     [DA: [Shape: SOA Unit Stride, Stride: i64 8]] ptr [[VP_PHI_MIX_UNI:%.*]] = phi  [ ptr [[VP_UNI_ELSE]], [[BB5:BB[0-9]+]] ],  [ ptr [[VP_STR_IF]], [[BB4:BB[0-9]+]] ]
; CHECK:     [DA: [Shape: Random]] i64 [[VP_LD:%.*]] = load ptr [[VP_PHI_MIX_UNI]]
; CHECK:     [DA: [Shape: SOA Random]] ptr [[VP_GEP_MIX_UNI:%.*]] = getelementptr inbounds i64, ptr [[VP_PHI_MIX_UNI]] i64 [[VP_LD]]
;
entry:
  %arr.soa.priv64 = alloca [1024 x i64], align 4
  %brr.soa.priv64 = alloca [1024 x i64], align 4
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr.soa.priv64, i64 zeroinitializer, i64 1024), "QUAL.OMP.PRIVATE:TYPED"(ptr %brr.soa.priv64, i64 zeroinitializer, i64 1024)]
  br label %simd.loop.preheader

simd.loop.preheader:
  br label %simd.loop

simd.loop:
  %iv1 = phi i64 [ 0, %simd.loop.preheader ], [ %iv1.next, %simd.check.phi]
  br i1 true, label %bb1, label %bb2
bb1:
  %str.if = getelementptr inbounds [1024 x i64], ptr %arr.soa.priv64, i64 0, i64 1
  br label %simd.check.phi
bb2:
  %uni.else = getelementptr inbounds [1024 x i64], ptr %brr.soa.priv64, i64 0, i64 2
  %ld.else = load i64, ptr %uni.else, align 4
  br label %simd.check.phi
simd.check.phi:
  %phi.mix.uni = phi i64* [%uni.else, %bb2], [%str.if, %bb1]
  %ld = load i64, ptr %phi.mix.uni, align 4
  %gep.mix.uni = getelementptr inbounds i64, ptr %phi.mix.uni, i64 %ld
  %ld.phi.derived = load i64, ptr %gep.mix.uni, align 4
  %iv1.next = add nuw nsw i64 %iv1, 1
  %cmp = icmp ult i64 %iv1.next, 1024
  br i1 %cmp, label %simd.loop, label %simd.end
simd.end:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)
declare dso_local i64 @helper(i64*)
