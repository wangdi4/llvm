; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -vplan-func-vec -vplan-dump-da < %s -disable-output 2>&1| FileCheck %s

define void @test(i32 %a) {
; CHECK:       Printing Divergence info for test
; CHECK-NEXT:  Basic Block: [[BB0:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:  Uniform: [Shape: Uniform] i32 [[VP_UNI:%.*]] = add i32 [[A0:%.*]] i32 42
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i32 [[VP_ADD:%.*]] = add i32 [[VP_LANE]] i32 42
; CHECK-NEXT:  Divergent: [Shape: Random] void [[VP0:%.*]] = ret
;
  %lane = call i32 @llvm.vplan.laneid()
  %uni = add i32 %a, 42
  %add = add i32 %lane, 42
  ret void
}

define void @test_loop_uni(i32 %vf) {
; CHECK:       Printing Divergence info for test_loop_uni
; CHECK-NEXT:  Basic Block: [[BB0:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB1:BB[0-9]+]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_VEC:%.*]] = phi  [ i32 [[VP_LANE]], [[BB0]] ],  [ i32 [[VP_VEC_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i32 [[VP_VEC_NEXT]] = add i32 [[VP_VEC]] i32 [[VF0:%.*]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i1 [[VP_EXIT_COND:%.*]] = icmp i32 [[VP_LOOP_IV]] i32 42
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB2:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Random] void [[VP0:%.*]] = ret
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %loop_iv = phi i32 [ 0, %entry ], [ %loop_iv.next, %header ]
  %vec = phi i32 [ %lane, %entry ], [ %vec.next, %header ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %vec.next = add nsw nuw i32 %vec, %vf
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %exit, label %header

exit:
  ret void
}

define void @test_loop_div_linear(i32 %vf) {
; CHECK:       Printing Divergence info for test_loop_div_linear
; CHECK-NEXT:  Basic Block: [[BB0:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB1:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 [[VP_LANE]], [[BB0]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:  Divergent: [Shape: Random] i1 [[VP_EXIT_COND:%.*]] = icmp i32 [[VP_LOOP_IV]] i32 42
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB2:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Random] void [[VP0:%.*]] = ret
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %loop_iv = phi i32 [ %lane, %entry ], [ %loop_iv.next, %header ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %exit, label %header

exit:
  ret void
}

define void @test_loop_div_random(i32 %vf) {
; CHECK:       Printing Divergence info for test_loop_div_random
; CHECK-NEXT:  Basic Block: [[BB0:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:  Divergent: [Shape: Random] i32 [[VP_MUL:%.*]] = mul i32 [[VP_LANE]] i32 [[VP_LANE]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB1:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Random] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 [[VP_MUL]], [[BB0]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:  Divergent: [Shape: Random] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:  Divergent: [Shape: Random] i1 [[VP_EXIT_COND:%.*]] = icmp i32 [[VP_LOOP_IV]] i32 42
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB2:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Random] void [[VP0:%.*]] = ret
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %mul = mul nsw nuw i32 %lane, %lane
  br label %header

header:
  %loop_iv = phi i32 [ %mul, %entry ], [ %loop_iv.next, %header ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %exit, label %header

exit:
  ret void
}

define void @test_loop_reduction(i32 %vf) {
; CHECK:       Printing Divergence info for test_loop_reduction
; CHECK-NEXT:  Basic Block: [[BB0:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB1:BB[0-9]+]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i32 1] i32 [[VP_VEC:%.*]] = phi  [ i32 [[VP_LANE]], [[BB0]] ],  [ i32 [[VP_VEC_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:  Divergent: [Shape: Random] i32 [[VP_RED:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_RED_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i32 [[VP_VEC_NEXT]] = add i32 [[VP_VEC]] i32 [[VF0:%.*]]
; CHECK-NEXT:  Divergent: [Shape: Random] i32 [[VP_RED_NEXT]] = add i32 [[VP_RED]] i32 [[VP_VEC]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i1 [[VP_EXIT_COND:%.*]] = icmp i32 [[VP_LOOP_IV]] i32 42
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB2:BB[0-9]+]]
; CHECK-NEXT:  Divergent: [Shape: Random] void [[VP0:%.*]] = ret
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %loop_iv = phi i32 [ 0, %entry ], [ %loop_iv.next, %header ]
  %vec = phi i32 [ %lane, %entry ], [ %vec.next, %header ]
  %red = phi i32 [ 0, %entry ], [ %red.next, %header ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %vec.next = add nsw nuw i32 %vec, %vf
  %red.next = add nsw nuw i32 %red, %vec
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %exit, label %header

exit:
  ret void
}

declare i32 @llvm.vplan.laneid()
