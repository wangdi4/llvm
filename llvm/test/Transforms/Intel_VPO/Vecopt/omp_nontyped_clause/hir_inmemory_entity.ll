; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; RUN: opt -enable-new-pm=0 -hir-framework -hir-vplan-vec -print-after=hir-vplan-vec -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-vplan-vec,print<hir>" -disable-output < %s 2>&1 | FileCheck %s

define dso_local i64 @foo(i64* %arr) {
; CHECK-LABEL:  Function: foo
; CHECK:       BEGIN REGION { modified }
; CHECK-NEXT:        [[PRIV_MEM_BC0:%.*]] = &((i64*)([[PRIV_MEM0:%.*]])[0])
; CHECK-NEXT:        [[DOTUNIFLOAD0:%.*]] = ([[RET0:%.*]])[0]
; CHECK-NEXT:        [[RED_INIT0:%.*]] = 0
; CHECK-NEXT:        [[RED_INIT_INSERT0:%.*]] = insertelement [[RED_INIT0]],  [[DOTUNIFLOAD0]],  0
; CHECK-NEXT:        (<4 x i64>*)([[PRIV_MEM0]])[0] = [[RED_INIT_INSERT0]]
; CHECK:             + DO i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = (<4 x i64>*)([[ARR0:%.*]])[i1]
; CHECK-NEXT:        |   [[DOTVEC20:%.*]] = (<4 x i64>*)([[PRIV_MEM0]])[0]
; CHECK-NEXT:        |   (<4 x i64>*)([[PRIV_MEM0]])[0] = [[DOTVEC0]] + [[DOTVEC20]]
; CHECK-NEXT:        + END LOOP
; CHECK:             [[DOTVEC30:%.*]] = (<4 x i64>*)([[PRIV_MEM0]])[0]
; CHECK-NEXT:        [[VEC_REDUCE0:%.*]] = @llvm.vector.reduce.add.v4i64([[DOTVEC30]])
; CHECK:             ([[RET0]])[0] = [[VEC_REDUCE0]]
; CHECK:             [[TMP0:%.*]] = ([[RET0]])[0]
; CHECK:             ret [[TMP0]]
; CHECK-NEXT:  END REGION
;
entry:
  %ret = alloca i64, align 8
  store i64 0, i64* %ret, align 8
  br label %preheader

preheader:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4), "QUAL.OMP.REDUCTION.ADD"(i64* %ret) ]
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %i.04 = phi i64 [ 0, %preheader ], [ %inc, %for.body ]
  %ptridx = getelementptr inbounds i64, i64* %arr, i64 %i.04
  %val = load i64, i64* %ptridx, align 8
  %retval = load i64, i64* %ret, align 8
  %add = add nsw i64 %retval, %val
  store i64 %add, i64* %ret, align 8
  %inc = add nuw nsw i64 %i.04, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  %0 = load i64, i64* %ret, align 8
  ret i64 %0
}

declare dso_local i64 @baz(i64*)
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
