; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of decomposed HCFG when external definition of a
; DDRef is killed by an instruction inside the HLLoop being decomposed.

; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-last-value-computation -hir-vplan-vec -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-dump-external-defs-hir=0 -disable-output -print-after=hir-vplan-vec < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-last-value-computation,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-dump-external-defs-hir=0 -disable-output < %s 2>&1 | FileCheck %s

; Input HIR
; <0>     BEGIN REGION { }
; <2>           %0 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD(),  QUAL.OMP.REDUCTION.ADD(&((%s.red)[0])),  QUAL.OMP.REDUCTION.ADD(&((%s2.red)[0])),  QUAL.OMP.NORMALIZED.IV(null),  QUAL.OMP.NORMALIZED.UB(null) ]
; <3>           (%s2.red)[0] = 0;
; <4>           (%s.red)[0] = 0;
; <6>           %add426 = 0;
; <7>           %add824 = 0;
; <34>
; <34>          + DO i1 = 0, 1023, 1   <DO_LOOP> <simd>
; <11>          |   %1 = (@a)[0][i1];
; <15>          |   %add824 = i1 + 2 * %1  +  %add824;
; <17>          |   %add426 = %add426  +  %add824;
; <19>          |   %add824 = %1 + 64  +  %add824;
; <34>          + END LOOP
; <34>
; <28>          (%s.red)[0] = %add824;
; <29>          (%s2.red)[0] = %add426;
; <31>          @llvm.directive.region.exit(%0); [ DIR.OMP.END.SIMD() ]
; <33>          ret %add426 + %add824 + 42;
; <0>     END REGION

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

; Function Attrs: nounwind uwtable
define dso_local i32 @_Z3foov() local_unnamed_addr {
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: _Z3foov:HIR.#{{[0-9]+}}
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   (+) Start: i32 [[ADD4260:%.*]] Exit: i32 [[VP0:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP1:%.*]], i32 [[VP0]], i32 [[VP_RED_INIT:%.*]], i32 [[VP_RED_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK-NEXT:   (+) Start: i32 [[ADD8240:%.*]] Exit: i32 [[VP2:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP3:%.*]], i32 [[VP2]], i32 [[VP_RED_INIT_1:%.*]], i32 [[VP_RED_FINAL_1:%.*]],
; CHECK:       Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: i64 1023 BinOp: i64 [[VP4:%.*]] = add i64 [[VP5:%.*]] i64 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP5]], i64 [[VP4]], i64 [[VP__IND_INIT:%.*]], i64 [[VP__IND_INIT_STEP]], i64 [[VP__IND_FINAL:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i32 [[VP_RED_INIT]] = reduction-init i32 0 i32 [[ADD4260]]
; CHECK-NEXT:     i32 [[VP_RED_INIT_1]] = reduction-init i32 0 i32 [[ADD8240]]
; CHECK-NEXT:     i64 [[VP__IND_INIT]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     i64 [[VP__IND_INIT_STEP]] = induction-init-step{add} i64 1
; CHECK-NEXT:     br [[BB0]]
;
; CHECK:         [[BB3:BB[0-9]+]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP_RED_FINAL]] = reduction-final{u_add} i32 [[VP0]]
; CHECK-NEXT:     i32 [[VP_RED_FINAL_1]] = reduction-final{u_add} i32 [[VP2]]
; CHECK-NEXT:     i64 [[VP__IND_FINAL]] = induction-final{add} i64 0 i64 1
;
; CHECK:       External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP_RED_FINAL_1]] -> [[VP12:%.*]] = {%add824}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1   i32 [[VP_RED_FINAL]] -> [[VP13:%.*]] = {%add426}

; Check the generated code
; CHECK:  Function: _Z3foov
; CHECK:                BEGIN REGION { modified }
; CHECK-NEXT:        ([[S2_RED0:%.*]])[0] = 0
; CHECK-NEXT:        ([[S_RED0:%.*]])[0] = 0
; CHECK-NEXT:        [[ADD4260]] = 0
; CHECK-NEXT:        [[ADD8240]] = 0
; CHECK-NEXT:        [[RED_INIT0:%.*]] = 0
; CHECK-NEXT:        [[RED_INIT_INSERT0:%.*]] = insertelement [[RED_INIT0]],  [[ADD4260]],  0
; CHECK-NEXT:        [[RED_INIT30:%.*]] = 0
; CHECK-NEXT:        [[RED_INIT_INSERT40:%.*]] = insertelement [[RED_INIT30]],  [[ADD8240]],  0
; CHECK-NEXT:        [[PHI_TEMP0:%.*]] = [[RED_INIT_INSERT0]]
; CHECK-NEXT:        [[PHI_TEMP50:%.*]] = [[RED_INIT_INSERT40]]
; CHECK:             + DO i1 = 0, 1023, 16   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = (<16 x i32>*)(@a)[0][i1]
; CHECK-NEXT:        |   [[DOTVEC70:%.*]] = [[DOTVEC0]]  *  2
; CHECK-NEXT:        |   [[DOTVEC80:%.*]] = i1 + [[DOTVEC70]] + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>  +  [[PHI_TEMP50]]
; CHECK-NEXT:        |   [[DOTVEC90:%.*]] = [[PHI_TEMP0]]  +  [[DOTVEC80]]
; CHECK-NEXT:        |   [[DOTVEC100:%.*]] = [[DOTVEC0]] + 64  +  [[DOTVEC80]]
; CHECK-NEXT:        |   [[PHI_TEMP0]] = [[DOTVEC90]]
; CHECK-NEXT:        |   [[PHI_TEMP50]] = [[DOTVEC100]]
; CHECK-NEXT:        + END LOOP
; CHECK:             [[ADD4260]] = @llvm.vector.reduce.add.v16i32([[DOTVEC90]])
; CHECK-NEXT:        [[ADD8240]] = @llvm.vector.reduce.add.v16i32([[DOTVEC100]])
; CHECK:             ([[S_RED0]])[0] = [[ADD8240]]
; CHECK-NEXT:        ([[S2_RED0]])[0] = [[ADD4260]]
; CHECK-NEXT:        ret [[ADD4260]] + [[ADD8240]] + 42
; CHECK-NEXT:  END REGION
;

omp.inner.for.body.lr.ph:
  %s2.red = alloca i32, align 4
  %s.red = alloca i32, align 4
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(i32* %s.red), "QUAL.OMP.REDUCTION.ADD"(i32* %s2.red), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  store i32 0, i32* %s2.red, align 4
  store i32 0, i32* %s.red, align 4
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %omp.inner.for.body.lr.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %omp.inner.for.body ], [ 0, %omp.inner.for.body.lr.ph ]
  %add426 = phi i32 [ %add4, %omp.inner.for.body ], [ 0, %omp.inner.for.body.lr.ph ]
  %add824 = phi i32 [ %add8, %omp.inner.for.body ], [ 0, %omp.inner.for.body.lr.ph ]
  %arrayidx = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %mul1 = shl i32 %1, 1
  %2 = trunc i64 %indvars.iv to i32
  %add2 = add nsw i32 %mul1, %2
  %add3 = add nsw i32 %add2, %add824
  %add4 = add nsw i32 %add426, %add3
  %add7 = add nsw i32 %1, 64
  %add8 = add nsw i32 %add7, %add3
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %omp.inner.for.body
  %add4.lcssa = phi i32 [ %add4, %omp.inner.for.body ]
  %add8.lcssa = phi i32 [ %add8, %omp.inner.for.body ]
  store i32 %add8.lcssa, i32* %s.red, align 4, !tbaa !7
  store i32 %add4.lcssa, i32* %s2.red, align 4, !tbaa !7
  %3 = add i32 %add4.lcssa, 42
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  %add10 = add nsw i32 %3, %add8.lcssa
  ret i32 %add10
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }

!2 = !{!3, !4, i64 0}
!3 = !{!"array@_ZTSA1024_i", !4, i64 0}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C++ TBAA"}
!7 = !{!4, !4, i64 0}
