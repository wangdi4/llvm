; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of decomposed HCFG when external definition of a
; DDRef is killed by an instruction inside the HLLoop being decomposed.

; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-last-value-computation,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-dump-external-defs-hir=0 -disable-output < %s 2>&1 | FileCheck %s

; Input HIR
; <0>     BEGIN REGION { }
; <2>           %0 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD(),  QUAL.OMP.REDUCTION.ADD(&((%s.red)[0])),  QUAL.OMP.REDUCTION.ADD(&((%s2.red)[0])),  QUAL.OMP.NORMALIZED.IV(null),  QUAL.OMP.NORMALIZED.UB(null) ]
; <3>           (%s2.red)[0] = 0;
; <4>           (%s.red)[0] = 0;
; <6>           %add426 = 0;
; <7>           %add824 = 0;
; <34>
; <34>          + DO i1 = 0, 1023, 1   <DO_LOOP> <simd>
; <11>          |   %1 = (@a)[0][i1];
; <15>          |   %add824 = i1 + 2 * %1  +  %add824;
; <17>          |   %add426 = %add426  +  %add824;
; <19>          |   %add824 = %1 + 64  +  %add824;
; <34>          + END LOOP
; <34>
; <28>          (%s.red)[0] = %add824;
; <29>          (%s2.red)[0] = %add426;
; <31>          @llvm.directive.region.exit(%0); [ DIR.OMP.END.SIMD() ]
; <33>          ret %add426 + %add824 + 42;
; <0>     END REGION

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

; Function Attrs: nounwind uwtable
define dso_local i32 @_Z3foov() local_unnamed_addr {
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: _Z3foov:HIR.#{{[0-9]+}}
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   (+) Start: i32 [[ADD4260:%.*]] Exit: i32 [[VP0:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP1:%.*]], i32 [[VP0]], i32 [[VP_RED_INIT:%.*]], i32 [[VP_RED_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK-NEXT:   (+) Start: i32 [[ADD8240:%.*]] Exit: i32 [[VP2:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP3:%.*]], i32 [[VP2]], i32 [[VP_RED_INIT_1:%.*]], i32 [[VP_RED_FINAL_1:%.*]],
; CHECK:       Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: i64 1023 BinOp: i64 [[VP4:%.*]] = add i64 [[VP5:%.*]] i64 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP5]], i64 [[VP4]], i64 [[VP__IND_INIT:%.*]], i64 [[VP__IND_INIT_STEP]], i64 [[VP__IND_FINAL:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i32 [[VP_RED_INIT]] = reduction-init i32 0 i32 [[ADD4260]]
; CHECK-NEXT:     i32 [[VP_RED_INIT_1]] = reduction-init i32 0 i32 [[ADD8240]]
; CHECK-NEXT:     i64 [[VP__IND_INIT]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     i64 [[VP__IND_INIT_STEP]] = induction-init-step{add} i64 1
; CHECK-NEXT:     br [[BB0]]
;
; CHECK:         [[BB3:BB[0-9]+]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP_RED_FINAL]] = reduction-final{u_add} i32 [[VP0]]
; CHECK-NEXT:     i32 [[VP_RED_FINAL_1]] = reduction-final{u_add} i32 [[VP2]]
; CHECK-NEXT:     i64 [[VP__IND_FINAL]] = induction-final{add} i64 0 i64 1
;
; CHECK:       External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP_RED_FINAL_1]] -> [[VP12:%.*]] = {%add824}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1   i32 [[VP_RED_FINAL]] -> [[VP13:%.*]] = {%add426}

; Check the generated code
; CHECK:  Function: _Z3foov
; CHECK:                BEGIN REGION { modified }
; CHECK-NEXT:        ([[S2_RED0:%.*]])[0] = 0
; CHECK-NEXT:        ([[S_RED0:%.*]])[0] = 0
; CHECK-NEXT:        [[ADD4260]] = 0
; CHECK-NEXT:        [[ADD8240]] = 0
; CHECK-NEXT:        [[RED_INIT0:%.*]] = 0
; CHECK-NEXT:        [[RED_INIT_INSERT0:%.*]] = insertelement [[RED_INIT0]],  [[ADD4260]],  0
; CHECK-NEXT:        [[RED_INIT30:%.*]] = 0
; CHECK-NEXT:        [[RED_INIT_INSERT40:%.*]] = insertelement [[RED_INIT30]],  [[ADD8240]],  0
; CHECK-NEXT:        [[PHI_TEMP0:%.*]] = [[RED_INIT_INSERT0]]
; CHECK-NEXT:        [[PHI_TEMP50:%.*]] = [[RED_INIT_INSERT40]]
; CHECK:             + DO i1 = 0, 1023, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = (<4 x i32>*)(@a)[0][i1]
; CHECK-NEXT:        |   [[DOTVEC70:%.*]] = [[DOTVEC0]]  *  2
; CHECK-NEXT:        |   [[DOTVEC80:%.*]] = i1 + [[DOTVEC70]] + <i32 0, i32 1, i32 2, i32 3>  +  [[PHI_TEMP50]]
; CHECK-NEXT:        |   [[DOTVEC90:%.*]] = [[PHI_TEMP0]]  +  [[DOTVEC80]]
; CHECK-NEXT:        |   [[DOTVEC100:%.*]] = [[DOTVEC0]] + 64  +  [[DOTVEC80]]
; CHECK-NEXT:        |   [[PHI_TEMP0]] = [[DOTVEC90]]
; CHECK-NEXT:        |   [[PHI_TEMP50]] = [[DOTVEC100]]
; CHECK-NEXT:        + END LOOP
; CHECK:             [[ADD4260]] = @llvm.vector.reduce.add.v4i32([[DOTVEC90]])
; CHECK-NEXT:        [[ADD8240]] = @llvm.vector.reduce.add.v4i32([[DOTVEC100]])
; CHECK-NEXT:        ([[S_RED0]])[0] = [[ADD8240]]
; CHECK-NEXT:        ([[S2_RED0]])[0] = [[ADD4260]]
; CHECK-NEXT:        ret [[ADD4260]] + [[ADD8240]] + 42
; CHECK-NEXT:  END REGION
;

omp.inner.for.body.lr.ph:
  %s2.red = alloca i32, align 4
  %s.red = alloca i32, align 4
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(i32* %s.red), "QUAL.OMP.REDUCTION.ADD"(i32* %s2.red), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  store i32 0, i32* %s2.red, align 4
  store i32 0, i32* %s.red, align 4
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %omp.inner.for.body.lr.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %omp.inner.for.body ], [ 0, %omp.inner.for.body.lr.ph ]
  %add426 = phi i32 [ %add4, %omp.inner.for.body ], [ 0, %omp.inner.for.body.lr.ph ]
  %add824 = phi i32 [ %add8, %omp.inner.for.body ], [ 0, %omp.inner.for.body.lr.ph ]
  %arrayidx = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %mul1 = shl i32 %1, 1
  %2 = trunc i64 %indvars.iv to i32
  %add2 = add nsw i32 %mul1, %2
  %add3 = add nsw i32 %add2, %add824
  %add4 = add nsw i32 %add426, %add3
  %add7 = add nsw i32 %1, 64
  %add8 = add nsw i32 %add7, %add3
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %omp.inner.for.body
  %add4.lcssa = phi i32 [ %add4, %omp.inner.for.body ]
  %add8.lcssa = phi i32 [ %add8, %omp.inner.for.body ]
  store i32 %add8.lcssa, i32* %s.red, align 4, !tbaa !7
  store i32 %add4.lcssa, i32* %s2.red, align 4, !tbaa !7
  %3 = add i32 %add4.lcssa, 42
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  %add10 = add nsw i32 %3, %add8.lcssa
  ret i32 %add10
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }

!2 = !{!3, !4, i64 0}
!3 = !{!"array@_ZTSA1024_i", !4, i64 0}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C++ TBAA"}
!7 = !{!4, !4, i64 0}
