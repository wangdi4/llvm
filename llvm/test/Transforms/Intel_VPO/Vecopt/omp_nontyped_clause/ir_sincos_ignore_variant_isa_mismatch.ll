; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Check VPlan vectorizer generates valid vector sincos call given
; the target CPU and ISA restrictions of available vector-variants.

; RUN: opt -S -vplan-vec -vector-library=SVML -mcpu=core-avx2 -vplan-force-vf=4 -tti-use-strict-target-isa-for-variant < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local void @test() local_unnamed_addr {
; CHECK-LABEL: @test(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[TMP3:%.*]], [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VECTOR_PH]] ], [ [[TMP2:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds [128 x float], [128 x float]* [[PHASE:%.*]], i64 0, i64 [[UNI_PHI]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast float* [[SCALAR_GEP]] to <4 x float>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x float>, <4 x float>* [[TMP0]], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = call svml_cc { <4 x float>, <4 x float> } @__svml_sincosf4(<4 x float> [[WIDE_LOAD]])
; CHECK-NEXT:    [[SINCOS_SIN:%.*]] = extractvalue { <4 x float>, <4 x float> } [[TMP1]], 0
; CHECK-NEXT:    [[SINCOS_COS:%.*]] = extractvalue { <4 x float>, <4 x float> } [[TMP1]], 1
; CHECK-NEXT:    store <4 x float> [[SINCOS_SIN]], <4 x float>* [[SINVAL_VEC:%.*]], align 4
; CHECK-NEXT:    store <4 x float> [[SINCOS_COS]], <4 x float>* [[COSVAL_VEC:%.*]], align 4
; CHECK-NEXT:    [[TMP2]] = add nuw nsw <4 x i64> [[VEC_PHI]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP3]] = add nuw nsw i64 [[UNI_PHI]], 4
; CHECK-NEXT:    [[TMP4:%.*]] = icmp uge i64 [[TMP3]], 128
; CHECK-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB3:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
;
DIR.OMP.SIMD.1338:
  %phase = alloca [128 x float], align 16
  %sinval = alloca float
  %cosval = alloca float
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %DIR.OMP.SIMD.1338
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE"(float* %cosval), "QUAL.OMP.PRIVATE"(float* %sinval) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %DIR.OMP.SIMD.1, %omp.inner.for.body
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %indvars.iv.next, %omp.inner.for.body ]
  %arrayidx4 = getelementptr inbounds [128 x float], [128 x float]* %phase, i64 0, i64 %indvars.iv
  %phase.ld = load float, float* %arrayidx4, align 4
  call void @sincosf(float %phase.ld, float* nonnull %sinval, float* nonnull %cosval)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 128
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
declare void @sincosf(float, float*, float*) #8

attributes #8 = { nofree nounwind "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "frame-pointer"="none" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+avx,+avx2,+bmi,+bmi2,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" "unsafe-fp-math"="true" "vector-variants"="_ZGVbN4vvv_sincosf,_ZGVcN8vvv_sincosf,_ZGVdN8vvv_sincosf,_ZGVeN16vvv_sincosf" }
