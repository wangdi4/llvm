; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vplan-vec -disable-output -vplan-print-after-plain-cfg -vplan-entities-dump -print-after=hir-vplan-vec < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; *** IR Dump Before vpo::VPlanDriverHIRPass ***
; <0>          BEGIN REGION { }
; <2>                %0 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD(),  QUAL.OMP.SIMDLEN(4),  QUAL.OMP.LINEAR(&((%l2.linear)[0])2),  QUAL.OMP.LINEAR:IV(&((%l1.linear.iv)[0])1),  QUAL.OMP.NORMALIZED.IV(null),  QUAL.OMP.NORMALIZED.UB(null) ]
; <24>
; <24>               + DO i1 = 0, zext.i32.i64(%k) + -1, 1   <DO_LOOP>  <MAX_TC_EST = 2147483647>  <LEGAL_MAX_TC = 2147483647> <simd> <vectorize> <ivdep>
; <6>                |   %1 = (%l2.linear)[0];
; <8>                |   (%lp1)[i1] = %1;
; <10>               |   (%l2.linear)[0] = %1 + 2;
; <11>               |   %call = @_Z3bazPl(&((%l2.linear)[0]));
; <24>               + END LOOP
; <24>
; <19>               (%l1.linear.iv)[0] = %k;
; <22>               @llvm.directive.region.exit(%0); [ DIR.OMP.END.SIMD() ]
; <0>          END REGION

define void @_Z3fooPlS_i(i64* nocapture noundef writeonly %lp1, i64* nocapture noundef readnone %lp2, i32 noundef %k) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: _Z3fooPlS_i:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%l2.linear}
; CHECK-DAG:     [[VP1:%.*]] = {zext.i32.i64(%k) + -1}
; CHECK-DAG:     [[VP2:%.*]] = {%lp1}
; CHECK-DAG:     [[VP3:%.*]] = {%l1.linear.iv}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK:       Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: ? BinOp: i64 [[VP4:%.*]] = add i64 [[VP5:%.*]] i64 1
; CHECK-NEXT:    Linked values: i64 [[VP5]], i64 [[VP4]],
; CHECK:       IntInduction(+) Start: i64 [[VP_LOAD:%.*]] Step: i64 2 StartVal: ? EndVal: ? need close form  Memory: i64* [[L2_LINEAR0:%.*]]

; CHECK:       *** IR Dump After vpo::VPlanDriverHIRPass ***
; CHECK:       BEGIN REGION { modified }
; CHECK-NEXT:        [[TGU0:%.*]] = zext.i32.i64([[K0:%.*]])  /u  4
; CHECK-NEXT:        [[VEC_TC0:%.*]] = [[TGU0]]  *  4
; CHECK-NEXT:        [[DOTVEC0:%.*]] = 0 == [[VEC_TC0]]
; CHECK-NEXT:        [[PHI_TEMP0:%.*]] = 0
; CHECK-NEXT:        [[EXTRACT_0_0:%.*]] = extractelement [[DOTVEC0]],  0
; CHECK-NEXT:        if ([[EXTRACT_0_0]] == 1)
; CHECK-NEXT:        {
; CHECK-NEXT:           goto [[MERGE_BLK0:merge.blk[0-9]+]].33
; CHECK-NEXT:        }
; CHECK-NEXT:        [[PRIV_MEM_BC0:%.*]] = &((i64*)([[PRIV_MEM0:%.*]])[0])
; CHECK-NEXT:        [[TGU30:%.*]] = zext.i32.i64([[K0]])  /u  4
; CHECK-NEXT:        [[VEC_TC40:%.*]] = [[TGU30]]  *  4
; CHECK-NEXT:        [[DOTUNIFLOAD0:%.*]] = ([[L2_LINEAR0]])[0]
; CHECK-NEXT:        [[IND_VEC_STEP0:%.*]] = 2  *  <i64 0, i64 1, i64 2, i64 3>
; CHECK-NEXT:        [[TMP0:%.*]] = [[DOTUNIFLOAD0]]  +  [[IND_VEC_STEP0]]
; CHECK-NEXT:        (<4 x i64>*)([[PRIV_MEM0]])[0] = [[TMP0]]
; CHECK-NEXT:        [[IND_STEP_INIT0:%.*]] = 2  *  4
; CHECK-NEXT:        [[PHI_TEMP50:%.*]] = [[TMP0]]
; CHECK-NEXT:        [[LOOP_UB0:%.*]] = [[VEC_TC40]]  -  1

; CHECK:             + DO i1 = 0, [[LOOP_UB0]], 4   <DO_LOOP>  <MAX_TC_EST = 536870911>  <LEGAL_MAX_TC = 536870911> <simd-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:        |   (<4 x i64>*)([[PRIV_MEM0]])[0] = [[PHI_TEMP50]]
; CHECK-NEXT:        |   [[DOTVEC70:%.*]] = (<4 x i64>*)([[PRIV_MEM0]])[0]
; CHECK-NEXT:        |   (<4 x i64>*)([[LP10:%.*]])[i1] = [[DOTVEC70]]
; CHECK-NEXT:        |   (<4 x i64>*)([[PRIV_MEM0]])[0] = [[DOTVEC70]] + 2
; CHECK:             |   [[PHI_TEMP50]] = [[IND_STEP_INIT0]] + [[PHI_TEMP50]]
; CHECK-NEXT:        + END LOOP

; CHECK:             [[IND_FINAL0:%.*]] = 0  +  [[VEC_TC40]]
; CHECK-NEXT:        [[DOTVEC150:%.*]] = (<4 x i64>*)([[PRIV_MEM0]])[0]
; CHECK-NEXT:        [[TMP1:%.*]] = 2  *  [[VEC_TC40]]
; CHECK-NEXT:        [[IND_FINAL160:%.*]] = [[DOTUNIFLOAD0]]  +  [[TMP1]]
; CHECK-NEXT:        ([[L2_LINEAR0]])[0] = [[IND_FINAL160]]
; CHECK-NEXT:        [[DOTVEC170:%.*]] = zext.i32.i64([[K0]]) == [[VEC_TC40]]
; CHECK-NEXT:        [[PHI_TEMP0]] = [[IND_FINAL0]]
; CHECK-NEXT:        [[PHI_TEMP190:%.*]] = [[IND_FINAL0]]
; CHECK-NEXT:        [[EXTRACT_0_210:%.*]] = extractelement [[DOTVEC170]],  0
; CHECK-NEXT:        if ([[EXTRACT_0_210]] == 1)
; CHECK-NEXT:        {
; CHECK-NEXT:           goto final.merge.82
; CHECK-NEXT:        }
; CHECK-NEXT:        [[MERGE_BLK0]].33:
; CHECK-NEXT:        [[LB_TMP0:%.*]] = [[PHI_TEMP0]]

; CHECK:             + DO i1 = [[LB_TMP0]], zext.i32.i64([[K0]]) + -1, 1   <DO_LOOP>  <MAX_TC_EST = 3>  <LEGAL_MAX_TC = 3> <nounroll> <novectorize> <max_trip_count = 3>
; CHECK-NEXT:        |   [[TMP3:%.*]] = ([[L2_LINEAR0]])[0]
; CHECK-NEXT:        |   ([[LP10]])[i1] = [[TMP3]]
; CHECK-NEXT:        |   ([[L2_LINEAR0]])[0] = [[TMP3]] + 2
; CHECK-NEXT:        |   [[CALL0:%.*]] = @_Z3bazPl(&(([[L2_LINEAR0]])[0]))
; CHECK-NEXT:        + END LOOP

; CHECK:             [[PHI_TEMP190]] = zext.i32.i64([[K0]]) + -1
; CHECK-NEXT:        final.merge.82:
; CHECK-NEXT:        ([[L1_LINEAR_IV0:%.*]])[0] = [[K0]]
; CHECK-NEXT:  END REGION
;
entry:
  %l2.linear = alloca i64, align 8
  %l1.linear.iv = alloca i64, align 8
  %cmp = icmp sgt i32 %k, 0
  br i1 %cmp, label %omp.inner.for.body.lr.ph, label %omp.precond.end

omp.inner.for.body.lr.ph:                         ; preds = %entry
  %conv = zext i32 %k to i64
  store i64 100, i64* %l2.linear, align 8
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %omp.inner.for.body.lr.ph
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4), "QUAL.OMP.LINEAR"(i64* %l2.linear, i32 2), "QUAL.OMP.LINEAR:IV"(i64* %l1.linear.iv, i32 1), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.1
  %.omp.iv.local.018 = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %add6, %omp.inner.for.body ]
  %1 = load i64, i64* %l2.linear, align 8
  %arrayidx = getelementptr inbounds i64, i64* %lp1, i64 %.omp.iv.local.018
  store i64 %1, i64* %arrayidx, align 8
  %add5 = add nsw i64 %1, 2
  store i64 %add5, i64* %l2.linear, align 8
  %call = call noundef i64 @_Z3bazPl(i64* noundef nonnull %l2.linear)
  %add6 = add nuw nsw i64 %.omp.iv.local.018, 1
  %exitcond.not = icmp eq i64 %add6, %conv
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.124, label %omp.inner.for.body

DIR.OMP.END.SIMD.124:                             ; preds = %omp.inner.for.body
  store i64 %conv, i64* %l1.linear.iv, align 8
  br label %DIR.OMP.END.SIMD.2

DIR.OMP.END.SIMD.2:                               ; preds = %DIR.OMP.END.SIMD.124
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.2, %entry
  ret void
}

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)

declare i64 @_Z3bazPl(i64* noundef) #0

attributes #0 = { nounwind }
