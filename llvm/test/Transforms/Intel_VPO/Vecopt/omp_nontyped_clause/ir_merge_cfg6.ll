; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt -S -passes=vplan-vec -disable-vplan-codegen -disable-output  -vplan-print-after-cfg-merge < %s 2>&1 | FileCheck %s --check-prefix=MERGE
; RUN: opt -S -passes="vplan-vec" -disable-vplan-codegen -disable-output  -vplan-print-after-cfg-merge < %s 2>&1 | FileCheck %s --check-prefix=MERGE

; Verify that vector TC check is correctly placed before instructions that
; are created before the loop preheader.

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

@gint = addrspace(1) global i32 1
@testKernel.lint = internal addrspace(3) global i32 undef

define void @_ZGVdN8u_testKernel(i32 addrspace(1)* noalias %results) {
; MERGE-LABEL:  VPlan after CFG merge before CG:
; MERGE-NEXT:  VPlan IR for: _ZGVdN8u_testKernel:simd.loop
; MERGE-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; MERGE-NEXT:     [DA: Uni] pushvf VF=8 UF=1
; MERGE-NEXT:     [DA: Uni] pushvf VF=8 UF=1
; TODO: the two predicates below should be placed after trip check
; MERGE-NEXT:     [DA: Uni] i1 [[VP__NOT:%.*]] = not i1 icmp eq (i8 addrspace(3)* bitcast (i32 addrspace(3)* @testKernel.lint to i8 addrspace(3)*), i8 addrspace(3)* null)
; MERGE-NEXT:     [DA: Uni] i1 [[VP__NOT_1:%.*]] = not i1 icmp eq (i8 addrspace(1)* bitcast (i32 addrspace(1)* @gint to i8 addrspace(1)*), i8 addrspace(1)* null)
; MERGE-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; MERGE-EMPTY:
; MERGE-NEXT:    [[BB1]]: # preds: [[BB0]]
; MERGE-NEXT:     [DA: Div] i32 [[VP_INDEX_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; MERGE-NEXT:     [DA: Uni] i32 [[VP_INDEX_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; MERGE-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 8, UF = 1
entry:
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 8), "QUAL.OMP.UNIFORM"(i32 addrspace(1)* %results) ]
  br label %simd.loop

simd.loop:
  %index = phi i32 [ 0, %simd.begin.region ], [ %indvar, %simd.loop.exit ]
  %ind_sext = sext i32 %index to i64
  %rem14 = and i64 %ind_sext, 1
  %tobool = icmp eq i64 %rem14, 0
  %.gint = select i1 %tobool, i32 addrspace(1)* addrspacecast (i32 addrspace(3)* @testKernel.lint to i32 addrspace(1)*), i32 addrspace(1)* @gint
  br i1 %tobool, label %land.lhs.true13, label %land.lhs.true

land.lhs.true:
  br i1 icmp eq (i8 addrspace(1)* bitcast (i32 addrspace(1)* @gint to i8 addrspace(1)*), i8 addrspace(1)* null), label %land.end, label %land.rhs

land.rhs:
  br label %land.end

land.end:
  br label %if.end22

land.lhs.true13:
  br i1 icmp eq (i8 addrspace(3)* bitcast (i32 addrspace(3)* @testKernel.lint to i8 addrspace(3)*), i8 addrspace(3)* null), label %land.end18, label %land.rhs15

land.rhs15:
  br label %land.end18

land.end18:
  br label %if.end22

if.end22:
  br label %simd.loop.exit

simd.loop.exit:
  %indvar = add nuw i32 %index, 1
  %vl.cond = icmp ult i32 %indvar, 8
  br i1 %vl.cond, label %simd.loop, label %simd.end.region

simd.end.region:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"(), "DIR.QUAL.LIST.END"() ]
  br label %return

return:
  ret void
}
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
