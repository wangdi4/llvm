; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to verify that VPlan's HIR decomposer is able to handle incoming
; vector types while decomposing a Blob's coefficient.

; Incoming HIR
;    + DO i1 = 0, 49, 1   <DO_LOOP>
;    |   %src.ld = (<8 x double>*)(@dsrc1)[0][2 * i1];
;    |   %add.i94 = %src.ld  +  %src.ld;
;    |   (<8 x double>*)(@ddest_zmm)[0][2 * i1] = %add.i94;
;    |   %dest.ld = (<8 x double>*)(@ddest_zmm)[0][2 * i1 + 1];
;    |   %src2.ld = (<8 x double>*)(@dsrc1)[0][2 * i1 + 1];
;    |   %add.i.i = %src2.ld  +  %src2.ld;
;    |   %sel = (%cond != 0) ? %add.i.i : %dest.ld;
;    |   (<8 x double>*)(@ddest_zmm)[0][2 * i1 + 1] = %sel;
;    + END LOOP

; In above example %cond is of type <8 x i1> and predicates's RHS is a
; zeroinitializer of type <8 x i1>

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-plain-cfg < %s -disable-output 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-plain-cfg < %s -disable-output 2>&1 | FileCheck %s


%union.V512 = type { <16 x float> }

@dsrc1 = dso_local local_unnamed_addr global [100 x %union.V512] zeroinitializer, align 64
@ddest_zmm = dso_local global [100 x %union.V512] zeroinitializer, align 64

; Function Attrs: nofree nounwind uwtable
define dso_local void @do_add_pd(<8 x i1> %cond) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: do_add_pd:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {@ddest_zmm}
; CHECK-DAG:     [[VP1:%.*]] = {@dsrc1}
; CHECK-DAG:     [[VP2:%.*]] = {%cond}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP3:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP4:%.*]], [[BB2]] ]
; CHECK-NEXT:     i64 [[VP5:%.*]] = mul i64 2 i64 [[VP3]]
; CHECK-NEXT:     %union.V512* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [100 x %union.V512]* @dsrc1 i64 0 i64 [[VP5]]
; CHECK-NEXT:     <8 x double>* [[VP6:%.*]] = bitcast %union.V512* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     <8 x double> [[VP_LOAD:%.*]] = load <8 x double>* [[VP6]]
; CHECK-NEXT:     <8 x double> [[VP7:%.*]] = fadd <8 x double> [[VP_LOAD]] <8 x double> [[VP_LOAD]]
; CHECK-NEXT:     %union.V512* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [100 x %union.V512]* @ddest_zmm i64 0 i64 [[VP5]]
; CHECK-NEXT:     <8 x double>* [[VP9:%.*]] = bitcast %union.V512* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     store <8 x double> [[VP7]] <8 x double>* [[VP9]]
; CHECK-NEXT:     i64 [[VP11:%.*]] = add i64 [[VP5]] i64 1
; CHECK-NEXT:     %union.V512* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [100 x %union.V512]* @ddest_zmm i64 0 i64 [[VP11]]
; CHECK-NEXT:     <8 x double>* [[VP12:%.*]] = bitcast %union.V512* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     <8 x double> [[VP_LOAD_1:%.*]] = load <8 x double>* [[VP12]]
; CHECK-NEXT:     %union.V512* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [100 x %union.V512]* @dsrc1 i64 0 i64 [[VP11]]
; CHECK-NEXT:     <8 x double>* [[VP15:%.*]] = bitcast %union.V512* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     <8 x double> [[VP_LOAD_2:%.*]] = load <8 x double>* [[VP15]]
; CHECK-NEXT:     <8 x double> [[VP16:%.*]] = fadd <8 x double> [[VP_LOAD_2]] <8 x double> [[VP_LOAD_2]]
; CHECK-NEXT:     <8 x i1> [[VP17:%.*]] = icmp ne <8 x i1> [[COND0:%.*]] <8 x i1> zeroinitializer
; CHECK-NEXT:     <8 x double> [[VP18:%.*]] = select <8 x i1> [[VP17]] <8 x double> [[VP16]] <8 x double> [[VP_LOAD_1]]
; CHECK-NEXT:     %union.V512* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [100 x %union.V512]* @ddest_zmm i64 0 i64 [[VP11]]
; CHECK-NEXT:     <8 x double>* [[VP21:%.*]] = bitcast %union.V512* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     store <8 x double> [[VP18]] <8 x double>* [[VP21]]
; CHECK-NEXT:     i64 [[VP4]] = add i64 [[VP3]] i64 1
; CHECK-NEXT:     i1 [[VP22:%.*]] = icmp slt i64 [[VP4]] i64 50
; CHECK-NEXT:     br i1 [[VP22]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
  br label %for.body26

for.body26:                                       ; preds = %entry, %for.body26
  %indvars.iv109 = phi i64 [ 0, %entry ], [ %indvars.iv.next110, %for.body26 ]
  %arrayidx28 = getelementptr inbounds [100 x %union.V512], [100 x %union.V512]* @dsrc1, i64 0, i64 %indvars.iv109
  %zmmd = bitcast %union.V512* %arrayidx28 to <8 x double>*
  %src.ld = load <8 x double>, <8 x double>* %zmmd, align 64
  %add.i94 = fadd contract <8 x double> %src.ld, %src.ld
  %arrayidx34 = getelementptr inbounds [100 x %union.V512], [100 x %union.V512]* @ddest_zmm, i64 0, i64 %indvars.iv109
  %zmmd35 = bitcast %union.V512* %arrayidx34 to <8 x double>*
  store <8 x double> %add.i94, <8 x double>* %zmmd35, align 64
  %iv.or = or i64 %indvars.iv109, 1
  %arrayidx37 = getelementptr inbounds [100 x %union.V512], [100 x %union.V512]* @ddest_zmm, i64 0, i64 %iv.or
  %zmmd38 = bitcast %union.V512* %arrayidx37 to <8 x double>*
  %dest.ld = load <8 x double>, <8 x double>* %zmmd38, align 64
  %arrayidx41 = getelementptr inbounds [100 x %union.V512], [100 x %union.V512]* @dsrc1, i64 0, i64 %iv.or
  %zmmd42 = bitcast %union.V512* %arrayidx41 to <8 x double>*
  %src2.ld = load <8 x double>, <8 x double>* %zmmd42, align 64
  %add.i.i = fadd contract <8 x double> %src2.ld, %src2.ld
  %sel = select contract <8 x i1> %cond, <8 x double> %add.i.i, <8 x double> %dest.ld
  store <8 x double> %sel, <8 x double>* %zmmd38, align 64
  %indvars.iv.next110 = add nuw nsw i64 %indvars.iv109, 2
  %cmp24 = icmp ult i64 %indvars.iv109, 98
  br i1 %cmp24, label %for.body26, label %for.end54

for.end54:                                        ; preds = %for.body26
  ret void
}

