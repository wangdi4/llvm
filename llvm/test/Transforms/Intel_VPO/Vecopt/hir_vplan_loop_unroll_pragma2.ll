; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt -S %s -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -print-before=hir-vplan-vec -print-after=hir-vplan-vec -disable-output 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -S %s -vplan-force-vf=4 -print-before=hir-vplan-vec -print-after=hir-vplan-vec -disable-output 2>&1 | FileCheck %s

; #define N 1048576
; void iota(double* A) {
; #pragma unroll 2
;   for (int i = 0; i < N; ++i) {
;     A[i] = i;
;   }
; }

; This test checks that the loop has <unroll = 2> metadata before unrolling, but marked with <nounroll> metadata after that.

define void @iota(double* nocapture %A) {
;
; CHECK: IR Dump Before {{VPlan HIR Vectorizer|vpo::VPlanDriverHIRPass}}
; CHECK: + DO i1 = 0, 1048575, 1   <DO_LOOP> <unroll = 2>
;
; CHECK: IR Dump After {{VPlan HIR Vectorizer|vpo::VPlanDriverHIRPass}}
; CHECK: + DO i1 = 0, 1048575, 8   <DO_LOOP> <auto-vectorized> <nounroll> <novectorize>
;
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret void

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %0 = trunc i64 %indvars.iv to i32
  %conv = sitofp i32 %0 to double
  %arrayidx = getelementptr inbounds double, double* %A, i64 %indvars.iv
  store double %conv, double* %arrayidx
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1048576
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !llvm.loop !7
}

!7 = distinct !{!7, !8, !9}
!8 = !{!"llvm.loop.mustprogress"}
!9 = !{!"llvm.loop.unroll.count", i32 2}
