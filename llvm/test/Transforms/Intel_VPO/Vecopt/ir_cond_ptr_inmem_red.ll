;NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; Test to check we correctly parse in memory reductions which are
; conditionally updated by their pointers.
; The source test looks like
;
; #pragma omp simd reduction(+:r,r2)
; for (int i=0; i < 1000; i++) {
;   int *pr;
;   if (m[i]) {
;     pr = &r;
;   }
;   else {
;     pr = &r2;
;   }
;   *pr += a[i] + k;
; }
;
; RUN: opt -disable-output -passes=vplan-vec -vplan-force-vf=2 -vplan-print-after-vpentity-instrs %s 2>&1 | FileCheck %s
;
define dso_local i32 @_Z3fooPiS_(i1 %m, ptr nocapture noundef readonly %a) {
; CHECK-LABEL: VPlan IR for: _Z3fooPiS_:omp.inner.for.body
; loop preheader
; CHECK:     ptr [[VP_R2_RED:%.*]] = allocate-priv i32, OrigAlign = 4
; CHECK:     ptr [[VP_R_RED:%.*]] = allocate-priv i32, OrigAlign = 4
; CHECK:     i32 [[VP_LOAD:%.*]] = load ptr [[R_RED0:%.*]]
; CHECK:     i32 [[VP_R_REDRED_INIT:%.*]] = reduction-init i32 0 i32 [[VP_LOAD]]
; CHECK:     i32 [[VP_LOAD_1:%.*]] = load ptr [[R2_RED0:%.*]]
; CHECK:     i32 [[VP_R2_REDRED_INIT:%.*]] = reduction-init i32 0 i32 [[VP_LOAD_1]]
; loop body
; CHECK:     ptr [[VP_PR_PRIV_0:%.*]] = phi  [ ptr [[VP_R_RED]], [[BB4:BB[0-9]+]] ],  [ ptr [[VP_R2_RED]], [[BB2:BB[0-9]+]] ]
; CHECK:     store i32 [[VP_ADD7:%.*]] ptr [[VP_PR_PRIV_0]]
; loop exit
; CHECK:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_R_RED]]
; CHECK:     i32 [[VP_R_REDRED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_LOAD_2]]
; CHECK:     store i32 [[VP_R_REDRED_FINAL]] ptr [[R_RED0]]
; CHECK:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_R2_RED]]
; CHECK:     i32 [[VP_R2_REDRED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_LOAD_3]]
; CHECK:     store i32 [[VP_R2_REDRED_FINAL]] ptr [[R2_RED0]]
;
DIR.OMP.SIMD.216:
  %r2.red = alloca i32, align 4
  %r.red = alloca i32, align 4
  %i.linear.iv = alloca i32, align 4
  store i32 0, ptr %r2.red, align 4
  store i32 0, ptr %r.red, align 4
  br label %omp.inner.for.body.lr.ph

omp.inner.for.body.lr.ph:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD:TYPED"(ptr %r.red, i32 0, i32 1), "QUAL.OMP.REDUCTION.ADD:TYPED"(ptr %r2.red, i32 0, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:
  %indvars.iv = phi i64 [ 0, %omp.inner.for.body.lr.ph ], [ %indvars.iv.next, %if.end ]
  br i1 %m, label %if.end, label %if.then

if.then:
  br label %if.end

if.end:
  %pr.priv.0 = phi ptr [ %r.red, %if.then ], [ %r2.red, %omp.inner.for.body ]
  %arrayidx5 = getelementptr inbounds i32, ptr %a, i64 %indvars.iv
  %ld4 = load i32, ptr %arrayidx5, align 4
  %ld5 = load i32, ptr %pr.priv.0, align 4
  %add7 = add nsw i32 %ld5, %ld4
  store i32 %add7, ptr %pr.priv.0, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1000
  br i1 %exitcond.not, label %omp.inner.for.cond.DIR.OMP.END.SIMD.4.loopexit_crit_edge, label %omp.inner.for.body

omp.inner.for.cond.DIR.OMP.END.SIMD.4.loopexit_crit_edge:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:
  %ld6 = load i32, ptr %r.red, align 4
  %ld7 = load i32, ptr %r2.red, align 4
  %r = add i32 %ld6, %ld7
  ret i32 %r
}


define dso_local i32 @_Z3gooPiS_(i1 %m, ptr nocapture noundef readonly %a) {
; CHECK-LABEL: VPlan IR for: _Z3gooPiS_:omp.inner.for.body
; loop preheader
; CHECK:     ptr [[VP_R2_RED:%.*]] = allocate-priv i32, OrigAlign = 4
; CHECK:     ptr [[VP_R_RED:%.*]] = allocate-priv i32, OrigAlign = 4
; CHECK:     i32 [[VP_LOAD:%.*]] = load ptr [[R_RED0:%.*]]
; CHECK:     i32 [[VP_R_REDRED_INIT:%.*]] = reduction-init i32 0 i32 [[VP_LOAD]]
; CHECK:     i32 [[VP_LOAD_1:%.*]] = load ptr [[R2_RED0:%.*]]
; CHECK:     i32 [[VP_R2_REDRED_INIT:%.*]] = reduction-init i32 0 i32 [[VP_LOAD_1]]
; loop body
; CHECK:     ptr [[VP_PR_PRIV_0:%.*]] = select i1 [[M0:%.*]] ptr [[VP_R_RED]] ptr [[VP_R2_RED]]
; CHECK:     store i32 [[VP_ADD7:%.*]] ptr [[VP_PR_PRIV_0]]
; loop exit
; CHECK:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_R_RED]]
; CHECK:     i32 [[VP_R_REDRED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_LOAD_2]]
; CHECK:     store i32 [[VP_R_REDRED_FINAL]] ptr [[R_RED0]]
; CHECK:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_R2_RED]]
; CHECK:     i32 [[VP_R2_REDRED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_LOAD_3]]
; CHECK:     store i32 [[VP_R2_REDRED_FINAL]] ptr [[R2_RED0]]
;
DIR.OMP.SIMD.216:
  %r2.red = alloca i32, align 4
  %r.red = alloca i32, align 4
  %i.linear.iv = alloca i32, align 4
  store i32 0, ptr %r2.red, align 4
  store i32 0, ptr %r.red, align 4
  br label %omp.inner.for.body.lr.ph

omp.inner.for.body.lr.ph:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD:TYPED"(ptr %r.red, i32 0, i32 1), "QUAL.OMP.REDUCTION.ADD:TYPED"(ptr %r2.red, i32 0, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:
  %indvars.iv = phi i64 [ 0, %omp.inner.for.body.lr.ph ], [ %indvars.iv.next, %if.end ]
  br label %if.end

if.end:
  %pr.priv.0 = select i1 %m, ptr %r.red, ptr %r2.red
  %arrayidx5 = getelementptr inbounds i32, ptr %a, i64 %indvars.iv
  %ld4 = load i32, ptr %arrayidx5, align 4
  %ld5 = load i32, ptr %pr.priv.0, align 4
  %add7 = add nsw i32 %ld5, %ld4
  store i32 %add7, ptr %pr.priv.0, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1000
  br i1 %exitcond.not, label %omp.inner.for.cond.DIR.OMP.END.SIMD.4.loopexit_crit_edge, label %omp.inner.for.body

omp.inner.for.cond.DIR.OMP.END.SIMD.4.loopexit_crit_edge:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:
  %ld6 = load i32, ptr %r.red, align 4
  %ld7 = load i32, ptr %r2.red, align 4
  %r = add i32 %ld6, %ld7
  ret i32 %r
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
