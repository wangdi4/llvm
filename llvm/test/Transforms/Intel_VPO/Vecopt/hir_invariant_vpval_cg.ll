; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-plain-cfg -print-after=hir-vplan-vec -vplan-force-vf=4 -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -vplan-print-after-plain-cfg -vplan-force-vf=4 -disable-output < %s 2>&1 | FileCheck %s

; LIT test to check VPValue based code generation for invariant canon expression
; and blob external defs. Loop being vectorized is the following:
;   for (i2 = 0; i2 < 100; i2++) {
;      arr[i1][n1 * n2 +  i2] = n1 * n2 + i1;
;   }
;
; Test checks that canon expression (n1 * n2 + i1) and blob (n1 * n2) are treated
; as external defs and that the generated code from VPValue based code generation
; for the same is correct.
; Auto generated checks that were not necessary were removed.

@arr = dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16

define dso_local void @foo(i64 %n1, i64 %n2) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after importing plain CFG
; CHECK-NEXT:  VPlan IR for: foo:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {(%n1 * %n2)<nsw>}
; CHECK-DAG:     [[VP1:%.*]] = {%i1}
; CHECK-DAG:     [[VP2:%.*]] = {@arr}
; CHECK-DAG:     [[VP3:%.*]] = {i1 + (%n1 * %n2)}
; CHECK-NEXT:  External Defs End:
; CHECK:          i64 [[VP4:%.*]] = phi  [ i64 0, {{.*}} ],  [ i64 [[VP5:%.*]], {{.*}} ]
; CHECK-NEXT:     i64 [[VP6:%.*]] = add i64 [[VP0]] i64 [[VP4]]
; CHECK-NEXT:     i64* [[VP7:%.*]] = subscript inbounds [100 x [100 x i64]]* @arr i64 0 i64 [[I10:%.*]] i64 [[VP6]]
; CHECK-NEXT:     store i64 [[VP3]] i64* [[VP7]]
;

; CHECK:        DO i2 = 0, 99, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; CHECK-NEXT:     (<4 x i64>*)(@arr)[0][i1][i2 + (%n1 * %n2)] = i1 + (%n1 * %n2);
; CHECK-NEXT:   END LOOP
;
entry:
  %mul = mul nsw i64 %n2, %n1
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.inc7, %entry
  %i1.020 = phi i64 [ 0, %entry ], [ %inc8, %for.inc7 ]
  %add = add nsw i64 %i1.020, %mul
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.cond1.preheader
  %i2.019 = phi i64 [ 0, %for.cond1.preheader ], [ %inc, %for.body3 ]
  %add5 = add nsw i64 %i2.019, %mul
  %arrayidx6 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @arr, i64 0, i64 %i1.020, i64 %add5
  store i64 %add, i64* %arrayidx6, align 8
  %inc = add nuw nsw i64 %i2.019, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.inc7, label %for.body3

for.inc7:                                         ; preds = %for.body3
  %inc8 = add nuw nsw i64 %i1.020, 1
  %exitcond21 = icmp eq i64 %inc8, 100
  br i1 %exitcond21, label %for.end9, label %for.cond1.preheader

for.end9:                                         ; preds = %for.inc7
  ret void
}
