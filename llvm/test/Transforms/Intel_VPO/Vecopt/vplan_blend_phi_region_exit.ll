; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2 -enable-vp-value-codegen=false | FileCheck %s
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2 -enable-vp-value-codegen=true  | FileCheck %s --check-prefix=CHECK-VPCG
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2 -enable-vp-value-codegen=false -disable-vplan-subregions -disable-vplan-loop-regions | FileCheck %s
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2 -enable-vp-value-codegen=true  -disable-vplan-subregions -disable-vplan-loop-regions | FileCheck %s --check-prefix=CHECK-VPCG

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

define dso_local void @foo(i64 *%a) local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %outer.preheader

outer.preheader:
  br label %outer.header

outer.header:
  %outer.iv = phi i64 [ %outer.iv.next, %outer.cont ], [ 0, %outer.preheader ]
  %arrayidx = getelementptr inbounds i64, i64* %a, i64 %outer.iv
  %ld = load i64, i64* %arrayidx
  %div.cmp = icmp eq i64 %ld, 42
  br i1 %div.cmp, label %inner.preheader, label %outer.cont

inner.preheader:
  br label %inner.header

inner.header:
  %inner.iv = phi i64 [ %inner.iv.next, %inner.header ], [ 0, %inner.preheader ]
  %inner.iv.next = add nuw nsw i64 %inner.iv, 1
  %exitcond = icmp eq i64 %inner.iv.next, 72
  br i1 %exitcond, label %inner.exit, label %inner.header

inner.exit:
  br label %outer.cont

; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[INDEX_NEXT:%.*]], [[VPLANNEDBB1:%.*]] ]
; CHECK-NEXT:    [[VEC_IND:%.*]] = phi <2 x i64> [ <i64 0, i64 1>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VPLANNEDBB1]] ]
; CHECK-NEXT:    [[SCALAR_GEP_:%.*]] = getelementptr inbounds i64, i64* [[A:%.*]], i64 [[INDEX]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i64* [[SCALAR_GEP_]] to <2 x i64>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i64>, <2 x i64>* [[TMP0]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i64> [[WIDE_LOAD]], <i64 42, i64 42>
; CHECK-NEXT:    br label [[VPLANNEDBB:%.*]]
; CHECK:       VPlannedBB:
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ [[TMP2:%.*]], [[VPLANNEDBB]] ], [ zeroinitializer, [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[TMP2]] = add nuw nsw <2 x i64> [[VEC_PHI]], <i64 1, i64 1>
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq <2 x i64> [[TMP2]], <i64 72, i64 72>
; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <2 x i1> [[TMP3]], i32 0
; CHECK-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB1]], label [[VPLANNEDBB]]
; CHECK:       VPlannedBB1:
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
; CHECK-NEXT:    [[PREDPHI2:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
;
;
; CHECK-VPCG-LABEL: @foo(
; CHECK-VPCG:       vector.body:
; CHECK-VPCG-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[INDEX_NEXT:%.*]], [[VPLANNEDBB2:%.*]] ]
; CHECK-VPCG-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ [[TMP7:%.*]], [[VPLANNEDBB2]] ], [ 0, [[VECTOR_PH]] ]
; CHECK-VPCG-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ [[TMP6:%.*]], [[VPLANNEDBB2]] ], [ <i64 0, i64 1>, [[VECTOR_PH]] ]
; CHECK-VPCG-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds i64, i64* [[A:%.*]], i64 [[UNI_PHI]]
; CHECK-VPCG-NEXT:    [[TMP0:%.*]] = bitcast i64* [[SCALAR_GEP]] to <2 x i64>*
; CHECK-VPCG-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i64>, <2 x i64>* [[TMP0]], align 8
; CHECK-VPCG-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i64> [[WIDE_LOAD]], <i64 42, i64 42>
; CHECK-VPCG-NEXT:    br label [[VPLANNEDBB:%.*]]
; CHECK-VPCG:       VPlannedBB:
; CHECK-VPCG-NEXT:    [[VEC_PHI1:%.*]] = phi <2 x i64> [ [[BROADCAST_SPLAT:%.*]], [[VPLANNEDBB]] ], [ zeroinitializer, [[VECTOR_BODY:%.*]] ]
; CHECK-VPCG-NEXT:    [[TMP2:%.*]] = extractelement <2 x i64> [[VEC_PHI1]], i32 0
; CHECK-VPCG-NEXT:    [[TMP3:%.*]] = add i64 [[TMP2]], 1
; CHECK-VPCG-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i64> undef, i64 [[TMP3]], i32 0
; CHECK-VPCG-NEXT:    [[BROADCAST_SPLAT]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT]], <2 x i64> undef, <2 x i32> zeroinitializer
; CHECK-VPCG-NEXT:    [[TMP4:%.*]] = icmp eq <2 x i64> [[BROADCAST_SPLAT]], <i64 72, i64 72>
; CHECK-VPCG-NEXT:    [[TMP5:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-VPCG-NEXT:    br i1 [[TMP5]], label [[VPLANNEDBB2]], label [[VPLANNEDBB]]
; CHECK-VPCG:       VPlannedBB2:
; CHECK-VPCG-NEXT:    [[PREDPHI:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
; CHECK-VPCG-NEXT:    [[PREDPHI3:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
;
outer.cont:
  ;; Verify that blend phi generation is correct no matter what operands order
  ;; in the phi is.
  %ph1 = phi i64 [ 2, %inner.exit ], [ 1, %outer.header ]
  %ph2 = phi i64 [ 1, %outer.header ], [ 2, %inner.exit ]
  %outer.iv.next = add nuw nsw i64 %outer.iv, 1
  %outer_exit_cond = icmp eq i64 %outer.iv.next, 442
  br i1 %outer_exit_cond, label %outer.loopexit, label %outer.header

outer.loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  br label %return

return:
  ret void
}
