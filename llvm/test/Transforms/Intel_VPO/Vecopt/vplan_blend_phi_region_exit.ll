; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S < %s -VPlanDriver -vplan-force-vf=2  | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

define dso_local void @foo(i64 *%a) local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %outer.preheader

outer.preheader:
  br label %outer.header

outer.header:
  %outer.iv = phi i64 [ %outer.iv.next, %outer.cont ], [ 0, %outer.preheader ]
  %arrayidx = getelementptr inbounds i64, i64* %a, i64 %outer.iv
  %ld = load i64, i64* %arrayidx
  %div.cmp = icmp eq i64 %ld, 42
  br i1 %div.cmp, label %inner.preheader, label %outer.cont

inner.preheader:
  br label %inner.header

inner.header:
  %inner.iv = phi i64 [ %inner.iv.next, %inner.header ], [ 0, %inner.preheader ]
  %inner.iv.next = add nuw nsw i64 %inner.iv, 1
  %exitcond = icmp eq i64 %inner.iv.next, 72
  br i1 %exitcond, label %inner.exit, label %inner.header

inner.exit:
  br label %outer.cont
; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[INDEX_NEXT:%.*]], [[VPLANNEDBB5:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[TMP11:%.*]], [[VPLANNEDBB5]] ]
; CHECK-NEXT:    [[UNI_PHI1:%.*]] = phi i64 [ [[TMP9:%.*]], [[VPLANNEDBB5]] ], [ 0, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ [[TMP8:%.*]], [[VPLANNEDBB5]] ], [ <i64 0, i64 1>, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds i64, i64* [[A:%.*]], i64 [[UNI_PHI1]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i64* [[SCALAR_GEP]] to <2 x i64>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i64>, <2 x i64>* [[TMP0]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i64> [[WIDE_LOAD]], <i64 42, i64 42>
; CHECK-NEXT:    br label [[VPLANNEDBB:%.*]]
; CHECK:       VPlannedBB:
; CHECK-NEXT:    [[UNI_PHI2:%.*]] = phi i64 [ [[TMP2:%.*]], [[VPLANNEDBB]] ], [ 0, [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[TMP2]] = add i64 [[UNI_PHI2]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i64> undef, i64 [[TMP2]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT]], <2 x i64> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq <2 x i64> [[BROADCAST_SPLAT]], <i64 72, i64 72>
; CHECK-NEXT:    [[DOTEXTRACT_0_:%.*]] = extractelement <2 x i1> [[TMP3]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = and <2 x i1> [[TMP1]], [[TMP1]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i1> [[TMP4]] to i2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i2 [[TMP5]], 0
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i1> undef, i1 [[TMP6]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT3]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[BROADCAST_SPLAT4_EXTRACT_0_:%.*]] = extractelement <2 x i1> [[BROADCAST_SPLAT4]], i32 0
; CHECK-NEXT:    [[TMP7:%.*]] = or i1 [[BROADCAST_SPLAT4_EXTRACT_0_]], [[DOTEXTRACT_0_]]
; CHECK-NEXT:    br i1 [[TMP7]], label [[VPLANNEDBB5]], label [[VPLANNEDBB]]
; CHECK:       VPlannedBB5:
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
; CHECK-NEXT:    [[PREDPHI6:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
;
outer.cont:
  ;; Verify that blend phi generation is correct no matter what operands order
  ;; in the phi is.
  %ph1 = phi i64 [ 2, %inner.exit ], [ 1, %outer.header ]
  %ph2 = phi i64 [ 1, %outer.header ], [ 2, %inner.exit ]
  %outer.iv.next = add nuw nsw i64 %outer.iv, 1
  %outer_exit_cond = icmp eq i64 %outer.iv.next, 442
  br i1 %outer_exit_cond, label %outer.loopexit, label %outer.header

outer.loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  br label %return

return:
  ret void
}
