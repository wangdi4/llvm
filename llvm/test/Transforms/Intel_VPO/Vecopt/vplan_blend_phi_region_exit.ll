; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S < %s -passes=vplan-vec -vplan-enable-all-zero-bypass-loops=false -vplan-force-vf=2  | FileCheck %s
; Loop bypasses are turned off because they do not affect what the test is designed to do.

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

define dso_local void @foo(ptr %a) local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %outer.preheader

outer.preheader:
  br label %outer.header

outer.header:
  %outer.iv = phi i64 [ %outer.iv.next, %outer.cont ], [ 0, %outer.preheader ]
  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %outer.iv
  %ld = load i64, ptr %arrayidx
  %div.cmp = icmp eq i64 %ld, 42
  br i1 %div.cmp, label %inner.preheader, label %outer.cont

inner.preheader:
  br label %inner.header

inner.header:
  %inner.iv = phi i64 [ %inner.iv.next, %inner.header ], [ 0, %inner.preheader ]
  %inner.iv.next = add nuw nsw i64 %inner.iv, 1
  %exitcond = icmp eq i64 %inner.iv.next, 72
  br i1 %exitcond, label %inner.exit, label %inner.header

inner.exit:
  br label %outer.cont
; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI3:%.*]] = phi i64 [ [[TMP9:%.*]], %[[VPLANNEDBB10:.*]] ], [ 0, [[VECTOR_PH:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ [[TMP8:%.*]], %[[VPLANNEDBB10]] ], [ <i64 0, i64 1>, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds i64, ptr [[A:%.*]], i64 [[UNI_PHI3]]
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i64>, ptr [[SCALAR_GEP]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i64> [[WIDE_LOAD]], <i64 42, i64 42>
; CHECK-NEXT:    br label %[[VPLANNEDBB4:.*]]
; CHECK:       [[VPLANNEDBB4]]:
; CHECK-NEXT:    br label %[[VPLANNEDBB5:.*]]
; CHECK:       [[VPLANNEDBB5]]:
; CHECK-NEXT:    [[UNI_PHI6:%.*]] = phi i64 [ [[TMP2:%.*]], %[[VPLANNEDBB5]] ], [ 0, %[[VPLANNEDBB4]] ]
; CHECK-NEXT:    [[TMP2]] = add i64 [[UNI_PHI6]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i64> poison, i64 [[TMP2]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT]], <2 x i64> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq <2 x i64> [[BROADCAST_SPLAT]], <i64 72, i64 72>
; CHECK-NEXT:    [[DOTEXTRACT_0_:%.*]] = extractelement <2 x i1> [[TMP3]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = and <2 x i1> [[TMP1]], [[TMP1]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i1> [[TMP4]] to i2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i2 [[TMP5]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = or i1 [[TMP6]], [[DOTEXTRACT_0_]]
; CHECK-NEXT:    br i1 [[TMP7]], label %[[VPLANNEDBB9:.*]], label %[[VPLANNEDBB5]]
; CHECK:       [[VPLANNEDBB9]]:
; CHECK-NEXT:    br label %[[VPLANNEDBB10]]
; CHECK:       [[VPLANNEDBB10]]:
; CHECK-NEXT:    [[PREDBLEND:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
; CHECK-NEXT:    [[PREDBLEND11:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> <i64 2, i64 2>, <2 x i64> <i64 1, i64 1>
outer.cont:
  ;; Verify that blend phi generation is correct no matter what operands order
  ;; in the phi is.
  %ph1 = phi i64 [ 2, %inner.exit ], [ 1, %outer.header ]
  %ph2 = phi i64 [ 1, %outer.header ], [ 2, %inner.exit ]
  %outer.iv.next = add nuw nsw i64 %outer.iv, 1
  %outer_exit_cond = icmp eq i64 %outer.iv.next, 442
  br i1 %outer_exit_cond, label %outer.loopexit, label %outer.header

outer.loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  br label %return

return:
  ret void
}
