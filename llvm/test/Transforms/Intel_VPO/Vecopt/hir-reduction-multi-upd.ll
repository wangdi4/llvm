; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; RUN: opt -disable-output -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -print-after=hir-vplan-vec -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-print-legality %s 2>&1 | FileCheck %s
; RUN: opt -disable-output -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -print-after=hir-vplan-vec -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-print-legality  %s 2>&1 | FileCheck %s
;
; Test to check that we don't choke on reduction with mulitple updates
; in HIR path.
; Incoming HIR
; BEGIN REGION { }
;       %0 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD(),  QUAL.OMP.SIMDLEN(4),  QUAL.OMP.REDUCTION.ADD(&((%ret.red)[0])),  QUAL.OMP.LINEAR:IV(&((%i.linear.iv)[0])1),  QUAL.OMP.NORMALIZED.IV(null),  QUAL.OMP.NORMALIZED.UB(null) ]
;       %ret.red.promoted = (%ret.red)[0];
;       %1 = %ret.red.promoted;
;       + DO i1 = 0, %n + -1, 1   <DO_LOOP> <simd>
;       |   %2 = (%ub)[i1];
;       |   if (%2 > 42)
;       |   {
;       |      %1 = %1  +  %2;
;       |      (%ub)[i1] = %2 + 5;
;       |   }
;       |   else
;       |   {
;       |      if (%2 < 10)
;       |      {
;       |         %1 = %1  +  -10;
;       |         (%ub)[i1] = 0;
;       |      }
;       |      else
;       |      {
;       |         %3 = (%ub)[i1 + -1];
;       |         %1 = %1  +  %3;
;       |      }
;       |   }
;       + END LOOP
;       (%i.linear.iv)[0] = %n;
;       (%ret.red)[0] = %1;
;       @llvm.directive.region.exit(%0); [ DIR.OMP.END.SIMD() ]
; END REGION

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nounwind uwtable
define dso_local i64 @foo(i64 noundef %n, i64* nocapture noundef %ub) local_unnamed_addr #0 {
; CHECK-LABEL:  HIRLegality Descriptor Lists
; CHECK:       HIRLegality ReductionList:
; CHECK-NEXT:  Ref: &(([[RET_RED0:%.*]])[0])
; CHECK-NEXT:    UpdateInstructions:
; CHECK-NEXT:    none
; CHECK-EMPTY:
; CHECK-NEXT:    AliasRef: [[RET_RED_PROMOTED0:%.*]]
; CHECK-NEXT:    UpdateInstructions:
; CHECK-NEXT:    none
; CHECK-EMPTY:
; CHECK-NEXT:    AliasRef: [[TMP1:%.*]]
; CHECK-NEXT:    UpdateInstructions:
; CHECK-NEXT:    [[TMP1:%.*]] = [[TMP1]]  +  [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP1]] = [[TMP1]]  +  -10
; CHECK-NEXT:    [[TMP1]] = [[TMP1]]  +  [[TMP3:%.*]]
; CHECK-NEXT:      InitValue: [[TMP1]]
;
; CHECK:       VPlan after insertion of VPEntities instructions:
; CHECK:       VPlan IR for: foo:HIR.#{{[0-9]+}}
; CHECK:       Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK:       Reduction list
; CHECK-NEXT:   (+) Start: i64 [[TMP1]] Exit: i64 [[VP3:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP4:%.*]], i64 [[VP3]], i64 [[VP_RED_INIT:%.*]], i64 [[VP_RED_FINAL:%.*]],
;
; CHECK:          i64 [[VP_RED_INIT]] = reduction-init i64 0 i64 [[TMP1]]
;
; CHECK:          i64 [[VP4:%.*]] = phi  [ i64 [[VP_RED_INIT]], [[BB2:BB[0-9]+]] ],  [ i64 [[VP3]], [[BB3:BB[0-9]+]] ]
; CHECK:          i64 [[VP11:%.*]] = add i64 [[VP4]] i64 [[VP_LOAD_1:%.*]]
; CHECK:          i64 [[VP12:%.*]] = add i64 [[VP4]] i64 -10
; CHECK:          i64 [[VP13:%.*]] = add i64 [[VP4]] i64 [[VP_LOAD:%.*]]
; CHECK:          i64 [[VP3]] = phi  [ i64 [[VP13]], [[BB4:BB[0-9]+]] ],  [ i64 [[VP12]], [[BB6:BB[0-9]+]] ],  [ i64 [[VP11]], [[BB7:BB[0-9]+]] ]
;
; CHECK:          i64 [[VP_RED_FINAL]] = reduction-final{u_add} i64 [[VP3]]
;
; CHECK:   + DO i1 = 0, [[LOOP_UB0:%.*]], 4   <DO_LOOP> <simd-vectorized> <nounroll> <novectorize>
;
entry:
  %ret.red = alloca i64, align 8
  %i.linear.iv = alloca i64, align 8
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %entry
  store i64 0, i64* %ret.red, align 8
  br label %DIR.OMP.SIMD.146

DIR.OMP.SIMD.146:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4), "QUAL.OMP.REDUCTION.ADD"(i64* %ret.red), "QUAL.OMP.LINEAR:IV"(i64* %i.linear.iv, i32 1), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  br label %DIR.OMP.SIMD.2

DIR.OMP.SIMD.2:                                   ; preds = %DIR.OMP.SIMD.146
  %ret.red.promoted = load i64, i64* %ret.red, align 8
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %DIR.OMP.SIMD.2, %omp.inner.for.inc
  %1 = phi i64 [ %ret.red.promoted, %DIR.OMP.SIMD.2 ], [ %4, %omp.inner.for.inc ]
  %.omp.iv.local.037 = phi i64 [ 0, %DIR.OMP.SIMD.2 ], [ %add20, %omp.inner.for.inc ]
  %arrayidx = getelementptr inbounds i64, i64* %ub, i64 %.omp.iv.local.037
  %2 = load i64, i64* %arrayidx, align 8
  %cmp5 = icmp sgt i64 %2, 42
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %omp.inner.for.body
  %add7 = add nsw i64 %1, %2
  %add9 = add nuw nsw i64 %2, 5
  store i64 %add9, i64* %arrayidx, align 8
  br label %omp.inner.for.inc

if.else:                                          ; preds = %omp.inner.for.body
  %cmp11 = icmp slt i64 %2, 10
  br i1 %cmp11, label %if.then12, label %if.else15

if.then12:                                        ; preds = %if.else
  %sub13 = add nsw i64 %1, -10
  store i64 0, i64* %arrayidx, align 8
  br label %omp.inner.for.inc

if.else15:                                        ; preds = %if.else
  %sub16 = add nsw i64 %.omp.iv.local.037, -1
  %arrayidx17 = getelementptr inbounds i64, i64* %ub, i64 %sub16
  %3 = load i64, i64* %arrayidx17, align 8
  %add18 = add nsw i64 %1, %3
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %if.then12, %if.else15, %if.then
  %4 = phi i64 [ %sub13, %if.then12 ], [ %add18, %if.else15 ], [ %add7, %if.then ]
  %add20 = add nuw nsw i64 %.omp.iv.local.037, 1
  %exitcond.not = icmp eq i64 %add20, %n
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %omp.inner.for.inc
  %.lcssa = phi i64 [ %4, %omp.inner.for.inc ]
  store i64 %n, i64* %i.linear.iv, align 8
  store i64 %.lcssa, i64* %ret.red, align 8
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %DIR.OMP.END.SIMD.2
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:
  ret i64 %.lcssa
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #0 = { nounwind "unsafe-fp-math"="true" }
attributes #1 = { nounwind }


