; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to verify correctness of the PHI node fixing algorithm for a slightly
; complex HCFG with two variables. The incoming value for a PHI node is not
; necessarily defined in the predecessor VPBB, but the value rather flows in
; from another predecessor in the control flow.

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -vplan-print-plain-cfg -vplan-dump-external-defs-hir=0 -S -disable-output -print-after=VPlanDriverHIR < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,vplan-driver-hir,print<hir>"  -vplan-print-plain-cfg -vplan-dump-external-defs-hir=0 -S -disable-output < %s 2>&1 | FileCheck %s

; Input HIR
; <73>    + DO i1 = 0, 1023, 1   <DO_LOOP>
; <8>     |   %t2.069.out3 = %t2.069;
; <10>    |   %1 = (@a)[0][i1];
; <14>    |   if (i1 > %1)
; <14>    |   {
; <25>    |      if (%1 > 1023)
; <25>    |      {
; <37>    |         %t2.1 = %t2.069.out3;
; <38>    |         %t1.0 = 2 * %1;
; <25>    |      }
; <25>    |      else
; <25>    |      {
; <31>    |         %4 = (@a)[0][i1 + 134];
; <32>    |         %t2.1 = %4;
; <33>    |         %t1.0 = %1;
; <25>    |      }
; <42>    |      %t2.069 = %t2.1 + 1024;
; <43>    |      %t1.1 = %t1.0;
; <14>    |   }
; <14>    |   else
; <14>    |   {
; <20>    |      %6 = (@a)[0][i1 + 1];
; <21>    |      %t1.1 = %6;
; <14>    |   }
; <46>    |   %t2.069.out = %t2.069;
; <48>    |   (@b)[0][i1] = %t1.1;
; <51>    |   (@c)[0][i1] = %t1.1 + 2 * %N;
; <53>    |   %7 = (@d)[0][i1];
; <57>    |   %spec.select = (i1 > %t1.1 + 2 * %N + %7) ? %t1.1 : %7;
; <58>    |   (@d)[0][i1] = %spec.select;
; <73>    + END LOOP

; Here PHI nodes are inserted at multiple VPBBs for %t1.0, %t2.1 and %t2.069.
; The PHI placed at loop latch VPBB for %t2.069 is of interest for us. The
; incoming value for this PHI node does not directly come the predecessor BB9
; (outer else), but rather from BB4 which precedes BB9.

; ******* NOTE *******
; The loop is not a valid SIMD loop. VPlan snippet after linearization:
;  BB2:
;   [DA: Div] i64 %vp56304 = induction-init{add} i64 0 i64 1
;   [DA: Uni] i64 %vp56528 = induction-init-step{add} i64 1
;  SUCCESSORS(1):BB3
;  PREDECESSORS(1): BB1
;
;  BB3:
;   [DA: Div] i32 %vp24032 = phi  [ i32 %t2.069, BB2 ],  [ i32 %vp23200, BB9 ]
;   [DA: Div] i64 %vp45280 = phi  [ i64 %vp56304, BB2 ],  [ i64 %vp40752, BB9 ]
;
; As can be seen, %vp24032 is not an induction or a reduction. We silently
; generate bad code but we recently started generating code for all
; PHIs that are not inductions/reductions and we expect them to be
; deconstructed. Until we decide how to handle such invalid SIMD loops, we
; now bail out during code generation.
; ******* NOTE *******

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@b = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@c = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@d = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

; Function Attrs: nounwind uwtable
define dso_local i32 @foo(i32 %N) local_unnamed_addr {
; Check the plain CFG structure and correctness of incoming values of PHI nodes
; CHECK-LABEL:  VPlan after importing plain CFG
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     i32 [[VP0:%.*]] = phi  [ i32 [[T2_0690:%.*]], [[BB1]] ],  [ i32 [[VP1:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32 [[VP4:%.*]] = hir-copy i32 [[VP0]] , OriginPhiId: -1
; CHECK-NEXT:     i32* [[VP5:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP2]]
; CHECK-NEXT:     i32 [[VP6:%.*]] = load i32* [[VP5]]
; CHECK-NEXT:     i64 [[VP7:%.*]] = sext i32 [[VP6]] to i64
; CHECK-NEXT:     i1 [[VP8:%.*]] = icmp sgt i64 [[VP2]] i64 [[VP7]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB4:BB[0-9]+]](i1 [[VP8]]), [[BB5:BB[0-9]+]](!i1 [[VP8]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]:
; CHECK-NEXT:       i64 [[VP9:%.*]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:       i32* [[VP10:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP9]]
; CHECK-NEXT:       i32 [[VP11:%.*]] = load i32* [[VP10]]
; CHECK-NEXT:       i32 [[VP12:%.*]] = hir-copy i32 [[VP11]] , OriginPhiId: -1
; CHECK-NEXT:      SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       i1 [[VP13:%.*]] = icmp sgt i32 [[VP6]] i32 1023
; CHECK-NEXT:      SUCCESSORS(2):[[BB6:BB[0-9]+]](i1 [[VP13]]), [[BB7:BB[0-9]+]](!i1 [[VP13]])
; CHECK-NEXT:      PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB7]]:
; CHECK-NEXT:         i64 [[VP14:%.*]] = add i64 [[VP2]] i64 134
; CHECK-NEXT:         i32* [[VP15:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP14]]
; CHECK-NEXT:         i32 [[VP16:%.*]] = load i32* [[VP15]]
; CHECK-NEXT:         i32 [[VP17:%.*]] = hir-copy i32 [[VP16]] , OriginPhiId: -1
; CHECK-NEXT:         i32 [[VP18:%.*]] = hir-copy i32 [[VP6]] , OriginPhiId: -1
; CHECK-NEXT:        SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB6]]:
; CHECK-NEXT:         i32 [[VP19:%.*]] = hir-copy i32 [[VP4]] , OriginPhiId: -1
; CHECK-NEXT:         i32 [[VP20:%.*]] = mul i32 [[VP6]] i32 2
; CHECK-NEXT:         i32 [[VP21:%.*]] = hir-copy i32 [[VP20]] , OriginPhiId: -1
; CHECK-NEXT:        SUCCESSORS(1):[[BB8]]
; CHECK-NEXT:        PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]:
; CHECK-NEXT:       i32 [[VP22:%.*]] = phi  [ i32 [[VP21]], [[BB6]] ],  [ i32 [[VP18]], [[BB7]] ]
; CHECK-NEXT:       i32 [[VP23:%.*]] = phi  [ i32 [[VP19]], [[BB6]] ],  [ i32 [[VP17]], [[BB7]] ]
; CHECK-NEXT:       i32 [[VP24:%.*]] = add i32 [[VP23]] i32 1024
; CHECK-NEXT:       i32 [[VP25:%.*]] = hir-copy i32 [[VP24]] , OriginPhiId: -1
; CHECK-NEXT:       i32 [[VP26:%.*]] = hir-copy i32 [[VP22]] , OriginPhiId: -1
; CHECK-NEXT:      SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:      PREDECESSORS(2): [[BB6]] [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     i32 [[VP27:%.*]] = phi  [ i32 [[VP26]], [[BB8]] ],  [ i32 [[VP12]], [[BB5]] ]
; CHECK-NEXT:     i32 [[VP1]] = phi  [ i32 [[VP25]], [[BB8]] ],  [ i32 [[VP0]], [[BB5]] ]
; CHECK-NEXT:     i32 [[VP28:%.*]] = hir-copy i32 [[VP1]] , OriginPhiId: -1
; CHECK-NEXT:     i32* [[VP29:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP2]]
; CHECK-NEXT:     store i32 [[VP27]] i32* [[VP29]]
; CHECK-NEXT:     i32 [[VP30:%.*]] = mul i32 [[N0:%.*]] i32 2
; CHECK-NEXT:     i32 [[VP31:%.*]] = add i32 [[VP27]] i32 [[VP30]]
; CHECK-NEXT:     i32* [[VP32:%.*]] = subscript inbounds [1024 x i32]* @c i64 0 i64 [[VP2]]
; CHECK-NEXT:     store i32 [[VP31]] i32* [[VP32]]
; CHECK-NEXT:     i32* [[VP33:%.*]] = subscript inbounds [1024 x i32]* @d i64 0 i64 [[VP2]]
; CHECK-NEXT:     i32 [[VP34:%.*]] = load i32* [[VP33]]
; CHECK-NEXT:     i32 [[VP35:%.*]] = mul i32 [[N0]] i32 2
; CHECK-NEXT:     i32 [[VP36:%.*]] = add i32 [[VP27]] i32 [[VP35]]
; CHECK-NEXT:     i32 [[VP37:%.*]] = add i32 [[VP36]] i32 [[VP34]]
; CHECK-NEXT:     i64 [[VP38:%.*]] = sext i32 [[VP37]] to i64
; CHECK-NEXT:     i1 [[VP39:%.*]] = icmp sgt i64 [[VP2]] i64 [[VP38]]
; CHECK-NEXT:     i32 [[VP40:%.*]] = select i1 [[VP39]] i32 [[VP27]] i32 [[VP34]]
; CHECK-NEXT:     i32* [[VP41:%.*]] = subscript inbounds [1024 x i32]* @d i64 0 i64 [[VP2]]
; CHECK-NEXT:     store i32 [[VP40]] i32* [[VP41]]
; CHECK-NEXT:     i64 [[VP3]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i1 [[VP42:%.*]] = icmp sle i64 [[VP3]] i64 1023
; CHECK-NEXT:    SUCCESSORS(2):[[BB2]](i1 [[VP42]]), [[BB9:BB[0-9]+]](!i1 [[VP42]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB8]] [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB10:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
;
; Check that the loop is not vectorized.
; CHECK:  DO i1 = 0, 1023, 1   <DO_LOOP>
omp.inner.for.body.lr.ph:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  %mul23 = shl nsw i32 %N, 1
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %if.end20, %omp.inner.for.body.lr.ph
  %indvars.iv = phi i64 [ %.pre, %if.end20 ], [ 0, %omp.inner.for.body.lr.ph ]
  %t2.069 = phi i32 [ %t2.2, %if.end20 ], [ undef, %omp.inner.for.body.lr.ph ]
  %arrayidx = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %2 = sext i32 %1 to i64
  %cmp2 = icmp sgt i64 %indvars.iv, %2
  %.pre = add nuw nsw i64 %indvars.iv, 1
  br i1 %cmp2, label %if.then, label %if.else16

if.then:                                          ; preds = %omp.inner.for.body
  %cmp7 = icmp sgt i32 %1, 1023
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %add11 = shl nsw i32 %1, 1
  br label %if.end

if.else:                                          ; preds = %if.then
  %3 = add nuw nsw i64 %indvars.iv, 134
  %arrayidx14 = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %3, !intel-tbaa !2
  %4 = load i32, i32* %arrayidx14, align 4, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  %t2.1 = phi i32 [ %t2.069, %if.then8 ], [ %4, %if.else ]
  %t1.0 = phi i32 [ %add11, %if.then8 ], [ %1, %if.else ]
  %add15 = add nsw i32 %t2.1, 1024
  br label %if.end20

if.else16:                                        ; preds = %omp.inner.for.body
  %5 = add nuw nsw i64 %indvars.iv, 0
  %arrayidx19 = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %.pre, !intel-tbaa !2
  %6 = load i32, i32* %arrayidx19, align 4, !tbaa !2
  br label %if.end20

if.end20:                                         ; preds = %if.else16, %if.end
  %t2.2 = phi i32 [ %t2.069, %if.else16 ], [ %add15, %if.end ]
  %t1.1 = phi i32 [ %6, %if.else16 ], [ %t1.0, %if.end ]
  %arrayidx22 = getelementptr inbounds [1024 x i32], [1024 x i32]* @b, i64 0, i64 %indvars.iv, !intel-tbaa !2
  store i32 %t1.1, i32* %arrayidx22, align 4, !tbaa !2
  %add24 = add nsw i32 %t1.1, %mul23
  %arrayidx26 = getelementptr inbounds [1024 x i32], [1024 x i32]* @c, i64 0, i64 %indvars.iv, !intel-tbaa !2
  store i32 %add24, i32* %arrayidx26, align 4, !tbaa !2
  %arrayidx30 = getelementptr inbounds [1024 x i32], [1024 x i32]* @d, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %7 = load i32, i32* %arrayidx30, align 4, !tbaa !2
  %add31 = add nsw i32 %7, %add24
  %8 = sext i32 %add31 to i64
  %cmp32 = icmp sgt i64 %indvars.iv, %8
  %spec.select = select i1 %cmp32, i32 %t1.1, i32 %7
  store i32 %spec.select, i32* %arrayidx30, align 4, !tbaa !2
  %exitcond = icmp eq i64 %.pre, 1024
  br i1 %exitcond, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %if.end20
  %t2.2.lcssa = phi i32 [ %t2.2, %if.end20 ]
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  %9 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @b, i64 0, i64 0), align 16, !tbaa !2
  %10 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @c, i64 0, i64 0), align 16, !tbaa !2
  %11 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @d, i64 0, i64 0), align 16, !tbaa !2
  %add40 = add i32 %9, %t2.2.lcssa
  %add41 = add i32 %add40, %10
  %add42 = add i32 %add41, %11
  ret i32 %add42
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }


!2 = !{!3, !4, i64 0}
!3 = !{!"array@_ZTSA1024_i", !4, i64 0}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
