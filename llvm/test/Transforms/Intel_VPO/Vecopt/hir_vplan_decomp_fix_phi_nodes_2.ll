; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to verify correctness of the PHI node fixing algorithm for a slightly
; complex HCFG with two variables. The incoming value for a PHI node is not
; necessarily defined in the predecessor VPBB, but the value rather flows in
; from another predecessor in the control flow.

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-plain-cfg -vplan-dump-external-defs-hir=0 -S -disable-output -print-after=hir-vplan-vec < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>"  -vplan-print-after-plain-cfg -vplan-dump-external-defs-hir=0 -S -disable-output < %s 2>&1 | FileCheck %s

; Input HIR
; <70>    + DO i1 = 0, 1023, 1   <DO_LOOP> <simd>
; <9>     |   %1 = (@a)[0][i1];
; <13>    |   if (i1 > %1)
; <13>    |   {
; <18>    |      if (%1 > 1023)
; <18>    |      {
; <23>    |         %t1.0 = 2 * %1;
; <18>    |      }
; <18>    |      else
; <18>    |      {
; <28>    |         %4 = (@a)[0][i1 + 134];
; <29>    |         %t2.069 = %4;
; <30>    |         %t1.0 = %1;
; <18>    |      }
; <33>    |      %t2.069 = %t2.069  +  1024;
; <34>    |      %t1.1 = %t1.0;
; <13>    |   }
; <13>    |   else
; <13>    |   {
; <39>    |      %6 = (@a)[0][i1 + 1];
; <40>    |      %t1.1 = %6;
; <13>    |   }
; <43>    |   %t2.069.out = %t2.069;
; <45>    |   (@b)[0][i1] = %t1.1;
; <48>    |   (@c)[0][i1] = %t1.1 + 2 * %N;
; <50>    |   %7 = (@d)[0][i1];
; <54>    |   %spec.select = (i1 > %t1.1 + 2 * %N + %7) ? %t1.1 : %7;
; <55>    |   (@d)[0][i1] = %spec.select;
; <70>    + END LOOP

; Here PHI nodes are inserted at multiple VPBBs for %t1.0, %t2.1 and %t2.069.
; The PHI placed at loop latch VPBB for %t2.069 is of interest for us. The
; incoming value for this PHI node does not directly come the predecessor BB9
; (outer else), but rather from BB4 which precedes BB9.

; ******* NOTE *******
; The loop is not a valid SIMD loop. VPlan snippet after linearization:
;  BB2:
;   [DA: Div] i64 %vp56304 = induction-init{add} i64 0 i64 1
;   [DA: Uni] i64 %vp56528 = induction-init-step{add} i64 1
;  SUCCESSORS(1):BB3
;  PREDECESSORS(1): BB1
;
;  BB3:
;   [DA: Div] i32 %vp24032 = phi  [ i32 %t2.069, BB2 ],  [ i32 %vp23200, BB9 ]
;   [DA: Div] i64 %vp45280 = phi  [ i64 %vp56304, BB2 ],  [ i64 %vp40752, BB9 ]
;
; As can be seen, %vp24032 is not an induction or a reduction. We silently
; generate bad code but we recently started generating code for all
; PHIs that are not inductions/reductions and we expect them to be
; deconstructed. Until we decide how to handle such invalid SIMD loops, we
; now bail out during code generation.
; ******* NOTE *******

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@b = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@c = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@d = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

; Function Attrs: nounwind uwtable
define dso_local i32 @foo(i32 %N) local_unnamed_addr {
; Check the plain CFG structure and correctness of incoming values of PHI nodes
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: foo:HIR.#{{[0-9]+}}
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i32 [[VP0:%.*]] = phi  [ i32 [[T2_0690:%.*]], [[BB1]] ],  [ i32 [[VP1:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP2]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP4:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i1 [[VP5:%.*]] = icmp sgt i64 [[VP2]] i64 [[VP4]]
; CHECK-NEXT:     br i1 [[VP5]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:       i64 [[VP6:%.*]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP6]]
; CHECK-NEXT:       i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:       i32 [[VP7:%.*]] = hir-copy i32 [[VP_LOAD_1]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       i1 [[VP8:%.*]] = icmp sgt i32 [[VP_LOAD]] i32 1023
; CHECK-NEXT:       br i1 [[VP8]], [[BB6:BB[0-9]+]], [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB7]]: # preds: [[BB4]]
; CHECK-NEXT:         i64 [[VP9:%.*]] = add i64 [[VP2]] i64 134
; CHECK-NEXT:         i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP9]]
; CHECK-NEXT:         i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:         i32 [[VP10:%.*]] = hir-copy i32 [[VP_LOAD_2]] , OriginPhiId: -1
; CHECK-NEXT:         i32 [[VP11:%.*]] = hir-copy i32 [[VP_LOAD]] , OriginPhiId: -1
; CHECK-NEXT:         br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB6]]: # preds: [[BB4]]
; CHECK-NEXT:         i32 [[VP12:%.*]] = mul i32 [[VP_LOAD]] i32 2
; CHECK-NEXT:         i32 [[VP13:%.*]] = hir-copy i32 [[VP12]] , OriginPhiId: -1
; CHECK-NEXT:         br [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[BB6]], [[BB7]]
; CHECK-NEXT:       i32 [[VP14:%.*]] = phi  [ i32 [[VP13]], [[BB6]] ],  [ i32 [[VP11]], [[BB7]] ]
; CHECK-NEXT:       i32 [[VP15:%.*]] = phi  [ i32 [[VP0]], [[BB6]] ],  [ i32 [[VP10]], [[BB7]] ]
; CHECK-NEXT:       i32 [[VP16:%.*]] = add i32 [[VP15]] i32 1024
; CHECK-NEXT:       i32 [[VP17:%.*]] = hir-copy i32 [[VP14]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB8]], [[BB5]]
; CHECK-NEXT:     i32 [[VP18:%.*]] = phi  [ i32 [[VP17]], [[BB8]] ],  [ i32 [[VP7]], [[BB5]] ]
; CHECK-NEXT:     i32 [[VP1]] = phi  [ i32 [[VP16]], [[BB8]] ],  [ i32 [[VP0]], [[BB5]] ]
; CHECK-NEXT:     i32 [[VP19:%.*]] = hir-copy i32 [[VP1]] , OriginPhiId: -1
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP2]]
; CHECK-NEXT:     store i32 [[VP18]] i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i32 [[VP20:%.*]] = mul i32 [[N0:%.*]] i32 2
; CHECK-NEXT:     i32 [[VP21:%.*]] = add i32 [[VP18]] i32 [[VP20]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [1024 x i32]* @c i64 0 i64 [[VP2]]
; CHECK-NEXT:     store i32 [[VP21]] i32* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds [1024 x i32]* @d i64 0 i64 [[VP2]]
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load i32* [[VP_SUBSCRIPT_5]]
; CHECK-NEXT:     i32 [[VP24:%.*]] = add i32 [[VP21]] i32 [[VP_LOAD_3]]
; CHECK-NEXT:     i64 [[VP25:%.*]] = sext i32 [[VP24]] to i64
; CHECK-NEXT:     i1 [[VP26:%.*]] = icmp sgt i64 [[VP2]] i64 [[VP25]]
; CHECK-NEXT:     i32 [[VP27:%.*]] = select i1 [[VP26]] i32 [[VP18]] i32 [[VP_LOAD_3]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_6:%.*]] = subscript inbounds [1024 x i32]* @d i64 0 i64 [[VP2]]
; CHECK-NEXT:     store i32 [[VP27]] i32* [[VP_SUBSCRIPT_6]]
; CHECK-NEXT:     i64 [[VP3]] = add i64 [[VP2]] i64 1
; CHECK-NEXT:     i1 [[VP28:%.*]] = icmp slt i64 [[VP3]] i64 1024
; CHECK-NEXT:     br i1 [[VP28]], [[BB2]], [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     br <External Block>
;
; Check that the loop is not vectorized.
; CHECK:  DO i1 = 0, 1023, 1   <DO_LOOP>
omp.inner.for.body.lr.ph:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  %mul23 = shl nsw i32 %N, 1
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %if.end20, %omp.inner.for.body.lr.ph
  %indvars.iv = phi i64 [ %.pre, %if.end20 ], [ 0, %omp.inner.for.body.lr.ph ]
  %t2.069 = phi i32 [ %t2.2, %if.end20 ], [ undef, %omp.inner.for.body.lr.ph ]
  %arrayidx = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %2 = sext i32 %1 to i64
  %cmp2 = icmp sgt i64 %indvars.iv, %2
  %.pre = add nuw nsw i64 %indvars.iv, 1
  br i1 %cmp2, label %if.then, label %if.else16

if.then:                                          ; preds = %omp.inner.for.body
  %cmp7 = icmp sgt i32 %1, 1023
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %add11 = shl nsw i32 %1, 1
  br label %if.end

if.else:                                          ; preds = %if.then
  %3 = add nuw nsw i64 %indvars.iv, 134
  %arrayidx14 = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %3, !intel-tbaa !2
  %4 = load i32, i32* %arrayidx14, align 4, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  %t2.1 = phi i32 [ %t2.069, %if.then8 ], [ %4, %if.else ]
  %t1.0 = phi i32 [ %add11, %if.then8 ], [ %1, %if.else ]
  %add15 = add nsw i32 %t2.1, 1024
  br label %if.end20

if.else16:                                        ; preds = %omp.inner.for.body
  %5 = add nuw nsw i64 %indvars.iv, 0
  %arrayidx19 = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %.pre, !intel-tbaa !2
  %6 = load i32, i32* %arrayidx19, align 4, !tbaa !2
  br label %if.end20

if.end20:                                         ; preds = %if.else16, %if.end
  %t2.2 = phi i32 [ %t2.069, %if.else16 ], [ %add15, %if.end ]
  %t1.1 = phi i32 [ %6, %if.else16 ], [ %t1.0, %if.end ]
  %arrayidx22 = getelementptr inbounds [1024 x i32], [1024 x i32]* @b, i64 0, i64 %indvars.iv, !intel-tbaa !2
  store i32 %t1.1, i32* %arrayidx22, align 4, !tbaa !2
  %add24 = add nsw i32 %t1.1, %mul23
  %arrayidx26 = getelementptr inbounds [1024 x i32], [1024 x i32]* @c, i64 0, i64 %indvars.iv, !intel-tbaa !2
  store i32 %add24, i32* %arrayidx26, align 4, !tbaa !2
  %arrayidx30 = getelementptr inbounds [1024 x i32], [1024 x i32]* @d, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %7 = load i32, i32* %arrayidx30, align 4, !tbaa !2
  %add31 = add nsw i32 %7, %add24
  %8 = sext i32 %add31 to i64
  %cmp32 = icmp sgt i64 %indvars.iv, %8
  %spec.select = select i1 %cmp32, i32 %t1.1, i32 %7
  store i32 %spec.select, i32* %arrayidx30, align 4, !tbaa !2
  %exitcond = icmp eq i64 %.pre, 1024
  br i1 %exitcond, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %if.end20
  %t2.2.lcssa = phi i32 [ %t2.2, %if.end20 ]
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  %9 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @b, i64 0, i64 0), align 16, !tbaa !2
  %10 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @c, i64 0, i64 0), align 16, !tbaa !2
  %11 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @d, i64 0, i64 0), align 16, !tbaa !2
  %add40 = add i32 %9, %t2.2.lcssa
  %add41 = add i32 %add40, %10
  %add42 = add i32 %add41, %11
  ret i32 %add42
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }


!2 = !{!3, !4, i64 0}
!3 = !{!"array@_ZTSA1024_i", !4, i64 0}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
