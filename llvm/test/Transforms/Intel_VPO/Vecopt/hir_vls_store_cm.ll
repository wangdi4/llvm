; INTEL_FEATURE_SW_ADVANCED
; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: intel_feature_sw_advanced
; NOTE: CM dump goes to stdout and HIR dump goes to stderr. Trying to use one
; RUN command line garbles up output causing checks to fail.
;
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -vplan-cost-model-print-analysis-for-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s --check-prefix=CMCHECK
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -print-after=hir-vplan-vec -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s --check-prefix=HIRCHECK
; RUN: opt -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec' -vplan-force-vf=4 -vplan-cost-model-print-analysis-for-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s --check-prefix=CMCHECK
; RUN: opt -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>' -vplan-force-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s --check-prefix=HIRCHECK
;
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -vplan-cost-model-print-analysis-for-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s --check-prefix=CMCHECK
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -print-after=hir-vplan-vec -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s --check-prefix=HIRCHECK
; RUN: opt -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec' -vplan-force-vf=4 -vplan-cost-model-print-analysis-for-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s --check-prefix=CMCHECK
; RUN: opt -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>' -vplan-force-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s --check-prefix=HIRCHECK
;
; Test to demonstrate issue with VLS group cost being applied twice to stores in
; the group. This happens the first time when we see a new store group. The
; second time this happens is when the instruction corresponding to the group
; insertion point is seen. Subsequent changes fix this to apply the group cost
; only when the instruction corresponding to insertion point is seen.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nofree norecurse nounwind uwtable writeonly
define dso_local void @foo(i64* nocapture %arr) local_unnamed_addr #0 {
; CMCHECK-LABEL:  Cost Model for VPlan foo:HIR.#{{[0-9]+}} with VF = 4:
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CMCHECK-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB0]]: base cost: 0
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 100, UF = 1
; CMCHECK-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; CMCHECK-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CMCHECK-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB1]]: base cost: 0
; CMCHECK-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 4 resulted Cost = 0
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB2]] ]
; CMCHECK-NEXT:    Cost 12 for i64 [[VP2:%.*]] = mul i64 2 i64 [[VP0]]
; CMCHECK-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i64* [[ARR0:%.*]] i64 [[VP2]]
; CMCHECK-NEXT:    Cost 12 for store i64 [[VP0]] i64* [[VP_SUBSCRIPT]] *OVLS*(-12) AdjCost: 0
; CMCHECK-NEXT:    Cost 2 for i64 [[VP3:%.*]] = add i64 [[VP0]] i64 1
; CMCHECK-NEXT:    Cost 2 for i64 [[VP5:%.*]] = add i64 [[VP2]] i64 1
; CMCHECK-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i64* [[ARR0]] i64 [[VP5]]
; CMCHECK-NEXT:    Cost 12 for store i64 [[VP3]] i64* [[VP_SUBSCRIPT_1]] *OVLS*(+8) AdjCost: 20
; CMCHECK-NEXT:    Cost 2 for i64 [[VP1]] = add i64 [[VP0]] i64 [[VP__IND_INIT_STEP]]
; CMCHECK-NEXT:    Cost 8 for i1 [[VP6:%.*]] = icmp slt i64 [[VP1]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CMCHECK-NEXT:    Cost 0 for br i1 [[VP6]], [[BB2]], [[BB3:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB2]]: base cost: 46
; CMCHECK-NEXT:  Base Cost: 46
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CMCHECK-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CMCHECK-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB3]]: base cost: 0
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CMCHECK-NEXT:    Cost 0 for br <External Block>
; CMCHECK-NEXT:  [[BB4]]: base cost: 0
; CMCHECK-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 4 resulted Cost = 0
;
; HIRCHECK:       Function: foo
; HIRCHECK-EMPTY:
; HIRCHECK-NEXT:            BEGIN REGION { modified }
; HIRCHECK-NEXT:                 + DO i1 = 0, 99, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; HIRCHECK-NEXT:                 |   [[DOTEXTENDED0:%.*]] = shufflevector i1 + <i64 0, i64 1, i64 2, i64 3>,  undef,  <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
; HIRCHECK-NEXT:                 |   [[SHUFFLE0:%.*]] = shufflevector undef,  [[DOTEXTENDED0]],  <i32 8, i32 1, i32 9, i32 3, i32 10, i32 5, i32 11, i32 7>
; HIRCHECK-NEXT:                 |   [[DOTEXTENDED10:%.*]] = shufflevector i1 + <i64 0, i64 1, i64 2, i64 3> + 1,  undef,  <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
; HIRCHECK-NEXT:                 |   [[SHUFFLE20:%.*]] = shufflevector [[SHUFFLE0]],  [[DOTEXTENDED10]],  <i32 0, i32 8, i32 2, i32 9, i32 4, i32 10, i32 6, i32 11>
; HIRCHECK-NEXT:                 |   (<8 x i64>*)([[ARR0:%.*]])[2 * i1] = [[SHUFFLE20]]
; HIRCHECK-NEXT:                 + END LOOP
; HIRCHECK:                 END REGION
;
entry:
  br label %for.body

for.body:
  %l1.011 = phi i64 [ 0, %entry ], [ %add, %for.body ]
  %mul = shl nuw nsw i64 %l1.011, 1
  %ptridx = getelementptr inbounds i64, i64* %arr, i64 %mul
  store i64 %l1.011, i64* %ptridx, align 8
  %add = add nuw nsw i64 %l1.011, 1
  %add2 = or i64 %mul, 1
  %ptridx3 = getelementptr inbounds i64, i64* %arr, i64 %add2
  store i64 %add, i64* %ptridx3, align 8
  %exitcond.not = icmp eq i64 %add, 100
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  ret void
}
; end INTEL_FEATURE_SW_ADVANCED
