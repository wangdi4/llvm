; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; Test to check that we don't fold unused add. If we fold it then in some cases
; we can create an empty loop which leads to verification errors.
;
; RUN: opt -disable-output -passes="hir-ssa-deconstruction,hir-opt-predicate,hir-vec-dir-insert,hir-vplan-vec" -disable-hir-aggressive-redundant-loop-removal -print-after=hir-vplan-vec %s 2>&1 | FileCheck %s

define void @foo(i1 %c, i64 %t, ptr %A, ptr %B, ptr %D) {
; CHECK-LABEL:  Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        if ([[C0:%.*]] != 0)
; CHECK-NEXT:        {
; CHECK-NEXT:           [[DOTVEC0:%.*]] = 3  /u  <i64 0, i64 1, i64 2, i64 3> + 1
; CHECK-NEXT:           (<4 x i16>*)([[D0:%.*]])[0] = [[DOTVEC0]]
; CHECK-NEXT:           [[DOTVEC0]] = 3  /u  <i64 0, i64 1, i64 2, i64 3> + 5
; CHECK-NEXT:           (<4 x i16>*)([[D0]])[4] = [[DOTVEC0]]
; CHECK-NEXT:           [[DOTVEC0]] = 3  /u  <i64 0, i64 1, i64 2, i64 3> + 9
; CHECK-NEXT:           (<4 x i16>*)([[D0]])[8] = [[DOTVEC0]]
; CHECK-NEXT:        }
; CHECK-NEXT:        else
; CHECK-NEXT:        {
; CHECK-NEXT:           [[DOTVEC20:%.*]] = trunc.<4 x i64>.<4 x i16>(<i64 0, i64 1, i64 2, i64 3> + 1)
; CHECK-NEXT:           [[DOTVEC20]] = trunc.<4 x i64>.<4 x i16>(<i64 0, i64 1, i64 2, i64 3> + 5)
; CHECK-NEXT:           [[DOTVEC20]] = trunc.<4 x i64>.<4 x i16>(<i64 0, i64 1, i64 2, i64 3> + 9)
; CHECK-NEXT:        }
; CHECK-NEXT:  END REGION
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.inc, %latch ]
  %a1 = add i64 %iv, 1
  %tr = trunc i64 %a1 to i16
  br i1 %c, label %then, label %latch

then:
  %div2 = sdiv i16 3, %tr
  %gep2 = getelementptr inbounds i16, ptr %D, i64 %iv
  store i16 %div2, ptr %gep2
  br label %latch

latch:
  %iv.inc = add i64 %iv, 1
  %cmp = icmp eq i64 %iv.inc, 12
  br i1 %cmp, label %exit, label %loop

exit:
  ret void
}
