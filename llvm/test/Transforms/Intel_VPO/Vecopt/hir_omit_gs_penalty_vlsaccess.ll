; INTEL_FEATURE_SW_ADVANCED
; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: intel_feature_sw_advanced
;
; NOTE: CM dump goes to stdout and HIR dump goes to stderr. Trying to use one
; RUN command line garbles up output causing checks to fail.
;
; RUN: opt -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec' -vplan-force-vf=4 -vplan-cost-model-print-analysis-for-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 | FileCheck %s --check-prefix=CMCHECK

; RUN: opt -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>' -vplan-force-vf=4 -mattr=+sse4.2 -enable-intel-advanced-opts -disable-output < %s 2>&1 | FileCheck %s --check-prefix=HIRCHECK
;
; Test to demonstrate GatherScatter(GS) penalty being applied to memory
; access that are VLS optimized. Subsequent changes will update the
; test to show GS penalty being removed when the access is VLS optimized.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i64 @foo(ptr nocapture readonly %lp) local_unnamed_addr #0 {
; CMCHECK-LABEL:  Cost Model for VPlan foo:HIR.#{{[0-9]+}} with VF = 4:
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CMCHECK-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB0]]: base cost: 0
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CMCHECK-NEXT:    Cost 0 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 100, UF = 1
; CMCHECK-NEXT:    Cost 2 for i64 [[VP_RED_INIT:%.*]] = reduction-init i64 0 i64 live-in0
; CMCHECK-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in1 i64 1
; CMCHECK-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CMCHECK-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB1]]: base cost: 2
; CMCHECK-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 4 resulted Cost = 2
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP_RED_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB2]] ]
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP4:%.*]] = hir-copy i64 [[VP0]] , OriginPhiId: -1
; CMCHECK-NEXT:    Cost 12 for i64 [[VP5:%.*]] = mul i64 2 i64 [[VP2]]
; CMCHECK-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[LP0:%.*]] i64 [[VP5]]
; CMCHECK-NEXT:    Cost 12 for i64 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]] *OVLS*(+6) AdjCost: 18
; CMCHECK-NEXT:    Cost 2 for i64 [[VP7:%.*]] = add i64 [[VP5]] i64 1
; CMCHECK-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[LP0]] i64 [[VP7]]
; CMCHECK-NEXT:    Cost 12 for i64 [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]] *OVLS*(-12) AdjCost: 0
; CMCHECK-NEXT:    Cost 2 for i64 [[VP8:%.*]] = add i64 [[VP_LOAD]] i64 [[VP4]]
; CMCHECK-NEXT:    Cost 2 for i64 [[VP1]] = add i64 [[VP8]] i64 [[VP_LOAD_1]]
; CMCHECK-NEXT:    Cost 2 for i64 [[VP3]] = add i64 [[VP2]] i64 [[VP__IND_INIT_STEP]]
; CMCHECK-NEXT:    Cost 8 for i1 [[VP9:%.*]] = icmp slt i64 [[VP3]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CMCHECK-NEXT:    Cost 0 for br i1 [[VP9]], [[BB2]], [[BB3:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB2]]: base cost: 46
; CMCHECK-NEXT:  Base Cost: 46
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CMCHECK-NEXT:    Cost 3 for i64 [[VP_RED_FINAL:%.*]] = reduction-final{u_add} i64 [[VP1]]
; CMCHECK-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CMCHECK-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CMCHECK-NEXT:  [[BB3]]: base cost: 3
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CMCHECK-NEXT:    Cost 0 for br <External Block>
; CMCHECK-NEXT:  [[BB4]]: base cost: 0
; CMCHECK-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 4 resulted Cost = 3
;
; HIRCHECK:       Function: foo
; HIRCHECK-EMPTY:
; HIRCHECK-NEXT:            BEGIN REGION { modified }
; HIRCHECK-NEXT:                 [[RED_INIT0:%.*]] = 0
; HIRCHECK-NEXT:                 [[RED_INIT_INSERT0:%.*]] = insertelement [[RED_INIT0]],  [[SUM_0130:%.*]],  0
; HIRCHECK-NEXT:                 [[PHI_TEMP0:%.*]] = [[RED_INIT_INSERT0]]
; HIRCHECK:                      + DO i1 = 0, 99, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; HIRCHECK-NEXT:                 |   [[DOTCOPY10:%.*]] = [[PHI_TEMP0]]
; HIRCHECK-NEXT:                 |   [[DOTVLS_LOAD0:%.*]] = (<8 x i64>*)([[LP0:%.*]])[2 * i1]
; HIRCHECK-NEXT:                 |   [[VLS_EXTRACT0:%.*]] = shufflevector [[DOTVLS_LOAD0]],  [[DOTVLS_LOAD0]],  <i32 0, i32 2, i32 4, i32 6>
; HIRCHECK-NEXT:                 |   [[VLS_EXTRACT20:%.*]] = shufflevector [[DOTVLS_LOAD0]],  [[DOTVLS_LOAD0]],  <i32 1, i32 3, i32 5, i32 7>
; HIRCHECK-NEXT:                 |   [[DOTVEC0:%.*]] = [[DOTCOPY10]] + [[VLS_EXTRACT0]]  +  [[VLS_EXTRACT20]]
; HIRCHECK-NEXT:                 |   [[PHI_TEMP0]] = [[DOTVEC0]]
; HIRCHECK-NEXT:                 + END LOOP
; HIRCHECK:                      [[SUM_0130]] = @llvm.vector.reduce.add.v4i64([[DOTVEC0]])
; HIRCHECK:                 END REGION
;
entry:
  br label %for.body

for.body:
  %l1.014 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %sum.013 = phi i64 [ 0, %entry ], [ %add4, %for.body ]
  %mul = shl nuw nsw i64 %l1.014, 1
  %ptridx = getelementptr inbounds i64, ptr %lp, i64 %mul
  %0 = load i64, ptr %ptridx, align 8
  %add = add nsw i64 %0, %sum.013
  %add2 = or i64 %mul, 1
  %ptridx3 = getelementptr inbounds i64, ptr %lp, i64 %add2
  %1 = load i64, ptr %ptridx3, align 8
  %add4 = add nsw i64 %add, %1
  %inc = add nuw nsw i64 %l1.014, 1
  %exitcond.not = icmp eq i64 %inc, 100
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  ret i64 %add4
}
; end INTEL_FEATURE_SW_ADVANCED
