; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -opaque-pointers -vplan-vec -vplan-force-vf=2 -vplan-entities-dump -vplan-print-after-vpentity-instrs -vplan-dump-induction-init-details -S < %s 2>&1 | FileCheck %s
; RUN: opt -opaque-pointers -passes="vplan-vec" -vplan-force-vf=2 -vplan-entities-dump -vplan-print-after-vpentity-instrs -vplan-dump-induction-init-details -S < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

; Test verifies that VPlan can consume OMP linear clauses with opaque pointres.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@arr = dso_local global [10 x i32] zeroinitializer, align 16

; Function Attrs: noinline nounwind uwtable
define dso_local void @foo(i64* %x, i32* %y, i16** %z) #0 {
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: foo:omp.inner.for.body.#{{[0-9]+}}
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i32 0 Step: i32 1 StartVal: i32 0 EndVal: i32 10 BinOp: i32 [[VP_IV_NEXT:%.*]] = add i32 [[VP_IV:%.*]] i32 [[VP_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP_IV]], i32 [[VP_IV_NEXT]], i32 [[VP_IV_IND_INIT:%.*]], i32 [[VP_IV_IND_INIT_STEP]], i32 [[VP_IV_IND_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK-NEXT:  PtrInduction(+) Start: ptr [[VP_LOAD_X1:%.*]] Step: i64 8 StartVal: ? EndVal: ? need close form 
; CHECK-NEXT:   Linked values: ptr [[VP_X_LINEAR_PTR:%.*]], ptr [[VP_X_LINEAR_PTR_IND_INIT_STEP:%.*]], void [[VP_X_VOID:%.*]], ptr [[VP_X_LINEAR_PTR_IND_FINAL:%.*]], 
; CHECK-NEXT:  Memory: ptr %x.linear.ptr
; CHECK-NEXT:  PtrInduction(+) Start: ptr [[VP_LOAD_Y1:%.*]] Step: i64 4 StartVal: ? EndVal: ? need close form 
; CHECK-NEXT:   Linked values: ptr [[VP_Y_LINEAR_PTR:%.*]], ptr [[VP_Y_LINEAR_PTR_IND_INIT_STEP:%.*]], void [[VP_Y_VOID:%.*]], ptr [[VP_Y_LINEAR_PTR_IND_FINAL:%.*]], 
; CHECK-NEXT:  Memory: ptr %y.linear.ptr
; CHECK-NEXT:  PtrInduction(+) Start: ptr [[VP_LOAD_Z1:%.*]] Step: i64 8 StartVal: ? EndVal: ? need close form 
; CHECK-NEXT:   Linked values: ptr [[VP_Z_LINEAR_PTR:%.*]], ptr [[VP_Z_LINEAR_PTR_IND_INIT_STEP:%.*]], void [[VP_Z_VOID:%.*]], ptr [[VP_Z_LINEAR_PTR_IND_FINAL:%.*]], 
; CHECK-NEXT:  Memory: ptr %z.linear.ptr
; CHECK-NEXT:  IntInduction(+) Start: i32 [[VP_IV]] Step: i32 1 StartVal: ? EndVal: ? need close form 
; CHECK-NEXT:   Linked values: ptr [[VP_I_LINEAR_IV_PTR:%.*]], i32 [[VP_I_LINEAR_IV_PTR_IND_INIT:%.*]], i32 [[VP_I_LINEAR_IV_PTR_IND_INIT_STEP:%.*]], void [[VP_I_VOID:%.*]], i32 [[VP_I_LINEAR_IV_PTR_IND_FINAL:%.*]],
; CHECK-NEXT:  Memory: ptr %i.linear.iv.ptr
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     ptr [[VP_I_LINEAR_IV_PTR]] = allocate-priv ptr, OrigAlign = 4
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV_PTR]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     ptr [[VP_Z_LINEAR_PTR]] = allocate-priv ptr, OrigAlign = 4
; CHECK-NEXT:     call i64 8 ptr [[VP_Z_LINEAR_PTR]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     ptr [[VP_Y_LINEAR_PTR]] = allocate-priv ptr, OrigAlign = 4
; CHECK-NEXT:     call i64 8 ptr [[VP_Y_LINEAR_PTR]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     ptr [[VP_X_LINEAR_PTR]] = allocate-priv ptr, OrigAlign = 4
; CHECK-NEXT:     call i64 8 ptr [[VP_X_LINEAR_PTR]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     i32 [[VP_IV_IND_INIT]] = induction-init{add, StartVal: i32 0, EndVal: i32 10} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_IV_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:     ptr [[VP_LOAD_X:%.*]] = load ptr [[X_LINEAR_PTR0:%.*]]
; CHECK-NEXT:     ptr [[VP_X_LINEAR_PTR_IND_INIT:%.*]] = induction-init{getelementptr, StartVal: ?, EndVal: ?} ptr [[VP_LOAD_X]] i64 8
; CHECK-NEXT:     store ptr [[VP_X_LINEAR_PTR_IND_INIT]] ptr [[VP_X_LINEAR_PTR]]
; CHECK-NEXT:     i64 [[VP_X_LINEAR_PTR_IND_INIT_STEP:%.*]] = induction-init-step{getelementptr} i64 8
; CHECK-NEXT:     ptr [[VP_LOAD_Y:%.*]] = load ptr [[Y_LINEAR_PTR0:%.*]]
; CHECK-NEXT:     ptr [[VP_Y_LINEAR_PTR_IND_INIT:%.*]] = induction-init{getelementptr, StartVal: ?, EndVal: ?} ptr [[VP_LOAD_Y]] i64 4
; CHECK-NEXT:     store ptr [[VP_Y_LINEAR_PTR_IND_INIT]] ptr [[VP_Y_LINEAR_PTR]]
; CHECK-NEXT:     i64 [[VP_Y_LINEAR_PTR_IND_INIT_STEP:%.*]] = induction-init-step{getelementptr} i64 4
; CHECK-NEXT:     ptr [[VP_LOAD_Z:%.*]] = load ptr [[Z_LINEAR_PTR0:%.*]]
; CHECK-NEXT:     ptr [[VP_Z_LINEAR_PTR_IND_INIT:%.*]] = induction-init{getelementptr, StartVal: ?, EndVal: ?} ptr [[VP_LOAD_Z]] i64 8
; CHECK-NEXT:     store ptr [[VP_Z_LINEAR_PTR_IND_INIT]] ptr [[VP_Z_LINEAR_PTR]]
; CHECK-NEXT:     i64 [[VP_Z_LINEAR_PTR_IND_INIT_STEP:%.*]] = induction-init-step{getelementptr} i64 8
; CHECK-NEXT:     i32 [[VP_LOAD_I:%.*]] = load ptr [[I_LINEAR_IV_PTR0:%.*]]
; CHECK-NEXT:     i32 [[VP_I_LINEAR_IV_PTR_IND_INIT:%.*]] = induction-init{add, StartVal: ?, EndVal: ?} i32 [[VP_LOAD_I]] i32 1
; CHECK-NEXT:     store i32 [[VP_I_LINEAR_IV_PTR_IND_INIT]] ptr [[VP_I_LINEAR_IV_PTR]]
; CHECK-NEXT:     i32 [[VP_I_LINEAR_IV_PTR_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB0]]
; CHECK-NEXT:     i32 [[VP_IV]] = phi  [ i32 [[VP_IV_IND_INIT]], [[BB2]] ],  [ i32 [[VP_IV_NEXT]], [[BB0]] ]
; CHECK-NEXT:     ptr [[VP0_1:%.*]] = phi  [ ptr [[VP_X_LINEAR_PTR_IND_INIT]], [[BB2]] ],  [ ptr [[VP1_1:%.*]], [[BB0]] ]
; CHECK-NEXT:     ptr [[VP0_2:%.*]] = phi  [ ptr [[VP_Y_LINEAR_PTR_IND_INIT]], [[BB2]] ],  [ ptr [[VP1_2:%.*]], [[BB0]] ]
; CHECK-NEXT:     ptr [[VP0_3:%.*]] = phi  [ ptr [[VP_Z_LINEAR_PTR_IND_INIT]], [[BB2]] ],  [ ptr [[VP1_3:%.*]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP2:%.*]] = phi  [ i32 [[VP_I_LINEAR_IV_PTR_IND_INIT]], [[BB2]] ],  [ i32 [[VP3:%.*]], [[BB0]] ]
; CHECK-NEXT:     store i32 [[VP2]] ptr [[VP_I_LINEAR_IV_PTR]]
; CHECK-NEXT:     store ptr [[VP0_3]] ptr [[VP_Z_LINEAR_PTR]]
; CHECK-NEXT:     store ptr [[VP0_2]] ptr [[VP_Y_LINEAR_PTR]]
; CHECK-NEXT:     store ptr [[VP0_1]] ptr [[VP_X_LINEAR_PTR]]
; CHECK-NEXT:     store i32 [[VP_IV]] ptr [[VP_I_LINEAR_IV_PTR]]
; CHECK-NEXT:     ptr [[VP_LOAD_Y1]] = load ptr [[VP_Y_LINEAR_PTR]]
; CHECK-NEXT:     i32 [[VP_LOAD_Y2:%.*]] = load ptr [[VP_LOAD_Y1]]
; CHECK-NEXT:     i32 [[VP_I:%.*]] = load ptr [[VP_I_LINEAR_IV_PTR]]
; CHECK-NEXT:     ptr [[VP_X_PTR:%.*]] = getelementptr inbounds [10 x i32], ptr @arr i64 0 i32 [[VP_I]]
; CHECK-NEXT:     store i32 [[VP_LOAD_X2:%.*]] ptr [[VP_X_PTR]]
; CHECK-NEXT:     ptr [[VP_LOAD_X1]] = load ptr [[VP_X_LINEAR_PTR]]
; CHECK-NEXT:     ptr [[VP_LOAD_Z1]] = load ptr [[VP_Z_LINEAR_PTR]]
; CHECK-NEXT:     call ptr [[VP_LOAD_X1]] ptr [[VP_LOAD_Z1]] ptr @_Z3bazPcPc
; CHECK-NEXT:     i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 [[VP_IV_IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP_COND_EXIT:%.*]] = icmp sgt i32 10 i32 [[VP_IV_NEXT]]
; CHECK-NEXT:     ptr [[VP1_1]] = getelementptr inbounds i8, ptr [[VP0_1]] i64 [[VP_X_LINEAR_PTR_IND_INIT_STEP]]
; CHECK-NEXT:     ptr [[VP1_2]] = getelementptr inbounds i8, ptr [[VP0_2]] i64 [[VP_Y_LINEAR_PTR_IND_INIT_STEP]]
; CHECK-NEXT:     ptr [[VP1_3]] = getelementptr inbounds i8, ptr [[VP0_3]] i64 [[VP_Z_LINEAR_PTR_IND_INIT_STEP]]
; CHECK-NEXT:     i32 [[VP3]] = add i32 [[VP2]] i32 [[VP_I_LINEAR_IV_PTR_IND_INIT_STEP]]
; CHECK-NEXT:     br i1 [[VP_COND_EXIT]], [[BB0]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP_IV_IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     ptr [[VP_LOAD_X2:%.*]] = load ptr [[VP_X_LINEAR_PTR]]
; CHECK-NEXT:     ptr [[VP_X_LINEAR_PTR_IND_FINAL]] = induction-final{getelementptr} ptr [[VP_LOAD_X]] i64 8
; CHECK-NEXT:     store ptr [[VP_X_LINEAR_PTR_IND_FINAL]] ptr [[X_LINEAR_PTR0]]
; CHECK-NEXT:     call i64 8 ptr [[VP_X_LINEAR_PTR]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     ptr [[VP_LOAD_Y2:%.*]] = load ptr [[VP_Y_LINEAR_PTR]]
; CHECK-NEXT:     ptr [[VP_Y_LINEAR_PTR_IND_FINAL]] = induction-final{getelementptr} ptr [[VP_LOAD_Y]] i64 4
; CHECK-NEXT:     store ptr [[VP_Y_LINEAR_PTR_IND_FINAL]] ptr [[Y_LINEAR_PTR0]]
; CHECK-NEXT:     call i64 8 ptr [[VP_Y_LINEAR_PTR]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     ptr [[VP_LOAD_Z2:%.*]] = load ptr [[VP_Z_LINEAR_PTR]]
; CHECK-NEXT:     ptr [[VP_Z_LINEAR_PTR_IND_FINAL]] = induction-final{getelementptr} ptr [[VP_LOAD_Z]] i64 8
; CHECK-NEXT:     store ptr [[VP_Z_LINEAR_PTR_IND_FINAL]] ptr [[Z_LINEAR_PTR0]]
; CHECK-NEXT:     call i64 8 ptr [[VP_Z_LINEAR_PTR]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_I_LINEAR_IV_PTR]]
; CHECK-NEXT:     i32 [[VP_I_LINEAR_IV_PTR_IND_FINAL]] = induction-final{add} i32 [[VP_LOAD_I]] i32 1
; CHECK-NEXT:     store i32 [[VP_I_LINEAR_IV_PTR_IND_FINAL]] ptr [[I_LINEAR_IV_PTR0]]
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV_PTR]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
; CHECK: define dso_local void @foo(ptr %x, ptr %y, ptr %z) #0 {
; CHECK-NEXT: entry:
; CHECK-NEXT:   [[X_LINEAR_PTR:%.*]] = alloca ptr, align 4
; CHECK-NEXT:   [[Y_LINEAR_PTR:%.*]] = alloca ptr, align 4
; CHECK-NEXT:   [[Z_LINEAR_PTR:%.*]] = alloca ptr, align 4
; CHECK-NEXT:   [[I_LINEAR_IV_PTR:%.*]] = alloca i32, align 4
; CHECK-NEXT:   [[I_LINEAR_IV_PTR_VEC:%.*]] = alloca <2 x i32>, align 8
; CHECK-NEXT:   [[I_LINEAR_IV_PTR_VEC_BASEADDR:%.*]] = getelementptr i32, ptr [[I_LINEAR_IV_PTR_VEC]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:   [[I_LINEAR_IV_PTR_VEC_BASEADDR_EXTRACT0:%.*]] = extractelement <2 x ptr> [[I_LINEAR_IV_PTR_VEC_BASEADDR]], i32 0
; CHECK-NEXT:   [[Z_LINEAR_PTR_VEC:%.*]] = alloca <2 x ptr>, align 16
; CHECK-NEXT:   [[Z_LINEAR_PTR_VEC_BASEADDR:%.*]] = getelementptr ptr, ptr [[Z_LINEAR_PTR_VEC]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:   [[Z_LINEAR_PTR_VEC_BASEADDR_EXTRACT0:%.*]] = extractelement <2 x ptr> [[Z_LINEAR_PTR_VEC_BASEADDR]], i32 0
; CHECK-NEXT:   [[Y_LINEAR_PTR_VEC:%.*]] = alloca <2 x ptr>, align 16
; CHECK-NEXT:   [[Y_LINEAR_PTR_VEC_BASEADDR:%.*]] = getelementptr ptr, ptr [[Y_LINEAR_PTR_VEC]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:   [[Y_LINEAR_PTR_VEC_BASEADDR_EXTRACT0:%.*]] = extractelement <2 x ptr> [[Y_LINEAR_PTR_VEC_BASEADDR]], i32 0
; CHECK-NEXT:   [[X_LINEAR_PTR_VEC:%.*]] = alloca <2 x ptr>, align 16
; CHECK-NEXT:   [[X_LINEAR_PTR_VEC_BASEADDR:%.*]] = getelementptr ptr, ptr [[X_LINEAR_PTR_VEC]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:   [[X_LINEAR_PTR_VEC_BASEADDR_EXTRACT0:%.*]] = extractelement <2 x ptr> [[X_LINEAR_PTR_VEC_BASEADDR]], i32 0
; CHECK-NEXT:   br label %DIR.OMP.SIMD.1
; CHECK-EMPTY: 
; CHECK-NEXT: DIR.OMP.SIMD.1:                                   ; preds = %entry
; CHECK-NEXT:   store ptr %x, ptr [[X_LINEAR_PTR]], align 4
; CHECK-NEXT:   store ptr %y, ptr [[Y_LINEAR_PTR]], align 4
; CHECK-NEXT:   store ptr %z, ptr [[Z_LINEAR_PTR]], align 4
; CHECK-NEXT:   br label %omp.region.entry
; CHECK-EMPTY: 
; CHECK-NEXT: omp.region.entry:                                 ; preds = %DIR.OMP.SIMD.1
; CHECK-NEXT:   br label %VPlannedBB
; CHECK-EMPTY: 
; CHECK-NEXT: VPlannedBB:                                       ; preds = %omp.region.entry
; CHECK-NEXT:   br label %VPlannedBB1
; CHECK-EMPTY: 
; CHECK-NEXT: VPlannedBB1:                                      ; preds = %VPlannedBB
; CHECK:        %0 = load ptr, ptr [[X_LINEAR_PTR]], align 1
; CHECK-NEXT:   %1 = load ptr, ptr [[X_LINEAR_PTR]], align 1
; CHECK-NEXT:   [[IND_START_BCAST_SPLATINSERT:%.*]] = insertelement <2 x ptr> poison, ptr %0, i32 0
; CHECK-NEXT:   [[IND_START_BCAST_SPLAT:%.*]] = shufflevector <2 x ptr> [[IND_START_BCAST_SPLATINSERT]], <2 x ptr> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:   [[VECTOR_GEP:%.*]] = getelementptr inbounds i8, <2 x ptr> [[IND_START_BCAST_SPLAT]], <2 x i64> <i64 0, i64 8>
; CHECK-NEXT:   store <2 x ptr> [[VECTOR_GEP]], ptr [[X_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   %2 = load ptr, ptr [[Y_LINEAR_PTR]], align 1
; CHECK-NEXT:   %3 = load ptr, ptr [[Y_LINEAR_PTR]], align 1
; CHECK-NEXT:   [[IND_START_BCAST_SPLATINSERT2:%.*]] = insertelement <2 x ptr> poison, ptr %2, i32 0
; CHECK-NEXT:   [[IND_START_BCAST_SPLAT3:%.*]] = shufflevector <2 x ptr> [[IND_START_BCAST_SPLATINSERT2]], <2 x ptr> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:   [[VECTOR_GEP4:%.*]] = getelementptr inbounds i8, <2 x ptr> [[IND_START_BCAST_SPLAT3]], <2 x i64> <i64 0, i64 4>
; CHECK-NEXT:   store <2 x ptr> [[VECTOR_GEP4]], ptr [[Y_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   %4 = load ptr, ptr [[Z_LINEAR_PTR]], align 1
; CHECK-NEXT:   %5 = load ptr, ptr [[Z_LINEAR_PTR]], align 1
; CHECK-NEXT:   [[IND_START_BCAST_SPLATINSERT5:%.*]] = insertelement <2 x ptr> poison, ptr %4, i32 0
; CHECK-NEXT:   [[IND_START_BCAST_SPLAT6:%.*]] = shufflevector <2 x ptr> [[IND_START_BCAST_SPLATINSERT5]], <2 x ptr> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:   [[VECTOR_GEP7:%.*]] = getelementptr inbounds i8, <2 x ptr> [[IND_START_BCAST_SPLAT6]], <2 x i64> <i64 0, i64 8>
; CHECK-NEXT:   store <2 x ptr> [[VECTOR_GEP7]], ptr [[Z_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   %6 = load i32, ptr [[I_LINEAR_IV_PTR]], align 1
; CHECK-NEXT:   %7 = load i32, ptr [[I_LINEAR_IV_PTR]], align 1
; CHECK-NEXT:   [[IND_START_BCAST_SPLATINSERT8:%.*]] = insertelement <2 x i32> poison, i32 %6, i32 0
; CHECK-NEXT:   [[IND_START_BCAST_SPLAT9:%.*]] = shufflevector <2 x i32> [[IND_START_BCAST_SPLATINSERT8]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:   %8 = add <2 x i32> [[IND_START_BCAST_SPLAT9]], <i32 0, i32 1>
; CHECK-NEXT:   store <2 x i32> %8, ptr [[I_LINEAR_IV_PTR_VEC]], align 1
; CHECK-NEXT:   br label %vector.body
; CHECK-EMPTY: 
; CHECK-NEXT: vector.body:                                      ; preds = %vector.body, %VPlannedBB1
; CHECK-NEXT:   [[UNI_PHI:%.*]] = phi i32 [ 0, %VPlannedBB1 ], [ %10, %vector.body ]
; CHECK-NEXT:   [[VEC_PHI:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, %VPlannedBB1 ], [ %9, %vector.body ]
; CHECK-NEXT:   [[UNI_PHI11:%.*]] = phi ptr [ %0, %VPlannedBB1 ], [ [[MM_VECTORGEP22_EXTRACT0:%.*]], %vector.body ]
; CHECK-NEXT:   [[VEC_PHI12:%.*]] = phi <2 x ptr> [ [[VECTOR_GEP]], %VPlannedBB1 ], [ [[MM_VECTORGEP22:%.*]], %vector.body ]
; CHECK-NEXT:   [[UNI_PHI13:%.*]] = phi ptr [ %2, %VPlannedBB1 ], [ [[MM_VECTORGEP23_EXTRACT0:%.*]], %vector.body ]
; CHECK-NEXT:   [[VEC_PHI14:%.*]] = phi <2 x ptr> [ [[VECTOR_GEP4]], %VPlannedBB1 ], [ [[MM_VECTORGEP23:%.*]], %vector.body ]
; CHECK-NEXT:   [[UNI_PHI15:%.*]] = phi ptr [ %4, %VPlannedBB1 ], [ [[MM_VECTORGEP24_EXTRACT0:%.*]], %vector.body ]
; CHECK-NEXT:   [[VEC_PHI16:%.*]] = phi <2 x ptr> [ [[VECTOR_GEP7]], %VPlannedBB1 ], [ [[MM_VECTORGEP24:%.*]], %vector.body ]
; CHECK-NEXT:   [[UNI_PHI17:%.*]] = phi i32 [ %6, %VPlannedBB1 ], [ %12, %vector.body ]
; CHECK-NEXT:   [[VEC_PHI18:%.*]] = phi <2 x i32> [ %8, %VPlannedBB1 ], [ %11, %vector.body ]
; CHECK-NEXT:   store <2 x i32> [[VEC_PHI18:%.*]], ptr [[I_LINEAR_IV_PTR_VEC]], align 1
; CHECK-NEXT:   store <2 x ptr> [[VEC_PHI16:%.*]], ptr [[Z_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   store <2 x ptr> [[VEC_PHI14:%.*]], ptr [[Y_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   store <2 x ptr> [[VEC_PHI12:%.*]], ptr [[X_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   store <2 x i32> [[VEC_PHI:%.*]], ptr [[I_LINEAR_IV_PTR_VEC]], align 4
; CHECK-NEXT:   [[WIDE_LOAD:%.*]] = load <2 x ptr>, ptr [[Y_LINEAR_PTR_VEC]], align 4
; CHECK-NEXT:   %wide.masked.gather = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[WIDE_LOAD]], i32 4, <2 x i1> <i1 true, i1 true>, <2 x i32> undef)
; CHECK-NEXT:   [[WIDE_LOAD19:%.*]] = load <2 x i32>, ptr [[I_LINEAR_IV_PTR_VEC]], align 4
; CHECK-NEXT:   [[MM_VECTORGEP:%.*]] = getelementptr inbounds [10 x i32], <2 x ptr> <ptr @arr, ptr @arr>, <2 x i64> zeroinitializer, <2 x i32> [[WIDE_LOAD19]]
; CHECK-NEXT:   call void @llvm.masked.scatter.v2i32.v2p0(<2 x i32> %wide.masked.gather, <2 x ptr> [[MM_VECTORGEP]], i32 4, <2 x i1> <i1 true, i1 true>)
; CHECK-NEXT:   [[WIDE_LOAD20:%.*]] = load <2 x ptr>, ptr [[X_LINEAR_PTR_VEC]], align 4
; CHECK-NEXT:   [[WIDE_LOAD20_EXTRACT1:%.*]] = extractelement <2 x ptr> [[WIDE_LOAD20]], i32 1
; CHECK-NEXT:   [[WIDE_LOAD20_EXTRACT0:%.*]] = extractelement <2 x ptr> [[WIDE_LOAD20]], i32 0
; CHECK-NEXT:   [[WIDE_LOAD21:%.*]] = load <2 x ptr>, ptr [[Z_LINEAR_PTR_VEC]], align 4
; CHECK-NEXT:   [[WIDE_LOAD21_EXTRACT1:%.*]] = extractelement <2 x ptr> [[WIDE_LOAD21]], i32 1
; CHECK-NEXT:   [[WIDE_LOAD21_EXTRACT0:%.*]] = extractelement <2 x ptr> [[WIDE_LOAD21]], i32 0
; CHECK-NEXT:   call void @_Z3bazPcPc(ptr nonnull [[WIDE_LOAD20_EXTRACT0]], ptr nonnull [[WIDE_LOAD21_EXTRACT0]])
; CHECK-NEXT:   call void @_Z3bazPcPc(ptr nonnull [[WIDE_LOAD20_EXTRACT1]], ptr nonnull [[WIDE_LOAD21_EXTRACT1]])
; CHECK-NEXT:   %9 = add nsw <2 x i32> [[VEC_PHI]], <i32 2, i32 2>
; CHECK-NEXT:   %10 = add nsw i32 [[UNI_PHI]], 2
; CHECK-NEXT:   [[MM_VECTORGEP22]] = getelementptr inbounds i8, <2 x ptr> [[VEC_PHI12]], <2 x i64> <i64 16, i64 16>
; CHECK-NEXT:   [[MM_VECTORGEP22_EXTRACT0]] = extractelement <2 x ptr> [[MM_VECTORGEP22]], i32 0
; CHECK-NEXT:   [[MM_VECTORGEP23]] = getelementptr inbounds i8, <2 x ptr> [[VEC_PHI14]], <2 x i64> <i64 8, i64 8>
; CHECK-NEXT:   [[MM_VECTORGEP23_EXTRACT0]] = extractelement <2 x ptr> [[MM_VECTORGEP23]], i32 0
; CHECK-NEXT:   [[MM_VECTORGEP24]] = getelementptr inbounds i8, <2 x ptr> [[VEC_PHI16]], <2 x i64> <i64 16, i64 16>
; CHECK-NEXT:   [[MM_VECTORGEP24_EXTRACT0]] = extractelement <2 x ptr> [[MM_VECTORGEP24]], i32 0
; CHECK-NEXT:   %11 = add <2 x i32> [[VEC_PHI18]], <i32 2, i32 2>
; CHECK-NEXT:   %12 = add i32 [[UNI_PHI17]], 2
; CHECK-NEXT:   %13 = icmp ult i32 %10, 10
; CHECK-NEXT:   br i1 %13, label %vector.body, label %VPlannedBB25, !llvm.loop !0
; CHECK-EMPTY: 
; CHECK-NEXT: VPlannedBB25:                                     ; preds = %vector.body
; CHECK-NEXT:   [[WIDE_LOAD26:%.*]] = load <2 x ptr>, ptr [[X_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   [[FINAL_GEP:%.*]] = getelementptr inbounds i8, ptr %0, i64 80
; CHECK-NEXT:   store ptr [[FINAL_GEP]], ptr [[X_LINEAR_PTR]], align 1
; CHECK-NEXT:   call void @llvm.lifetime.end.p0(i64 16, ptr [[X_LINEAR_PTR_VEC_BASEADDR_EXTRACT0]])
; CHECK-NEXT:   [[WIDE_LOAD27:%.*]] = load <2 x ptr>, ptr [[Y_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   [[FINAL_GEP28:%.*]] = getelementptr inbounds i8, ptr %2, i64 40
; CHECK-NEXT:   store ptr [[FINAL_GEP28]], ptr [[Y_LINEAR_PTR]], align 1
; CHECK-NEXT:   call void @llvm.lifetime.end.p0(i64 16, ptr [[Y_LINEAR_PTR_VEC_BASEADDR_EXTRACT0]])
; CHECK-NEXT:   [[WIDE_LOAD29:%.*]] = load <2 x ptr>, ptr [[Z_LINEAR_PTR_VEC]], align 1
; CHECK-NEXT:   [[FINAL_GEP30:%.*]] = getelementptr inbounds i8, ptr %4, i64 80
; CHECK-NEXT:   store ptr [[FINAL_GEP30]], ptr [[Z_LINEAR_PTR]], align 1
; CHECK-NEXT:   call void @llvm.lifetime.end.p0(i64 16, ptr [[Z_LINEAR_PTR_VEC_BASEADDR_EXTRACT0]])
; CHECK-NEXT:   [[WIDE_LOAD31:%.*]] = load <2 x i32>, ptr [[I_LINEAR_IV_PTR_VEC]], align 1
; CHECK-NEXT:   %14 = add i32 %6, 10
; CHECK-NEXT:   store i32 %14, ptr [[I_LINEAR_IV_PTR]], align 1
; CHECK-NEXT:   call void @llvm.lifetime.end.p0(i64 8, ptr [[I_LINEAR_IV_PTR_VEC_BASEADDR_EXTRACT0]])
; CHECK-NEXT:   br label %VPlannedBB32
; CHECK-EMPTY: 
;
entry:
  %x.linear.ptr = alloca ptr, align 4
  %y.linear.ptr = alloca ptr, align 4
  %z.linear.ptr = alloca ptr, align 4
  %i.linear.iv.ptr = alloca i32, align 4
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %entry
  store ptr %x, ptr %x.linear.ptr, align 4
  store ptr %y, ptr %y.linear.ptr, align 4
  store ptr %z, ptr %z.linear.ptr, align 4
  br label %omp.region.entry

omp.region.entry:                                 ; preds = %DIR.OMP.SIMD.1
%i3 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LINEAR:TYPED.PTR_TO_PTR"(ptr %x.linear.ptr, i64 0, i32 1, i32 1), "QUAL.OMP.LINEAR:TYPED.PTR_TO_PTR"(ptr %y.linear.ptr, i32 0, i32 1, i32 1), "QUAL.OMP.LINEAR:TYPED.PTR_TO_PTR"(ptr %z.linear.ptr, ptr null, i32 1, i32 1), "QUAL.OMP.LINEAR:IV.TYPED"(ptr %i.linear.iv.ptr, i32 0, i32 1, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %omp.region.entry
  %iv = phi i32 [ 0, %omp.region.entry ], [ %iv.next, %omp.inner.for.body ]
  store i32 %iv, ptr %i.linear.iv.ptr, align 4
  %yload1 = load ptr, ptr %y.linear.ptr, align 4
  %yload2 = load i32, ptr %yload1, align 4
  %i = load i32, ptr %i.linear.iv.ptr, align 4
  %arr.ptr = getelementptr inbounds [10 x i32], ptr @arr, i64 0, i32 %i
  store i32 %yload2, ptr %arr.ptr, align 4
  %xload = load ptr, ptr %x.linear.ptr, align 4
  %zload = load ptr, ptr %z.linear.ptr, align 4
  call void @_Z3bazPcPc(ptr nonnull %xload, ptr nonnull %zload)
  %iv.next = add nsw i32 %iv, 1
  %cond.exit = icmp sgt i32 10, %iv.next
  br i1 %cond.exit, label %omp.inner.for.body, label %omp.region.exit

omp.region.exit:                                  ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %i3) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:                               ; preds = %omp.region.exit
  %y.last = load ptr, ptr %y.linear.ptr, align 4
  store ptr %y.last, ptr %y, align 4
  %xlast = load ptr, ptr %x.linear.ptr, align 4
  %zlast = load ptr, ptr %z.linear.ptr, align 4
  call void @_Z3bazPcPc(ptr nonnull %xlast, ptr nonnull %zlast)
  br label %omp.loop.exit

omp.loop.exit:                                    ; preds = %DIR.OMP.END.SIMD.1
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %omp.loop.exit
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

declare dso_local void @_Z3bazPcPc(ptr, ptr)

attributes #0 = { noinline nounwind uwtable "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "frame-pointer"="all" "may-have-openmp-directive"="true" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "unsafe-fp-math"="true" }
attributes #1 = { nounwind }

