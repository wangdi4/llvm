; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; NOTE: CM dump goes to stdout and HIR dump goes to stderr. Trying to use one
; RUN command line garbles up output causing checks to fail.
;
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -vplan-force-vf=4 -disable-output -vplan-cost-model-print-analysis-for-vf=4 < %s 2>&1 | FileCheck %s --check-prefix=CMCHECK
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -vplan-force-vf=4 -disable-output -print-after=VPlanDriverHIR < %s 2>&1 | FileCheck %s --check-prefix=HIRCHECK
;
; Test to demonstrate GatherScatter(GS) cost being used for accesses
; where VLS optimization still kicks in but groups are not supported
; by OVLS. Vectorizer currently generates shuffles and wide loads/stores
; on its own instead of relying on OVLS optimization to kick in later.
; Subsequent changes will update the test to show TTI based cost being
; used for cases that are not supported by OVLS. We may even want to
; consider using TTI cost until we start relying on OVLS transform to
; kick in after VPlan vectorizer.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @foo(i32* nocapture readonly %lp) local_unnamed_addr #0 {
; CMCHECK-LABEL:  Cost Model for VPlan HIR foo.17 with VF = 4:
; CMCHECK-NEXT:  Total Cost: 110000
; CMCHECK-NEXT:  Base Cost: 102000
; CMCHECK-NEXT:  Extra cost due to Spill/Fill heuristic is 8000
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]], total cost: 0
; CMCHECK-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB1]], total cost: 0
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 99, UF = 1
; CMCHECK-NEXT:    Cost Unknown for i32 [[VP__RED_INIT:%.*]] = reduction-init i32 0 i32 live-in0
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in1 i64 1
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CMCHECK-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB2]], total cost: 102000
; CMCHECK-NEXT:  Block Vector spill/fill approximate cost (not included into total cost): 8000
; CMCHECK-NEXT:    Cost Unknown for i32 [[VP0:%.*]] = phi  [ i32 [[VP__RED_INIT]], [[BB1]] ],  [ i32 [[VP1:%.*]], [[BB2]] ]
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB2]] ]
; CMCHECK-NEXT:    Cost Unknown for i32 [[VP4:%.*]] = hir-copy i32 [[VP0]] , OriginPhiId: -1
; CMCHECK-NEXT:    Cost 16000 for i64 [[VP5:%.*]] = mul i64 2 i64 [[VP2]]
; CMCHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[LP0:%.*]] i64 [[VP5]]
; FIXME --- the cost for the load is wrong here. It is using the cost of doing the gather.
; we can see the same cost being reused for the subsequent load instead of being zero.
; Generated HIR shows VLS wide load and shuffles.
; CMCHECK-NEXT:    Cost 24000 for i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]] ( OVLS )
; CMCHECK-NEXT:    Cost 16000 for i64 [[VP6:%.*]] = mul i64 2 i64 [[VP2]]
; CMCHECK-NEXT:    Cost 2000 for i64 [[VP7:%.*]] = add i64 [[VP6]] i64 1
; CMCHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[LP0]] i64 [[VP7]]
; CMCHECK-NEXT:    Cost 24000 for i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]] ( OVLS )
; CMCHECK-NEXT:    Cost 1000 for i32 [[VP8:%.*]] = add i32 [[VP_LOAD]] i32 [[VP4]]
; CMCHECK-NEXT:    Cost 1000 for i32 [[VP1]] = add i32 [[VP8]] i32 [[VP_LOAD_1]]
; CMCHECK-NEXT:    Cost 2000 for i64 [[VP3]] = add i64 [[VP2]] i64 [[VP__IND_INIT_STEP]]
; CMCHECK-NEXT:    Cost 16000 for i1 [[VP9:%.*]] = icmp sle i64 [[VP3]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CMCHECK-NEXT:    Cost 0 for br i1 [[VP9]], [[BB2]], [[BB3:BB[0-9]+]]
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB3]], total cost: 0
; CMCHECK-NEXT:    Cost Unknown for i32 [[VP__RED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP1]]
; CMCHECK-NEXT:    Cost Unknown for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 live-in1 i64 1
; CMCHECK-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CMCHECK-NEXT:  Analyzing VPBasicBlock [[BB4]], total cost: 0
; CMCHECK-NEXT:    Cost 0 for br <External Block>
;
; HIRCHECK-LABEL:  *** IR Dump After VPlan Vectorization Driver HIR{{.*}}***
; HIRCHECK-NEXT:  Function: foo
; HIRCHECK-EMPTY:
; HIRCHECK-NEXT:  <0>          BEGIN REGION { modified }
; HIRCHECK-NEXT:  <21>                  [[RED_VAR0:%.*]] = 0
; HIRCHECK-NEXT:  <22>                  [[RED_VAR0]] = insertelement [[RED_VAR0]],  [[SUM_0130:%.*]],  0
; HIRCHECK-NEXT:  <20>               + DO i1 = 0, 99, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; HIRCHECK-NEXT:  <23>               |   [[DOTCOPY0:%.*]] = [[RED_VAR0]]
; HIRCHECK-NEXT:  <24>               |   [[DOTVLS_LOAD0:%.*]] = (<8 x i32>*)([[LP0:%.*]])[2 * i1]
; HIRCHECK-NEXT:  <25>               |   [[VLS_SHUF0:%.*]] = shufflevector [[DOTVLS_LOAD0]],  undef,  <i32 0, i32 2, i32 4, i32 6>
; HIRCHECK-NEXT:  <26>               |   [[VLS_SHUF10:%.*]] = shufflevector [[DOTVLS_LOAD0]],  undef,  <i32 1, i32 3, i32 5, i32 7>
; HIRCHECK-NEXT:  <27>               |   [[DOTVEC0:%.*]] = [[VLS_SHUF0]]  +  [[DOTCOPY0]]
; HIRCHECK-NEXT:  <28>               |   [[RED_VAR0]] = [[DOTVEC0]]  +  [[VLS_SHUF10]]
; HIRCHECK-NEXT:  <20>               + END LOOP
; HIRCHECK-NEXT:  <29>                  [[SUM_0130]] = @llvm.vector.reduce.add.v4i32([[RED_VAR0]])
; HIRCHECK-NEXT:  <0>          END REGION
;
entry:
  br label %for.body

for.body:
  %l1.014 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %sum.013 = phi i32 [ 0, %entry ], [ %add4, %for.body ]
  %mul = shl nuw nsw i64 %l1.014, 1
  %ptridx = getelementptr inbounds i32, i32* %lp, i64 %mul
  %0 = load i32, i32* %ptridx, align 8
  %add = add nsw i32 %0, %sum.013
  %add2 = or i64 %mul, 1
  %ptridx3 = getelementptr inbounds i32, i32* %lp, i64 %add2
  %1 = load i32, i32* %ptridx3, align 8
  %add4 = add nsw i32 %add, %1
  %inc = add nuw nsw i64 %l1.014, 1
  %exitcond.not = icmp eq i64 %inc, 100
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  ret i32 %add4
}
