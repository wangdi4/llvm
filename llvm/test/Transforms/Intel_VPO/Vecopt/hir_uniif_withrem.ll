; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -disable-output -vplan-enable-masked-vectorized-remainder -print-after=hir-vplan-vec -hir-details %s 2>&1 | FileCheck %s

; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -disable-output -vplan-enable-masked-vectorized-remainder -print-after=hir-vplan-vec -hir-details %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Test to check that uniform IF is correctly marked as incoming for the main
; loop in presence of masked remainder.
;
; Incoming HIR
; BEGIN REGION { }
;   %1 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD()... ]
;    + DO i1 = 0, %N + -1, 1   <DO_LOOP> <simd>
;    |   if (%c1 <= i1)
;    |   {
;    |      if (%c1 == %c2)
;    |      {
;    |         %mul.58 = %f  /  5.0;
;    |      }
;    |      else
;    |      {
;    |         %0 = %f  *  5.0;
;    |      }
;    |   }
;    + END LOOP
;    @llvm.directive.region.exit(%1); [ DIR.OMP.END.SIMD() ]
;    ret ;
; END REGION

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #0

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #0

define hidden void @diffusivities_.DIR.OMP.DISTRIBUTE.PARLOOP.27.split1714.split(i32 %c1, i32 %c2, i64 %N, float %f) #1 {
; CHECK-LABEL:  Function: diffusivities_.DIR.OMP.DISTRIBUTE.PARLOOP.27.split1714.split
; CHECK:        [[CMP0:%.*]] = [[C10:%.*]] == [[C20:%.*]];
; CHECK:        <LVAL-REG> NON-LINEAR i1 [[CMP0]] {sb:21}
; CHECK:        <RVAL-REG> LINEAR i32 [[C10]] {sb:8}
; CHECK:        <RVAL-REG> LINEAR i32 [[C20]] {sb:10}
; CHECK:        + LiveIn symbases: 5, 8, 10, 11, 21, 22, 24, 25
; CHECK:        + DO i64 i1 = 0, [[LOOP_UB0:%.*]], 16   <DO_LOOP> <simd-vectorized> <nounroll> <novectorize>
; CHECK:        + END LOOP
; Here is the clone of CMP0 in remainder, it's correctly marked as livein
; CHECK:        [[CMP150:%.*]] = [[C10]] == [[C20]]
; CHECK:        <LVAL-REG> NON-LINEAR i1 [[CMP150]] {sb:35}
; CHECK:        <RVAL-REG> LINEAR i32 [[C10]] {sb:8}
; CHECK:        <RVAL-REG> LINEAR i32 [[C20]] {sb:10}
; CHECK:        + LiveIn symbases: 5, 8, 10, 11, 19, 25, 35, 36, 37
; CHECK:        + DO i64 i1 = [[PHI_TEMP0:%.*]], [[LOOP_UB170:%.*]], 16   <DO_LOOP>  <MAX_TC_EST = 1>  <LEGAL_MAX_TC = 1> <vector-remainder> <nounroll> <novectorize> <max_trip_count = 1>
; CHECK:        + END LOOP
DIR.OMP.DISTRIBUTE.PARLOOP.14.split:
  br label %DIR.OMP.SIMD.1

omp.pdo.body58:
  %omp.pdo.norm.iv260.local.01712 = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %add.55, %bb16_endif ]
  %int_sext113 = trunc i64 %omp.pdo.norm.iv260.local.01712 to i32
  %rel.22.not = icmp sgt i32 %c1, %int_sext113
  br i1 %rel.22.not, label %bb16_endif, label %bb_new63_then

bb_new71_then:
  %0 = fmul fast float %f, 0.5e+1
  br label %bb16_endif

bb_new74_else:
  %mul.58 = fdiv fast float %f, 0.5e+1
  br label %bb16_endif

bb_new63_then:
  %c_uni = icmp eq i32 %c1, %c2
  br i1 %c_uni, label %bb_new74_else, label %bb_new71_then

bb16_endif:
  %add.55 = add nuw nsw i64 %omp.pdo.norm.iv260.local.01712, 1
  %exitcond.not = icmp eq i64 %add.55, %N
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.216, label %omp.pdo.body58

DIR.OMP.SIMD.1:
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  br label %omp.pdo.body58

DIR.OMP.END.SIMD.216:
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

attributes #0 = { nounwind }
attributes #1 = { "target-features"="+avx,+avx2,+bmi,+bmi2,+crc32,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" }


