; INTEL_FEATURE_SW_ADVANCED
; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: intel_feature_sw_advanced
; RUN: opt < %s -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec' \
; RUN:     -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=8 \
; RUN:     -vplan-force-uf=4 -vplan-force-vf=8 \
; RUN:     -vplan-cm-unroll=true -vplan-cm-unroll-partial-sums-only=true \
; RUN:     -vplan-enable-partial-sums=true \
; RUN:     | FileCheck %s --check-prefix=CHECK-VF8-UF4

; RUN: opt < %s -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec' \
; RUN:     -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=8 \
; RUN:     -vplan-force-uf=8 -vplan-force-vf=8 \
; RUN:     -vplan-cm-unroll=true \
; RUN:     -vplan-enable-partial-sums=true \
; RUN:     | FileCheck %s --check-prefix=CHECK-VF8-UF8

; Basic checks for unroll heuristic for partial sums, which reduces the unrolled body cost
; for partial sum reductions proportionally to the ratio of the total reduction cost
; (including costs for non-reduction operands) to the total loop cost.
;
; The heuristic also adds an overhead for each partial sum candidate to reflect the
; cost of the tree-like reduction overhead added in the postexit.
;
; Four cases are covered:
;
; single_redn() is a simple dot-product loop, which we expect to have the largest cost decrease.
;
; single_redn_reuse() is a simple dot-product along with some extra non-reduction work which
;   reuses some of the computation for the dot product. We expect this to have a slightly lower
;   decrease than single_redn() due to the additional independent code.
;
; multi_redn() has 4 reductions, with no reuse between them. We expect a lower cost decrease for
;   each, as well as higher overhead.
;
; multi_redn_reuse() has 4 reductions, with no reuse between them. We expect this to have a lower
;   decrease than multi_redn().

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define float @single_redn(ptr nocapture noundef readonly %A, ptr nocapture noundef readonly %B, i32 noundef %n) local_unnamed_addr #0 {
;
; CHECK-VF8-UF4-LABEL:  Cost Model for VPlan single_redn:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in1 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB1]]: base cost: 4
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 4
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for i64 [[VP4:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP6:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP6]] float [[VP2]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP5]] = add i64 [[VP4]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF4-NEXT:    Cost 8 for i1 [[VP7:%.*]] = icmp slt i64 [[VP5]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br i1 [[VP7]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB2]]: base cost: 14.4375
; CHECK-VF8-UF4-NEXT:  Base Cost: 14.4375
; CHECK-VF8-UF4-NEXT:  Cost decrease due to Unroll heuristic is 6.984375
; CHECK-VF8-UF4-NEXT:  Total Cost: 7.453125
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP3]] float live-in0
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB3]]: base cost: 7
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF4-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 7
;
; CHECK-VF8-UF8-LABEL:  Cost Model for VPlan single_redn:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in1 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB1]]: base cost: 4
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 4
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for i64 [[VP4:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP6:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP6]] float [[VP2]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP5]] = add i64 [[VP4]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF8-NEXT:    Cost 8 for i1 [[VP7:%.*]] = icmp slt i64 [[VP5]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br i1 [[VP7]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB2]]: base cost: 14.4375
; CHECK-VF8-UF8-NEXT:  Base Cost: 14.4375
; CHECK-VF8-UF8-NEXT:  Cost decrease due to Unroll heuristic is 8.140625
; CHECK-VF8-UF8-NEXT:  Total Cost: 6.296875
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP3]] float live-in0
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB3]]: base cost: 11
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF8-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 11
;
entry:
  %cmp.not7 = icmp eq i32 %n, 0
  br i1 %cmp.not7, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:
  %0 = zext i32 %n to i64
  br label %for.body

for.cond.cleanup.loopexit:
  %add.lcssa = phi float [ %add, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:
  %acc.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %add.lcssa, %for.cond.cleanup.loopexit ]
  ret float %acc.0.lcssa

for.body:
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %acc.08 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv
  %1 = load float, ptr %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds float, ptr %B, i64 %indvars.iv
  %2 = load float, ptr %arrayidx2, align 4
  %mul = fmul fast float %2, %1
  %add = fadd fast float %mul, %acc.08
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp.not = icmp eq i64 %indvars.iv.next, %0
  br i1 %cmp.not, label %for.cond.cleanup.loopexit, label %for.body
}

define float @multi_redn(ptr nocapture noundef readonly %A, ptr nocapture noundef readonly %B, ptr nocapture noundef readonly %C, ptr nocapture noundef readonly %D, i32 noundef %n) local_unnamed_addr #0 {
;
; CHECK-VF8-UF4-LABEL:  Cost Model for VPlan multi_redn:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT_1:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT_2:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT_3:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in4 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB1]]: base cost: 7
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 7
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT_3]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP4:%.*]] = phi  [ float [[VP_RED_INIT_2]], [[BB1]] ],  [ float [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP6:%.*]] = phi  [ float [[VP_RED_INIT_1]], [[BB1]] ],  [ float [[VP7:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP8:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP9:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for i64 [[VP10:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP11:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP12:%.*]] = fmul float [[VP_LOAD]] float [[VP_LOAD]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP9]] = fadd float [[VP12]] float [[VP8]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP13:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD_1]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP7]] = fadd float [[VP13]] float [[VP6]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[C0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_2]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP14:%.*]] = fmul float [[VP_LOAD_2]] float [[VP_LOAD_2]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP5]] = fadd float [[VP14]] float [[VP4]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds ptr [[D0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD_3:%.*]] = load ptr [[VP_SUBSCRIPT_3]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP15:%.*]] = fmul float [[VP_LOAD_3]] float [[VP_LOAD_3]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP15]] float [[VP2]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP11]] = add i64 [[VP10]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF4-NEXT:    Cost 8 for i1 [[VP16:%.*]] = icmp slt i64 [[VP11]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br i1 [[VP16]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB2]]: base cost: 22.875
; CHECK-VF8-UF4-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 4
; CHECK-VF8-UF4-NEXT:  Base Cost: 22.875
; CHECK-VF8-UF4-NEXT:  Extra cost due to Spill/Fill heuristic is 32
; CHECK-VF8-UF4-NEXT:  Cost decrease due to Unroll heuristic is 6.375
; CHECK-VF8-UF4-NEXT:  Total Cost: 48.5
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP9]] float live-in0
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL_1:%.*]] = reduction-final{fadd} float [[VP7]] float live-in1
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL_2:%.*]] = reduction-final{fadd} float [[VP5]] float live-in2
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL_3:%.*]] = reduction-final{fadd} float [[VP3]] float live-in3
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB3]]: base cost: 28
; CHECK-VF8-UF4-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 16
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF4-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 28
;
; CHECK-VF8-UF8-LABEL:  Cost Model for VPlan multi_redn:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 64
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT_1:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT_2:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT_3:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in4 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB1]]: base cost: 7
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 64
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 7
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT_3]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP4:%.*]] = phi  [ float [[VP_RED_INIT_2]], [[BB1]] ],  [ float [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP6:%.*]] = phi  [ float [[VP_RED_INIT_1]], [[BB1]] ],  [ float [[VP7:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP8:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP9:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for i64 [[VP10:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP11:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP12:%.*]] = fmul float [[VP_LOAD]] float [[VP_LOAD]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP9]] = fadd float [[VP12]] float [[VP8]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP13:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD_1]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP7]] = fadd float [[VP13]] float [[VP6]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[C0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_2]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP14:%.*]] = fmul float [[VP_LOAD_2]] float [[VP_LOAD_2]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP5]] = fadd float [[VP14]] float [[VP4]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds ptr [[D0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD_3:%.*]] = load ptr [[VP_SUBSCRIPT_3]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP15:%.*]] = fmul float [[VP_LOAD_3]] float [[VP_LOAD_3]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP15]] float [[VP2]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP11]] = add i64 [[VP10]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF8-NEXT:    Cost 8 for i1 [[VP16:%.*]] = icmp slt i64 [[VP11]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br i1 [[VP16]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB2]]: base cost: 22.875
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 68
; CHECK-VF8-UF8-NEXT:  Base Cost: 22.875
; CHECK-VF8-UF8-NEXT:  Extra cost due to Spill/Fill heuristic is 352
; CHECK-VF8-UF8-NEXT:  Cost decrease due to Unroll heuristic is 7
; CHECK-VF8-UF8-NEXT:  Total Cost: 367.875
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP9]] float live-in0
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL_1:%.*]] = reduction-final{fadd} float [[VP7]] float live-in1
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL_2:%.*]] = reduction-final{fadd} float [[VP5]] float live-in2
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL_3:%.*]] = reduction-final{fadd} float [[VP3]] float live-in3
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB3]]: base cost: 44
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 80
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF8-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 64
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 44
;
entry:
  %cmp.not48 = icmp eq i32 %n, 0
  br i1 %cmp.not48, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %0 = zext i32 %n to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %add.lcssa = phi float [ %add, %for.body ]
  %add10.lcssa = phi float [ %add10, %for.body ]
  %add17.lcssa = phi float [ %add17, %for.body ]
  %add24.lcssa = phi float [ %add24, %for.body ]
  %1 = fadd fast float %add10.lcssa, %add.lcssa
  %2 = fmul fast float %add24.lcssa, %add17.lcssa
  %3 = fsub fast float %1, %2
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = phi float [ %3, %for.cond.cleanup.loopexit ], [ 0.000000e+00, %entry ]
  ret float %sub

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %acc.sroa.12.052 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add24, %for.body ]
  %acc.sroa.9.051 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add17, %for.body ]
  %acc.sroa.6.050 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add10, %for.body ]
  %acc.sroa.0.049 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv
  %4 = load float, ptr %arrayidx, align 4
  %mul = fmul fast float %4, %4
  %add = fadd fast float %mul, %acc.sroa.0.049
  %arrayidx5 = getelementptr inbounds float, ptr %B, i64 %indvars.iv
  %5 = load float, ptr %arrayidx5, align 4
  %mul8 = fmul fast float %5, %5
  %add10 = fadd fast float %mul8, %acc.sroa.6.050
  %arrayidx12 = getelementptr inbounds float, ptr %C, i64 %indvars.iv
  %6 = load float, ptr %arrayidx12, align 4
  %mul15 = fmul fast float %6, %6
  %add17 = fadd fast float %mul15, %acc.sroa.9.051
  %arrayidx19 = getelementptr inbounds float, ptr %D, i64 %indvars.iv
  %7 = load float, ptr %arrayidx19, align 4
  %mul22 = fmul fast float %7, %7
  %add24 = fadd fast float %mul22, %acc.sroa.12.052
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp.not = icmp eq i64 %indvars.iv.next, %0
  br i1 %cmp.not, label %for.cond.cleanup.loopexit, label %for.body
}

define float @multi_redn_reuse(ptr nocapture noundef readonly %A, ptr nocapture noundef readonly %B, i32 noundef %n) local_unnamed_addr #0 {
;
; CHECK-VF8-UF4-LABEL:  Cost Model for VPlan multi_redn_reuse:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT_1:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT_2:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT_3:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in4 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB1]]: base cost: 7
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 7
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT_3]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP4:%.*]] = phi  [ float [[VP_RED_INIT_2]], [[BB1]] ],  [ float [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP6:%.*]] = phi  [ float [[VP_RED_INIT_1]], [[BB1]] ],  [ float [[VP7:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP8:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP9:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for i64 [[VP10:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP11:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP12:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP9]] = fadd float [[VP12]] float [[VP8]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP7]] = fadd float [[VP12]] float [[VP6]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP5]] = fadd float [[VP12]] float [[VP4]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP12]] float [[VP2]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP11]] = add i64 [[VP10]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF4-NEXT:    Cost 8 for i1 [[VP13:%.*]] = icmp slt i64 [[VP11]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br i1 [[VP13]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB2]]: base cost: 17.4375
; CHECK-VF8-UF4-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 8
; CHECK-VF8-UF4-NEXT:  Base Cost: 17.4375
; CHECK-VF8-UF4-NEXT:  Extra cost due to Spill/Fill heuristic is 32
; CHECK-VF8-UF4-NEXT:  Cost decrease due to Unroll heuristic is 6
; CHECK-VF8-UF4-NEXT:  Total Cost: 43.4375
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP9]] float live-in0
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL_1:%.*]] = reduction-final{fadd} float [[VP7]] float live-in1
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL_2:%.*]] = reduction-final{fadd} float [[VP5]] float live-in2
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL_3:%.*]] = reduction-final{fadd} float [[VP3]] float live-in3
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB3]]: base cost: 28
; CHECK-VF8-UF4-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 16
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF4-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 28
;
; CHECK-VF8-UF8-LABEL:  Cost Model for VPlan multi_redn_reuse:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 64
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT_1:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT_2:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT_3:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in4 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB1]]: base cost: 7
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 64
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 7
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT_3]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP4:%.*]] = phi  [ float [[VP_RED_INIT_2]], [[BB1]] ],  [ float [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP6:%.*]] = phi  [ float [[VP_RED_INIT_1]], [[BB1]] ],  [ float [[VP7:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP8:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP9:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for i64 [[VP10:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP11:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP10]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP12:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP9]] = fadd float [[VP12]] float [[VP8]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP7]] = fadd float [[VP12]] float [[VP6]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP5]] = fadd float [[VP12]] float [[VP4]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP12]] float [[VP2]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP11]] = add i64 [[VP10]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF8-NEXT:    Cost 8 for i1 [[VP13:%.*]] = icmp slt i64 [[VP11]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br i1 [[VP13]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB2]]: base cost: 17.4375
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 72
; CHECK-VF8-UF8-NEXT:  Base Cost: 17.4375
; CHECK-VF8-UF8-NEXT:  Extra cost due to Spill/Fill heuristic is 352
; CHECK-VF8-UF8-NEXT:  Cost decrease due to Unroll heuristic is 7
; CHECK-VF8-UF8-NEXT:  Total Cost: 362.4375
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP9]] float live-in0
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL_1:%.*]] = reduction-final{fadd} float [[VP7]] float live-in1
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL_2:%.*]] = reduction-final{fadd} float [[VP5]] float live-in2
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL_3:%.*]] = reduction-final{fadd} float [[VP3]] float live-in3
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB3]]: base cost: 44
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 80
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF8-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 64
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 44
;
entry:
  %cmp.not50 = icmp eq i32 %n, 0
  br i1 %cmp.not50, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %0 = zext i32 %n to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %add.lcssa = phi float [ %add, %for.body ]
  %add10.lcssa = phi float [ %add10, %for.body ]
  %add17.lcssa = phi float [ %add17, %for.body ]
  %add24.lcssa = phi float [ %add24, %for.body ]
  %1 = fadd fast float %add10.lcssa, %add.lcssa
  %2 = fmul fast float %add24.lcssa, %add17.lcssa
  %3 = fsub fast float %1, %2
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = phi float [ %3, %for.cond.cleanup.loopexit ], [ 0.000000e+00, %entry ]
  ret float %sub

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %acc.sroa.12.054 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add24, %for.body ]
  %acc.sroa.9.053 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add17, %for.body ]
  %acc.sroa.6.052 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add10, %for.body ]
  %acc.sroa.0.051 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv
  %4 = load float, ptr %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds float, ptr %B, i64 %indvars.iv
  %5 = load float, ptr %arrayidx2, align 4
  %mul = fmul fast float %5, %4
  %add = fadd fast float %mul, %acc.sroa.0.051
  %add10 = fadd fast float %mul, %acc.sroa.6.052
  %add17 = fadd fast float %mul, %acc.sroa.9.053
  %add24 = fadd fast float %mul, %acc.sroa.12.054
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp.not = icmp eq i64 %indvars.iv.next, %0
  br i1 %cmp.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind memory(argmem: readwrite) uwtable
define dso_local nofpclass(nan inf) float @single_redn_reuse(ptr noalias nocapture noundef writeonly %Y, ptr noalias nocapture noundef readonly %A, ptr noalias nocapture noundef readonly %B, i32 noundef %n) local_unnamed_addr #1 {
;
; CHECK-VF8-UF4-LABEL:  Cost Model for VPlan single_redn_reuse:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in1 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB1]]: base cost: 4
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 4
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost Unknown for i64 [[VP4:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF4-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP6:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP6]] float [[VP2]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP7:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD_1]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP8:%.*]] = fmul float [[VP_LOAD]] float [[VP_LOAD]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP9:%.*]] = fadd float [[VP7]] float [[VP8]]
; CHECK-VF8-UF4-NEXT:    Cost 1 for float [[VP10:%.*]] = fadd float [[VP9]] float [[VP6]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[Y0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF4-NEXT:    Cost 1.4375 for store float [[VP10]] ptr [[VP_SUBSCRIPT_2]]
; CHECK-VF8-UF4-NEXT:    Cost 2 for i64 [[VP5]] = add i64 [[VP4]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF4-NEXT:    Cost 8 for i1 [[VP11:%.*]] = icmp slt i64 [[VP5]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br i1 [[VP11]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB2]]: base cost: 19.875
; CHECK-VF8-UF4-NEXT:  Base Cost: 19.875
; CHECK-VF8-UF4-NEXT:  Cost decrease due to Unroll heuristic is 6.03125
; CHECK-VF8-UF4-NEXT:  Total Cost: 13.84375
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF4-NEXT:    Cost 7 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP3]] float live-in0
; CHECK-VF8-UF4-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF4-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF4-NEXT:  [[BB3]]: base cost: 7
; CHECK-VF8-UF4-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF4-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF4-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF4-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 7
;
; CHECK-VF8-UF8-LABEL:  Cost Model for VPlan single_redn_reuse:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB0]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP0:%.*]] = add i64 [[VP1:%.*]] i64 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP0]], UF = 1
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP_RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in1 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB1]]: base cost: 4
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 4
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for float [[VP2:%.*]] = phi  [ float [[VP_RED_INIT]], [[BB1]] ],  [ float [[VP3:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost Unknown for i64 [[VP4:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP5:%.*]], [[BB2]] ]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF8-NEXT:    Cost 1.21875 for float [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP6:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP3]] = fadd float [[VP6]] float [[VP2]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP7:%.*]] = fmul float [[VP_LOAD_1]] float [[VP_LOAD_1]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP8:%.*]] = fmul float [[VP_LOAD]] float [[VP_LOAD]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP9:%.*]] = fadd float [[VP7]] float [[VP8]]
; CHECK-VF8-UF8-NEXT:    Cost 1 for float [[VP10:%.*]] = fadd float [[VP9]] float [[VP6]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[Y0:%.*]] i64 [[VP4]]
; CHECK-VF8-UF8-NEXT:    Cost 1.4375 for store float [[VP10]] ptr [[VP_SUBSCRIPT_2]]
; CHECK-VF8-UF8-NEXT:    Cost 2 for i64 [[VP5]] = add i64 [[VP4]] i64 [[VP__IND_INIT_STEP]]
; CHECK-VF8-UF8-NEXT:    Cost 8 for i1 [[VP11:%.*]] = icmp slt i64 [[VP5]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br i1 [[VP11]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB2]]: base cost: 19.875
; CHECK-VF8-UF8-NEXT:  Base Cost: 19.875
; CHECK-VF8-UF8-NEXT:  Cost decrease due to Unroll heuristic is 7.03125
; CHECK-VF8-UF8-NEXT:  Total Cost: 12.84375
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-VF8-UF8-NEXT:    Cost 11 for float [[VP_RED_FINAL:%.*]] = reduction-final{fadd} float [[VP3]] float live-in0
; CHECK-VF8-UF8-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-VF8-UF8-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-VF8-UF8-NEXT:  [[BB3]]: base cost: 11
; CHECK-VF8-UF8-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-VF8-UF8-NEXT:    Cost 0 for br <External Block>
; CHECK-VF8-UF8-NEXT:  [[BB4]]: base cost: 0
; CHECK-VF8-UF8-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 11
;
entry:
  %cmp.not39 = icmp eq i32 %n, 0
  br i1 %cmp.not39, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %0 = zext i32 %n to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %add.lcssa = phi float [ %add, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %acc.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %add.lcssa, %for.cond.cleanup.loopexit ]
  ret float %acc.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %acc.040 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add, %for.body ]
  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv
  %1 = load float, ptr %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds float, ptr %B, i64 %indvars.iv
  %2 = load float, ptr %arrayidx2, align 4
  %mul = fmul fast float %2, %1
  %add = fadd fast float %mul, %acc.040
  %mul12 = fmul fast float %2, %2
  %mul18 = fmul fast float %1, %1
  %add13 = fadd fast float %mul12, %mul18
  %add19 = fadd fast float %add13, %mul
  %arrayidx21 = getelementptr inbounds float, ptr %Y, i64 %indvars.iv
  store float %add19, ptr %arrayidx21, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp.not = icmp eq i64 %indvars.iv.next, %0
  br i1 %cmp.not, label %for.cond.cleanup.loopexit, label %for.body
}

; end INTEL_FEATURE_SW_ADVANCED
