; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: asserts
; RUN: opt < %s -passes="vplan-func-vec" -enable-vplan-func-vec-all-zero-bypass-loops -enable-vplan-func-vec-all-zero-bypass-non-loops -print-after-vplan-func-vec-all-zero-bypass -disable-output -S 2>&1 | FileCheck %s

; This test has an outer non-loop bypass region and an inner loop bypass region
; that share the same region exit block. Since loop bypasses are collected first
; this test checks to make sure that all-zero bypass inserts the regions in
; correct order because if the nested loop region is inserted first, then the
; CFG will change and the exit block will no longer be the same for the outer
; region. It is always safe to insert regions from outermost to innermost and
; this test checks that this happens.

declare i64 @llvm.vplan.laneid()

define dso_local void @foo(ptr nocapture readonly %a, ptr nocapture readonly %b, ptr nocapture %c, i32 %x, i32 %y) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after all-zero bypass for VPlan Function vectorization:
; CHECK-NEXT:  VPlan IR for: foo
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i32 [[VP_SUB:%.*]] = sub i32 [[X0:%.*]] i32 [[Y0:%.*]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_ADD7:%.*]] = add i32 [[Y0]] i32 [[X0]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i64 [[VP_LANE:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     [DA: Div] ptr [[VP_PTRIDX:%.*]] = getelementptr inbounds i32, ptr [[A0:%.*]] i64 [[VP_LANE]]
; CHECK-NEXT:     [DA: Div] i32 [[VP0:%.*]] = load ptr [[VP_PTRIDX]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_CMP1:%.*]] = icmp sgt i32 [[VP0]] i32 [[X0]]
; CHECK-NEXT:     [DA: Uni] br all.zero.bypass.begin10
; CHECK-EMPTY:
; CHECK-NEXT:    all.zero.bypass.begin10: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_ALL_ZERO_CHECK:%.*]] = all-zero-check i1 [[VP_CMP1]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_ALL_ZERO_CHECK]], all.zero.bypass.end12, [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: all.zero.bypass.begin10
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_CMP1]]
; CHECK-NEXT:       [DA: Div] ptr [[VP_PTRIDX3:%.*]] = getelementptr inbounds i32, ptr [[C0:%.*]] i64 [[VP_LANE]]
; CHECK-NEXT:       [DA: Div] store i32 [[VP_SUB]] ptr [[VP_PTRIDX3]]
; CHECK-NEXT:       [DA: Div] i32 [[VP2:%.*]] = load ptr [[VP_PTRIDX]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_CMP631:%.*]] = icmp sgt i32 [[VP2]] i32 0
; CHECK-NEXT:       [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_BR_VP_CMP631:%.*]] = select i1 [[VP_CMP1]] i1 [[VP_CMP631]] i1 false
; CHECK-NEXT:       [DA: Uni] br all.zero.bypass.begin14
; CHECK-EMPTY:
; CHECK-NEXT:      all.zero.bypass.begin14: # preds: [[BB3]]
; CHECK-NEXT:       [DA: Uni] i1 [[VP_ALL_ZERO_CHECK_1:%.*]] = all-zero-check i1 [[VP_BB3_BR_VP_CMP631]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_ALL_ZERO_CHECK_1]], all.zero.bypass.end16, [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB4]]: # preds: all.zero.bypass.begin14
; CHECK-NEXT:         [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP631]]
; CHECK-NEXT:         [DA: Div] ptr [[VP_PTRIDX9:%.*]] = getelementptr inbounds ptr, ptr [[B0:%.*]] i64 [[VP_LANE]]
; CHECK-NEXT:         [DA: Div] ptr [[VP4:%.*]] = load ptr [[VP_PTRIDX9]]
; CHECK-NEXT:         [DA: Uni] br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB5]]: # preds: [[BB5]], [[BB4]]
; CHECK-NEXT:         [DA: Uni] i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 0, [[BB4]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB5]] ]
; CHECK-NEXT:         [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP631]]
; CHECK-NEXT:         [DA: Div] ptr [[VP_PTRIDX11:%.*]] = getelementptr inbounds i32, ptr [[VP4]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:         [DA: Div] store i32 [[VP_ADD7]] ptr [[VP_PTRIDX11]]
; CHECK-NEXT:         [DA: Uni] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 1
; CHECK-NEXT:         [DA: Uni] i64 [[VP6:%.*]] = sext i32 [[X0]] to i64
; CHECK-NEXT:         [DA: Uni] i1 [[VP_CMP6:%.*]] = icmp slt i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP6]]
; CHECK-NEXT:         [DA: Uni] i1 [[VP7:%.*]] = all-zero-check i1 [[VP_BB3_BR_VP_CMP631]]
; CHECK-NEXT:         [DA: Uni] i1 [[VP8:%.*]] = not i1 [[VP7]]
; CHECK-NEXT:         [DA: Uni] i1 [[VP9:%.*]] = and i1 [[VP8]] i1 [[VP_CMP6]]
; CHECK-NEXT:         [DA: Uni] br i1 [[VP9]], [[BB5]], [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:         [DA: Div] i1 [[VP10:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_CMP631]]
; CHECK-NEXT:         [DA: Uni] br all.zero.bypass.end16
; CHECK-EMPTY:
; CHECK-NEXT:      all.zero.bypass.end16: # preds: [[BB6]], all.zero.bypass.begin14
; CHECK-NEXT:       [DA: Uni] br all.zero.bypass.end12
; CHECK-EMPTY:
; CHECK-NEXT:    all.zero.bypass.end12: # preds: all.zero.bypass.begin10, all.zero.bypass.end16
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: all.zero.bypass.end12
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;              entry
;                |
;            outer.if (D)
;             /       \
;         if.then (D)  |
;          /        |  |
;         /         |  |
;   for.body.ph     |  |
;         \         |  |
;          \        |  |
;      ->for.body   |  |
;      |___|  |     |  |
;             |     |  |
;          loopexit |  |
;             |    /  /
;             |   /  /
;             |  /  /
;            exit --
  %sub = sub nsw i32 %x, %y
  %add7 = add nsw i32 %y, %x
  br label %outer.if

outer.if:
  %lane = call i64 @llvm.vplan.laneid()
  %ptridx = getelementptr inbounds i32, ptr %a, i64 %lane
  %0 = load i32, ptr %ptridx, align 4
  %cmp1 = icmp sgt i32 %0, %x
  br i1 %cmp1, label %if.then, label %exit

if.then:
  %ptridx3 = getelementptr inbounds i32, ptr %c, i64 %lane
  store i32 %sub, ptr %ptridx3, align 4
  %1 = load i32, ptr %ptridx, align 4
  %cmp631 = icmp sgt i32 %1, 0
  br i1 %cmp631, label %for.body.ph, label %exit

for.body.ph:
  %ptridx9 = getelementptr inbounds ptr, ptr %b, i64 %lane
  %2 = load ptr, ptr %ptridx9, align 8
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ 0, %for.body.ph ], [ %indvars.iv.next, %for.body ]
  %ptridx11 = getelementptr inbounds i32, ptr %2, i64 %indvars.iv
  store i32 %add7, ptr %ptridx11, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %3 = sext i32 %x to i64
  %cmp6 = icmp slt i64 %indvars.iv.next, %3
  br i1 %cmp6, label %for.body, label %loopexit

loopexit:
  br label %exit

exit:
  ret void
}
