; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -print-after=hir-vplan-vec -vplan-force-vf=4 -vplan-print-after-plain-cfg -S -disable-output  < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -vplan-force-vf=4 -vplan-print-after-plain-cfg -S -disable-output < %s 2>&1 | FileCheck %s

; This test checks how we decompose invariant HLIfs.

define void @test1(i64* %arr, i64 %n1, i64 %n2) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: test1:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {if ((%n1 * %n2) == 0)}
; CHECK-DAG:     [[VP1:%.*]] = {%arr}
; CHECK-NEXT:  External Defs End:
; Condition isn't decomposed.
; CHECK:          br i1 [[VP0]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK:       Function: test1
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        + DO i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   if (([[N10:%.*]] * [[N20:%.*]]) == 0)
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      (<4 x i64>*)([[ARR0:%.*]])[i1] = i1 + <i64 0, i64 1, i64 2, i64 3>
; CHECK-NEXT:        |   }
; CHECK-NEXT:        |   else
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      (<4 x i64>*)([[ARR0]])[2 * i1 + 2 * <i64 0, i64 1, i64 2, i64 3>] = i1 + <i64 0, i64 1, i64 2, i64 3>
; CHECK-NEXT:        |   }
; CHECK-NEXT:        + END LOOP
; CHECK:             ret
; CHECK-NEXT:  END REGION
;
bb:
  %m = mul i64 %n1, %n2
  br label %entry

entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i64 4) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %tobool = icmp eq i64 %m, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:
  %arrayidx = getelementptr inbounds i64, i64* %arr, i64 %iv
  store i64 %iv, i64* %arrayidx, align 4
  br label %latch

if.else:
  %idx = mul i64 %iv, 2
  %arrayidx2 = getelementptr inbounds i64, i64* %arr, i64 %idx
  store i64 %iv, i64* %arrayidx2, align 4
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 100
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @test2(i64* %arr, i64 %n1, i64 %n2, i64 %n3) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: test2:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {((%n1 /u %n2) * %n3)}
; CHECK-DAG:     [[VP1:%.*]] = {%arr}
; CHECK-NEXT:  External Defs End:
; Condition is decomposed. We still create a VPExternalDef for a CanonExpr, but
; that is CG'ed *inside* the loop, so it's fine.
; CHECK:            i1 [[VP5:%.*]] = icmp eq i64 [[VP0]] i64 0
; CHECK-NEXT:       br i1 [[VP5]], [[BB5:BB[0-9]+]], [[BB6:BB[0-9]+]]
; Our VPlanHIRCG bailsout on integer division.
; CHECK:       Function: test2
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { }
; CHECK-NEXT:        [[TOK0:%.*]] = @llvm.directive.region.entry()
; CHECK:             + DO i1 = 0, 99, 1   <DO_LOOP> <simd> <vectorize>
; CHECK-NEXT:        |   if (i1 != 42)
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      if ((([[N10:%.*]] /u [[N20:%.*]]) * [[N30:%.*]]) == 0)
; CHECK-NEXT:        |      {
; CHECK-NEXT:        |         ([[ARR0]])[2 * i1] = i1
; CHECK-NEXT:        |      }
; CHECK-NEXT:        |      else
; CHECK-NEXT:        |      {
; CHECK-NEXT:        |         ([[ARR0]])[i1] = i1
; CHECK-NEXT:        |      }
; CHECK-NEXT:        |   }
; CHECK-NEXT:        + END LOOP
; CHECK:             @llvm.directive.region.exit([[TOK0]])
; CHECK-NEXT:        ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i64 4) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cmp = icmp eq i64 %iv, 42
  br i1 %cmp, label %latch, label %mask

mask:
  ; Cannot form VPExternalDef for this HLIf because udiv isn't hoistable.
  %d = udiv i64 %n1, %n2
  %m = mul i64 %d, %n3
  %tobool = icmp eq i64 %m, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:
  %arrayidx = getelementptr inbounds i64, i64* %arr, i64 %iv
  store i64 %iv, i64* %arrayidx, align 4
  br label %latch

if.else:
  %idx = mul i64 %iv, 2
  %arrayidx2 = getelementptr inbounds i64, i64* %arr, i64 %idx
  store i64 %iv, i64* %arrayidx2, align 4
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 100
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @test3(i64* %arr, i64 %n1, i64 %n2) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: test3:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%arr}
; CHECK-DAG:     [[VP1:%.*]] = {if (%n1 == 42 && %n2 == 42)}
; CHECK-NEXT:  External Defs End:
; Condition isn't decomposed.
; CHECK:          br i1 [[VP1]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK:       Function: test3
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        + DO i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   if ([[N10:%.*]] == 42 && [[N20:%.*]] == 42)
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      (<4 x i64>*)([[ARR0]])[i1] = i1 + <i64 0, i64 1, i64 2, i64 3>
; CHECK-NEXT:        |   }
; CHECK-NEXT:        |   else
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      (<4 x i64>*)([[ARR0]])[2 * i1 + 2 * <i64 0, i64 1, i64 2, i64 3>] = i1 + <i64 0, i64 1, i64 2, i64 3>
; CHECK-NEXT:        |   }
; CHECK-NEXT:        + END LOOP
; CHECK:             ret
; CHECK-NEXT:  END REGION
;
bb:
  br label %entry

entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i64 4) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cmp1 = icmp eq i64 %n1, 42
  %cmp2 = icmp eq i64 %n2, 42
  %cond = and i1 %cmp1, %cmp2
  br i1 %cond, label %if.then, label %if.else

if.then:
  %arrayidx = getelementptr inbounds i64, i64* %arr, i64 %iv
  store i64 %iv, i64* %arrayidx, align 4
  br label %latch

if.else:
  %idx = mul i64 %iv, 2
  %arrayidx2 = getelementptr inbounds i64, i64* %arr, i64 %idx
  store i64 %iv, i64* %arrayidx2, align 4
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 100
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
