; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; REQUIRES: asserts
; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -vplan-plain-dump -vplan-entities-dump -enable-mmindex=1  -disable-nonlinear-mmindex=0 -vplan-print-after-vpentity-instrs -vplan-force-vf=4 -S < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -vplan-plain-dump -vplan-entities-dump -enable-mmindex=1 -disable-nonlinear-mmindex=0 -vplan-print-after-vpentity-instrs -vplan-force-vf=4 -S < %s 2>&1 | FileCheck %s
; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -vplan-plain-dump -vplan-entities-dump -enable-mmindex=1  -disable-nonlinear-mmindex=1 -print-after=hir-vplan-vec  -vplan-force-vf=4 -S < %s 2>&1 | FileCheck --check-prefixes=DISABLED %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -vplan-plain-dump -vplan-entities-dump -enable-mmindex=1 -disable-nonlinear-mmindex=1 -print-after=hir-vplan-vec -vplan-force-vf=4 -S < %s 2>&1 | FileCheck --check-prefixes=DISABLED %s

; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -enable-mmindex=1 -disable-nonlinear-mmindex=0 -vplan-force-vf=4  -S -print-after=hir-vplan-vec  < %s 2>&1 | FileCheck --check-prefixes=CG_ENABLE %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -enable-mmindex=1 -disable-nonlinear-mmindex=0 -vplan-force-vf=4 -S -print-after=hir-vplan-vec < %s 2>&1 | FileCheck --check-prefixes=CG_ENABLE %s

;
; CHECK:       External Defs Start:
; CHECK:         [[VPMPLUS:%.*]] = {%m + -1}
; CHECK:       External Defs End:
; CHECK:  Reduction list
; CHECK-NEXT:   signed (SIntMax) Start: i32 [[BEST_0230:%.*]] Exit: i32 [[VP0:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP1:%.*]], i32 [[VP0]], i32 [[VP__RED_INIT:%.*]], i32 [[VP__RED_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK-NEXT:   signed (SIntMin) Start: i32 [[TMP_0240:%.*]] Exit: i32 [[VP2:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP3:%.*]], i32 [[VP2]], i32 [[VP__RED_INIT_1:%.*]], i32 [[VP__RED_FINAL_1:%.*]],
; CHECK-NEXT:   IsLinearIndex: 1  Parent exit: i32 [[VP0]]
; CHECK-NEXT:   signed (SIntMin) Start: i32 [[VAL_0250:%.*]] Exit: i32 [[VP4:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP5:%.*]], i32 [[VP4]], i32 [[VP__RED_INIT_2:%.*]], i32 [[VP__RED_FINAL_2:%.*]],
; CHECK-NEXT:   IsLinearIndex: 0  Parent exit: i32 [[VP2]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i32 0 Step: i32 1 StartVal: i32 0 EndVal: ? BinOp: i32 [[VP6:%.*]] = add i32 [[VP7:%.*]] i32 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP7]], i32 [[VP6]], i32 [[VP__IND_INIT:%.*]], i32 [[VP__IND_FINAL:%.*]],
; CHECK:    [[BB1:BB[0-9]+]]:
; CHECK:    [[BB2:BB[0-9]+]]:
; CHECK-NEXT:     i32 [[VP__RED_INIT]] = reduction-init i32 [[BEST_0230]]
; CHECK-NEXT:     i32 [[VP__RED_INIT_1]] = reduction-init i32 [[TMP_0240]]
; CHECK-NEXT:     i32 [[VP__RED_INIT_2]] = reduction-init i32 [[VAL_0250]]
; CHECK-NEXT:     i32 [[VP__IND_INIT]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP__IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     i32 [[VP5]] = phi  [ i32 [[VP__RED_INIT_2]], [[BB2]] ],  [ i32 [[VP4]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP3]] = phi  [ i32 [[VP__RED_INIT_1]], [[BB2]] ],  [ i32 [[VP2]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP1]] = phi  [ i32 [[VP__RED_INIT]], [[BB2]] ],  [ i32 [[VP0]], [[BB0]] ]
; CHECK-NEXT:     i32 [[VP7]] = phi  [ i32 [[VP__IND_INIT]], [[BB2]] ],  [ i32 [[VP6]], [[BB0]] ]
; CHECK-NEXT:     i64 [[VP9:%.*]] = sext i32 [[VP7]] to i64
; CHECK-NEXT:     i32* [[VP10:%.*]] = subscript inbounds i32* [[ORDERING0:%.*]] i64 [[VP9]]
; CHECK-NEXT:     i32 [[VP11:%.*]] = load i32* [[VP10]]
; CHECK-NEXT:     i1 [[VP12:%.*]] = icmp sgt i32 [[VP11]] i32 [[VP1]]
; CHECK-NEXT:     i32 [[VP2]] = select i1 [[VP12]] i32 [[VP7]] i32 [[VP3]]
; CHECK-NEXT:     i32 [[VP13:%.*]] = add i32 [[VP11]] i32 2
; CHECK-NEXT:     i1 [[VP14:%.*]] = icmp sgt i32 [[VP11]] i32 [[VP1]]
; CHECK-NEXT:     i32 [[VP4]] = select i1 [[VP14]] i32 [[VP13]] i32 [[VP5]]
; CHECK-NEXT:     i1 [[VP15:%.*]] = icmp sgt i32 [[VP11]] i32 [[VP1]]
; CHECK-NEXT:     i32 [[VP0]] = select i1 [[VP15]] i32 [[VP11]] i32 [[VP1]]
; CHECK-NEXT:     i32 [[VP6]] = add i32 [[VP7]] i32 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP16:%.*]] = icmp sle i32 [[VP6]] i32 [[VPMPLUS]]
; CHECK:    [[BB3:BB[0-9]+]]:
; CHECK-NEXT:     i32 [[VP__RED_FINAL]] = reduction-final{u_smax} i32 [[VP0]]
; CHECK-NEXT:     i32 [[VP__RED_FINAL_1]] = reduction-final{s_smin} i32 [[VP2]] i32 [[VP0]] i32 [[VP__RED_FINAL]]
; CHECK-NEXT:     i32 [[VP__RED_FINAL_2]] = reduction-final{s_smin} i32 [[VP4]] i32 [[VP2]] i32 [[VP__RED_FINAL_1]]
; CHECK-NEXT:     i32 [[VP__IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK: <4 x
;
; DISABLED-NOT: <4 x
;
;CG_ENABLE: Function: maxloc
;CG_ENABLE-EMPTY:
;CG_ENABLE-NEXT: BEGIN REGION { modified }
;CG_ENABLE-NEXT:       %tgu = (%m)/u4;
;CG_ENABLE-NEXT:       if (0 <u 4 * %tgu)
;CG_ENABLE-NEXT:       {
;CG_ENABLE-NEXT:          %red.var = %best.023;
;CG_ENABLE-NEXT:          %red.var1 = %tmp.024;
;CG_ENABLE-NEXT:          %red.var2 = %val.025;
;CG_ENABLE:               + DO i1 = 0, 4 * %tgu + -1, 4   <DO_LOOP>  <MAX_TC_EST = 1073741823> <auto-vectorized> <nounroll> <novectorize>
;CG_ENABLE-NEXT:          |   %.vec = (<4 x i32>*)(%ordering)[i1];
;CG_ENABLE-NEXT:          |   %red.var1 = (%.vec > %red.var) ? i1 + <i32 0, i32 1, i32 2, i32 3> : %red.var1;
;CG_ENABLE-NEXT:          |   %red.var2 = (%.vec > %red.var) ? %.vec + 2 : %red.var2;
;CG_ENABLE-NEXT:          |   %red.var = (%.vec > %red.var) ? %.vec : %red.var;
;CG_ENABLE-NEXT:          + END LOOP
;CG_ENABLE:               %best.023 = @llvm.vector.reduce.smax.v4i32(%red.var);
;CG_ENABLE-NEXT:          %idx.blend = (%best.023 == %red.var) ? %red.var1 : <i32 2147483647, i32 2147483647, i32 2147483647, i32 2147483647>;
;CG_ENABLE-NEXT:          %tmp.024 = @llvm.vector.reduce.smin.v4i32(%idx.blend);
;CG_ENABLE-NEXT:          %mmidx.cmp. = %tmp.024 == %red.var1;
;CG_ENABLE-NEXT:          %bsfintmask = bitcast.<4 x i1>.i4(%mmidx.cmp.);
;CG_ENABLE-NEXT:          %bsf = @llvm.cttz.i4(%bsfintmask,  1);
;CG_ENABLE-NEXT:          %val.025 = extractelement %red.var2,  %bsf;
;CG_ENABLE-NEXT:       }
;CG_ENABLE:            + DO i1 = 4 * %tgu, %m + -1, 1   <DO_LOOP>  <MAX_TC_EST = 3> <nounroll> <novectorize> <max_trip_count = 3>
;CG_ENABLE-NEXT:       |   %0 = (%ordering)[i1];
;CG_ENABLE-NEXT:       |   %tmp.024 = (%0 > %best.023) ? i1 : %tmp.024;
;CG_ENABLE-NEXT:       |   %val.025 = (%0 > %best.023) ? %0 + 2 : %val.025;
;CG_ENABLE-NEXT:       |   %best.023 = (%0 > %best.023) ? %0 : %best.023;
;CG_ENABLE-NEXT:       + END LOOP
;CG_ENABLE-NEXT: END REGION

; source code
;int ordering[1000];
;int  maxloc (int m) {
;    int best = -111111111;
;    int tmp = 0;
;    int val = 0;
;    for (int i=0; i< m; i++) {
;        if (ordering[i] > best) {
;            best = ordering[i];
;            tmp = i;
;            val = ordering[i]+2;
;        }
;    }
;    return tmp + best+val;
;}
; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @maxloc(i32 %m, i32* nocapture readonly %ordering) local_unnamed_addr #0 {
entry:
  %cmp22 = icmp sgt i32 %m, 0
  br i1 %cmp22, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
;  %wide.trip.count = sext i32 %m to i64
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv = phi i32 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %val.025 = phi i32 [ 0, %for.body.preheader ], [ %spec.select21, %for.body ]
  %tmp.024 = phi i32 [ 0, %for.body.preheader ], [ %spec.select20, %for.body ]
  %best.023 = phi i32 [ -111111111, %for.body.preheader ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %ordering, i32 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %cmp1 = icmp sgt i32 %0, %best.023
  %add = add nsw i32 %0, 2
  %spec.select = select i1 %cmp1, i32 %0, i32 %best.023
  %spec.select20 = select i1 %cmp1, i32 %indvars.iv, i32 %tmp.024
  %spec.select21 = select i1 %cmp1, i32 %add, i32 %val.025
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, %m
  br i1 %exitcond, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %for.body
  %spec.select.lcssa = phi i32 [ %spec.select, %for.body ]
  %spec.select20.lcssa = phi i32 [ %spec.select20, %for.body ]
  %spec.select21.lcssa = phi i32 [ %spec.select21, %for.body ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %best.0.lcssa = phi i32 [ -111111111, %entry ], [ %spec.select.lcssa, %for.end.loopexit ]
  %tmp.0.lcssa = phi i32 [ 0, %entry ], [ %spec.select20.lcssa, %for.end.loopexit ]
  %val.0.lcssa = phi i32 [ 0, %entry ], [ %spec.select21.lcssa, %for.end.loopexit ]
  %add6 = add nsw i32 %tmp.0.lcssa, %best.0.lcssa
  %add7 = add nsw i32 %add6, %val.0.lcssa
  ret i32 %add6
};
attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+avx,+avx2,+bmi,+bmi2,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" "unsafe-fp-math"="false" "use-soft-float"="false" }

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"icx (ICX) dev.8.x.0"}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}

