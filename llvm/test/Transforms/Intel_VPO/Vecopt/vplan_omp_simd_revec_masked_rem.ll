; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt %s -S -passes=vplan-vec -vplan-nested-simd-strategy=innermost -vplan-force-vf=2 -vplan-force-loop-vf="1:8" | FileCheck %s --check-prefix=INNER
; RUN: opt %s -S -passes=vplan-vec -vplan-nested-simd-strategy=frominside -vplan-force-vf=2 -vplan-force-loop-vf="1:8" | FileCheck %s

define void @foo(ptr %a) {
; INNER-LABEL: define void @foo
;
; Main loop
;
; INNER:       vector.body:
; INNER-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VPLANNEDBB2:%.*]] ], [ [[TMP2:%.*]], [[VECTOR_BODY:%.*]] ]
; INNER-NEXT:    [[VEC_PHI:%.*]] = phi <8 x i32> [ <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>, [[VPLANNEDBB2]] ], [ [[TMP1:%.*]], [[VECTOR_BODY]] ]
; INNER-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr i32, ptr [[ARR:%.*]], i32 [[UNI_PHI]]
; INNER-NEXT:    [[TMP0:%.*]] = add <8 x i32> [[BROADCAST_SPLAT:%.*]], [[VEC_PHI]]
; INNER-NEXT:    store <8 x i32> [[TMP0]], ptr [[SCALAR_GEP]], align 4
; INNER-NEXT:    [[TMP1]] = add nuw nsw <8 x i32> [[VEC_PHI]], <i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8>
; INNER-NEXT:    [[TMP2]] = add nuw nsw i32 [[UNI_PHI]], 8
; INNER-NEXT:    [[TMP3:%.*]] = icmp uge i32 [[TMP2]], 56
; INNER-NEXT:    br i1 [[TMP3]], label [[VPLANNEDBB4:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
;
; Masked mode remainder
;
; INNER:       VPlannedBB10:
; INNER-NEXT:    [[UNI_PHI11:%.*]] = phi i32 [ 0, [[VPLANNEDBB9:%.*]] ], [ [[TMP9:%.*]], [[NEW_LATCH:%.*]] ]
; INNER-NEXT:    [[VEC_PHI12:%.*]] = phi <8 x i32> [ <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>, [[VPLANNEDBB9]] ], [ [[TMP8:%.*]], [[NEW_LATCH]] ]
; INNER-NEXT:    [[TMP5:%.*]] = add nuw nsw <8 x i32> [[VEC_PHI12]], [[BROADCAST_SPLAT14:%.*]]
; INNER-NEXT:    [[DOTEXTRACT_0_:%.*]] = extractelement <8 x i32> [[TMP5]], i32 0
; INNER-NEXT:    [[TMP6:%.*]] = icmp ult <8 x i32> [[VEC_PHI12]], [[BROADCAST_SPLAT16:%.*]]
; INNER-NEXT:    br label [[VPLANNEDBB17:%.*]]
; INNER:       VPlannedBB17:
; INNER-NEXT:    [[SCALAR_GEP18:%.*]] = getelementptr i32, ptr [[ARR]], i32 [[DOTEXTRACT_0_]]
; INNER-NEXT:    [[TMP7:%.*]] = add <8 x i32> [[BROADCAST_SPLAT20:%.*]], [[TMP5]]
; INNER-NEXT:    call void @llvm.masked.store.v8i32.p0(<8 x i32> [[TMP7]], ptr [[SCALAR_GEP18]], i32 4, <8 x i1> [[TMP6]])
; INNER-NEXT:    br label [[NEW_LATCH]]
; INNER:       new_latch:
; INNER-NEXT:    [[TMP8]] = add nuw nsw <8 x i32> [[VEC_PHI12]], <i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8>
; INNER-NEXT:    [[TMP9]] = add nuw nsw i32 [[UNI_PHI11]], 8
; INNER-NEXT:    [[TMP10:%.*]] = icmp ult <8 x i32> [[TMP8]], [[BROADCAST_SPLAT16]]
; INNER-NEXT:    [[TMP11:%.*]] = bitcast <8 x i1> [[TMP10]] to i8
; INNER-NEXT:    [[TMP12:%.*]] = icmp eq i8 [[TMP11]], 0
; INNER-NEXT:    br i1 [[TMP12]], label [[VPLANNEDBB21:%.*]], label [[VPLANNEDBB10:%.*]]
;
; CHECK-LABEL: define void @foo
;
; Main loop (re-vectorized)
;
; CHECK:       VPlannedBB35:
; CHECK-NEXT:    [[UNI_PHI36:%.*]] = phi i32 [ 0, [[VPLANNEDBB34:%.*]] ], [ [[TMP3:%.*]], [[VPLANNEDBB35:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI37:%.*]] = phi <8 x i32> [ <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>, [[VPLANNEDBB34]] ], [ [[TMP2:%.*]], [[VPLANNEDBB35]] ]
; CHECK-NEXT:    [[REPLICATEDVAL_UNI_PHI37UNI_PHI37:%.*]] = shufflevector <8 x i32> [[UNI_PHI37]], <8 x i32> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT38:%.*]] = insertelement <2 x i32> poison, i32 [[UNI_PHI36]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT39:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT38]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[MM_VECTORGEP:%.*]] = getelementptr i32, <2 x ptr> [[WIDE_LOAD:%.*]], <2 x i32> [[BROADCAST_SPLAT39]]
; CHECK-NEXT:    [[TMP1:%.*]] = add <16 x i32> [[TMP0:%.*]], [[REPLICATEDVAL_UNI_PHI37UNI_PHI37]]
; CHECK-NEXT:    [[VECBASEPTR_MM_VECTORGEP:%.*]] = shufflevector <2 x ptr> [[MM_VECTORGEP]], <2 x ptr> undef, <16 x i32> <i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
; CHECK-NEXT:    [[ELEMBASEPTR_:%.*]] = getelementptr i32, <16 x ptr> [[VECBASEPTR_MM_VECTORGEP]], <16 x i64> <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7>
; CHECK-NEXT:    call void @llvm.masked.scatter.v16i32.v16p0(<16 x i32> [[TMP1]], <16 x ptr> [[ELEMBASEPTR_]], i32 4, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>)
; CHECK-NEXT:    [[TMP2]] = add <8 x i32> [[UNI_PHI37]], <i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8>
; CHECK-NEXT:    [[TMP3]] = add i32 [[UNI_PHI36]], 8
; CHECK-NEXT:    [[TMP4:%.*]] = icmp uge i32 [[TMP3]], 56
; CHECK-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB40:%.*]], label [[VPLANNEDBB35]]
;
; Masked mode remainder (re-vectorized)
;
; CHECK:       VPlannedBB55:
; CHECK-NEXT:    [[UNI_PHI56:%.*]] = phi i32 [ 0, [[VPLANNEDBB50:%.*]] ], [ [[TMP13:%.*]], [[VPLANNEDBB62:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI57:%.*]] = phi <8 x i32> [ <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>, [[VPLANNEDBB50]] ], [ [[TMP12:%.*]], [[VPLANNEDBB62]] ]
; CHECK-NEXT:    [[TMP9:%.*]] = add <8 x i32> [[UNI_PHI57]], [[TMP5:%.*]]
; CHECK-NEXT:    [[REPLICATEDVAL_:%.*]] = shufflevector <8 x i32> [[TMP9]], <8 x i32> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    [[WIDE_EXTRACT:%.*]] = shufflevector <16 x i32> [[REPLICATEDVAL_]], <16 x i32> undef, <2 x i32> <i32 0, i32 8>
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ult <8 x i32> [[UNI_PHI57]], [[TMP8:%.*]]
; CHECK-NEXT:    br label [[VPLANNEDBB58:%.*]]
; CHECK:       VPlannedBB58:
; CHECK-NEXT:    [[MM_VECTORGEP59:%.*]] = getelementptr i32, <2 x ptr> [[WIDE_LOAD]], <2 x i32> [[WIDE_EXTRACT]]
; CHECK-NEXT:    [[MM_VECTORGEP59_EXTRACT_1_:%.*]] = extractelement <2 x ptr> [[MM_VECTORGEP59]], i32 1
; CHECK-NEXT:    [[MM_VECTORGEP59_EXTRACT_0_:%.*]] = extractelement <2 x ptr> [[MM_VECTORGEP59]], i32 0
; CHECK-NEXT:    [[TMP11:%.*]] = add <16 x i32> [[TMP6:%.*]], [[REPLICATEDVAL_]]
; CHECK-NEXT:    [[EXTRACTSUBVEC_61:%.*]] = shufflevector <16 x i32> [[TMP11]], <16 x i32> undef, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
; CHECK-NEXT:    [[EXTRACTSUBVEC_60:%.*]] = shufflevector <16 x i32> [[TMP11]], <16 x i32> undef, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
; CHECK-NEXT:    call void @llvm.masked.store.v8i32.p0(<8 x i32> [[EXTRACTSUBVEC_60]], ptr [[MM_VECTORGEP59_EXTRACT_0_]], i32 4, <8 x i1> [[TMP10]])
; CHECK-NEXT:    call void @llvm.masked.store.v8i32.p0(<8 x i32> [[EXTRACTSUBVEC_61]], ptr [[MM_VECTORGEP59_EXTRACT_1_]], i32 4, <8 x i1> [[TMP10]])
; CHECK-NEXT:    br label [[VPLANNEDBB62]]
; CHECK:       VPlannedBB62:
; CHECK-NEXT:    [[TMP12]] = add <8 x i32> [[UNI_PHI57]], <i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8, i32 8>
; CHECK-NEXT:    [[TMP13]] = add i32 [[UNI_PHI56]], 8
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ult <8 x i32> [[TMP12]], [[TMP8]]
; CHECK-NEXT:    [[TMP15:%.*]] = bitcast <8 x i1> [[TMP14]] to i8
; CHECK-NEXT:    [[TMP16:%.*]] = icmp eq i8 [[TMP15]], 0
; CHECK-NEXT:    br i1 [[TMP16]], label [[VPLANNEDBB63:%.*]], label [[VPLANNEDBB55:%.*]]
;
entry:
  br label %header

header:
  %token = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %body

body:
  %i = phi i32 [ 0, %header ], [ %i.next, %exit.inner ]
  %index = getelementptr ptr, ptr %a, i32 %i
  %arr = load ptr, ptr %index
  br label %header.inner

header.inner:
  %token.inner = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %body.inner

body.inner:
  %j = phi i32 [ 0, %header.inner ], [ %j.next, %body.inner ]

  %index.inner = getelementptr i32, ptr %arr, i32 %j
  %val = add i32 %i, %j
  store i32 %val, ptr %index.inner

  %j.next = add i32 %j, 1
  %cmp.inner = icmp eq i32 %j.next, 63
  br i1 %cmp.inner, label %latch.inner, label %body.inner, !llvm.loop !1

latch.inner:
  call void @llvm.directive.region.exit(token %token.inner) [ "DIR.OMP.END.SIMD"() ]
  br label %exit.inner

exit.inner:
  %i.next = add i32 %i, 1
  %cmp = icmp eq i32 %i.next, 32
  br i1 %cmp, label %latch, label %body

latch:
  call void @llvm.directive.region.exit(token %token) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

!1 = distinct !{!1, !2}
!2 = !{!"llvm.loop.intel.vector.vecremainder", !"true"}
