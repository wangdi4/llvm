; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; This test verifies that private-variables escaping into unknown function
; via an intermediate write is captured as 'unsafe'. We also test a scenario where
; we capture a private-variable as unsafe on account of an intermediate bitcast,
; which is loop-invariant.

; RUN: opt -S -passes=vplan-vec -vplan-enable-soa -vplan-dump-soa-info -disable-vplan-codegen %s 2>&1 | FileCheck %s
;
; ; HIR-run.
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -vplan-enable-masked-variant=0 -vplan-enable-soa-hir -vplan-dump-soa-info\
; RUN: -disable-output  -disable-vplan-codegen %s 2>&1 | FileCheck %s

; Marking as fail due to the test in test_pointer_induction_escape function is incorrect.
; The test contains inducitons of pointers to private arrays. This is an incorrect
; situation and we should bail out. The test should be corrected to move the inducitons
; into inner loops. Also the test should be copied and added to test that we bail out
; in such situations (along with implementing that baliout). CMPLRLLVM-21499.
;
; XFAIL: *
;
; REQUIRES:asserts

;Source Code: test2.c
;int arr_e[1024];
;extern int helper(int *elem);
;extern int helper2(void);
;int foo(int n1, int k) {
;  int index;
;#pragma omp simd private(arr_e)
;  for (index = 1; index < 1024; index++) {
;    int *ptr = &arr_e[index];
;    ptr[k] = helper2();
;    helper(&ptr[k]);
;  }
;  return arr_e[index-k];
;}

; Compile-command: icx test2.c -o out.ll -fiopenmp -O1 -S  \
; -mllvm -disable-vplan-codegen -mllvm -vplan-entities-dump \
; -mllvm -vplan-use-entity-instr -emit-llvm


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@arr_e = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @foo(i32 %n1, i32 %k) local_unnamed_addr {
;CHECK-LABEL: SOA profitability
;CHECK-NEXT:  SOAUnsafe = arr_e.priv
;CHECK-NEXT:  SOAUnsafe = arr_e2.priv
;CHECK-NEXT:  SOASafe = ptr.priv Profitable = 1
;CHECK-NEXT:  SOASafe = index.lpriv Profitable = 1
;
omp.inner.for.body.lr.ph:
  %ptr.priv = alloca ptr, align 8
  %arr_e.priv = alloca [1024 x i32], align 4
  %arr_e2.priv = alloca [1024 x i32], align 4
  %index.lpriv = alloca i32, align 4
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %omp.inner.for.body.lr.ph
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e.priv, i32 0, i32 1024), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e2.priv, i32 0, i32 1024), "QUAL.OMP.LASTPRIVATE:TYPED"(ptr %index.lpriv, i32 0, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %ptr.priv, ptr null, i32 1) ]
  br label %DIR.OMP.SIMD.2

DIR.OMP.SIMD.2:                                   ; preds = %DIR.OMP.SIMD.1
  %idxprom1 = sext i32 %k to i64
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.2
  %indvars.iv = phi i64 [ %indvars.iv.next, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.2 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  store i8 10, ptr %arr_e2.priv, align 1            ;; Should cause arr_e2 to be marked as unsafe.
  %1 = trunc i64 %indvars.iv.next to i32
  store i32 %1, ptr %index.lpriv, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ptr.priv)
  %arrayidx = getelementptr inbounds [1024 x i32], ptr %arr_e.priv, i64 0, i64 %indvars.iv.next
  store ptr %arrayidx, ptr %ptr.priv, align 8
  %call = call i32 @helper2()
  %2 = load ptr, ptr %ptr.priv, align 8
  %arrayidx2 = getelementptr inbounds i32, ptr %2, i64 %idxprom1
  store i32 %call, ptr %arrayidx2, align 4
  %call5 = call i32 @helper(ptr %arrayidx2)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ptr.priv)
  %exitcond = icmp eq i64 %indvars.iv.next, 1023
  br i1 %exitcond, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %omp.inner.for.body
  %3 = load i32, ptr %index.lpriv, align 4
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %DIR.OMP.END.SIMD.2
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.4

DIR.OMP.END.SIMD.4:                               ; preds = %DIR.OMP.END.SIMD.3
  %sub = sub nsw i32 %3, %k
  %idxprom7 = sext i32 %sub to i64
  %arrayidx8 = getelementptr inbounds [1024 x i32], ptr @arr_e, i64 0, i64 %idxprom7
  %4 = load i32, ptr %arrayidx8, align 4
  ret i32 %4
}

; This test makes sure that loads/stores of bitcasted privates or their aliases are marked as unsafe.
;; Function Attrs: nounwind
define void @test_bitcast() {
;CHECK-LABEL: SOA profitability
;CHECK-NEXT: SOASafe = arr_e1.priv
;CHECK-NEXT: SOAUnsafe = arr_e2.priv
;CHECK-NEXT: SOAUnsafe = arr_e3.priv
;CHECK-NEXT: SOAUnsafe = arr_e4.priv
;CHECK-NEXT: SOAUnsafe = arr_e5.priv
;
  %arr_e1.priv = alloca [624 x i32], align 4
  %arr_e2.priv = alloca [624 x i32], align 4
  %arr_e3.priv = alloca [624 x i32], align 4
  %arr_e4.priv = alloca [624 x i32], align 4
  %arr_e5.priv = alloca [624 x i32], align 4
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e1.priv, i32 0, i32 624), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e2.priv, i32 0, i32 624), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e3.priv, i32 0, i32 624), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e4.priv, i32 0, i32 624), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e5.priv, i32 0, i32 624) ]
  br label %simd.loop

simd.loop:
  %index = phi i32 [ 0, %simd.begin.region ], [ %indvar, %simd.loop.exit ]
  %se = sext i32 %index to i64
  %add = add nuw i64 %se, 1
  call void @llvm.lifetime.start.p0(i64 2496, ptr nonnull %arr_e1.priv)
  call void @llvm.lifetime.start.p0(i64 2496, ptr nonnull %arr_e2.priv)
  call void @llvm.lifetime.start.p0(i64 2496, ptr nonnull %arr_e3.priv)
  call void @llvm.lifetime.start.p0(i64 2496, ptr nonnull %arr_e4.priv)
  call void @llvm.lifetime.start.p0(i64 2496, ptr nonnull %arr_e5.priv)
  %g1 = getelementptr inbounds i8, ptr %arr_e2.priv, i64 3
  %l2 = load i64, ptr %g1, align 1      ;; Should cause arr_e2 to be marked as unsafe.
  store i8 10, ptr %arr_e3.priv, align 1            ;; Should cause arr_e3 to be marked as unsafe.
  %add1 = trunc i64 %add to i32
  store i32 %add1, ptr %arr_e1.priv, align 4
  %gep2 = getelementptr inbounds [624 x i32], ptr %arr_e4.priv, i64 0, i64 1
  %vec1 = insertelement <2 x ptr> undef, ptr %arr_e4.priv, i32 0
  %vec2 = insertelement <2 x ptr> %vec1, ptr %gep2, i32 1
  %call = call i32 @helper3(<2 x ptr> %vec2)
  ;; This private array does not escape. The following insert/extract-element sequence is safe.
  ;; However, input code might have random instructions (e.g., shuffle,select, etc.), manipulating
  ;; this vector in ways which we cannot reason about statically. Hence, we conservatively mark these
  ;; as un-safe.
  %gep4 = getelementptr inbounds [624 x i32], ptr %arr_e5.priv, i64 0, i64 1
  %vec3 = insertelement <2 x ptr> undef, ptr %arr_e5.priv, i32 0
  %vec4 = insertelement <2 x ptr> %vec1, ptr %gep4, i32 1
  %E1 = extractelement <2 x ptr> %vec4, i32 1
  call void @llvm.lifetime.end.p0(i64 2496, ptr nonnull %arr_e1.priv)
  call void @llvm.lifetime.end.p0(i64 2496, ptr nonnull %arr_e2.priv)
  call void @llvm.lifetime.end.p0(i64 2496, ptr nonnull %arr_e3.priv)
  call void @llvm.lifetime.end.p0(i64 2496, ptr nonnull %arr_e4.priv)
  call void @llvm.lifetime.end.p0(i64 2496, ptr nonnull %arr_e5.priv)
  br label %simd.loop.exit

simd.loop.exit:
  %indvar = add nuw i32 %index, 1
  %vl.cond = icmp ult i32 %indvar, 8
  br i1 %vl.cond, label %simd.loop, label %simd.end.region

simd.end.region:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:
  ret void
}; Test that load/store from bitcast's are identified as unsafe.

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

; Function Attrs: nounwind
declare token @llvm.directive.region.entry()

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token)

declare dso_local i32 @helper(ptr) local_unnamed_addr

declare dso_local i32 @helper2() local_unnamed_addr

declare dso_local i32 @helper3(<2 x ptr>) local_unnamed_addr

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)


; Test that possible pointer-escape via indirect call is conservatively reported as
; SOA-unsafe. This test also checks that unsupported types are outrightly rejected.

;CHECK-LABEL: SOA profitability
;CHECK-NEXT: SOASafe = ptr.priv
;CHECK-NEXT: SOAUnsafe = arr_e.priv
;CHECK-NEXT: SOASafe = arr_e1.priv
;CHECK-NEXT: SOAUnsafe = struct.priv
;CHECK-NEXT: SOAUnsafe = arr.struct.priv
;CHECK-NEXT: SOASafe = arr.struct.ptr.priv
;CHECK-NEXT: SOAUnsafe = vec.priv
;CHECK-NEXT: SOAUnsafe = arr.vec.priv

define void @test_negative(ptr nocapture readonly %p2) {
  %ptr.priv = alloca ptr, align 8
  %arr_e.priv = alloca [624 x i32], align 4
  %arr_e1.priv = alloca [624 x ptr], align 4
  %struct.priv = alloca {i32, [624 x i32]}, align 4
  %arr.struct.priv = alloca [100 x {i32}], align 4
  %arr.struct.ptr.priv = alloca [100 x ptr], align 4
  %vec.priv = alloca <4 x i32>, align 4
  %arr.vec.priv = alloca [100 x <4 x i32>], align 4
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %ptr.priv, ptr null, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e.priv, i32 0, i32 624), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e1.priv, i32 0, i32 624), "QUAL.OMP.PRIVATE:TYPED"(ptr %struct.priv, {i32, [624 x i32]} zeroinitializer, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr.struct.priv, {i32} zeroinitializer, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr.struct.ptr.priv, {i32} zeroinitializer, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %vec.priv, <4 x i32> zeroinitializer, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr.vec.priv, <4 x i32> zeroinitializer, i32 100) ]
  br label %simd.loop

simd.loop:
  %index = phi i64 [ 0, %simd.begin.region ], [ %indvar, %simd.loop.exit ]
  call void @llvm.lifetime.start.p0(i64 2496, ptr nonnull %arr_e.priv)
  %arrayidx = getelementptr inbounds ptr, ptr %p2, i64 %index
  %ld = load ptr, ptr %arrayidx, align 8
  %call = call i32 %ld(ptr %arr_e.priv)
  call void @llvm.lifetime.end.p0(i64 2496, ptr nonnull %arr_e.priv)
  br label %simd.loop.exit

simd.loop.exit:
  %indvar = add nuw i64 %index, 1
  %vl.cond = icmp ult i64 %indvar, 8
  br i1 %vl.cond, label %simd.loop, label %simd.end.region

simd.end.region:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; This test checks that we do not enter a tight infinite loop on account of PHI instructions
; and its users.
define void @test_pointer_induction_escape() {
;CHECK-LABEL: SOA profitability
;CHECK-NEXT: SOAUnsafe = arr_e.priv
;CHECK-NEXT: SOASafe = arr_ne.priv
  %arr_e.priv = alloca [1024 x i32], align 4
  %arr_ne.priv = alloca [1024 x i32], align 4
  %arrayidx.end = getelementptr inbounds [1024 x i32], ptr %arr_e.priv, i64 0, i64 1023
  %as.cast1 = addrspacecast ptr %arrayidx.end to ptr addrspace(4)
  %ptr2int1 = ptrtoint ptr addrspace(4) %as.cast1 to i64
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_e.priv, i32 0, i32 1024), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr_ne.priv, i32 0, i32 1024) ]
  br label %simd.loop

simd.loop:
  %index = phi i64 [ 0, %simd.begin.region ], [ %indvar, %simd.loop.end ]
  %arrayidx.current = phi ptr [ %arr_e.priv, %simd.begin.region], [%arrayidx.next, %simd.loop.end]
  %arrayidx.current1 = phi ptr [ %arr_ne.priv, %simd.begin.region], [%arrayidx.next1, %simd.loop.end]
  %ld = load i32, ptr %arrayidx.current
  br label %simd.loop.end

simd.loop.end:
  %as.cast2 = addrspacecast ptr %arrayidx.current to ptr addrspace(4)
  %ptr2int2 = ptrtoint ptr addrspace(4) %as.cast2 to i64
  %icmp = icmp ult i64 %ptr2int2, %ptr2int1
  %arrayidx.next = getelementptr inbounds i32, ptr %arrayidx.current, i64 1
  %arrayidx.next1 = getelementptr inbounds i32, ptr %arrayidx.current1, i64 1
  %indvar = add nuw i64 %index, 1
  %vl.cond = icmp ult i64 %indvar, 8
  br i1 %vl.cond, label %simd.end.region, label %simd.loop

simd.end.region:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}
