; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to show the bug in recogntion of implicit last prvates.
; RUN: opt -disable-output -hir-ssa-deconstruction -hir-temp-cleanup -hir-vplan-vec -vplan-print-after-vpentity-instrs -print-after=hir-vplan-vec -hir-verify=false %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Incoming HIR: conditionally incremented pointer
; BEGIN REGION { }
;       [[TMP0:%.*]] = @llvm.directive.region.entry()
;       [[TMP1:%.*]] = &(([[P0:%.*]])[0])
;
;       + DO i1 = 0, 1023, 1   <DO_LOOP> <simd>
;       |   [[SPEC_SELECT_IDX0:%.*]] = (i1 == 9) ? 4 : 0
;       |   [[TMP1]] = &(([[TMP1]])[%spec.select.idx])
;       + END LOOP
;
;       (null)[0] = &(([[TMP1]])[0])
;       @llvm.directive.region.exit([[TMP0]])
;       ret
; END REGION

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #0

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #0

define dso_local void @_Z27CQ417746_private_simple_ptrv(i16* %p) local_unnamed_addr #1 {
;
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: _Z27CQ417746_private_simple_ptrv:HIR.#{{[0-9]+}}
; CHECK:         [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK:         [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP__IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i16* [[VP1:%.*]] = phi  [ i16* [[TMP1:%.*]], [[BB1]] ],  [ i16* [[VP_SUBSCRIPT:%.*]], [[BB2]] ]
; ==== Only this phi is generated for conditional last private updates watching
; CHECK-NEXT:     i32 [[VP_PRIV_IDX_HDR:%.*]] = phi  [ i32 -1, [[BB1]] ],  [ i32 [[VP2:%.*]], [[BB2]] ]
; CHECK-NEXT:     i32 [[VP2]] = phi  [ i32 [[VP__IND_INIT]], [[BB1]] ],  [ i32 [[VP3:%.*]], [[BB2]] ]
; CHECK-NEXT:     i1 [[VP4:%.*]] = icmp eq i32 [[VP2]] i32 9
; CHECK-NEXT:     i64 [[VP5:%.*]] = select i1 [[VP4]] i64 4 i64 0
; CHECK-NEXT:     i16* [[VP_SUBSCRIPT]] = subscript i16* [[VP1]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP3]] = add i32 [[VP2]] i32 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP6:%.*]] = icmp slt i32 [[VP3]] i32 1024
; CHECK-NEXT:     br i1 [[VP6]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     i32 [[VP__IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; ==== Here the index of the update's iteration (second operand, VP2) is set incorrectly.
; CHECK-NEXT:     i16* [[VP_SUBSCRIPT_PRIV_FINAL:%.*]] = private-final-c i16* [[VP_SUBSCRIPT]] i32 [[VP2]] i16* [[TMP1]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
;
; ===== Generated code
; CHECK-LABEL:  Function: _Z27CQ417746_private_simple_ptrv
; CHECK:       BEGIN REGION { modified }
; CHECK-NEXT:        [[TMP2:%.*]] = &(([[P0:%.*]])[0])
; CHECK-NEXT:        [[PHI_TEMP0:%.*]] = [[TMP2]]
; CHECK-NEXT:        [[PHI_TEMP20:%.*]] = -1
;
; CHECK:              DO i1 = 0, 1023, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:           [[DOTVEC0:%.*]] = (i1 + <i32 0, i32 1, i32 2, i32 3> == 9) ? 4 : 0
; CHECK-NEXT:           [[LIVEOUTCOPY0:%.*]] = &((<4 x i16*>)([[PHI_TEMP0]])[[[DOTVEC0]]])
; CHECK-NEXT:           [[PHI_TEMP0]] = [[LIVEOUTCOPY0]]
; CHECK-NEXT:           [[PHI_TEMP20]] = i1 + <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:         END LOOP
; ==== The code generated for conditional last private: should not use induction
;      outside of the loop. This causes assertion.
; CHECK:             [[DOTVEC60:%.*]] = i1 + <i32 0, i32 1, i32 2, i32 3> != -1
; CHECK-NEXT:        [[TMP0:%.*]] = bitcast.<4 x i1>.i4([[DOTVEC60]])
; CHECK-NEXT:        [[CMP0:%.*]] = [[TMP0]] == 0
; CHECK-NEXT:        [[ALL_ZERO_CHECK0:%.*]] = [[CMP0]]
; CHECK-NEXT:        [[PHI_TEMP70:%.*]] = [[TMP2]]
; CHECK-NEXT:        if ([[CMP0]] == 1)
; CHECK-NEXT:        {
; CHECK-NEXT:           goto [[BB5:BB[0-9]+]].41
; CHECK-NEXT:        }
; CHECK-NEXT:        [[PRIV_IDX_MAX0:%.*]] = @llvm.vector.reduce.smax.v4i32(i1 + <i32 0, i32 1, i32 2, i32 3>)
; CHECK-NEXT:        [[PRIV_IDX_CMP0:%.*]] = i1 + <i32 0, i32 1, i32 2, i32 3> == [[PRIV_IDX_MAX0]]
; CHECK-NEXT:        [[BSFINTMASK0:%.*]] = bitcast.<4 x i1>.i4([[PRIV_IDX_CMP0]])
; CHECK-NEXT:        [[BSF0:%.*]] = @llvm.cttz.i4([[BSFINTMASK0]],  1)
; CHECK-NEXT:        [[TMP2]] = extractelement [[LIVEOUTCOPY0]],  [[BSF0]]
; CHECK-NEXT:        [[PHI_TEMP70]] = [[TMP2]]
; CHECK-NEXT:        [[BB5]].41:
; CHECK-NEXT:        (null)[0] = &(([[TMP2]])[0])
; CHECK-NEXT:        ret
; CHECK-NEXT:  END REGION
;
entry:
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:
  %0 = call token @llvm.directive.region.entry() #0 [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE"(i16** null), "QUAL.OMP.LINEAR:IV"(i32* undef, i32 1) ]
  br label %omp.inner.for.body.i.i

omp.inner.for.body.i.i:
  %1 = phi i16* [ %spec.select, %omp.inner.for.body.i.i ], [ %p, %DIR.OMP.SIMD.1 ]
  %.omp.iv.i.i.local.021 = phi i32 [ %add4.i.i, %omp.inner.for.body.i.i ], [ 0, %DIR.OMP.SIMD.1 ]
  %cmp3.i.i = icmp eq i32 %.omp.iv.i.i.local.021, 9
  %spec.select.idx = select i1 %cmp3.i.i, i64 4, i64 0
  %spec.select = getelementptr i16, i16* %1, i64 %spec.select.idx
  %add4.i.i = add nuw nsw i32 %.omp.iv.i.i.local.021, 1
  %exitcond39 = icmp eq i32 %add4.i.i, 1024
  br i1 %exitcond39, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body.i.i

DIR.OMP.END.SIMD.2:
  %spec.select.lcssa = phi i16* [ %spec.select, %omp.inner.for.body.i.i ]
  store i16* %spec.select.lcssa, i16** null, align 8
  br label %DIR.OMP.END.SIMD.243

DIR.OMP.END.SIMD.243:
  call void @llvm.directive.region.exit(token %0) #0 [ "DIR.OMP.END.SIMD"() ]
  ret void
}

attributes #0 = { nounwind }
attributes #1 = { "unsafe-fp-math"="true" }

