; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Checks if tree conflict is lowered to double permute tree reduction

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; RUN: opt -S -enable-new-pm=0 -mattr=+avx512vl,+avx512cd -vplan-force-vf=4 -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-lower-tree-conflict -disable-output < %s 2>&1 | FileCheck %s --check-prefix=CHECK-VF4
; RUN: opt -S -mattr=+avx512vl,+avx512cd -vplan-force-vf=4 -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-lower-tree-conflict -disable-output < %s 2>&1 | FileCheck %s --check-prefix=CHECK-VF4

; Test chain of masked tree conflicts. Block-predicates should be properly preserved
; for the instructions in the post-conflict loop exit blocks.

define dso_local void @foo(i32* noalias nocapture noundef %A, i32* noalias nocapture noundef readonly %B, i32* noalias nocapture noundef %C, i32* noalias nocapture noundef readonly %D) local_unnamed_addr #0 {
; void foo(int* restrict A, int* restrict B, int* restrict C, int* restrict D) {
;   for (int i=0; i<8; ++i) {
;     if (D[i] > 1) {
;       int index = B[i];
;       A[index] = A[index] + i;
;       C[index] = C[index] + i;
;     }
;   }
; }
;
; CHECK-VF4-LABEL:  VPlan IR for: Initial VPlan for VF=4
; CHECK-VF4-NEXT:  External Defs Start:
; CHECK-VF4-DAG:     [[VP0:%.*]] = {%A}
; CHECK-VF4-DAG:     [[VP1:%.*]] = {%C}
; CHECK-VF4-DAG:     [[VP2:%.*]] = {%D}
; CHECK-VF4-DAG:     [[VP3:%.*]] = {%B}
; CHECK-VF4-NEXT:  External Defs End:
; CHECK-VF4-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] br [[BB1:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 8, UF = 1 (SVAOpBits 0->F )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1 (SVAOpBits 0->F )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] br [[BB2:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-VF4-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP4:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP5:%.*]], [[BB3]] ] (SVAOpBits 0->FV 1->FV )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (F  )] i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[D0:%.*]] i64 [[VP4]] (SVAOpBits 0->F 1->F 2->F 3->F )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]] (SVAOpBits 0->F )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i1 [[VP6:%.*]] = icmp sgt i32 [[VP_LOAD]] i32 1 (SVAOpBits 0->V 1->V )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] br [[BB4:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB4]]: # preds: [[BB2]]
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i1 [[VP7:%.*]] = block-predicate i1 [[VP6]] (SVAOpBits 0->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (F  )] i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP4]] (SVAOpBits 0->F 1->F 2->F 3->F )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]] (SVAOpBits 0->F )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD_1]] to i64 (SVAOpBits 0->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0->V 1->V 2->V 3->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_2]] (SVAOpBits 0->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP8:%.*]] = trunc i64 [[VP4]] to i32 (SVAOpBits 0->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds i32* [[A0]] i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0->V 1->V 2->V 3->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i64 [[VP_VPCONFLICT_INTRINSIC:%.*]] = vpconflict-insn i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i64 [[VP_CTLZ:%.*]] = call i64 [[VP_VPCONFLICT_INTRINSIC]] i1 false llvm.ctlz [x 1] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i64 [[VP10:%.*]] = sub i64 63 i64 [[VP_CTLZ]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i32 [[VP11:%.*]] = trunc i64 [[VP10]] to i32 (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i1 [[VP_MASK_TODO:%.*]] = icmp ne i32 [[VP11]] i32 -1 (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i1 [[VP12:%.*]] = and i1 [[VP_MASK_TODO]] i1 [[VP6]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (   )] i1 [[VP_CONFLICT_TOP_TEST:%.*]] = all-zero-check i1 [[VP12]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (   )] br i1 [[VP_CONFLICT_TOP_TEST]], [[BB5:BB[0-9]+]], [[BB6:BB[0-9]+]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:      [[BB6]]: # preds: [[BB4]]
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] br [[BB7:BB[0-9]+]] (SVAOpBits 0-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:      [[BB7]]: # preds: [[BB6]], [[BB7]]
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_CURR_VPERM_CONTROL:%.*]] = phi  [ i32 [[VP11]], [[BB6]] ],  [ i32 [[VP_VPERM_CONTROL_SELECT:%.*]], [[BB7]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_CURR_VRES:%.*]] = phi  [ i32 [[VP8]], [[BB6]] ],  [ i32 [[VP_VRES_NEXT:%.*]], [[BB7]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_CURR_MASK_TODO:%.*]] = phi  [ i1 [[VP12]], [[BB6]] ],  [ i1 [[VP_MASK_TODO_NEXT:%.*]], [[BB7]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP13:%.*]] = bitcast i32 [[VP_CURR_VRES]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP_VTMP:%.*]] = permute float [[VP13]] i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP14:%.*]] = bitcast float [[VP_VTMP]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_DUMMY_CMP:%.*]] = icmp eq i1 [[VP_CURR_MASK_TODO]] i1 true (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_VTMP_SELECT:%.*]] = select i1 [[VP_DUMMY_CMP]] i32 [[VP14]] i32 0 (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP15:%.*]] = add i32 [[VP_VTMP_SELECT]] i32 [[VP_CURR_VRES]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_VRES_NEXT]] = select i1 [[VP_DUMMY_CMP]] i32 [[VP15]] i32 [[VP_CURR_VRES]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP16:%.*]] = bitcast i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP_VPERM_CONTROL_NEXT:%.*]] = permute float [[VP16]] i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP17:%.*]] = bitcast float [[VP_VPERM_CONTROL_NEXT]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_VPERM_CONTROL_SELECT]] = select i1 [[VP_DUMMY_CMP]] i32 [[VP17]] i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_MASK_TODO_NEXT]] = icmp ne i32 [[VP_VPERM_CONTROL_SELECT]] i32 -1 (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] i1 [[VP_LATCH_COND:%.*]] = all-zero-check i1 [[VP_MASK_TODO_NEXT]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] i1 [[VP_LATCH_COND_NOT:%.*]] = not i1 [[VP_LATCH_COND]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] br i1 [[VP_LATCH_COND_NOT]], [[BB7]], [[BB8:BB[0-9]+]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:      [[BB8]]: # preds: [[BB7]]
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] br [[BB5]] (SVAOpBits 0-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB5]]: # preds: [[BB8]], [[BB4]]
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i32 [[VP_FINAL_RESULT:%.*]] = phi  [ i32 [[VP8]], [[BB4]] ],  [ i32 [[VP_VRES_NEXT]], [[BB7]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i1 [[VP18:%.*]] = block-predicate i1 [[VP6]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i32 [[VP19:%.*]] = add i32 [[VP_LOAD_2]] i32 [[VP_FINAL_RESULT]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] store i32 [[VP19]] i32* [[VP_SUBSCRIPT_3]] (SVAOpBits 0->V 1->V )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (   )] br [[BB9:BB[0-9]+]] (SVAOpBits 0-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB9]]: # preds: [[BB5]]
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds i32* [[C0:%.*]] i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0->V 1->V 2->V 3->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_LOAD_3:%.*]] = load i32* [[VP_SUBSCRIPT_4]] (SVAOpBits 0->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] i32* [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds i32* [[C0]] i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0->V 1->V 2->V 3->V )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i64 [[VP_VPCONFLICT_INTRINSIC_1:%.*]] = vpconflict-insn i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i64 [[VP_CTLZ_1:%.*]] = call i64 [[VP_VPCONFLICT_INTRINSIC_1]] i1 false llvm.ctlz [x 1] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i64 [[VP22:%.*]] = sub i64 63 i64 [[VP_CTLZ_1]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i32 [[VP23:%.*]] = trunc i64 [[VP22]] to i32 (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i1 [[VP_MASK_TODO_1:%.*]] = icmp ne i32 [[VP23]] i32 -1 (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i1 [[VP24:%.*]] = and i1 [[VP_MASK_TODO_1]] i1 [[VP6]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (   )] i1 [[VP_CONFLICT_TOP_TEST_1:%.*]] = all-zero-check i1 [[VP24]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (   )] br i1 [[VP_CONFLICT_TOP_TEST_1]], [[BB10:BB[0-9]+]], [[BB11:BB[0-9]+]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:      [[BB11]]: # preds: [[BB9]]
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] br [[BB12:BB[0-9]+]] (SVAOpBits 0-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:      [[BB12]]: # preds: [[BB11]], [[BB12]]
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_CURR_VPERM_CONTROL_1:%.*]] = phi  [ i32 [[VP23]], [[BB11]] ],  [ i32 [[VP_VPERM_CONTROL_SELECT_1:%.*]], [[BB12]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_CURR_VRES_1:%.*]] = phi  [ i32 [[VP8]], [[BB11]] ],  [ i32 [[VP_VRES_NEXT_1:%.*]], [[BB12]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_CURR_MASK_TODO_1:%.*]] = phi  [ i1 [[VP24]], [[BB11]] ],  [ i1 [[VP_MASK_TODO_NEXT_1:%.*]], [[BB12]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP25:%.*]] = bitcast i32 [[VP_CURR_VRES_1]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP_VTMP_1:%.*]] = permute float [[VP25]] i32 [[VP_CURR_VPERM_CONTROL_1]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP26:%.*]] = bitcast float [[VP_VTMP_1]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_DUMMY_CMP_1:%.*]] = icmp eq i1 [[VP_CURR_MASK_TODO_1]] i1 true (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_VTMP_SELECT_1:%.*]] = select i1 [[VP_DUMMY_CMP_1]] i32 [[VP26]] i32 0 (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP27:%.*]] = add i32 [[VP_VTMP_SELECT_1]] i32 [[VP_CURR_VRES_1]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_VRES_NEXT_1]] = select i1 [[VP_DUMMY_CMP_1]] i32 [[VP27]] i32 [[VP_CURR_VRES_1]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP28:%.*]] = bitcast i32 [[VP_CURR_VPERM_CONTROL_1]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] float [[VP_VPERM_CONTROL_NEXT_1:%.*]] = permute float [[VP28]] i32 [[VP_CURR_VPERM_CONTROL_1]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP29:%.*]] = bitcast float [[VP_VPERM_CONTROL_NEXT_1]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_VPERM_CONTROL_SELECT_1]] = select i1 [[VP_DUMMY_CMP_1]] i32 [[VP29]] i32 [[VP_CURR_VPERM_CONTROL_1]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_MASK_TODO_NEXT_1]] = icmp ne i32 [[VP_VPERM_CONTROL_SELECT_1]] i32 -1 (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] i1 [[VP_LATCH_COND_1:%.*]] = all-zero-check i1 [[VP_MASK_TODO_NEXT_1]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] i1 [[VP_LATCH_COND_NOT_1:%.*]] = not i1 [[VP_LATCH_COND_1]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] br i1 [[VP_LATCH_COND_NOT_1]], [[BB12]], [[BB13:BB[0-9]+]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:      [[BB13]]: # preds: [[BB12]]
; CHECK-VF4-NEXT:       [DA: Uni, SVA: (   )] br [[BB10]] (SVAOpBits 0-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB10]]: # preds: [[BB13]], [[BB9]]
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i32 [[VP_FINAL_RESULT_1:%.*]] = phi  [ i32 [[VP8]], [[BB9]] ],  [ i32 [[VP_VRES_NEXT_1]], [[BB12]] ] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i1 [[VP30:%.*]] = block-predicate i1 [[VP6]] (SVAOpBits 0-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: (   )] i32 [[VP31:%.*]] = add i32 [[VP_LOAD_3]] i32 [[VP_FINAL_RESULT_1]] (SVAOpBits 0-> 1-> )
; CHECK-VF4-NEXT:     [DA: Div, SVA: ( V )] store i32 [[VP31]] i32* [[VP_SUBSCRIPT_5]] (SVAOpBits 0->V 1->V )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (   )] br [[BB14:BB[0-9]+]] (SVAOpBits 0-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB14]]: # preds: [[BB10]]
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (   )] br [[BB3]] (SVAOpBits 0-> )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB3]]: # preds: [[BB14]]
; CHECK-VF4-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP5]] = add i64 [[VP4]] i64 [[VP__IND_INIT_STEP]] (SVAOpBits 0->FV 1->FV )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP32:%.*]] = icmp slt i64 [[VP5]] i64 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] br i1 [[VP32]], [[BB2]], [[BB15:BB[0-9]+]] (SVAOpBits 0->F 1->F 2->F )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB15]]: # preds: [[BB3]]
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] br [[BB16:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:    [[BB16]]: # preds: [[BB15]]
; CHECK-VF4-NEXT:     [DA: Uni, SVA: (F  )] br <External Block> (SVAOpBits )
; CHECK-VF4-EMPTY:
; CHECK-VF4-NEXT:  External Uses:
; CHECK-VF4-NEXT:  Id: 0   no underlying for i64 [[VP__IND_FINAL]]
;
entry:
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc
  ret void

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds i32, i32* %D, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %cmp1 = icmp sgt i32 %0, 1
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %arrayidx3 = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %1 = load i32, i32* %arrayidx3, align 4
  %idxprom4 = sext i32 %1 to i64
  %arrayidx5 = getelementptr inbounds i32, i32* %A, i64 %idxprom4
  %2 = load i32, i32* %arrayidx5, align 4
  %3 = trunc i64 %indvars.iv to i32
  %add = add nsw i32 %2, %3
  store i32 %add, i32* %arrayidx5, align 4
  %arrayidx9 = getelementptr inbounds i32, i32* %C, i64 %idxprom4
  %4 = load i32, i32* %arrayidx9, align 4
  %add10 = add nsw i32 %4, %3
  store i32 %add10, i32* %arrayidx9, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 8
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

attributes #0 = { argmemonly nofree norecurse nosync nounwind uwtable "approx-func-fp-math"="true" "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "frame-pointer"="none" "loopopt-pipeline"="light" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="skylake-avx512" "target-features"="+adx,+aes,+avx,+avx2,+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl,+bmi,+bmi2,+clflushopt,+clwb,+crc32,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+pku,+popcnt,+prfchw,+rdrnd,+rdseed,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsavec,+xsaveopt,+xsaves" "unsafe-fp-math"="true" }
