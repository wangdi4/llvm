; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Checks that we do not recognize Histogram.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; REQUIRES: asserts
; RUN: opt -S -mattr=+avx512vl,+avx512cd -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -enable-vconflict-idiom -hir-vplan-vec -vplan-print-after-hir-decomposer	-disable-vplan-codegen -disable-output < %s 2>&1 | FileCheck %s

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo1(i32* noalias nocapture %A, i32* noalias nocapture readonly %B, i32* noalias nocapture readonly %C, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo1:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP1:%.*]] = {%C}
; CHECK-DAG:     [[VP2:%.*]] = {%B}
; CHECK-DAG:     [[VP3:%.*]] = {%A}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP4:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP5:%.*]], [[BB2]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP4]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds i32* [[C0:%.*]] i64 [[VP4]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i64 [[VP6:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds i32* [[A0]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_1]] i32 [[VP_LOAD_2]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP7:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      live-out : i32 [[VP7]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i64 [[VP5]] = add i64 [[VP4]] i64 1
; CHECK-NEXT:     i1 [[VP8:%.*]] = icmp sle i64 [[VP5]] i64 [[VP0]]
; CHECK-NEXT:     br i1 [[VP8]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    A[index] = A[index] + C[i];
;  }
  %cmp14 = icmp sgt i32 %N, 0
  br i1 %cmp14, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count16 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %A, i64 %idxprom1
  %1 = load i32, i32* %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, i32* %C, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx4, align 4
  %add = add nsw i32 %2, %1
  store i32 %add, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count16
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo2(i32* noalias nocapture %A, i32* noalias nocapture readonly %B, i32* noalias nocapture readonly %C, i32* noalias nocapture readonly %D, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo2:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%C}
; CHECK-DAG:     [[VP1:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP2:%.*]] = {%D}
; CHECK-DAG:     [[VP3:%.*]] = {%B}
; CHECK-DAG:     [[VP4:%.*]] = {%A}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP6:%.*]], [[BB2]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[C0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds i32* [[D0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i32 [[VP7:%.*]] = add i32 [[VP_LOAD_1]] i32 [[VP_LOAD_2]]
; CHECK-NEXT:     i64 [[VP8:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds i32* [[A0]] i64 [[VP8]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_3]] i32 [[VP7]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP9:%.*]] = sdiv i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      i32 [[VP10:%.*]] = mul i32 [[VP9]] i32 100
; CHECK-NEXT:      live-out : i32 [[VP10]] = mul i32 [[VP9]] i32 100
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] i32* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     i64 [[VP6]] = add i64 [[VP5]] i64 1
; CHECK-NEXT:     i1 [[VP11:%.*]] = icmp sle i64 [[VP6]] i64 [[VP1]]
; CHECK-NEXT:     br i1 [[VP11]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    A[index] = (A[index]/(C[i]+D[i]))*100;
;  }
  %cmp17 = icmp sgt i32 %N, 0
  br i1 %cmp17, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count19 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %A, i64 %idxprom1
  %1 = load i32, i32* %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, i32* %C, i64 %indvars.iv
  %2 = load i32, i32* %arrayidx4, align 4
  %arrayidx6 = getelementptr inbounds i32, i32* %D, i64 %indvars.iv
  %3 = load i32, i32* %arrayidx6, align 4
  %add = add nsw i32 %3, %2
  %div = sdiv i32 %1, %add
  %mul = mul nsw i32 %div, 100
  store i32 %mul, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count19
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo3(i32* noalias nocapture %A, i32* noalias nocapture readonly %B, i32* noalias nocapture %C, i32* noalias nocapture %D, i32* noalias nocapture %E, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo3:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%.sink}
; CHECK-DAG:     [[VP1:%.*]] = {%C}
; CHECK-DAG:     [[VP2:%.*]] = {%y.0}
; CHECK-DAG:     [[VP3:%.*]] = {%B}
; CHECK-DAG:     [[VP4:%.*]] = {%E}
; CHECK-DAG:     [[VP5:%.*]] = {%D}
; CHECK-DAG:     [[VP6:%.*]] = {%A}
; CHECK-DAG:     [[VP7:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP8:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP9:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP8]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i1 [[VP10:%.*]] = trunc i64 [[VP8]] to i1
; CHECK-NEXT:     i1 [[VP11:%.*]] = mul i1 true i1 [[VP10]]
; CHECK-NEXT:     i32 [[VP12:%.*]] = zext i1 [[VP11]] to i32
; CHECK-NEXT:     i1 [[VP13:%.*]] = icmp eq i32 [[VP12]] i32 0
; CHECK-NEXT:     br i1 [[VP13]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP14:%.*]] = trunc i64 [[VP8]] to i32
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[E0:%.*]] i64 [[VP8]]
; CHECK-NEXT:       store i32 [[VP14]] i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds i32* [[D0:%.*]] i64 [[VP8]]
; CHECK-NEXT:       i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:       i32 [[VP15:%.*]] = trunc i64 [[VP8]] to i32
; CHECK-NEXT:       i32 [[VP16:%.*]] = add i32 [[VP15]] i32 10
; CHECK-NEXT:       i32 [[VP17:%.*]] = hir-copy i32 [[VP16]] , OriginPhiId: -1
; CHECK-NEXT:       i32 [[VP18:%.*]] = add i32 [[VP_LOAD_1]] i32 1
; CHECK-NEXT:       i32 [[VP19:%.*]] = trunc i64 [[VP8]] to i32
; CHECK-NEXT:       i32 [[VP20:%.*]] = mul i32 [[VP18]] i32 [[VP19]]
; CHECK-NEXT:       i32 [[VP21:%.*]] = add i32 [[VP20]] i32 10
; CHECK-NEXT:       i32 [[VP22:%.*]] = hir-copy i32 [[VP21]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP23:%.*]] = trunc i64 [[VP8]] to i32
; CHECK-NEXT:       i32 [[VP24:%.*]] = add i32 [[VP23]] i32 10
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds i32* [[D0]] i64 [[VP8]]
; CHECK-NEXT:       store i32 [[VP24]] i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:       i32 [[VP25:%.*]] = trunc i64 [[VP8]] to i32
; CHECK-NEXT:       i32 [[VP26:%.*]] = add i32 [[VP25]] i32 10
; CHECK-NEXT:       i32 [[VP27:%.*]] = trunc i64 [[VP8]] to i32
; CHECK-NEXT:       i32 [[VP28:%.*]] = mul i32 [[VP26]] i32 [[VP27]]
; CHECK-NEXT:       i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds i32* [[E0]] i64 [[VP8]]
; CHECK-NEXT:       i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:       i32 [[VP29:%.*]] = trunc i64 [[VP8]] to i32
; CHECK-NEXT:       i32 [[VP30:%.*]] = hir-copy i32 [[VP29]] , OriginPhiId: -1
; CHECK-NEXT:       i32 [[VP31:%.*]] = mul i32 [[VP_LOAD_2]] i32 -1
; CHECK-NEXT:       i32 [[VP32:%.*]] = add i32 [[VP31]] i32 [[VP28]]
; CHECK-NEXT:       i32 [[VP33:%.*]] = hir-copy i32 [[VP32]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     i32 [[VP34:%.*]] = phi  [ i32 [[VP33]], [[BB4]] ],  [ i32 [[VP22]], [[BB5]] ]
; CHECK-NEXT:     i32 [[VP35:%.*]] = phi  [ i32 [[VP30]], [[BB4]] ],  [ i32 [[VP17]], [[BB5]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds i32* [[C0:%.*]] i64 [[VP8]]
; CHECK-NEXT:     store i32 [[VP35]] i32* [[VP_SUBSCRIPT_5]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_6:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load i32* [[VP_SUBSCRIPT_6]]
; CHECK-NEXT:     i64 [[VP36:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_7:%.*]] = subscript inbounds i32* [[A0]] i64 [[VP36]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_3]] i32 [[VP34]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP37:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      live-out : i32 [[VP37]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] i32* [[VP_SUBSCRIPT_7]]
; CHECK-NEXT:     i64 [[VP9]] = add i64 [[VP8]] i64 1
; CHECK-NEXT:     i1 [[VP38:%.*]] = icmp sle i64 [[VP9]] i64 [[VP7]]
; CHECK-NEXT:     br i1 [[VP38]], [[BB2]], [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    int x = A[index];
;    int y = 0;
;    if (i%2==0){
;      C[i] = i;
;      D[i] = i + 10;
;      y = C[i] * D[i] - E[i];
;    }else{
;      C[i] = i + 10;
;      E[i] = i;
;      y = C[i] + D[i] * E[i];
;    }
;    A[index] = A[index] + y;
;  }
  %cmp64 = icmp sgt i32 %N, 0
  br i1 %cmp64, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count69 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %if.end
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %if.end
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end ]
  %i.065 = phi i32 [ 0, %for.body.preheader ], [ %inc, %if.end ]
  %arrayidx = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %A, i64 %idxprom1
  %1 = trunc i64 %indvars.iv to i32
  %rem = and i32 %1, 1
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %add = add nuw nsw i32 %i.065, 10
  %arrayidx7 = getelementptr inbounds i32, i32* %D, i64 %indvars.iv
  %2 = add i32 %1, 10
  store i32 %2, i32* %arrayidx7, align 4
  %mul = mul nsw i32 %add, %1
  %arrayidx13 = getelementptr inbounds i32, i32* %E, i64 %indvars.iv
  %3 = load i32, i32* %arrayidx13, align 4
  %sub = sub nsw i32 %mul, %3
  br label %if.end

if.else:                                          ; preds = %for.body
  %4 = add i32 %1, 10
  %arrayidx18 = getelementptr inbounds i32, i32* %E, i64 %indvars.iv
  store i32 %1, i32* %arrayidx18, align 4
  %arrayidx22 = getelementptr inbounds i32, i32* %D, i64 %indvars.iv
  %5 = load i32, i32* %arrayidx22, align 4
  %mul25 = mul nsw i32 %5, %1
  %add26 = add nsw i32 %mul25, %4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %.sink = phi i32 [ %1, %if.then ], [ %4, %if.else ]
  %y.0 = phi i32 [ %sub, %if.then ], [ %add26, %if.else ]
  %6 = getelementptr inbounds i32, i32* %C, i64 %indvars.iv
  store i32 %.sink, i32* %6, align 4
  %7 = load i32, i32* %arrayidx2, align 4
  %add29 = add nsw i32 %7, %y.0
  store i32 %add29, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %inc = add nuw nsw i32 %i.065, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count69
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo4(i32* noalias nocapture %A, i32* noalias nocapture readonly %B, i32* noalias nocapture readonly %C, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo4:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%y.0}
; CHECK-DAG:     [[VP1:%.*]] = {%B}
; CHECK-DAG:     [[VP2:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP3:%.*]] = {%A}
; CHECK-DAG:     [[VP4:%.*]] = {%C}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP6:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i32 [[VP7:%.*]] = trunc i64 [[VP5]] to i32
; CHECK-NEXT:     i32 [[VP8:%.*]] = hir-copy i32 [[VP7]] , OriginPhiId: -1
; CHECK-NEXT:     i1 [[VP9:%.*]] = trunc i64 [[VP5]] to i1
; CHECK-NEXT:     i1 [[VP10:%.*]] = mul i1 true i1 [[VP9]]
; CHECK-NEXT:     i32 [[VP11:%.*]] = zext i1 [[VP10]] to i32
; CHECK-NEXT:     i1 [[VP12:%.*]] = icmp ne i32 [[VP11]] i32 0
; CHECK-NEXT:     br i1 [[VP12]], [[BB4:BB[0-9]+]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP_LOAD_1:%.*]] = load i32* [[C0:%.*]]
; CHECK-NEXT:       i32 [[VP13:%.*]] = trunc i64 [[VP5]] to i32
; CHECK-NEXT:       i32 [[VP14:%.*]] = add i32 [[VP_LOAD_1]] i32 [[VP13]]
; CHECK-NEXT:       i32 [[VP15:%.*]] = hir-copy i32 [[VP14]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB2]]
; CHECK-NEXT:     i32 [[VP16:%.*]] = phi  [ i32 [[VP15]], [[BB4]] ],  [ i32 [[VP8]], [[BB2]] ]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i64 [[VP17:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds i32* [[A0]] i64 [[VP17]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_2]] i32 [[VP16]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP18:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      live-out : i32 [[VP18]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i64 [[VP6]] = add i64 [[VP5]] i64 1
; CHECK-NEXT:     i1 [[VP19:%.*]] = icmp sle i64 [[VP6]] i64 [[VP2]]
; CHECK-NEXT:     br i1 [[VP19]], [[BB2]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br <External Block>
;
entry:
;   for (int i=0; i<N; i++){
;     index = B[i];
;     int x = A[index];
;     int y = 0;
;     if (i%2==0)
;        y = i;
;     else
;     y = i + C[0];
;     A[index] = A[index] + y;
;   }
  %cmp23 = icmp sgt i32 %N, 0
  br i1 %cmp23, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count25 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %if.end
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %if.end
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end ]
  %arrayidx = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %A, i64 %idxprom1
  %1 = trunc i64 %indvars.iv to i32
  %rem = and i32 %1, 1
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.end, label %if.else

if.else:                                          ; preds = %for.body
  %2 = load i32, i32* %C, align 4
  %add = add nsw i32 %2, %1
  br label %if.end

if.end:                                           ; preds = %for.body, %if.else
  %y.0 = phi i32 [ %add, %if.else ], [ %1, %for.body ]
  %3 = load i32, i32* %arrayidx2, align 4
  %add7 = add nsw i32 %3, %y.0
  store i32 %add7, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count25
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo5(i32* noalias nocapture %A, i32* noalias nocapture readonly %B, i32* noalias nocapture readonly %C, i32* noalias nocapture readonly %D, i32* noalias nocapture readonly %E, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo5:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%D}
; CHECK-DAG:     [[VP1:%.*]] = {%B}
; CHECK-DAG:     [[VP2:%.*]] = {%A}
; CHECK-DAG:     [[VP3:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP4:%.*]] = {%E}
; CHECK-DAG:     [[VP5:%.*]] = {%C}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB2]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load i32* [[C0:%.*]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds i32* [[E0:%.*]] i64 2
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds i32* [[D0:%.*]] i64 3
; CHECK-NEXT:     i32 [[VP_LOAD_4:%.*]] = load i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i32 [[VP8:%.*]] = mul i32 [[VP_LOAD_3]] i32 [[VP_LOAD_2]]
; CHECK-NEXT:     i64 [[VP9:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds i32* [[A0]] i64 [[VP9]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_1]] i32 [[VP_LOAD_4]] i32 [[VP8]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN2:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP10:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      i32 [[VP11:%.*]] = add i32 [[VP10]] i32 [[VP_LIVE_IN2]]
; CHECK-NEXT:      live-out : i32 [[VP11]] = add i32 [[VP10]] i32 [[VP_LIVE_IN2]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] i32* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP12:%.*]] = icmp sle i64 [[VP7]] i64 [[VP3]]
; CHECK-NEXT:     br i1 [[VP12]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    A[index] = A[index] + C[0]*E[2] + D[3];
;  }
  %arrayidx4 = getelementptr inbounds i32, i32* %E, i64 2
  %arrayidx5 = getelementptr inbounds i32, i32* %D, i64 3
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count17 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %A, i64 %idxprom1
  %1 = load i32, i32* %arrayidx2, align 4
  %2 = load i32, i32* %C, align 4
  %3 = load i32, i32* %arrayidx4, align 4
  %mul = mul nsw i32 %3, %2
  %add = add nsw i32 %mul, %1
  %4 = load i32, i32* %arrayidx5, align 4
  %add6 = add nsw i32 %add, %4
  store i32 %add6, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count17
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

define dso_local void @foo6(i32* noalias nocapture %A, i32* noalias nocapture readonly %B, i32* noalias nocapture %D, i32* noalias nocapture readonly %E, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo6:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%D}
; CHECK-DAG:     [[VP1:%.*]] = {%0}
; CHECK-DAG:     [[VP2:%.*]] = {%B}
; CHECK-DAG:     [[VP3:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP4:%.*]] = {%A}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP6:%.*]], [[BB2]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds i32* [[D0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i32 [[VP7:%.*]] = add i32 [[VP_LOAD_2]] i32 [[TMP0:%.*]]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds i32* [[D0]] i64 [[VP5]]
; CHECK-NEXT:     store i32 [[VP7]] i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i64 [[VP8:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds i32* [[A0]] i64 [[VP8]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_1]] i32 [[VP_LOAD_2]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP9:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      i32 [[VP10:%.*]] = add i32 [[VP9]] i32 [[TMP0]]
; CHECK-NEXT:      live-out : i32 [[VP10]] = add i32 [[VP9]] i32 [[TMP0]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] i32* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     i64 [[VP6]] = add i64 [[VP5]] i64 1
; CHECK-NEXT:     i1 [[VP11:%.*]] = icmp sle i64 [[VP6]] i64 [[VP3]]
; CHECK-NEXT:     br i1 [[VP11]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    int x = A[index];
;    D[i] = D[i] + E[0];
;    A[index] = x + D[i];
;  }
  %cmp25 = icmp sgt i32 %N, 0
  br i1 %cmp25, label %for.body.lr.ph, label %for.cond.cleanup

for.body.lr.ph:                                   ; preds = %entry
  %0 = load i32, i32* %E, align 4
  %wide.trip.count27 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %1 = load i32, i32* %arrayidx, align 4
  %idxprom1 = sext i32 %1 to i64
  %arrayidx2 = getelementptr inbounds i32, i32* %A, i64 %idxprom1
  %2 = load i32, i32* %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, i32* %D, i64 %indvars.iv
  %3 = load i32, i32* %arrayidx4, align 4
  %add = add nsw i32 %0, %3
  store i32 %add, i32* %arrayidx4, align 4
  %add10 = add nsw i32 %add, %2
  store i32 %add10, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count27
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

attributes #0 = { nofree norecurse nounwind uwtable mustprogress "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-jump-tables"="false" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "pre_loopopt" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+avx,+avx2,+bmi,+bmi2,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" "unsafe-fp-math"="true" "use-soft-float"="false" }
