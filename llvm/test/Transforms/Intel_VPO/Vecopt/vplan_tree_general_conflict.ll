; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Checks that we do not recognize Histogram.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; REQUIRES: asserts
; RUN: opt -S -mattr=+avx512vl,+avx512cd -passes='hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec' -vplan-print-after-hir-decomposer	-disable-vplan-codegen -disable-output < %s 2>&1 | FileCheck %s

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo1(ptr noalias nocapture %A, ptr noalias nocapture readonly %B, ptr noalias nocapture readonly %C, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo1:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%C}
; CHECK-DAG:     [[VP1:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP2:%.*]] = {%B}
; CHECK-DAG:     [[VP3:%.*]] = {%A}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[VP4:%.*]] = add i64 [[VP1]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP6:%.*]], [[BB2]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[C0:%.*]] i64 [[VP5]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds ptr [[A0]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_1]] i32 [[VP_LOAD_2]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP8:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      live-out : i32 [[VP8]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] ptr [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i64 [[VP6]] = add i64 [[VP5]] i64 1
; CHECK-NEXT:     i1 [[VP9:%.*]] = icmp slt i64 [[VP6]] i64 [[VP4]]
; CHECK-NEXT:     br i1 [[VP9]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    A[index] = A[index] + C[i];
;  }
  %cmp14 = icmp sgt i32 %N, 0
  br i1 %cmp14, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count16 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %idxprom1
  %1 = load i32, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, ptr %C, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx4, align 4
  %add = add nsw i32 %2, %1
  store i32 %add, ptr %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count16
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo2(ptr noalias nocapture %A, ptr noalias nocapture readonly %B, ptr noalias nocapture readonly %C, ptr noalias nocapture readonly %D, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo2:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%C}
; CHECK-DAG:     [[VP1:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP2:%.*]] = {%D}
; CHECK-DAG:     [[VP3:%.*]] = {%B}
; CHECK-DAG:     [[VP4:%.*]] = {%A}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = add i64 [[VP1]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB2]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[C0:%.*]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[D0:%.*]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i32 [[VP8:%.*]] = add i32 [[VP_LOAD_1]] i32 [[VP_LOAD_2]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds ptr [[A0]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_3]] i32 [[VP8]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP10:%.*]] = sdiv i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      i32 [[VP11:%.*]] = mul i32 [[VP10]] i32 100
; CHECK-NEXT:      live-out : i32 [[VP11]] = mul i32 [[VP10]] i32 100
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] ptr [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP12:%.*]] = icmp slt i64 [[VP7]] i64 [[VP5]]
; CHECK-NEXT:     br i1 [[VP12]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    A[index] = (A[index]/(C[i]+D[i]))*100;
;  }
  %cmp17 = icmp sgt i32 %N, 0
  br i1 %cmp17, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count19 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %idxprom1
  %1 = load i32, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, ptr %C, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx4, align 4
  %arrayidx6 = getelementptr inbounds i32, ptr %D, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx6, align 4
  %add = add nsw i32 %3, %2
  %div = sdiv i32 %1, %add
  %mul = mul nsw i32 %div, 100
  store i32 %mul, ptr %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count19
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo3(ptr noalias nocapture %A, ptr noalias nocapture readonly %B, ptr noalias nocapture %C, ptr noalias nocapture %D, ptr noalias nocapture %E, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo3:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%.sink}
; CHECK-DAG:     [[VP1:%.*]] = {%C}
; CHECK-DAG:     [[VP2:%.*]] = {%y.0}
; CHECK-DAG:     [[VP3:%.*]] = {%B}
; CHECK-DAG:     [[VP4:%.*]] = {%E}
; CHECK-DAG:     [[VP5:%.*]] = {%D}
; CHECK-DAG:     [[VP6:%.*]] = {%A}
; CHECK-DAG:     [[VP7:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[VP8:%.*]] = add i64 [[VP7]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP9:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP10:%.*]], [[BB3]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP9]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i1 [[VP11:%.*]] = trunc i64 [[VP9]] to i1
; CHECK-NEXT:     i1 [[VP12:%.*]] = mul i1 true i1 [[VP11]]
; CHECK-NEXT:     i32 [[VP13:%.*]] = zext i1 [[VP12]] to i32
; CHECK-NEXT:     i1 [[VP14:%.*]] = icmp eq i32 [[VP13]] i32 0
; CHECK-NEXT:     br i1 [[VP14]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP15:%.*]] = trunc i64 [[VP9]] to i32
; CHECK-NEXT:       ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[E0:%.*]] i64 [[VP9]]
; CHECK-NEXT:       store i32 [[VP15]] ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:       ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[D0:%.*]] i64 [[VP9]]
; CHECK-NEXT:       i32 [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:       i32 [[VP17:%.*]] = add i32 [[VP15]] i32 10
; CHECK-NEXT:       i32 [[VP18:%.*]] = hir-copy i32 [[VP17]] , OriginPhiId: -1
; CHECK-NEXT:       i32 [[VP19:%.*]] = add i32 [[VP_LOAD_1]] i32 1
; CHECK-NEXT:       i32 [[VP21:%.*]] = mul i32 [[VP19]] i32 [[VP15]]
; CHECK-NEXT:       i32 [[VP22:%.*]] = add i32 [[VP21]] i32 10
; CHECK-NEXT:       i32 [[VP23:%.*]] = hir-copy i32 [[VP22]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       i32 [[VP24:%.*]] = trunc i64 [[VP9]] to i32
; CHECK-NEXT:       i32 [[VP25:%.*]] = add i32 [[VP24]] i32 10
; CHECK-NEXT:       ptr [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds ptr [[D0]] i64 [[VP9]]
; CHECK-NEXT:       store i32 [[VP25]] ptr [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:       i32 [[VP29:%.*]] = mul i32 [[VP25]] i32 [[VP24]]
; CHECK-NEXT:       ptr [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds ptr [[E0]] i64 [[VP9]]
; CHECK-NEXT:       i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:       i32 [[VP31:%.*]] = hir-copy i32 [[VP24]] , OriginPhiId: -1
; CHECK-NEXT:       i32 [[VP32:%.*]] = mul i32 [[VP_LOAD_2]] i32 -1
; CHECK-NEXT:       i32 [[VP33:%.*]] = add i32 [[VP32]] i32 [[VP29]]
; CHECK-NEXT:       i32 [[VP34:%.*]] = hir-copy i32 [[VP33]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     i32 [[VP35:%.*]] = phi  [ i32 [[VP34]], [[BB4]] ],  [ i32 [[VP23]], [[BB5]] ]
; CHECK-NEXT:     i32 [[VP36:%.*]] = phi  [ i32 [[VP31]], [[BB4]] ],  [ i32 [[VP18]], [[BB5]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds ptr [[C0:%.*]] i64 [[VP9]]
; CHECK-NEXT:     store i32 [[VP36]] ptr [[VP_SUBSCRIPT_5]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_6:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_SUBSCRIPT_6]]
; CHECK-NEXT:     i64 [[VP37:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_7:%.*]] = subscript inbounds ptr [[A0]] i64 [[VP37]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_3]] i32 [[VP35]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP38:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      live-out : i32 [[VP38]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] ptr [[VP_SUBSCRIPT_7]]
; CHECK-NEXT:     i64 [[VP10]] = add i64 [[VP9]] i64 1
; CHECK-NEXT:     i1 [[VP39:%.*]] = icmp slt i64 [[VP10]] i64 [[VP8]]
; CHECK-NEXT:     br i1 [[VP39]], [[BB2]], [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    int x = A[index];
;    int y = 0;
;    if (i%2==0){
;      C[i] = i;
;      D[i] = i + 10;
;      y = C[i] * D[i] - E[i];
;    }else{
;      C[i] = i + 10;
;      E[i] = i;
;      y = C[i] + D[i] * E[i];
;    }
;    A[index] = A[index] + y;
;  }
  %cmp64 = icmp sgt i32 %N, 0
  br i1 %cmp64, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count69 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %if.end
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %if.end
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end ]
  %i.065 = phi i32 [ 0, %for.body.preheader ], [ %inc, %if.end ]
  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %idxprom1
  %1 = trunc i64 %indvars.iv to i32
  %rem = and i32 %1, 1
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %add = add nuw nsw i32 %i.065, 10
  %arrayidx7 = getelementptr inbounds i32, ptr %D, i64 %indvars.iv
  %2 = add i32 %1, 10
  store i32 %2, ptr %arrayidx7, align 4
  %mul = mul nsw i32 %add, %1
  %arrayidx13 = getelementptr inbounds i32, ptr %E, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx13, align 4
  %sub = sub nsw i32 %mul, %3
  br label %if.end

if.else:                                          ; preds = %for.body
  %4 = add i32 %1, 10
  %arrayidx18 = getelementptr inbounds i32, ptr %E, i64 %indvars.iv
  store i32 %1, ptr %arrayidx18, align 4
  %arrayidx22 = getelementptr inbounds i32, ptr %D, i64 %indvars.iv
  %5 = load i32, ptr %arrayidx22, align 4
  %mul25 = mul nsw i32 %5, %1
  %add26 = add nsw i32 %mul25, %4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %.sink = phi i32 [ %1, %if.then ], [ %4, %if.else ]
  %y.0 = phi i32 [ %sub, %if.then ], [ %add26, %if.else ]
  %6 = getelementptr inbounds i32, ptr %C, i64 %indvars.iv
  store i32 %.sink, ptr %6, align 4
  %7 = load i32, ptr %arrayidx2, align 4
  %add29 = add nsw i32 %7, %y.0
  store i32 %add29, ptr %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %inc = add nuw nsw i32 %i.065, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count69
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo4(ptr noalias nocapture %A, ptr noalias nocapture readonly %B, ptr noalias nocapture readonly %C, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo4:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%y.0}
; CHECK-DAG:     [[VP1:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP2:%.*]] = {%B}
; CHECK-DAG:     [[VP3:%.*]] = {%A}
; CHECK-DAG:     [[VP4:%.*]] = {%C}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = add i64 [[VP1]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB3]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i32 [[VP8:%.*]] = trunc i64 [[VP6]] to i32
; CHECK-NEXT:     i32 [[VP9:%.*]] = hir-copy i32 [[VP8]] , OriginPhiId: -1
; CHECK-NEXT:     i1 [[VP10:%.*]] = trunc i64 [[VP6]] to i1
; CHECK-NEXT:     i1 [[VP11:%.*]] = mul i1 true i1 [[VP10]]
; CHECK-NEXT:     i32 [[VP12:%.*]] = zext i1 [[VP11]] to i32
; CHECK-NEXT:     i1 [[VP13:%.*]] = icmp ne i32 [[VP12]] i32 0
; CHECK-NEXT:     br i1 [[VP13]], [[BB4:BB[0-9]+]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       ptr [[VP_SUBSCRIPT_C0:%.*]] = subscript inbounds ptr [[C0:%.*]]
; CHECK-NEXT:       i32 [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_C0]]
; CHECK-NEXT:       i32 [[VP14:%.*]] = trunc i64 [[VP6]] to i32
; CHECK-NEXT:       i32 [[VP15:%.*]] = add i32 [[VP_LOAD_1]] i32 [[VP14]]
; CHECK-NEXT:       i32 [[VP16:%.*]] = hir-copy i32 [[VP15]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB2]]
; CHECK-NEXT:     i32 [[VP17:%.*]] = phi  [ i32 [[VP16]], [[BB4]] ],  [ i32 [[VP9]], [[BB2]] ]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i64 [[VP18:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[A0]] i64 [[VP18]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_2]] i32 [[VP17]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP19:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      live-out : i32 [[VP19]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] ptr [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP20:%.*]] = icmp slt i64 [[VP7]] i64 [[VP5]]
; CHECK-NEXT:     br i1 [[VP20]], [[BB2]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br <External Block>
;
entry:
;   for (int i=0; i<N; i++){
;     index = B[i];
;     int x = A[index];
;     int y = 0;
;     if (i%2==0)
;        y = i;
;     else
;     y = i + C[0];
;     A[index] = A[index] + y;
;   }
  %cmp23 = icmp sgt i32 %N, 0
  br i1 %cmp23, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count25 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %if.end
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %if.end
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end ]
  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %idxprom1
  %1 = trunc i64 %indvars.iv to i32
  %rem = and i32 %1, 1
  %cmp3 = icmp eq i32 %rem, 0
  br i1 %cmp3, label %if.end, label %if.else

if.else:                                          ; preds = %for.body
  %2 = load i32, ptr %C, align 4
  %add = add nsw i32 %2, %1
  br label %if.end

if.end:                                           ; preds = %for.body, %if.else
  %y.0 = phi i32 [ %add, %if.else ], [ %1, %for.body ]
  %3 = load i32, ptr %arrayidx2, align 4
  %add7 = add nsw i32 %3, %y.0
  store i32 %add7, ptr %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count25
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind uwtable mustprogress
define dso_local void @foo5(ptr noalias nocapture %A, ptr noalias nocapture readonly %B, ptr noalias nocapture readonly %C, ptr noalias nocapture readonly %D, ptr noalias nocapture readonly %E, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo5:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP1:%.*]] = {%D}
; CHECK-DAG:     [[VP2:%.*]] = {%B}
; CHECK-DAG:     [[VP3:%.*]] = {%A}
; CHECK-DAG:     [[VP4:%.*]] = {%E}
; CHECK-DAG:     [[VP5:%.*]] = {%C}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[VP6:%.*]] = add i64 [[VP0]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP7:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP8:%.*]], [[BB2]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP7]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_C0:%.*]] = subscript inbounds ptr [[C0:%.*]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_C0]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[E0:%.*]] i64 2
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds ptr [[D0:%.*]] i64 3
; CHECK-NEXT:     i32 [[VP_LOAD_4:%.*]] = load ptr [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i32 [[VP9:%.*]] = mul i32 [[VP_LOAD_3]] i32 [[VP_LOAD_2]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds ptr [[A0]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_1]] i32 [[VP_LOAD_4]] i32 [[VP9]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN2:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP11:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      i32 [[VP12:%.*]] = add i32 [[VP11]] i32 [[VP_LIVE_IN2]]
; CHECK-NEXT:      live-out : i32 [[VP12]] = add i32 [[VP11]] i32 [[VP_LIVE_IN2]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] ptr [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     i64 [[VP8]] = add i64 [[VP7]] i64 1
; CHECK-NEXT:     i1 [[VP13:%.*]] = icmp slt i64 [[VP8]] i64 [[VP6]]
; CHECK-NEXT:     br i1 [[VP13]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    A[index] = A[index] + C[0]*E[2] + D[3];
;  }
  %arrayidx4 = getelementptr inbounds i32, ptr %E, i64 2
  %arrayidx5 = getelementptr inbounds i32, ptr %D, i64 3
  %cmp15 = icmp sgt i32 %N, 0
  br i1 %cmp15, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count17 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %idxprom1
  %1 = load i32, ptr %arrayidx2, align 4
  %2 = load i32, ptr %C, align 4
  %3 = load i32, ptr %arrayidx4, align 4
  %mul = mul nsw i32 %3, %2
  %add = add nsw i32 %mul, %1
  %4 = load i32, ptr %arrayidx5, align 4
  %add6 = add nsw i32 %add, %4
  store i32 %add6, ptr %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count17
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

define dso_local void @foo6(ptr noalias nocapture %A, ptr noalias nocapture readonly %B, ptr noalias nocapture %D, ptr noalias nocapture readonly %E, i32 %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after VPlanHIRDecomposer:
; CHECK-NEXT:  VPlan IR for: foo6:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%D}
; CHECK-DAG:     [[VP1:%.*]] = {%0}
; CHECK-DAG:     [[VP2:%.*]] = {%B}
; CHECK-DAG:     [[VP3:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP4:%.*]] = {%A}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = add i64 [[VP3]] i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB2]] ]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[B0:%.*]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load ptr [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds ptr [[D0:%.*]] i64 [[VP6]]
; CHECK-NEXT:     i32 [[VP_LOAD_2:%.*]] = load ptr [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     i32 [[VP8:%.*]] = add i32 [[VP_LOAD_2]] i32 [[TMP0:%.*]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds ptr [[D0]] i64 [[VP6]]
; CHECK-NEXT:     store i32 [[VP8]] ptr [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds ptr [[A0]] i64 [[VP_VCONFLICT_INDEX]]
; CHECK-NEXT:     i32 [[VP_GENERAL_MEM_OPT_CONFLICT:%.*]] = vp-general-mem-opt-conflict i64 [[VP_VCONFLICT_INDEX]] void [[VP_CONFLICT_REGION:%.*]] i32 [[VP_LOAD_1]] i32 [[VP_LOAD_2]] -> VConflictRegion {
; CHECK-NEXT:      value : none
; CHECK-NEXT:      mask : none
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN0:%.*]]
; CHECK-NEXT:      live-in : i32 [[VP_LIVE_IN1:%.*]]
; CHECK-NEXT:      Region:
; CHECK-NEXT:      VConflictBB
; CHECK-NEXT:      i32 [[VP10:%.*]] = add i32 [[VP_LIVE_IN0]] i32 [[VP_LIVE_IN1]]
; CHECK-NEXT:      i32 [[VP11:%.*]] = add i32 [[VP10]] i32 [[TMP0]]
; CHECK-NEXT:      live-out : i32 [[VP11]] = add i32 [[VP10]] i32 [[TMP0]]
; CHECK-NEXT:     }
; CHECK-NEXT:     store i32 [[VP_GENERAL_MEM_OPT_CONFLICT]] ptr [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP12:%.*]] = icmp slt i64 [[VP7]] i64 [[VP5]]
; CHECK-NEXT:     br i1 [[VP12]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
;  for (int i=0; i<N; i++){
;    index = B[i];
;    int x = A[index];
;    D[i] = D[i] + E[0];
;    A[index] = x + D[i];
;  }
  %cmp25 = icmp sgt i32 %N, 0
  br i1 %cmp25, label %for.body.lr.ph, label %for.cond.cleanup

for.body.lr.ph:                                   ; preds = %entry
  %0 = load i32, ptr %E, align 4
  %wide.trip.count27 = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx, align 4
  %idxprom1 = sext i32 %1 to i64
  %arrayidx2 = getelementptr inbounds i32, ptr %A, i64 %idxprom1
  %2 = load i32, ptr %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds i32, ptr %D, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx4, align 4
  %add = add nsw i32 %0, %3
  store i32 %add, ptr %arrayidx4, align 4
  %add10 = add nsw i32 %add, %2
  store i32 %add10, ptr %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count27
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

attributes #0 = { nofree norecurse nounwind uwtable mustprogress "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-jump-tables"="false" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "pre_loopopt" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+avx,+avx2,+bmi,+bmi2,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" "unsafe-fp-math"="true" "use-soft-float"="false" }
