; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -VPlanDriver -vplan-use-entity-instr -enable-vp-value-codegen -vplan-force-vf=16 -S < %s 2>&1 | FileCheck %s

; CHECK-LABEL: @foo(
; CHECK:       vector.ph:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <16 x i64> undef, i64 [[TMP2:%.*]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <16 x i64> [[BROADCAST_SPLATINSERT]], <16 x i64> undef, <16 x i32> zeroinitializer
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[TMP21:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, [[VECTOR_PH]] ], [ [[TMP20:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 [[UNI_PHI]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i32* [[SCALAR_GEP]] to <16 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <16 x i32>, <16 x i32>* [[TMP4]], align 4
; CHECK-NEXT:    [[SCALAR_GEP1:%.*]] = getelementptr inbounds [1024 x i32], [1024 x i32]* @b, i64 0, i64 [[UNI_PHI]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32* [[SCALAR_GEP1]] to <16 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD2:%.*]] = load <16 x i32>, <16 x i32>* [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = icmp sgt <16 x i32> [[WIDE_LOAD]], [[WIDE_LOAD2]]
; CHECK-NEXT:    [[TMP7:%.*]] = icmp eq <16 x i32> [[WIDE_LOAD]], <i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16, i32 16>
; CHECK-NEXT:    [[TMP8:%.*]] = mul nsw <16 x i32> [[WIDE_LOAD2]], [[WIDE_LOAD]]
; CHECK-NEXT:    [[TMP9:%.*]] = add nsw <16 x i32> [[WIDE_LOAD2]], [[WIDE_LOAD]]
; CHECK-NEXT:    [[TMP10:%.*]] = select <16 x i1> [[TMP7]], <16 x i32> [[TMP8]], <16 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
; CHECK-NEXT:    [[TMP11:%.*]] = select <16 x i1> [[TMP7]], <16 x i32> [[TMP9]], <16 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
; CHECK-NEXT:    [[TMP12:%.*]] = mul nsw <16 x i32> [[WIDE_LOAD2]], [[WIDE_LOAD2]]
; CHECK-NEXT:    [[TMP13:%.*]] = mul nsw <16 x i32> [[WIDE_LOAD]], [[WIDE_LOAD]]
; CHECK-NEXT:    [[PREDPHI:%.*]] = select <16 x i1> [[TMP6]], <16 x i32> [[TMP12]], <16 x i32> zeroinitializer
; CHECK-NEXT:    [[PREDPHI3:%.*]] = select <16 x i1> [[TMP6]], <16 x i32> [[TMP13]], <16 x i32> zeroinitializer
; CHECK-NEXT:    [[PREDPHI4:%.*]] = select <16 x i1> [[TMP6]], <16 x i32> [[TMP10]], <16 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
; CHECK-NEXT:    [[PREDPHI5:%.*]] = select <16 x i1> [[TMP6]], <16 x i32> [[TMP11]], <16 x i32> <i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1, i32 1>
; CHECK-NEXT:    [[TMP14:%.*]] = mul nsw <16 x i32> [[PREDPHI4]], [[PREDPHI]]
; CHECK-NEXT:    [[TMP15:%.*]] = add nsw <16 x i32> [[TMP14]], [[WIDE_LOAD2]]
; CHECK-NEXT:    [[TMP16:%.*]] = bitcast i32* [[SCALAR_GEP1]] to <16 x i32>*
; CHECK-NEXT:    store <16 x i32> [[TMP15]], <16 x i32>* [[TMP16]], align 4
; CHECK-NEXT:    [[TMP17:%.*]] = mul nsw <16 x i32> [[PREDPHI5]], [[PREDPHI3]]
; CHECK-NEXT:    [[TMP18:%.*]] = add nsw <16 x i32> [[TMP17]], [[WIDE_LOAD]]
; CHECK-NEXT:    [[TMP19:%.*]] = bitcast i32* [[SCALAR_GEP]] to <16 x i32>*
; CHECK-NEXT:    store <16 x i32> [[TMP18]], <16 x i32>* [[TMP19]], align 4
; CHECK-NEXT:    [[TMP20]] = add nuw nsw <16 x i64> [[VEC_PHI]], <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
; CHECK-NEXT:    [[TMP21]] = add nuw nsw i64 [[UNI_PHI]], 16
; CHECK-NEXT:    [[TMP22:%.*]] = icmp slt <16 x i64> [[TMP20]], [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[TMP23:%.*]] = extractelement <16 x i1> [[TMP22]], i32 0
; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX]], 16
; CHECK-NEXT:    [[TMP24:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC:%.*]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[VPLANNEDBB:%.*]], label [[VECTOR_BODY]]

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"

@N = common local_unnamed_addr global i32 0, align 4
@a = common local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@b = common local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

; Function Attrs: noinline norecurse nounwind uwtable
define i32 @foo() local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %L1

L1:
  %0 = load i32, i32* @N, align 4
  %cmp54 = icmp sgt i32 %0, 0
  br i1 %cmp54, label %for.body.lr.ph, label %DIR.OMP.END.SIMD.1

for.body.lr.ph:                                   ; preds = %L1
  %1 = load i32, i32* @N, align 4
  %2 = sext i32 %1 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %if.end26
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %if.end26 ]
  %arrayidx = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv
  %3 = load i32, i32* %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds [1024 x i32], [1024 x i32]* @b, i64 0, i64 %indvars.iv
  %4 = load i32, i32* %arrayidx2, align 4
  %cmp3 = icmp sgt i32 %3, %4
  br i1 %cmp3, label %if.then, label %if.end26

if.then:                                          ; preds = %for.body
  %cmp6 = icmp eq i32 %3, 16
  %mul = mul nsw i32 %4, %3
  %add = add nsw i32 %4, %3
  %5 = select i1 %cmp6, i32 %mul, i32 1
  %6 = select i1 %cmp6, i32 %add, i32 1
  %mul20 = mul nsw i32 %4, %4
  %mul25 = mul nsw i32 %3, %3
  br label %if.end26

if.end26:                                         ; preds = %if.then, %for.body
  %mb.0 = phi i32 [ %mul20, %if.then ], [ 0, %for.body ]
  %ma.0 = phi i32 [ %mul25, %if.then ], [ 0, %for.body ]
  %mc.1 = phi i32 [ %5, %if.then ], [ 1, %for.body ]
  %md.1 = phi i32 [ %6, %if.then ], [ 1, %for.body ]
  %mul27 = mul nsw i32 %mc.1, %mb.0
  %add30 = add nsw i32 %mul27, %4
  store i32 %add30, i32* %arrayidx2, align 4
  %mul31 = mul nsw i32 %md.1, %ma.0
  %add34 = add nsw i32 %mul31, %3
  store i32 %add34, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp slt i64 %indvars.iv.next, %2
  br i1 %cmp, label %for.body, label %loop.exit

loop.exit:                                        ; preds = %if.end26
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:                               ; preds = loop.exit
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.QUAL.LIST.END.2

DIR.QUAL.LIST.END.2:                              ; preds = %DIR.OMP.END.SIMD.1
  ret i32 0
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
