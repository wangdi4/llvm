; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -VPlanDriver -vplan-force-vf=2 -vplan-print-after-create-masked-vplan -vplan-enable-masked-variant < %s | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @main(i32 %N) {
; CHECK-LABEL:  VPlan after emitting masked variant:
; CHECK-NEXT:  VPlan IR for: main:for.body.cloned.masked
; CHECK-NEXT:    Cloned.[[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] br Cloned.[[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    Cloned.[[BB1]]: # preds: Cloned.[[BB0]]
; CHECK-NEXT:     [DA: Div] i32 [[VP0:%.*]] = induction-init{add} i32 live-in0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP1:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP2:%.*]] = vector-trip-count i32 [[N0:%.*]], UF = 1
; CHECK-NEXT:     [DA: Uni] br Cloned.[[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    Cloned.[[BB2]]: # preds: Cloned.[[BB1]], new_latch
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV:%.*]] = phi  [ i32 [[VP0]], Cloned.[[BB1]] ],  [ i32 [[VP_IV_NEXT:%.*]], new_latch ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BOTTOM_TEST:%.*]] = icmp eq i32 [[VP_IV]] i32 [[VP2]]
; CHECK-NEXT:     [DA: Div] br i1 [[VP_BOTTOM_TEST]], [[BB3:BB[0-9]+]], new_latch
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: Cloned.[[BB2]]
; CHECK-NEXT:       [DA: Uni] br new_latch
; CHECK-EMPTY:
; CHECK-NEXT:    new_latch: # preds: [[BB3]], Cloned.[[BB2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 [[VP1]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BOTTOM_TEST_1:%.*]] = icmp eq i32 [[VP_IV_NEXT]] i32 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_BOTTOM_TEST_1]], Cloned.[[BB4:BB[0-9]+]], Cloned.[[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    Cloned.[[BB4]]: # preds: new_latch
; CHECK-NEXT:     [DA: Uni] i32 [[VP3:%.*]] = induction-final{add} i32 live-in0 i32 1
; CHECK-NEXT:     [DA: Uni] br Cloned.[[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    Cloned.[[BB5]]: # preds: Cloned.[[BB4]]
; CHECK-NEXT:     [DA: Uni] br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0     [[LCSSA_PHI0:%.*]] = phi i32 [ [[IV_NEXT0:%.*]], [[FOR_BODY0:%.*]] ] i32 [[VP3]] -> i32 [[IV_NEXT0]]
; CHECK:       target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
; CHECK-NEXT:  target triple = "x86_64-unknown-linux-gnu"
;
; CHECK:  define void @main(i32 [[N0]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[PREHEADER0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  preheader:
; CHECK-NEXT:    br label [[VPLANNEDBB0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[VPLANNEDBB10:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB1:
; CHECK-NEXT:    [[TMP0:%.*]] = and i32 [[N0]], -2
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 0, [[TMP0]]
; CHECK-NEXT:    br i1 [[TMP1]], label [[SCALAR_PH0:%.*]], label [[VECTOR_PH0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP3:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VECTOR_PH0]] ], [ [[TMP2:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[TMP2]] = add nsw <2 x i32> [[VEC_PHI0]], <i32 2, i32 2>
; CHECK-NEXT:    [[TMP3]] = add nsw i32 [[UNI_PHI0]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i32 [[TMP3]], [[TMP0]]
; CHECK-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB30:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB3:
; CHECK-NEXT:    [[TMP5:%.*]] = mul i32 1, [[TMP0]]
; CHECK-NEXT:    [[TMP6:%.*]] = add i32 0, [[TMP5]]
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ne i32 [[N0]], [[TMP0]]
; CHECK-NEXT:    br i1 [[TMP7]], label [[SCALAR_PH0]], label [[VPLANNEDBB40:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    [[UNI_PHI50:%.*]] = phi i32 [ [[TMP6]], [[MIDDLE_BLOCK0]] ], [ 0, [[VPLANNEDBB10]] ]
; CHECK-NEXT:    br label [[VPLANNEDBB60:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB6:
; CHECK-NEXT:    br label [[FOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB4:
; CHECK-NEXT:    [[UNI_PHI70:%.*]] = phi i32 [ [[IV_NEXT0]], [[FOR_BODY0]] ], [ [[TMP6]], [[MIDDLE_BLOCK0]] ]
; CHECK-NEXT:    br label [[VPLANNEDBB80:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB8:
; CHECK-NEXT:    br label [[LOOPEXIT0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  for.body:
; CHECK-NEXT:    [[IV0:%.*]] = phi i32 [ [[UNI_PHI50]], [[VPLANNEDBB60]] ], [ [[IV_NEXT0]], [[FOR_BODY0]] ]
; CHECK-NEXT:    [[IV_NEXT0]] = add nsw i32 [[IV0]], 1
; CHECK-NEXT:    [[BOTTOM_TEST0:%.*]] = icmp eq i32 [[IV_NEXT0]], [[N0]]
; CHECK-NEXT:    br i1 [[BOTTOM_TEST0]], label [[VPLANNEDBB40]], label [[FOR_BODY0]], !llvm.loop !2
; CHECK-EMPTY:
; CHECK-NEXT:  loopexit:
; CHECK-NEXT:    [[LCSSA_PHI0]] = phi i32 [ [[UNI_PHI70]], [[VPLANNEDBB80]] ]
; CHECK-NEXT:    [[ADD_FINAL0:%.*]] = add nsw i32 [[LCSSA_PHI0]], 1
; CHECK-NEXT:    br label [[BB:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  bb:
; CHECK-NEXT:    br label [[EXIT0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  exit:
; CHECK-NEXT:    ret void
; CHECK-NEXT:  }
;
entry:
  br label %preheader

preheader:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %for.body ]
  %iv.next = add nsw i32 %iv, 1
  %bottom_test = icmp eq i32 %iv.next, %N
  br i1 %bottom_test, label %loopexit, label %for.body

loopexit:
  %lcssa.phi = phi i32 [ %iv.next, %for.body ]
  %add.final = add nsw i32 %lcssa.phi, 1
  br label %bb

bb:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret void
}

declare token @llvm.directive.region.entry() nounwind
declare void @llvm.directive.region.exit(token) nounwind
