; Test to verify that VPlan vectorizer handles FP min/max array reduction
; optimized in SOA layout.

; C/C++ source
; float test(float init, int n, float *A)
; {
;   float min[9];
;   for (int i = 0; i < 9; i++)
;     min[i] = init;
;
;   #pragma omp simd reduction(min:min)
;   for (int l1 = 0; l1 < n; l1++) {
;      for (int l2 = 0; l2 < 9; l2++)
;       min[l2] = min[l2] < A[l1] ? min[l2] : A[l1];
;   }
;
;   return min[9];
; }

; RUN: opt -passes=vplan-vec -vplan-force-vf=2 -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-dump-soa-info -print-after=vplan-vec -disable-output < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define float @test(ptr nocapture readonly %A, i64 %N, float %init) {
; CHECK: VPlan after insertion of VPEntities instructions:
; CHECK: Reduction list
; CHECK:  (FloatMin) Start: ptr %min
; CHECK:   Linked values: ptr [[VPMINALLOCA:%.*]],
; CHECK:  Memory: ptr %min

; CHECK: ptr [[VPMINALLOCA]] = allocate-priv [9 x float], OrigAlign = 4
; CHECK: reduction-init-arr float 0x7FF0000000000000 ptr [[VPMINALLOCA]]
; CHECK: [9 x float] [[VPMINFIN:%.*]] = reduction-final-arr{fmin} ptr [[VPMINALLOCA]] ptr %min

; CHECK:      SOA profitability:
; CHECK-NEXT: SOASafe = [[VPMINALLOCA]] (min) Profitable = 1

; Checks for code generated by LLVM-IR vectorizer.
; CHECK-LABEL: define float @test
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[MIN:%.*]] = alloca [9 x float], align 4
; CHECK-NEXT:    [[MIN_GEP:%.*]] = getelementptr inbounds [9 x float], ptr [[MIN]], i64 0, i64 0
; CHECK-NEXT:    [[MIN_SOA_VEC:%.*]] = alloca [9 x <2 x float>], align 8
; CHECK-NEXT:    br label [[FILL_MIN:%.*]]

; CHECK:       VPlannedBB2:
; CHECK:         [[SOA_SCALAR_GEP:%.*]] = getelementptr inbounds [9 x <2 x float>], ptr [[MIN_SOA_VEC]], i64 0, i64 0
; CHECK-NEXT:    br label [[ARRAY_REDN_INIT_LOOP:%.*]]
; CHECK:       array.redn.init.loop:
; CHECK-NEXT:    [[CUR_ELEM_IDX:%.*]] = phi i64 [ 0, [[VPLANNEDBB2:%.*]] ], [ [[NEXT_ELEM_IDX:%.*]], [[ARRAY_REDN_INIT_LOOP:%.*]] ]
; CHECK-NEXT:    [[CUR_ELEM_PTR:%.*]] = getelementptr float, ptr [[MIN_SOA_VEC]], i64 [[CUR_ELEM_IDX]]
; CHECK-NEXT:    store float 0x7FF0000000000000, ptr [[CUR_ELEM_PTR]], align 4
; CHECK-NEXT:    [[NEXT_ELEM_IDX]] = add i64 [[CUR_ELEM_IDX]], 1
; CHECK-NEXT:    [[INITLOOP_COND:%.*]] = icmp ult i64 [[NEXT_ELEM_IDX]], 18
; CHECK-NEXT:    br i1 [[INITLOOP_COND]], label [[ARRAY_REDN_INIT_LOOP]], label [[ARRAY_REDN_INIT_LOOPEXIT:%.*]]

; CHECK:       soa.array.redn.final.loop:
; CHECK-NEXT:    [[TMP10:%.*]] = phi i64 [ 0, [[VPLANNEDBB9:%.*]] ], [ [[TMP17:%.*]], [[SOA_ARRAY_REDN_FINAL_LOOP:%.*]] ]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr [9 x <2 x float>], ptr [[MIN_SOA_VEC]], i64 0, i64 [[TMP10]]
; CHECK-NEXT:    [[TMP12:%.*]] = load <2 x float>, ptr [[TMP11]], align 8
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr [9 x float], ptr [[MIN]], i64 0, i64 [[TMP10]]
; CHECK-NEXT:    [[TMP14:%.*]] = load float, ptr [[TMP13]], align 4
; CHECK-NEXT:    [[TMP15:%.*]] = call fast float @llvm.vector.reduce.fmin.v2f32(<2 x float> [[TMP12]])
; CHECK-NEXT:    [[TMP16:%.*]] = call fast float @llvm.minnum.f32(float [[TMP15]], float [[TMP14]])
; CHECK-NEXT:    store float [[TMP16]], ptr [[TMP13]], align 4
; CHECK-NEXT:    [[TMP17]] = add i64 [[TMP10]], 1
; CHECK-NEXT:    [[TMP18:%.*]] = icmp ult i64 [[TMP17]], 9
; CHECK-NEXT:    br i1 [[TMP18]], label [[SOA_ARRAY_REDN_FINAL_LOOP]], label [[SOA_ARRAY_REDN_FINAL_LOOP_EXIT:%.*]]
;
entry:
  %min = alloca [9 x float], align 4
  %min.gep = getelementptr inbounds [9 x float], ptr %min, i64 0, i64 0
  br label %fill.min

fill.min:
  %arr.begin = getelementptr inbounds [9 x float], ptr %min, i32 0, i32 0
  %arr.end = getelementptr float, ptr %arr.begin, i32 9
  %red.init.isempty = icmp eq ptr %arr.begin, %arr.end
  br i1 %red.init.isempty, label %begin.simd.1, label %red.init.body

red.init.body:
  %red.curr.ptr = phi ptr [ %arr.begin, %fill.min ], [ %red.next.ptr, %red.init.body ]
  store float %init, ptr %red.curr.ptr, align 4
  %red.next.ptr = getelementptr inbounds float, ptr %red.curr.ptr, i32 1
  %red.init.done = icmp eq ptr %red.next.ptr, %arr.end
  br i1 %red.init.done, label %begin.simd.1, label %red.init.body

begin.simd.1:
  br label %begin.simd

begin.simd:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.MIN:TYPED"(ptr %min.gep, float 0.000000e+00, i32 9) ]
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ %indvars.iv.next, %latch ], [ 0, %begin.simd ]
  %arrayidx = getelementptr inbounds float, ptr %A, i64 %indvars.iv
  %A.i = load float, ptr %arrayidx, align 4
  br label %inner.loop

inner.loop:
  %inner.iv = phi i64 [ 0, %for.body ], [ %inner.iv.next, %inner.loop ]
  %min.idx = getelementptr inbounds [9 x float], ptr %min.gep, i64 0, i64 %inner.iv
  %min.ld = load float, ptr %min.idx, align 4
  %cmp = fcmp fast olt float %A.i, %min.ld
  %select = select fast i1 %cmp, float %A.i, float %min.ld
  store float %select, ptr %min.idx, align 4
  %inner.iv.next = add nuw nsw i64 %inner.iv, 1
  %inner.exitcond = icmp slt i64 %inner.iv.next, 9
  br i1 %inner.exitcond, label %inner.loop, label %latch

latch:
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp slt i64 %indvars.iv.next, %N
  br i1 %exitcond, label %for.body, label %for.cond.cleanup.loopexit

for.cond.cleanup.loopexit:                             ; preds = %for.body
  br label %end.simd

end.simd:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.QUAL.LIST.END.3

DIR.QUAL.LIST.END.3:
  %fin.gep = getelementptr inbounds [9 x float], ptr %min, i32 0, i32 9
  %fin = load float, ptr %fin.gep, align 4
  ret float %fin

}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
