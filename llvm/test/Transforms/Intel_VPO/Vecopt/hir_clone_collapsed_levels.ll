; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2
; RUN: opt -disable-output -passes='hir-ssa-deconstruction,hir-loop-collapse,hir-vec-dir-insert,hir-vplan-vec,print<hir>' -hir-details -vplan-force-vf=16 -vplan-enable-masked-main-loop -vec-threshold=0 < %s 2>&1 | FileCheck %s
;
; LIT test to check that we preserve number of collapsed levels during HIR
; vector code generation.
;
; HIR coming into vectorizer looks like:
;      + DO i64 i1 = 0, 8, 1   <DO_LOOP>  <MAX_TC_EST = 100>  <LEGAL_MAX_TC = 100>
;      |   %0 = (@arr2)[0][0][i1];
;      |   <RVAL-REG> {al:8}{Collapsed levels:2}(LINEAR ptr @arr2)[i64 0][i64 0][LINEAR i64 i1] inbounds
;      |
;      |   (@arr1)[0][0][i1] = %0 + 1;
;      |   <LVAL-REG> {al:8}{Collapsed levels:2}(LINEAR ptr @arr1)[i64 0][i64 0][LINEAR i64 i1] inbounds
;      + END LOOP
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@arr2 = local_unnamed_addr global [3 x [3 x i64]] zeroinitializer, align 16
@arr1 = local_unnamed_addr global [3 x [3 x i64]] zeroinitializer, align 16

define void @foo() {
; CHECK-LABEL:  Function: foo
; CHECK:       BEGIN REGION { modified }
; CHECK:             [[DOTVEC30:%.*]] = (<16 x i64>*)(@arr2)[0][0][0], Mask = @{%.vec2}
; CHECK-NEXT:        <LVAL-REG> NON-LINEAR <16 x i64> [[DOTVEC30]] {sb:24}
; CHECK-NEXT:        <RVAL-REG> {al:8}{Collapsed levels:2}(<16 x i64>*)(LINEAR ptr @arr2)[i64 0][i64 0][i64 0] inbounds  {sb:15}
; CHECK-NEXT:           <BLOB> LINEAR ptr @arr2 {sb:6}
; CHECK:             (<16 x i64>*)(@arr1)[0][0][0] = [[DOTVEC30]] + 1, Mask = @{%.vec2}
; CHECK-NEXT:        <LVAL-REG> {al:8}{Collapsed levels:2}(<16 x i64>*)(LINEAR ptr @arr1)[i64 0][i64 0][i64 0] inbounds  {sb:16}
; CHECK-NEXT:           <BLOB> LINEAR ptr @arr1 {sb:10}
; CHECK-NEXT:        <RVAL-REG> NON-LINEAR <16 x i64> [[DOTVEC30]] + 1 {sb:2}
; CHECK-NEXT:           <BLOB> NON-LINEAR <16 x i64> [[DOTVEC30]] {sb:24}
; CHECK:       END REGION
;
entry:
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.inc7
  %l1.017 = phi i64 [ 0, %entry ], [ %inc8, %for.inc7 ]
  br label %for.body3

for.body3:                                        ; preds = %for.cond1.preheader, %for.body3
  %l2.016 = phi i64 [ 0, %for.cond1.preheader ], [ %inc, %for.body3 ]
  %arrayidx4 = getelementptr inbounds [3 x [3 x i64]], ptr @arr2, i64 0, i64 %l1.017, i64 %l2.016
  %0 = load i64, ptr %arrayidx4, align 8
  %add = add nsw i64 %0, 1
  %arrayidx6 = getelementptr inbounds [3 x [3 x i64]], ptr @arr1, i64 0, i64 %l1.017, i64 %l2.016
  store i64 %add, ptr %arrayidx6, align 8
  %inc = add nuw nsw i64 %l2.016, 1
  %exitcond.not = icmp eq i64 %inc, 3
  br i1 %exitcond.not, label %for.inc7, label %for.body3

for.inc7:                                         ; preds = %for.body3
  %inc8 = add nuw nsw i64 %l1.017, 1
  %exitcond18.not = icmp eq i64 %inc8, 3
  br i1 %exitcond18.not, label %for.end9, label %for.cond1.preheader

for.end9:                                         ; preds = %for.inc7
  ret void
}
