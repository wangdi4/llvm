; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -mtriple=x86_64 -passes=vplan-vec -S < %s | FileCheck %s
; RUN: opt -mtriple=x86_64 -passes='hir-ssa-deconstruction,hir-vplan-vec,hir-cg' -S < %s | FileCheck %s

; Test that VPlan vectorizer can handle vector variant dispatcher routine (ifunc).

; auto-cpu-clone pass runs right after vec-clone and if a vector variant
; is scheduled for dispatching to multiple CPUs, such routine tirned into
; a dispatcher routine which does have type GlobalIFunc (a sibling of
; Function class). Make sure that we can use the ifunc but not try to
; create another instance of it. Attempt to insert a declaration that has
; name conflict actually handled at module level not quite correctly:
; the routine turns out renamed when it is being inserted into module
; by adding a suffix (period character followed by a number).

@_ZGVxN4v__Z12FindPositiond = dso_local ifunc <4 x i32> (<2 x double>, <2 x double>), ptr @_ZGVxN4v__Z12FindPositiond.resolver

define dso_local ptr @_ZGVxN4v__Z12FindPositiond.resolver() {
; Body has been removed for simplicity
  ret ptr null
}

%struct.point = type { double, double }

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable
declare dso_local noundef i32 @_Z12FindPositiond(double noundef nofpclass(nan inf)) local_unnamed_addr #0

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

; Function Attrs: mustprogress nofree noinline nosync nounwind willreturn memory(readwrite) uwtable
define dso_local x86_regcallcc noundef nofpclass(nan inf) <4 x double> @_ZGVYN4vu__Z11InterpolatedPK5point(<4 x double> noundef nofpclass(nan inf) %x, ptr noundef %vals) local_unnamed_addr #2 {
; CHECK-LABEL: define dso_local x86_regcallcc noundef nofpclass(nan inf) <4 x double> @_ZGVYN4vu__Z11InterpolatedPK5point
; CHECK-SAME:  (<4 x double> noundef nofpclass(nan inf) [[X:%.*]], ptr noundef [[VALS:%.*]]) local_unnamed_addr #[[ATTR2:[0-9]+]] {
; CHECK:         [[TMP:%.*]] = call x86_regcallcc noundef <4 x i32> @_ZGVxN4v__Z12FindPositiond(<2 x double> noundef nofpclass(nan inf) [[WIDE_LOAD_PART_1:%.*]], <2 x double> noundef nofpclass(nan inf) [[WIDE_LOAD_PART_2:%.*]])
;
entry:
  %alloca.vals = alloca ptr, align 8
  store ptr %vals, ptr %alloca.vals, align 8
  %vec.x = alloca <4 x double>, align 32
  %vec.retval = alloca <4 x double>, align 32
  store <4 x double> %x, ptr %vec.x, align 32
  br label %simd.begin.region

simd.begin.region:                                ; preds = %entry
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4), "QUAL.OMP.UNIFORM:TYPED"(ptr %alloca.vals, ptr null, i32 1) ]
  br label %simd.loop.preheader

simd.loop.preheader:                              ; preds = %simd.begin.region
  %load.vals = load ptr, ptr %alloca.vals, align 8
  br label %simd.loop.header

simd.loop.header:                                 ; preds = %simd.loop.header, %simd.loop.preheader
  %index = phi i32 [ 0, %simd.loop.preheader ], [ %indvar, %simd.loop.header ]
  %vec.x.gep1 = getelementptr double, ptr %vec.x, i32 %index
  %vec.x.elem2 = load double, ptr %vec.x.gep1, align 8
  %call = tail call noundef i32 @_Z12FindPositiond(double noundef nofpclass(nan inf) %vec.x.elem2)
  %idxprom = sext i32 %call to i64
  %c0 = getelementptr inbounds %struct.point, ptr %load.vals, i64 %idxprom, i32 0
  %0 = load double, ptr %c0, align 8
  %mul = fmul fast double %0, %vec.x.elem2
  %c1 = getelementptr inbounds %struct.point, ptr %load.vals, i64 %idxprom, i32 1
  %1 = load double, ptr %c1, align 8
  %add = fadd fast double %mul, %1
  %vec.retval.gep = getelementptr double, ptr %vec.retval, i32 %index
  store double %add, ptr %vec.retval.gep, align 8
  %indvar = add nuw nsw i32 %index, 1
  %vl.cond = icmp ult i32 %indvar, 4
  br i1 %vl.cond, label %simd.loop.header, label %simd.end.region

simd.end.region:                                  ; preds = %simd.loop.header
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:                                           ; preds = %simd.end.region
  %vec.ret = load <4 x double>, ptr %vec.retval, align 32
  ret <4 x double> %vec.ret
}

; CHECK-NOT: declare dso_local x86_regcallcc noundef <4 x i32> @_ZGVxN4v__Z12FindPositiond.

attributes #0 = { mustprogress nofree noinline norecurse nosync nounwind willreturn memory(none) uwtable "advanced-optim"="false" "approx-func-fp-math"="true" "denormal-fp-math"="preserve-sign,preserve-sign" "loopopt-pipeline"="light" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "prefer-vector-width"="512" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "unsafe-fp-math"="true" "vector-variants"="_ZGVxN4v__Z12FindPositiond,_ZGVxM4v__Z12FindPositiond,_ZGVYN8v__Z12FindPositiond,_ZGVYM8v__Z12FindPositiond,_ZGVZN16v__Z12FindPositiond,_ZGVZM16v__Z12FindPositiond" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nofree noinline nosync nounwind willreturn memory(readwrite) uwtable "advanced-optim"="false" "approx-func-fp-math"="true" "denormal-fp-math"="preserve-sign,preserve-sign" "loopopt-pipeline"="light" "may-have-openmp-directive"="true" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "pre_loopopt" "prefer-vector-width"="512" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+cmov,+mmx,+popcnt,+sse,+sse2,+sse3,+ssse3,+sse4.1,+sse4.2,+avx,+avx2,+fma,+bmi,+bmi2,+pclmul,+cx16,+cx8,+crc32,+f16c,+fsgsbase,+fxsr,+invpcid,+lzcnt,+movbe,+rdrnd,+sahf,+x87,+xsave,+xsaveopt" "tune-cpu"="core-avx2" "unsafe-fp-math"="true" }
