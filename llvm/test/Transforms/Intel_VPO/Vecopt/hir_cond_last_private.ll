; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -print-after=hir-vplan-vec -vplan-force-vf=2 -disable-output -vplan-enable-new-cfg-merge-hir=false < %s 2>&1 | FileCheck %s
; RUN: opt -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -vplan-force-vf=2 -disable-output -vplan-enable-new-cfg-merge-hir=false < %s 2>&1 | FileCheck %s
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -print-after=hir-vplan-vec -vplan-force-vf=2 -disable-output -vplan-enable-new-cfg-merge-hir < %s 2>&1 | FileCheck %s
; RUN: opt -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -vplan-force-vf=2 -disable-output -vplan-enable-new-cfg-merge-hir < %s 2>&1 | FileCheck %s

; Candidate HLLoop before VPlan (foo):
; <24>         + DO i1 = 0, 99, 1   <DO_LOOP> <simd>
; <7>          |   if (0 < i1)
; <7>          |   {
; <11>         |      %2 = (%a)[0];
; <12>         |      (%ret.lpriv)[0] = %2;
; <7>          |   }
; <24>         + END LOOP

define void @foo(i8* %a) {
; CHECK:       Function: foo
; CHECK:  BEGIN REGION { modified }
; CHECK-NEXT:        [[PRIV_MEM_BC0:%.*]] = &((i8*)([[PRIV_MEM0:%.*]])[0])
; CHECK-NEXT:        [[PRIV_MEM_BC30:%.*]] = &((i32*)([[PRIV_MEM20:%.*]])[0])
; CHECK-NEXT:        (<2 x i32>*)([[PRIV_MEM20]])[0] = -1
; CHECK:             + DO i1 = 0, 99, 2   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = 0 < i1 + <i32 0, i32 1>
; CHECK-NEXT:        |   [[TMP0:%.*]] = bitcast.<2 x i1>.i2([[DOTVEC0]])
; CHECK-NEXT:        |   [[CMP50:%.*]] = [[TMP0]] != 0
; CHECK-NEXT:        |   [[DOTUNIFLOAD0:%.*]] = undef
; CHECK-NEXT:        |   if ([[CMP50]] == 1)
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      [[DOTUNIFLOAD0]] = ([[A0:%.*]])[0]
; CHECK-NEXT:        |   }
; CHECK-NEXT:        |   (<2 x i32>*)([[PRIV_MEM20]])[0] = i1 + <i32 0, i32 1>, Mask = @{[[DOTVEC0]]};
; CHECK-NEXT:        |   (<2 x i8>*)([[PRIV_MEM0]])[0] = [[DOTUNIFLOAD0]], Mask = @{[[DOTVEC0]]};
; CHECK-NEXT:        + END LOOP
; CHECK:             [[DOTVEC60:%.*]] = (<2 x i8>*)([[PRIV_MEM0]])[0]
; CHECK-NEXT:        [[DOTVEC70:%.*]] = (<2 x i32>*)([[PRIV_MEM20]])[0]
; CHECK-NEXT:        [[DOTVEC80:%.*]] = [[DOTVEC70]] != -1
; CHECK-NEXT:        [[TMP1:%.*]] = bitcast.<2 x i1>.i2([[DOTVEC80]])
; CHECK-NEXT:        [[CMP90:%.*]] = [[TMP1]] == 0
; CHECK-NEXT:        [[ALL_ZERO_CHECK0:%.*]] = [[CMP90]]
; CHECK-NEXT:        if ([[CMP90]] == 1)
; CHECK-NEXT:        {
; CHECK-NEXT:           goto [[BB0:BB.*]];
; CHECK-NEXT:        }
; CHECK-NEXT:        [[PRIV_IDX_MAX0:%.*]] = @llvm.vector.reduce.smax.v2i32([[DOTVEC70]])
; CHECK-NEXT:        [[PRIV_IDX_CMP0:%.*]] = [[DOTVEC70]] == [[PRIV_IDX_MAX0]]
; CHECK-NEXT:        [[BSFINTMASK0:%.*]] = bitcast.<2 x i1>.i2([[PRIV_IDX_CMP0]])
; CHECK-NEXT:        [[BSF0:%.*]] = @llvm.cttz.i2([[BSFINTMASK0]],  1)
; CHECK-NEXT:        [[PRIV_EXTRACT0:%.*]] = extractelement [[DOTVEC60]],  [[BSF0]]
; CHECK-NEXT:        ([[RET_LPRIV0:%.*]])[0] = [[PRIV_EXTRACT0]]
; CHECK-NEXT:        [[BB0]]:
; CHECK:             ret
; CHECK-NEXT:  END REGION
;
entry:
  %ret.lpriv = alloca i8
  br label %0

0:
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LASTPRIVATE:CONDITIONAL.TYPED"(i8* %ret.lpriv, i8 0, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:
  %.omp.iv.local.016 = phi i32 [ 0, %0 ], [ %add9, %omp.inner.for.inc ]
  %cmp = icmp slt i32 0, %.omp.iv.local.016
  br i1 %cmp, label %if.then, label %omp.inner.for.inc

if.then:
  %2 = load i8, i8* %a
  store i8 %2, i8* %ret.lpriv
  br label %omp.inner.for.inc

omp.inner.for.inc:
  %add9 = add nsw i32 %.omp.iv.local.016, 1
  %cmp4 = icmp sgt i32 100, %add9
  br i1 %cmp4, label %omp.inner.for.body, label %omp.inner.for.cond.omp.inner.for.end_crit_edge

omp.inner.for.cond.omp.inner.for.end_crit_edge:
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
