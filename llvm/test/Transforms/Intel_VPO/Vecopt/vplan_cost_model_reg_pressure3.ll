; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -hir-ssa-deconstruction -vplan-cost-model-use-gettype \
; RUN:     -hir-vec-dir-insert -VPlanDriverHIR -disable-output \
; RUN:     -vplan-cost-model-print-analysis-for-vf=8 2>&1 | FileCheck %s

; Many users from 'if.then' block are expected to induce register pressure high
; enough to spill some register(s) in 'for.body' block.
; The test checks that.
; The test is not expected to be run in optimizing pipeline so the loads from the
; same memory are not optimized away and are not sank to their uses.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@b = dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@a = dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

define dso_local void @foo() {
; CHECK-LABEL:  HIR Cost Model for VPlan foo.42 with VF = 8:
; CHECK-NEXT:  Total VPlan Cost: 112
; CHECK-NEXT:  VPlan Base Cost before adjustments: 84
; CHECK-NEXT:  Total VPlan spill/fill cost: +28
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]], total cost: 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB1:BB[0-9]+]], total cost: 0
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB2:BB[0-9]+]], total cost: 26
; CHECK-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP2:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP3:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP4:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP5:%.*]] = load i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP6:%.*]] = load i32* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP7:%.*]] = load i32* [[VP_SUBSCRIPT_5]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_6:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP8:%.*]] = load i32* [[VP_SUBSCRIPT_6]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_7:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP9:%.*]] = load i32* [[VP_SUBSCRIPT_7]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_8:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP10:%.*]] = load i32* [[VP_SUBSCRIPT_8]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_9:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP11:%.*]] = load i32* [[VP_SUBSCRIPT_9]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_10:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP12:%.*]] = load i32* [[VP_SUBSCRIPT_10]]
; CHECK-NEXT:    Cost Unknown for i32 [[VP13:%.*]] = hir-copy i32 0 , OriginPhiId: -1
; CHECK-NEXT:    Cost 2 for i32 [[VP14:%.*]] = add i32 [[VP2]] i32 1
; CHECK-NEXT:    Cost 2 for i1 [[VP15:%.*]] = icmp i32 [[VP14]] i32 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB4:BB[0-9]+]], total cost: 20
; CHECK-NEXT:  Block spill/fill standalone cost (not included into total cost): 28
; CHECK-NEXT:    Cost 0 for i1 [[VP16:%.*]] = block-predicate i1 [[VP15]]
; CHECK-NEXT:    Cost 2 for i32 [[VP17:%.*]] = add i32 [[VP2]] i32 [[VP3]]
; CHECK-NEXT:    Cost 2 for i32 [[VP18:%.*]] = add i32 [[VP17]] i32 [[VP4]]
; CHECK-NEXT:    Cost 2 for i32 [[VP19:%.*]] = add i32 [[VP18]] i32 [[VP5]]
; CHECK-NEXT:    Cost 2 for i32 [[VP20:%.*]] = add i32 [[VP19]] i32 [[VP6]]
; CHECK-NEXT:    Cost 2 for i32 [[VP21:%.*]] = add i32 [[VP20]] i32 [[VP7]]
; CHECK-NEXT:    Cost 2 for i32 [[VP22:%.*]] = add i32 [[VP21]] i32 [[VP8]]
; CHECK-NEXT:    Cost 2 for i32 [[VP23:%.*]] = add i32 [[VP22]] i32 [[VP9]]
; CHECK-NEXT:    Cost 2 for i32 [[VP24:%.*]] = add i32 [[VP23]] i32 [[VP10]]
; CHECK-NEXT:    Cost 2 for i32 [[VP25:%.*]] = add i32 [[VP24]] i32 [[VP11]]
; CHECK-NEXT:    Cost 2 for i32 [[VP26:%.*]] = add i32 [[VP25]] i32 [[VP12]]
; CHECK-NEXT:    Cost Unknown for i32 [[VP27:%.*]] = hir-copy i32 [[VP26]] , OriginPhiId: -1
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB3]], total cost: 38
; CHECK-NEXT:    Cost Unknown for i32 [[VP__BLEND_BB4:%.*]] = blend [ i32 [[VP13]], i1 true ], [ i32 [[VP27]], i1 [[VP15]] ]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_11:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for store i32 [[VP__BLEND_BB4]] i32* [[VP_SUBSCRIPT_11]]
; CHECK-NEXT:    Cost 4 for i64 [[VP1]] = add i64 [[VP0]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:    Cost 32 for i1 [[VP28:%.*]] = icmp i64 [[VP1]] i64 1023
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB5:BB[0-9]+]], total cost: 0
; CHECK-NEXT:    Cost Unknown for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB6:BB[0-9]+]], total cost: 0
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %arrayidx1 = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv
  %arrayidx2 = getelementptr inbounds [1024 x i32], [1024 x i32]* @b, i64 0, i64 %indvars.iv
  %load1 = load i32, i32* %arrayidx1, align 4
  %load20 = load i32, i32* %arrayidx2, align 4
  %load21 = load i32, i32* %arrayidx2, align 4
  %load22 = load i32, i32* %arrayidx2, align 4
  %load23 = load i32, i32* %arrayidx2, align 4
  %load24 = load i32, i32* %arrayidx2, align 4
  %load25 = load i32, i32* %arrayidx2, align 4
  %load26 = load i32, i32* %arrayidx2, align 4
  %load27 = load i32, i32* %arrayidx2, align 4
  %load28 = load i32, i32* %arrayidx2, align 4
  %load29 = load i32, i32* %arrayidx2, align 4

  %add = add nsw nuw i32 %load1, 1
  %tobool = icmp eq i32 %add, 0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %add20 = add nsw nuw i32 %load20, %load1
  %add21 = add nsw nuw i32 %load21, %add20
  %add22 = add nsw nuw i32 %load22, %add21
  %add23 = add nsw nuw i32 %load23, %add22
  %add24 = add nsw nuw i32 %load24, %add23
  %add25 = add nsw nuw i32 %load25, %add24
  %add26 = add nsw nuw i32 %load26, %add25
  %add27 = add nsw nuw i32 %load27, %add26
  %add28 = add nsw nuw i32 %load28, %add27
  %add29 = add nsw nuw i32 %load29, %add28
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %res = phi i32 [ 0, %for.body ], [ %add29, %if.then ]
  store i32 %res, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  ret void
}
