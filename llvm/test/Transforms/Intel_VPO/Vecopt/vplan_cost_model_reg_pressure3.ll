; INTEL_FEATURE_SW_ADVANCED
; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: intel_feature_sw_advanced
; RUN: opt < %s -hir-ssa-deconstruction -vplan-cost-model-use-gettype \
; RUN:     -hir-vec-dir-insert -hir-vplan-vec -disable-output \
; RUN:     -vplan-cost-model-print-analysis-for-vf=8 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s
; RUN: opt < %s -hir-ssa-deconstruction -vplan-cost-model-use-gettype \
; RUN:     -hir-vec-dir-insert -hir-vplan-vec -disable-output \
; RUN:     -vplan-cost-model-print-analysis-for-vf=8 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s

; Many users from 'if.then' block are expected to induce register pressure high
; enough to spill some register(s) in 'for.body' block.
; The test checks that.
; The test is not expected to be run in optimizing pipeline so the loads from the
; same memory are not optimized away and are not sank to their uses.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@b = dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@a = dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

define dso_local void @foo() {
; CHECK-LABEL:  Cost Model for VPlan foo:HIR.#{{[0-9]+}} with VF = 8:
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; CHECK-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; CHECK-NEXT:  [[BB0]]: base cost: 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB1]]
; CHECK-NEXT:    Cost Unknown for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; CHECK-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; CHECK-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; CHECK-NEXT:  [[BB1]]: base cost: 0
; CHECK-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB2]]
; CHECK-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i32]* @a i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_3:%.*]] = load i32* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_4:%.*]] = load i32* [[VP_SUBSCRIPT_4]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_5:%.*]] = load i32* [[VP_SUBSCRIPT_5]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_6:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_6:%.*]] = load i32* [[VP_SUBSCRIPT_6]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_7:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_7:%.*]] = load i32* [[VP_SUBSCRIPT_7]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_8:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_8:%.*]] = load i32* [[VP_SUBSCRIPT_8]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_9:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_9:%.*]] = load i32* [[VP_SUBSCRIPT_9]]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_10:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for i32 [[VP_LOAD_10:%.*]] = load i32* [[VP_SUBSCRIPT_10]]
; CHECK-NEXT:    Cost Unknown for i32 [[VP2:%.*]] = hir-copy i32 0 , OriginPhiId: -1
; CHECK-NEXT:    Cost 2 for i32 [[VP3:%.*]] = add i32 [[VP_LOAD]] i32 1
; CHECK-NEXT:    Cost 8 for i1 [[VP4:%.*]] = icmp ne i32 [[VP3]] i32 0
; CHECK-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; CHECK-NEXT:  [[BB2]]: base cost: 32
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB4]]
; CHECK-NEXT:    Cost 0 for i1 [[VP5:%.*]] = block-predicate i1 [[VP4]]
; CHECK-NEXT:    Cost 2 for i32 [[VP6:%.*]] = add i32 [[VP_LOAD]] i32 [[VP_LOAD_1]]
; CHECK-NEXT:    Cost 2 for i32 [[VP7:%.*]] = add i32 [[VP6]] i32 [[VP_LOAD_2]]
; CHECK-NEXT:    Cost 2 for i32 [[VP8:%.*]] = add i32 [[VP7]] i32 [[VP_LOAD_3]]
; CHECK-NEXT:    Cost 2 for i32 [[VP9:%.*]] = add i32 [[VP8]] i32 [[VP_LOAD_4]]
; CHECK-NEXT:    Cost 2 for i32 [[VP10:%.*]] = add i32 [[VP9]] i32 [[VP_LOAD_5]]
; CHECK-NEXT:    Cost 2 for i32 [[VP11:%.*]] = add i32 [[VP10]] i32 [[VP_LOAD_6]]
; CHECK-NEXT:    Cost 2 for i32 [[VP12:%.*]] = add i32 [[VP11]] i32 [[VP_LOAD_7]]
; CHECK-NEXT:    Cost 2 for i32 [[VP13:%.*]] = add i32 [[VP12]] i32 [[VP_LOAD_8]]
; CHECK-NEXT:    Cost 2 for i32 [[VP14:%.*]] = add i32 [[VP13]] i32 [[VP_LOAD_9]]
; CHECK-NEXT:    Cost 2 for i32 [[VP15:%.*]] = add i32 [[VP14]] i32 [[VP_LOAD_10]]
; CHECK-NEXT:    Cost Unknown for i32 [[VP16:%.*]] = hir-copy i32 [[VP15]] , OriginPhiId: -1
; CHECK-NEXT:    Cost 0 for br [[BB3]]
; CHECK-NEXT:  [[BB4]]: base cost: 20
; CHECK-NEXT:  Block Vector spill/fill approximate cost (not included into base cost): 24
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB3]]
; CHECK-NEXT:    Cost Unknown for i32 [[VP__BLEND_BB4:%.*]] = blend [ i32 [[VP2]], i1 true ], [ i32 [[VP16]], i1 [[VP4]] ]
; CHECK-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_11:%.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[VP0]]
; CHECK-NEXT:    Cost 2 for store i32 [[VP__BLEND_BB4]] i32* [[VP_SUBSCRIPT_11]]
; CHECK-NEXT:    Cost 4 for i64 [[VP1]] = add i64 [[VP0]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:    Cost 32 for i1 [[VP17:%.*]] = icmp slt i64 [[VP1]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    Cost 0 for br i1 [[VP17]], [[BB2]], [[BB5:BB[0-9]+]]
; CHECK-NEXT:  [[BB3]]: base cost: 38
; CHECK-NEXT:  Base Cost: 90
; CHECK-NEXT:  Extra cost due to Spill/Fill heuristic is 56
; CHECK-NEXT:  Total Cost: 146
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB5]]
; CHECK-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:    Cost 0 for br [[BB6:BB[0-9]+]]
; CHECK-NEXT:  [[BB5]]: base cost: 0
; CHECK-NEXT:  Analyzing VPBasicBlock [[BB6]]
; CHECK-NEXT:    Cost 0 for br <External Block>
; CHECK-NEXT:  [[BB6]]: base cost: 0
; CHECK-NEXT:  Cost Model for Loop postexit [[BB5]] : [[BB6]] for VF = 8 resulted Cost = 0
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %arrayidx1 = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv
  %arrayidx2 = getelementptr inbounds [1024 x i32], [1024 x i32]* @b, i64 0, i64 %indvars.iv
  %load1 = load i32, i32* %arrayidx1, align 4
  %load20 = load i32, i32* %arrayidx2, align 4
  %load21 = load i32, i32* %arrayidx2, align 4
  %load22 = load i32, i32* %arrayidx2, align 4
  %load23 = load i32, i32* %arrayidx2, align 4
  %load24 = load i32, i32* %arrayidx2, align 4
  %load25 = load i32, i32* %arrayidx2, align 4
  %load26 = load i32, i32* %arrayidx2, align 4
  %load27 = load i32, i32* %arrayidx2, align 4
  %load28 = load i32, i32* %arrayidx2, align 4
  %load29 = load i32, i32* %arrayidx2, align 4
  %add = add nsw nuw i32 %load1, 1
  %tobool = icmp eq i32 %add, 0
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %add20 = add nsw nuw i32 %load20, %load1
  %add21 = add nsw nuw i32 %load21, %add20
  %add22 = add nsw nuw i32 %load22, %add21
  %add23 = add nsw nuw i32 %load23, %add22
  %add24 = add nsw nuw i32 %load24, %add23
  %add25 = add nsw nuw i32 %load25, %add24
  %add26 = add nsw nuw i32 %load26, %add25
  %add27 = add nsw nuw i32 %load27, %add26
  %add28 = add nsw nuw i32 %load28, %add27
  %add29 = add nsw nuw i32 %load29, %add28
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %res = phi i32 [ 0, %for.body ], [ %add29, %if.then ]
  store i32 %res, i32* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  ret void
}
; end INTEL_FEATURE_SW_ADVANCED
