; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2
; RUN: opt %s -disable-output -passes=vplan-vec -debug-only=vpo-ir-loop-vectorize-legality -vplan-nested-simd-strategy=bailout 2>&1 | FileCheck %s --check-prefix=BAILOUT
; RUN: opt %s -disable-output -passes=vplan-vec -vplan-print-after-vpentity-instrs -vplan-nested-simd-strategy=outermost -vplan-force-vf=4 | FileCheck %s --check-prefix=OUTER
; RUN: opt %s -disable-output -passes=vplan-vec -vplan-print-after-vpentity-instrs -vplan-nested-simd-strategy=innermost -vplan-force-vf=4 | FileCheck %s --check-prefix=INNER
; RUN: opt %s -disable-output -passes=vplan-vec -vplan-print-after-vpentity-instrs -vplan-force-vf=4 | FileCheck %s --check-prefix=OUTER

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define internal void @foo(ptr nocapture readonly %a.addr.0.val, ptr noalias nocapture %sum) {
; BAILOUT:      Unsupported nested OpenMP (simd) loop or region.
;
; OUTER-LABEL:  VPlan after insertion of VPEntities instructions:
; OUTER-NEXT:  VPlan IR for: foo:omp.inner.for.body.#{{[0-9]+}}
; OUTER:         [[BB2:BB[0-9]+]]: # preds: [[BB1:BB[0-9]+]], [[BB3:BB[0-9]+]]
; OUTER-NEXT:     i64 [[VP_INDVARS_IV3:%.*]] = phi  [ i64 [[VP_INDVARS_IV3_IND_INIT:%.*]], [[BB1]] ],  [ i64 [[VP_INDVARS_IV_NEXT4:%.*]], [[BB3]] ]
; OUTER-NEXT:     i32 [[VP0:%.*]] = phi  [ i32 [[VP_I_PRIV_IND_INIT:%.*]], [[BB1]] ],  [ i32 [[VP1:%.*]], [[BB3]] ]
; OUTER-NEXT:     store i32 [[VP0]] ptr [[VP_I_PRIV:%.*]]
; OUTER-NEXT:     i32 [[VP_I5:%.*]] = trunc i64 [[VP_INDVARS_IV3]] to i32
; OUTER-NEXT:     store i32 [[VP_I5]] ptr [[VP_I_PRIV]]
; OUTER-NEXT:     br [[BB4:BB[0-9]+]]
;
; OUTER:         [[BB6:BB[0-9]+]]: # preds: [[BB5:BB[0-9]+]], [[BB6]]
; OUTER-NEXT:     i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 0, [[BB5]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB6]] ]
; OUTER-NEXT:     i32 [[VP_ADD222:%.*]] = phi  [ i32 [[VP_SUM_PROMOTED:%.*]], [[BB5]] ],  [ i32 [[VP_ADD22:%.*]], [[BB6]] ]
; OUTER-NEXT:     ptr [[VP_ARRAYIDX21:%.*]] = getelementptr inbounds i32, ptr [[VP_I7:%.*]] i64 [[VP_INDVARS_IV]]
; OUTER-NEXT:     i32 [[VP_I8:%.*]] = load ptr [[VP_ARRAYIDX21]]
; OUTER-NEXT:     i32 [[VP_ADD22]] = add i32 [[VP_ADD222]] i32 [[VP_I8]]
; OUTER-NEXT:     i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 1
; OUTER-NEXT:     i1 [[VP_EXITCOND_NOT:%.*]] = icmp eq i64 [[VP_INDVARS_IV_NEXT]] i64 1024
; OUTER-NEXT:     br i1 [[VP_EXITCOND_NOT]], [[BB7:BB[0-9]+]], [[BB6]]
;
; OUTER:         [[BB3]]: # preds: [[BB8:BB[0-9]+]]
; OUTER-NEXT:     i64 [[VP_INDVARS_IV_NEXT4]] = add i64 [[VP_INDVARS_IV3]] i64 [[VP_INDVARS_IV3_IND_INIT_STEP:%.*]]
; OUTER-NEXT:     i32 [[VP1]] = add i32 [[VP0]] i32 [[VP_I_PRIV_IND_INIT_STEP:%.*]]
; OUTER-NEXT:     i1 [[VP_EXITCOND6:%.*]] = icmp eq i64 [[VP_INDVARS_IV_NEXT4]] i64 1024
; OUTER-NEXT:     br i1 [[VP_EXITCOND6]], [[BB9:BB[0-9]+]], [[BB2]]
;
; INNER-LABEL:  VPlan after insertion of VPEntities instructions:
; INNER-NEXT:  VPlan IR for: foo:omp.inner.for.body17.#{{[0-9]+}}
; INNER-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; INNER-NEXT:     br [[BB1:BB[0-9]+]]
; INNER-EMPTY:
; INNER-NEXT:    [[BB1]]: # preds: [[BB0]]
; INNER-NEXT:     i32 [[VP_ADD222RED_INIT:%.*]] = reduction-init i32 0 i32 [[SUM_PROMOTED0:%.*]]
; INNER-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; INNER-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; INNER-NEXT:     br [[BB2:BB[0-9]+]]
; INNER-EMPTY:
; INNER-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; INNER-NEXT:     i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB2]] ]
; INNER-NEXT:     i32 [[VP_ADD222:%.*]] = phi  [ i32 [[VP_ADD222RED_INIT]], [[BB1]] ],  [ i32 [[VP_ADD22:%.*]], [[BB2]] ]
; INNER-NEXT:     ptr [[VP_ARRAYIDX21:%.*]] = getelementptr inbounds i32, ptr [[I70:%.*]] i64 [[VP_INDVARS_IV]]
; INNER-NEXT:     i32 [[VP_I8:%.*]] = load ptr [[VP_ARRAYIDX21]]
; INNER-NEXT:     i32 [[VP_ADD22]] = add i32 [[VP_ADD222]] i32 [[VP_I8]]
; INNER-NEXT:     i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; INNER-NEXT:     i1 [[VP_EXITCOND_NOT:%.*]] = icmp eq i64 [[VP_INDVARS_IV_NEXT]] i64 1024
; INNER-NEXT:     br i1 [[VP_EXITCOND_NOT]], [[BB3:BB[0-9]+]], [[BB2]]
; INNER-EMPTY:
; INNER-NEXT:    [[BB3]]: # preds: [[BB2]]
; INNER-NEXT:     i32 [[VP_ADD222RED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_ADD22]]
; INNER-NEXT:     i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; INNER-NEXT:     br [[BB4:BB[0-9]+]]
; INNER-EMPTY:
; INNER-NEXT:    [[BB4]]: # preds: [[BB3]]
; INNER-NEXT:     br <External Block>
; INNER-EMPTY:
; INNER-NEXT:  External Uses:
; INNER-NEXT:  Id: 0     [[ADD22_LCSSA0:%.*]] = phi i32 [ [[ADD220:%.*]], [[OMP_INNER_FOR_BODY170:%.*]] ] i32 [[VP_ADD222RED_FINAL]] -> i32 [[ADD220]]
;
DIR.OMP.SIMD.4:
  %i.priv = alloca i32, align 4
  %j.linear.iv = alloca i32, align 4
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %DIR.OMP.SIMD.4
  %i2 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LINEAR:IV.TYPED"(ptr %i.priv, i32 0, i32 1, i32 1) ]
  br label %DIR.OMP.SIMD.115

DIR.OMP.SIMD.115:                                 ; preds = %DIR.OMP.SIMD.1
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %DIR.OMP.SIMD.115, %omp.precond.end
  %indvars.iv3 = phi i64 [ 0, %DIR.OMP.SIMD.115 ], [ %indvars.iv.next4, %omp.precond.end ]
  %i5 = trunc i64 %indvars.iv3 to i32
  store i32 %i5, ptr %i.priv, align 4
  br label %DIR.OMP.SIMD.2

DIR.OMP.SIMD.2:                                   ; preds = %omp.inner.for.body
  %i6 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.NORMALIZED.IV:TYPED"(ptr null, i32 0), "QUAL.OMP.NORMALIZED.UB:TYPED"(ptr null, i32 0), "QUAL.OMP.LINEAR:IV.TYPED"(ptr %j.linear.iv, i32 0, i32 1, i32 1) ]
  br label %DIR.OMP.SIMD.117

DIR.OMP.SIMD.117:                                 ; preds = %DIR.OMP.SIMD.2
  %arrayidx = getelementptr inbounds ptr, ptr %a.addr.0.val, i64 %indvars.iv3
  %i7 = load ptr, ptr %arrayidx, align 8
  %sum.promoted = load i32, ptr %sum, align 4
  br label %omp.inner.for.body17

omp.inner.for.body17:                             ; preds = %DIR.OMP.SIMD.117, %omp.inner.for.body17
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.117 ], [ %indvars.iv.next, %omp.inner.for.body17 ]
  %add222 = phi i32 [ %sum.promoted, %DIR.OMP.SIMD.117 ], [ %add22, %omp.inner.for.body17 ]
  %arrayidx21 = getelementptr inbounds i32, ptr %i7, i64 %indvars.iv
  %i8 = load i32, ptr %arrayidx21, align 4
  %add22 = add nsw i32 %add222, %i8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.3, label %omp.inner.for.body17

DIR.OMP.END.SIMD.3:                               ; preds = %omp.inner.for.body17
  %add22.lcssa = phi i32 [ %add22, %omp.inner.for.body17 ]
  store i32 %add22.lcssa, ptr %sum, align 4
  br label %DIR.OMP.END.SIMD.39

DIR.OMP.END.SIMD.39:                              ; preds = %DIR.OMP.END.SIMD.3
  call void @llvm.directive.region.exit(token %i6) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.39, %omp.inner.for.body
  %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1
  %exitcond6 = icmp eq i64 %indvars.iv.next4, 1024
  br i1 %exitcond6, label %omp.inner.for.cond.DIR.OMP.END.SIMD.9.loopexit_crit_edge, label %omp.inner.for.body

omp.inner.for.cond.DIR.OMP.END.SIMD.9.loopexit_crit_edge: ; preds = %omp.precond.end
  call void @llvm.directive.region.exit(token %i2) [ "DIR.OMP.END.SIMD"() ]
  br label %loop.region.exit

loop.region.exit:                                 ; preds = %DIR.OMP.SIMD.4, %omp.inner.for.cond.DIR.OMP.END.SIMD.9.loopexit_crit_edge
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
