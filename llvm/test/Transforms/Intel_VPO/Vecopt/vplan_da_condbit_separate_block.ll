; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check that divergence is properly propagated to phis when the actual branch (CondBit)
; resides in a different block from the instruction used as the CondBit. In this test there is
; one divergent icmp instruction (VP_CMPZ) that is used as a CondBit in two different blocks.
; This should cause two phis, VP_DIV_PHI and VP_DIV_PHI2, to be marked as divergent.

; RUN: opt < %s -VPlanDriver -vplan-dump-da -disable-output -S 2>&1 | FileCheck %s
; RUN: opt < %s -passes="vplan-driver" -vplan-dump-da -disable-output -S 2>&1 | FileCheck %s

; Function Attrs: nounwind
define void @foo() {
; CHECK:       Printing Divergence info for Loop at depth 1 containing: [[BB0:BB[0-9]+]]<header>,[[BB1:BB[0-9]+]],[[BB2:BB[0-9]+]],[[BB3:BB[0-9]+]],[[BB4:BB[0-9]+]],[[BB5:BB[0-9]+]],[[BB6:BB[0-9]+]],[[BB7:BB[0-9]+]],[[BB8:BB[0-9]+]],[[BB9:BB[0-9]+]]<latch><exiting>
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB0]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i64 [[VP_INDEX:%.*]] = phi  [ i64 [[VP_INDEX_IND_INIT:%.*]], [[BB10:BB[0-9]+]] ],  [ i64 [[VP_INDVAR:%.*]], [[BB9]] ]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i64 [[VP_ADD1:%.*]] = add i64 [[LID00:%.*]] i64 [[VP_INDEX]]
; CHECK-NEXT:  Divergent: [Shape: Random] i1 [[VP_CMPZ:%.*]] = icmp eq i64 [[LSZ00:%.*]] i64 [[VP_ADD1]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB1]]
; CHECK-NEXT:  Divergent: [Shape: Random] br i1 [[VP_CMPZ]], [[BB3]], [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB2]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB3]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB4]]
; CHECK-NEXT:  Divergent: [Shape: Random] i1 [[VP_DIV_PHI:%.*]] = phi  [ i1 false, [[BB2]] ],  [ i1 true, [[BB3]] ]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB5]]
; CHECK-NEXT:  Divergent: [Shape: Random] br i1 [[VP_CMPZ]], [[BB7]], [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB6]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB7]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB8]]
; CHECK-NEXT:  Divergent: [Shape: Random] i1 [[VP_DIV_PHI2:%.*]] = phi  [ i1 false, [[BB6]] ],  [ i1 true, [[BB7]] ]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB9]]
; CHECK-NEXT:  Divergent: [Shape: Unit Stride, Stride: i64 1] i64 [[VP_INDVAR]] = add i64 [[VP_INDEX]] i64 [[VP_INDEX_IND_INIT_STEP:%.*]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i1 [[VP_VL_COND:%.*]] = icmp ult i64 [[VP_INDVAR]] i64 [[VP_VECTOR_TRIP_COUNT:%.*]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br i1 [[VP_VL_COND]], [[BB0]], [[BB11:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB11]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] i64 [[VP_INDEX_IND_FINAL:%.*]] = induction-final{add} i64 live-in0 i64 1
; CHECK-NEXT:  Uniform: [Shape: Uniform] br [[BB12:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Basic Block: [[BB12]]
; CHECK-NEXT:  Uniform: [Shape: Uniform] br <External Block>
;
entry:
  %lid0 = call i64 @_Z12get_local_idj(i32 0) #3
  %lsz0 = call i64 @_Z14get_local_sizej(i32 0) #3
  br label %simd.begin.region

simd.begin.region:                              ; preds = %entry
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 8) ]
  br label %simd.loop.preheader

simd.loop.preheader:                            ; preds = %simd.begin.region
  br label %simd.loop

simd.loop:                                      ; preds = %simd.loop.exit, %simd.loop.preheader
  %index = phi i64 [ 0, %simd.loop.preheader ], [ %indvar, %simd.loop.exit ]
  %add1 = add nuw i64 %lid0, %index
  %cmpz = icmp eq i64 %lsz0, %add1
  br label %divergent.if

divergent.if:                              ; preds = %simd.loop
  br i1 %cmpz, label %divergent.then, label %divergent.else

divergent.then:                            ; preds = %divergent.if
  br label %divergent.converge

divergent.else:                            ; preds = %divergent.if
  br label %divergent.converge

divergent.converge:                        ; preds = %divergent.then, %divergent.else
  %div.phi = phi i1 [ false, %divergent.else ], [ true, %divergent.then ]
  br label %divergent.if2

divergent.if2:
  br i1 %cmpz, label %divergent.then2, label %divergent.else2

divergent.then2:                           ; preds = %divergent.if2
  br label %divergent.converge2

divergent.else2:                           ; preds = %divergent.if2
  br label %divergent.converge2

divergent.converge2:                       ; preds = %divergent.then2, %divergent.else2
  %div.phi2 = phi i1 [ false, %divergent.else2 ], [ true, %divergent.then2 ]
  br label %simd.loop.exit

simd.loop.exit:                            ; preds = %early.simd.loop.exiting
  %indvar = add nuw i64 %index, 1
  %vl.cond = icmp ult i64 %indvar, 8
  br i1 %vl.cond, label %simd.loop, label %simd.end.region

simd.end.region:                           ; preds = %simd.loop.exit
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:                                    ; preds = %simd.end.region
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @_Z12get_local_idj(i32) local_unnamed_addr #1

; Function Attrs: nounwind readnone
declare i64 @_Z14get_local_sizej(i32) local_unnamed_addr #1

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #3

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #3
