; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -disable-output -vplan-print-after-plain-cfg -vplan-force-invariant-decomposition=0 -vplan-dump-external-defs-hir < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -disable-output -vplan-print-after-plain-cfg -vplan-force-invariant-decomposition=0 -vplan-dump-external-defs-hir < %s 2>&1 | FileCheck %s

;
; LIT test to check that invariant canon expressions are not decomposed and
; get treated as external defs. The loop being vectorized is the following:
;   for (i1 = 0; i1 < 100; i1++) {
;      arr[n1 * n2][i1] = 111;
;      farr[n1 + n2 + i1] += farr2[n1 * n2 + i1];
;    }
;
; The canon expression [n1 * n2] in the reference to arr is invariant.
; Similarly [n1 + n2] and [n1 * n2] are invariant in the canon expressions
; that reference farr/farr2 once we ignore the loop IV. The test checks we
; generate unique external defs for [n1 * n2] and [n1 + n2]. The external defs
; corresponding to [n1 * n2] and [n1 + n2] are added to the IV appropriately
; during decomposition when generating the accesses to farr/farr2.
;
; The auto generated checks for external defs are done using CHECK-DAG
; as the order of printing of external defs is non-deterministic. Auto
; generated checks that were unnecessary were also removed.

@arr = common dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16
@farr2 = common dso_local local_unnamed_addr global [100 x float] zeroinitializer, align 16
@farr = common dso_local local_unnamed_addr global [100 x float] zeroinitializer, align 16

define dso_local void @foo(i64 %n1, i64 %n2) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: foo:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%n1 + %n2}
; CHECK-DAG:     [[VP1:%.*]] = {@arr}
; CHECK-DAG:     [[VP2:%.*]] = {@farr2}
; CHECK-DAG:     [[VP3:%.*]] = {(%n1 * %n2)<nsw>}
; CHECK-DAG:     [[VP4:%.*]] = {@farr}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i64 [[VP5:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP6:%.*]], [[BB2]] ]
; CHECK-NEXT:     i64* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [100 x [100 x i64]]* @arr i64 0 i64 [[VP3]] i64 [[VP5]]
; CHECK-NEXT:     store i64 111 i64* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP7:%.*]] = add i64 [[VP3]] i64 [[VP5]]
; CHECK-NEXT:     float* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [100 x float]* @farr2 i64 0 i64 [[VP7]]
; CHECK-NEXT:     float [[VP_LOAD:%.*]] = load float* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:     i64 [[VP8:%.*]] = add i64 [[VP0]] i64 [[VP5]]
; CHECK-NEXT:     float* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [100 x float]* @farr i64 0 i64 [[VP8]]
; CHECK-NEXT:     float [[VP_LOAD_1:%.*]] = load float* [[VP_SUBSCRIPT_2]]
; CHECK-NEXT:     float [[VP9:%.*]] = fadd float [[VP_LOAD]] float [[VP_LOAD_1]]
; CHECK-NEXT:     float* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [100 x float]* @farr i64 0 i64 [[VP8]]
; CHECK-NEXT:     store float [[VP9]] float* [[VP_SUBSCRIPT_3]]
; CHECK-NEXT:     i64 [[VP6]] = add i64 [[VP5]] i64 1
; CHECK-NEXT:     i1 [[VP11:%.*]] = icmp slt i64 [[VP6]] i64 100
; CHECK-NEXT:     br i1 [[VP11]], [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
;
entry:
  %mul = mul nsw i64 %n2, %n1
  %add = add nsw i64 %n2, %n1
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %i1.024 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx1 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @arr, i64 0, i64 %mul, i64 %i1.024
  store i64 111, i64* %arrayidx1, align 8
  %add5 = add nsw i64 %i1.024, %mul
  %arrayidx6 = getelementptr inbounds [100 x float], [100 x float]* @farr2, i64 0, i64 %add5
  %0 = load float, float* %arrayidx6, align 4
  %add9 = add nsw i64 %add, %i1.024
  %arrayidx10 = getelementptr inbounds [100 x float], [100 x float]* @farr, i64 0, i64 %add9
  %1 = load float, float* %arrayidx10, align 4
  %add11 = fadd float %0, %1
  store float %add11, float* %arrayidx10, align 4
  %inc = add nuw nsw i64 %i1.024, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  ret void
}
