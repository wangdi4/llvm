; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -vplan-force-vf=2 -print-after=hir-vplan-vec -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -vplan-force-vf=2 -disable-output < %s 2>&1 | FileCheck %s



define void @foo(i1 %cond, i1 %a, i64 *%p) {
; CHECK-LABEL:  Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        + DO i1 = 0, 41, 2   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = (<2 x i64>*)([[P0:%.*]])[i1]
; CHECK-NEXT:        |   [[DOTVEC20:%.*]] = [[DOTVEC0]] == 42
; CHECK-NEXT:        |   [[DOTVEC30:%.*]] = [[DOTVEC0]] == 47
; CHECK-NEXT:        |   [[DOTVEC40:%.*]] = ([[COND0:%.*]] != 0) ? [[DOTVEC20]] : [[DOTVEC30]]
; CHECK-NEXT:        |   [[DOTVEC50:%.*]] = ([[DOTVEC0]] == 42) ? [[DOTVEC20]] : [[COND0]]
; CHECK-NEXT:        |   [[EXTRACT_1_0:%.*]] = extractelement [[DOTVEC40]] + [[DOTVEC50]],  1
; CHECK-NEXT:        |   ([[P0]])[0] = [[EXTRACT_1_0]]
; CHECK-NEXT:        + END LOOP
; CHECK:             ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1
  %gep = getelementptr i64, i64 *%p, i64 %iv
  %ld = load i64, i64 *%gep
  %cmp = icmp eq i64 %ld, 42
  %cmp2 = icmp eq i64 %ld, 47
  ; This used to crash because %cmp/%cmp2 were tried to be processed similar to
  ; %cond (HIR specifics) which is incorrect.
  %sel = select i1 %cond, i1 %cmp, i1 %cmp2
  ; Check that the check is for single use and not a single user
  %sel2 = select i1 %cmp, i1 %cmp, i1 %cond
  %xor = xor i1 %sel, %sel2
  %sext = sext i1 %xor to i64
  store i64 %sext, i64 *%p
  %exitcond = icmp eq i64 %iv.next, 42
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)
