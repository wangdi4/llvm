; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -disable-output -vplan-print-plain-cfg -vplan-force-invariant-decomposition=0 -vplan-dump-external-defs-hir < %s 2>&1 | FileCheck %s
;
; LIT test to check that invariant canon expressions are not decomposed and
; get treated as external defs. The loop being vectorized is the following:
;
;    for (i1 = 0; i1 < 100; i1++) {
;      longarr[n3 * i1 + 111] = (i1 + n1 + n2) / 9;
;      intarr[i1 + n3] = i1 + n1 + n2;
;    }
;
; Once we ignore IV in [n3 * i1 + 111] and [i1 + n3], we are only left with
; a constant or self blob canon expressions. The test checks that removing and
; adding back the IV, which is done, during checks to avoid invariant decomposition
; is done correctly. The test also checks that we create one external def for
; (n1 + n2) and the decomposition of (i1 + n1 + n2) / 9 plus the truncation
; to int of (i1 + n1 + n2) is done correctly.
;
; The auto generated checks for external defs are done using CHECK-DAG
; as the order of printing of external defs is non-deterministic. Auto
; generated checks that were unnecessary were also removed.
;
@longarr = dso_local local_unnamed_addr global [100 x i64] zeroinitializer, align 16
@intarr = dso_local local_unnamed_addr global [100 x i32] zeroinitializer, align 16

define void @foo(i64 %n1, i64 %n2, i64 %n3) {
; CHECK-LABEL:  Print after buildPlainCFG
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:   [[VP0:%.*]] = %n3
; CHECK-DAG:   [[VP1:%.*]] = @longarr
; CHECK-DAG:   [[VP2:%.*]] = @intarr
; CHECK-DAG:   [[VP3:%.*]] = %n1 + %n2
; CHECK-NEXT:  External Defs End:
; CHECK:          i64 [[VP4:%.*]] = phi  [ i64 0, {{.*}} ],  [ i64 [[VP5:%.*]], {{.*}} ]
; CHECK-NEXT:     i64 [[VP6:%.*]] = add i64 [[VP3]] i64 [[VP4]]
; CHECK-NEXT:     i64 [[VP7:%.*]] = sdiv i64 [[VP6]] i64 9
; CHECK-NEXT:     i64 [[VP8:%.*]] = mul i64 [[N30:%.*]] i64 [[VP4]]
; CHECK-NEXT:     i64 [[VP9:%.*]] = add i64 [[VP8]] i64 111
; CHECK-NEXT:     i64* [[VP10:%.*]] = getelementptr inbounds [100 x i64]* @longarr i64 0 i64 [[VP9]]
; CHECK-NEXT:     store i64 [[VP7]] i64* [[VP10]]
; CHECK-NEXT:     i64 [[VP11:%.*]] = add i64 [[VP3]] i64 [[VP4]]
; CHECK-NEXT:     i32 [[VP12:%.*]] = trunc i64 [[VP11]] to i32
; CHECK-NEXT:     i64 [[VP13:%.*]] = add i64 [[N30]] i64 [[VP4]]
; CHECK-NEXT:     i32* [[VP14:%.*]] = getelementptr inbounds [100 x i32]* @intarr i64 0 i64 [[VP13]]
; CHECK-NEXT:     store i32 [[VP12]] i32* [[VP14]]
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %i1.017 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %add = add nsw i64 %i1.017, %n2
  %add1 = add i64 %add, %n1
  %div = sdiv i64 %add1, 9
  %mul = mul nsw i64 %i1.017, %n3
  %add2 = add nsw i64 %mul, 111
  %arrayidx = getelementptr inbounds [100 x i64], [100 x i64]* @longarr, i64 0, i64 %add2
  store i64 %div, i64* %arrayidx, align 8
  %conv = trunc i64 %add1 to i32
  %add3 = add nsw i64 %i1.017, %n3
  %arrayidx6 = getelementptr inbounds [100 x i32], [100 x i32]* @intarr, i64 0, i64 %add3
  store i32 %conv, i32* %arrayidx6, align 4
  %inc = add nuw nsw i64 %i1.017, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  ret void
}
