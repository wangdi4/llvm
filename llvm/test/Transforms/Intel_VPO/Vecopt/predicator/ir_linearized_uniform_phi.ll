; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt -passes='vplan-vec' -vplan-force-vf=2 -vplan-enable-masked-variant=0 -vplan-print-after-predicator -disable-output < %s 2>&1 | FileCheck %s --check-prefixes=VPLAN
; RUN: opt -passes='vplan-vec' -vplan-force-vf=2 -S < %s 2>&1 | FileCheck %s --check-prefixes=CG

define void @foo(ptr %p, ptr %uniform.ptr) {
; VPLAN-LABEL:  VPlan after predicator:
; VPLAN-NEXT:  VPlan IR for: foo:header.#{{[0-9]+}}
; VPLAN-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; VPLAN-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB1]]: # preds: [[BB0]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_IV_IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 4, UF = 1
; VPLAN-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_IV_NEXT:%.*]], [[BB3]] ]
; VPLAN-NEXT:     [DA: Div] i1 [[VP_COND:%.*]] = icmp sgt i64 [[VP_IV]] i64 0
; VPLAN-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB4]]: # preds: [[BB2]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND]]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = load ptr [[UNIFORM_PTR0:%.*]]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[VP_UNIFORM]]
; VPLAN-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB5]]: # preds: [[BB4]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM_NOT:%.*]] = select i1 [[VP_COND]] i1 [[VP_UNIFORM_NOT]] i1 false
; VPLAN-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = select i1 [[VP_COND]] i1 [[VP_UNIFORM]] i1 false
; VPLAN-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB6]]: # preds: [[BB5]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; VPLAN-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB7]]: # preds: [[BB6]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; VPLAN-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB8]]: # preds: [[BB7]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_BLEND_BLEND_BB5:%.*]] = blend [ i64 2, i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] ], [ i64 1, i1 [[VP_BB3_BR_VP_UNIFORM]] ]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP_COND_ACTIVE:%.*]] = active-lane i1 [[VP_COND]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_BLEND_BLEND_BB5_ACTIVE:%.*]] = lane-extract i64 [[VP_BLEND_BLEND_BB5]] i1 [[VP_COND_ACTIVE]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_COND]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_VAL:%.*]] = add i64 [[VP_BLEND_BLEND_BB5_ACTIVE]] i64 1
; VPLAN-NEXT:     [DA: Uni] br [[BB9:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB9]]: # preds: [[BB8]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_COND]]
; VPLAN-NEXT:     [DA: Uni] br [[BB3]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB3]]: # preds: [[BB9]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_ST_BLEND_BB8:%.*]] = blend [ i64 -1, i1 true ], [ i64 [[VP_VAL]], i1 [[VP_COND]] ]
; VPLAN-NEXT:     [DA: Div] ptr [[VP_GEP:%.*]] = getelementptr i64, ptr [[P0:%.*]] i64 [[VP_IV]]
; VPLAN-NEXT:     [DA: Div] store i64 [[VP_ST_BLEND_BB8]] ptr [[VP_GEP]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_IV_NEXT]] = add i64 [[VP_IV]] i64 [[VP_IV_IND_INIT_STEP]]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-NEXT:     [DA: Uni] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB10:BB[0-9]+]], [[BB2]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB10]]: # preds: [[BB3]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; VPLAN-NEXT:     [DA: Uni] br [[BB11:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB11]]: # preds: [[BB10]]
; VPLAN-NEXT:     [DA: Uni] br <External Block>
; VPLAN-EMPTY:
; VPLAN-NEXT:  External Uses:
; VPLAN-NEXT:  Id: 0   no underlying for i64 [[VP_IV_IND_FINAL]]
;
;
; CG:  define void @foo(ptr [[P0:%.*]], ptr [[UNIFORM_PTR0:%.*]]) {
; CG:       vector.body:
; CG-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VPLANNEDBB10:%.*]] ], [ [[TMP14:%.*]], [[VPLANNEDBB90:%.*]] ]
; CG-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i64> [ <i64 0, i64 1>, [[VPLANNEDBB10]] ], [ [[TMP13:%.*]], [[VPLANNEDBB90]] ]
; CG-NEXT:    [[TMP0:%.*]] = icmp sgt <2 x i64> [[VEC_PHI0]], zeroinitializer
; CG-NEXT:    br label [[VPLANNEDBB30:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB3:
; CG-NEXT:    [[TMP1:%.*]] = bitcast <2 x i1> [[TMP0]] to i2
; CG-NEXT:    [[TMP2:%.*]] = icmp ne i2 [[TMP1]], 0
; CG-NEXT:    br i1 [[TMP2]], label [[PRED_LOAD_IF0:%.*]], label [[TMP4:%.*]]
; CG-EMPTY:
; CG-NEXT:  pred.load.if:
; CG-NEXT:    [[TMP3:%.*]] = load i1, ptr [[UNIFORM_PTR0]], align 1
; CG-NEXT:    [[BROADCAST_SPLATINSERT0:%.*]] = insertelement <2 x i1> poison, i1 [[TMP3]], i64 0
; CG-NEXT:    br label [[TMP4]]
; CG-EMPTY:
; CG-NEXT:  4:
; CG-NEXT:    [[TMP5:%.*]] = phi <2 x i1> [ poison, [[VPLANNEDBB30]] ], [ [[BROADCAST_SPLATINSERT0]], [[PRED_LOAD_IF0]] ]
; CG-NEXT:    br label [[PRED_LOAD_CONTINUE0:%.*]]
; CG-EMPTY:
; CG-NEXT:  pred.load.continue:
; CG-NEXT:    [[BROADCAST_SPLAT0:%.*]] = shufflevector <2 x i1> [[TMP5]], <2 x i1> poison, <2 x i32> zeroinitializer
; CG-NEXT:    [[TMP6:%.*]] = xor <2 x i1> [[BROADCAST_SPLAT0]], <i1 true, i1 true>
; CG-NEXT:    br label [[VPLANNEDBB40:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB4:
; CG-NEXT:    [[TMP7:%.*]] = select <2 x i1> [[TMP0]], <2 x i1> [[TMP6]], <2 x i1> zeroinitializer
; CG-NEXT:    [[TMP8:%.*]] = select <2 x i1> [[TMP0]], <2 x i1> [[BROADCAST_SPLAT0]], <2 x i1> zeroinitializer
; CG-NEXT:    br label [[VPLANNEDBB50:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB5:
; CG-NEXT:    br label [[VPLANNEDBB60:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB6:
; CG-NEXT:    br label [[VPLANNEDBB70:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB7:
; CG-NEXT:    [[PREDBLEND0:%.*]] = select <2 x i1> [[TMP8]], <2 x i64> <i64 1, i64 1>, <2 x i64> <i64 2, i64 2>
; CG-NEXT:    [[TMP9:%.*]] = bitcast <2 x i1> [[TMP0]] to i2
; CG-NEXT:    [[CTTZ0:%.*]] = call i2 @llvm.cttz.i2(i2 [[TMP9]], i1 false)
; CG-NEXT:    [[TMP10:%.*]] = extractelement <2 x i64> [[PREDBLEND0]], i2 [[CTTZ0]]
; CG-NEXT:    [[TMP11:%.*]] = add i64 [[TMP10]], 1
; CG-NEXT:    [[BROADCAST_SPLATINSERT100:%.*]] = insertelement <2 x i64> poison, i64 [[TMP11]], i64 0
; CG-NEXT:    [[BROADCAST_SPLAT110:%.*]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT100]], <2 x i64> poison, <2 x i32> zeroinitializer
; CG-NEXT:    br label [[VPLANNEDBB80:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB8:
; CG-NEXT:    br label [[VPLANNEDBB90]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB9:
; CG-NEXT:    [[PREDBLEND120:%.*]] = select <2 x i1> [[TMP0]], <2 x i64> [[BROADCAST_SPLAT110]], <2 x i64> <i64 -1, i64 -1>
; CG-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr i64, ptr [[P0]], i64 [[UNI_PHI0]]
; CG-NEXT:    store <2 x i64> [[PREDBLEND120]], ptr [[SCALAR_GEP0]], align 4
; CG-NEXT:    [[TMP13]] = add nuw nsw <2 x i64> [[VEC_PHI0]], <i64 2, i64 2>
; CG-NEXT:    [[TMP14]] = add nuw nsw i64 [[UNI_PHI0]], 2
; CG-NEXT:    [[TMP15:%.*]] = icmp uge i64 [[TMP14]], 4
; CG-NEXT:    br i1 [[TMP15]], label [[VPLANNEDBB130:%.*]], label [[VECTOR_BODY0:%.*]], !llvm.loop !0
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cond = icmp sgt i64 %iv, 0
  br i1 %cond, label %uni.start, label %latch

uni.start:
  %uniform = load i1, ptr %uniform.ptr
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %if.end

if.else:
  br label %if.end

if.end:
  %blend = phi i64 [ 1, %if.then ], [ 2, %if.else]
  %val = add nsw nuw i64 %blend, 1
  br label %uni.end

uni.end:
  br label %latch

latch:
  %st = phi i64 [ -1, %header ], [ %val, %uni.end]
  %gep = getelementptr i64, ptr %p, i64 %iv
  store i64 %st, ptr %gep
  %iv.next = add nsw nuw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 4
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Used to crash with the first iteration of the patch. Not sure how to reproduce
; the same now that blends with undef are optimized inside predicator.
define void @uniform_with_undef(ptr %p, i64 %n) {
; VPLAN-LABEL:  VPlan after predicator:
; VPLAN-NEXT:  VPlan IR for: uniform_with_undef:header.#{{[0-9]+}}
; VPLAN-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; VPLAN-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB1]]: # preds: [[BB0]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_IV_IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 4, UF = 1
; VPLAN-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_IV_NEXT:%.*]], [[BB3]] ]
; VPLAN-NEXT:     [DA: Div] i1 [[VP_COND:%.*]] = icmp sgt i64 [[VP_IV]] i64 0
; VPLAN-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = icmp eq i64 [[VP_IV]] i64 [[N0:%.*]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; VPLAN-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB4]]: # preds: [[BB2]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; VPLAN-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB5]]: # preds: [[BB4]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; VPLAN-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB6]]: # preds: [[BB5]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_VAL:%.*]] = add i64 1 i64 1
; VPLAN-NEXT:     [DA: Uni] br [[BB3]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB3]]: # preds: [[BB6]]
; VPLAN-NEXT:     [DA: Div] ptr [[VP_GEP:%.*]] = getelementptr i64, ptr [[P0:%.*]] i64 [[VP_IV]]
; VPLAN-NEXT:     [DA: Div] store i64 1 ptr [[VP_GEP]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP_IV_NEXT]] = add i64 [[VP_IV]] i64 [[VP_IV_IND_INIT_STEP]]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-NEXT:     [DA: Uni] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB7:BB[0-9]+]], [[BB2]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB7]]: # preds: [[BB3]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; VPLAN-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB8]]: # preds: [[BB7]]
; VPLAN-NEXT:     [DA: Uni] br <External Block>
; VPLAN-EMPTY:
; VPLAN-NEXT:  External Uses:
; VPLAN-NEXT:  Id: 0   no underlying for i64 [[VP_IV_IND_FINAL]]
;
;
; CG:  define void @uniform_with_undef(ptr [[P0:%.*]], i64 [[N0:%.*]]) {
; CG:       vector.body:
; CG-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VPLANNEDBB10]] ], [ [[TMP5:%.*]], [[VPLANNEDBB60:%.*]] ]
; CG-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i64> [ <i64 0, i64 1>, [[VPLANNEDBB10]] ], [ [[TMP4:%.*]], [[VPLANNEDBB60]] ]
; CG-NEXT:    [[TMP0:%.*]] = icmp sgt <2 x i64> [[VEC_PHI0]], zeroinitializer
; CG-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i64> [[VEC_PHI0]], [[BROADCAST_SPLAT0]]
; CG-NEXT:    [[TMP2:%.*]] = xor <2 x i1> [[TMP1]], <i1 true, i1 true>
; CG-NEXT:    br label [[VPLANNEDBB30:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB3:
; CG-NEXT:    br label [[VPLANNEDBB40:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB4:
; CG-NEXT:    br label [[VPLANNEDBB50:%.*]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB5:
; CG-NEXT:    br label [[VPLANNEDBB60]]
; CG-EMPTY:
; CG-NEXT:  VPlannedBB6:
; CG-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr i64, ptr [[P0]], i64 [[UNI_PHI0]]
; CG-NEXT:    store <2 x i64> <i64 1, i64 1>, ptr [[SCALAR_GEP0]], align 4
; CG-NEXT:    [[TMP4]] = add nuw nsw <2 x i64> [[VEC_PHI0]], <i64 2, i64 2>
; CG-NEXT:    [[TMP5]] = add nuw nsw i64 [[UNI_PHI0]], 2
; CG-NEXT:    [[TMP6:%.*]] = icmp uge i64 [[TMP5]], 4
; CG-NEXT:    br i1 [[TMP6]], label [[VPLANNEDBB70:%.*]], label [[VECTOR_BODY0]], !llvm.loop !
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cond = icmp sgt i64 %iv, 0
  %varying = icmp eq i64 %iv, %n
  br i1 %varying, label %if.then, label %if.else

if.then:
  br label %if.end

if.else:
  br label %if.end

if.end:
  %blend = phi i64 [ 1, %if.then ], [ undef, %if.else]
  %val = add nsw nuw i64 %blend, 1
  br label %latch

latch:
  %gep = getelementptr i64, ptr %p, i64 %iv
  store i64 %blend, ptr %gep
  %iv.next = add nsw nuw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 4
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)
