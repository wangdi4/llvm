; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt -vplan-import-orig-bb-names -S -vplan-func-vec -print-after-vplan-func-vec-predicator < %s -disable-output | FileCheck %s
; RUN: opt -vplan-import-orig-bb-names -S -passes="vplan-func-vec" -print-after-vplan-func-vec-predicator < %s -disable-output | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @simple() {
; CHECK-LABEL:  VPlan IR for: simple
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb1
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;   entry
;   / |
;  bb1|
;    \|
;   exit
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb1, label %exit

bb1:
  br label %exit

exit:
  ret void
}

define void @test() {
; CHECK-LABEL:  VPlan IR for: test
; CHECK-NEXT:    : # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if.else
; CHECK-EMPTY:
; CHECK-NEXT:    if.else: # preds:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_DEF_FALSE:%.*]] = add i32 [[VP_LANE]] i32 1
; CHECK-NEXT:     [DA: Uni] br if.true
; CHECK-EMPTY:
; CHECK-NEXT:    if.true: # preds: if.else
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_DEF_TRUE:%.*]] = add i32 [[VP_LANE]] i32 0
; CHECK-NEXT:     [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: if.true
; CHECK-NEXT:     [DA: Div] i32 [[VP_MERGE_BLEND_IF_TRUE:%.*]] = blend [ i32 [[VP_DEF_FALSE]], i1 [[VP_VARYING_NOT]] ], [ i32 [[VP_DEF_TRUE]], i1 [[VP_VARYING]] ]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if.true, label %if.else

if.true:
  %def.true = add nsw nuw i32 %lane, 0
  br label %if.end

if.else:
  %def.false = add nsw nuw i32 %lane, 1
  br label %if.end

if.end:
  %merge = phi i32 [ %def.true, %if.true ], [ %def.false, %if.else ]
  ret void
}

define void @test_2_hammocks() {
; CHECK-LABEL:  VPlan IR for: test_2_hammocks
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5: # preds: bb3
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb5
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb4
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      entry
;      /   \
;    bb1   bb2
;      \   /
;       bb3
;      /   \
;    bb4   bb5
;      \   /
;       exit

  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb1, label %bb2

bb1:
  br label %bb3

bb2:
  br label %bb3

bb3:
  %bb3.varying = call i1 @varying(i32 %lane)
  br i1 %bb3.varying, label %bb4, label %bb5

bb4:
  br label %exit

bb5:
  br label %exit

exit:
  ret void
}

define void @test_nested_if_else() {
; CHECK-LABEL:  VPlan IR for: test_nested_if_else
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_BB2_VARYING_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb6
; CHECK-EMPTY:
; CHECK-NEXT:    bb6: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5: # preds: bb6
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb5
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: bb4
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb3
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;         entry
;        /    \
;      bb1    bb2
;      / \    / \
;    bb3 bb4 bb5 bb6
;      \  |   |  /
;       \ |   | /
;         exit
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb1, label %bb2

bb1:
  %bb1.varying = call i1 @varying(i32 %lane)
  br i1 %bb1.varying, label %bb3, label %bb4

bb3:
  br label %exit

bb4:
  br label %exit

bb2:
  %bb2.varying = call i1 @varying(i32 %lane)
  br i1 %bb2.varying, label %bb5, label %bb6

bb5:
  br label %exit

bb6:
  br label %exit

exit:
  ret void
}

define void @test_uniform_edge_to_divergent_block(i1 *%uniform.ptr) {
; CHECK-LABEL:  VPlan IR for: test_uniform_edge_to_divergent_block
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = load i1* [[UNIFORM_PTR0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_UNIFORM]], bb1, bb2
; CHECK-EMPTY:
; CHECK-NEXT:      bb1: # preds: bb0
; CHECK-NEXT:       [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:      bb3: # preds: bb1
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: bb0, bb3
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT_PHI_BB2:%.*]] = phi  [ i1 false, bb0 ],  [ i1 [[VP_VARYING_NOT]], bb3 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = or i1 [[VP_UNIFORM_NOT]] i1 [[VP_VARYING_NOT_PHI_BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP1]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb2
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;          entry
;           |
;         BB0 (U)
;       /     \
;     BB1 (D)  |
;    /   \    /
;   /     \ /
;  BB3   BB2
;   \    /
;    BB4
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  %uniform = load i1, i1 *%uniform.ptr
  br i1 %uniform, label %bb1, label %bb2

bb1:
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb3, label %bb2

bb2:
  br label %bb4

bb3:
  br label %bb4

bb4:
  ret void
}

define void @test_two_linearized_pathes_merge(i1 *%uniform.ptr) {
; CHECK-LABEL:  VPlan IR for: test_two_linearized_pathes_merge
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Uni] i1 [[VP_BB0_UNIFORM:%.*]] = load i1* [[UNIFORM_PTR0:%.*]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_BB0_UNIFORM]], bb1, bb2
; CHECK-EMPTY:
; CHECK-NEXT:      bb2: # preds: bb0
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb6
; CHECK-EMPTY:
; CHECK-NEXT:      bb6: # preds: bb2
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:      bb1: # preds: bb0
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:      bb3: # preds: bb1
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:       [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB0]]: # preds: bb3
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB1_VARYING]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:      bb4: # preds: [[BB0]]
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB1_VARYING_NOT]] i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:       [DA: Uni] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5: # preds: bb4, bb6
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_PHI_BB5:%.*]] = phi  [ i1 false, bb4 ],  [ i1 [[VP_BB2_VARYING]], bb6 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT]], bb4 ],  [ i1 false, bb6 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 [[VP_BB1_VARYING_NOT]], bb4 ],  [ i1 false, bb6 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = or i1 [[VP_BB2_VARYING_PHI_BB5]] i1 [[VP_BB1_VARYING_NOT_PHI_BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT_PHI_BB5]] i1 [[VP4]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb5
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;           entry
;            |
;           BB0 (U)
;          /    \
;         /      \
;      BB1 (D)   BB2 (D)
;     /   \      /  \
;  BB3     +    /    \
;  |  \    |   /      \
;  |    BB4    |      |
;  |      \    /      |
;  |        BB5       BB6
;  \         \       /
;   \         \     /
;    +-------> exit
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  %bb0.uniform = load i1, i1 *%uniform.ptr
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = call i1 @varying(i32 %lane)
  br i1 %bb1.varying, label %bb3, label %bb4

bb2:
  %bb2.varying = call i1 @varying(i32 %lane)
  br i1 %bb2.varying, label %bb5, label %bb6

bb3:
  %bb3.varying = call i1 @varying(i32 %lane)
  br i1 %bb3.varying, label %exit, label %bb4

bb4:
  br label %bb5

bb5:
  br label %exit

bb6:
  br label %exit

exit:
  ret void
}

define void @test_separate_blend_bb_for_2_div_plus_uniform(i1 *%uniform.ptr) {
; CHECK-LABEL:  VPlan IR for: test_separate_blend_bb_for_2_div_plus_uniform
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = load i1* [[UNIFORM_PTR0:%.*]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_UNIFORM]], bb1, bb4
; CHECK-EMPTY:
; CHECK-NEXT:      bb1: # preds: bb0
; CHECK-NEXT:       [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:      bb2: # preds: bb1
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:      bb3: # preds: bb2
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]: # preds: bb3
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB3:%.*]] = blend [ i32 2, i1 [[VP_VARYING_NOT]] ], [ i32 3, i1 [[VP_VARYING]] ]
; CHECK-NEXT:       [DA: Div] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb0, [[BLEND_BB0]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 0, bb0 ],  [ i32 [[VP_PHI_BLEND_BB3]], [[BLEND_BB0]] ]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;        entry
;          |
;         BB0 (U)
;       /     \
;     BB1 (D)  |
;    /   \     |
;   /     \    |
;  BB3   BB2   |
;   \    /    /
;    BB4<----+
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  %uniform = load i1, i1 *%uniform.ptr
  br i1 %uniform, label %bb1, label %bb4

bb1:
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb3, label %bb2

bb2:
  br label %bb4

bb3:
  br label %bb4

bb4:
  %phi = phi i32 [ 0, %bb0 ], [ 2, %bb2 ], [ 3, %bb3 ]
  ret void
}

define void @test_two_blend_bbs(i1 %u0, i1 %u4)  {
; CHECK-LABEL:  VPlan IR for: test_two_blend_bbs
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Uni] br i1 [[U00:%.*]], bb1, bb4
; CHECK-EMPTY:
; CHECK-NEXT:      bb4: # preds: bb0
; CHECK-NEXT:       [DA: Uni] br i1 [[U40:%.*]], bb7, bb5
; CHECK-EMPTY:
; CHECK-NEXT:        bb5: # preds: bb4
; CHECK-NEXT:         [DA: Div] i1 [[VP_BB5_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:         [DA: Uni] br bb6
; CHECK-EMPTY:
; CHECK-NEXT:        bb6: # preds: bb5
; CHECK-NEXT:         [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB5_VARYING]]
; CHECK-NEXT:         [DA: Uni] br [[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BLEND_BB0]]: # preds: bb6
; CHECK-NEXT:         [DA: Div] i32 [[VP_PHI_BLEND_BB6:%.*]] = blend [ i32 5, i1 true ], [ i32 6, i1 [[VP_BB5_VARYING]] ]
; CHECK-NEXT:         [DA: Div] br bb7
; CHECK-EMPTY:
; CHECK-NEXT:      bb1: # preds: bb0
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:      bb2: # preds: bb1
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:      bb3: # preds: bb2
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB1:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB1]]: # preds: bb3
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB3:%.*]] = blend [ i32 2, i1 [[VP_BB1_VARYING_NOT]] ], [ i32 3, i1 [[VP_BB1_VARYING]] ]
; CHECK-NEXT:       [DA: Div] br bb7
; CHECK-EMPTY:
; CHECK-NEXT:    bb7: # preds: bb4, [[BLEND_BB0]], [[BLEND_BB1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI:%.*]] = phi  [ i32 4, bb4 ],  [ i32 [[VP_PHI_BLEND_BB6]], [[BLEND_BB0]] ],  [ i32 [[VP_PHI_BLEND_BB3]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;       entry
;          |
;         BB0 (U)
;       /     \
;     BB1 (D)  BB4 (U)
;    /   \      /  \
;   /     \    /    BB5 (D)
;  BB3   BB2  |    / |
;   \     |   | BB6  |
;    \    |   | /    /
;     \   |  / /    /
;      \  | / /    /
;       +>BB7<----+
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  br i1 %u0, label %bb1, label %bb4

bb1:
  %bb1.varying = call i1 @varying(i32 %lane)
  br i1 %bb1.varying, label %bb3, label %bb2

bb2:
  br label %bb7

bb3:
  br label %bb7

bb4:
  br i1 %u4, label %bb7, label %bb5

bb5:
  %bb5.varying = call i1 @varying(i32 %lane)
  br i1 %bb5.varying, label %bb6, label %bb7

bb6:
  br label %bb7

bb7:
  %phi = phi i32 [5, %bb5], [ 3, %bb3 ], [ 4, %bb4 ],[ 6, %bb6 ], [ 2, %bb2 ]
  ret void
}

define void @test_uni_loop(i32 %vf) {
; CHECK-LABEL:  VPlan IR for: test_uni_loop
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br header
; CHECK-EMPTY:
; CHECK-NEXT:    header: # preds: entry, latch
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 0, entry ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], latch ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC:%.*]] = phi  [ i32 [[VP_LANE]], entry ],  [ i32 [[VP_VEC_NEXT:%.*]], latch ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_COND:%.*]] = icmp eq i32 [[VP_LANE]] i32 3
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: header
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND]]
; CHECK-NEXT:     [DA: Uni] br latch
; CHECK-EMPTY:
; CHECK-NEXT:    latch: # preds: if.then
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_BLEND_IF_THEN:%.*]] = blend [ i32 0, i1 true ], [ i32 1, i1 [[VP_COND]] ]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC_NEXT]] = add i32 [[VP_VEC]] i32 [[VF0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_EXIT_COND:%.*]] = icmp eq i32 [[VP_LOOP_IV]] i32 42
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_EXIT_COND]], exit, header
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: latch
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %loop_iv = phi i32 [ 0, %entry ], [ %loop_iv.next, %latch ]
  %vec = phi i32 [ %lane, %entry ], [ %vec.next, %latch ]
  %cond = icmp eq i32 %lane, 3
  br i1 %cond, label %if.then, label %latch

if.then:
  br label %latch

latch:
  %phi = phi i32 [ 0, %header ], [ 1, %if.then]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %vec.next = add nsw nuw i32 %vec, %vf
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %exit, label %header

exit:
  ret void
}

; Simplified form of loop-cfu normalization. Can't represent what LoopCFU
; actually does because it breaks SSA form (e.g. for the IV phi/update). It's
; "restored" after predication/linearization.
define void @test_div_loop(i32 %vf) {
; CHECK-LABEL:  VPlan IR for: test_div_loop
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32 [[VP_MUL:%.*]] = mul i32 [[VP_LANE]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Uni] br header
; CHECK-EMPTY:
; CHECK-NEXT:    header: # preds: entry, latch
; CHECK-NEXT:     [DA: Div] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 [[VP_MUL]], entry ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], latch ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_MASK:%.*]] = phi  [ i1 true, entry ],  [ i1 [[VP_MASK_NEXT:%.*]], latch ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LIVEOUT_PREV:%.*]] = phi  [ i32 undef, entry ],  [ i32 [[VP_LIVEOUT_BLEND_ACTIVE:%.*]], latch ]
; CHECK-NEXT:     [DA: Uni] br active
; CHECK-EMPTY:
; CHECK-NEXT:    active: # preds: header
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_MASK]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_ADD:%.*]] = add i32 [[VP_LOOP_IV]] i32 7
; CHECK-NEXT:     [DA: Uni] br latch
; CHECK-EMPTY:
; CHECK-NEXT:    latch: # preds: active
; CHECK-NEXT:     [DA: Div] i32 [[VP_LIVEOUT_BLEND_ACTIVE]] = blend [ i32 [[VP_LIVEOUT_PREV]], i1 true ], [ i32 [[VP_LOOP_IV]], i1 [[VP_MASK]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_DIV_EXIT_COND:%.*]] = icmp eq i32 [[VP_LOOP_IV]] i32 42
; CHECK-NEXT:     [DA: Div] i1 [[VP_NOT:%.*]] = xor i1 [[VP_DIV_EXIT_COND]] i1 true
; CHECK-NEXT:     [DA: Div] i1 [[VP_MASK_NEXT]] = and i1 [[VP_MASK]] i1 [[VP_NOT]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_EXIT_COND:%.*]] = call i1 [[VP_MASK_NEXT]] i1 (i1)* @allzero
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_EXIT_COND]], exit, header
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: latch
; CHECK-NEXT:     [DA: Div] i32 [[VP_LIVEOUT_USE:%.*]] = phi  [ i32 [[VP_LIVEOUT_BLEND_ACTIVE]], latch ]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %mul = mul nsw nuw i32 %lane, %lane
  br label %header

header:
  %loop_iv = phi i32 [ %mul, %entry ], [ %loop_iv.next, %latch ]
  %mask = phi i1 [ true, %entry ], [ %mask.next, %latch ]
  %liveout.prev = phi i32 [ undef, %entry ], [ %liveout, %latch ]
  br i1 %mask, label %active, label %latch

active:
  %add = add i32 %loop_iv, 7
  br label %latch

latch:
  %liveout = phi i32 [ %liveout.prev, %header ], [ %loop_iv, %active ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %div_exit_cond = icmp eq i32 %loop_iv, 42
  %not = xor i1 %div_exit_cond, true
  %mask.next = and i1 %mask, %not
  %exit_cond = call i1 @allzero(i1 %mask.next)
  br i1 %exit_cond, label %exit, label %header

exit:
  %liveout.use = phi i32 [ %liveout, %latch ]
  ret void
}

define void @test_uni_loop_div_top_test(i32 %vf) {
; CHECK-LABEL:  VPlan IR for: test_uni_loop_div_top_test
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_TOPTEST:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_TOPTEST_NOT:%.*]] = not i1 [[VP_TOPTEST]]
; CHECK-NEXT:     [DA: Uni] br preheader
; CHECK-EMPTY:
; CHECK-NEXT:    preheader: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br header
; CHECK-EMPTY:
; CHECK-NEXT:    header: # preds: preheader, header
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 0, preheader ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], header ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC:%.*]] = phi  [ i32 [[VP_LANE]], preheader ],  [ i32 [[VP_VEC_NEXT:%.*]], header ]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC_NEXT]] = add i32 [[VP_VEC]] i32 [[VF0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_EXIT_COND:%.*]] = icmp eq i32 [[VP_LOOP_IV]] i32 42
; CHECK-NEXT:     [DA: Uni] i1 [[VP2:%.*]] = all-zero-check i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP3:%.*]] = or i1 [[VP2]] i1 [[VP_EXIT_COND]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP3]], loop.exit, header
; CHECK-EMPTY:
; CHECK-NEXT:    loop.exit: # preds: header
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: loop.exit
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %toptest = call i1 @varying(i32 %lane)
  br i1 %toptest, label %exit, label %preheader

preheader:
  br label %header

header:
  %loop_iv = phi i32 [ 0, %preheader ], [ %loop_iv.next, %header ]
  %vec = phi i32 [ %lane, %preheader ], [ %vec.next, %header ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %vec.next = add nsw nuw i32 %vec, %vf
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %loop.exit, label %header

loop.exit:
  br label %exit

exit:
  ret void
}

; Checks that two top-level loops don't cause any asserts.
define void @test_two_loops(i32 %vf) {
; CHECK-LABEL:  VPlan IR for: test_two_loops
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_TOPTEST:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_TOPTEST_NOT:%.*]] = not i1 [[VP_TOPTEST]]
; CHECK-NEXT:     [DA: Uni] br preheader
; CHECK-EMPTY:
; CHECK-NEXT:    preheader: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br header
; CHECK-EMPTY:
; CHECK-NEXT:    header: # preds: preheader, header
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 0, preheader ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], header ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC:%.*]] = phi  [ i32 [[VP_LANE]], preheader ],  [ i32 [[VP_VEC_NEXT:%.*]], header ]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_COND:%.*]] = icmp eq i32 [[VP_LANE]] i32 3
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC_NEXT]] = add i32 [[VP_VEC]] i32 [[VF0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_EXIT_COND:%.*]] = icmp eq i32 [[VP_LOOP_IV]] i32 42
; CHECK-NEXT:     [DA: Uni] i1 [[VP2:%.*]] = all-zero-check i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP3:%.*]] = or i1 [[VP2]] i1 [[VP_EXIT_COND]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP3]], loop.exit, header
; CHECK-EMPTY:
; CHECK-NEXT:    loop.exit: # preds: header
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br header2
; CHECK-EMPTY:
; CHECK-NEXT:    header2: # preds: loop.exit, header2
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV2:%.*]] = phi  [ i32 0, loop.exit ],  [ i32 [[VP_LOOP_IV2_NEXT:%.*]], header2 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LOOP_IV2_NEXT]] = add i32 [[VP_LOOP_IV2]] i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_EXIT_COND2:%.*]] = icmp eq i32 [[VP_LOOP_IV2]] i32 42
; CHECK-NEXT:     [DA: Uni] i1 [[VP6:%.*]] = all-zero-check i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP7:%.*]] = or i1 [[VP6]] i1 [[VP_EXIT_COND2]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP7]], loop.exit2, header2
; CHECK-EMPTY:
; CHECK-NEXT:    loop.exit2: # preds: header2
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP_TOPTEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: loop.exit2
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %toptest = call i1 @varying(i32 %lane)
  br i1 %toptest, label %exit, label %preheader

preheader:
  br label %header

header:
  %loop_iv = phi i32 [ 0, %preheader ], [ %loop_iv.next, %header ]
  %vec = phi i32 [ %lane, %preheader ], [ %vec.next, %header ]
  %cond = icmp eq i32 %lane, 3
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %vec.next = add nsw nuw i32 %vec, %vf
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %loop.exit, label %header

loop.exit:
  br label %header2

header2:
  %loop_iv2 = phi i32 [ 0, %loop.exit ], [ %loop_iv2.next, %header2 ]
  %loop_iv2.next = add nsw nuw i32 %loop_iv2, 1
  %exit_cond2 = icmp eq i32 %loop_iv2, 42
  br i1 %exit_cond2, label %loop.exit2, label %header2

loop.exit2:
  br label %exit

exit:
  ret void
}

define dso_local void @test_divergent_loop_with_double_top_test(i32 %N, i32 *%a, i32 %mask_out_loop) {
; CHECK-LABEL:  VPlan IR for: test_divergent_loop_with_double_top_test
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_SKIP_LOOP:%.*]] = icmp eq i32 [[VP_LANE]] i32 [[MASK_OUT_LOOP0:%.*]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_SKIP_LOOP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST:%.*]] = icmp eq i32 [[N0:%.*]] i32 0
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST_NOT:%.*]] = not i1 [[VP_SECOND_TEST]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SECOND_TEST_NOT_1:%.*]] = not i1 [[VP_SECOND_TEST]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_BR_VP_SECOND_TEST_NOT:%.*]] = and i1 [[VP_SKIP_LOOP]] i1 [[VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br header
; CHECK-EMPTY:
; CHECK-NEXT:    header: # preds: bb2, [[BB1:BB[0-9]+]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV:%.*]] = phi  [ i32 [[VP_IV_NEXT:%.*]], [[BB1]] ],  [ i32 0, bb2 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK:%.*]] = phi  [ i1 [[VP_SECOND_TEST_NOT_1]], bb2 ],  [ i1 [[VP_LOOP_MASK_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_LIVE_OUT_PREV:%.*]] = phi  [ i32 undef, bb2 ],  [ i32 [[VP_IV_LIVE_OUT_BLEND:%.*]], [[BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: header
; CHECK-NEXT:     [DA: Div] i1 [[VP_HEADER_BR_VP_LOOP_MASK:%.*]] = and i1 [[VP_BB1_BR_VP_SECOND_TEST_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_HEADER_BR_VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] i32* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i32* [[A0:%.*]] i32 [[VP_IV]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_LD:%.*]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_SOME_CMP:%.*]] = icmp eq i32 [[VP_LD]] i32 42
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND:%.*]] = icmp eq i32 [[VP_IV_NEXT]] i32 [[VP_LANE]]
; CHECK-NEXT:     [DA: Uni] br [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_LIVE_OUT_BLEND]] = select i1 [[VP_LOOP_MASK]] i32 [[VP_IV]] i32 [[VP_IV_LIVE_OUT_PREV]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND_NOT:%.*]] = not i1 [[VP_EXITCOND]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK_NEXT]] = and i1 [[VP_EXITCOND_NOT]] i1 [[VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP5:%.*]] = all-zero-check i1 [[VP_LOOP_MASK_NEXT]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP5]], bb3, header
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_USE:%.*]] = phi  [ i32 [[VP_IV_LIVE_OUT_BLEND]], [[BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_SECOND_TEST_NOT]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb3
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;       entry
;       /     \
;     bb1      \
;    /  \       \
;   +   bb2      +
;   |    |       |
;   |  header<+  |
;   |   | +---+  |
;   +   |        |
;    \  |        |
;     +->exit <--+
  %lane = call i32 @llvm.vplan.laneid()
  %skip_loop = icmp eq i32 %lane, %mask_out_loop
  br i1 %skip_loop, label %bb1, label %exit

bb1:
  %second.test = icmp eq i32 %N, 0
  br i1 %second.test, label %exit, label %bb2

bb2:
  br label %header

header:
  %iv = phi i32 [ %iv.next, %header ], [ 0, %bb2 ]
  %arrayidx = getelementptr inbounds i32, i32* %a, i32 %iv
  %ld = load i32, i32* %arrayidx
  %some_cmp = icmp eq i32 %ld, 42
  %iv.next = add nuw nsw i32 %iv, 1
  %exitcond = icmp eq i32 %iv.next, %lane
  br i1 %exitcond, label %bb3, label %header

bb3:
  %phi_use = phi i32 [ %iv, %header ]
  br label %exit

exit:
  ret void
}

define void @test_single_succ_single_pred_edge() {
; CHECK-LABEL:  VPlan IR for: test_single_succ_single_pred_edge
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: bb0
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb3
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;       entry
;          |
;         BB0 (D)
;       /    \
;     BB1    BB2
;      |      |
;      |      |
;     BB3    /
;      |    /
;     BB4<-+
; Test checks predicate of the BB3, because BB1-BB3 edge is both single
; successor for BB1 and single predecessor for BB3.
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  %bb0.varying = call i1 @varying(i32 %lane)
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  br label %bb3

bb2:
  br label %bb4

bb3:
  br label %bb4

bb4:
  ret void
}

define void @test_use_dom_instead_of_direct_succ() {
; CHECK-LABEL:  VPlan IR for: test_use_dom_instead_of_direct_succ
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb6
; CHECK-EMPTY:
; CHECK-NEXT:    bb6: # preds: bb0
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: bb6
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB6_BR_VP_BB6_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB6_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb7
; CHECK-EMPTY:
; CHECK-NEXT:    bb7: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB6_BR_VP_BB6_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_VARYING_NOT:%.*]] = not i1 [[VP_BB7_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: bb7
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB7_BR_VP_BB7_VARYING_NOT:%.*]] = and i1 [[VP_BB6_BR_VP_BB6_VARYING]] i1 [[VP_BB7_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb8
; CHECK-EMPTY:
; CHECK-NEXT:    bb8: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB7_BR_VP_BB7_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb8
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_BB2_VARYING_NOT:%.*]] = and i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_BB2_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb3
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB2_BR_VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5: # preds: bb4
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = or i1 [[VP_BB6_BR_VP_BB6_VARYING]] i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP7]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb5
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;           entry
;             |
;            BB0 (D)
;          /    \
;        BB1 (D) \
;       /  \      BB6 (D)-+
;      +    \       |     |
;      |    BB2    BB7 (D)|
;      |    /  \    |\    |
;      |  BB4  BB3  + BB8 |
;      |    \  /   /   |  |
;      |    BB5<--+    |  |
;      +     | \       |  +
;       \    |  +------+ /
;        \   |          /
;         +-> exit <---+
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br label %bb0

bb0:
  %bb0.varying = call i1 @varying(i32 %lane)
  br i1 %bb0.varying, label %bb1, label %bb6

bb1:
  %bb1.varying = call i1 @varying(i32 %lane)
  br i1 %bb1.varying, label %exit, label %bb2

bb2:
  %bb2.varying = call i1 @varying(i32 %lane)
  br i1 %bb2.varying, label %bb4, label %bb3

bb3:
  br label %bb5

bb4:
  br label %bb5

bb5:
  br label %exit

bb6:
  %bb6.varying = call i1 @varying(i32 %lane)
  br i1 %bb6.varying, label %bb7, label %exit

bb7:
  %bb7.varying = call i1 @varying(i32 %lane)
  br i1 %bb7.varying, label %bb5, label %bb8

bb8:
  br label %bb5

exit:
  ret void
}

define void @test_triple_pred_in_single_linearized_flow() {
; CHECK-LABEL:  VPlan IR for: test_triple_pred_in_single_linearized_flow
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb0
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_BR_VP_BB1_VARYING:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: bb3
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB1_BR_VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb2
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb4
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
; NOTE: Dependent on order of children visiting in RPOT. If BB0-BB2 is changed
; to BB-BB3 the issue isn't reproducible.
; By the time BB2 is processed, edges BB0-BB2 and BB1-BB2 are RemovedDivergent
; and BB2 is disconnected from the linearized BB0-BB1-BB3 chain. The test checks
; that exactly one BB3-BB2 edge is added when connecting BB2 to the linearized
; CFG.
;       entry
; (False) |
;  +----BB0 (D)
;  |    / (True)
;  |  BB1 (D)
;  | /   \
;  |/     \
;  BB2   BB3
;   \    /
;     BB4
;     |
;    exit
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  %bb0.varying = call i1 @varying(i32 %lane)
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = call i1 @varying(i32 %lane)
  br i1 %bb1.varying, label %bb2, label %bb3

bb2:
  br label %bb4

bb3:
  br label %bb4

bb4:
  br label %exit

exit:
  ret void
}

define void @test_linearized_chain() {
; CHECK-LABEL:  VPlan IR for: test_linearized_chain
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: bb0
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB2_BR_VP_BB2_VARYING]] i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb3
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
; "White-box" test. Assumes the linearization process visit blocks in order:
; BB0, BB2, BB1. While visiting BB2, edge BB0->BB1 is dropped and at the time
; BB1 is visited we need to attach it directly to BB2. Ensure that unprocessed
; edges from BB2 are not causing crashes (we used to assert for a number of
; outgoing edges inside the linearized chain, but didn't limit it to the blocks
; for which at least once successor was processed).
;       entry
;          |
;         BB0 (D)
;       /     \
;     BB1     BB2
;      \     / |
;       \   /  +
;        BB3  /
;         |  /
;         | /
;        BB4
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  %bb0.varying = call i1 @varying(i32 %lane)
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  br label %bb3

bb2:
  %bb2.varying = call i1 @varying(i32 %lane)
  br i1 %bb2.varying, label %bb3, label %bb4

bb3:
  br label %bb4

bb4:
  ret void
}

define void @test_reuse_idom() {
; CHECK-LABEL:  VPlan IR for: test_reuse_idom
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_VARYING_NOT:%.*]] = not i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: bb0
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB0_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB2_BR_VP_BB2_VARYING:%.*]] = and i1 [[VP_BB0_VARYING_NOT]] i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB0_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT:%.*]] = and i1 [[VP_BB0_VARYING]] i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB2_BR_VP_BB2_VARYING]] i1 [[VP_BB1_BR_VP_BB1_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: bb3
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB3_VARYING:%.*]] = and i1 [[VP2]] i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5: # preds: bb4
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_BB3_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb6
; CHECK-EMPTY:
; CHECK-NEXT:    bb6: # preds: bb5
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br bb7
; CHECK-EMPTY:
; CHECK-NEXT:    bb7: # preds: bb6
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
; Check BB6's predicate. Ideally, it should re-use the one from BB3.
;          entry
;            |
;           BB0 (D)
;         /    \
;      BB1 (D)  \
;      /  \      \
;     /    \    BB2 (D)
;     +     \  /   \
;     |      BB3 (D)\
;     |     /  \     +
;     |    /    \    |
;     |   BB5   BB4  |
;     |    \    /    +
;     +     BB6     /
;      \     |     /
;       +-->BB7<--+
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  %bb0.varying = call i1 @varying(i32 %lane)
  br i1 %bb0.varying, label %bb1, label %bb2

bb1:
  %bb1.varying = call i1 @varying(i32 %lane)
  br i1 %bb1.varying, label %bb7, label %bb3

bb2:
  %bb2.varying = call i1 @varying(i32 %lane)
  br i1 %bb2.varying, label %bb3, label %bb7

bb3:
  %bb3.varying = call i1 @varying(i32 %lane)
  br i1 %bb3.varying, label %bb5, label %bb4

bb4:
  br label %bb6

bb5:
  br label %bb6

bb6:
  br label %bb7

bb7:
  ret void
}

define void @test_blend_splitting_for_early_path_join(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: test_blend_splitting_for_early_path_join
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Uni] br i1 [[UNIFORM0:%.*]], bb1, bb2
; CHECK-EMPTY:
; CHECK-NEXT:      bb2: # preds: bb0
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB2_VARYING_NOT:%.*]] = not i1 [[VP_BB2_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:      bb3: # preds: bb2
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_BB2_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_VARYING_NOT:%.*]] = not i1 [[VP_BB3_VARYING]]
; CHECK-NEXT:       [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB0]]: # preds: bb3
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT:%.*]] = and i1 [[VP_BB2_VARYING_NOT]] i1 [[VP_BB3_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB0:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB0]]: # preds: [[BB0]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB3:%.*]] = blend [ i32 2, i1 true ], [ i32 3, i1 [[VP_BB2_VARYING_NOT]] ]
; CHECK-NEXT:       [DA: Div] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:      bb1: # preds: bb0
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB1_VARYING_NOT:%.*]] = not i1 [[VP_BB1_VARYING]]
; CHECK-NEXT:       [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:      bb4: # preds: bb1
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB1_VARYING_NOT]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_VARYING_NOT:%.*]] = not i1 [[VP_BB4_VARYING]]
; CHECK-NEXT:       [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB1]]: # preds: bb4
; CHECK-NEXT:       [DA: Div] i1 [[VP_BB4_BR_VP_BB4_VARYING_NOT:%.*]] = and i1 [[VP_BB1_VARYING_NOT]] i1 [[VP_BB4_VARYING_NOT]]
; CHECK-NEXT:       [DA: Uni] br [[BLEND_BB1:blend.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BLEND_BB1]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_PHI_BLEND_BB4:%.*]] = blend [ i32 1, i1 true ], [ i32 4, i1 [[VP_BB1_VARYING_NOT]] ]
; CHECK-NEXT:       [DA: Div] br bb5
; CHECK-EMPTY:
; CHECK-NEXT:    bb5: # preds: [[BLEND_BB0]], [[BLEND_BB1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_PHI_BB5:%.*]] = phi  [ i32 [[VP_PHI_BLEND_BB3]], [[BLEND_BB0]] ],  [ i32 [[VP_PHI_BLEND_BB4]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP_BB4_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 false, [[BLEND_BB0]] ],  [ i1 [[VP_BB4_BR_VP_BB4_VARYING_NOT]], [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT_PHI_BB5:%.*]] = phi  [ i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT]], [[BLEND_BB0]] ],  [ i1 false, [[BLEND_BB1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_BB3_BR_VP_BB3_VARYING_NOT_PHI_BB5]] i1 [[VP_BB4_BR_VP_BB4_VARYING_NOT_PHI_BB5]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br bb6
; CHECK-EMPTY:
; CHECK-NEXT:    bb6: # preds: bb5
; CHECK-NEXT:     [DA: Div] i32 [[VP_PHI_BLEND_BB5:%.*]] = blend [ i32 [[VP_PHI_PHI_BB5]], i1 true ], [ i32 5, i1 [[VP2]] ]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;          entry
;            |
;           BB0 (U)-----+
;         /              \
;      BB1 (D)            BB2 (D)
;      /  \              /  \
;     /    \            /   BB3 (D)
;     +     \          /  /   \
;     |      BB4 (D)- / -/---->BB5
;     |        \     /  /     |
;     |         \   +  /      |
;     |          \  | /       |
;     |           \ v/        |
;     +---------> BB6 <-------+
; After linearization (approximate, might be different in actual implementation)
; should be like this:
;           entry
;             |
;            BB0
;           /  \
;         BB1  BB2
;          |    |
;         BB4  BB3
;          |    |
;    Blend_1_4  Blend_2_3
;           \   /
;            BB5 RealPhi = [ Blend_1_4, BB4 ], [ Blend_2_3, BB3]
;             |
;            BB6 BlendForOrigPhi (RealPhi, BB5Def) (*)
; (*) can't have a blend with 5 incoming values, none of def1/def4/def2/def3
; would dominate that point.
  %lane = call i32 @llvm.vplan.laneid()
  br label %bb0

bb0:
  br i1 %uniform, label %bb1, label %bb2

bb1:
  %bb1.varying = call i1 @varying(i32 %lane)
  br i1 %bb1.varying, label %bb6, label %bb4

bb2:
  %bb2.varying = call i1 @varying(i32 %lane)
  br i1 %bb2.varying, label %bb6, label %bb3

bb3:
  %bb3.varying = call i1 @varying(i32 %lane)
  br i1 %bb3.varying, label %bb6, label %bb5

bb4:
  %bb4.varying = call i1 @varying(i32 %lane)
  br i1 %bb4.varying, label %bb6, label %bb5

bb5:
  br label %bb6

bb6:
  %phi = phi i32 [ 1, %bb1 ], [ 4, %bb4 ], [ 2, %bb2 ], [ 3, %bb3 ], [ 5, %bb5 ]
  ret void
}

define void @test_no_blend_in_uniform_control_flow(i32 %b) {
; CHECK-LABEL:  VPlan IR for: test_no_blend_in_uniform_control_flow
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = icmp eq i32 [[B0:%.*]] i32 42
; CHECK-NEXT:     [DA: Uni] br header
; CHECK-EMPTY:
; CHECK-NEXT:    header: # preds: entry, latch
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV:%.*]] = phi  [ i32 0, entry ],  [ i32 [[VP_IV_NEXT:%.*]], latch ]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_UNIFORM]], bb0, latch
; CHECK-EMPTY:
; CHECK-NEXT:      bb0: # preds: header
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_UNIFORM]], bb1, latch
; CHECK-EMPTY:
; CHECK-NEXT:      bb1: # preds: bb0
; CHECK-NEXT:       [DA: Uni] i32 [[VP_NO_BLEND_PHI:%.*]] = phi  [ i32 [[VP_IV]], bb0 ]
; CHECK-NEXT:       [DA: Uni] br latch
; CHECK-EMPTY:
; CHECK-NEXT:    latch: # preds: header, bb0, bb1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_THREE:%.*]] = phi  [ i32 [[VP_IV]], header ],  [ i32 [[VP_IV]], bb0 ],  [ i32 [[VP_IV]], bb1 ]
; CHECK-NEXT:     [DA: Uni] i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     [DA: Uni] i1 [[VP_COND:%.*]] = icmp eq i32 [[VP_IV_NEXT]] i32 42
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_COND]], exit, header
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: latch
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
; Make sure that workaround for CG's block-merge doesn't cause issues in blends
; transformation for bb1 - we shouldn't be doing anything to it for this uniform
; control flow (used to crash).
;             entry
;               |
;             header<+
;            /  |    |
;          bb0  |    |
;          / |  |    |
;        bb1 |  +    |
;         \  | /     |
;         latch------+
;           |
;         exit
  %lane = call i32 @llvm.vplan.laneid()
  %uniform = icmp eq i32 %b,  42
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %latch ]
  br i1 %uniform, label %bb0, label %latch

bb0:
  br i1 %uniform, label %bb1, label %latch

bb1:
  %no.blend.phi = phi i32 [ %iv, %bb0 ]
  br label %latch

latch:
  %three = phi i32 [ %iv, %header ], [ %iv, %bb0 ], [ %iv, %bb1 ]
  %iv.next = add nsw nuw i32 %iv, 1
  %cond = icmp eq i32 %iv.next, 42
  br i1 %cond, label %exit, label %header

exit:
  ret void
}

define void @test_not_of_phi() {
; CHECK-LABEL:  VPlan IR for: test_not_of_phi
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP_COND_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: bb0
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb1
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br label %bb0

bb0:
  %cond = phi i1 [ %varying, %entry ]
  %some = phi i32 [ 0, %entry ]
  br i1 %cond, label %bb1, label %bb2

bb1:
  br label %exit

bb2:
  br label %exit

exit:
  ret void
}

define void @no_blend_on_edge(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: no_blend_on_edge
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br i1 [[UNIFORM0:%.*]], bb3, bb1
; CHECK-EMPTY:
; CHECK-NEXT:      bb1: # preds: entry
; CHECK-NEXT:       [DA: Div] i32 [[VP_DEF1:%.*]] = add i32 [[VP_LANE]] i32 1
; CHECK-NEXT:       [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:      bb2: # preds: bb1
; CHECK-NEXT:       [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:       [DA: Div] i32 [[VP_DEF2:%.*]] = add i32 [[VP_LANE]] i32 2
; CHECK-NEXT:       [DA: Uni] br bb3
; CHECK-EMPTY:
; CHECK-NEXT:    bb3: # preds: entry, bb2
; CHECK-NEXT:     [DA: Div] i32 [[VP_P_PHI_BB3:%.*]] = phi  [ i32 undef, entry ],  [ i32 [[VP_DEF1]], bb2 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_PHI_BB3:%.*]] = phi  [ i1 false, entry ],  [ i1 [[VP_VARYING]], bb2 ]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = or i1 [[UNIFORM0]] i1 [[VP_VARYING_PHI_BB3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP1]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_DEF3:%.*]] = add i32 [[VP_LANE]] i32 3
; CHECK-NEXT:     [DA: Uni] br bb4
; CHECK-EMPTY:
; CHECK-NEXT:    bb4: # preds: bb3
; CHECK-NEXT:     [DA: Div] i32 [[VP_P_BLEND_BB3:%.*]] = blend [ i32 [[VP_P_PHI_BB3]], i1 true ], [ i32 [[VP_DEF3]], i1 [[VP1]] ]
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  Before linearization | After
;      entry (U)        |     entry
;     /    \            |      |  |
;    /      \           |      | bb1
;  bb3<-bb2<-bb1        |      |  |
;     \     /           |      | bb2
;      \   /            |      | /
;       bb4             |      bb3 ;  merge-phi = phi [undef, %def1]
;                       |       |
;                       |      bb4 ; blend merge-phi, true, %def3, bb3.pred
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %uniform, label %bb3, label %bb1

bb1:
  %def1 = add i32 %lane, 1
  br i1 %varying, label %bb2, label %bb4

bb2:
  %def2 = add i32 %lane, 2
  br label %bb3

bb3:
  %def3 = add i32 %lane, 3
  br label %bb4

bb4:
  %p = phi i32 [ %def1, %bb1 ], [ %def3, %bb3]
  ret void
}

define void @uniform_br_under_outer_mask_1(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_1
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING]] i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Uni] br i1 [[UNIFORM0]], if.then, if.end
; CHECK-EMPTY:
; CHECK-NEXT:      if.then: # preds: [[BB0]]
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:       [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: if.then, [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  if (%varying) {
;    if (external-uniform) {
;      Can preserve uniform CF.
;    }
;  }
;           D
;          / \
;         U   +
;        /|   |
;       o |   |
;        \|   | If U is preserved then the left edge needs to be preserved.
;         o   +
;          \ /
;           o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if, label %exit

if:
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_2(i1 *%uniform.ptr) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_2
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = load i1* [[UNIFORM_PTR0:%.*]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  %uniform =
;  if (%varying) {
;    if (%uniform) {
;      Still can preserve uniform CF because %uniform is always defined.
;    }
;  }
;           D
;          / \
;         U   +
;        /|   |
;       o |   |
;        \|   | If U is preserved then the left edge needs to be preserved.
;         o   +
;          \ /
;           o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  %uniform = load i1, i1 *%uniform.ptr
  br i1 %varying, label %if, label %exit

if:
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_3(i1 *%uniform.ptr) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_3
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM:%.*]] = load i1* [[UNIFORM_PTR0:%.*]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;  if (%varying) {
;    %conditionally.uniform =
;    if (%conditionally.uniform) {
;       Cannot trivially preserve uniform CF. The condition might never be
;       defined (%varying == 0 on all lanes) resulting in a branch based on
;       undef.
;    }
;  }
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if, label %exit

if:
  %uniform = load i1, i1 *%uniform.ptr
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_4(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_4
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.then
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;    /   \
;    |    U
;    |   /|
;    +  o +
;     \ |/    If U is preserved then middle edge needs to be preserved.
;       o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %exit

if.then:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_5(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_5
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br i1 [[UNIFORM0]], if.then, if.else
; CHECK-EMPTY:
; CHECK-NEXT:      if.else: # preds: [[BB0]]
; CHECK-NEXT:       [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:       [DA: Uni] br if.else2
; CHECK-EMPTY:
; CHECK-NEXT:      if.else2: # preds: if.else
; CHECK-NEXT:       [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:       [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:      if.then: # preds: [[BB0]]
; CHECK-NEXT:       [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:       [DA: Uni] br if.then2
; CHECK-EMPTY:
; CHECK-NEXT:      if.then2: # preds: if.then
; CHECK-NEXT:       [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:       [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: if.else2, if.then2
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;    /   \
;   +     U
;   |    / \
;   |   o   o
;   |   |   |  If U is preserved then two right edges need to be preserved.
;   |   o   o
;   +    \ /
;    \    o
;     \  /
;       o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %if.then2

if.then2:
  br label %if.end

if.else:
  br label %if.else2

if.else2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_6(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_6
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br if.else
; CHECK-EMPTY:
; CHECK-NEXT:    if.else: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br if.else2
; CHECK-EMPTY:
; CHECK-NEXT:    if.else2: # preds: if.else
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: if.else2
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br if.then2
; CHECK-EMPTY:
; CHECK-NEXT:    if.then2: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.then2
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;    /   \
;    |    U
;    |   / \
;    |  o   o
;    |  |   |  If U is preserved then right 2 edges need to be preserved.
;    |  o   o
;    +  |  /
;     \ | /
;       o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %if.then2

if.then2:
  br label %exit

if.else:
  br label %if.else2

if.else2:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_7(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_7
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br if.else
; CHECK-EMPTY:
; CHECK-NEXT:    if.else: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_ELSE_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_ELSE_VARYING_NOT:%.*]] = not i1 [[VP_ELSE_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: if.else
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_ELSE_BR_VP_ELSE_VARYING_NOT:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM_NOT]] i1 [[VP_ELSE_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_ELSE_BR_VP_ELSE_VARYING:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM_NOT]] i1 [[VP_ELSE_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING_NOT:%.*]] = not i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING_NOT:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = or i1 [[VP_IF_ELSE_BR_VP_ELSE_VARYING_NOT]] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP3]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_IF_ELSE_BR_VP_ELSE_VARYING]] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;   /   \
;  +     U
;  |    / \
;  |   D   D
;  |   | X |
;  +   o   o
;   \   \ /
;    \   o
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  %then.varying = call i1 @varying(i32 %lane)
  br i1 %then.varying, label %bb1, label %bb2

if.else:
  %else.varying = call i1 @varying(i32 %lane)
  br i1 %else.varying, label %bb1, label %bb2

bb1:
  br label %if.end

bb2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_8(i1 %uniform, i1 %u.then, i1 %u.else) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_8
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U_THEN_NOT:%.*]] = not i1 [[U_THEN0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U_ELSE_NOT:%.*]] = not i1 [[U_ELSE0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br if.else
; CHECK-EMPTY:
; CHECK-NEXT:    if.else: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: if.else
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_ELSE_BR_VP_U_ELSE_NOT:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM_NOT]] i1 [[VP_U_ELSE_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_ELSE_BR_VP_U_ELSE:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM_NOT]] i1 [[U_ELSE0]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_THEN_BR_VP_U_THEN_NOT:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM]] i1 [[VP_U_THEN_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_THEN_BR_VP_U_THEN:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM]] i1 [[U_THEN0]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = or i1 [[VP_IF_ELSE_BR_VP_U_ELSE_NOT]] i1 [[VP_IF_THEN_BR_VP_U_THEN_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP3]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_IF_ELSE_BR_VP_U_ELSE]] i1 [[VP_IF_THEN_BR_VP_U_THEN]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;   /   \
;  +     U
;  |    / \
;  |   U   U
;  |   | X |
;  +   o   o
;   \   \ /
;    \   o
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br i1 %u.then, label %bb1, label %bb2

if.else:
  br i1 %u.else, label %bb1, label %bb2

bb1:
  br label %if.end

bb2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_9(i1 %uniform, i1 %u.else) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_9
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U_ELSE_NOT:%.*]] = not i1 [[U_ELSE0:%.*]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br if.else
; CHECK-EMPTY:
; CHECK-NEXT:    if.else: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: if.else
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_ELSE_BR_VP_U_ELSE_NOT:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM_NOT]] i1 [[VP_U_ELSE_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_ELSE_BR_VP_U_ELSE:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM_NOT]] i1 [[U_ELSE0]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_THEN_VARYING_NOT:%.*]] = not i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING_NOT:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING:%.*]] = and i1 [[VP_IF_BR_VP_UNIFORM]] i1 [[VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb2
; CHECK-EMPTY:
; CHECK-NEXT:    bb2: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = or i1 [[VP_IF_ELSE_BR_VP_U_ELSE_NOT]] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP3]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: bb2
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = or i1 [[VP_IF_ELSE_BR_VP_U_ELSE]] i1 [[VP_IF_THEN_BR_VP_THEN_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;   /   \
;  +     U
;  |    / \
;  |   D   U
;  |   | X |
;  +   o   o
;   \   \ /
;    \   o
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %exit, label %if

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  %then.varying = call i1 @varying(i32 %lane)
  br i1 %then.varying, label %bb1, label %bb2

if.else:
  br i1 %u.else, label %bb1, label %bb2

bb1:
  br label %if.end

bb2:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_10(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_10
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING2:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING2_NOT:%.*]] = not i1 [[VP_VARYING2]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: bb0
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB0_BR_VP_VARYING2_NOT:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_VARYING2_NOT]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_IF_BR_VP_UNIFORM]] i1 [[VP_BB0_BR_VP_VARYING2_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br if.end
; CHECK-EMPTY:
; CHECK-NEXT:    if.end: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = or i1 [[VP_VARYING_NOT]] i1 [[VP_BB0_BR_VP_VARYING2_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP4]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.end
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;     /  \
;    D    U
;    | \ /|
;    |  o |
;    |   \|
;    |    o
;    +   /
;     \ /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb0, label %if

bb0:
  %varying2 = call i1 @varying(i32 %lane)
  br i1 %varying2, label %exit, label %if.then

if:
  br i1 %uniform, label %if.then, label %if.end

if.then:
  br label %if.end

if.end:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_11(i1 %u0, i1 %u1) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_11
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_U0_NOT:%.*]] = not i1 [[U00:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if1
; CHECK-EMPTY:
; CHECK-NEXT:    if1: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if1
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF1_BR_VP_U1:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[U10:%.*]]
; CHECK-NEXT:     [DA: Uni] br if0
; CHECK-EMPTY:
; CHECK-NEXT:    if0: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: if0
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF0_BR_VP_U0_NOT:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_U0_NOT]]
; CHECK-NEXT:     [DA: Uni] br bb
; CHECK-EMPTY:
; CHECK-NEXT:    bb: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = or i1 [[VP_IF1_BR_VP_U1]] i1 [[VP_IF0_BR_VP_U0_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP2]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;      D
;     / \
;    U   U
;    |\ /|
;    + o +
;     \|/
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if0, label %if1

if0:
  br i1 %u0, label %exit, label %bb

if1:
  br i1 %u1, label %bb, label %exit

bb:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_12(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_12
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br if.else
; CHECK-EMPTY:
; CHECK-NEXT:    if.else: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: if.else
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br bb
; CHECK-EMPTY:
; CHECK-NEXT:    bb: # preds: if.then
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: bb
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;    / \
;   o   U
;   |  / \
;   +  o  o
;    \ | /
;      o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %bb, label %if

bb:
  br label %exit

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %exit

if.else:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_13(i1 %uniform) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_13
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br bb
; CHECK-EMPTY:
; CHECK-NEXT:    bb: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: bb
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_VARYING]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_UNIFORM:%.*]] = and i1 [[VP_VARYING]] i1 [[UNIFORM0]]
; CHECK-NEXT:     [DA: Uni] br if.else
; CHECK-EMPTY:
; CHECK-NEXT:    if.else: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Uni] br if.then
; CHECK-EMPTY:
; CHECK-NEXT:    if.then: # preds: if.else
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_IF_BR_VP_UNIFORM]]
; CHECK-NEXT:     [DA: Uni] br exit
; CHECK-EMPTY:
; CHECK-NEXT:    exit: # preds: if.then
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;     D
;    / \
;   U   o
;  / \  |
;  o  o +
;   \ |/
;     o

  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if, label %bb

bb:
  br label %exit

if:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %exit

if.else:
  br label %exit

exit:
  ret void
}

define void @uniform_br_under_outer_mask_14(i1 %u0, i1 %u1) {
; CHECK-LABEL:  VPlan IR for: uniform_br_under_outer_mask_14
; CHECK-NEXT:    entry: # preds:
; CHECK-NEXT:     [DA: Div] i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @varying
; CHECK-NEXT:     [DA: Div] i1 [[VP_VARYING_NOT:%.*]] = not i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br else
; CHECK-EMPTY:
; CHECK-NEXT:    else: # preds: entry
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_VARYING_NOT]]
; CHECK-NEXT:     [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: else
; CHECK-NEXT:     [DA: Div] i1 [[VP_ELSE_BR_VP_U1:%.*]] = and i1 [[VP_VARYING_NOT]] i1 [[U10:%.*]]
; CHECK-NEXT:     [DA: Uni] br bb1
; CHECK-EMPTY:
; CHECK-NEXT:    bb1: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_ELSE_BR_VP_U1]]
; CHECK-NEXT:     [DA: Uni] br if
; CHECK-EMPTY:
; CHECK-NEXT:    if: # preds: bb1
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_VARYING]]
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: if
; CHECK-NEXT:     [DA: Div] i1 [[VP_IF_BR_VP_U0:%.*]] = and i1 [[VP_VARYING]] i1 [[U00:%.*]]
; CHECK-NEXT:     [DA: Uni] br bb0
; CHECK-EMPTY:
; CHECK-NEXT:    bb0: # preds: [[BB1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_IF_BR_VP_U0]]
; CHECK-NEXT:     [DA: Uni] br merge
; CHECK-EMPTY:
; CHECK-NEXT:    merge: # preds: bb0
; CHECK-NEXT:     [DA: Div] ret
; CHECK-NEXT:     [DA: Uni] br <External Block>
;
entry:
;         D
;       /   \
;      U     U
;      |\   /|
;      o + o +
;       \| |/
;         o
  %lane = call i32 @llvm.vplan.laneid()
  %varying = call i1 @varying(i32 %lane)
  br i1 %varying, label %if, label %else

if:
  br i1 %u0, label %bb0, label %merge

bb0:
  br label %merge

else:
  br i1 %u1, label %bb1, label %merge

bb1:
  br label %merge

merge:
  ret void
}

declare i1 @varying(i32)
declare i32 @llvm.vplan.laneid()
declare i1 @allzero(i1) #0

attributes #0 = { "opencl-vec-uniform-return" }
