; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; RUN: opt -passes='hir-ssa-deconstruction,hir-vplan-vec' -vplan-force-vf=2 -vplan-enable-masked-variant=0 -vplan-print-after-predicator -disable-output < %s 2>&1 | FileCheck %s --check-prefixes=VPLAN
; RUN: opt -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -vplan-force-vf=2 -disable-output < %s 2>&1 | FileCheck %s --check-prefixes=HIR-CG

define void @foo(ptr %p, ptr %uniform.ptr) {
; VPLAN-LABEL:  VPlan after predicator:
; VPLAN-NEXT:  VPlan IR for: foo:HIR.#{{[0-9]+}}
; VPLAN-NEXT:  External Defs Start:
; VPLAN-DAG:     [[VP0:%.*]] = {%st}
; VPLAN-DAG:     [[VP1:%.*]] = {%blend}
; VPLAN-DAG:     [[VP2:%.*]] = {%uniform.ptr}
; VPLAN-DAG:     [[VP3:%.*]] = {%p}
; VPLAN-NEXT:  External Defs End:
; VPLAN-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; VPLAN-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB1]]: # preds: [[BB0]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; VPLAN-NEXT:     [DA: Div] i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-NEXT:     [DA: Uni] i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP4:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP5:%.*]], [[BB3]] ]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP6:%.*]] = hir-copy i64 -1 , OriginPhiId: -1
; VPLAN-NEXT:     [DA: Div] i1 [[VP7:%.*]] = icmp sgt i64 [[VP4]] i64 0
; VPLAN-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB4]]: # preds: [[BB2]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP7]]
; VPLAN-NEXT:     [DA: Uni] ptr [[VP_SUBSCRIPT_0:%.*]] = subscript inbounds ptr [[UNIFORM_PTR0:%.*]]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT_0]]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP9:%.*]] = icmp ne i1 [[VP_LOAD]] i1 false
; VPLAN-NEXT:     [DA: Uni] i1 [[VP__NOT:%.*]] = not i1 [[VP9]]
; VPLAN-NEXT:     [DA: Uni] br [[BB5:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB5]]: # preds: [[BB4]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP_BB4_BR_VP__NOT:%.*]] = select i1 [[VP7]] i1 [[VP__NOT]] i1 false
; VPLAN-NEXT:     [DA: Div] i1 [[VP_BB4_BR_:%.*]] = select i1 [[VP7]] i1 [[VP9]] i1 false
; VPLAN-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB6]]: # preds: [[BB5]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP10:%.*]] = block-predicate i1 [[VP_BB4_BR_VP__NOT]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP11:%.*]] = hir-copy i64 2 , OriginPhiId: -1
; VPLAN-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB7]]: # preds: [[BB6]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP12:%.*]] = block-predicate i1 [[VP_BB4_BR_]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP13:%.*]] = hir-copy i64 1 , OriginPhiId: -1
; VPLAN-NEXT:     [DA: Uni] br [[BB8:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB8]]: # preds: [[BB7]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP__BLEND_BB5:%.*]] = blend [ i64 [[VP11]], i1 [[VP_BB4_BR_VP__NOT]] ], [ i64 [[VP13]], i1 [[VP_BB4_BR_]] ]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP__ACTIVE:%.*]] = active-lane i1 [[VP7]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP__BLEND_BB5_ACTIVE:%.*]] = lane-extract i64 [[VP__BLEND_BB5]] i1 [[VP__ACTIVE]]
; VPLAN-NEXT:     [DA: Div] i1 [[VP14:%.*]] = block-predicate i1 [[VP7]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP15:%.*]] = add i64 [[VP__BLEND_BB5_ACTIVE]] i64 1
; VPLAN-NEXT:     [DA: Uni] i64 [[VP16:%.*]] = hir-copy i64 [[VP15]] , OriginPhiId: -1
; VPLAN-NEXT:     [DA: Uni] br [[BB3]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB3]]: # preds: [[BB8]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP__BLEND_BB7:%.*]] = blend [ i64 [[VP6]], i1 true ], [ i64 [[VP16]], i1 [[VP7]] ]
; VPLAN-NEXT:     [DA: Div] ptr [[VP_SUBSCRIPT:%.*]] = subscript ptr [[P0:%.*]] i64 [[VP4]]
; VPLAN-NEXT:     [DA: Div] store i64 [[VP__BLEND_BB7]] ptr [[VP_SUBSCRIPT]]
; VPLAN-NEXT:     [DA: Div] i64 [[VP5]] = add i64 [[VP4]] i64 [[VP__IND_INIT_STEP]]
; VPLAN-NEXT:     [DA: Uni] i1 [[VP17:%.*]] = icmp slt i64 [[VP5]] i64 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-NEXT:     [DA: Uni] br i1 [[VP17]], [[BB2]], [[BB9:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB9]]: # preds: [[BB3]]
; VPLAN-NEXT:     [DA: Uni] i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; VPLAN-NEXT:     [DA: Uni] br [[BB10:BB[0-9]+]]
; VPLAN-EMPTY:
; VPLAN-NEXT:    [[BB10]]: # preds: [[BB9]]
; VPLAN-NEXT:     [DA: Uni] br <External Block>
; VPLAN-EMPTY:
; VPLAN-NEXT:  External Uses:
; VPLAN-NEXT:  Id: 0   no underlying for i64 [[VP__IND_FINAL]]
;
; HIR-CG-LABEL:  Function: foo
; HIR-CG-EMPTY:
; HIR-CG-NEXT:  BEGIN REGION { modified }
; HIR-CG-NEXT:        + DO i1 = 0, 1023, 2   <DO_LOOP> <simd-vectorized> <novectorize>
; HIR-CG-NEXT:        |   [[DOTCOPY0:%.*]] = -1
; HIR-CG-NEXT:        |   [[DOTVEC0:%.*]] = i1 + <i64 0, i64 1> > 0
; HIR-CG-NEXT:        |   [[TMP0:%.*]] = bitcast.<2 x i1>.i2([[DOTVEC0]])
; HIR-CG-NEXT:        |   [[CMP0:%.*]] = [[TMP0]] != 0
; HIR-CG-NEXT:        |   [[DOTUNIFLOAD0:%.*]] = undef
; HIR-CG-NEXT:        |   if ([[CMP0]] == 1)
; HIR-CG-NEXT:        |   {
; HIR-CG-NEXT:        |      [[DOTUNIFLOAD0]] = ([[UNIFORM_PTR0:%.*]])[0]
; HIR-CG-NEXT:        |   }
; HIR-CG-NEXT:        |   [[DOTVEC40:%.*]] = [[DOTUNIFLOAD0]] != 0
; HIR-CG-NEXT:        |   [[DOTVEC50:%.*]] = [[DOTVEC40]]  ^  -1
; HIR-CG-NEXT:        |   [[DOTVEC60:%.*]] = (i1 + <i64 0, i64 1> > 0) ?  [[DOTVEC50]] : 0
; HIR-CG-NEXT:        |   [[DOTVEC70:%.*]] = (i1 + <i64 0, i64 1> > 0) ?  [[DOTVEC40]] : 0
; HIR-CG-NEXT:        |   [[DOTCOPY80:%.*]] = 2
; HIR-CG-NEXT:        |   [[DOTCOPY90:%.*]] = 1
; HIR-CG-NEXT:        |   [[SELECT0:%.*]] = ([[DOTVEC70]] == <i1 true, i1 true>) ? [[DOTCOPY90]] : [[DOTCOPY80]]
; HIR-CG-NEXT:        |   [[BSFINTMASK0:%.*]] = bitcast.<2 x i1>.i2([[DOTVEC0]])
; HIR-CG-NEXT:        |   [[BSF0:%.*]] = @llvm.cttz.i2([[BSFINTMASK0]],  0)
; HIR-CG-NEXT:        |   [[ACTIVE_LN_EXTRACT0:%.*]] = extractelement [[SELECT0]],  [[BSF0]]
; HIR-CG-NEXT:        |   [[DOTCOPY100:%.*]] = [[ACTIVE_LN_EXTRACT0]] + 1
; HIR-CG-NEXT:        |   [[SELECT110:%.*]] = ([[DOTVEC0]] == <i1 true, i1 true>) ? [[DOTCOPY100]] : [[DOTCOPY0]]
; HIR-CG-NEXT:        |   (<2 x i64>*)([[P0:%.*]])[i1] = [[SELECT110]]
; HIR-CG-NEXT:        + END LOOP
; HIR-CG:             ret
; HIR-CG-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cond = icmp sgt i64 %iv, 0
  br i1 %cond, label %uni.start, label %latch

uni.start:
  %uniform = load i1, ptr %uniform.ptr
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %if.end

if.else:
  br label %if.end

if.end:
  %blend = phi i64 [ 1, %if.then ], [ 2, %if.else]
  %val = add nsw nuw i64 %blend, 1
  br label %uni.end

uni.end:
  br label %latch

latch:
  %st = phi i64 [ -1, %header ], [ %val, %uni.end]
  %gep = getelementptr i64, ptr %p, i64 %iv
  store i64 %st, ptr %gep
  %iv.next = add nsw nuw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 1024
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)
