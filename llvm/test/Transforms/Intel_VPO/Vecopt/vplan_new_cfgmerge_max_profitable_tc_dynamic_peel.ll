; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2

; This test checks that we truncate the computed value for minimum profitable
; peel count when `-vplan-max-profitable-dyn-peel-multiplier` is non-zero.

target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "x86_64-unknown-linux-gnu"

; RUN: opt < %s -disable-output -passes=vplan-vec \
; RUN:     -vplan-force-vf=8 -vplan-force-uf=1 -mattr=+avx512f \
; RUN:     -vplan-enable-vectorized-peel=false -vplan-enable-peeling \
; RUN:     -vplan-force-dyn-alignment -vplan-calc-min-profitable-dyn-peel-tc \
; RUN:     -vplan-max-profitable-dyn-peel-multiplier=2 \
; RUN:     -vplan-print-after-cfg-merge \
; RUN:     -debug-only=LoopVectorizationPlanner,LoopVectorizationPlanner_peel_tc 2>&1 \
; RUN:     | FileCheck %s --check-prefixes=CHECK,LLVM,SCA-PEEL

; RUN: opt < %s -disable-output -passes=hir-ssa-deconstruction,hir-vplan-vec \
; RUN:     -vplan-force-vf=8 -vplan-force-uf=1 -mattr=+avx512f \
; RUN:     -vplan-enable-vectorized-peel=false -vplan-enable-peeling \
; RUN:     -vplan-force-dyn-alignment -vplan-calc-min-profitable-dyn-peel-tc \
; RUN:     -vplan-max-profitable-dyn-peel-multiplier=2 \
; RUN:     -vplan-print-after-cfg-merge \
; RUN:     -debug-only=LoopVectorizationPlanner,LoopVectorizationPlanner_peel_tc 2>&1 \
; RUN:     | FileCheck %s --check-prefixes=CHECK,HIR,SCA-PEEL

; RUN: opt < %s -disable-output -passes=vplan-vec \
; RUN:     -vplan-force-vf=8 -vplan-force-uf=1 -mattr=+avx512f \
; RUN:     -vplan-enable-vectorized-peel=true -vplan-enable-peeling \
; RUN:     -vplan-force-dyn-alignment -vplan-calc-min-profitable-dyn-peel-tc \
; RUN:     -vplan-max-profitable-dyn-peel-multiplier=2 \
; RUN:     -vplan-print-after-cfg-merge \
; RUN:     -debug-only=LoopVectorizationPlanner,LoopVectorizationPlanner_peel_tc 2>&1 \
; RUN:     | FileCheck %s --check-prefixes=CHECK,LLVM,VEC-PEEL

; RUN: opt < %s -disable-output -passes=hir-ssa-deconstruction,hir-vplan-vec \
; RUN:     -vplan-force-vf=8 -vplan-force-uf=1 -mattr=+avx512f \
; RUN:     -vplan-enable-vectorized-peel=true -vplan-enable-peeling \
; RUN:     -vplan-force-dyn-alignment -vplan-calc-min-profitable-dyn-peel-tc \
; RUN:     -vplan-max-profitable-dyn-peel-multiplier=2 \
; RUN:     -vplan-print-after-cfg-merge \
; RUN:     -debug-only=LoopVectorizationPlanner,LoopVectorizationPlanner_peel_tc 2>&1 \
; RUN:     | FileCheck %s --check-prefixes=CHECK,HIR,VEC-PEEL

define void @test(ptr %A, i64 %N) {
; LLVM-LABEL:  Selecting VF for VPlan test:for.body.#{{[0-9]+}}
; HIR-LABEL:   Selecting VF for VPlan test:HIR.#{{[0-9]+}}
; CHECK:         Selected peeling: Dynamic
; SCA-PEEL:      Peel loop cost = {{[0-9]+}} (scalar peel loop)
; VEC-PEEL:      Peel loop cost = {{[0-9]+}} (masked vector peel loop)
; CHECK:         (VF = 8, UF = 1) min profitable peel tc = [[TC:[0-9]+]]
; CHECK:         Truncating min profitable peel tc to 16
; CHECK:         Peeling will be performed.
; CHECK:         Using min profitable peel TC: 16
; CHECK:       Selecting VPlan with VF=8
; CHECK-LABEL: VPlan after CFG merge before CG:
; LLVM-NEXT:   VPlan IR for: test:for.body.#{{[0-9]+}}
; HIR-NEXT:    VPlan IR for: Initial VPlan for VF=8
; CHECK:         [[PEEL_CHECK_TC0:peel.check.tc[0-9]+]]: # preds:
; CHECK:           [DA: Uni] pushvf VF=8 UF=1
; CHECK-NEXT:      [DA: Uni] i1 [[VP0:%.*]] = icmp ult i64 {{.*}} i64 16
; CHECK-NEXT:      [DA: Uni] br i1 [[VP0]], [[MERGE_BLK0:merge.blk[0-9]+]], [[PEEL_CHECKZ0:peel.checkz[0-9]+]]
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %ptr = getelementptr inbounds i64, ptr %A, i64 %indvars.iv
  %elem = load i64, ptr %ptr, align 8
  %add = add nsw nuw i64 %elem, 10
  store i64 %add, ptr %ptr, align 8
  store i64 %add, ptr %ptr, align 8
  store i64 %add, ptr %ptr, align 8
  store i64 %add, ptr %ptr, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %N
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #0

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #0

attributes #0 = { nounwind }
