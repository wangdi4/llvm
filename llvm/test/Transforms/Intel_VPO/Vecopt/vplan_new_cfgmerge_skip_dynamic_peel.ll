; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2
;
; This test checks that we emit a trip count check to skip the peel loop when
; `-vplan-skip-dynamic-peel-tc` is set to a non-zero value, and the peel kind
; is dynamic.

; RUN: opt -disable-output < %s -passes=vplan-vec -vplan-enable-peeling=true \
; RUN:     -vplan-vec-scenario='s4;v4;s4' -vplan-print-after-merge-skeleton \
; RUN:     -vplan-skip-dynamic-peel-tc=1200 2>&1 | FileCheck %s --check-prefix=DYN-PEEL
; RUN: opt -disable-output < %s -passes=vplan-vec -vplan-enable-peeling=true \
; RUN:     -vplan-vec-scenario='m4;v4;m4' -vplan-print-after-merge-skeleton \
; RUN:     -vplan-skip-dynamic-peel-tc=1200 2>&1 | FileCheck %s --check-prefix=DYN-PEEL

; RUN: opt -disable-output < %s -passes=vplan-vec -vplan-enable-peeling=false \
; RUN:     -vplan-vec-scenario='s4;v4;s4' -vplan-print-after-merge-skeleton \
; RUN:     -vplan-skip-dynamic-peel-tc=1200 2>&1 | FileCheck %s --check-prefix=STA-PEEL
; RUN: opt -disable-output < %s -passes=vplan-vec -vplan-enable-peeling=false \
; RUN:     -vplan-vec-scenario='m4;v4;m4' -vplan-print-after-merge-skeleton \
; RUN:     -vplan-skip-dynamic-peel-tc=1200 2>&1 | FileCheck %s --check-prefix=STA-PEEL

target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "x86_64-unknown-linux-gnu"

define void @test(ptr %A, i64 %N) {
; DYN-PEEL-LABEL: VPlan after merge skeleton creation:
; DYN-PEEL-NEXT:  VPlan IR for: test:for.body.#{{[0-9]+}}
; DYN-PEEL-NEXT:    [[PEEL_CHECK_TC0:peel.check.tc[0-9]+]]: # preds:
; DYN-PEEL-NEXT:     [DA: Uni] pushvf VF=4 UF=1
; DYN-PEEL-NEXT:     [DA: Uni] i1 [[VP0:%.*]] = icmp ult i64 [[N0:%.*]] i64 1200
; DYN-PEEL-NEXT:     [DA: Uni] br i1 [[VP0]], [[MERGE_BLK0:merge.blk[0-9]+]], [[PEEL_CHECKZ0:peel.checkz[0-9]+]]
; DYN-PEEL-EMPTY:
; DYN-PEEL-NEXT:      [[PEEL_CHECKZ0]]: # preds: [[PEEL_CHECK_TC0]]
; DYN-PEEL-NEXT:       [DA: Uni] ptr [[VP_PEEL_BASE_PTR:%.*]] = inv-scev-wrapper{ [[A0:%.*]] }
; DYN-PEEL-NEXT:       [DA: Uni] i64 [[VP_BASEPTR_INT:%.*]] = ptrtoint ptr [[VP_PEEL_BASE_PTR]] to i64
; DYN-PEEL-NEXT:       [DA: Uni] i64 [[VP_QUOTIENT:%.*]] = udiv i64 [[VP_BASEPTR_INT]] i64 8
; DYN-PEEL-NEXT:       [DA: Uni] i64 [[VP_QMULTIPLIER:%.*]] = mul i64 [[VP_QUOTIENT]] i64 3
; DYN-PEEL-NEXT:       [DA: Uni] i64 [[VP_PEEL_COUNT:%.*]] = urem i64 [[VP_QMULTIPLIER]] i64 4
; DYN-PEEL-NEXT:       [DA: Uni] i1 [[VP_PEEL_ZERO_CHECK:%.*]] = icmp eq i64 0 i64 [[VP_PEEL_COUNT]]
; DYN-PEEL-NEXT:       [DA: Uni] br i1 [[VP_PEEL_ZERO_CHECK]], [[MERGE_BLK0]], [[PEEL_CHECKV0:peel.checkv[0-9]+]]
; DYN-PEEL-EMPTY:
; DYN-PEEL-NEXT:      [[PEEL_CHECKV0]]: # preds: [[PEEL_CHECKZ0]]
; DYN-PEEL-NEXT:       [DA: Uni] i64 [[VP1:%.*]] = add i64 [[VP_PEEL_COUNT]] i64 4
; DYN-PEEL-NEXT:       [DA: Uni] i1 [[VP_PEEL_VEC_TC_CHECK:%.*]] = icmp ugt i64 [[VP1]] i64 [[N0]]
; DYN-PEEL-NEXT:       [DA: Uni] br i1 [[VP_PEEL_VEC_TC_CHECK]], [[MERGE_BLK1:merge.blk[0-9]+]], [[BB0:BB[0-9]+]]
; DYN-PEEL-EMPTY:
; DYN-PEEL-NEXT:        [[BB0]]: # preds: [[PEEL_CHECKV0]]
; DYN-PEEL-NEXT:         [DA: Uni] token [[VP_VPLAN_PEEL_ADAPTER:%.*]] = vplan-peel-adapter for VPlan {test:for.body.#{{[0-9]+}}{{.*}}}
; DYN-PEEL-NEXT:         [DA: Uni] br [[MERGE_BLK0]]
; DYN-PEEL-EMPTY:
; DYN-PEEL-NEXT:      [[MERGE_BLK0]]: # preds: [[BB0]], [[PEEL_CHECKZ0]], [[PEEL_CHECK_TC0]]
; DYN-PEEL-NEXT:       [DA: Uni] i64 [[VP2:%.*]] = phi-merge  [ i64 0, [[PEEL_CHECKZ0]] ],  [ i64 0, [[PEEL_CHECK_TC0]] ],  [ token [[VP_VPLAN_PEEL_ADAPTER]], [[BB0]] ]
; DYN-PEEL-NEXT:       [DA: Uni] br [[BB1:BB[0-9]+]]
;
; STA-PEEL-LABEL: VPlan after merge skeleton creation:
; STA-PEEL-NEXT:  VPlan IR for: test:for.body.#{{[0-9]+}}
; STA-PEEL-NEXT:    [[PEEL_CHECKZ0:peel.checkz[0-9]+]]: # preds:
; STA-PEEL-NEXT:     [DA: Uni] pushvf VF=4 UF=1
; STA-PEEL-NEXT:     [DA: Uni] br [[PEEL_CHECKV0:peel.checkv[0-9]+]]
; STA-PEEL-EMPTY:
; STA-PEEL-NEXT:    [[PEEL_CHECKV0]]: # preds: [[PEEL_CHECKZ0]]
; STA-PEEL-NEXT:     [DA: Uni] i64 [[VP0:%.*]] = add i64 1 i64 4
; STA-PEEL-NEXT:     [DA: Uni] i1 [[VP_PEEL_VEC_TC_CHECK:%.*]] = icmp ugt i64 [[VP0]] i64 [[N0:%.*]]
; STA-PEEL-NEXT:     [DA: Uni] br i1 [[VP_PEEL_VEC_TC_CHECK]], [[MERGE_BLK0:merge.blk[0-9]+]], [[BB0:BB[0-9]+]]
; STA-PEEL-EMPTY:
; STA-PEEL-NEXT:      [[BB0]]: # preds: [[PEEL_CHECKV0]]
; STA-PEEL-NEXT:       [DA: Uni] token [[VP_VPLAN_PEEL_ADAPTER:%.*]] = vplan-peel-adapter for VPlan {test:for.body.#{{[0-9]+}}{{.*}}}
; STA-PEEL-NEXT:       [DA: Uni] br [[MERGE_BLK1:merge.blk[0-9]+]]
; STA-PEEL-EMPTY:
; STA-PEEL-NEXT:      [[MERGE_BLK1]]: # preds: [[BB0]]
; STA-PEEL-NEXT:       [DA: Uni] i64 [[VP1:%.*]] = phi-merge  [ token [[VP_VPLAN_PEEL_ADAPTER]], [[BB0]] ]
; STA-PEEL-NEXT:       [DA: Uni] br [[BB1:BB[0-9]+]]
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %ptr = getelementptr inbounds i64, ptr %A, i64 %indvars.iv
  store i64 0, ptr %ptr, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %N
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #0

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #0

attributes #0 = { nounwind }
