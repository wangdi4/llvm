; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to verify that redundant PHIs that blend same incoming values along all
; edges are removed by VPlan HIR decomposer. These are emitted due to
; inaccuracies in HIR's DDG edge information.

; Incoming HIR
; <0>          BEGIN REGION { }
; <51>               %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
; <50>
; <50>               + DO i1 = 0, 99, 1   <DO_LOOP> <ivdep>
; <19>               |   %fetch.6269 = null;
; <20>               |   if (%cond1 != 0)
; <20>               |   {
; <26>               |      %fetch.6269 = null;
; <20>               |   }
; <33>               |   if (%cond2 != 0)
; <33>               |   {
; <37>               |      (null)[0] = 0;
; <33>               |   }
; <42>               |   %"fetch.6279[][]_fetch.6288" = (%fetch.6269)[0];
; <50>               + END LOOP
; <50>
; <52>               @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
; <0>          END REGION

; For this example, DDG reports that there are 2 reaching definitions for %fetch.6269
; in node <42>. However both reach definitions are the same "null" values and this
; redundant PHI can be removed and replaced.

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-plain-cfg -disable-vplan-codegen -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-plain-cfg -disable-vplan-codegen -disable-output < %s 2>&1 | FileCheck %s

define void @foo(i1 %cond1, i1 %cond2) #2 {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: foo:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {if (%cond1 != 0)}
; CHECK-DAG:     [[VP1:%.*]] = {%fetch.6269}
; CHECK-DAG:     [[VP2:%.*]] = {if (%cond2 != 0)}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP3:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP4:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32* [[VP5:%.*]] = hir-copy i32* null , OriginPhiId: -1
; CHECK-NEXT:     br i1 [[VP0]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       i32* [[VP6:%.*]] = hir-copy i32* null , OriginPhiId: -1
; CHECK-NEXT:       br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]], [[BB2]]
; CHECK-NEXT:     i32* [[VP7:%.*]] = phi  [ i32* [[VP6]], [[BB4]] ],  [ i32* [[VP5]], [[BB2]] ]
; CHECK-NEXT:     br i1 [[VP2]], [[BB6:BB[0-9]+]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:       store i32 0 i32* null
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB6]], [[BB5]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP7]]
; CHECK-NEXT:     i64 [[VP4]] = add i64 [[VP3]] i64 1
; CHECK-NEXT:     i1 [[VP8:%.*]] = icmp slt i64 [[VP4]] i64 100
; CHECK-NEXT:     br i1 [[VP8]], [[BB2]], [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     br <External Block>
;
newFuncRoot:
  br label %bb925

bb925:                                            ; preds = %newFuncRoot
  br label %bb929.preheader

bb929.preheader:                                  ; preds = %bb925
  br label %bb929

bb929:                                            ; preds = %bb960_endif, %bb929.preheader
  %indvars.iv17000 = phi i64 [ 0, %bb929.preheader ], [ %indvars.iv.next17001, %bb960_endif ]
  %indvars.iv.next17001 = add nsw i64 %indvars.iv17000, 1
  br label %bb_new1628_else

bb_new1628_else:                                  ; preds = %bb929
  br label %bb935_endif

bb935_endif:                                      ; preds = %bb_new1628_else
  br label %bb_new1633_then

bb_new1633_then:                                  ; preds = %bb935_endif
  br label %bb938_endif

bb938_endif:                                      ; preds = %bb_new1633_then
  br label %bb_new1645_else

bb_new1645_else:                                  ; preds = %bb938_endif
  br label %bb941_endif

bb941_endif:                                      ; preds = %bb_new1645_else
  br label %bb_new1655_else

bb_new1655_else:                                  ; preds = %bb941_endif
  br label %bb944_endif

bb944_endif:                                      ; preds = %bb_new1655_else
  br i1 %cond1, label %bb_new1661_then, label %bb950_endif

bb_new1661_then:                                  ; preds = %bb944_endif
  br label %bb946_endif

bb946_endif:                                      ; preds = %bb_new1661_then
  br label %bb950_endif

bb950_endif:                                      ; preds = %bb946_endif, %bb944_endif
  %fetch.6269 = phi i32* [ null, %bb944_endif ], [ null, %bb946_endif ]
  br label %bb950_endif.bb956_endif_crit_edge

bb950_endif.bb956_endif_crit_edge:                ; preds = %bb950_endif
  br label %bb956_endif

bb956_endif:                                      ; preds = %bb950_endif.bb956_endif_crit_edge
  br i1 %cond2, label %bb_new1673_then, label %bb958_endif

bb_new1673_then:                                  ; preds = %bb956_endif
  store i32 0, i32* null, align 1
  br label %bb958_endif

bb958_endif:                                      ; preds = %bb_new1673_then, %bb956_endif
  %"fetch.6279[]" = tail call i32* @llvm.intel.subscript.p0i32.i64.i64.p0i32.i64(i8 0, i64 0, i64 0, i32* nonnull elementtype(i32) null, i64 0)
  %"fetch.6279[][]" = tail call i32* @llvm.intel.subscript.p0i32.i64.i64.p0i32.i64(i8 0, i64 0, i64 0, i32* elementtype(i32) null, i64 0)
  %"fetch.6279[][]_fetch.6288" = load i32, i32* %fetch.6269, align 1
  br label %bb960_endif

bb960_endif:                                      ; preds = %bb958_endif
  %exitcond17006 = icmp eq i64 %indvars.iv.next17001, 100
  br i1 %exitcond17006, label %bb930.loopexit, label %bb929, !llvm.loop !0

bb930.loopexit:                                   ; preds = %bb960_endif
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i32* @llvm.intel.subscript.p0i32.i64.i64.p0i32.i64(i8, i64, i64, i32*, i64) #0

!0 = distinct !{!0, !1}
!1 = !{!"llvm.loop.vectorize.ivdep_back"}
