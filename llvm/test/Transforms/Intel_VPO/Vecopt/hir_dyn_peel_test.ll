; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -disable-output -print-after=hir-vplan-vec  -vplan-force-vf=4 -vplan-enable-new-cfg-merge-hir -vplan-print-after-cfg-merge -hir-details < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -disable-output -vplan-force-vf=4  -vplan-enable-new-cfg-merge-hir -vplan-print-after-cfg-merge -hir-details < %s 2>&1 | FileCheck %s
;
; LIT test to check dynamic peeling in VPlan HIR path.
;
define void @foo(i64* %lp, i64 %n1) {
; CHECK-LABEL:  VPlan after CFG merge before CG:
; CHECK-NEXT:  VPlan IR for: Initial VPlan for VF=4
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%n1 + -1}
; CHECK-DAG:     [[VP1:%.*]] = {%lp}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[PEEL_CHECKZ0:peel.checkz[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i64 [[VP2:%.*]] = add i64 [[VP0]] i64 1
; CHECK-NEXT:     [DA: Uni] pushvf VF=4 UF=1
; CHECK-NEXT:     [DA: Uni] i64* [[VP_PEEL_BASE_PTR:%.*]] = inv-scev-wrapper{([[LP0:%.*]]),+,0}
; CHECK-NEXT:     [DA: Uni] i64 [[VP_BASEPTR_INT:%.*]] = ptrtoint i64* [[VP_PEEL_BASE_PTR]] to i64
; CHECK-NEXT:     [DA: Uni] i64 [[VP_QUOTIENT:%.*]] = udiv i64 [[VP_BASEPTR_INT]] i64 8
; CHECK-NEXT:     [DA: Uni] i64 [[VP_QMULTIPLIER:%.*]] = mul i64 [[VP_QUOTIENT]] i64 3
; CHECK-NEXT:     [DA: Uni] i64 [[VP_PEEL_COUNT:%.*]] = urem i64 [[VP_QMULTIPLIER]] i64 4
; CHECK-NEXT:     [DA: Uni] i1 [[VP_PEEL_ZERO_CHECK:%.*]] = icmp eq i64 0 i64 [[VP_PEEL_COUNT]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_PEEL_ZERO_CHECK]], [[MERGE_BLK0:merge.blk[0-9]+]], [[PEEL_CHECKV0:peel.checkv[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[PEEL_CHECKV0]]: # preds: [[PEEL_CHECKZ0]]
; CHECK-NEXT:       [DA: Uni] i64 [[VP3:%.*]] = add i64 [[VP_PEEL_COUNT]] i64 4
; CHECK-NEXT:       [DA: Uni] i1 [[VP_PEEL_VEC_TC_CHECK:%.*]] = icmp ugt i64 [[VP3]] i64 [[VP2]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_PEEL_VEC_TC_CHECK]], [[MERGE_BLK1:merge.blk[0-9]+]], [[PEELBLK0:PeelBlk[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[PEELBLK0]]: # preds: [[PEEL_CHECKV0]]
; CHECK-NEXT:         [DA: Uni] pushvf VF=1 UF=1
; CHECK-NEXT:         [DA: Uni] token [[VP_ORIG_LOOP:%.*]] = scalar-peel-hir <HLLoop>, NeedsCloning: 1, TempInitMap:
; CHECK-NEXT:         { Initialize temp [[UB_TMP0:%.*]] with -> i64 [[VP_PEEL_COUNT]] }
; CHECK-NEXT:         [DA: Uni] i64 [[VP_ORIG_LIVEOUT:%.*]] = orig-live-out-hir token [[VP_ORIG_LOOP]], liveout: [[UB_TMP0]]
; CHECK-NEXT:         [DA: Uni] br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB0]]: # preds: [[PEELBLK0]]
; CHECK-NEXT:         [DA: Uni] popvf
; CHECK-NEXT:         [DA: Uni] br [[MERGE_BLK0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[MERGE_BLK0]]: # preds: [[PEEL_CHECKZ0]], [[BB0]]
; CHECK-NEXT:       [DA: Uni] i64 [[VP4:%.*]] = phi-merge  [ i64 0, [[PEEL_CHECKZ0]] ],  [ i64 [[VP_ORIG_LIVEOUT]], [[BB0]] ]
; CHECK-NEXT:       [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB1]]: # preds: [[MERGE_BLK0]]
; CHECK-NEXT:       [DA: Uni] i64 [[VP5:%.*]] = add i64 [[VP_PEEL_COUNT]] i64 4
; CHECK-NEXT:       [DA: Uni] i1 [[VP_PEEL_VEC_TC_CHECK_1:%.*]] = icmp ugt i64 [[VP5]] i64 [[VP2]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_PEEL_VEC_TC_CHECK_1]], [[MERGE_BLK1]], [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       [DA: Uni] pushvf VF=4 UF=1
; CHECK-NEXT:       [DA: Uni] br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP2]] i64 [[VP_PEEL_COUNT]], UF = 1
; CHECK-NEXT:       [DA: Div] i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 [[VP4]] i64 1
; CHECK-NEXT:       [DA: Uni] i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:       [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB3]], [[BB4]]
; CHECK-NEXT:       [DA: Div] i64 [[VP6:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB3]] ],  [ i64 [[VP7:%.*]], [[BB4]] ]
; CHECK-NEXT:       [DA: Div] i64* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i64* [[LP0]] i64 [[VP6]]
; CHECK-NEXT:       [DA: Div] store i64 [[VP6]] i64* [[VP_SUBSCRIPT]]
; CHECK-NEXT:       [DA: Div] i64 [[VP7]] = add i64 [[VP6]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:       [DA: Uni] i1 [[VP8:%.*]] = icmp slt i64 [[VP7]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP8]], [[BB4]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:       [DA: Uni] i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:       [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:       [DA: Uni] popvf
; CHECK-NEXT:       [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:       [DA: Uni] i1 [[VP_REMTC_CHECK:%.*]] = icmp eq i64 [[VP2]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_REMTC_CHECK]], final.merge, [[MERGE_BLK1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[MERGE_BLK1]]: # preds: [[BB7]], [[PEEL_CHECKV0]], [[BB1]]
; CHECK-NEXT:       [DA: Uni] i64 [[VP9:%.*]] = phi-merge  [ i64 live-out0, [[BB7]] ],  [ i64 0, [[PEEL_CHECKV0]] ],  [ i64 [[VP4]], [[BB1]] ]
; CHECK-NEXT:       [DA: Uni] br [[REMBLK0:RemBlk[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[REMBLK0]]: # preds: [[MERGE_BLK1]]
; CHECK-NEXT:       [DA: Uni] pushvf VF=1 UF=1
; CHECK-NEXT:       [DA: Uni] token [[VP_ORIG_LOOP_1:%.*]] = scalar-remainder-hir <HLLoop>, NeedsCloning: 0, TempInitMap:
; CHECK-NEXT:         { Initialize temp [[LB_TMP0:%.*]] with -> i64 [[VP9]] }
; CHECK-NEXT:       [DA: Uni] i64 [[VP_ORIG_LIVEOUT_1:%.*]] = orig-live-out-hir token [[VP_ORIG_LOOP_1]], liveout: [[N10:%.*]] + -1
; CHECK-NEXT:       [DA: Uni] br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[REMBLK0]]
; CHECK-NEXT:       [DA: Uni] popvf
; CHECK-NEXT:       [DA: Uni] br final.merge
; CHECK-EMPTY:
; CHECK-NEXT:    final.merge: # preds: [[BB7]], [[BB8]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP10:%.*]] = phi-merge  [ i64 [[VP_ORIG_LIVEOUT_1]], [[BB8]] ],  [ i64 live-out0, [[BB7]] ]
; CHECK-NEXT:     [DA: Uni] popvf
; CHECK-NEXT:     [DA: Uni] br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i64 [[VP__IND_FINAL]]
;
; CHECK:        BEGIN REGION { modified }
; CHECK:              %.vec = ptrtoint.<4 x i64*>.<4 x i64>(%lp);
; CHECK:              %.vec1 = %.vec  /u  8;
; CHECK:              %.vec2 = %.vec1  *  3;
; CHECK:              %.vec3 = %.vec2  %u  4;
; CHECK:              %.vec4 = 0 == %.vec3;
; CHECK:              %phi.temp = 0;
; CHECK:              %extract.0. = extractelement %.vec4,  0;
; CHECK:              if (%extract.0. == 1)
; CHECK:              {
; CHECK:                 goto merge.blk14.23;
; CHECK:              }
; CHECK:              %.vec5 = %.vec3 + 4 >u %n1;
; CHECK:              %phi.temp6 = 0;
; CHECK:              %extract.0.8 = extractelement %.vec5,  0;
; CHECK:              if (%extract.0.8 == 1)
; CHECK:              {
; CHECK:                 goto merge.blk12.31;
; CHECK:              }
; CHECK:              %extract.0.9 = extractelement %.vec3,  0;
; CHECK:              %ub.tmp = %extract.0.9;
; CHECK:              %peel.ub = %ub.tmp  -  1;

; CHECK:              + DO i64 i1 = 0, %peel.ub, 1   <DO_LOOP>
; CHECK:              |   (%lp)[i1] = i1;
; CHECK:              + END LOOP

; CHECK:              %phi.temp = %ub.tmp;
; CHECK:              merge.blk14.23:
; CHECK:              %.vec11 = %.vec3 + 4 >u %n1;
; CHECK:              %phi.temp6 = %phi.temp;
; CHECK:              %extract.0.13 = extractelement %.vec11,  0;
; CHECK:              if (%extract.0.13 == 1)
; CHECK:              {
; CHECK:                 goto merge.blk12.31;
; CHECK:              }
; CHECK:              %tgu = %n1  /u  4;
; CHECK:              %vec.tc = %tgu  *  4;

; CHECK:              + DO i64 i1 = %phi.temp, %vec.tc + -1, 4   <DO_LOOP> <auto-vectorized> <nounroll> <novectorize>
; CHECK:              |   (<4 x i64>*)(%lp)[i1] = i1 + <i64 0, i64 1, i64 2, i64 3>;
; Fixme: Expect store to be marked with !intel.preferred_alignment
; CHECK:              |   <LVAL-REG> {al:8}(<4 x i64>*)(LINEAR i64* %lp)[LINEAR i64 i1] inbounds  !tbaa {{.*}}
; CHECK:              + END LOOP

; CHECK:              %.vec14 = %n1 == %vec.tc;
; CHECK:              %phi.temp6 = %vec.tc;
; CHECK:              %phi.temp16 = %vec.tc;
; CHECK:              %extract.0.18 = extractelement %.vec14,  0;
; CHECK:              if (%extract.0.18 == 1)
; CHECK:              {
; CHECK:                 goto final.merge.69;
; CHECK:              }
; CHECK:              merge.blk12.31:
; CHECK:              %lb.tmp = %phi.temp6;

; CHECK:              + DO i64 i1 = %lb.tmp, %n1 + -1, 1   <DO_LOOP>
; CHECK:              |   (%lp)[i1] = i1;
; CHECK:              + END LOOP

; CHECK:              %phi.temp16 = %n1 + -1;
; CHECK:              final.merge.69:
; CHECK:        END REGION
;
entry:
  %cmp5 = icmp sgt i64 %n1, 0
  br i1 %cmp5, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %l1.06 = phi i64 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds i64, i64* %lp, i64 %l1.06
  store i64 %l1.06, i64* %arrayidx, align 8, !tbaa !3
  %inc = add nuw nsw i64 %l1.06, 1
  %exitcond.not = icmp eq i64 %inc, %n1
  br i1 %exitcond.not, label %for.end.loopexit, label %for.body, !llvm.loop !7

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  ret void
}

attributes #0 = { nofree norecurse nosync nounwind writeonly uwtable "approx-func-fp-math"="true" "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "frame-pointer"="none" "loopopt-pipeline"="full" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "pre_loopopt" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+avx,+avx2,+bmi,+bmi2,+crc32,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" "unsafe-fp-math"="true" }

!llvm.module.flags = !{!0, !1}
!llvm.ident = !{!2}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!2 = !{!"Intel(R) oneAPI DPC++/C++ Compiler 2022.1.0 (2022.x.0.YYYYMMDD)"}
!3 = !{!4, !4, i64 0}
!4 = !{!"long", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = distinct !{!7, !8, !9}
!8 = !{!"llvm.loop.mustprogress"}
!9 = !{!"llvm.loop.intel.vector.dynamic_align", !"true"}
