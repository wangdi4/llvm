; INTEL_FEATURE_SW_ADVANCED
; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: intel_feature_sw_advanced
; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec \
; RUN:     -mtriple=x86_64-unknown-unknown -mcpu=skx \
; RUN:     -enable-intel-advanced-opts \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=8 \
; RUN:     | FileCheck %s --check-prefix=VPLAN-HIR-CM-VF8

; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec \
; RUN:     -mtriple=x86_64-unknown-unknown -mcpu=skx \
; RUN:     -vplan-cm-gather-scatter-threshold=93 -enable-intel-advanced-opts \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=8 \
; RUN:     | FileCheck %s --check-prefix=VPLAN-HIR-CM-VF8-GS93

@arr.i32.0 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.1 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.2 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.3 = external local_unnamed_addr global [1024 x i32], align 16

define void @test_fit_32bitindex_gather() local_unnamed_addr #0 {
; VPLAN-HIR-CM-VF8-LABEL:  Cost Model for VPlan test_fit_32bitindex_gather:HIR.#{{[0-9]+}} with VF = 8:
; VPLAN-HIR-CM-VF8-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; VPLAN-HIR-CM-VF8-NEXT:  [[BB0]]: base cost: 0
; VPLAN-HIR-CM-VF8-NEXT:  Analyzing VPBasicBlock [[BB1]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost Unknown for i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 341, UF = 1
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32 [[VP__IND_INIT:%.*]] = induction-init{add} i32 live-in0 i32 1
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; VPLAN-HIR-CM-VF8-NEXT:  [[BB1]]: base cost: 0
; VPLAN-HIR-CM-VF8-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 0
; VPLAN-HIR-CM-VF8-NEXT:  Analyzing VPBasicBlock [[BB2]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost Unknown for i32 [[VP0:%.*]] = phi  [ i32 [[VP__IND_INIT]], [[BB1]] ],  [ i32 [[VP1:%.*]], [[BB2]] ]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 1 for i32 [[VP2:%.*]] = mul i32 3 i32 [[VP0]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 1 for i64 [[VP3:%.*]] = sext i32 [[VP2]] to i64
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.0 i64 0 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 4 for i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.1 i64 1 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 4 for i32 [[VP_LOAD_1:%.*]] = load i32* [[VP_SUBSCRIPT_1]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.2 i64 2147483647 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 4 for i32 [[VP_LOAD_2:%.*]] = load i32* [[VP_SUBSCRIPT_2]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.3 i64 2147483648 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 4 for i32 [[VP_LOAD_3:%.*]] = load i32* [[VP_SUBSCRIPT_3]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_4:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.0 i64 0 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 8 for store i32 [[VP_LOAD_1]] i32* [[VP_SUBSCRIPT_4]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_5:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.1 i64 1 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 8 for store i32 [[VP_LOAD_2]] i32* [[VP_SUBSCRIPT_5]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_6:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.2 i64 2147483647 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 8 for store i32 [[VP_LOAD_3]] i32* [[VP_SUBSCRIPT_6]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32* [[VP_SUBSCRIPT_7:%.*]] = subscript inbounds [1024 x i32]* @arr.i32.3 i64 2147483648 i64 [[VP3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 8 for store i32 [[VP_LOAD]] i32* [[VP_SUBSCRIPT_7]] *GS*
; VPLAN-HIR-CM-VF8-NEXT:    Cost 1 for i32 [[VP1]] = add i32 [[VP0]] i32 [[VP__IND_INIT_STEP]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 1 for i1 [[VP18:%.*]] = icmp slt i32 [[VP1]] i32 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for br i1 [[VP18]], [[BB2]], [[BB3:BB[0-9]+]]
; VPLAN-HIR-CM-VF8-NEXT:  [[BB2]]: base cost: 52
; VPLAN-HIR-CM-VF8-NEXT:  Block total cost includes GS Cost: 48
; VPLAN-HIR-CM-VF8-NEXT:  Base Cost: 52
; VPLAN-HIR-CM-VF8-NEXT:  Extra cost due to Gather/Scatter heuristic is 96
; VPLAN-HIR-CM-VF8-NEXT:  Total Cost: 148
; VPLAN-HIR-CM-VF8-NEXT:  Analyzing VPBasicBlock [[BB3]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for i32 [[VP__IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; VPLAN-HIR-CM-VF8-NEXT:  [[BB3]]: base cost: 0
; VPLAN-HIR-CM-VF8-NEXT:  Analyzing VPBasicBlock [[BB4]]
; VPLAN-HIR-CM-VF8-NEXT:    Cost 0 for br <External Block>
; VPLAN-HIR-CM-VF8-NEXT:  [[BB4]]: base cost: 0
; VPLAN-HIR-CM-VF8-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 0
;

; Verify that GS heuristic does not cause penalty on this test with threshold set to 93.
; VPLAN-HIR-CM-VF8-GS93-NOT:  Extra cost due to Gather/Scatter heuristic

entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %indvars.iv64 = sext i32 %indvars.iv to i64
  %ld.idx0 = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.0, i64 0, i64 %indvars.iv64
  %ld.idx1 = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.1, i64 1, i64 %indvars.iv64
  %ld.idx2 = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.2, i64 2147483647, i64 %indvars.iv64
  %ld.idx3 = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.3, i64 2147483648, i64 %indvars.iv64
  %ld0 = load i32, i32* %ld.idx0
  %ld1 = load i32, i32* %ld.idx1
  %ld2 = load i32, i32* %ld.idx2
  %ld3 = load i32, i32* %ld.idx3

  store i32 %ld1, i32* %ld.idx0
  store i32 %ld2, i32* %ld.idx1
  store i32 %ld3, i32* %ld.idx2
  store i32 %ld0, i32* %ld.idx3

  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 3
  %exitcond = icmp eq i32 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void

}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

; This attribute makes TTI to work as if -zmm-usage=low is thrown. W/o this
; attribute TTI assumes zmm can be used and <8 x i64> index fits a single HW
; gather/scatter instruction.
attributes #0 = { "min-legal-vector-width"="0" }
attributes #1 = { nounwind }
; end INTEL_FEATURE_SW_ADVANCED
