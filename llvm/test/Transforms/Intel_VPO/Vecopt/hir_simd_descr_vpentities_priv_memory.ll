; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of VPlan entities generated for SIMD reduction descriptors reduced using private memory, when vectorzing with incoming HIR for two cases.

; int foo(int* ptr, int step, int n) {
;     int s = 0; char c = step;
; #pragma omp simd reduction(+:s)
;     for (int i = 0; i < n; i++) {
;         s += *ptr * c;
;     }
;     return s;
; }

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-temp-cleanup -hir-last-value-computation -VPlanDriverHIR -disable-vplan-codegen -vplan-entities-dump -vplan-print-after-vpentity-instrs -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-last-value-computation,hir-vec-dir-insert,vplan-driver-hir" -disable-vplan-codegen -vplan-entities-dump -vplan-print-after-vpentity-instrs -disable-output < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Input HIR for Case 1
; <0>     BEGIN REGION { }
; <2>           %1 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD(),  QUAL.OMP.REDUCTION.ADD(&((%s)[0])),  QUAL.OMP.NORMALIZED.IV(null),  QUAL.OMP.NORMALIZED.UB(null) ]
; <3>           %ptr.addr.promoted = (%ptr.addr)[0];
; <4>           %c.promoted = (%c)[0];
; <5>           %.pre = (%s)[0];
; <6>           %2 = %.pre;
; <24>
; <24>          + DO i1 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295> <simd>
; <10>          |   %3 = (%ptr.addr.promoted)[0];
; <13>          |   %2 = (sext.i8.i32(%c.promoted) * %3)  +  %2;
; <14>          |   (%s)[0] = %2;
; <24>          + END LOOP
; <24>
; <22>          @llvm.directive.region.exit(%1); [ DIR.OMP.END.SIMD() ]
; <0>     END REGION


; For the above HIR, the update site (add) is not live-out as the store to the
; variable is done immediately within loop. Hence the reduction is done using
; private memory. The initial value should be saved in private memory and the
; store operation must save the result in same private memory which is
; appropriately written to the reduction variable in finalize statements. Also
; %2 is used as a valid alias to the reduction variable %s inside the loop.

; Function Attrs: nounwind uwtable
define dso_local i32 @foo1(i32* %ptr, i32 %step, i32 %n) local_unnamed_addr {
; CHECK-LABEL:  After insertion VPEntities instructions:
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; FIXME: Start below should be %2 since original reduction variable was replaced with its alias.
; CHECK-NEXT:   (+) Start: i32* [[S0:%.*]]
; CHECK-NEXT:    Linked values: void [[VP0:%.*]], i32 [[VP1:%.*]], i32* [[VP2:%.*]], i32 [[VP__RED_INIT:%.*]], i32 [[VP3:%.*]], i32 [[VP__RED_FINAL:%.*]],
; CHECK-NEXT:   Memory: i32* [[S0]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i32 0 Step: i32 1 BinOp: i32 [[VP4:%.*]] = add i32 [[VP5:%.*]] i32 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP5]], i32 [[VP4]], i32 [[VP__IND_INIT:%.*]], i32 [[VP__IND_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK:       SOASafe = i32* [[S0]]
; CHECK-NEXT:    REGION: [[REGION0:region[0-9]+]]
; CHECK-NEXT:    [[BB1:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP6:%.*]] = add i32 [[N0:%.*]] i32 -1
; CHECK-NEXT:     [DA: Divergent] i32* [[VP2]] = allocate-priv i32*
; CHECK-NEXT:     [DA: Divergent] i32 [[VP__RED_INIT]] = reduction-init i32 0 i32* [[S0]]
; CHECK-NEXT:     [DA: Divergent] store i32 [[VP__RED_INIT]] i32* [[VP2]]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP__IND_INIT]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP__IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB0]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]:
; FIXME: Reduction PHI should use reduction-init as incoming value.
; CHECK-NEXT:     [DA: Divergent] i32 [[VP7:%.*]] = phi  [ i32 [[TMP2:%.*]], [[BB2]] ],  [ i32 [[VP1]], [[BB0]] ]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP5]] = phi  [ i32 [[VP__IND_INIT]], [[BB2]] ],  [ i32 [[VP4]], [[BB0]] ]
; CHECK-NEXT:     [DA: Uniform] i32 [[VP8:%.*]] = load i32* [[PTR_ADDR_PROMOTED0:%.*]]
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP9:%.*]] = sext i8 [[C_PROMOTED0:%.*]] to i32
; CHECK-NEXT:     [DA: Uniform] i32 [[VP10:%.*]] = mul i32 [[VP8]] i32 [[VP9]]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP1]] = add i32 [[VP10]] i32 [[VP7]]
; CHECK-NEXT:     [DA: Divergent] store i32 [[VP1]] i32* [[VP2]]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP4]] = add i32 [[VP5]] i32 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uniform]   i1 [[VP11:%.*]] = icmp i32 [[VP4]] i32 [[VP6]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB0]](i1 [[VP11]]), [[BB3:BB[0-9]+]](!i1 [[VP11]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB2]] [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Divergent] i32 [[VP12:%.*]] = load i32* [[VP2]]
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP__RED_FINAL]] = reduction-final{u_add} i32 [[VP12]]
; CHECK-NEXT:     [DA: Uniform]   store i32 [[VP__RED_FINAL]] i32* [[S0]]
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP__IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    END Region([[REGION0]])
;
entry:
  %ptr.addr = alloca i32*, align 8
  %s = alloca i32, align 4
  %c = alloca i8, align 1
  store i32* %ptr, i32** %ptr.addr, align 8, !tbaa !2
  %0 = bitcast i32* %s to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0) #2
  store i32 0, i32* %s, align 4, !tbaa !6
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %c) #2
  %conv = trunc i32 %step to i8
  store i8 %conv, i8* %c, align 1, !tbaa !8
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %DIR.OMP.SIMD.114, label %omp.precond.end

DIR.OMP.SIMD.114:                                 ; preds = %entry
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(i32* %s), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  %ptr.addr.promoted = load i32*, i32** %ptr.addr, align 8, !tbaa !2
  %c.promoted = load i8, i8* %c, align 1, !tbaa !8
  %.pre = load i32, i32* %s, align 4, !tbaa !6
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.114
  %2 = phi i32 [ %add8, %omp.inner.for.body ], [ %.pre, %DIR.OMP.SIMD.114 ]
  %.omp.iv.0 = phi i32 [ %add9, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.114 ]
  %3 = load i32, i32* %ptr.addr.promoted, align 4, !tbaa !6
  %conv6 = sext i8 %c.promoted to i32
  %mul7 = mul nsw i32 %3, %conv6
  %add8 = add nsw i32 %mul7, %2
  store i32 %add8, i32* %s, align 4, !tbaa !6
  %add9 = add nuw nsw i32 %.omp.iv.0, 1
  %exitcond = icmp eq i32 %add9, %n
  br i1 %exitcond, label %omp.loop.exit, label %omp.inner.for.body

omp.loop.exit:                                    ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SIMD"() ]
  %.pre19 = load i32, i32* %s, align 4, !tbaa !6
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %omp.loop.exit, %entry
  %4 = phi i32 [ %.pre19, %omp.loop.exit ], [ 0, %entry ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %c) #2
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0) #2
  ret i32 %4
}


; Input HIR for Case 2
; <0>     BEGIN REGION { }
; <2>           %1 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD(),  QUAL.OMP.REDUCTION.ADD(&((%s)[0])),  QUAL.OMP.NORMALIZED.IV(null),  QUAL.OMP.NORMALIZED.UB(null) ]
; <3>           %ptr.addr.promoted = (%ptr.addr)[0];
; <4>           %c.promoted = (%c)[0];
; <5>           %.pre = (%s)[0];
; <6>           %2 = %.pre;
; <25>
; <25>          + DO i1 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295> <simd>
; <10>          |   %3 = (%ptr.addr.promoted)[0];
; <13>          |   %2 = (sext.i8.i32(%c.promoted) * %3)  +  %2;
; <14>          |   (%s)[0] = %2;
; <25>          + END LOOP
; <25>
; <22>          (%some_ptr)[0] = %2;
; <23>          @llvm.directive.region.exit(%1); [ DIR.OMP.END.SIMD() ]
; <0>     END REGION


; The updating instruction (add) is live-out of the loop used to store into
; %some_ptr. In this case, we perform a register reduction and the add
; instruction is directly used for last-value computation representation. The
; stores to private memory inside the loop are dead and expected to be removed
; by later optimizations. Also %2 is used as a valid alias to the reduction
; variable %s inside the loop.

define dso_local i32 @foo2(i32* %ptr, i32 %step, i32 %n) local_unnamed_addr {
; CHECK-LABEL:  After insertion VPEntities instructions:
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; FIXME: Start below should be %2 since original reduction variable was replaced with its alias.
; CHECK-NEXT:   (+) Start: i32* [[S0:%.*]] Exit: i32 [[VP0:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP1:%.*]], i32 [[VP0]], void [[VP2:%.*]], i32* [[VP3:%.*]], i32 [[VP__RED_INIT:%.*]], i32 [[VP4:%.*]], i32 [[VP__RED_FINAL:%.*]],
; CHECK-NEXT:   Memory: i32* [[S0]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i32 0 Step: i32 1 BinOp: i32 [[VP5:%.*]] = add i32 [[VP6:%.*]] i32 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP6]], i32 [[VP5]], i32 [[VP__IND_INIT:%.*]], i32 [[VP__IND_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK:       SOASafe = i32* [[S0]]
; CHECK-NEXT:    REGION: [[REGION0:region[0-9]+]]
; CHECK-NEXT:    [[BB1:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP7:%.*]] = add i32 [[N0:%.*]] i32 -1
; CHECK-NEXT:     [DA: Divergent] i32* [[VP3]] = allocate-priv i32*
; CHECK-NEXT:     [DA: Divergent] i32 [[VP__RED_INIT]] = reduction-init i32 0 i32* [[S0]]
; CHECK-NEXT:     [DA: Divergent] store i32 [[VP__RED_INIT]] i32* [[VP3]]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP__IND_INIT]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP__IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB0]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]:
; FIXME: Reduction PHI should use reduction-init as incoming value.
; CHECK-NEXT:     [DA: Divergent] i32 [[VP1]] = phi  [ i32 [[TMP2:%.*]], [[BB2]] ],  [ i32 [[VP0]], [[BB0]] ]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP6]] = phi  [ i32 [[VP__IND_INIT]], [[BB2]] ],  [ i32 [[VP5]], [[BB0]] ]
; CHECK-NEXT:     [DA: Uniform] i32 [[VP8:%.*]] = load i32* [[PTR_ADDR_PROMOTED0:%.*]]
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP9:%.*]] = sext i8 [[C_PROMOTED0:%.*]] to i32
; CHECK-NEXT:     [DA: Uniform] i32 [[VP10:%.*]] = mul i32 [[VP8]] i32 [[VP9]]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP0]] = add i32 [[VP10]] i32 [[VP1]]
; CHECK-NEXT:     [DA: Divergent] store i32 [[VP0]] i32* [[VP3]]
; CHECK-NEXT:     [DA: Divergent] i32 [[VP5]] = add i32 [[VP6]] i32 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uniform]   i1 [[VP11:%.*]] = icmp i32 [[VP5]] i32 [[VP7]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB0]](i1 [[VP11]]), [[BB3:BB[0-9]+]](!i1 [[VP11]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB2]] [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP__RED_FINAL]] = reduction-final{u_add} i32 [[VP0]]
; CHECK-NEXT:     [DA: Uniform]   store i32 [[VP__RED_FINAL]] i32* [[S0]]
; CHECK-NEXT:     [DA: Uniform]   i32 [[VP__IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    END Region([[REGION0]])
;
entry:
  %ptr.addr = alloca i32*, align 8
  %s = alloca i32, align 4
  %c = alloca i8, align 1
  %some_ptr = alloca i32, align 4
  store i32* %ptr, i32** %ptr.addr, align 8, !tbaa !2
  %0 = bitcast i32* %s to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0) #2
  store i32 0, i32* %s, align 4, !tbaa !6
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %c) #2
  %conv = trunc i32 %step to i8
  store i8 %conv, i8* %c, align 1, !tbaa !8
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %DIR.OMP.SIMD.114, label %omp.precond.end

DIR.OMP.SIMD.114:                                 ; preds = %entry
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(i32* %s), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  %ptr.addr.promoted = load i32*, i32** %ptr.addr, align 8, !tbaa !2
  %c.promoted = load i8, i8* %c, align 1, !tbaa !8
  %.pre = load i32, i32* %s, align 4, !tbaa !6
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.114
  %2 = phi i32 [ %add8, %omp.inner.for.body ], [ %.pre, %DIR.OMP.SIMD.114 ]
  %.omp.iv.0 = phi i32 [ %add9, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.114 ]
  %3 = load i32, i32* %ptr.addr.promoted, align 4, !tbaa !6
  %conv6 = sext i8 %c.promoted to i32
  %mul7 = mul nsw i32 %3, %conv6
  %add8 = add nsw i32 %mul7, %2
  store i32 %add8, i32* %s, align 4, !tbaa !6
  %add9 = add nuw nsw i32 %.omp.iv.0, 1
  %exitcond = icmp eq i32 %add9, %n
  br i1 %exitcond, label %omp.loop.exit, label %omp.inner.for.body

omp.loop.exit:                                    ; preds = %omp.inner.for.body
  store i32 %add8, i32* %some_ptr
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SIMD"() ]
  %.pre19 = load i32, i32* %s, align 4, !tbaa !6
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %omp.loop.exit, %entry
  %4 = phi i32 [ %.pre19, %omp.loop.exit ], [ 0, %entry ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %c) #2
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0) #2
  ret i32 %4
}


; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #2

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1


attributes #1 = { argmemonly nounwind }
attributes #2 = { nounwind }


!2 = !{!3, !3, i64 0}
!3 = !{!"pointer@_ZTSPi", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !4, i64 0}
!8 = !{!4, !4, i64 0}
