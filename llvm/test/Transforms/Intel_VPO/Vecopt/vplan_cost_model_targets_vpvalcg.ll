; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -S -vplan-vec  -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vplan-cost-model-print-analysis-for-vf=8 -vplan-force-vf=8 -disable-output \
; RUN:     | FileCheck %s --check-prefix=VPLAN-CM-AVX2

; RUN: opt < %s -S -vplan-vec  -mtriple=x86_64-unknown-unknown -mattr=+sse2 \
; RUN:     -vplan-cost-model-print-analysis-for-vf=8 -vplan-force-vf=8 -disable-output \
; RUN:     | FileCheck %s --check-prefix=VPLAN-CM-SSE2

; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec \
; RUN:     -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=8 \
; RUN:     | FileCheck %s --check-prefix=VPLAN-HIR-CM-AVX2

; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec \
; RUN:     -mtriple=x86_64-unknown-unknown -mattr=+sse2 \
; RUN:     -disable-output -vplan-cost-model-print-analysis-for-vf=8 -vplan-force-vf=8 \
; RUN:     | FileCheck %s --check-prefix=VPLAN-HIR-CM-SSE2

; RUN: opt < %s -S -vplan-vec  -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vplan-force-vf=8 -instcombine -simplifycfg  -cost-model -analyze -enable-new-pm=0 \
; RUN:     | FileCheck %s --check-prefix=LLVM-CM-AVX2

; RUN: opt < %s -S -vplan-vec  -mtriple=x86_64-unknown-unknown -mattr=+sse2 \
; RUN:     -vplan-force-vf=8 -instcombine -simplifycfg  -cost-model -analyze -enable-new-pm=0 \
; RUN:     | FileCheck %s --check-prefix=LLVM-CM-SSE2


; Verify that we properly use the target ISA when doing cost modelling.
; In this test the cost vector icmp differs significantly between sse2/avx2.

@arr.i64.1 = external local_unnamed_addr global [1024 x i64], align 16
@arr.i64.2 = external local_unnamed_addr global [1024 x i64], align 16
@arr.i64.3 = external local_unnamed_addr global [1024 x i64], align 16

define void @foo() local_unnamed_addr {
; VPLAN-CM-AVX2-LABEL:  Cost Model for VPlan foo:for.body.#{{[0-9]+}} with VF = 8:
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:  [[BB0]]: base cost: 0
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB1]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:  [[BB1]]: base cost: 0
; VPLAN-CM-AVX2-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 0
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB2]]
; VPLAN-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB2]] ]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_LD_IDX:%.*]] = getelementptr inbounds [1024 x i64]* @arr.i64.1 i64 0 i64 [[VP_INDVARS_IV]]
; VPLAN-CM-AVX2-NEXT:    Cost 2.25 for i64 [[VP_LD:%.*]] = load i64* [[VP_LD_IDX]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_LD2_IDX:%.*]] = getelementptr inbounds [1024 x i64]* @arr.i64.3 i64 0 i64 [[VP_INDVARS_IV]]
; VPLAN-CM-AVX2-NEXT:    Cost 2.25 for i64 [[VP_LD2:%.*]] = load i64* [[VP_LD2_IDX]]
; VPLAN-CM-AVX2-NEXT:    Cost 8 for i1 [[VP_CMP:%.*]] = icmp sge i64 [[VP_LD]] i64 [[VP_LD2]]
; VPLAN-CM-AVX2-NEXT:    Cost 1 for i64 [[VP_CMP_TO_I64:%.*]] = zext i1 [[VP_CMP]] to i64
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_ST_IDX:%.*]] = getelementptr inbounds [1024 x i64]* @arr.i64.2 i64 0 i64 [[VP_INDVARS_IV]]
; VPLAN-CM-AVX2-NEXT:    Cost 2.5 for store i64 [[VP_CMP_TO_I64]] i64* [[VP_ST_IDX]]
; VPLAN-CM-AVX2-NEXT:    Cost 2 for i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; VPLAN-CM-AVX2-NEXT:    Cost 8 for i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB3:BB[0-9]+]], [[BB2]]
; VPLAN-CM-AVX2-NEXT:  [[BB2]]: base cost: 26
; VPLAN-CM-AVX2-NEXT:  Base Cost: 26
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB3]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; VPLAN-CM-AVX2-NEXT:  [[BB3]]: base cost: 0
; VPLAN-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB4]]
; VPLAN-CM-AVX2-NEXT:    Cost 0 for br <External Block>
; VPLAN-CM-AVX2-NEXT:  [[BB4]]: base cost: 0
; VPLAN-CM-AVX2-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 0
;
; VPLAN-CM-SSE2-LABEL:  Cost Model for VPlan foo:for.body.#{{[0-9]+}} with VF = 8:
; VPLAN-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; VPLAN-CM-SSE2-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; VPLAN-CM-SSE2-NEXT:  [[BB0]]: base cost: 0
; VPLAN-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB1]]
; VPLAN-CM-SSE2-NEXT:    Cost 0 for i64 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-CM-SSE2-NEXT:    Cost 0 for i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-CM-SSE2-NEXT:    Cost Unknown for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; VPLAN-CM-SSE2-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; VPLAN-CM-SSE2-NEXT:  [[BB1]]: base cost: 0
; VPLAN-CM-SSE2-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 0
; VPLAN-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB2]]
; VPLAN-CM-SSE2-NEXT:    Cost Unknown for i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB2]] ]
; VPLAN-CM-SSE2-NEXT:    Cost 0 for i64* [[VP_LD_IDX:%.*]] = getelementptr inbounds [1024 x i64]* @arr.i64.1 i64 0 i64 [[VP_INDVARS_IV]]
; VPLAN-CM-SSE2-NEXT:    Cost 4 for i64 [[VP_LD:%.*]] = load i64* [[VP_LD_IDX]]
; VPLAN-CM-SSE2-NEXT:    Cost 0 for i64* [[VP_LD2_IDX:%.*]] = getelementptr inbounds [1024 x i64]* @arr.i64.3 i64 0 i64 [[VP_INDVARS_IV]]
; VPLAN-CM-SSE2-NEXT:    Cost 4 for i64 [[VP_LD2:%.*]] = load i64* [[VP_LD2_IDX]]
; VPLAN-CM-SSE2-NEXT:    Cost 32 for i1 [[VP_CMP:%.*]] = icmp sge i64 [[VP_LD]] i64 [[VP_LD2]]
; VPLAN-CM-SSE2-NEXT:    Cost 1 for i64 [[VP_CMP_TO_I64:%.*]] = zext i1 [[VP_CMP]] to i64
; VPLAN-CM-SSE2-NEXT:    Cost 0 for i64* [[VP_ST_IDX:%.*]] = getelementptr inbounds [1024 x i64]* @arr.i64.2 i64 0 i64 [[VP_INDVARS_IV]]
; VPLAN-CM-SSE2-NEXT:    Cost 4 for store i64 [[VP_CMP_TO_I64]] i64* [[VP_ST_IDX]]
; VPLAN-CM-SSE2-NEXT:    Cost 4 for i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; VPLAN-CM-SSE2-NEXT:    Cost 32 for i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-CM-SSE2-NEXT:    Cost 0 for br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB3:BB[0-9]+]], [[BB2]]
; VPLAN-CM-SSE2-NEXT:  [[BB2]]: base cost: 81
; VPLAN-CM-SSE2-NEXT:  Base Cost: 81
; VPLAN-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB3]]
; VPLAN-CM-SSE2-NEXT:    Cost 0 for i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; VPLAN-CM-SSE2-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; VPLAN-CM-SSE2-NEXT:  [[BB3]]: base cost: 0
; VPLAN-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB4]]
; VPLAN-CM-SSE2-NEXT:    Cost 0 for br <External Block>
; VPLAN-CM-SSE2-NEXT:  [[BB4]]: base cost: 0
; VPLAN-CM-SSE2-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 0
;
; VPLAN-HIR-CM-AVX2-LABEL:  Cost Model for VPlan foo:HIR.#{{[0-9]+}} with VF = 8:
; VPLAN-HIR-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; VPLAN-HIR-CM-AVX2-NEXT:  [[BB0]]: base cost: 0
; VPLAN-HIR-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB1]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; VPLAN-HIR-CM-AVX2-NEXT:  [[BB1]]: base cost: 0
; VPLAN-HIR-CM-AVX2-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 0
; VPLAN-HIR-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB2]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB2]] ]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i64]* @arr.i64.1 i64 0 i64 [[VP0]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 2.25 for i64 [[VP_LOAD:%.*]] = load i64* [[VP_SUBSCRIPT]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i64]* @arr.i64.3 i64 0 i64 [[VP0]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 2.25 for i64 [[VP_LOAD_1:%.*]] = load i64* [[VP_SUBSCRIPT_1]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 8 for i1 [[VP2:%.*]] = icmp sge i64 [[VP_LOAD]] i64 [[VP_LOAD_1]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 1 for i64 [[VP3:%.*]] = zext i1 [[VP2]] to i64
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i64]* @arr.i64.2 i64 0 i64 [[VP0]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 2.5 for store i64 [[VP3]] i64* [[VP_SUBSCRIPT_2]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 2 for i64 [[VP1]] = add i64 [[VP0]] i64 [[VP__IND_INIT_STEP]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 8 for i1 [[VP4:%.*]] = icmp slt i64 [[VP1]] i64 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for br i1 [[VP4]], [[BB2]], [[BB3:BB[0-9]+]]
; VPLAN-HIR-CM-AVX2-NEXT:  [[BB2]]: base cost: 26
; VPLAN-HIR-CM-AVX2-NEXT:  Base Cost: 26
; VPLAN-HIR-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB3]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; VPLAN-HIR-CM-AVX2-NEXT:  [[BB3]]: base cost: 0
; VPLAN-HIR-CM-AVX2-NEXT:  Analyzing VPBasicBlock [[BB4]]
; VPLAN-HIR-CM-AVX2-NEXT:    Cost 0 for br <External Block>
; VPLAN-HIR-CM-AVX2-NEXT:  [[BB4]]: base cost: 0
; VPLAN-HIR-CM-AVX2-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 0
;
; VPLAN-HIR-CM-SSE2-LABEL:  Cost Model for VPlan foo:HIR.#{{[0-9]+}} with VF = 8:
; VPLAN-HIR-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB0:BB[0-9]+]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for br [[BB1:BB[0-9]+]]
; VPLAN-HIR-CM-SSE2-NEXT:  [[BB0]]: base cost: 0
; VPLAN-HIR-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB1]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost Unknown for i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for br [[BB2:BB[0-9]+]]
; VPLAN-HIR-CM-SSE2-NEXT:  [[BB1]]: base cost: 0
; VPLAN-HIR-CM-SSE2-NEXT:  Cost Model for Loop preheader [[BB0]] : [[BB1]] for VF = 8 resulted Cost = 0
; VPLAN-HIR-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB2]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost Unknown for i64 [[VP0:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP1:%.*]], [[BB2]] ]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [1024 x i64]* @arr.i64.1 i64 0 i64 [[VP0]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 4 for i64 [[VP_LOAD:%.*]] = load i64* [[VP_SUBSCRIPT]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds [1024 x i64]* @arr.i64.3 i64 0 i64 [[VP0]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 4 for i64 [[VP_LOAD_1:%.*]] = load i64* [[VP_SUBSCRIPT_1]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 32 for i1 [[VP2:%.*]] = icmp sge i64 [[VP_LOAD]] i64 [[VP_LOAD_1]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 1 for i64 [[VP3:%.*]] = zext i1 [[VP2]] to i64
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for i64* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds [1024 x i64]* @arr.i64.2 i64 0 i64 [[VP0]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 4 for store i64 [[VP3]] i64* [[VP_SUBSCRIPT_2]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 4 for i64 [[VP1]] = add i64 [[VP0]] i64 [[VP__IND_INIT_STEP]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 32 for i1 [[VP4:%.*]] = icmp slt i64 [[VP1]] i64 [[VP_VECTOR_TRIP_COUNT]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for br i1 [[VP4]], [[BB2]], [[BB3:BB[0-9]+]]
; VPLAN-HIR-CM-SSE2-NEXT:  [[BB2]]: base cost: 81
; VPLAN-HIR-CM-SSE2-NEXT:  Base Cost: 81
; VPLAN-HIR-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB3]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for br [[BB4:BB[0-9]+]]
; VPLAN-HIR-CM-SSE2-NEXT:  [[BB3]]: base cost: 0
; VPLAN-HIR-CM-SSE2-NEXT:  Analyzing VPBasicBlock [[BB4]]
; VPLAN-HIR-CM-SSE2-NEXT:    Cost 0 for br <External Block>
; VPLAN-HIR-CM-SSE2-NEXT:  [[BB4]]: base cost: 0
; VPLAN-HIR-CM-SSE2-NEXT:  Cost Model for Loop postexit [[BB3]] : [[BB4]] for VF = 8 resulted Cost = 0
;
; LLVM-CM-AVX2-LABEL:  Printing analysis 'Cost Model Analysis' for function 'foo':
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   br label [[VECTOR_BODY0:%.*]]
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[UNI_PHI0:%.*]] = phi i64 [ 0, [[ENTRY0:%.*]] ], [ [[TMP5:%.*]], [[VECTOR_BODY0]] ]
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SCALAR_GEP0:%.*]] = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.1, i64 0, i64 [[UNI_PHI0]]
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[TMP0:%.*]] = bitcast i64* [[SCALAR_GEP0]] to <8 x i64>*
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 2 for instruction:   [[WIDE_LOAD0:%.*]] = load <8 x i64>, <8 x i64>* [[TMP0]], align 16
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SCALAR_GEP30:%.*]] = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.3, i64 0, i64 [[UNI_PHI0]]
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[TMP1:%.*]] = bitcast i64* [[SCALAR_GEP30]] to <8 x i64>*
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 2 for instruction:   [[WIDE_LOAD40:%.*]] = load <8 x i64>, <8 x i64>* [[TMP1]], align 16
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[TMP2:%.*]] = icmp sge <8 x i64> [[WIDE_LOAD0]], [[WIDE_LOAD40]]
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[TMP3:%.*]] = zext <8 x i1> [[TMP2]] to <8 x i64>
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SCALAR_GEP50:%.*]] = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.2, i64 0, i64 [[UNI_PHI0]]
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[TMP4:%.*]] = bitcast i64* [[SCALAR_GEP50]] to <8 x i64>*
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 2 for instruction:   store <8 x i64> [[TMP3]], <8 x i64>* [[TMP4]], align 16
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[TMP5]] = add nuw nsw i64 [[UNI_PHI0]], 8
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[TMP6:%.*]] = icmp ugt i64 [[UNI_PHI0]], 1015
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   br i1 [[TMP6]], label [[FOR_END0:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
; LLVM-CM-AVX2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   ret void
;
; LLVM-CM-SSE2-LABEL:  Printing analysis 'Cost Model Analysis' for function 'foo':
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   br label [[VECTOR_BODY0:%.*]]
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[UNI_PHI0:%.*]] = phi i64 [ 0, [[ENTRY0:%.*]] ], [ [[TMP5:%.*]], [[VECTOR_BODY0]] ]
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SCALAR_GEP0:%.*]] = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.1, i64 0, i64 [[UNI_PHI0]]
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[TMP0:%.*]] = bitcast i64* [[SCALAR_GEP0]] to <8 x i64>*
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[WIDE_LOAD0:%.*]] = load <8 x i64>, <8 x i64>* [[TMP0]], align 16
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SCALAR_GEP30:%.*]] = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.3, i64 0, i64 [[UNI_PHI0]]
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[TMP1:%.*]] = bitcast i64* [[SCALAR_GEP30]] to <8 x i64>*
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[WIDE_LOAD40:%.*]] = load <8 x i64>, <8 x i64>* [[TMP1]], align 16
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 24 for instruction:   [[TMP2:%.*]] = icmp sge <8 x i64> [[WIDE_LOAD0]], [[WIDE_LOAD40]]
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 8 for instruction:   [[TMP3:%.*]] = zext <8 x i1> [[TMP2]] to <8 x i64>
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SCALAR_GEP50:%.*]] = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.2, i64 0, i64 [[UNI_PHI0]]
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   [[TMP4:%.*]] = bitcast i64* [[SCALAR_GEP50]] to <8 x i64>*
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   store <8 x i64> [[TMP3]], <8 x i64>* [[TMP4]], align 16
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[TMP5]] = add nuw nsw i64 [[UNI_PHI0]], 8
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[TMP6:%.*]] = icmp ugt i64 [[UNI_PHI0]], 1015
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   br i1 [[TMP6]], label [[FOR_END0:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
; LLVM-CM-SSE2-NEXT:  Cost Model: Found an estimated cost of 0 for instruction:   ret void
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]

  %ld.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.1, i64 0, i64 %indvars.iv
  %ld = load i64, i64* %ld.idx

  %ld2.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.3, i64 0, i64 %indvars.iv
  %ld2 = load i64, i64* %ld2.idx

  %cmp = icmp sge i64 %ld, %ld2
  %cmp_to_i64 = zext i1 %cmp to i64

  %st.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.2, i64 0, i64 %indvars.iv
  store i64 %cmp_to_i64, i64* %st.idx

  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }
