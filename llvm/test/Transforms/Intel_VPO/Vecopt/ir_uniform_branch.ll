; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -vplan-force-vf=4 -S -passes=vplan-vec < %s | FileCheck %s

;void foo(int *A, int *B, int N, int c) {
;  for (int i=0: N) {
;    if (c != 0)
;      tmp = B[i];
;    else
;      tmp = 6;
;    A[i] += tmp;
;  }
;}
define void @foo(ptr noalias nocapture %A, ptr noalias nocapture readonly %B, i32 %N, i32 %c) local_unnamed_addr #0 {
; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VPLANNEDBB2:%.*]] ], [ [[TMP10:%.*]], [[VPLANNEDBB5:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI4:%.*]] = phi i64 [ 1, [[VPLANNEDBB2]] ], [ [[TMP9:%.*]], [[VPLANNEDBB5]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i64> [ <i64 1, i64 2, i64 3, i64 4>, [[VPLANNEDBB2]] ], [ [[TMP8:%.*]], [[VPLANNEDBB5]] ]
; CHECK-NEXT:    br i1 [[CMP1:%.*]], label [[VPLANNEDBB5]], label [[VPLANNEDBB6:%.*]]
; CHECK:       VPlannedBB6:
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds i32, ptr [[B:%.*]], i64 [[UNI_PHI4]]
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[SCALAR_GEP]], align 4
; CHECK-NEXT:    br label [[VPLANNEDBB5]]
; CHECK:       VPlannedBB5:
; CHECK-NEXT:    [[VEC_PHI7:%.*]] = phi <4 x i32> [ [[WIDE_LOAD]], [[VPLANNEDBB6]] ], [ <i32 6, i32 6, i32 6, i32 6>, [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[SCALAR_GEP8:%.*]] = getelementptr inbounds i32, ptr [[A:%.*]], i64 [[UNI_PHI4]]
; CHECK-NEXT:    [[WIDE_LOAD9:%.*]] = load <4 x i32>, ptr [[SCALAR_GEP8]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = add nsw <4 x i32> [[WIDE_LOAD9]], [[VEC_PHI7]]
; CHECK-NEXT:    store <4 x i32> [[TMP6]], ptr [[SCALAR_GEP8]], align 4
; CHECK-NEXT:    [[TMP8]] = add nuw nsw <4 x i64> [[VEC_PHI]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP9]] = add nuw nsw i64 [[UNI_PHI4]], 4
; CHECK-NEXT:    [[TMP10]] = add i64 [[UNI_PHI]], 4
; CHECK-NEXT:    [[TMP11:%.*]] = icmp uge i64 [[TMP10]], [[TMP3:%.*]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[VPLANNEDBB10:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %L1

L1:
  %cmp16 = icmp sgt i32 %N, 1
  br i1 %cmp16, label %for.body.lr.ph, label %for.cond.cleanup

for.body.lr.ph:                                   ; preds = %entry
  %cmp1 = icmp eq i32 %c, 0
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %if.end
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void

for.body:                                         ; preds = %if.end, %for.body.lr.ph
  %indvars.iv = phi i64 [ 1, %for.body.lr.ph ], [ %indvars.iv.next, %if.end ]
  br i1 %cmp1, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4
  br label %if.end

if.end:                                           ; preds = %for.body, %if.then
  %.sink7 = phi i32 [ %0, %if.then ], [ 6, %for.body ]
  %arrayidx5 = getelementptr inbounds i32, ptr %A, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx5, align 4
  %add6 = add nsw i32 %1, %.sink7
  store i32 %add6, ptr %arrayidx5, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry()

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token)
