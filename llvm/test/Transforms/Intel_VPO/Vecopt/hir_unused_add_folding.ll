; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
;
; Test to check that we don't fold unused add. If we fold it then in some cases
; we can create an empty loop which leads to verification errors.
;
; RUN: opt -disable-output -hir-ssa-deconstruction -hir-opt-predicate -hir-vec-dir-insert -hir-vplan-vec -disable-hir-aggressive-redundant-loop-removal -vplan-enable-non-masked-vectorized-remainder -print-after=hir-vplan-vec %s 2>&1 | FileCheck %s
; RUN: opt -disable-output -passes="hir-ssa-deconstruction,hir-opt-predicate,hir-vec-dir-insert,hir-vplan-vec" -disable-hir-aggressive-redundant-loop-removal -vplan-enable-non-masked-vectorized-remainder -print-after=hir-vplan-vec %s 2>&1 | FileCheck %s

define void @foo(i1 %c, i64 %t, i64* %A, i64* %B) {
; CHECK-LABEL: Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        if ([[C0:%.*]] != 0)
; CHECK-NEXT:        {
; CHECK:                + DO i1 = 0, [[LOOP_UB0:%.*]], 4   <DO_LOOP> <auto-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:           |   (<4 x i64>*)([[A0:%.*]])[i1] = (-1 * i1 + -1 * <i64 0, i64 1, i64 2, i64 3> + 3)/u2
; CHECK-NEXT:           + END LOOP
; CHECK:                + DO i1 = [[PHI_TEMP50:%.*]], [[LOOP_UB190:%.*]], 2   <DO_LOOP>  <MAX_TC_EST = 2>  <LEGAL_MAX_TC = 2> <nounroll> <novectorize> <max_trip_count = 2>
; CHECK-NEXT:           |   (<2 x i64>*)([[A0]])[i1] = (-1 * i1 + -1 * <i64 0, i64 1> + 3)/u2
; CHECK-NEXT:           + END LOOP
; CHECK:                + DO i1 = [[LB_TMP0:%.*]], [[T0:%.*]] + -1, 1   <DO_LOOP>  <MAX_TC_EST = 3>  <LEGAL_MAX_TC = 3> <nounroll> <novectorize> <max_trip_count = 3>
; CHECK-NEXT:           |   [[ADD0:%.*]] = i1  +  -3
; CHECK-NEXT:           |   ([[A0]])[i1] = ([[ADD0]] /u -2)
; CHECK-NEXT:           + END LOOP
; CHECK:                [[PHI_TEMP260:%.*]] = [[T0]] + -1
; CHECK-NEXT:           final.merge.{{.*}}:
; CHECK-NEXT:        }
; CHECK-NEXT:        else
; CHECK-NEXT:        {
; CHECK:                + DO i1 = 0, [[LOOP_UB450:%.*]], 4   <DO_LOOP> <auto-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:           |   [[DOTVEC460:%.*]] = i1 + <i64 0, i64 1, i64 2, i64 3>  +  -3
; CHECK-NEXT:           |   [[DOTSCAL0:%.*]] = i1  +  -3
; CHECK:                + DO i1 = [[PHI_TEMP400:%.*]], [[LOOP_UB570:%.*]], 2   <DO_LOOP>  <MAX_TC_EST = 2>  <LEGAL_MAX_TC = 2> <nounroll> <novectorize> <max_trip_count = 2>
; CHECK-NEXT:           |   [[DOTVEC580:%.*]] = i1 + <i64 0, i64 1>  +  -3
; CHECK-NEXT:           |   [[DOTSCAL590:%.*]] = i1  +  -3
; CHECK-NEXT:           + END LOOP
; CHECK:                + DO i1 = [[LB_TMP300:%.*]], [[T0:%.*]] + -1, 1   <DO_LOOP>  <MAX_TC_EST = 3>  <LEGAL_MAX_TC = 3> <nounroll> <novectorize> <max_trip_count = 3>
; CHECK-NEXT:           |   [[ADD0:%.*]] = i1  +  -3
; CHECK-NEXT:           + END LOOP
; CHECK:                [[PHI_TEMP660:%.*]] = [[T0]] + -1
; CHECK-NEXT:           final.merge.{{.*}}:
; CHECK-NEXT:        }
; CHECK-NEXT:  END REGION
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.inc, %latch ]
  %add = add i64 %iv, -3
  br i1 %c, label %then, label %latch

then:
  %div = udiv i64 %add, -2
  %gep = getelementptr inbounds i64, i64* %A, i64 %iv
  store i64 %div, i64* %gep
  br label %latch

latch:
  %iv.inc = add i64 %iv, 1
  %cmp = icmp eq i64 %iv.inc, %t
  br i1 %cmp, label %exit, label %loop

exit:
  ret void
}
