; Test to check the functionality of vectorization opt-report statistics
; tracker peel/remainder loops generated by LLVM-IR/HIR vectorizer.

; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter -vplan-vec-scenario="n0;v4;v2s1" -intel-opt-report=high -vplan-enable-masked-vectorized-remainder=0 < %s -disable-output 2>&1 | FileCheck %s -check-prefixes=VEC-REM,VEC-REM-IR
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-cg,simplifycfg,intel-ir-optreport-emitter -vplan-vec-scenario="n0;v4;v2s1" -intel-opt-report=high -vplan-enable-masked-vectorized-remainder=0 < %s -disable-output 2>&1 | FileCheck %s -check-prefixes=VEC-REM

; VEC-REM:      LOOP BEGIN
; VEC-REM-NEXT:     remark #15301: SIMD LOOP WAS VECTORIZED
; VEC-REM-NEXT:     remark #15305: vectorization support: vector length 4
; VEC-REM-NEXT:     remark #15475: --- begin vector loop cost summary ---
; VEC-REM-NEXT:     remark #15476: scalar cost: 141.000000
; VEC-REM-NEXT:     remark #15477: vector cost: 125.562500
; VEC-REM-NEXT:     remark #15478: estimated potential speedup: 1.109375
; VEC-REM-NEXT:     remark #15309: vectorization support: normalized vectorization overhead 0.000000
; VEC-REM-NEXT:     remark #15570: using scalar loop trip count: 300
; VEC-REM-NEXT:     remark #15591: vectorized intrinsic functions: 1
; VEC-REM-NEXT:     remark #15485: serialized function calls: 1
; VEC-REM-IR-NEXT:        remark #15558: Call to function 'serial_call' was serialized due to no suitable vector variants were found.
; VEC-REM-NEXT:     remark #15488: --- end vector loop cost summary ---
; VEC-REM:      LOOP END
; VEC-REM-EMPTY:
; VEC-REM-NEXT: LOOP BEGIN
; VEC-REM-NEXT: <Remainder loop for vectorization>
; VEC-REM-NEXT:     remark #15439: remainder loop was vectorized (unmasked)
; VEC-REM-NEXT:     remark #15305: vectorization support: vector length 2
; VEC-REM-NEXT:     remark #15475: --- begin vector loop cost summary ---
; VEC-REM-NEXT:     remark #15591: vectorized intrinsic functions: 1
; VEC-REM-NEXT:     remark #15485: serialized function calls: 1
; VEC-REM-IR-NEXT:        remark #15558: Call to function 'serial_call' was serialized due to no suitable vector variants were found.
; VEC-REM-NEXT:     remark #15488: --- end vector loop cost summary ---
; VEC-REM:      LOOP END
; VEC-REM-EMPTY: 
; VEC-REM-NEXT: LOOP BEGIN
; VEC-REM-NEXT: <Remainder loop for vectorization>
; VEC-REM-NEXT: LOOP END
; VEC-REM-NEXT: =================================================================

; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="s4;v4;n0" \
; RUN:     -intel-opt-report=high < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,STA-PEEL
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-cg,simplifycfg,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="s4;v4;n0" \
; RUN:     -intel-opt-report=high < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,STA-PEEL
; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="s1;v4;s1" \
; RUN:     -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,DYN-PEEL
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-cg,simplifycfg,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="s1;v4;s1" \
; RUN:     -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,DYN-PEEL

; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="m4;v4;n0" -intel-opt-report=high < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,STA-PEEL,VEC-PEEL,VEC-PEEL-IR
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-cg,simplifycfg,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="m4;v4;n0" -intel-opt-report=high < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,STA-PEEL,VEC-PEEL
; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="m4;v4;s1" -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,DYN-PEEL,VEC-PEEL,VEC-PEEL-IR
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-cg,simplifycfg,intel-ir-optreport-emitter \
; RUN:     -vplan-vec-scenario="m4;v4;s1" -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 \
; RUN:     | FileCheck %s -check-prefixes=PEEL,DYN-PEEL,VEC-PEEL

; PEEL:          LOOP BEGIN
; PEEL-NEXT:     <Peeled loop for vectorization>
; VEC-PEEL-NEXT:     remark #15437: peel loop was vectorized
; VEC-PEEL-NEXT:     remark #15305: vectorization support: vector length 4

; STA-PEEL-NEXT:     remark #15575: peel loop is static
; STA-PEEL-NEXT:     remark #15577: estimated number of scalar loop iterations peeled: 1

; DYN-PEEL-NEXT:     remark #15576: peel loop is dynamic
; DYN-PEEL-NEXT:     remark #15577: estimated number of scalar loop iterations peeled: 3

; VEC-PEEL-NEXT:     remark #15475: --- begin vector loop cost summary ---
; VEC-PEEL-NEXT:     remark #15591: vectorized intrinsic functions: 1
; VEC-PEEL-NEXT:     remark #15485: serialized function calls: 1

; VEC-PEEL-IR-NEXT:  remark #15558: Call to function 'serial_call' was serialized due to no suitable vector variants were found.
; VEC-PEEL-NEXT:     remark #15488: --- end vector loop cost summary ---
; VEC-PEEL-NEXT:     remark #15447: --- begin vector loop memory reference summary ---

; VEC-PEEL-NEXT:     remark #15454: masked aligned unit stride loads: 1
; VEC-PEEL-NEXT:     remark #15456: masked unaligned unit stride loads: 1
; FIXME: should both be unaligned, since this is the peel loop -- only the main
;        loop should have aligned loads.

; VEC-PEEL-NEXT:     remark #15474: --- end vector loop memory reference summary ---
; PEEL:          LOOP END

; PEEL:          LOOP BEGIN
; PEEL-NEXT:         remark #15301: SIMD LOOP WAS VECTORIZED
; PEEL-NEXT:         remark #15305: vectorization support: vector length 4
; PEEL:              remark #15447: --- begin vector loop memory reference summary --
; PEEL-NEXT:         remark #15448: unmasked aligned unit stride loads: 1
; PEEL-NEXT:         remark #15450: unmasked unaligned unit stride loads: 1
; PEEL:              remark #15474: --- end vector loop memory reference summary --
; PEEL:          LOOP END

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare void @serial_call() nounwind
declare double @llvm.sqrt.f64(double %val) #1
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

@STATIC = external global [256 x double], align 1024

define void @test_calls(ptr %DYNAMIC) local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  call void @serial_call()
  %iv.plus.1 = add nuw nsw i64 %iv, 1

  %a.gep = getelementptr double, ptr %DYNAMIC, i64 %iv.plus.1
  %a = load double, ptr %a.gep, align 8

  %iv.plus.3 = add nuw nsw i64 %iv, 3
  %static.gep = getelementptr double, ptr @STATIC, i64 %iv.plus.3
  %b = load double, ptr %static.gep, align 8

  %d = fadd fast double %a, %b

  ; Intrinsic
  %sqrt = call double @llvm.sqrt.f64(double %d)
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 300
  br i1 %exitcond, label %loop.exit, label %header

loop.exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

attributes #1 = { nounwind readnone "target-features"="+fxsr,+mmx,+sse,+sse2,+x87,+avx,+avx2" }
