; Test to check the functionality of vectorization opt-report statistics
; tracker peel/remainder loops generated by LLVM-IR/HIR vectorizer.

; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter -vplan-vec-scenario="n0;v4;v2s1" -intel-opt-report=high -vplan-enable-masked-vectorized-remainder=0 < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=VEC-REM,VEC-REM-IR
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-optreport-emitter -vplan-vec-scenario="n0;v4;v2s1" -intel-opt-report=high -vplan-enable-masked-vectorized-remainder=0 < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=VEC-REM

; VEC-REM:      LOOP BEGIN
; VEC-REM-NEXT:     remark #15301: SIMD LOOP WAS VECTORIZED
; VEC-REM-NEXT:     remark #15305: vectorization support: vector length 4
; VEC-REM-NEXT:     remark #15475: --- begin vector loop cost summary ---
; VEC-REM-NEXT:     remark #15476: scalar cost: 35.000000
; VEC-REM-NEXT:     remark #15477: vector cost: 21.031250
; VEC-REM-NEXT:     remark #15478: estimated potential speedup: 1.656250
; VEC-REM-NEXT:     remark #15309: vectorization support: normalized vectorization overhead 0.000000
; VEC-REM-NEXT:     remark #15570: using scalar loop trip count: 300
; VEC-REM-NEXT:     remark #15482: vectorized math library calls: 1
; VEC-REM-NEXT:     remark #15485: serialized function calls: 1
; VEC-REM-IR-NEXT:        remark #15558: Call to function 'serial_call' was serialized due to no suitable vector variants were found.
; VEC-REM-NEXT:     remark #15488: --- end vector loop cost summary ---
; VEC-REM:      LOOP END
; VEC-REM-EMPTY:
; VEC-REM-NEXT: LOOP BEGIN
; VEC-REM-NEXT: <Remainder loop for vectorization>
; VEC-REM-NEXT:     remark #15439: remainder loop was vectorized (unmasked)
; VEC-REM-NEXT:     remark #15305: vectorization support: vector length 2
; VEC-REM-NEXT:     remark #15475: --- begin vector loop cost summary ---
; VEC-REM-NEXT:     remark #15482: vectorized math library calls: 1
; VEC-REM-NEXT:     remark #15485: serialized function calls: 1
; VEC-REM-IR-NEXT:        remark #15558: Call to function 'serial_call' was serialized due to no suitable vector variants were found.
; VEC-REM-NEXT:     remark #15488: --- end vector loop cost summary ---
; VEC-REM:      LOOP END
; VEC-REM-EMPTY: 
; VEC-REM-NEXT: LOOP BEGIN
; VEC-REM-NEXT: <Remainder loop for vectorization>
; VEC-REM-NEXT: LOOP END
; VEC-REM-NEXT: =================================================================

; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter -vplan-vec-scenario="s1;v4;n0" -intel-opt-report=high < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=SCALAR-PEEL,SCALAR-STATIC-PEEL
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-optreport-emitter -vplan-vec-scenario="s1;v4;n0" -intel-opt-report=high < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=SCALAR-PEEL,SCALAR-STATIC-PEEL
; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter -vplan-vec-scenario="s1;v4;s1" -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=SCALAR-PEEL,SCALAR-DYNAMIC-PEEL
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-optreport-emitter -vplan-vec-scenario="s1;v4;s1" -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=SCALAR-PEEL,SCALAR-DYNAMIC-PEEL

; SCALAR-PEEL: LOOP BEGIN
; SCALAR-PEEL-NEXT: <Peeled loop for vectorization>
; SCALAR-STATIC-PEEL-NEXT:     remark #15575: peel loop is static
; SCALAR-STATIC-PEEL-NEXT:     remark #15577: estimated number of scalar loop iterations peeled: 1
; SCALAR-DYNAMIC-PEEL-NEXT:     remark #15576: peel loop is dynamic
; SCALAR-DYNAMIC-PEEL-NEXT:     remark #15577: estimated number of scalar loop iterations peeled: 3
; SCALAR-PEEL-NEXT: LOOP END

; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter -vplan-vec-scenario="m4;v4;n0" -intel-opt-report=high < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=VEC-PEEL,VEC-PEEL-STATIC,VEC-PEEL-IR
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-optreport-emitter -vplan-vec-scenario="m4;v4;n0" -intel-opt-report=high < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=VEC-PEEL,VEC-PEEL-STATIC
; RUN: opt -passes=vplan-vec,intel-ir-optreport-emitter -vplan-vec-scenario="m4;v4;s1" -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=VEC-PEEL,VEC-PEEL-DYNAMIC,VEC-PEEL-IR
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-optreport-emitter -vplan-vec-scenario="m4;v4;s1" -intel-opt-report=high -vplan-enable-peeling -vplan-force-dyn-alignment < %s -disable-output 2>&1 | FileCheck %s --strict-whitespace -check-prefixes=VEC-PEEL,VEC-PEEL-DYNAMIC

; VEC-PEEL: LOOP BEGIN
; VEC-PEEL-NEXT: <Peeled loop for vectorization>
; VEC-PEEL-NEXT:     remark #15437: peel loop was vectorized
; VEC-PEEL-NEXT:     remark #15305: vectorization support: vector length 4
; VEC-PEEL-STATIC-NEXT:     remark #15575: peel loop is static
; VEC-PEEL-STATIC-NEXT:     remark #15577: estimated number of scalar loop iterations peeled: 1
; VEC-PEEL-DYNAMIC-NEXT:     remark #15576: peel loop is dynamic
; VEC-PEEL-DYNAMIC-NEXT:     remark #15577: estimated number of scalar loop iterations peeled: 3
; VEC-PEEL-NEXT:     remark #15475: --- begin vector loop cost summary ---
; VEC-PEEL-NEXT:     remark #15482: vectorized math library calls: 1
; VEC-PEEL-NEXT:     remark #15485: serialized function calls: 1
; VEC-PEEL-IR-NEXT:     remark #15558: Call to function 'serial_call' was serialized due to no suitable vector variants were found.
; VEC-PEEL-NEXT:     remark #15488: --- end vector loop cost summary ---
; VEC-PEEL: LOOP END

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare void @serial_call() nounwind
declare double @llvm.sqrt.f64(double %val) #1
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

define void @test_calls(ptr %a) local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  call void @serial_call()
  %gep = getelementptr double, ptr %a, i64 %iv
  %d = load double, ptr %gep, align 8
  ; Intrinsic
  %sqrt = call double @llvm.sqrt.f64(double %d)
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 300
  br i1 %exitcond, label %loop.exit, label %header

loop.exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

attributes #1 = { nounwind readnone "target-features"="+fxsr,+mmx,+sse,+sse2,+x87,+avx,+avx2" }
