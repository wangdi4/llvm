; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -disable-output -print-after=hir-vplan-vec  -vplan-force-vf=4 -hir-details < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -disable-output -vplan-force-vf=4 -hir-details < %s 2>&1 | FileCheck %s
;
; LIT test to check correct code generation when a call is involved in a
; reduction. The original JIRA(CMPLRLLVM-30786) also reported incorrect
; liveout information. We check livein/liveout information for the generated
; loop.
;
; Incoming scalar loop:
;       + DO i1 = 0, 99, 1   <DO_LOOP> <simd>
;       |   %2 = (@farr)[0][i1];
;       |   %1 = @llvm.maxnum.f32(%2,  %1);
;       + END LOOP
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@farr = dso_local local_unnamed_addr global [100 x float] zeroinitializer, align 16

; Function Attrs: nounwind uwtable
define dso_local float @getmax() local_unnamed_addr #0 {
; CHECK:    BEGIN REGION { modified }
; CHECK:         %max.red.promoted = (%max.red)[0]
;
; CHECK:         %1 = %max.red.promoted
; CHECK:         <LVAL-REG> LINEAR float %1 {sb:3}
;
; CHECK:         %red.init = %1
;
; CHECK:         %phi.temp = %red.init
; CHECK:         <LVAL-REG> NON-LINEAR <4 x float> %phi.temp {sb:16}
;
; CHECK:         + LiveIn symbases: 3, 9, 16
; CHECK:         + LiveOut symbases: 3, 20
;
; CHECK:         + DO i64 i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK:         |   %.vec = (<4 x float>*)(@farr)[0][i1]
; CHECK:         |      <BLOB> LINEAR [100 x float]* @farr {sb:9}
; CHECK:         |
; CHECK:         |   %llvm.maxnum.v4f32 = @llvm.maxnum.v4f32(%.vec,  %phi.temp)
; CHECK:         |   <LVAL-REG> NON-LINEAR <4 x float> %llvm.maxnum.v4f32 {sb:20}
; CHECK:         |   <RVAL-REG> NON-LINEAR <4 x float> %phi.temp {sb:16}
;
; CHECK:         |   %phi.temp = %llvm.maxnum.v4f32;
; CHECK:         + END LOOP
;
; CHECK:         %1 = @llvm.vector.reduce.fmax.v4f32(%llvm.maxnum.v4f32)
; CHECK:         <LVAL-REG> NON-LINEAR float %1 {sb:3}
; CHECK:         <RVAL-REG> NON-LINEAR <4 x float> %llvm.maxnum.v4f32 {sb:20}
;
; CHECK:         (%max.red)[0] = %1;
; CHECK:    END REGION
;
entry:
  %max.red = alloca float, align 4
  store float 0.000000e+00, float* %max.red, align 4
  br label %for.ph

for.ph:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.MAX"(float* %max.red) ]
  %max.red.promoted = load float, float* %max.red, align 4
  br label %for.body

for.body:
  %1 = phi float [ %max.red.promoted, %for.ph ], [ %3, %for.body ]
  %.omp.iv.local.013 = phi i64 [ 0, %for.ph ], [ %add3, %for.body ]
  %arrayidx = getelementptr inbounds [100 x float], [100 x float]* @farr, i64 0, i64 %.omp.iv.local.013
  %2 = load float, float* %arrayidx, align 4
  %3 = call fast float @llvm.maxnum.f32(float %2, float %1)
  %add3 = add nuw nsw i64 %.omp.iv.local.013, 1
  %exitcond.not = icmp eq i64 %add3, 100
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  %.lcssa = phi float [ %3, %for.body ]
  store float %.lcssa, float* %max.red, align 4
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret float %.lcssa
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
declare float @llvm.maxnum.f32(float, float)
