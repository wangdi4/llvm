; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -S -vplan-vec | FileCheck %s

define void @foo(i8* %a) {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[RET_LPRIV:%.*]] = alloca i8, align 1
; CHECK-NEXT:    [[RET_LPRIV_VEC:%.*]] = alloca <4 x i8>, align 4
; CHECK-NEXT:    [[RET_LPRIV_VEC_BC:%.*]] = bitcast <4 x i8>* [[RET_LPRIV_VEC]] to i8*
; CHECK-NEXT:    [[RET_LPRIV_VEC_BASE_ADDR:%.*]] = getelementptr i8, i8* [[RET_LPRIV_VEC_BC]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[PRIV_IDX_MEM_VEC:%.*]] = alloca <4 x i32>, align 16
; CHECK-NEXT:    [[PRIV_IDX_MEM_VEC_BC:%.*]] = bitcast <4 x i32>* [[PRIV_IDX_MEM_VEC]] to i32*
; CHECK-NEXT:    [[PRIV_IDX_MEM_VEC_BASE_ADDR:%.*]] = getelementptr i32, i32* [[PRIV_IDX_MEM_VEC_BC]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    br label [[TMP0:%.*]]
; CHECK:       0:
; CHECK-NEXT:    br label [[VPLANNEDBB:%.*]]
; CHECK:       VPlannedBB:
; CHECK-NEXT:    br label [[VPLANNEDBB1:%.*]]
; CHECK:       VPlannedBB1:
; CHECK-NEXT:    [[RET_LPRIV_VEC_BCAST:%.*]] = bitcast <4 x i8>* [[RET_LPRIV_VEC]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.start.p0i8(i64 4, i8* [[RET_LPRIV_VEC_BCAST]])
; CHECK-NEXT:    store <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, <4 x i32>* [[PRIV_IDX_MEM_VEC]], align 1
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VPLANNEDBB1]] ], [ [[TMP8:%.*]], [[VPLANNEDBB4:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VPLANNEDBB1]] ], [ [[TMP7:%.*]], [[VPLANNEDBB4]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp slt <4 x i32> zeroinitializer, [[VEC_PHI]]
; CHECK-NEXT:    br label [[VPLANNEDBB3:%.*]]
; CHECK:       VPlannedBB3:
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <4 x i1> [[TMP1]] to i4
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i4 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[TMP3]], label [[PRED_LOAD_IF:%.*]], label [[TMP5:%.*]]
; CHECK:       pred.load.if:
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, i8* [[A:%.*]], align 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x i8> poison, i8 [[TMP4]], i32 0
; CHECK-NEXT:    br label [[TMP5:%.*]]
; CHECK:       6:
; CHECK-NEXT:    [[TMP6:%.*]] = phi <4 x i8> [ poison, [[VPLANNEDBB3]] ], [ [[BROADCAST_SPLATINSERT]], [[PRED_LOAD_IF]] ]
; CHECK-NEXT:    br label [[PRED_LOAD_CONTINUE:%.*]]
; CHECK:       pred.load.continue:
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x i8> [[TMP6]], <4 x i8> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    call void @llvm.masked.store.v4i32.p0v4i32(<4 x i32> [[VEC_PHI]], <4 x i32>* [[PRIV_IDX_MEM_VEC]], i32 1, <4 x i1> [[TMP1]])
; CHECK-NEXT:    call void @llvm.masked.store.v4i8.p0v4i8(<4 x i8> [[BROADCAST_SPLAT]], <4 x i8>* [[RET_LPRIV_VEC]], i32 1, <4 x i1> [[TMP1]])
; CHECK-NEXT:    br label [[VPLANNEDBB4]]
; CHECK:       VPlannedBB4:
; CHECK-NEXT:    [[TMP7]] = add nsw <4 x i32> [[VEC_PHI]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP8]] = add nsw i32 [[UNI_PHI]], 4
; CHECK-NEXT:    [[TMP9:%.*]] = icmp ult i32 [[TMP8]], 100
; CHECK-NEXT:    br i1 [[TMP9]], label [[VECTOR_BODY]], label [[VPLANNEDBB5:%.*]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       VPlannedBB5:
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i8>, <4 x i8>* [[RET_LPRIV_VEC]], align 1
; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i32>, <4 x i32>* [[PRIV_IDX_MEM_VEC]], align 1
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne <4 x i32> [[WIDE_LOAD6]], <i32 -1, i32 -1, i32 -1, i32 -1>
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i1> [[TMP10]] to i4
; CHECK-NEXT:    [[TMP12:%.*]] = icmp eq i4 [[TMP11]], 0
; CHECK-NEXT:    br i1 [[TMP12]], label [[VPLANNEDBB7:%.*]], label [[VPLANNEDBB8:%.*]]
; CHECK:       VPlannedBB8:
; CHECK-NEXT:    [[TMP13:%.*]] = call i32 @llvm.vector.reduce.smax.v4i32(<4 x i32> [[WIDE_LOAD6]])
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT9:%.*]] = insertelement <4 x i32> poison, i32 [[TMP13]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT10:%.*]] = shufflevector <4 x i32> [[BROADCAST_SPLATINSERT9]], <4 x i32> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:    [[PRIV_IDX_CMP:%.*]] = icmp eq <4 x i32> [[WIDE_LOAD6]], [[BROADCAST_SPLAT10]]
; CHECK-NEXT:    [[TMP14:%.*]] = bitcast <4 x i1> [[PRIV_IDX_CMP]] to i4
; CHECK-NEXT:    [[CTTZ:%.*]] = call i4 @llvm.cttz.i4(i4 [[TMP14]], i1 true)
; CHECK-NEXT:    [[PRIV_EXTRACT:%.*]] = extractelement <4 x i8> [[WIDE_LOAD]], i4 [[CTTZ]]
; CHECK-NEXT:    store i8 [[PRIV_EXTRACT]], i8* [[RET_LPRIV]], align 1
; CHECK-NEXT:    br label [[VPLANNEDBB7]]
; CHECK:       VPlannedBB7:
; CHECK-NEXT:    [[RET_LPRIV_VEC_BCAST1:%.*]] = bitcast <4 x i8>* [[RET_LPRIV_VEC]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 4, i8* [[RET_LPRIV_VEC_BCAST1]])
; CHECK-NEXT:    br label [[VPLANNEDBB11:%.*]]
;
entry:
  %ret.lpriv = alloca i8
  br label %0

0:
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LASTPRIVATE:CONDITIONAL"(i8* %ret.lpriv) ]
  br label %omp.inner.for.body

omp.inner.for.body:
  %.omp.iv.local.016 = phi i32 [ 0, %0 ], [ %add9, %omp.inner.for.inc ]
  %cmp = icmp slt i32 0, %.omp.iv.local.016
  br i1 %cmp, label %if.then, label %omp.inner.for.inc

if.then:
  %2 = load i8, i8* %a
  store i8 %2, i8* %ret.lpriv
  br label %omp.inner.for.inc

omp.inner.for.inc:
  %add9 = add nsw i32 %.omp.iv.local.016, 1
  %cmp4 = icmp sgt i32 100, %add9
  br i1 %cmp4, label %omp.inner.for.body, label %omp.inner.for.cond.omp.inner.for.end_crit_edge

omp.inner.for.cond.omp.inner.for.end_crit_edge:
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
