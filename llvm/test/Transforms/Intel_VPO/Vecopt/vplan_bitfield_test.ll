; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -print-after=hir-vplan-vec -disable-output < %s 2>&1 | FileCheck %s --check-prefix=HIR-CHECK
; RUN: opt -enable-new-pm=0 -vplan-vec -S < %s 2>&1 | FileCheck %s --check-prefix=LLVM-CHECK
; RUN: opt -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -disable-output < %s 2>&1 | FileCheck %s --check-prefix=HIR-CHECK
; RUN: opt -passes='vplan-vec' -S < %s 2>&1 | FileCheck %s --check-prefix=LLVM-CHECK
;
; Miscellaneous tests to check that vector code generation correctly handles
; arrays of types such as i1/i3/i7... A type such as i1 has an alloc and store
; size of 8-bits and a type size of 1 bit. However, a vector of i1 type say
; <4 x i1> also has store size of 8 bits and generating wide accesses for unit
; stride accesses to an array of type i1 would generate incorrect results. As
; an example, a <4 x i1> store would only write to 1-byte instead of to 4
; consecutive bytes as expected. We need to treat such irregular cases as
; non-unit-strided so that vector CG generates gathers/scatters.
;
; Test to check that we generate scatters for stores to unit-strided accesses
; to an array of i1 due to padding bits in array elements.
;
define void @foo(i1* %arri1, i7* %arri7 ) {
; HIR-CHECK:            + DO i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; HIR-CHECK-NEXT:       |   [[DOTVEC0:%.*]] = (<4 x i1>*)([[ARRI10:%.*]])[i1 + <i64 0, i64 1, i64 2, i64 3>]
; HIR-CHECK-NEXT:       |   (<4 x i7>*)([[ARRI70:%.*]])[i1 + <i64 0, i64 1, i64 2, i64 3>] = [[DOTVEC0]]
; HIR-CHECK-NEXT:       + END LOOP
;
; LLVM-CHECK:  define void @foo(i1* [[ARRI10:%.*]], i7* [[ARRI70:%.*]]) {
; LLVM-CHECK:       VPlannedBB:
; LLVM-CHECK-NEXT:    [[BROADCAST_SPLATINSERT0:%.*]] = insertelement <4 x i1*> poison, i1* [[ARRI10]], i32 0
; LLVM-CHECK-NEXT:    [[BROADCAST_SPLAT0:%.*]] = shufflevector <4 x i1*> [[BROADCAST_SPLATINSERT0]], <4 x i1*> poison, <4 x i32> zeroinitializer
; LLVM-CHECK-NEXT:    [[BROADCAST_SPLATINSERT30:%.*]] = insertelement <4 x i7*> poison, i7* [[ARRI70]], i32 0
; LLVM-CHECK-NEXT:    [[BROADCAST_SPLAT40:%.*]] = shufflevector <4 x i7*> [[BROADCAST_SPLATINSERT30]], <4 x i7*> poison, <4 x i32> zeroinitializer
; LLVM-CHECK-NEXT:    br label [[VPLANNEDBB10:%.*]]
; LLVM-CHECK-EMPTY:
; LLVM-CHECK-NEXT:  VPlannedBB1:
; LLVM-CHECK-NEXT:    br label [[VECTOR_BODY0:%.*]]
; LLVM-CHECK-EMPTY:
; LLVM-CHECK-NEXT:  vector.body:
; LLVM-CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VPLANNEDBB10]] ], [ [[TMP2:%.*]], [[VECTOR_BODY0]] ]
; LLVM-CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VPLANNEDBB10]] ], [ [[TMP1:%.*]], [[VECTOR_BODY0]] ]
; LLVM-CHECK-NEXT:    [[MM_VECTORGEP0:%.*]] = getelementptr inbounds i1, <4 x i1*> [[BROADCAST_SPLAT0]], <4 x i64> [[VEC_PHI0]]
; LLVM-CHECK-NEXT:    [[WIDE_MASKED_GATHER0:%.*]] = call <4 x i1> @llvm.masked.gather.v4i1.v4p0i1(<4 x i1*> [[MM_VECTORGEP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i1> undef)
; LLVM-CHECK-NEXT:    [[TMP0:%.*]] = sext <4 x i1> [[WIDE_MASKED_GATHER0]] to <4 x i7>
; LLVM-CHECK-NEXT:    [[MM_VECTORGEP50:%.*]] = getelementptr inbounds i7, <4 x i7*> [[BROADCAST_SPLAT40]], <4 x i64> [[VEC_PHI0]]
; LLVM-CHECK-NEXT:    call void @llvm.masked.scatter.v4i7.v4p0i7(<4 x i7> [[TMP0]], <4 x i7*> [[MM_VECTORGEP50]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
; LLVM-CHECK-NEXT:    [[TMP1]] = add nuw nsw <4 x i64> [[VEC_PHI0]], <i64 4, i64 4, i64 4, i64 4>
; LLVM-CHECK-NEXT:    [[TMP2]] = add nuw nsw i64 [[UNI_PHI0]], 4
; LLVM-CHECK-NEXT:    [[TMP3:%.*]] = icmp uge i64 [[TMP2]], 100
; LLVM-CHECK-NEXT:    br i1 [[TMP3]], label [[VPLANNEDBB60:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %l1.05 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %ptridx = getelementptr inbounds i1, i1* %arri1, i64 %l1.05
  %ldval = load i1, i1* %ptridx, align 1
  %conv = sext i1 %ldval to i7
  %ptridx2 = getelementptr inbounds i7, i7* %arri7, i64 %l1.05
  store i7 %conv, i7* %ptridx2, align 1
  %inc = add nuw nsw i64 %l1.05, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
