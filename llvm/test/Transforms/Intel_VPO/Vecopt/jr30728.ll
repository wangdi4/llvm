; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -disable-output -print-before=hir-vplan-vec -print-after=hir-vplan-vec -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,print<hir>,hir-vplan-vec,print<hir>" -disable-output -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
;
; LIT test to check that when setting denominator of a canon expression due to a
; UDiv, we do not do an unnecessary negation of the canon expr. This was happening
; for the case when the denominator value was 2147483648 with I32 type as the
; call to set denominator was being made with the denominator value -2147483648.
;
; The relevant VPlan dump looks like the following before vector code generation.
;
;  %vp35296 = {%n + -3}
;
;   [DA: Div, SVA: (FV )] i64 %vp61682 = phi  [ i64 %vp42418, BB2 ],  [ i64 %vp62972, BB3 ] (SVAOpBits 0->FV 1->FV )
;   [DA: Div, SVA: ( V )] i32 %vp61762 = trunc i64 %vp61682 to i32 (SVAOpBits 0->V )
;   [DA: Div, SVA: ( V )] i32 %vp61788 = add i32 %vp35296 i32 %vp61762 (SVAOpBits 0->V 1->V )
;   [DA: Div, SVA: ( V )] i32 %vp61828 = udiv i32 %vp61788 i32 -2147483648 (SVAOpBits 0->V 1->V )
;
; Note that the denominator value being displayed as negative is due to LLVM IR making
; no distinction between signed and unsigned integer values. TODO: possibly look into
; changing UDiv dump to address this.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nofree norecurse nosync nounwind uwtable writeonly
define dso_local void @foo(i32* nocapture %arr, i32 %n) local_unnamed_addr #0 {
; CHECK-LABEL:  Function: foo
; CHECK:              + DO i1 = 0, 127, 1   <DO_LOOP>
; CHECK-NEXT:         |   (%arr)[i1] = (i1 + %n + -3)/u2147483648
; CHECK-NEXT:         + END LOOP
;
; CHECK-LABEL:  Function: foo
; CHECK:              + DO i1 = 0, 127, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; CHECK-NEXT:         |   (<4 x i32>*)(%arr)[i1] = (i1 + %n + <i32 0, i32 1, i32 2, i32 3> + -3)/u2147483648;
; CHECK-NEXT:         + END LOOP
;
entry:
  %add = add i32 %n, -3
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %0 = trunc i64 %indvars.iv to i32
  %sub = add i32 %add, %0
  %shr = lshr i32 %sub, 31
  %arrayidx = getelementptr inbounds i32, i32* %arr, i64 %indvars.iv
  store i32 %shr, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 128
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  ret void
}
