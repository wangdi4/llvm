; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -S -vec-clone -vplan-pragma-omp-ordered-simd-extract -vpo-cfg-restructuring -VPlanDriver -vplan-force-vf=4 2>&1 | FileCheck %s

; Check that the call that is emitted by code extractor is not vectorized.

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local i32 @_Z3fooi(i32 %a) local_unnamed_addr #0 {
; CHECK:  define dso_local i32 @_Z3fooi(i32 [[A0:%.*]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    br label [[CODEREPL0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  codeRepl:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region()
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_30:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3:
; CHECK-NEXT:    ret i32 0
; CHECK-NEXT:  }
;
; CHECK:  define dso_local <4 x i32> @_ZGVbN4v__Z3fooi(<4 x i32> [[A0]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_RETVAL0:%.*]] = alloca <4 x i32>, align 16
; CHECK-NEXT:    [[RET_CAST0:%.*]] = bitcast <4 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0:%.*]], label [[VECTOR_PH0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP3:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[UNI_PHI10:%.*]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP2:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP1:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> zeroinitializer, <4 x i32>* [[TMP0]], align 16
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_1()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_1()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_1()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_1()
; CHECK-NEXT:    [[TMP1]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP2]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP3]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP4:%.*]] = icmp ne i32 [[TMP3]], 4
; CHECK-NEXT:    br i1 false, label [[VECTOR_BODY0]], label [[VPLANNEDBB0:%.*]], !llvm.loop !0
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0:%.*]]
;
; CHECK:  define dso_local <8 x i32> @_ZGVcN8v__Z3fooi(<8 x i32> [[A0]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_RETVAL0]] = alloca <8 x i32>, align 32
; CHECK-NEXT:    [[RET_CAST0]] = bitcast <8 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0]], label [[VECTOR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP3]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[UNI_PHI10]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP2]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP1]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[SCALAR_GEP0]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> zeroinitializer, <4 x i32>* [[TMP0]], align 16
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_2()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_2()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_2()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_2()
; CHECK-NEXT:    [[TMP1]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP2]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP3]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP4]] = icmp ne i32 [[TMP3]], 8
; CHECK-NEXT:    br i1 [[TMP4]], label [[VECTOR_BODY0]], label [[VPLANNEDBB0]], !llvm.loop !5
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0]]
;
; CHECK:  define dso_local <8 x i32> @_ZGVdN8v__Z3fooi(<8 x i32> [[A0]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_RETVAL0]] = alloca <8 x i32>, align 32
; CHECK-NEXT:    [[RET_CAST0]] = bitcast <8 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0]], label [[VECTOR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP3]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[UNI_PHI10]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP2]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP1]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[SCALAR_GEP0]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> zeroinitializer, <4 x i32>* [[TMP0]], align 16
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_3()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_3()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_3()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_3()
; CHECK-NEXT:    [[TMP1]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP2]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP3]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP4]] = icmp ne i32 [[TMP3]], 8
; CHECK-NEXT:    br i1 [[TMP4]], label [[VECTOR_BODY0]], label [[VPLANNEDBB0]], !llvm.loop !7
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0]]
;
; CHECK:  define dso_local <16 x i32> @_ZGVeN16v__Z3fooi(<16 x i32> [[A0]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_RETVAL0]] = alloca <16 x i32>, align 64
; CHECK-NEXT:    [[RET_CAST0]] = bitcast <16 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0]], label [[VECTOR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP3]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[UNI_PHI10]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP2]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP1]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[SCALAR_GEP0]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> zeroinitializer, <4 x i32>* [[TMP0]], align 16
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_4()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_4()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_4()
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_4()
; CHECK-NEXT:    [[TMP1]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP2]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP3]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP4]] = icmp ne i32 [[TMP3]], 16
; CHECK-NEXT:    br i1 [[TMP4]], label [[VECTOR_BODY0]], label [[VPLANNEDBB0]], !llvm.loop !9
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0]]
;
; CHECK:  define dso_local <4 x i32> @_ZGVbM4v__Z3fooi(<4 x i32> [[A0]], <4 x i32> [[MASK0:%.*]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_MASK0:%.*]] = alloca <4 x i32>, align 16
; CHECK-NEXT:    [[VEC_RETVAL0]] = alloca <4 x i32>, align 16
; CHECK-NEXT:    [[MASK_CAST0:%.*]] = bitcast <4 x i32>* [[VEC_MASK0]] to i32*
; CHECK-NEXT:    [[RET_CAST0]] = bitcast <4 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    store <4 x i32> [[MASK0]], <4 x i32>* [[VEC_MASK0]], align 16
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0]], label [[VECTOR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP14:%.*]], [[PRED_CALL_CONTINUE110:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI10]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP13:%.*]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[VEC_PHI0]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP12:%.*]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[SCALAR_GEP0]] = getelementptr i32, i32* [[MASK_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD0:%.*]] = load <4 x i32>, <4 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1]] = icmp ne <4 x i32> [[WIDE_LOAD0]], zeroinitializer
; CHECK-NEXT:    [[TMP2]] = xor <4 x i1> [[TMP1]], <i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[SCALAR_GEP20:%.*]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP3]] = bitcast i32* [[SCALAR_GEP20]] to <4 x i32>*
; CHECK-NEXT:    call void @llvm.masked.store.v4i32.p0v4i32(<4 x i32> zeroinitializer, <4 x i32>* [[TMP3]], i32 16, <4 x i1> [[TMP1]])
; CHECK-NEXT:    [[PREDICATE0:%.*]] = extractelement <4 x i1> [[TMP1]], i64 0
; CHECK-NEXT:    [[TMP4]] = icmp eq i1 [[PREDICATE0]], true
; CHECK-NEXT:    br i1 [[TMP4]], label [[PRED_CALL_IF0:%.*]], label [[TMP5:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_5()
; CHECK-NEXT:    br label [[TMP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  5:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue:
; CHECK-NEXT:    [[PREDICATE30:%.*]] = extractelement <4 x i1> [[TMP1]], i64 1
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i1 [[PREDICATE30]], true
; CHECK-NEXT:    br i1 [[TMP6]], label [[PRED_CALL_IF60:%.*]], label [[TMP7:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if6:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_5()
; CHECK-NEXT:    br label [[TMP7]]
; CHECK-EMPTY:
; CHECK-NEXT:  7:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE70:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue7:
; CHECK-NEXT:    [[PREDICATE40:%.*]] = extractelement <4 x i1> [[TMP1]], i64 2
; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i1 [[PREDICATE40]], true
; CHECK-NEXT:    br i1 [[TMP8]], label [[PRED_CALL_IF80:%.*]], label [[TMP9:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if8:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_5()
; CHECK-NEXT:    br label [[TMP9]]
; CHECK-EMPTY:
; CHECK-NEXT:  9:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE90:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue9:
; CHECK-NEXT:    [[PREDICATE50:%.*]] = extractelement <4 x i1> [[TMP1]], i64 3
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i1 [[PREDICATE50]], true
; CHECK-NEXT:    br i1 [[TMP10]], label [[PRED_CALL_IF100:%.*]], label [[TMP11:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if10:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_5()
; CHECK-NEXT:    br label [[TMP11]]
; CHECK-EMPTY:
; CHECK-NEXT:  11:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE110]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue11:
; CHECK-NEXT:    [[TMP12]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP13]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP14]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP15:%.*]] = icmp ne i32 [[TMP14]], 4
; CHECK-NEXT:    br i1 false, label [[VECTOR_BODY0]], label [[VPLANNEDBB0]], !llvm.loop !11
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0]]
;
; CHECK:  define dso_local <8 x i32> @_ZGVcM8v__Z3fooi(<8 x i32> [[A0]], <8 x i32> [[MASK0]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_MASK0]] = alloca <8 x i32>, align 32
; CHECK-NEXT:    [[VEC_RETVAL0]] = alloca <8 x i32>, align 32
; CHECK-NEXT:    [[MASK_CAST0]] = bitcast <8 x i32>* [[VEC_MASK0]] to i32*
; CHECK-NEXT:    [[RET_CAST0]] = bitcast <8 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    store <8 x i32> [[MASK0]], <8 x i32>* [[VEC_MASK0]], align 32
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0]], label [[VECTOR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP14]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[UNI_PHI10]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP13]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[VEC_PHI0]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP12]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[SCALAR_GEP0]] = getelementptr i32, i32* [[MASK_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD0]] = load <4 x i32>, <4 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1]] = icmp ne <4 x i32> [[WIDE_LOAD0]], zeroinitializer
; CHECK-NEXT:    [[TMP2]] = xor <4 x i1> [[TMP1]], <i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[SCALAR_GEP20]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP3]] = bitcast i32* [[SCALAR_GEP20]] to <4 x i32>*
; CHECK-NEXT:    call void @llvm.masked.store.v4i32.p0v4i32(<4 x i32> zeroinitializer, <4 x i32>* [[TMP3]], i32 16, <4 x i1> [[TMP1]])
; CHECK-NEXT:    [[PREDICATE0]] = extractelement <4 x i1> [[TMP1]], i64 0
; CHECK-NEXT:    [[TMP4]] = icmp eq i1 [[PREDICATE0]], true
; CHECK-NEXT:    br i1 [[TMP4]], label [[PRED_CALL_IF0]], label [[TMP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_6()
; CHECK-NEXT:    br label [[TMP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  5:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE0]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue:
; CHECK-NEXT:    [[PREDICATE30]] = extractelement <4 x i1> [[TMP1]], i64 1
; CHECK-NEXT:    [[TMP6]] = icmp eq i1 [[PREDICATE30]], true
; CHECK-NEXT:    br i1 [[TMP6]], label [[PRED_CALL_IF60]], label [[TMP7]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if6:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_6()
; CHECK-NEXT:    br label [[TMP7]]
; CHECK-EMPTY:
; CHECK-NEXT:  7:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE70]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue7:
; CHECK-NEXT:    [[PREDICATE40]] = extractelement <4 x i1> [[TMP1]], i64 2
; CHECK-NEXT:    [[TMP8]] = icmp eq i1 [[PREDICATE40]], true
; CHECK-NEXT:    br i1 [[TMP8]], label [[PRED_CALL_IF80]], label [[TMP9]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if8:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_6()
; CHECK-NEXT:    br label [[TMP9]]
; CHECK-EMPTY:
; CHECK-NEXT:  9:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE90]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue9:
; CHECK-NEXT:    [[PREDICATE50]] = extractelement <4 x i1> [[TMP1]], i64 3
; CHECK-NEXT:    [[TMP10]] = icmp eq i1 [[PREDICATE50]], true
; CHECK-NEXT:    br i1 [[TMP10]], label [[PRED_CALL_IF100]], label [[TMP11]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if10:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_6()
; CHECK-NEXT:    br label [[TMP11]]
; CHECK-EMPTY:
; CHECK-NEXT:  11:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE110]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue11:
; CHECK-NEXT:    [[TMP12]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP13]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP14]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP15]] = icmp ne i32 [[TMP14]], 8
; CHECK-NEXT:    br i1 [[TMP15]], label [[VECTOR_BODY0]], label [[VPLANNEDBB0]], !llvm.loop !13
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0]]
;
; CHECK:  define dso_local <8 x i32> @_ZGVdM8v__Z3fooi(<8 x i32> [[A0]], <8 x i32> [[MASK0]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_MASK0]] = alloca <8 x i32>, align 32
; CHECK-NEXT:    [[VEC_RETVAL0]] = alloca <8 x i32>, align 32
; CHECK-NEXT:    [[MASK_CAST0]] = bitcast <8 x i32>* [[VEC_MASK0]] to i32*
; CHECK-NEXT:    [[RET_CAST0]] = bitcast <8 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    store <8 x i32> [[MASK0]], <8 x i32>* [[VEC_MASK0]], align 32
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0]], label [[VECTOR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP14]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[UNI_PHI10]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP13]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[VEC_PHI0]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP12]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[SCALAR_GEP0]] = getelementptr i32, i32* [[MASK_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD0]] = load <4 x i32>, <4 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1]] = icmp ne <4 x i32> [[WIDE_LOAD0]], zeroinitializer
; CHECK-NEXT:    [[TMP2]] = xor <4 x i1> [[TMP1]], <i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[SCALAR_GEP20]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP3]] = bitcast i32* [[SCALAR_GEP20]] to <4 x i32>*
; CHECK-NEXT:    call void @llvm.masked.store.v4i32.p0v4i32(<4 x i32> zeroinitializer, <4 x i32>* [[TMP3]], i32 16, <4 x i1> [[TMP1]])
; CHECK-NEXT:    [[PREDICATE0]] = extractelement <4 x i1> [[TMP1]], i64 0
; CHECK-NEXT:    [[TMP4]] = icmp eq i1 [[PREDICATE0]], true
; CHECK-NEXT:    br i1 [[TMP4]], label [[PRED_CALL_IF0]], label [[TMP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_7()
; CHECK-NEXT:    br label [[TMP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  5:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE0]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue:
; CHECK-NEXT:    [[PREDICATE30]] = extractelement <4 x i1> [[TMP1]], i64 1
; CHECK-NEXT:    [[TMP6]] = icmp eq i1 [[PREDICATE30]], true
; CHECK-NEXT:    br i1 [[TMP6]], label [[PRED_CALL_IF60]], label [[TMP7]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if6:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_7()
; CHECK-NEXT:    br label [[TMP7]]
; CHECK-EMPTY:
; CHECK-NEXT:  7:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE70]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue7:
; CHECK-NEXT:    [[PREDICATE40]] = extractelement <4 x i1> [[TMP1]], i64 2
; CHECK-NEXT:    [[TMP8]] = icmp eq i1 [[PREDICATE40]], true
; CHECK-NEXT:    br i1 [[TMP8]], label [[PRED_CALL_IF80]], label [[TMP9]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if8:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_7()
; CHECK-NEXT:    br label [[TMP9]]
; CHECK-EMPTY:
; CHECK-NEXT:  9:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE90]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue9:
; CHECK-NEXT:    [[PREDICATE50]] = extractelement <4 x i1> [[TMP1]], i64 3
; CHECK-NEXT:    [[TMP10]] = icmp eq i1 [[PREDICATE50]], true
; CHECK-NEXT:    br i1 [[TMP10]], label [[PRED_CALL_IF100]], label [[TMP11]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if10:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_7()
; CHECK-NEXT:    br label [[TMP11]]
; CHECK-EMPTY:
; CHECK-NEXT:  11:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE110]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue11:
; CHECK-NEXT:    [[TMP12]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP13]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP14]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP15]] = icmp ne i32 [[TMP14]], 8
; CHECK-NEXT:    br i1 [[TMP15]], label [[VECTOR_BODY0]], label [[VPLANNEDBB0]], !llvm.loop !15
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0]]
;
; CHECK:  define dso_local <16 x i32> @_ZGVeM16v__Z3fooi(<16 x i32> [[A0]], <16 x i32> [[MASK0]]) local_unnamed_addr #0 {
; CHECK-NEXT:  DIR.OMP.END.ORDERED.4:
; CHECK-NEXT:    [[VEC_MASK0]] = alloca <16 x i32>, align 64
; CHECK-NEXT:    [[VEC_RETVAL0]] = alloca <16 x i32>, align 64
; CHECK-NEXT:    [[MASK_CAST0]] = bitcast <16 x i32>* [[VEC_MASK0]] to i32*
; CHECK-NEXT:    [[RET_CAST0]] = bitcast <16 x i32>* [[VEC_RETVAL0]] to i32*
; CHECK-NEXT:    store <16 x i32> [[MASK0]], <16 x i32>* [[VEC_MASK0]], align 64
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br i1 false, label [[SCALAR_PH0]], label [[VECTOR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP14]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[UNI_PHI10]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP13]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[VEC_PHI0]] = phi <4 x i32> [ <i32 0, i32 1, i32 2, i32 3>, [[VECTOR_PH0]] ], [ [[TMP12]], [[PRED_CALL_CONTINUE110]] ]
; CHECK-NEXT:    [[SCALAR_GEP0]] = getelementptr i32, i32* [[MASK_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0]] = bitcast i32* [[SCALAR_GEP0]] to <4 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD0]] = load <4 x i32>, <4 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1]] = icmp ne <4 x i32> [[WIDE_LOAD0]], zeroinitializer
; CHECK-NEXT:    [[TMP2]] = xor <4 x i1> [[TMP1]], <i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[SCALAR_GEP20]] = getelementptr i32, i32* [[RET_CAST0]], i32 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP3]] = bitcast i32* [[SCALAR_GEP20]] to <4 x i32>*
; CHECK-NEXT:    call void @llvm.masked.store.v4i32.p0v4i32(<4 x i32> zeroinitializer, <4 x i32>* [[TMP3]], i32 16, <4 x i1> [[TMP1]])
; CHECK-NEXT:    [[PREDICATE0]] = extractelement <4 x i1> [[TMP1]], i64 0
; CHECK-NEXT:    [[TMP4]] = icmp eq i1 [[PREDICATE0]], true
; CHECK-NEXT:    br i1 [[TMP4]], label [[PRED_CALL_IF0]], label [[TMP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_8()
; CHECK-NEXT:    br label [[TMP5]]
; CHECK-EMPTY:
; CHECK-NEXT:  5:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE0]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue:
; CHECK-NEXT:    [[PREDICATE30]] = extractelement <4 x i1> [[TMP1]], i64 1
; CHECK-NEXT:    [[TMP6]] = icmp eq i1 [[PREDICATE30]], true
; CHECK-NEXT:    br i1 [[TMP6]], label [[PRED_CALL_IF60]], label [[TMP7]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if6:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_8()
; CHECK-NEXT:    br label [[TMP7]]
; CHECK-EMPTY:
; CHECK-NEXT:  7:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE70]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue7:
; CHECK-NEXT:    [[PREDICATE40]] = extractelement <4 x i1> [[TMP1]], i64 2
; CHECK-NEXT:    [[TMP8]] = icmp eq i1 [[PREDICATE40]], true
; CHECK-NEXT:    br i1 [[TMP8]], label [[PRED_CALL_IF80]], label [[TMP9]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if8:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_8()
; CHECK-NEXT:    br label [[TMP9]]
; CHECK-EMPTY:
; CHECK-NEXT:  9:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE90]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue9:
; CHECK-NEXT:    [[PREDICATE50]] = extractelement <4 x i1> [[TMP1]], i64 3
; CHECK-NEXT:    [[TMP10]] = icmp eq i1 [[PREDICATE50]], true
; CHECK-NEXT:    br i1 [[TMP10]], label [[PRED_CALL_IF100]], label [[TMP11]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if10:
; CHECK-NEXT:    call void @_Z3fooi.ordered.simd.region_8()
; CHECK-NEXT:    br label [[TMP11]]
; CHECK-EMPTY:
; CHECK-NEXT:  11:
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE110]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue11:
; CHECK-NEXT:    [[TMP12]] = add nuw <4 x i32> [[VEC_PHI0]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP13]] = add nuw i32 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP14]] = add i32 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP15]] = icmp ne i32 [[TMP14]], 16
; CHECK-NEXT:    br i1 [[TMP15]], label [[VECTOR_BODY0]], label [[VPLANNEDBB0]], !llvm.loop !17
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0]]
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0:%.*]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_1() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_2() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_3() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_4() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_5() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_6() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_7() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK:  define internal void @_Z3fooi.ordered.simd.region_8() #2 {
; CHECK-NEXT:  newFuncRoot:
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_10]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.ORDERED.3.exitStub:
; CHECK-NEXT:    ret void
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.1:
; CHECK-NEXT:    [[TMP0]] = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_ORDERED_20]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.ORDERED.2:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.ORDERED"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_ORDERED_3_EXITSTUB0]]
; CHECK-NEXT:  }
;
; CHECK: attributes #2 = { alwaysinline nounwind uwtable }
DIR.OMP.END.ORDERED.4:
  br label %DIR.OMP.ORDERED.1

DIR.OMP.ORDERED.1:                                ; preds = %DIR.OMP.END.ORDERED.4
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.ORDERED"(), "QUAL.OMP.ORDERED.SIMD"() ]
  br label %DIR.OMP.ORDERED.2

DIR.OMP.ORDERED.2:                                ; preds = %DIR.OMP.ORDERED.1
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.ORDERED"() ]
  br label %DIR.OMP.END.ORDERED.3

DIR.OMP.END.ORDERED.3:                            ; preds = %DIR.OMP.ORDERED.2
  ret i32 0
}

declare token @llvm.directive.region.entry() #1

declare void @llvm.directive.region.exit(token) #1

attributes #0 = { noinline nounwind uwtable "vector-variants"="_ZGVbN4v__Z3fooi,_ZGVcN8v__Z3fooi,_ZGVdN8v__Z3fooi,_ZGVeN16v__Z3fooi,_ZGVbM4v__Z3fooi,_ZGVcM8v__Z3fooi,_ZGVdM8v__Z3fooi,_ZGVeM16v__Z3fooi" }
attributes #1 = { nounwind }

