; INTEL_FEATURE_SW_ADVANCED
; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; REQUIRES: intel_feature_sw_advanced
; RUN: opt < %s -S -passes=vplan-vec -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vplan-cost-model-print-analysis-for-vf=1 -disable-output \
; RUN:     -vector-library=SVML -enable-intel-advanced-opts | \
; RUN:     FileCheck %s --check-prefix=VPLAN-CM-VF1

; RUN: opt < %s -S -passes=vplan-vec -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vplan-cost-model-print-analysis-for-vf=2 -disable-output \
; RUN:     -vector-library=SVML -enable-intel-advanced-opts | \
; RUN:     FileCheck %s --check-prefix=VPLAN-CM-VF2

; RUN: opt < %s -S -passes=vplan-vec -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vplan-cost-model-print-analysis-for-vf=4 -disable-output \
; RUN:     -vector-library=SVML -enable-intel-advanced-opts | \
; RUN:     FileCheck %s --check-prefix=VPLAN-CM-VF4

; RUN: opt < %s -S -passes='vplan-vec,instcombine,simplifycfg,print<cost-model>' -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vector-library=SVML -enable-intel-advanced-opts -vplan-force-vf=1 2>&1 | FileCheck %s --check-prefix=CM-ANAL-VF1

; RUN: opt < %s -S -passes='vplan-vec,instcombine,simplifycfg,print<cost-model>' -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vector-library=SVML -enable-intel-advanced-opts -vplan-force-vf=2 2>&1 | FileCheck %s --check-prefix=CM-ANAL-VF2

; RUN: opt < %s -S -passes='vplan-vec,instcombine,simplifycfg,print<cost-model>' -mtriple=x86_64-unknown-unknown -mattr=+avx2 \
; RUN:     -vector-library=SVML -enable-intel-advanced-opts -vplan-force-vf=4 2>&1 | FileCheck %s --check-prefix=CM-ANAL-VF4

@arr.i32.1 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.2 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.3 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.4 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.5 = external local_unnamed_addr global [1024 x i32], align 16
@arr.i32.6 = external local_unnamed_addr global [1024 x i32], align 16

@arr.i64.1 = external local_unnamed_addr global [1024 x i64], align 16
@arr.i64.2 = external local_unnamed_addr global [1024 x i64], align 16
@arr.i64.3 = external local_unnamed_addr global [1024 x i64], align 16
@arr.i64.4 = external local_unnamed_addr global [1024 x i64], align 16
@arr.i64.5 = external local_unnamed_addr global [1024 x i64], align 16
@arr.i64.6 = external local_unnamed_addr global [1024 x i64], align 16

define void @foo() {
;
; VPLAN-CM-VF1:         Cost 2 for i32 [[VP_UDIV_BY_CONST:%.*]] = udiv i32 [[VP_LD32_1:%.*]] i32 7
; VPLAN-CM-VF1-NEXT:    Cost 1 for i32 [[VP_UDIV_BY_POWER2:%.*]] = udiv i32 [[VP_LD32_2:%.*]] i32 16
; VPLAN-CM-VF1-NEXT:    Cost 1 for i32 [[VP_UDIV:%.*]] = udiv i32 [[VP_LD32_3:%.*]] i32 [[VP_UDIV_BY_POWER2]]
; VPLAN-CM-VF1-NEXT:    Cost 6 for i32 [[VP_SDIV_BY_CONST:%.*]] = sdiv i32 [[VP_LD32_1]] i32 -7
; VPLAN-CM-VF1-NEXT:    Cost 4 for i32 [[VP_SDIV_BY_POWER2:%.*]] = sdiv i32 [[VP_LD32_2]] i32 16
; VPLAN-CM-VF1-NEXT:    Cost 1 for i32 [[VP_SDIV:%.*]] = sdiv i32 [[VP_LD32_3]] i32 [[VP_SDIV_BY_POWER2]]
; VPLAN-CM-VF1-NEXT:    Cost 2 for i64 [[VP_UDIV64_BY_CONST:%.*]] = udiv i64 [[VP_LD64_1:%.*]] i64 7
; VPLAN-CM-VF1-NEXT:    Cost 1 for i64 [[VP_UDIV64_BY_POWER2:%.*]] = udiv i64 [[VP_LD64_2:%.*]] i64 16
; VPLAN-CM-VF1-NEXT:    Cost 1 for i64 [[VP_UDIV64:%.*]] = udiv i64 [[VP_LD64_3:%.*]] i64 [[VP_UDIV64_BY_POWER2]]
; VPLAN-CM-VF1-NEXT:    Cost 6 for i64 [[VP_SDIV64_BY_CONST:%.*]] = sdiv i64 [[VP_LD64_1]] i64 -7
; VPLAN-CM-VF1-NEXT:    Cost 4 for i64 [[VP_SDIV64_BY_POWER2:%.*]] = sdiv i64 [[VP_LD64_2]] i64 16
; VPLAN-CM-VF1-NEXT:    Cost 1 for i64 [[VP_SDIV64:%.*]] = sdiv i64 [[VP_LD64_3]] i64 [[VP_SDIV64_BY_POWER2]]
;
; VPLAN-CM-VF2:         Cost 5 for i32 [[VP_UDIV_BY_CONST:%.*]] = udiv i32 [[VP_LD32_1:%.*]] i32 7
; VPLAN-CM-VF2-NEXT:    Cost 1 for i32 [[VP_UDIV_BY_POWER2:%.*]] = udiv i32 [[VP_LD32_2:%.*]] i32 16
; VPLAN-CM-VF2-NEXT:    Cost 80 for i32 [[VP_UDIV:%.*]] = udiv i32 [[VP_LD32_3:%.*]] i32 [[VP_UDIV_BY_POWER2]]
; VPLAN-CM-VF2-NEXT:    Cost 6 for i32 [[VP_SDIV_BY_CONST:%.*]] = sdiv i32 [[VP_LD32_1]] i32 -7
; VPLAN-CM-VF2-NEXT:    Cost 4 for i32 [[VP_SDIV_BY_POWER2:%.*]] = sdiv i32 [[VP_LD32_2]] i32 16
; VPLAN-CM-VF2-NEXT:    Cost 80 for i32 [[VP_SDIV:%.*]] = sdiv i32 [[VP_LD32_3]] i32 [[VP_SDIV_BY_POWER2]]
; VPLAN-CM-VF2-NEXT:    Cost 80 for i64 [[VP_UDIV64_BY_CONST:%.*]] = udiv i64 [[VP_LD64_1:%.*]] i64 7
; VPLAN-CM-VF2-NEXT:    Cost 1 for i64 [[VP_UDIV64_BY_POWER2:%.*]] = udiv i64 [[VP_LD64_2:%.*]] i64 16
; VPLAN-CM-VF2-NEXT:    Cost 40 for i64 [[VP_UDIV64:%.*]] = udiv i64 [[VP_LD64_3:%.*]] i64 [[VP_UDIV64_BY_POWER2]]
; VPLAN-CM-VF2-NEXT:    Cost 240 for i64 [[VP_SDIV64_BY_CONST:%.*]] = sdiv i64 [[VP_LD64_1]] i64 -7
; VPLAN-CM-VF2-NEXT:    Cost 6 for i64 [[VP_SDIV64_BY_POWER2:%.*]] = sdiv i64 [[VP_LD64_2]] i64 16
; VPLAN-CM-VF2-NEXT:    Cost 40 for i64 [[VP_SDIV64:%.*]] = sdiv i64 [[VP_LD64_3]] i64 [[VP_SDIV64_BY_POWER2]]
;
; VPLAN-CM-VF4:         Cost 5 for i32 [[VP_UDIV_BY_CONST:%.*]] = udiv i32 [[VP_LD32_1:%.*]] i32 7
; VPLAN-CM-VF4-NEXT:    Cost 1 for i32 [[VP_UDIV_BY_POWER2:%.*]] = udiv i32 [[VP_LD32_2:%.*]] i32 16
; VPLAN-CM-VF4-NEXT:    Cost 80 for i32 [[VP_UDIV:%.*]] = udiv i32 [[VP_LD32_3:%.*]] i32 [[VP_UDIV_BY_POWER2]] *IDiv/IRem*(-77) AdjCost: 3
; VPLAN-CM-VF4-NEXT:    Cost 6 for i32 [[VP_SDIV_BY_CONST:%.*]] = sdiv i32 [[VP_LD32_1]] i32 -7
; VPLAN-CM-VF4-NEXT:    Cost 4 for i32 [[VP_SDIV_BY_POWER2:%.*]] = sdiv i32 [[VP_LD32_2]] i32 16
; VPLAN-CM-VF4-NEXT:    Cost 80 for i32 [[VP_SDIV:%.*]] = sdiv i32 [[VP_LD32_3]] i32 [[VP_SDIV_BY_POWER2]] *IDiv/IRem*(-77) AdjCost: 3
; VPLAN-CM-VF4-NEXT:    Cost 160 for i64 [[VP_UDIV64_BY_CONST:%.*]] = udiv i64 [[VP_LD64_1:%.*]] i64 7 *IDiv/IRem*(-144) AdjCost: 16
; VPLAN-CM-VF4-NEXT:    Cost 2 for i64 [[VP_UDIV64_BY_POWER2:%.*]] = udiv i64 [[VP_LD64_2:%.*]] i64 16
; VPLAN-CM-VF4-NEXT:    Cost 80 for i64 [[VP_UDIV64:%.*]] = udiv i64 [[VP_LD64_3:%.*]] i64 [[VP_UDIV64_BY_POWER2]] *IDiv/IRem*(-72) AdjCost: 8
; VPLAN-CM-VF4-NEXT:    Cost 480 for i64 [[VP_SDIV64_BY_CONST:%.*]] = sdiv i64 [[VP_LD64_1]] i64 -7 *IDiv/IRem*(-432) AdjCost: 48
; VPLAN-CM-VF4-NEXT:    Cost 11 for i64 [[VP_SDIV64_BY_POWER2:%.*]] = sdiv i64 [[VP_LD64_2]] i64 16
; VPLAN-CM-VF4-NEXT:    Cost 80 for i64 [[VP_SDIV64:%.*]] = sdiv i64 [[VP_LD64_3]] i64 [[VP_SDIV64_BY_POWER2]] *IDiv/IRem*(-72) AdjCost: 8
;
; CM-ANAL-VF1:       Cost Model: Found an estimated cost of 2 for instruction:   [[UDIV_BY_CONST0:%.*]] = udiv i32 [[LD32_10:%.*]], 7
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[UDIV_BY_POWER210:%.*]] = lshr i32 [[LD32_20:%.*]], 4
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[UDIV0:%.*]] = udiv i32 [[LD32_30:%.*]], [[UDIV_BY_POWER210]]
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 6 for instruction:   [[SDIV_BY_CONST0:%.*]] = sdiv i32 [[LD32_10]], -7
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[SDIV_BY_POWER20:%.*]] = sdiv i32 [[LD32_20]], 16
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SDIV0:%.*]] = sdiv i32 [[LD32_30]], [[SDIV_BY_POWER20]]
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 2 for instruction:   [[UDIV64_BY_CONST0:%.*]] = udiv i64 [[LD64_10:%.*]], 7
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[UDIV64_BY_POWER220:%.*]] = lshr i64 [[LD64_20:%.*]], 4
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[UDIV640:%.*]] = udiv i64 [[LD64_30:%.*]], [[UDIV64_BY_POWER220]]
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 6 for instruction:   [[SDIV64_BY_CONST0:%.*]] = sdiv i64 [[LD64_10]], -7
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[SDIV64_BY_POWER20:%.*]] = sdiv i64 [[LD64_20]], 16
; CM-ANAL-VF1-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[SDIV640:%.*]] = sdiv i64 [[LD64_30]], [[SDIV64_BY_POWER20]]
;
; CM-ANAL-VF2:       Cost Model: Found an estimated cost of 5 for instruction:   [[TMP6:%.*]] = udiv <2 x i32> [[WIDE_LOAD0:%.*]], <i32 7, i32 7>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[TMP7:%.*]] = lshr <2 x i32> [[WIDE_LOAD80:%.*]], <i32 4, i32 4>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 80 for instruction:   [[TMP8:%.*]] = udiv <2 x i32> [[WIDE_LOAD90:%.*]], [[TMP7]]
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 6 for instruction:   [[TMP9:%.*]] = sdiv <2 x i32> [[WIDE_LOAD0]], <i32 -7, i32 -7>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[TMP10:%.*]] = sdiv <2 x i32> [[WIDE_LOAD80]], <i32 16, i32 16>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 80 for instruction:   [[TMP11:%.*]] = sdiv <2 x i32> [[WIDE_LOAD90]], [[TMP10]]
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 80 for instruction:   [[TMP12:%.*]] = udiv <2 x i64> [[WIDE_LOAD160:%.*]], <i64 7, i64 7>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[TMP13:%.*]] = lshr <2 x i64> [[WIDE_LOAD170:%.*]], <i64 4, i64 4>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 40 for instruction:   [[TMP14:%.*]] = udiv <2 x i64> [[WIDE_LOAD180:%.*]], [[TMP13]]
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 240 for instruction:   [[TMP15:%.*]] = sdiv <2 x i64> [[WIDE_LOAD160]], <i64 -7, i64 -7>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 6 for instruction:   [[TMP16:%.*]] = sdiv <2 x i64> [[WIDE_LOAD170]], <i64 16, i64 16>
; CM-ANAL-VF2-NEXT:  Cost Model: Found an estimated cost of 40 for instruction:   [[TMP17:%.*]] = sdiv <2 x i64> [[WIDE_LOAD180]], [[TMP16]]
;
; CM-ANAL-VF4:       Cost Model: Found an estimated cost of 5 for instruction:   [[TMP6:%.*]] = udiv <4 x i32> [[WIDE_LOAD0:%.*]], <i32 7, i32 7, i32 7, i32 7>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 1 for instruction:   [[TMP7:%.*]] = lshr <4 x i32> [[WIDE_LOAD80:%.*]], <i32 4, i32 4, i32 4, i32 4>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 80 for instruction:   [[TMP8:%.*]] = udiv <4 x i32> [[WIDE_LOAD90:%.*]], [[TMP7]]
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 6 for instruction:   [[TMP9:%.*]] = sdiv <4 x i32> [[WIDE_LOAD0]], <i32 -7, i32 -7, i32 -7, i32 -7>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 4 for instruction:   [[TMP10:%.*]] = sdiv <4 x i32> [[WIDE_LOAD80]], <i32 16, i32 16, i32 16, i32 16>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 80 for instruction:   [[TMP11:%.*]] = sdiv <4 x i32> [[WIDE_LOAD90]], [[TMP10]]
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 160 for instruction:   [[TMP12:%.*]] = udiv <4 x i64> [[WIDE_LOAD160:%.*]], <i64 7, i64 7, i64 7, i64 7>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 2 for instruction:   [[TMP13:%.*]] = lshr <4 x i64> [[WIDE_LOAD170:%.*]], <i64 4, i64 4, i64 4, i64 4>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 80 for instruction:   [[TMP14:%.*]] = udiv <4 x i64> [[WIDE_LOAD180:%.*]], [[TMP13]]
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 480 for instruction:   [[TMP15:%.*]] = sdiv <4 x i64> [[WIDE_LOAD160]], <i64 -7, i64 -7, i64 -7, i64 -7>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 11 for instruction:   [[TMP16:%.*]] = sdiv <4 x i64> [[WIDE_LOAD170]], <i64 16, i64 16, i64 16, i64 16>
; CM-ANAL-VF4-NEXT:  Cost Model: Found an estimated cost of 80 for instruction:   [[TMP17:%.*]] = sdiv <4 x i64> [[WIDE_LOAD180]], [[TMP16]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %ld32.1.idx = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.1, i64 0, i64 %indvars.iv
  %ld32.2.idx = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.2, i64 0, i64 %indvars.iv
  %ld32.3.idx = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.3, i64 0, i64 %indvars.iv
  %ld32.4.idx = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.4, i64 0, i64 %indvars.iv
  %ld32.5.idx = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.5, i64 0, i64 %indvars.iv
  %ld32.6.idx = getelementptr inbounds [1024 x i32], [1024 x i32]* @arr.i32.6, i64 0, i64 %indvars.iv

  %ld32.1 = load i32, i32* %ld32.1.idx
  %ld32.2 = load i32, i32* %ld32.2.idx
  %ld32.3 = load i32, i32* %ld32.3.idx

  %ld64.1.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.1, i64 0, i64 %indvars.iv
  %ld64.2.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.2, i64 0, i64 %indvars.iv
  %ld64.3.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.3, i64 0, i64 %indvars.iv
  %ld64.4.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.4, i64 0, i64 %indvars.iv
  %ld64.5.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.5, i64 0, i64 %indvars.iv
  %ld64.6.idx = getelementptr inbounds [1024 x i64], [1024 x i64]* @arr.i64.6, i64 0, i64 %indvars.iv

  %ld64.1 = load i64, i64* %ld64.1.idx
  %ld64.2 = load i64, i64* %ld64.2.idx
  %ld64.3 = load i64, i64* %ld64.3.idx

  %udiv_by_const = udiv i32 %ld32.1, 7
  %udiv_by_power2 = udiv i32 %ld32.2, 16
  %udiv = udiv i32 %ld32.3, %udiv_by_power2

  %sdiv_by_const = sdiv i32 %ld32.1, -7
  %sdiv_by_power2 = sdiv i32 %ld32.2, 16
  %sdiv = sdiv i32 %ld32.3, %sdiv_by_power2

  %udiv64_by_const = udiv i64 %ld64.1, 7
  %udiv64_by_power2 = udiv i64 %ld64.2, 16
  %udiv64 = udiv i64 %ld64.3, %udiv64_by_power2

  %sdiv64_by_const = sdiv i64 %ld64.1, -7
  %sdiv64_by_power2 = sdiv i64 %ld64.2, 16
  %sdiv64 = sdiv i64 %ld64.3, %sdiv64_by_power2

  store i32 %udiv_by_const, i32* %ld32.1.idx
  store i32 %udiv_by_power2, i32* %ld32.2.idx
  store i32 %udiv, i32* %ld32.3.idx
  store i32 %sdiv_by_const, i32* %ld32.4.idx
  store i32 %sdiv_by_power2, i32* %ld32.5.idx
  store i32 %sdiv, i32* %ld32.6.idx

  store i64 %udiv64_by_const, i64* %ld64.1.idx
  store i64 %udiv64_by_power2, i64* %ld64.2.idx
  store i64 %udiv64, i64* %ld64.3.idx
  store i64 %sdiv64_by_const, i64* %ld64.4.idx
  store i64 %sdiv64_by_power2, i64* %ld64.5.idx
  store i64 %sdiv64, i64* %ld64.6.idx

  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

; end INTEL_FEATURE_SW_ADVANCED
