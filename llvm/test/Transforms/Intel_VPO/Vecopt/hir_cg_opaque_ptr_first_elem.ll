; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -opaque-pointers -disable-output -hir-ssa-deconstruction  -hir-framework -hir-vplan-vec -vplan-force-vf=4 -print-after=hir-vplan-vec -hir-details 2>&1 | FileCheck %s
; RUN: opt < %s -opaque-pointers -disable-output -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -vplan-force-vf=4 -hir-details 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%Outer = type { i32, [64 x %Inner] }
%Inner = type { i32, i32 }

define void @foo(ptr %p0, ptr %p1, i64 %N) {
; CHECK-LABEL:  Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        [[DOTUNIFLOAD0:%.*]] = (i32*)([[P10:%.*]])[0].1
; CHECK-NEXT:        <LVAL-REG> NON-LINEAR i32 [[DOTUNIFLOAD0]] {sb:15}
; CHECK-NEXT:        <RVAL-REG> {al:4}(i32*)(LINEAR ptr [[P10]])[i64 0].1 inbounds  {sb:12}
; CHECK-NEXT:           <BLOB> LINEAR ptr [[P10]] {sb:7}

; CHECK:             (<4 x i32>*)([[P00:%.*]])[0] = [[DOTUNIFLOAD0]]
; CHECK-NEXT:        <LVAL-REG> {al:4}(<4 x i32>*)(LINEAR ptr [[P00]])[i64 0] inbounds  {sb:12}
; CHECK-NEXT:           <BLOB> LINEAR ptr [[P00]] {sb:9}
; CHECK-NEXT:        <RVAL-REG> NON-LINEAR <4 x i32> [[DOTUNIFLOAD0]] {sb:15}

; CHECK:             ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  %gep0 = getelementptr inbounds i32, ptr %p0, i64 %iv
  %gep1 = getelementptr inbounds %Outer, ptr %p1, i64 0, i32 1
  %ld = load i32, ptr %gep1
  store i32 %ld, ptr %gep0

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 4
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}


%Outer.vec = type { i32, [64 x %Inner.vec] }
%Inner.vec = type { <2 x i32>, i32 }

define void @bar(ptr %p0, ptr %p1, i64 %N) {
; CHECK-LABEL:  Function: bar
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        [[DOTUNIFLOAD0:%.*]] = (<2 x i32>*)([[P10:%.*]])[0].1
; CHECK-NEXT:        <LVAL-REG> NON-LINEAR <2 x i32> [[DOTUNIFLOAD0]] {sb:15}
; CHECK-NEXT:        <RVAL-REG> {al:8}(<2 x i32>*)(LINEAR ptr [[P10]])[i64 0].1 inbounds  {sb:12}
; CHECK-NEXT:           <BLOB> LINEAR ptr [[P10]] {sb:7}
;
; CHECK:             [[DOTREPLICATED0:%.*]] = shufflevector [[DOTUNIFLOAD0]],  undef,  <i32 0, i32 1, i32 0, i32 1, i32 0, i32 1, i32 0, i32 1>
; CHECK-NEXT:        <LVAL-REG> NON-LINEAR <8 x i32> [[DOTREPLICATED0]] {sb:16}
; CHECK-NEXT:        <RVAL-REG> NON-LINEAR <2 x i32> [[DOTUNIFLOAD0]] {sb:15}

; CHECK:             (<8 x i32>*)([[P00:%.*]])[0] = [[DOTREPLICATED0]]
; CHECK-NEXT:        <LVAL-REG> {al:8}(<8 x i32>*)(LINEAR ptr [[P00]])[i64 0] inbounds  {sb:12}
; CHECK-NEXT:           <BLOB> LINEAR ptr [[P00]] {sb:9}
; CHECK-NEXT:        <RVAL-REG> NON-LINEAR <8 x i32> [[DOTREPLICATED0]] {sb:16}

; CHECK:             ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  ; Can't use <2 x i32> element type because HIR won't be triggered.
  %gep0 = getelementptr inbounds i64, ptr %p0, i64 %iv
  %gep1 = getelementptr inbounds %Outer.vec, ptr %p1, i64 0, i32 1
  %ld = load <2 x i32>, ptr %gep1
  store <2 x i32> %ld, ptr %gep0

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 4
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}


declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
