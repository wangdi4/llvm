; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2
; RUN: opt %s -vplan-da-ignore-integer-overflow=false -vplan-dump-da -passes="vplan-vec" -disable-output 2>&1 | FileCheck %s --check-prefix=ASSUMEOVERFLOW
; RUN: opt %s -vplan-da-ignore-integer-overflow=true -vplan-dump-da -passes="vplan-vec" -disable-output 2>&1 | FileCheck %s --check-prefix=ASSUMENOOVERFLOW

; This checks tests for differentiation between the two modes of DA.

; One check is for conservative mode where DA checks for possible overflow.
; When assuming overflow, the add using %N can potentially cause overflow,
; leading to non-unit stride gep.

; The other check is for the default more aggressive mode where DA ignores the
; possibility of overflow on the addition using %N, leading to unit-stride gep.

define void @_Z3fooPll(ptr nocapture noundef writeonly %a, i64 noundef %N) {
; ASSUMEOVERFLOW:  Divergent: [Shape: Random] i64 [[VP_ADD1:%.*]] = add i64 [[VP_INDVARS_IV:%.*]] i64 [[N0:%.*]]
; ASSUMEOVERFLOW-NEXT:  Divergent: [Shape: Random] ptr [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A0:%.*]] i64 [[VP_ADD1]]
; ASSUMENOOVERFLOW:  Divergent: [Shape: Unit Stride, Stride: i64 1] i64 [[VP_ADD1:%.*]] = add i64 [[VP_INDVARS_IV:%.*]] i64 [[N0:%.*]]
; ASSUMENOOVERFLOW-NEXT:  Divergent: [Shape: Strided, Stride: i64 8] ptr [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i64, ptr [[A0:%.*]] i64 [[VP_ADD1]]
;
DIR.OMP.SIMD.1:
  br label %DIR.OMP.SIMD.113

DIR.OMP.SIMD.113:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 8) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %DIR.OMP.SIMD.113, %omp.inner.for.body
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.113 ], [ %indvars.iv.next, %omp.inner.for.body ]
  %add1 = add nsw i64 %indvars.iv, %N
  %arrayidx = getelementptr inbounds i64, ptr %a, i64 %add1
  store i64 %N, ptr %arrayidx, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 128
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.1, label %omp.inner.for.body

DIR.OMP.END.SIMD.1:                               ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.2

DIR.OMP.END.SIMD.2:                               ; preds = %DIR.OMP.END.SIMD.1
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

