; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2
; RUN: opt -passes="vplan-vec" -disable-output -vplan-force-vf=4 -vplan-print-after-vpentity-instrs -vplan-entities-dump -S < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

; This test checks if VPlan processes IR with extra-empty blocks correctly (check for empty_block* in input IR below)
; These empty blocks might appear if IR was not properly optimized before passing into VPlan
; Check that we still vectorize not fully optimized IR with empty blocks and reduction

;; float foo(float *A, float *B) {
;;   float x = 1.0f;
;; #pragma omp simd reduction(inscan, + : x)
;; #pragma nounroll
;;   for (int i=0; i<1024; i++) {
;;     B[i] = x;
;; #pragma omp scan exclusive(x)
;;     x += A[i];
;;   }
;;   return x;
;; }

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define float @_Z3fooPfS_(ptr %A, ptr %B) {
;
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:

; CHECK:       Reduction list
; CHECK-NEXT:    (+) Start: ptr [[X_RED0:%.*]]
; CHECK-NEXT:    Linked values: ptr [[VP_X_RED:%.*]], float [[VP_X_REDINSCAN_RED_INIT:%.*]], void [[VP_STORE:%.*]], float [[VP_X_REDINSCAN_RED_FINAL:%.*]],
; CHECK-NEXT:    inscan ReductionKind: exclusive
; CHECK-NEXT:   Memory: ptr [[X_RED0]]
;
; CHECK:        [[BB0:BB[0-9]+]]: # preds: [[BB2:BB[0-9]+]], [[BB3:BB[0-9]+]] 
; CHECK-NEXT:     i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_IND_INIT:%.*]], [[BB2]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     float [[VP_INSCAN_ACCUM:%.*]] = phi  [ float [[VP_X_REDINSCAN_RED_INIT]], [[BB2]] ],  [ float [[VP2:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32 [[VP3:%.*]] = phi  [ i32 [[VP_I_LINEAR_IV_IND_INIT:%.*]], [[BB2]] ],  [ i32 [[VP4:%.*]], [[BB3]] ]
; CHECK-NEXT:     store i32 [[VP3]] ptr [[VP_I_LINEAR_IV:%.*]]
; CHECK-NEXT:     store float 0.000000e+00 ptr [[VP_X_RED]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     i32 [[VP5:%.*]] = trunc i64 [[VP_INDVARS_IV]] to i32
; CHECK-NEXT:     store i32 [[VP5]] ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     float [[VP6:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     ptr [[VP_ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[B0:%.*]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     store float [[VP6]] ptr [[VP_ARRAYIDX]]
; CHECK-NEXT:     br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     br [[BB11:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]: # preds: [[BB10]]
; CHECK-NEXT:     br [[BB12:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]: # preds: [[BB11]]
; CHECK-NEXT:     float [[VP_LOAD_2:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP_EXCL_SCAN:%.*]] = running-exclusive-reduction{fadd} float [[VP_LOAD_2]] float [[VP_INSCAN_ACCUM]] float 0.000000e+00
; CHECK-NEXT:     store float [[VP_EXCL_SCAN]] ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP7:%.*]] = extract-last-vector-lane float [[VP_EXCL_SCAN]]
; CHECK-NEXT:     float [[VP8:%.*]] = extract-last-vector-lane float [[VP_LOAD_2]]
; CHECK-NEXT:     float [[VP2]] = fadd float [[VP7]] float [[VP8]]
; CHECK-NEXT:     br [[BB13:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]: # preds: [[BB12]]
; CHECK-NEXT:     br [[BB14:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]: # preds: [[BB13]]
; CHECK-NEXT:     br [[BB15:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB15]]: # preds: [[BB14]]
; CHECK-NEXT:     br [[BB16:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB16]]: # preds: [[BB15]]
; CHECK-NEXT:     i32 [[VP9:%.*]] = load ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     i64 [[VP_IDXPROM1:%.*]] = sext i32 [[VP9]] to i64
; CHECK-NEXT:     ptr [[VP_ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[A0:%.*]] i64 [[VP_IDXPROM1]]
; CHECK-NEXT:     float [[VP1:%.*]] = load ptr [[VP_ARRAYIDX2]]
; CHECK-NEXT:     float [[VP0:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP_ADD3:%.*]] = fadd float [[VP0]] float [[VP1]]
; CHECK-NEXT:     store float [[VP_ADD3]] ptr [[VP_X_RED]]
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:     br [[BB17:BB[0-9]+]]
DIR.OMP.SIMD.1:
  %x.red = alloca float, align 4
  %i.linear.iv = alloca i32, align 4
  store float 1.000000e+00, ptr %x.red, align 4
  br label %DIR.OMP.SIMD.126

DIR.OMP.SIMD.126:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD:INSCAN.TYPED"(ptr %x.red, float 0.000000e+00, i32 1, i64 1), "QUAL.OMP.LINEAR:IV.TYPED"(ptr %i.linear.iv, i32 0, i32 1, i32 1) ]
  br label %DIR.OMP.END.SCAN.2

DIR.OMP.END.SCAN.2:                               ; preds = %DIR.OMP.SIMD.126, %DIR.VPO.END.GUARD.MEM.MOTION.533
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.126 ], [ %indvars.iv.next, %DIR.VPO.END.GUARD.MEM.MOTION.533 ]
  br label %DIR.VPO.GUARD.MEM.MOTION.3

DIR.VPO.GUARD.MEM.MOTION.3:                       ; preds = %DIR.OMP.END.SCAN.2
  %guard.start1 = call token @llvm.directive.region.entry() [ "DIR.VPO.GUARD.MEM.MOTION"(), "QUAL.OMP.LIVEIN"(ptr %x.red) ]
  br label %empty_block1

empty_block1:                                     ; preds = DIR.VPO.GUARD.MEM.MOTION.3
  br label %empty_block2

empty_block2:                                     ; preds = empty_block1
  br label %DIR.VPO.GUARD.MEM.MOTION.2

DIR.VPO.GUARD.MEM.MOTION.2:                       ; preds = %empty_block2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %i.linear.iv)
  %1 = trunc i64 %indvars.iv to i32
  store i32 %1, ptr %i.linear.iv, align 4
  %2 = load float, ptr %x.red, align 4
  %arrayidx = getelementptr inbounds float, ptr %B, i64 %indvars.iv
  store float %2, ptr %arrayidx, align 4
  br label %DIR.VPO.END.GUARD.MEM.MOTION.552

DIR.VPO.END.GUARD.MEM.MOTION.552:                 ; preds = %DIR.VPO.GUARD.MEM.MOTION.2
  call void @llvm.directive.region.exit(token %guard.start1) [ "DIR.VPO.END.GUARD.MEM.MOTION"() ]
  br label %DIR.OMP.SCAN.2

DIR.OMP.SCAN.2:                                   ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.552
  %3 = call token @llvm.directive.region.entry() [ "DIR.OMP.SCAN"(), "QUAL.OMP.EXCLUSIVE:TYPED"(ptr %x.red, float 0.000000e+00, i32 1, i64 1) ]
  br label %empty_block3

empty_block3:                                     ; preds = %DIR.OMP.SCAN.2
  br label %empty_block4

empty_block4:                                     ; preds = %empty_block3
  br label %DIR.OMP.SCAN.1

DIR.OMP.SCAN.1:                                   ; preds = %empty_block4
  fence acq_rel
  br label %empty_block5

empty_block5:                                     ; preds = %DIR.OMP.SCAN.1
  br label %DIR.OMP.END.SCAN.4

DIR.OMP.END.SCAN.4:                               ; preds = %empty_block5
  call void @llvm.directive.region.exit(token %3) [ "DIR.OMP.END.SCAN"() ]
  br label %DIR.OMP.END.SCAN.9.split

DIR.OMP.END.SCAN.9.split:                         ; preds = %DIR.OMP.END.SCAN.4
  %guard.start2 = call token @llvm.directive.region.entry() [ "DIR.VPO.GUARD.MEM.MOTION"(), "QUAL.OMP.LIVEIN"(ptr %x.red) ]
  br label %DIR.OMP.END.SCAN.228

DIR.OMP.END.SCAN.228:                             ; preds = %DIR.OMP.END.SCAN.9.split
  %4 = load i32, ptr %i.linear.iv, align 4
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds float, ptr %A, i64 %idxprom1
  %5 = load float, ptr %arrayidx2, align 4
  %6 = load float, ptr %x.red, align 4
  %add3 = fadd fast float %6, %5
  store float %add3, ptr %x.red, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %i.linear.iv)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %DIR.VPO.END.GUARD.MEM.MOTION.9

DIR.VPO.END.GUARD.MEM.MOTION.9:                   ; preds = %DIR.OMP.END.SCAN.228
  call void @llvm.directive.region.exit(token %guard.start2) [ "DIR.VPO.END.GUARD.MEM.MOTION"() ]
  br label %DIR.VPO.END.GUARD.MEM.MOTION.533

DIR.VPO.END.GUARD.MEM.MOTION.533:                 ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.9
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.6, label %DIR.OMP.END.SCAN.2

DIR.OMP.END.SIMD.6:                               ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.533
  %add3.lcssa = phi float [ %add3, %DIR.VPO.END.GUARD.MEM.MOTION.533 ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:                               ; preds = %DIR.OMP.END.SIMD.6
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %DIR.OMP.END.SIMD.1
  ret float %add3.lcssa
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)

declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)
