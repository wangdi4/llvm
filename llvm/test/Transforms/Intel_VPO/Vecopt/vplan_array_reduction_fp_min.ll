; Test to verify that VPlan vectorizer handles FP min/max array reduction
; idioms identified in incoming IR.

; C/C++ source
; float test(float init, int n, float *A)
; {
;   float min[9];
;   for (int i = 0; i < 9; i++)
;     min[i] = init;
;
;   #pragma omp simd simdlen(2) reduction(min:min)
;   for (int l1 = 0; l1 < n; l1++) {
;     min[l1] = larr[l1] < A[l1] ? larr[l1] : A[l1];
;   }
;
;   return min[9];
; }

; RUN: opt -passes=vplan-vec -vplan-force-vf=2 -vplan-print-after-vpentity-instrs -vplan-entities-dump -print-after=vplan-vec -disable-output < %s 2>&1 | FileCheck %s --check-prefixes=CHECK,IR
; RUN: opt -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -vplan-force-vf=2 -vplan-print-after-vpentity-instrs -vplan-entities-dump -disable-output < %s 2>&1 | FileCheck %s --check-prefixes=CHECK,HIR

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define float @test(float* nocapture readonly %A, i64 %N, float %init) {
; CHECK: VPlan after insertion of VPEntities instructions:
; CHECK: Reduction list
; CHECK:  (FloatMin) Start: [9 x float]* %min
; CHECK:   Linked values: [9 x float]* [[VPMINALLOCA:%.*]],
; CHECK:  Memory: [9 x float]* %min

; CHECK: [9 x float]* [[VPMINALLOCA]] = allocate-priv [9 x float], OrigAlign = 4
; CHECK: reduction-init-arr float 0x7FF0000000000000 [9 x float]* [[VPMINALLOCA]]
; CHECK: [9 x float] [[VPMINFIN:%.*]] = reduction-final-arr{fmin} [9 x float]* [[VPMINALLOCA]] [9 x float]* %min

; Checks for code generated by LLVM-IR vectorizer.
; IR-LABEL: define {{[^@]+}}@test(
; IR-NEXT:  entry:
; IR-NEXT:    [[MIN:%.*]] = alloca [9 x float], align 4
; IR-NEXT:    [[MIN_VEC:%.*]] = alloca [2 x [9 x float]], align 4
; IR-NEXT:    [[MIN_VEC_BC:%.*]] = bitcast [2 x [9 x float]]* [[MIN_VEC]] to [9 x float]*
; IR-NEXT:    [[MIN_VEC_BASE_ADDR:%.*]] = getelementptr [9 x float], [9 x float]* [[MIN_VEC_BC]], <2 x i32> <i32 0, i32 1>
; IR-NEXT:    [[MIN_VEC_BASE_ADDR_EXTRACT_1_:%.*]] = extractelement <2 x [9 x float]*> [[MIN_VEC_BASE_ADDR]], i32 1
; IR-NEXT:    [[MIN_VEC_BASE_ADDR_EXTRACT_0_:%.*]] = extractelement <2 x [9 x float]*> [[MIN_VEC_BASE_ADDR]], i32 0
; IR-NEXT:    br label [[FILL_MIN:%.*]]

; IR:       VPlannedBB2:
; IR:         [[ARR_RED_BASE_ADDR_BC:%.*]] = bitcast [9 x float]* [[MIN_VEC_BASE_ADDR_EXTRACT_0_]] to float*
; IR-NEXT:    br label [[ARRAY_REDN_INIT_LOOP:%.*]]
; IR:       array.redn.init.loop:
; IR-NEXT:    [[CUR_ELEM_IDX:%.*]] = phi i64 [ 0, [[VPLANNEDBB2:%.*]] ], [ [[NEXT_ELEM_IDX:%.*]], [[ARRAY_REDN_INIT_LOOP]] ]
; IR-NEXT:    [[CUR_ELEM_PTR:%.*]] = getelementptr float, float* [[ARR_RED_BASE_ADDR_BC]], i64 [[CUR_ELEM_IDX]]
; IR-NEXT:    store float 0x7FF0000000000000, float* [[CUR_ELEM_PTR]], align 4
; IR-NEXT:    [[NEXT_ELEM_IDX]] = add i64 [[CUR_ELEM_IDX]], 1
; IR-NEXT:    [[INITLOOP_COND:%.*]] = icmp ult i64 [[NEXT_ELEM_IDX]], 18
; IR-NEXT:    br i1 [[INITLOOP_COND]], label [[ARRAY_REDN_INIT_LOOP]], label [[ARRAY_REDN_INIT_LOOPEXIT:%.*]]

; IR:       array.redn.final.main.loop:
; IR-NEXT:    [[MAIN_ELEM_IDX:%.*]] = phi i64 [ 0, [[VPLANNEDBB4:%.*]] ], [ [[NEXT_MAIN_ELEM_IDX:%.*]], [[ARRAY_REDN_FINAL_MAIN_LOOP:%.*]] ]
; IR-NEXT:    [[ORIG_ARR_GEP:%.*]] = getelementptr [9 x float], [9 x float]* [[MIN]], i64 0, i64 [[MAIN_ELEM_IDX]]
; IR-NEXT:    [[ORIG_ARR_BC:%.*]] = bitcast float* [[ORIG_ARR_GEP]] to <4 x float>*
; IR-NEXT:    [[ORIG_ARR_LD:%.*]] = load <4 x float>, <4 x float>* [[ORIG_ARR_BC]], align 4
; IR-NEXT:    [[PRIV_ARR_GEP_LANE0:%.*]] = getelementptr [9 x float], [9 x float]* [[MIN_VEC_BASE_ADDR_EXTRACT_0_]], i64 0, i64 [[MAIN_ELEM_IDX]]
; IR-NEXT:    [[PRIV_ARR_BC_LANE0:%.*]] = bitcast float* [[PRIV_ARR_GEP_LANE0]] to <4 x float>*
; IR-NEXT:    [[PRIV_ARR_LD_LANE0:%.*]] = load <4 x float>, <4 x float>* [[PRIV_ARR_BC_LANE0]], align 4
; IR-NEXT:    [[ARR_FIN_RED:%.*]] = call fast <4 x float> @llvm.minnum.v4f32(<4 x float> [[ORIG_ARR_LD]], <4 x float> [[PRIV_ARR_LD_LANE0]])
; IR-NEXT:    [[PRIV_ARR_GEP_LANE1:%.*]] = getelementptr [9 x float], [9 x float]* [[MIN_VEC_BASE_ADDR_EXTRACT_1_]], i64 0, i64 [[MAIN_ELEM_IDX]]
; IR-NEXT:    [[PRIV_ARR_BC_LANE1:%.*]] = bitcast float* [[PRIV_ARR_GEP_LANE1]] to <4 x float>*
; IR-NEXT:    [[PRIV_ARR_LD_LANE1:%.*]] = load <4 x float>, <4 x float>* [[PRIV_ARR_BC_LANE1]], align 4
; IR-NEXT:    [[ARR_FIN_RED5:%.*]] = call fast <4 x float> @llvm.minnum.v4f32(<4 x float> [[ARR_FIN_RED]], <4 x float> [[PRIV_ARR_LD_LANE1]])
; IR-NEXT:    store <4 x float> [[ARR_FIN_RED5]], <4 x float>* [[ORIG_ARR_BC]], align 4
; IR-NEXT:    [[NEXT_MAIN_ELEM_IDX]] = add i64 [[MAIN_ELEM_IDX]], 4
; IR-NEXT:    [[FINAL_MAINLOOP_COND:%.*]] = icmp ult i64 [[NEXT_MAIN_ELEM_IDX]], 8
; IR-NEXT:    br i1 [[FINAL_MAINLOOP_COND]], label [[ARRAY_REDN_FINAL_MAIN_LOOP]], label [[ARRAY_REDN_FINAL_REM_LOOP:%.*]]
; IR:       array.redn.final.rem.loop:
; IR-NEXT:    [[REM_ELEM_IDX:%.*]] = phi i64 [ 8, [[ARRAY_REDN_FINAL_MAIN_LOOP]] ], [ [[NEXT_REM_ELEM_IDX:%.*]], [[ARRAY_REDN_FINAL_REM_LOOP]] ]
; IR-NEXT:    [[ORIG_ARR_GEP6:%.*]] = getelementptr [9 x float], [9 x float]* [[MIN]], i64 0, i64 [[REM_ELEM_IDX]]
; IR-NEXT:    [[ORIG_ARR_LD7:%.*]] = load float, float* [[ORIG_ARR_GEP6]], align 4
; IR-NEXT:    [[PRIV_ARR_GEP_LANE08:%.*]] = getelementptr [9 x float], [9 x float]* [[MIN_VEC_BASE_ADDR_EXTRACT_0_]], i64 0, i64 [[REM_ELEM_IDX]]
; IR-NEXT:    [[PRIV_ARR_LD_LANE09:%.*]] = load float, float* [[PRIV_ARR_GEP_LANE08]], align 4
; IR-NEXT:    [[ARR_FIN_RED10:%.*]] = call fast float @llvm.minnum.f32(float [[ORIG_ARR_LD7]], float [[PRIV_ARR_LD_LANE09]])
; IR-NEXT:    [[PRIV_ARR_GEP_LANE111:%.*]] = getelementptr [9 x float], [9 x float]* [[MIN_VEC_BASE_ADDR_EXTRACT_1_]], i64 0, i64 [[REM_ELEM_IDX]]
; IR-NEXT:    [[PRIV_ARR_LD_LANE112:%.*]] = load float, float* [[PRIV_ARR_GEP_LANE111]], align 4
; IR-NEXT:    [[ARR_FIN_RED13:%.*]] = call fast float @llvm.minnum.f32(float [[ARR_FIN_RED10]], float [[PRIV_ARR_LD_LANE112]])
; IR-NEXT:    store float [[ARR_FIN_RED13]], float* [[ORIG_ARR_GEP6]], align 4
; IR-NEXT:    [[NEXT_REM_ELEM_IDX]] = add i64 [[REM_ELEM_IDX]], 1
; IR-NEXT:    [[FINAL_REMLOOP_COND:%.*]] = icmp ult i64 [[NEXT_REM_ELEM_IDX]], 9
; IR-NEXT:    br i1 [[FINAL_REMLOOP_COND]], label [[ARRAY_REDN_FINAL_REM_LOOP]], label [[ARRAY_REDN_FINAL_EXIT:%.*]]
;
; Checks for code generated by HIR vectorizer.
; HIR-LABEL: Function: test
; HIR:           BEGIN REGION { modified }
; HIR:                %arr.red.base.addr.bc = bitcast.[9 x float]*.float*(&(([9 x float]*)(%priv.mem)[0]));
; HIR:                 + DO i1 = 0, 17, 1   <DO_LOOP>
; HIR-NEXT:            |   (float*)(%arr.red.base.addr.bc)[i1] = 0x7FF0000000000000;
; HIR-NEXT:            + END LOOP

; HIR:                 %extract.1. = extractelement &((<2 x [9 x float]*>)(%priv.mem.bc)[<i32 0, i32 1>]),  1;
; HIR-NEXT:            %priv.arr.copy0 = &(([9 x float]*)(%priv.mem)[0]);
; HIR:                 + DO i1 = 0, 7, 4   <DO_LOOP>
; HIR-NEXT:            |   %orig.arr.ld = (<4 x float>*)(%min)[0][i1];
; HIR-NEXT:            |   %priv.arr.ld.lane0 = (<4 x float>*)(%priv.arr.copy0)[0][i1];
; HIR-NEXT:            |   %arr.fin.red = @llvm.minnum.v4f32(%orig.arr.ld,  %priv.arr.ld.lane0);
; HIR-NEXT:            |   %priv.arr.ld.lane1 = (<4 x float>*)(%extract.1.)[0][i1];
; HIR-NEXT:            |   %arr.fin.red8 = @llvm.minnum.v4f32(%arr.fin.red,  %priv.arr.ld.lane1);
; HIR-NEXT:            |   (<4 x float>*)(%min)[0][i1] = %arr.fin.red8;
; HIR-NEXT:            + END LOOP

; HIR:                 %extract.1.13 = extractelement &((<2 x [9 x float]*>)(%priv.mem.bc)[<i32 0, i32 1>]),  1;
; HIR-NEXT:            %priv.arr.copy010 = &(([9 x float]*)(%priv.mem)[0]);
; HIR:                 + DO i1 = 8, 8, 1   <DO_LOOP>
; HIR-NEXT:            |   %orig.arr.ld9 = (float*)(%min)[0][i1];
; HIR-NEXT:            |   %priv.arr.ld.lane011 = (float*)(%priv.arr.copy010)[0][i1];
; HIR-NEXT:            |   %arr.fin.red12 = @llvm.minnum.f32(%orig.arr.ld9,  %priv.arr.ld.lane011);
; HIR-NEXT:            |   %priv.arr.ld.lane114 = (float*)(%extract.1.13)[0][i1];
; HIR-NEXT:            |   %arr.fin.red15 = @llvm.minnum.f32(%arr.fin.red12,  %priv.arr.ld.lane114);
; HIR-NEXT:            |   (float*)(%min)[0][i1] = %arr.fin.red15;
; HIR-NEXT:            + END LOOP
; HIR:           END REGION
;
entry:
  %min = alloca [9 x float], align 4
  br label %fill.min

fill.min:
  %arr.begin = getelementptr inbounds [9 x float], [9 x float]* %min, i32 0, i32 0
  %arr.end = getelementptr float, float* %arr.begin, i32 9
  %red.init.isempty = icmp eq float* %arr.begin, %arr.end
  br i1 %red.init.isempty, label %begin.simd.1, label %red.init.body

red.init.body:
  %red.curr.ptr = phi float* [ %arr.begin, %fill.min ], [ %red.next.ptr, %red.init.body ]
  store float %init, float* %red.curr.ptr, align 4
  %red.next.ptr = getelementptr inbounds float, float* %red.curr.ptr, i32 1
  %red.init.done = icmp eq float* %red.next.ptr, %arr.end
  br i1 %red.init.done, label %begin.simd.1, label %red.init.body

begin.simd.1:
  br label %begin.simd

begin.simd:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.MIN:TYPED"([9 x float]* %min, float 0.000000e+00, i32 9) ]
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %begin.simd ]
  %arrayidx = getelementptr inbounds float, float* %A, i64 %indvars.iv
  %A.i = load float, float* %arrayidx, align 4
  %min.gep = getelementptr inbounds [9 x float], [9 x float]* %min, i64 0, i64 %indvars.iv
  %min.ld = load float, float* %min.gep, align 4
  %cmp = fcmp fast olt float %A.i, %min.ld
  %select = select fast i1 %cmp, float %A.i, float %min.ld
  store float %select, float* %min.gep, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp slt i64 %indvars.iv.next, %N
  br i1 %exitcond, label %for.body, label %for.cond.cleanup.loopexit

for.cond.cleanup.loopexit:                             ; preds = %for.body
  br label %end.simd

end.simd:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.QUAL.LIST.END.3

DIR.QUAL.LIST.END.3:
  %fin.gep = getelementptr inbounds [9 x float], [9 x float]* %min, i32 0, i32 9
  %fin = load float, float* %fin.gep, align 4
  ret float %fin

}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
