; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -disable-output -passes="vplan-vec" -vplan-print-after-initial-transforms -vplan-entities-dump -disable-vplan-codegen -vplan-force-vf=2 -vplan-force-inscan-reduction-vectorization=true -S < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

;; float foo(float *A, float *B) {
;;   float x = 1.0f;
;; #pragma omp simd reduction(inscan, max : x)
;; #pragma nounroll
;;   for (int i=0; i<1024; i++) {
;;     B[i] = x;
;; #pragma omp scan exclusive(x)
;;     x = std::max(A[i], x);
;;   }
;;   return x;
;; }

define float @_Z3fooPfS_(ptr %A, ptr %B) {
; CHECK-LABEL:  Reduction list
; CHECK-NEXT:   (FloatMax) Start: ptr [[X_RED0:%.*]]
; CHECK-NEXT:    Linked values: ptr [[VP_X_RED:%.*]], float [[VP_X_REDINSCAN_RED_INIT:%.*]], void [[VP_STORE:%.*]], float [[VP_X_REDINSCAN_RED_FINAL:%.*]],
; CHECK-NEXT:    inscan ReductionKind: exclusive
; CHECK-NEXT:   Memory: ptr [[X_RED0]]
; CHECK-EMPTY:
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK:          float [[VP_LOAD:%.*]] = load ptr [[X_RED0]]
; CHECK-NEXT:     ptr [[VP_X_RED]] = allocate-priv ptr, OrigAlign = 4
; CHECK:          float [[VP_LOAD_1:%.*]] = load ptr [[X_RED0]]
; CHECK:          float [[VP_X_REDINSCAN_RED_INIT]] = reduction-init-scalar float [[VP_LOAD_1]] float [[VP_LOAD_2:%.*]]
; CHECK:          br [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], new_latch
; CHECK-NEXT:     i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], new_latch ],  [ i64 [[VP_INDVARS_IV_IND_INIT:%.*]], [[BB2]] ]
; CHECK-NEXT:     float [[VP_INSCAN_ACCUM:%.*]] = phi  [ float [[VP_X_REDINSCAN_RED_INIT]], [[BB2]] ],  [ float [[VP1:%.*]], new_latch ]
; CHECK-NEXT:     i32 [[VP2:%.*]] = phi  [ i32 [[VP_I_LINEAR_IV_IND_INIT:%.*]], [[BB2]] ],  [ i32 [[VP3:%.*]], new_latch ]
; CHECK-NEXT:     store i32 [[VP2]] ptr [[VP_I_LINEAR_IV:%.*]]
; CHECK-NEXT:     store float [[VP_LOAD]] ptr [[VP_X_RED]]
; CHECK-NEXT:     br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     i32 [[VP0:%.*]] = trunc i64 [[VP_INDVARS_IV]] to i32
; CHECK-NEXT:     store i32 [[VP0]] ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     i32 [[VP4:%.*]] = load ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     i64 [[VP_IDXPROM1:%.*]] = sext i32 [[VP4]] to i64
; CHECK-NEXT:     ptr [[VP_ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[A0:%.*]] i64 [[VP_IDXPROM1]]
; CHECK-NEXT:     float [[VP5:%.*]] = load ptr [[VP_ARRAYIDX2]]
; CHECK-NEXT:     float [[VP6:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     i1 [[VP_CMP_I:%.*]] = fcmp olt float [[VP5]] float [[VP6]]
; CHECK-NEXT:     float [[VP7:%.*]] = select i1 [[VP_CMP_I]] float [[VP6]] float [[VP5]]
; CHECK-NEXT:     store float [[VP7]] ptr [[VP_X_RED]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     i32 [[VP3]] = add i32 [[VP2]] i32 [[VP_I_LINEAR_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:     br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     float [[VP_LOAD_4:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP_EXCL_SCAN:%.*]] = running-exclusive-reduction{fmax} float [[VP_LOAD_4]] float [[VP_INSCAN_ACCUM]] float [[VP_LOAD]]
; CHECK-NEXT:     store float [[VP_EXCL_SCAN]] ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP8:%.*]] = extract-last-vector-lane float [[VP_EXCL_SCAN]]
; CHECK-NEXT:     float [[VP9:%.*]] = extract-last-vector-lane float [[VP_LOAD_4]]
; CHECK-NEXT:     float [[VP1]] = fmax float [[VP8]] float [[VP9]]
; CHECK-NEXT:     br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     br [[BB11:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]: # preds: [[BB10]]
; CHECK-NEXT:     float [[VP10:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     ptr [[VP_ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[B0:%.*]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     store float [[VP10]] ptr [[VP_ARRAYIDX]]
; CHECK-NEXT:     br new_latch
; CHECK-EMPTY:
; CHECK-NEXT:    new_latch: # preds: [[BB11]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:     i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT:%.*]]
; CHECK-NEXT:     br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB12:BB[0-9]+]], [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]: # preds: new_latch
; CHECK-NEXT:     float [[VP_X_REDINSCAN_RED_FINAL]] = reduction-final-inscan float [[VP1]]
; CHECK-NEXT:     store float [[VP_X_REDINSCAN_RED_FINAL]] ptr [[X_RED0]]
;
DIR.OMP.SIMD.1:
  %x.red = alloca float, align 4
  %i.linear.iv = alloca i32, align 4
  store float 1.000000e+00, ptr %x.red, align 4
  br label %DIR.OMP.SIMD.127

DIR.OMP.SIMD.127:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.MAX:INSCAN.TYPED"(ptr %x.red, float 0.000000e+00, i32 1, i64 1), "QUAL.OMP.NORMALIZED.IV:TYPED"(i8* null, i32 0), "QUAL.OMP.NORMALIZED.UB:TYPED"(i8* null, i32 0), "QUAL.OMP.LINEAR:IV.TYPED"(ptr %i.linear.iv, i32 0, i32 1, i32 1) ]
  br label %DIR.VPO.END.GUARD.MEM.MOTION.426

DIR.VPO.END.GUARD.MEM.MOTION.426:                 ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.4, %DIR.OMP.SIMD.127
  %indvars.iv = phi i64 [ %indvars.iv.next, %DIR.VPO.END.GUARD.MEM.MOTION.4 ], [ 0, %DIR.OMP.SIMD.127 ]
  br label %DIR.VPO.GUARD.MEM.MOTION.2.split

DIR.VPO.GUARD.MEM.MOTION.2.split:                 ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.426
  %guard.start = call token @llvm.directive.region.entry() [ "DIR.VPO.GUARD.MEM.MOTION"(), "QUAL.OMP.LIVEIN"(ptr %x.red) ]
  br label %DIR.VPO.GUARD.MEM.MOTION.1

DIR.VPO.GUARD.MEM.MOTION.1:                       ; preds = %DIR.VPO.GUARD.MEM.MOTION.2.split
  %1 = trunc i64 %indvars.iv to i32
  store i32 %1, ptr %i.linear.iv, align 4
  %2 = load float, ptr %x.red, align 4
  %arrayidx = getelementptr inbounds float, ptr %B, i64 %indvars.iv
  store float %2, ptr %arrayidx, align 4
  br label %DIR.OMP.SCAN.4

DIR.OMP.SCAN.4:                                   ; preds = %DIR.VPO.GUARD.MEM.MOTION.1
  %3 = call token @llvm.directive.region.entry() [ "DIR.OMP.SCAN"(), "QUAL.OMP.EXCLUSIVE"(ptr %x.red, i64 1) ]
  br label %DIR.OMP.SCAN.2

DIR.OMP.SCAN.2:                                   ; preds = %DIR.OMP.SCAN.4
  fence acq_rel
  br label %DIR.OMP.END.SCAN.6

DIR.OMP.END.SCAN.6:                               ; preds = %DIR.OMP.SCAN.2
  call void @llvm.directive.region.exit(token %3) [ "DIR.OMP.END.SCAN"() ]
  br label %DIR.OMP.END.SCAN.3

DIR.OMP.END.SCAN.3:                               ; preds = %DIR.OMP.END.SCAN.6
  %4 = load i32, ptr %i.linear.iv, align 4
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds float, ptr %A, i64 %idxprom1
  %5 = load float, ptr %arrayidx2, align 4
  %6 = load float, ptr %x.red, align 4
  %cmp.i = fcmp fast olt float %5, %6
  %7 = select i1 %cmp.i, float %6, float %5
  store float %7, ptr %x.red, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %DIR.VPO.END.GUARD.MEM.MOTION.8

DIR.VPO.END.GUARD.MEM.MOTION.8:                   ; preds = %DIR.OMP.END.SCAN.3
  call void @llvm.directive.region.exit(token %guard.start) [ "DIR.VPO.END.GUARD.MEM.MOTION"() ]
  br label %DIR.VPO.END.GUARD.MEM.MOTION.4

DIR.VPO.END.GUARD.MEM.MOTION.4:                   ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.8
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.5, label %DIR.VPO.END.GUARD.MEM.MOTION.426

DIR.OMP.END.SIMD.5:                               ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.4
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.529

DIR.OMP.END.SIMD.529:                             ; preds = %DIR.OMP.END.SIMD.5
  %8 = load float, ptr %x.red, align 4
  ret float %8
}

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)
