; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt %s -S -passes=vplan-vec -vplan-nested-simd-strategy=innermost -vplan-force-vf=2 | FileCheck %s --check-prefix=INNER
; RUN: opt %s -S -passes=vplan-vec -vplan-nested-simd-strategy=frominside -vplan-force-vf=2 | FileCheck %s

; RUN: opt %s -disable-output -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -vplan-nested-simd-strategy=innermost -vplan-force-vf=2 2>&1 | FileCheck %s --check-prefix=HIR-INNER
; RUN: opt %s -disable-output -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -vplan-nested-simd-strategy=frominside -vplan-force-vf=2 2>&1 | FileCheck %s --check-prefix=HIR

define void @foo(ptr %a) {
; INNER-LABEL: define void @foo
;
; Main loop
;
; INNER:       vector.body:
; INNER-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VPLANNEDBB1:%.*]] ], [ [[TMP3:%.*]], [[VECTOR_BODY:%.*]] ]
; INNER-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VPLANNEDBB1]] ], [ [[TMP2:%.*]], [[VECTOR_BODY]] ]
; INNER-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[INDEX:%.*]], align 8
; INNER-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr i32, ptr [[TMP0]], i32 [[UNI_PHI]]
; INNER-NEXT:    [[TMP1:%.*]] = add <2 x i32> [[BROADCAST_SPLAT:%.*]], [[VEC_PHI]]
; INNER-NEXT:    store <2 x i32> [[TMP1]], ptr [[SCALAR_GEP]], align 4
; INNER-NEXT:    [[TMP2]] = add nuw nsw <2 x i32> [[VEC_PHI]], <i32 2, i32 2>
; INNER-NEXT:    [[TMP3]] = add nuw nsw i32 [[UNI_PHI]], 2
; INNER-NEXT:    [[TMP4:%.*]] = icmp uge i32 [[TMP3]], 64
; INNER-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB3:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
;
; CHECK-LABEL: define void @foo
;
; Main loop (re-vectorized)
;
; CHECK:       VPlannedBB15:
; CHECK-NEXT:    [[UNI_PHI16:%.*]] = phi i32 [ 0, [[VPLANNEDBB14:%.*]] ], [ [[TMP3:%.*]], [[VPLANNEDBB15:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI17:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VPLANNEDBB14]] ], [ [[TMP2:%.*]], [[VPLANNEDBB15]] ]
; CHECK-NEXT:    [[REPLICATEDVAL_UNI_PHI17UNI_PHI17:%.*]] = shufflevector <2 x i32> [[UNI_PHI17]], <2 x i32> undef, <4 x i32> <i32 0, i32 1, i32 0, i32 1>
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT18:%.*]] = insertelement <2 x i32> poison, i32 [[UNI_PHI16]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT19:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT18]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x ptr>, ptr [[SCALAR_GEP11:%.*]], align 8
; CHECK-NEXT:    [[MM_VECTORGEP:%.*]] = getelementptr i32, <2 x ptr> [[WIDE_LOAD]], <2 x i32> [[BROADCAST_SPLAT19]]
; CHECK-NEXT:    [[TMP1:%.*]] = add <4 x i32> [[TMP0:%.*]], [[REPLICATEDVAL_UNI_PHI17UNI_PHI17]]
; CHECK-NEXT:    [[VECBASEPTR_MM_VECTORGEP:%.*]] = shufflevector <2 x ptr> [[MM_VECTORGEP]], <2 x ptr> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[ELEMBASEPTR_:%.*]] = getelementptr i32, <4 x ptr> [[VECBASEPTR_MM_VECTORGEP]], <4 x i64> <i64 0, i64 1, i64 0, i64 1>
; CHECK-NEXT:    call void @llvm.masked.scatter.v4i32.v4p0(<4 x i32> [[TMP1]], <4 x ptr> [[ELEMBASEPTR_]], i32 4, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
; CHECK-NEXT:    [[TMP2]] = add <2 x i32> [[UNI_PHI17]], <i32 2, i32 2>
; CHECK-NEXT:    [[TMP3]] = add i32 [[UNI_PHI16]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = icmp uge i32 [[TMP3]], 64
; CHECK-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB20:%.*]], label [[VPLANNEDBB15]]
;
; HIR-INNER:      BEGIN REGION { modified }
; HIR-INNER-NEXT:       + DO i1 = 0, 31, 1   <DO_LOOP>
; HIR-INNER-NEXT:       |   + DO i2 = 0, 63, 2   <DO_LOOP> <simd-vectorized> <novectorize>
; HIR-INNER-NEXT:       |   |   %.unifload = (ptr)(%a)[i1];
; HIR-INNER-NEXT:       |   |   (<2 x i32>*)(%.unifload)[i2] = i1 + i2 + <i32 0, i32 1>;
; HIR-INNER-NEXT:       |   + END LOOP
; HIR-INNER-NEXT:       + END LOOP
; HIR-INNER-NEXT: END REGION
;
; HIR:      BEGIN REGION { modified }
; HIR-NEXT:       + DO i1 = 0, 31, 2   <DO_LOOP> <simd-vectorized> <novectorize>
; HIR-NEXT:       |   %phi.temp = 0;
; HIR-NEXT:       |
; HIR-NEXT:       |   + DO i2 = 0, 31, 1   <DO_LOOP> <novectorize>
; HIR-NEXT:       |   |   %.vec = (<2 x ptr>*)(%a)[i1];
; HIR-NEXT:       |   |   %wide.insert = shufflevector i1 + <i32 0, i32 1>,  undef,  <i32 0, i32 undef, i32 1, i32 undef>;
; HIR-NEXT:       |   |   %shuffle = shufflevector %wide.insert,  poison,  <i64 0, i64 0, i64 2, i64 2>;
; HIR-NEXT:       |   |   %wide.insert3 = shufflevector i2,  undef,  <i32 0, i32 undef, i32 1, i32 undef>;
; HIR-NEXT:       |   |   %extractsubvec. = shufflevector %wide.insert3,  undef,  <i32 0, i32 1>;
; HIR-NEXT:       |   |   %shuffle4 = shufflevector %extractsubvec.,  poison,  zeroinitializer;
; HIR-NEXT:       |   |   %.replicated = shufflevector %shuffle4,  undef,  <i32 0, i32 1, i32 0, i32 1>;
; HIR-NEXT:       |   |   %.vec5 = <i32 2, i32 2, i32 2, i32 2>  *  %.replicated;
; HIR-NEXT:       |   |   %.scal = <i32 2, i32 2>  *  %shuffle4;
; HIR-NEXT:       |   |   %.vec6 = 2  *  i2;
; HIR-NEXT:       |   |   %.scal7 = 2  *  i2;
; HIR-NEXT:       |   |   %.replicated.elts = shufflevector &((<2 x ptr>)(%.vec)[%.vec6]),  undef,  <i32 0, i32 0, i32 1, i32 1>;
; HIR-NEXT:       |   |   (<4 x i32>*)(%.replicated.elts)[<i64 0, i64 1, i64 0, i64 1>] = %shuffle + <i32 0, i32 1, i32 0, i32 1> + %.vec5;
; HIR-NEXT:       |   |   %.vec8 = i2 + 1 < 32;
; HIR-NEXT:       |   |   %phi.temp = i2 + 1;
; HIR-NEXT:       |   + END LOOP
; HIR-NEXT:       + END LOOP
; HIR-NEXT: END REGION
;
entry:
  br label %header

header:
  %token = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %body

body:
  %i = phi i32 [ 0, %header ], [ %i.next, %exit.inner ]
  %index = getelementptr ptr, ptr %a, i32 %i
  br label %header.inner

header.inner:
  %token.inner = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %body.inner

body.inner:
  %j = phi i32 [ 0, %header.inner ], [ %j.next, %body.inner ]

  ; Uniform load inside the innermost loop
  %arr = load ptr, ptr %index

  %index.inner = getelementptr i32, ptr %arr, i32 %j
  %val = add i32 %i, %j
  store i32 %val, ptr %index.inner

  %j.next = add i32 %j, 1
  %cmp.inner = icmp eq i32 %j.next, 64
  br i1 %cmp.inner, label %latch.inner, label %body.inner

latch.inner:
  call void @llvm.directive.region.exit(token %token.inner) [ "DIR.OMP.END.SIMD"() ]
  br label %exit.inner

exit.inner:
  %i.next = add i32 %i, 1
  %cmp = icmp eq i32 %i.next, 32
  br i1 %cmp, label %latch, label %body

latch:
  call void @llvm.directive.region.exit(token %token) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
