; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt %s -S -passes=vplan-vec -vplan-nested-simd-strategy=innermost -vplan-force-vf=2 | FileCheck %s --check-prefix=INNER
; RUN: opt %s -S -passes=vplan-vec -vplan-nested-simd-strategy=frominside -vplan-force-vf=2 | FileCheck %s

define i32 @foo(ptr %a, i32 %n) {
; INNER-LABEL: define i32 @foo
;
; Main loop
;
; INNER:       vector.body:
; INNER-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VPLANNEDBB2:%.*]] ], [ [[TMP5:%.*]], [[VECTOR_BODY:%.*]] ]
; INNER-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VPLANNEDBB2]] ], [ [[TMP4:%.*]], [[VECTOR_BODY]] ]
; INNER-NEXT:    [[VEC_PHI4:%.*]] = phi <2 x i32> [ zeroinitializer, [[VPLANNEDBB2]] ], [ [[TMP3:%.*]], [[VECTOR_BODY]] ]
; INNER-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr i32, ptr [[ARR:%.*]], i32 [[UNI_PHI]]
; INNER-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, ptr [[SCALAR_GEP]], align 4
; INNER-NEXT:    [[TMP3]] = add <2 x i32> [[VEC_PHI4]], [[WIDE_LOAD]]
; INNER-NEXT:    [[TMP4]] = add nuw nsw <2 x i32> [[VEC_PHI]], <i32 2, i32 2>
; INNER-NEXT:    [[TMP5]] = add nuw nsw i32 [[UNI_PHI]], 2
; INNER-NEXT:    [[TMP6:%.*]] = icmp uge i32 [[TMP5]], [[TMP2:%.*]]
; INNER-NEXT:    br i1 [[TMP6]], label [[VPLANNEDBB5:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; INNER:       VPlannedBB5:
; INNER-NEXT:    [[TMP7:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP3]])
; INNER-NEXT:    [[TMP8:%.*]] = mul i32 1, [[TMP2]]
; INNER-NEXT:    [[TMP9:%.*]] = add i32 0, [[TMP8]]
; INNER-NEXT:    br label [[VPLANNEDBB6:%.*]]
;
; Remainder
;
; INNER:       body.inner:
; INNER-NEXT:    [[J:%.*]] = phi i32 [ [[UNI_PHI9:%.*]], [[REMBLK13:%.*]] ], [ [[J_NEXT:%.*]], [[BODY_INNER:%.*]] ]
; INNER-NEXT:    [[SUM:%.*]] = phi i32 [ [[UNI_PHI8:%.*]], [[REMBLK13]] ], [ [[SUM_NEXT:%.*]], [[BODY_INNER]] ]
; INNER-NEXT:    [[INDEX_INNER:%.*]] = getelementptr i32, ptr [[ARR]], i32 [[J]]
; INNER-NEXT:    [[VAL:%.*]] = load i32, ptr [[INDEX_INNER]], align 4
; INNER-NEXT:    [[SUM_NEXT]] = add i32 [[SUM]], [[VAL]]
; INNER-NEXT:    [[J_NEXT]] = add i32 [[J]], 1
; INNER-NEXT:    [[CMP_INNER:%.*]] = icmp eq i32 [[J_NEXT]], [[N:%.*]]
; INNER-NEXT:    br i1 [[CMP_INNER]], label [[VPLANNEDBB10:%.*]], label [[BODY_INNER]], !llvm.loop [[LOOP2:![0-9]+]]
;
; CHECK-LABEL: define i32 @foo
;
; Main loop (re-vectorized)
;
; CHECK:       VPlannedBB25:
; CHECK-NEXT:    [[UNI_PHI26:%.*]] = phi i32 [ 0, [[VPLANNEDBB24:%.*]] ], [ [[TMP5:%.*]], [[VPLANNEDBB25:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI27:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VPLANNEDBB24]] ], [ [[TMP4:%.*]], [[VPLANNEDBB25]] ]
; CHECK-NEXT:    [[VEC_PHI28:%.*]] = phi <4 x i32> [ zeroinitializer, [[VPLANNEDBB24]] ], [ [[TMP3:%.*]], [[VPLANNEDBB25]] ]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i32> poison, i32 [[UNI_PHI26]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[MM_VECTORGEP:%.*]] = getelementptr i32, <2 x ptr> [[WIDE_LOAD19:%.*]], <2 x i32> [[BROADCAST_SPLAT]]
; CHECK-NEXT:    [[VECBASEPTR_MM_VECTORGEP:%.*]] = shufflevector <2 x ptr> [[MM_VECTORGEP]], <2 x ptr> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[ELEMBASEPTR_:%.*]] = getelementptr i32, <4 x ptr> [[VECBASEPTR_MM_VECTORGEP]], <4 x i64> <i64 0, i64 1, i64 0, i64 1>
; CHECK-NEXT:    [[WIDE_MASKED_GATHER:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[ELEMBASEPTR_]], i32 4, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> poison)
; CHECK-NEXT:    [[TMP3]] = add <4 x i32> [[VEC_PHI28]], [[WIDE_MASKED_GATHER]]
; CHECK-NEXT:    [[TMP4]] = add <2 x i32> [[UNI_PHI27]], <i32 2, i32 2>
; CHECK-NEXT:    [[TMP5]] = add i32 [[UNI_PHI26]], 2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp uge i32 [[TMP5]], [[TMP2:%.*]]
; CHECK-NEXT:    br i1 [[TMP6]], label [[VPLANNEDBB29:%.*]], label [[VPLANNEDBB25]]
; CHECK:       VPlannedBB29:
; CHECK-NEXT:    [[VEC_PHI30:%.*]] = phi <4 x i32> [ [[TMP3]], [[VPLANNEDBB25]] ]
; CHECK-NEXT:    [[EXTRACTSUBVEC_31:%.*]] = shufflevector <4 x i32> [[VEC_PHI30]], <4 x i32> undef, <2 x i32> <i32 2, i32 3>
; CHECK-NEXT:    [[EXTRACTSUBVEC_:%.*]] = shufflevector <4 x i32> [[VEC_PHI30]], <4 x i32> undef, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP7:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[EXTRACTSUBVEC_]])
; CHECK-NEXT:    [[TMP8:%.*]] = insertelement <2 x i32> undef, i32 [[TMP7]], i32 0
; CHECK-NEXT:    [[TMP9:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[EXTRACTSUBVEC_31]])
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x i32> [[TMP8]], i32 [[TMP9]], i32 1
; CHECK-NEXT:    [[TMP11:%.*]] = mul i32 1, [[TMP2]]
; CHECK-NEXT:    [[TMP12:%.*]] = add i32 0, [[TMP11]]
; CHECK-NEXT:    br label [[VPLANNEDBB32:%.*]]
;
; Remainder (re-vectorized)
;
; CHECK:       VPlannedBB38:
; CHECK-NEXT:    [[UNI_PHI39:%.*]] = phi i32 [ [[UNI_PHI36:%.*]], [[VPLANNEDBB37:%.*]] ], [ [[TMP15:%.*]], [[VPLANNEDBB38:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI40:%.*]] = phi <2 x i32> [ [[VEC_PHI35:%.*]], [[VPLANNEDBB37]] ], [ [[TMP14:%.*]], [[VPLANNEDBB38]] ]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT41:%.*]] = insertelement <2 x i32> poison, i32 [[UNI_PHI39]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT42:%.*]] = shufflevector <2 x i32> [[BROADCAST_SPLATINSERT41]], <2 x i32> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[MM_VECTORGEP43:%.*]] = getelementptr i32, <2 x ptr> [[WIDE_LOAD19]], <2 x i32> [[BROADCAST_SPLAT42]]
; CHECK-NEXT:    [[WIDE_MASKED_GATHER44:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[MM_VECTORGEP43]], i32 4, <2 x i1> <i1 true, i1 true>, <2 x i32> poison)
; CHECK-NEXT:    [[TMP14]] = add <2 x i32> [[VEC_PHI40]], [[WIDE_MASKED_GATHER44]]
; CHECK-NEXT:    [[TMP15]] = add i32 [[UNI_PHI39]], 1
; CHECK-NEXT:    [[TMP16:%.*]] = icmp eq i32 [[TMP15]], [[N:%.*]]
; CHECK-NEXT:    br i1 [[TMP16]], label [[VPLANNEDBB45:%.*]], label [[VPLANNEDBB38]]
;
entry:
  br label %header

header:
  %token = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %body

body:
  %i = phi i32 [ 0, %header ], [ %i.next, %exit.inner ]
  %index = getelementptr ptr, ptr %a, i32 %i
  %arr = load ptr, ptr %index
  br label %header.inner

header.inner:
  %token.inner = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %body.inner

body.inner:
  %j = phi i32 [ 0, %header.inner ], [ %j.next, %body.inner ]
  %sum = phi i32 [ 0, %header.inner ], [ %sum.next, %body.inner ]

  %index.inner = getelementptr i32, ptr %arr, i32 %j
  %val = load i32, ptr %index.inner
  %sum.next = add i32 %sum, %val

  %j.next = add i32 %j, 1
  %cmp.inner = icmp eq i32 %j.next, %n
  br i1 %cmp.inner, label %latch.inner, label %body.inner

latch.inner:
  %sum.next.lcssa = phi i32 [ %sum.next, %body.inner ]
  br label %end.inner

end.inner:
  call void @llvm.directive.region.exit(token %token.inner) [ "DIR.OMP.END.SIMD"() ]
  br label %exit.inner

exit.inner:
  %i.next = add i32 %i, 1
  %cmp = icmp eq i32 %i.next, 32
  br i1 %cmp, label %latch, label %body

latch:
  %res = phi i32 [ %sum.next.lcssa, %exit.inner ]
  br label %end

end:
  call void @llvm.directive.region.exit(token %token) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret i32 %res
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
