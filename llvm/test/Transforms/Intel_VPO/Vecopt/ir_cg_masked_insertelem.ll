; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -VPlanDriver -vplan-force-vf=2 -print-module -disable-output -disable-verify 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare i32 @foo(i32)

; This used to crash by generating broken SSA.
define void @test_predicated_index_operand(i32 *%p, i64 %n) {
; CHECK-LABEL: @test_predicated_index_operand(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[TMP21:%.*]], [[PRED_CALL_CONTINUE6:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI1:%.*]] = phi i64 [ [[TMP20:%.*]], [[PRED_CALL_CONTINUE6]] ], [ 0, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ [[TMP19:%.*]], [[PRED_CALL_CONTINUE6]] ], [ <i64 0, i64 1>, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i64 [[UNI_PHI1]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[SCALAR_GEP]] to <2 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, <2 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_1_:%.*]] = extractelement <2 x i32> [[WIDE_LOAD]], i32 1
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_0_:%.*]] = extractelement <2 x i32> [[WIDE_LOAD]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i32> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    [[TMP2:%.*]] = xor <2 x i1> [[TMP1]], <i1 true, i1 true>
; CHECK-NEXT:    [[PREDICATE:%.*]] = extractelement <2 x i1> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i1 [[PREDICATE]], true
; CHECK-NEXT:    br i1 [[TMP3]], label [[PRED_CALL_IF:%.*]], label [[TMP8:%.*]]
; CHECK:       pred.call.if:
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_0_]])
; FIXME: SSA is broken here - TMP17 is defined much later!
; CHECK-NEXT:    br i1 [[TMP17:%.*]], label [[PRED_INSERTELEMENT_IF:%.*]], label [[TMP6:%.*]]
; CHECK:       pred.insertelement.if:
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[WIDE_LOAD_EXTRACT_0_]], i32 [[TMP4]]
; CHECK-NEXT:    br label [[TMP6]]
; CHECK:       6:
; CHECK-NEXT:    [[TMP7:%.*]] = phi <4 x i32> [ undef, [[PRED_CALL_IF]] ], [ [[TMP5]], [[PRED_INSERTELEMENT_IF]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE:%.*]]
; CHECK:       pred.insertelement.continue:
; CHECK-NEXT:    br label [[TMP8]]
; CHECK:       8:
; CHECK-NEXT:    [[TMP9:%.*]] = phi <4 x i32> [ zeroinitializer, [[VECTOR_BODY:%.*]] ], [ [[TMP7]], [[PRED_INSERTELEMENT_CONTINUE]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE:%.*]]
; CHECK:       pred.call.continue:
; CHECK-NEXT:    [[PREDICATE2:%.*]] = extractelement <2 x i1> [[TMP2]], i64 1
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i1 [[PREDICATE2]], true
; CHECK-NEXT:    br i1 [[TMP10]], label [[PRED_CALL_IF5:%.*]], label [[TMP15:%.*]]
; CHECK:       pred.call.if5:
; CHECK-NEXT:    [[TMP11:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_1_]])
; FIXME: SSA is broken here - TMP18 is defined much later!
; CHECK-NEXT:    br i1 [[TMP18:%.*]], label [[PRED_INSERTELEMENT_IF7:%.*]], label [[TMP13:%.*]]
; CHECK:       pred.insertelement.if7:
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[WIDE_LOAD_EXTRACT_1_]], i32 [[TMP11]]
; CHECK-NEXT:    br label [[TMP13]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = phi <4 x i32> [ undef, [[PRED_CALL_IF5]] ], [ [[TMP12]], [[PRED_INSERTELEMENT_IF7]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE8:%.*]]
; CHECK:       pred.insertelement.continue8:
; CHECK-NEXT:    br label [[TMP15]]
; CHECK:       15:
; CHECK-NEXT:    [[TMP16:%.*]] = phi <4 x i32> [ zeroinitializer, [[PRED_CALL_CONTINUE]] ], [ [[TMP14]], [[PRED_INSERTELEMENT_CONTINUE8]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE6]]
; CHECK:       pred.call.continue6:
; CHECK-NEXT:    [[PREDICATE3:%.*]] = extractelement <2 x i1> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP17]] = icmp eq i1 [[PREDICATE3]], true
; CHECK-NEXT:    [[PREDICATE4:%.*]] = extractelement <2 x i1> [[TMP2]], i64 1
; CHECK-NEXT:    [[TMP18]] = icmp eq i1 [[PREDICATE4]], true
; CHECK-NEXT:    [[TMP19]] = add nuw nsw <2 x i64> [[VEC_PHI]], <i64 2, i64 2>
; CHECK-NEXT:    [[TMP20]] = add nuw nsw i64 [[UNI_PHI1]], 2
; CHECK-NEXT:    [[TMP21]] = add i64 [[UNI_PHI]], 2
; CHECK-NEXT:    [[TMP22:%.*]] = icmp eq i64 [[TMP21]], [[N_VEC:%.*]]
; CHECK-NEXT:    br i1 [[TMP22]], label [[VPLANNEDBB:%.*]], label [[VECTOR_BODY]], !llvm.loop !0
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ %iv.next, %latch ], [ 0, %entry ]
  %gep = getelementptr inbounds i32, i32 *%p, i64 %iv
  %ld = load i32, i32* %gep
  %cond = icmp eq i32 %ld, 0
  br i1 %cond, label %latch, label %masked

masked:
  %pred.op = call i32 @foo(i32 %ld)
  %vecins = insertelement <4 x i32> zeroinitializer, i32 %ld, i32 %pred.op
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %loopexit, label %header

loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @test_predicated_value_operand(i32 *%p, i64 %n) {
; CHECK-LABEL: @test_predicated_value_operand(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[TMP23:%.*]], [[PRED_INSERTELEMENT_CONTINUE8:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI1:%.*]] = phi i64 [ [[TMP22:%.*]], [[PRED_INSERTELEMENT_CONTINUE8]] ], [ 0, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ [[TMP21:%.*]], [[PRED_INSERTELEMENT_CONTINUE8]] ], [ <i64 0, i64 1>, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i64 [[UNI_PHI1]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[SCALAR_GEP]] to <2 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, <2 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_1_:%.*]] = extractelement <2 x i32> [[WIDE_LOAD]], i32 1
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_0_:%.*]] = extractelement <2 x i32> [[WIDE_LOAD]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i32> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    [[TMP2:%.*]] = xor <2 x i1> [[TMP1]], <i1 true, i1 true>
; CHECK-NEXT:    [[PREDICATE:%.*]] = extractelement <2 x i1> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i1 [[PREDICATE]], true
; CHECK-NEXT:    br i1 [[TMP3]], label [[PRED_CALL_IF:%.*]], label [[TMP5:%.*]]
; CHECK:       pred.call.if:
; CHECK-NEXT:    [[TMP4:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_0_]])
; CHECK-NEXT:    br label [[TMP5]]
; CHECK:       5:
; CHECK-NEXT:    [[TMP6:%.*]] = phi i32 [ undef, [[VECTOR_BODY]] ], [ [[TMP4]], [[PRED_CALL_IF]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE:%.*]]
; CHECK:       pred.call.continue:
; CHECK-NEXT:    [[TMP7:%.*]] = insertelement <2 x i32> undef, i32 [[TMP6]], i32 0
; CHECK-NEXT:    [[PREDICATE2:%.*]] = extractelement <2 x i1> [[TMP2]], i64 1
; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i1 [[PREDICATE2]], true
; CHECK-NEXT:    br i1 [[TMP8]], label [[PRED_CALL_IF5:%.*]], label [[TMP10:%.*]]
; CHECK:       pred.call.if5:
; CHECK-NEXT:    [[TMP9:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_1_]])
; CHECK-NEXT:    br label [[TMP10]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = phi i32 [ undef, [[PRED_CALL_CONTINUE]] ], [ [[TMP9]], [[PRED_CALL_IF5]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE6:%.*]]
; CHECK:       pred.call.continue6:
; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <2 x i32> [[TMP7]], i32 [[TMP11]], i32 1
; CHECK-NEXT:    [[PREDICATE3:%.*]] = extractelement <2 x i1> [[TMP2]], i64 0
; CHECK-NEXT:    [[TMP13:%.*]] = icmp eq i1 [[PREDICATE3]], true
; CHECK-NEXT:    br i1 [[TMP13]], label [[PRED_INSERTELEMENT_IF:%.*]], label [[TMP15:%.*]]
; CHECK:       pred.insertelement.if:
; CHECK-NEXT:    [[TMP14:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[TMP6]], i32 [[WIDE_LOAD_EXTRACT_0_]]
; CHECK-NEXT:    br label [[TMP15]]
; CHECK:       15:
; CHECK-NEXT:    [[TMP16:%.*]] = phi <4 x i32> [ undef, [[PRED_CALL_CONTINUE6]] ], [ [[TMP14]], [[PRED_INSERTELEMENT_IF]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE:%.*]]
; CHECK:       pred.insertelement.continue:
; CHECK-NEXT:    [[PREDICATE4:%.*]] = extractelement <2 x i1> [[TMP2]], i64 1
; CHECK-NEXT:    [[TMP17:%.*]] = icmp eq i1 [[PREDICATE4]], true
; CHECK-NEXT:    br i1 [[TMP17]], label [[PRED_INSERTELEMENT_IF7:%.*]], label [[TMP19:%.*]]
; CHECK:       pred.insertelement.if7:
; CHECK-NEXT:    [[TMP18:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[TMP11]], i32 [[WIDE_LOAD_EXTRACT_1_]]
; CHECK-NEXT:    br label [[TMP19]]
; CHECK:       19:
; CHECK-NEXT:    [[TMP20:%.*]] = phi <4 x i32> [ undef, [[PRED_INSERTELEMENT_CONTINUE]] ], [ [[TMP18]], [[PRED_INSERTELEMENT_IF7]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE8]]
; CHECK:       pred.insertelement.continue8:
; CHECK-NEXT:    [[TMP21]] = add nuw nsw <2 x i64> [[VEC_PHI]], <i64 2, i64 2>
; CHECK-NEXT:    [[TMP22]] = add nuw nsw i64 [[UNI_PHI1]], 2
; CHECK-NEXT:    [[TMP23]] = add i64 [[UNI_PHI]], 2
; CHECK-NEXT:    [[TMP24:%.*]] = icmp eq i64 [[TMP23]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[VPLANNEDBB:%.*]], label [[VECTOR_BODY]], !llvm.loop !4
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ %iv.next, %latch ], [ 0, %entry ]
  %gep = getelementptr inbounds i32, i32 *%p, i64 %iv
  %ld = load i32, i32* %gep
  %cond = icmp eq i32 %ld, 0
  br i1 %cond, label %latch, label %masked

masked:
  %pred.op = call i32 @foo(i32 %ld)
  %vecins = insertelement <4 x i32> zeroinitializer, i32 %pred.op, i32 %ld
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %loopexit, label %header

loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}


declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
