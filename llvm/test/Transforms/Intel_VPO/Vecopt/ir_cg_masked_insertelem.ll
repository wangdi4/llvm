; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -passes=vplan-vec -vplan-force-vf=2 -S 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

declare i32 @foo(i32)

; This used to crash by generating broken SSA.
define void @test_predicated_index_operand(ptr %p, i64 %n) {
; CHECK:  define void @test_predicated_index_operand(ptr [[P0:%.*]], i64 [[N0:%.*]]) {
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ [[TMP23:%.*]], [[VPLANNEDBB80:%.*]] ], [ 0, [[VPLANNEDBB20:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i64> [ [[TMP22:%.*]], [[VPLANNEDBB80]] ], [ <i64 0, i64 1>, [[VPLANNEDBB20]] ]
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr inbounds i32, ptr [[P0]], i64 [[UNI_PHI0]]
; CHECK-NEXT:    [[WIDE_LOAD0:%.*]] = load <2 x i32>, ptr [[SCALAR_GEP0]], align 4
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_1_0:%.*]] = extractelement <2 x i32> [[WIDE_LOAD0]], i32 1
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_0_0:%.*]] = extractelement <2 x i32> [[WIDE_LOAD0]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq <2 x i32> [[WIDE_LOAD0]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = xor <2 x i1> [[TMP4]], <i1 true, i1 true>
; CHECK-NEXT:    br label [[VPLANNEDBB40:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB4:
; CHECK-NEXT:    [[PREDICATE0:%.*]] = extractelement <2 x i1> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i1 [[PREDICATE0]], true
; CHECK-NEXT:    br i1 [[TMP6]], label [[PRED_CALL_IF0:%.*]], label [[TMP8:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if:
; CHECK-NEXT:    [[TMP7:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_0_0]])
; CHECK-NEXT:    br label [[TMP8]]
; CHECK-EMPTY:
; CHECK-NEXT:  7:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ undef, [[VPLANNEDBB40]] ], [ [[TMP7]], [[PRED_CALL_IF0]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue:
; CHECK-NEXT:    [[PREDICATE50:%.*]] = extractelement <2 x i1> [[TMP5]], i64 1
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i1 [[PREDICATE50]], true
; CHECK-NEXT:    br i1 [[TMP10]], label [[PRED_CALL_IF150:%.*]], label [[TMP12:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if15:
; CHECK-NEXT:    [[TMP11:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_1_0]])
; CHECK-NEXT:    br label [[TMP12]]
; CHECK-EMPTY:
; CHECK-NEXT:  11:
; CHECK-NEXT:    [[TMP13:%.*]] = phi i32 [ undef, [[PRED_CALL_CONTINUE0]] ], [ [[TMP11]], [[PRED_CALL_IF150]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE160:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue16:
; CHECK-NEXT:    [[PREDICATE60:%.*]] = extractelement <2 x i1> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i1 [[PREDICATE60]], true
; CHECK-NEXT:    br i1 [[TMP14]], label [[PRED_INSERTELEMENT_IF0:%.*]], label [[TMP16:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.if:
; CHECK-NEXT:    [[TMP15:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[WIDE_LOAD_EXTRACT_0_0]], i32 [[TMP9]]
; CHECK-NEXT:    br label [[TMP16]]
; CHECK-EMPTY:
; CHECK-NEXT:  15:
; CHECK-NEXT:    [[TMP17:%.*]] = phi <4 x i32> [ undef, [[PRED_CALL_CONTINUE160]] ], [ [[TMP15]], [[PRED_INSERTELEMENT_IF0]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.continue:
; CHECK-NEXT:    [[PREDICATE70:%.*]] = extractelement <2 x i1> [[TMP5]], i64 1
; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i1 [[PREDICATE70]], true
; CHECK-NEXT:    br i1 [[TMP18]], label [[PRED_INSERTELEMENT_IF170:%.*]], label [[TMP20:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.if17:
; CHECK-NEXT:    [[TMP19:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[WIDE_LOAD_EXTRACT_1_0]], i32 [[TMP13]]
; CHECK-NEXT:    br label [[TMP20]]
; CHECK-EMPTY:
; CHECK-NEXT:  19:
; CHECK-NEXT:    [[TMP21:%.*]] = phi <4 x i32> [ undef, [[PRED_INSERTELEMENT_CONTINUE0]] ], [ [[TMP19]], [[PRED_INSERTELEMENT_IF170]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE180:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.continue18:
; CHECK-NEXT:    br label [[VPLANNEDBB80]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB8:
; CHECK-NEXT:    [[TMP22]] = add nuw nsw <2 x i64> [[VEC_PHI0]], <i64 2, i64 2>
; CHECK-NEXT:    [[TMP23]] = add nuw nsw i64 [[UNI_PHI0]], 2
; CHECK-NEXT:    [[TMP24:%.*]] = icmp uge i64 [[TMP23]], [[TMP2:%.*]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[VPLANNEDBB90:%.*]], label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB9:
; CHECK-NEXT:    [[TMP25:%.*]] = mul i64 1, [[TMP2]]
; CHECK-NEXT:    [[TMP26:%.*]] = add i64 0, [[TMP25]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ %iv.next, %latch ], [ 0, %entry ]
  %gep = getelementptr inbounds i32, ptr %p, i64 %iv
  %ld = load i32, ptr %gep
  %cond = icmp eq i32 %ld, 0
  br i1 %cond, label %latch, label %masked

masked:
  %pred.op = call i32 @foo(i32 %ld)
  %vecins = insertelement <4 x i32> zeroinitializer, i32 %ld, i32 %pred.op
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %loopexit, label %header

loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @test_predicated_value_operand(ptr %p, i64 %n) {
; CHECK:  define void @test_predicated_value_operand(ptr [[P0:%.*]], i64 [[N0:%.*]]) {
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ [[TMP25:%.*]], [[VPLANNEDBB80:%.*]] ], [ 0, [[VPLANNEDBB20:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i64> [ [[TMP24:%.*]], [[VPLANNEDBB80]] ], [ <i64 0, i64 1>, [[VPLANNEDBB20]] ]
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr inbounds i32, ptr [[P0]], i64 [[UNI_PHI0]]
; CHECK-NEXT:    [[WIDE_LOAD0:%.*]] = load <2 x i32>, ptr [[SCALAR_GEP0]], align 4
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_1_0:%.*]] = extractelement <2 x i32> [[WIDE_LOAD0]], i32 1
; CHECK-NEXT:    [[WIDE_LOAD_EXTRACT_0_0:%.*]] = extractelement <2 x i32> [[WIDE_LOAD0]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq <2 x i32> [[WIDE_LOAD0]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = xor <2 x i1> [[TMP4]], <i1 true, i1 true>
; CHECK-NEXT:    br label [[VPLANNEDBB40:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB4:
; CHECK-NEXT:    [[PREDICATE0:%.*]] = extractelement <2 x i1> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i1 [[PREDICATE0]], true
; CHECK-NEXT:    br i1 [[TMP6]], label [[PRED_CALL_IF0:%.*]], label [[TMP8:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if:
; CHECK-NEXT:    [[TMP7:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_0_0]])
; CHECK-NEXT:    br label [[TMP8]]
; CHECK-EMPTY:
; CHECK-NEXT:  7:
; CHECK-NEXT:    [[TMP9:%.*]] = phi i32 [ undef, [[VPLANNEDBB40]] ], [ [[TMP7]], [[PRED_CALL_IF0]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue:
; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x i32> undef, i32 [[TMP9]], i32 0
; CHECK-NEXT:    [[PREDICATE50:%.*]] = extractelement <2 x i1> [[TMP5]], i64 1
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i1 [[PREDICATE50]], true
; CHECK-NEXT:    br i1 [[TMP11]], label [[PRED_CALL_IF150:%.*]], label [[TMP13:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.if15:
; CHECK-NEXT:    [[TMP12:%.*]] = call i32 @foo(i32 [[WIDE_LOAD_EXTRACT_1_0]])
; CHECK-NEXT:    br label [[TMP13]]
; CHECK-EMPTY:
; CHECK-NEXT:  12:
; CHECK-NEXT:    [[TMP14:%.*]] = phi i32 [ undef, [[PRED_CALL_CONTINUE0]] ], [ [[TMP12]], [[PRED_CALL_IF150]] ]
; CHECK-NEXT:    br label [[PRED_CALL_CONTINUE160:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.call.continue16:
; CHECK-NEXT:    [[TMP15:%.*]] = insertelement <2 x i32> [[TMP10]], i32 [[TMP14]], i32 1
; CHECK-NEXT:    [[PREDICATE60:%.*]] = extractelement <2 x i1> [[TMP5]], i64 0
; CHECK-NEXT:    [[TMP16:%.*]] = icmp eq i1 [[PREDICATE60]], true
; CHECK-NEXT:    br i1 [[TMP16]], label [[PRED_INSERTELEMENT_IF0:%.*]], label [[TMP18:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.if:
; CHECK-NEXT:    [[TMP17:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[TMP9]], i32 [[WIDE_LOAD_EXTRACT_0_0]]
; CHECK-NEXT:    br label [[TMP18]]
; CHECK-EMPTY:
; CHECK-NEXT:  17:
; CHECK-NEXT:    [[TMP19:%.*]] = phi <4 x i32> [ undef, [[PRED_CALL_CONTINUE160]] ], [ [[TMP17]], [[PRED_INSERTELEMENT_IF0]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.continue:
; CHECK-NEXT:    [[PREDICATE70:%.*]] = extractelement <2 x i1> [[TMP5]], i64 1
; CHECK-NEXT:    [[TMP20:%.*]] = icmp eq i1 [[PREDICATE70]], true
; CHECK-NEXT:    br i1 [[TMP20]], label [[PRED_INSERTELEMENT_IF170:%.*]], label [[TMP22:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.if17:
; CHECK-NEXT:    [[TMP21:%.*]] = insertelement <4 x i32> zeroinitializer, i32 [[TMP14]], i32 [[WIDE_LOAD_EXTRACT_1_0]]
; CHECK-NEXT:    br label [[TMP22]]
; CHECK-EMPTY:
; CHECK-NEXT:  21:
; CHECK-NEXT:    [[TMP23:%.*]] = phi <4 x i32> [ undef, [[PRED_INSERTELEMENT_CONTINUE0]] ], [ [[TMP21]], [[PRED_INSERTELEMENT_IF170]] ]
; CHECK-NEXT:    br label [[PRED_INSERTELEMENT_CONTINUE180:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  pred.insertelement.continue18:
; CHECK-NEXT:    br label [[VPLANNEDBB80]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB8:
; CHECK-NEXT:    [[TMP24]] = add nuw nsw <2 x i64> [[VEC_PHI0]], <i64 2, i64 2>
; CHECK-NEXT:    [[TMP25]] = add nuw nsw i64 [[UNI_PHI0]], 2
; CHECK-NEXT:    [[TMP26:%.*]] = icmp uge i64 [[TMP25]], [[TMP2]]
; CHECK-NEXT:    br i1 [[TMP26]], label [[VPLANNEDBB90:%.*]], label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB9:
; CHECK-NEXT:    [[TMP27:%.*]] = mul i64 1, [[TMP2]]
; CHECK-NEXT:    [[TMP28:%.*]] = add i64 0, [[TMP27]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ %iv.next, %latch ], [ 0, %entry ]
  %gep = getelementptr inbounds i32, ptr %p, i64 %iv
  %ld = load i32, ptr %gep
  %cond = icmp eq i32 %ld, 0
  br i1 %cond, label %latch, label %masked

masked:
  %pred.op = call i32 @foo(i32 %ld)
  %vecins = insertelement <4 x i32> zeroinitializer, i32 %pred.op, i32 %ld
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %loopexit, label %header

loopexit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}


declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
