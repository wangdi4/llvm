; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check that VPlan HIR decomposer generates correct exit PHI for a
; live-out temp that is also live-in. Since the temp does not have any uses
; inside the loop, VPExternalDef is created for it during Exit PHI creation.
; Also check for correctness of generated vector code.

; Incoming HIR
;      + LiveIn symbases: 3, 7, 10, 11
;      + LiveOut symbases: 3
;      + DO i64 i1 = 0, 68, 1   <DO_LOOP>
;      |   if ((@q)[0][i1 + 1] == 0)
;      |   <RVAL-REG> {al:4}(LINEAR [20 x i32]* @q)[i64 0][LINEAR i64 i1 + 1] inbounds  {sb:14}
;      |      <BLOB> LINEAR [20 x i32]* @q {sb:7}
;      |
;      |   {
;      |      (@s)[0] = %add;
;      |      <LVAL-REG> {al:4}(LINEAR i32* @s)[i64 0] inbounds  {sb:15}
;      |         <BLOB> LINEAR i32* @s {sb:11}
;      |      <RVAL-REG> LINEAR i32 %add {sb:10}
;      |
;      |      %0 = %add;
;      |      <LVAL-REG> LINEAR i32 %add {sb:3}
;      |         <BLOB> LINEAR i32 %add {sb:10}
;      |      <RVAL-REG> LINEAR i32 %add {sb:10}
;      |
;      |   }
;      + END LOOP

; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -disable-output -vplan-print-after-plain-cfg -print-after=hir-vplan-vec < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -disable-output -vplan-print-after-plain-cfg < %s 2>&1 | FileCheck %s


@s = dso_local local_unnamed_addr global i32 0, align 4
@q = dso_local local_unnamed_addr global [20 x i32] zeroinitializer, align 16

define dso_local i32 @main(i32 %add) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: main:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%0}
; CHECK-DAG:     [[VP1:%.*]] = {@s}
; CHECK-DAG:     [[VP2:%.*]] = {%add}
; CHECK-DAG:     [[VP3:%.*]] = {@q}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i32 [[VP4:%.*]] = phi  [ i32 [[TMP0:%.*]], [[BB1]] ],  [ i32 [[VP5:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP8:%.*]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [20 x i32]* @q i64 0 i64 [[VP8]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i1 [[VP9:%.*]] = icmp eq i32 [[VP_LOAD]] i32 0
; CHECK-NEXT:     br i1 [[VP9]], [[BB4:BB[0-9]+]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       store i32 [[ADD0:%.*]] i32* @s
; CHECK-NEXT:       i32 [[VP10:%.*]] = hir-copy i32 [[ADD0]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB2]]
; CHECK-NEXT:     i32 [[VP5]] = phi  [ i32 [[VP10]], [[BB4]] ],  [ i32 [[VP4]], [[BB2]] ]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP11:%.*]] = icmp slt i64 [[VP7]] i64 69
; CHECK-NEXT:     br i1 [[VP11]], [[BB2]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP5]] -> [[VP12:%.*]] = {%0}
;
; CHECK-LABEL:   BEGIN REGION { modified }
; CHECK-NEXT:          %phi.temp = %1;
; CHECK-NEXT:          %phi.temp1 = -1;

; CHECK:               + DO i1 = 0, 67, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; CHECK-NEXT:          |   %.vec = (<4 x i32>*)(@q)[0][i1 + 1];
; CHECK-NEXT:          |   %.vec3 = %.vec == 0;
; CHECK-NEXT:          |   (<4 x i32>*)(@s)[0] = %add; Mask = @{%.vec3}
; CHECK-NEXT:          |   %.copy4 = %add;
; CHECK-NEXT:          |   %select = (%.vec3 == <i1 true, i1 true, i1 true, i1 true>) ? i1 + <i64 0, i64 1, i64 2, i64 3> : %phi.temp1;
; CHECK-NEXT:          |   %select5 = (%.vec3 == <i1 true, i1 true, i1 true, i1 true>) ? %.copy4 : %phi.temp;
; CHECK-NEXT:          |   %phi.temp = %select5;
; CHECK-NEXT:          |   %phi.temp1 = %select;
; CHECK-NEXT:          + END LOOP

; CHECK:               %.vec8 = %select != -1;
; CHECK-NEXT:          %0 = bitcast.<4 x i1>.i4(%.vec8);
; CHECK-NEXT:          %cmp = %0 == 0;
; CHECK-NEXT:          %all.zero.check = %cmp;
; CHECK-NEXT:          %phi.temp9 = %1;
; CHECK-NEXT:          %unifcond = extractelement %all.zero.check,  0;
; CHECK-NEXT:          if (%unifcond == 1)
; CHECK-NEXT:          {
; CHECK-NEXT:             goto BB9.50;
; CHECK-NEXT:          }
; CHECK-NEXT:          %priv.idx.max = @llvm.vector.reduce.smax.v4i64(%select);
; CHECK-NEXT:          %priv.idx.cmp = %select == %priv.idx.max;
; CHECK-NEXT:          %bsfintmask = bitcast.<4 x i1>.i4(%priv.idx.cmp);
; CHECK-NEXT:          %bsf = @llvm.cttz.i4(%bsfintmask,  1);
; CHECK-NEXT:          %1 = extractelement %select5,  %bsf;
; CHECK-NEXT:          %phi.temp9 = %1;
; CHECK-NEXT:          BB9.50:

; CHECK:               + DO i1 = 68, 68, 1   <DO_LOOP> <novectorize>
; CHECK-NEXT:          |   if ((@q)[0][i1 + 1] == 0)
; CHECK-NEXT:          |   {
; CHECK-NEXT:          |      (@s)[0] = %add;
; CHECK-NEXT:          |      %1 = %add;
; CHECK-NEXT:          |   }
; CHECK-NEXT:          + END LOOP
; CHECK-NEXT:    END REGION
;
entry:
  br label %for.body3

for.body3:                                        ; preds = %entry, %for.inc6
  %0 = phi i32 [ 20, %entry ], [ %2, %for.inc6 ]
  %indvars.iv = phi i64 [ 1, %entry ], [ %indvars.iv.next, %for.inc6 ]
  %arrayidx5 = getelementptr inbounds [20 x i32], [20 x i32]* @q, i64 0, i64 %indvars.iv
  %1 = load i32, i32* %arrayidx5, align 4
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.then, label %for.inc6

if.then:                                          ; preds = %for.body3
  store i32 %add, i32* @s, align 4
  br label %for.inc6

for.inc6:                                         ; preds = %for.body3, %if.then
  %2 = phi i32 [ %0, %for.body3 ], [ %add, %if.then ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 70
  br i1 %exitcond, label %for.end8, label %for.body3

for.end8:                                         ; preds = %for.inc6
  %.lcssa = phi i32 [ %2, %for.inc6 ]
  ret i32 %.lcssa
}
