; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check that VPlan HIR decomposer generates correct exit PHI for a
; live-out temp that is also live-in. Since the temp does not have any uses
; inside the loop, VPExternalDef is created for it during Exit PHI creation.
; Also check for correctness of generated vector code.

; Incoming HIR
;      + LiveIn symbases: 3, 7, 10, 11
;      + LiveOut symbases: 3
;      + DO i64 i1 = 0, 68, 1   <DO_LOOP>
;      |   if ((@q)[0][i1 + 1] == 0)
;      |   <RVAL-REG> {al:4}(LINEAR [20 x i32]* @q)[i64 0][LINEAR i64 i1 + 1] inbounds  {sb:14}
;      |      <BLOB> LINEAR [20 x i32]* @q {sb:7}
;      |
;      |   {
;      |      (@s)[0] = %add;
;      |      <LVAL-REG> {al:4}(LINEAR i32* @s)[i64 0] inbounds  {sb:15}
;      |         <BLOB> LINEAR i32* @s {sb:11}
;      |      <RVAL-REG> LINEAR i32 %add {sb:10}
;      |
;      |      %0 = %add;
;      |      <LVAL-REG> LINEAR i32 %add {sb:3}
;      |         <BLOB> LINEAR i32 %add {sb:10}
;      |      <RVAL-REG> LINEAR i32 %add {sb:10}
;      |
;      |   }
;      + END LOOP

; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -disable-output -vplan-print-after-plain-cfg -print-after=hir-vplan-vec -vplan-enable-new-cfg-merge-hir=false < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -disable-output -vplan-print-after-plain-cfg -vplan-enable-new-cfg-merge-hir=false < %s 2>&1 | FileCheck %s
; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -disable-output -vplan-print-after-plain-cfg -print-after=hir-vplan-vec -vplan-enable-new-cfg-merge-hir < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -disable-output -vplan-print-after-plain-cfg -vplan-enable-new-cfg-merge-hir < %s 2>&1 | FileCheck %s

@s = dso_local local_unnamed_addr global i32 0, align 4
@q = dso_local local_unnamed_addr global [20 x i32] zeroinitializer, align 16

define dso_local i32 @main(i32 %add) {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: main:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%0}
; CHECK-DAG:     [[VP1:%.*]] = {@s}
; CHECK-DAG:     [[VP2:%.*]] = {%add}
; CHECK-DAG:     [[VP3:%.*]] = {@q}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i32 [[VP4:%.*]] = phi  [ i32 [[TMP0:%.*]], [[BB1]] ],  [ i32 [[VP5:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP6:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP7:%.*]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP8:%.*]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds [20 x i32]* @q i64 0 i64 [[VP8]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i1 [[VP9:%.*]] = icmp eq i32 [[VP_LOAD]] i32 0
; CHECK-NEXT:     br i1 [[VP9]], [[BB4:BB[0-9]+]], [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       store i32 [[ADD0:%.*]] i32* @s
; CHECK-NEXT:       i32 [[VP10:%.*]] = hir-copy i32 [[ADD0]] , OriginPhiId: -1
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB2]]
; CHECK-NEXT:     i32 [[VP5]] = phi  [ i32 [[VP10]], [[BB4]] ],  [ i32 [[VP4]], [[BB2]] ]
; CHECK-NEXT:     i64 [[VP7]] = add i64 [[VP6]] i64 1
; CHECK-NEXT:     i1 [[VP11:%.*]] = icmp slt i64 [[VP7]] i64 69
; CHECK-NEXT:     br i1 [[VP11]], [[BB2]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP5]] -> [[VP12:%.*]] = {%0}
;
; CHECK-LABEL:  BEGIN REGION { modified }
; CHECK:             [[PHI_TEMP0:%.*]] = [[TMP2:%.*]];
; CHECK-NEXT:        [[PHI_TEMP10:%.*]] = -1;

; CHECK:             + DO i1 = 0, 67, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = (<4 x i32>*)(@q)[0][i1 + 1];
; CHECK-NEXT:        |   [[DOTVEC30:%.*]] = [[DOTVEC0]] == 0;
; CHECK-NEXT:        |   (<4 x i32>*)(@s)[0] = [[ADD0]], Mask = @{[[DOTVEC30]]};
; CHECK-NEXT:        |   [[DOTCOPY40:%.*]] = [[ADD0]];
; CHECK-NEXT:        |   [[SELECT0:%.*]] = ([[DOTVEC30]] == <i1 true, i1 true, i1 true, i1 true>) ? i1 + <i64 0, i64 1, i64 2, i64 3> : [[PHI_TEMP10]];
; CHECK-NEXT:        |   [[SELECT50:%.*]] = ([[DOTVEC30]] == <i1 true, i1 true, i1 true, i1 true>) ? [[DOTCOPY40]] : [[PHI_TEMP0]];
; CHECK-NEXT:        |   [[PHI_TEMP0]] = [[SELECT50]];
; CHECK-NEXT:        |   [[PHI_TEMP10]] = [[SELECT0]];
; CHECK-NEXT:        + END LOOP

; CHECK:             [[DOTVEC80:%.*]] = [[SELECT0]] != -1;
; CHECK-NEXT:        [[TMP1:%.*]] = bitcast.<4 x i1>.i4([[DOTVEC80]]);
; CHECK-NEXT:        [[CMP0:%.*]] = [[TMP1]] == 0;
; CHECK-NEXT:        [[ALL_ZERO_CHECK0:%.*]] = [[CMP0]];
; CHECK-NEXT:        [[PHI_TEMP90:%.*]] = [[TMP2]];
; CHECK-NEXT:        if ([[CMP0]] == 1)
; CHECK-NEXT:        {
; CHECK-NEXT:           goto [[BB7:BB.*]];
; CHECK-NEXT:        }
; CHECK-NEXT:        [[PRIV_IDX_MAX0:%.*]] = @llvm.vector.reduce.smax.v4i64([[SELECT0]]);
; CHECK-NEXT:        [[PRIV_IDX_CMP0:%.*]] = [[SELECT0]] == [[PRIV_IDX_MAX0]];
; CHECK-NEXT:        [[BSFINTMASK0:%.*]] = bitcast.<4 x i1>.i4([[PRIV_IDX_CMP0]]);
; CHECK-NEXT:        [[BSF0:%.*]] = @llvm.cttz.i4([[BSFINTMASK0]],  1);
; CHECK-NEXT:        [[TMP2]] = extractelement [[SELECT50]],  [[BSF0]];
; CHECK-NEXT:        [[PHI_TEMP90]] = [[TMP2]];
; CHECK-NEXT:        [[BB7]]:

; CHECK:             + DO i1 = {{.*}}, 68, 1   <DO_LOOP>
; CHECK-NEXT:        |   if ((@q)[0][i1 + 1] == 0)
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      (@s)[0] = [[ADD0]];
; CHECK-NEXT:        |      [[TMP2]] = [[ADD0]];
; CHECK-NEXT:        |   }
; CHECK-NEXT:        + END LOOP
; CHECK-NEXT:  END REGION
;

entry:
  br label %for.body3

for.body3:                                        ; preds = %entry, %for.inc6
  %0 = phi i32 [ 20, %entry ], [ %2, %for.inc6 ]
  %indvars.iv = phi i64 [ 1, %entry ], [ %indvars.iv.next, %for.inc6 ]
  %arrayidx5 = getelementptr inbounds [20 x i32], [20 x i32]* @q, i64 0, i64 %indvars.iv
  %1 = load i32, i32* %arrayidx5, align 4
  %tobool = icmp eq i32 %1, 0
  br i1 %tobool, label %if.then, label %for.inc6

if.then:                                          ; preds = %for.body3
  store i32 %add, i32* @s, align 4
  br label %for.inc6

for.inc6:                                         ; preds = %for.body3, %if.then
  %2 = phi i32 [ %0, %for.body3 ], [ %add, %if.then ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 70
  br i1 %exitcond, label %for.end8, label %for.body3

for.end8:                                         ; preds = %for.inc6
  %.lcssa = phi i32 [ %2, %for.inc6 ]
  ret i32 %.lcssa
}
