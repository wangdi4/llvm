; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

;; Test that we do not create duplicated instructions when collecting private aliases
;; Since the incorrect behavior was crash at VPlan destructor, check that the
;; imported aliases make sense.
;; Also check SOA layout enabled for the private.

; RUN: opt -vplan-print-after-vpentity-instrs -passes=vplan-vec -vplan-dump-soa-info -vplan-force-vf=4 -disable-output < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)
; Case with select having two pointers from same private.
;
; The source code looks like below.
;
; int64_t a[32];
; int64_t *p1 = a;
; int64_t *p2 = &a[1];
; void select_two_privates(int *ptr, bool pred) {
;   int64_t *p = pred ? p1 : p2;
;   #pragma omp simd private(a) simdlen(16)
;   for (int i = 0; i < 16; i++) {
;     ptr[i] = *p;
;   }
; }
;
define void @select_two_privates(i64 %init1, i64 %init2, ptr %ptr, i1 zeroext %pred) {
; CHECK:          ptr [[VP_PRIV:%.*]] = allocate-priv [32 x i64], OrigAlign = 8
; CHECK-NEXT:     call i64 256 ptr [[VP_PRIV]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     ptr [[VP_GEP2:%.*]] = getelementptr inbounds [32 x i64], ptr [[VP_PRIV]] i64 0 i64 1
; CHECK-NEXT:     ptr [[VP_GEP1:%.*]] = getelementptr inbounds [32 x i64], ptr [[VP_PRIV]] i64 0 i64 0
; CHECK-NEXT:     ptr [[VP_SELECT:%.*]] = select i1 [[PRED0:%.*]] ptr [[VP_GEP1]] ptr [[VP_GEP2]]
; CHECK-NEXT:     i64 [[VP_INDEX_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     i64 [[VP_INDEX_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
;
; CHECK:       SOA profitability
; CHECK-NEXT:  SOASafe = [[VP_PRIV]] (priv) Profitable = 1
;
entry:
  %priv = alloca [32 x i64], align 8
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 16), "QUAL.OMP.PRIVATE:TYPED"(ptr %priv, i64 0, i32 32), "QUAL.OMP.UNIFORM"(i64 %init1), "QUAL.OMP.UNIFORM"(i64 %init2), "QUAL.OMP.UNIFORM:TYPED"(ptr %ptr, i64 0, i32 1), "QUAL.OMP.UNIFORM"(i1 %pred) ]
  br label %simd.loop.preheader

simd.loop.preheader:
  %gep1 = getelementptr inbounds [32 x i64], ptr %priv, i64 0, i64 0
  %gep2 = getelementptr inbounds [32 x i64], ptr %priv, i64 0, i64 1
  %select = select i1 %pred, ptr %gep1, ptr %gep2
  br label %simd.loop.header

simd.loop.header:
  %index = phi i64 [ 0, %simd.loop.preheader ], [ %indvar, %simd.loop.latch ]
  %load = load i64, ptr %select, align 8
  %gep = getelementptr inbounds i64, ptr %ptr, i64 %index
  store i64 %load, ptr %gep, align 8
  br label %simd.loop.latch

simd.loop.latch:
  %indvar = add nuw i64 %index, 1
  %cond = icmp ult i64 %indvar, 16
  br i1 %cond, label %simd.loop.header, label %simd.end.region

simd.end.region:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:
  ret void
}
