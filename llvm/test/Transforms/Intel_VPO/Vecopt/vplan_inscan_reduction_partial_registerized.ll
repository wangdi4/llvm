; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to verify that VPlan vectorizer legality correctly imports a partially
; registerized inscan reduction variable.

; RUN: opt -disable-output -vplan-vec -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-force-vf=2 -vplan-force-inscan-reduction-vectorization=true -S < %s 2>&1 | FileCheck %s
; RUN: opt -disable-output -passes="vplan-vec" -vplan-print-after-vpentity-instrs -vplan-entities-dump -vplan-force-vf=2 -vplan-force-inscan-reduction-vectorization=true -S < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define float @_Z3fooPfS_i(float* %A, float* %B, i32 %N) {
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: _Z3fooPfS_i:DIR.OMP.END.SCAN.335.#{{[0-9]+}}
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   (+) Start: float [[DOTPRE0:%.*]] Exit: float [[VP_RED_LD:%.*]]
; CHECK-NEXT:    Linked values: float [[VP_RED_PHI:%.*]], float [[VP_RED_LD]], float* [[VP_X_RED:%.*]], float [[VP_X_REDINSCAN_RED_INIT:%.*]], void [[VP_STORE:%.*]], float [[VP_X_REDINSCAN_RED_FINAL:%.*]],
; CHECK-NEXT:    inscan ReductionKind: inclusive
; CHECK-NEXT:   Memory: float* [[X_RED0:%.*]]
; CHECK-EMPTY:
; CHECK:         [[BB2:BB[0-9]+]]: # preds: [[BB1:BB[0-9]+]]
; CHECK-NEXT:     float* [[VP_X_RED]] = allocate-priv float*, OrigAlign = 4
; CHECK-NEXT:     i8* [[VP0:%.*]] = bitcast float* [[VP_X_RED]]
; CHECK-NEXT:     call i64 4 i8* [[VP0]] void (i64, i8*)* @llvm.lifetime.start.p0i8
; CHECK-NEXT:     float [[VP_X_REDINSCAN_RED_INIT]] = reduction-init-scalar float 0.000000e+00 float [[DOTPRE0]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     float [[VP_RED_PHI]] = phi  [ float [[VP_X_REDINSCAN_RED_INIT]], [[BB2]] ],  [ float [[VP_RED_LD]], [[BB3]] ]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB2]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     float [[VP_INSCAN_ACCUM:%.*]] = phi  [ float [[VP_X_REDINSCAN_RED_INIT]], [[BB2]] ],  [ float [[VP1:%.*]], [[BB3]] ]
; CHECK-NEXT:     store float 0.000000e+00 float* [[VP_X_RED]]
; CHECK-NEXT:     float* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds float* [[A0:%.*]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     float [[VP_A_LD:%.*]] = load float* [[VP_ARRAYIDX]]
; CHECK-NEXT:     float [[VP_ADD5:%.*]] = fadd float 0.000000e+00 float [[VP_A_LD]]
; CHECK-NEXT:     store float [[VP_ADD5]] float* [[VP_X_RED]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     float [[VP_LOAD:%.*]] = load float* [[VP_X_RED]]
; CHECK-NEXT:     float [[VP_INCL_SCAN:%.*]] = running-inclusive-reduction float [[VP_LOAD]] float [[VP_INSCAN_ACCUM]] float 0.000000e+00
; CHECK-NEXT:     store float [[VP_INCL_SCAN]] float* [[VP_X_RED]]
; CHECK-NEXT:     float [[VP1]] = extract-last-vector-lane float [[VP_INCL_SCAN]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB6]]
; CHECK-NEXT:     float [[VP_RED_LD]] = load float* [[VP_X_RED]]
; CHECK-NEXT:     float* [[VP_ARRAYIDX7:%.*]] = getelementptr inbounds float* [[B0:%.*]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     store float [[VP_RED_LD]] float* [[VP_ARRAYIDX7]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP_EXITCOND_NOT:%.*]] = icmp eq i64 [[VP_INDVARS_IV_NEXT]] i64 [[WIDE_TRIP_COUNT0:%.*]]
; CHECK-NEXT:     br i1 [[VP_EXITCOND_NOT]], [[BB7:BB[0-9]+]], [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB3]]
; CHECK-NEXT:     float [[VP_X_REDINSCAN_RED_FINAL]] = reduction-final-inscan float [[VP_RED_LD]]
; CHECK-NEXT:     store float [[VP_X_REDINSCAN_RED_FINAL]] float* [[X_RED0]]
; CHECK-NEXT:     i8* [[VP2:%.*]] = bitcast float* [[VP_X_RED]]
; CHECK-NEXT:     call i64 4 i8* [[VP2]] void (i64, i8*)* @llvm.lifetime.end.p0i8
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0     [[DOTLCSSA0:%.*]] = phi float [ [[RED_LD0:%.*]], [[DIR_OMP_END_SCAN_30:%.*]] ] float [[VP_X_REDINSCAN_RED_FINAL]] -> float [[RED_LD0]]
;
entry:
  %x.red = alloca float, align 4
  %cmp = icmp sgt i32 %N, 0
  br i1 %cmp, label %DIR.OMP.SIMD.1, label %omp.precond.end

DIR.OMP.SIMD.1:                                   ; preds = %entry
  store float 1.000000e+00, float* %x.red, align 4
  br label %DIR.OMP.SIMD.136

DIR.OMP.SIMD.136:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD:INSCAN.TYPED"(float* %x.red, float zeroinitializer, i32 1, i64 1) ]
  br label %DIR.OMP.SIMD.137

DIR.OMP.SIMD.137:                                 ; preds = %DIR.OMP.SIMD.136
  %wide.trip.count = zext i32 %N to i64
  %.pre = load float, float* %x.red, align 4
  br label %DIR.OMP.END.SCAN.335

DIR.OMP.END.SCAN.335:                             ; preds = %DIR.OMP.SIMD.137, %DIR.OMP.END.SCAN.3
  %red.phi = phi float [ %.pre, %DIR.OMP.SIMD.137 ], [ %red.ld, %DIR.OMP.END.SCAN.3 ]
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.137 ], [ %indvars.iv.next, %DIR.OMP.END.SCAN.3 ]
  %arrayidx = getelementptr inbounds float, float* %A, i64 %indvars.iv
  %a.ld = load float, float* %arrayidx, align 4
  %add5 = fadd fast float %red.phi, %a.ld
  store float %add5, float* %x.red, align 4
  br label %DIR.OMP.SCAN.3

DIR.OMP.SCAN.3:                                   ; preds = %DIR.OMP.END.SCAN.335
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SCAN"(), "QUAL.OMP.INCLUSIVE"(float* %x.red, i64 1) ]
  br label %DIR.OMP.SCAN.2

DIR.OMP.SCAN.2:                                   ; preds = %DIR.OMP.SCAN.3
  fence acq_rel
  br label %DIR.OMP.END.SCAN.5

DIR.OMP.END.SCAN.5:                               ; preds = %DIR.OMP.SCAN.2
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SCAN"() ]
  br label %DIR.OMP.END.SCAN.3

DIR.OMP.END.SCAN.3:                               ; preds = %DIR.OMP.END.SCAN.5
  %red.ld = load float, float* %x.red, align 4
  %arrayidx7 = getelementptr inbounds float, float* %B, i64 %indvars.iv
  store float %red.ld, float* %arrayidx7, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.7, label %DIR.OMP.END.SCAN.335, !llvm.loop !0

DIR.OMP.END.SIMD.7:                               ; preds = %DIR.OMP.END.SCAN.3
  %.lcssa = phi float [ %red.ld, %DIR.OMP.END.SCAN.3 ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:                               ; preds = %DIR.OMP.END.SIMD.7
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.1, %entry
  %x.1 = phi float [ 1.000000e+00, %entry ], [ %.lcssa, %DIR.OMP.END.SIMD.1 ]
  ret float %x.1
}

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)

!0 = distinct !{!0, !1, !2}
!1 = !{!"llvm.loop.vectorize.enable", i1 true}
!2 = !{!"llvm.loop.vectorize.ivdep_loop", i32 0}
