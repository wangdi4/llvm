; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2
; Test to verify that early-exit loops with liveout IVs are handled correctly by VPlan.

; RUN: opt %s -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-last-value-computation,hir-vec-dir-insert,print<hir>,hir-vplan-vec,print<hir>" -disable-hir-last-value-computation-multi-exit-loop -vplan-print-after-transformed-early-exit-loop -vplan-enable-early-exit-loops -vplan-force-vf=4 -disable-output 2>&1 | FileCheck %s

; CHECK:  BEGIN REGION { }
; CHECK:        %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
; CHECK:        + DO i1 = 0, 1023, 1   <DO_MULTI_EXIT_LOOP>
; CHECK:        |   %indvars.iv.out = i1;
; CHECK:        |   if ((%a)[i1] == %val)
; CHECK:        |   {
; CHECK:        |      goto cleanup.loopexit;
; CHECK:        |   }
; CHECK:        + END LOOP
; CHECK:        @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
; CHECK:  END REGION

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i64 @_Z3fooiPKaPaa(ptr nocapture readonly %a, i8 signext %val) local_unnamed_addr {
; CHECK-LABEL:  VPlan after transforming early-exit loop:
; CHECK-NEXT:  VPlan IR for: _Z3fooiPKaPaa:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%a}
; CHECK-DAG:     [[VP1:%.*]] = {%val}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; CHECK-NEXT:     i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in1 i64 1
; CHECK-NEXT:     i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]]
; CHECK-NEXT:     i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP__SSA_PHI:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     i64 [[VP3:%.*]] = hir-copy i64 [[VP2]] , OriginPhiId: -1
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP2]]
; CHECK-NEXT:     i8 [[VP_LOAD:%.*]] = load ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i1 [[VP4:%.*]] = icmp eq i8 [[VP_LOAD]] i8 [[VAL0:%.*]]
; CHECK-NEXT:     i1 [[VP_EARLY_EXIT_EXEC_MASK:%.*]] = early-exit-exec-mask i1 [[VP4]]
; CHECK-NEXT:     br i1 [[VP_EARLY_EXIT_EXEC_MASK]], [[BB3:BB[0-9]+]], [[INTERMEDIATE_BB0:intermediate.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[INTERMEDIATE_BB0]]: # preds: [[BB2]]
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:       i64 [[VP5:%.*]] = add i64 [[VP2]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:       i1 [[VP6:%.*]] = icmp slt i64 [[VP5]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]: # preds: [[BB3]], [[INTERMEDIATE_BB0]]
; CHECK-NEXT:     i64 [[VP__SSA_PHI]] = phi  [ i64 [[VP5]], [[BB3]] ],  [ i64 [[VP2]], [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     i32 [[VP_EXIT_ID_PHI:%.*]] = phi  [ i32 0, [[BB3]] ],  [ i32 1, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     i1 [[VP_TAKE_BACKEDGE_COND:%.*]] = phi  [ i1 [[VP6]], [[BB3]] ],  [ i1 false, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     i1 [[VP_EE_LATCH_COND_CANON:%.*]] = not i1 [[VP_TAKE_BACKEDGE_COND]]
; CHECK-NEXT:     i1 [[VP_EE_MASK_IS_ZERO:%.*]] = all-zero-check i1 [[VP_EE_LATCH_COND_CANON]]
; CHECK-NEXT:     br i1 [[VP_EE_MASK_IS_ZERO]], [[BB2]], [[CASCADED_IF_BLOCK0:cascaded.if.block[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[CASCADED_IF_BLOCK0]]: # preds: [[NEW_LOOP_LATCH0]]
; CHECK-NEXT:     i1 [[VP7:%.*]] = icmp ne i32 [[VP_EXIT_ID_PHI]] i32 0
; CHECK-NEXT:     i32 [[VP_EARLY_EXIT_LANE:%.*]] = early-exit-lane i1 [[VP7]]
; CHECK-NEXT:     i1 [[VP8:%.*]] = icmp ne i32 [[VP_EARLY_EXIT_LANE]] i32 -1
; CHECK-NEXT:     i32 [[VP_EE_OR_FIRST_LANE:%.*]] = select-val-or-lane i1 [[VP8]] i32 [[VP_EARLY_EXIT_LANE]], first lane
; CHECK-NEXT:     i32 [[VP_EE_OR_LAST_LANE:%.*]] = select-val-or-lane i1 [[VP8]] i32 [[VP_EARLY_EXIT_LANE]], last lane
; CHECK-NEXT:     i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 [[VP__SSA_PHI]] i32 [[VP_EE_OR_FIRST_LANE]]
; CHECK-NEXT:     i64 [[VP__PRIV_FINAL:%.*]] = private-final-uc i64 [[VP3]] i32 [[VP_EE_OR_LAST_LANE]]
; CHECK-NEXT:     i32 [[VP_EARLY_EXIT_ID:%.*]] = early-exit-id i32 [[VP_EXIT_ID_PHI]] i32 [[VP_EE_OR_LAST_LANE]]
; CHECK-NEXT:     i1 [[VP9:%.*]] = icmp eq i32 [[VP_EARLY_EXIT_ID]] i32 1
; CHECK-NEXT:     br i1 [[VP9]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[CASCADED_IF_BLOCK0]]
; CHECK-NEXT:       br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[CASCADED_IF_BLOCK0]]
; CHECK-NEXT:       br cleanup.loopexit
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i64 [[VP__PRIV_FINAL]] -> [[VP10:%.*]] = {%indvars.iv.out}

; CHECK:       BEGIN REGION { modified }
; CHECK-NEXT:        + DO i1 = 0, 1023, 4   <DO_MULTI_EXIT_LOOP> <auto-vectorized> <novectorize>
; CHECK-NEXT:        |   %.copy = i1 + <i64 0, i64 1, i64 2, i64 3>;
; CHECK-NEXT:        |   %.vec = (<4 x i8>*)(%a)[i1];
; CHECK-NEXT:        |   %.vec1 = %.vec == %val;
; CHECK-NEXT:        |   %ee.execmask.ctz.intmask = bitcast.<4 x i1>.i4(%.vec1);
; CHECK-NEXT:        |   %ee.execmask.ctz. = @llvm.cttz.i4(%ee.execmask.ctz.intmask,  0);
; CHECK-NEXT:        |   %ee.execmask.zext = zext.i4.i5(%ee.execmask.ctz.);
; CHECK-NEXT:        |   %ee.execmask.shl = 1  <<  %ee.execmask.zext;
; CHECK-NEXT:        |   %ee.execmask.int = %ee.execmask.shl  -  1;
; CHECK-NEXT:        |   %ee.execmask.int.trunc = trunc.i5.i4(%ee.execmask.int);
; CHECK-NEXT:        |   %ee.execmask = bitcast.i4.<4 x i1>(%ee.execmask.int.trunc);
; CHECK-NEXT:        |   %.vec2 = %ee.execmask  ^  -1;
; CHECK-NEXT:        |   %.vec3 = i1 + <i64 0, i64 1, i64 2, i64 3> + 4 < 1024;
; CHECK-NEXT:        |   %select = (%ee.execmask == <i1 true, i1 true, i1 true, i1 true>) ? i1 + <i64 0, i64 1, i64 2, i64 3> + 4 : i1 + <i64 0, i64 1, i64 2, i64 3>;
; CHECK-NEXT:        |   %select4 = (%ee.execmask == <i1 true, i1 true, i1 true, i1 true>) ? 0 : 1;
; CHECK-NEXT:        |   %select5 = (%ee.execmask == <i1 true, i1 true, i1 true, i1 true>) ? %.vec3 : 0;
; CHECK-NEXT:        |   %.vec6 = %select5  ^  -1;
; CHECK-NEXT:        |   %0 = bitcast.<4 x i1>.i4(%.vec6);
; CHECK-NEXT:        |   %cmp7 = %0 == 0;
; CHECK-NEXT:        |   %all.zero.check = %cmp7;
; CHECK-NEXT:        |   if (%cmp7 != 1)
; CHECK-NEXT:        |   {
; CHECK-NEXT:        |      goto cascaded.if.block11.50;
; CHECK-NEXT:        |   }
; CHECK-NEXT:        + END LOOP

; CHECK:             cascaded.if.block11.50:
; CHECK-NEXT:        %.vec8 = %select4 != 0;
; CHECK-NEXT:        %ee.lane.intmask = bitcast.<4 x i1>.i4(%.vec8);
; CHECK-NEXT:        %ee.lane. = @llvm.cttz.i4(%ee.lane.intmask,  0);
; CHECK-NEXT:        %select9 = (%ee.lane. == 4) ? -1 : %ee.lane.;
; CHECK-NEXT:        %ee.lane.sext = sext.i4.i32(%select9);
; CHECK-NEXT:        %ee.or.first.lane.sel = (%ee.lane.sext != -1) ? %ee.lane.sext : 0;
; CHECK-NEXT:        %ee.or.last.lane.sel = (%ee.lane.sext != -1) ? %ee.lane.sext : 3;
; CHECK-NEXT:        %extracted.lval = extractelement %select,  %ee.or.first.lane.sel;
; CHECK-NEXT:        %indvars.iv.out = extractelement %.copy,  %ee.or.last.lane.sel;
; CHECK-NEXT:        %ee.id.final = extractelement %select4,  %ee.or.last.lane.sel;
; CHECK-NEXT:        %.vec10 = %ee.id.final == 1;
; CHECK-NEXT:        %extract.0. = extractelement %.vec10,  0;
; CHECK-NEXT:        if (%extract.0. == 1)
; CHECK-NEXT:        {
; CHECK-NEXT:           goto BB5.65;
; CHECK-NEXT:        }
; CHECK-NEXT:        goto BB3.69;
; CHECK-NEXT:        BB5.65:
; CHECK-NEXT:        goto cleanup.loopexit;
; CHECK-NEXT:        BB3.69:
; CHECK-NEXT:  END REGION
;
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds i8, ptr %a, i64 %indvars.iv
  %0 = load i8, ptr %arrayidx, align 1
  %cmp2 = icmp eq i8 %0, %val
  br i1 %cmp2, label %cleanup.loopexit, label %for.inc

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp slt i64 %indvars.iv.next, 1024
  br i1 %cmp, label %for.body, label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %for.inc
  %iv.lcssa = phi i64 [ %indvars.iv, %for.body ], [ 1024, %for.inc ]
  ret i64 %iv.lcssa
}

