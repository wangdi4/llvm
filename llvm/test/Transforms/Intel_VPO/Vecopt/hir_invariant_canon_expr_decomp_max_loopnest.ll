; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check that VPlan's HIRDecomposer prevents decomposition of
; invariant CEs in loops at max loop nest level (no inner loops).

; Input HIR
; BEGIN REGION { }
;       + DO i1 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   + DO i2 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   |   + DO i3 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   |   |   + DO i4 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   |   |   |   + DO i5 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   |   |   |   |   + DO i6 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   |   |   |   |   |   + DO i7 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   |   |   |   |   |   |   + DO i8 = 0, %n + -1, 1   <DO_LOOP>  <MAX_TC_EST = 4294967295>
;       |   |   |   |   |   |   |   |   %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
;       |   |   |   |   |   |   |   |
;       |   |   |   |   |   |   |   |   + DO i9 = 0, sext.i32.i64(%n) + -1, 1   <DO_LOOP>
;       |   |   |   |   |   |   |   |   |   (%A)[i9] = i9 + 2 * %C;
;       |   |   |   |   |   |   |   |   + END LOOP
;       |   |   |   |   |   |   |   |
;       |   |   |   |   |   |   |   |   @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
;       |   |   |   |   |   |   |   + END LOOP
;       |   |   |   |   |   |   + END LOOP
;       |   |   |   |   |   + END LOOP
;       |   |   |   |   + END LOOP
;       |   |   |   + END LOOP
;       |   |   + END LOOP
;       |   + END LOOP
;       + END LOOP
; END REGION

; The canon expression 2 * %C is loop invariant at max loop nest level, so there are
; no other inner loops to check for invariance.

; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -disable-output -vplan-print-after-plain-cfg -vplan-force-vf=2 < %s 2>&1 | FileCheck %s



target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nofree norecurse nounwind uwtable writeonly
define dso_local void @foo(i32 %n, ptr nocapture %A, i32 %C) local_unnamed_addr {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: foo:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {2 * %C}
; CHECK-DAG:     [[VP1:%.*]] = {sext.i32.i64(%n) + -1}
; CHECK-DAG:     [[VP2:%.*]] = {%A}
; CHECK-NEXT:  External Defs End:
; CHECK:          i64 [[UB_INC:%.*]] = add i64 [[VP1]] i64 1
; CHECK:          i64 [[VP3:%.*]] = phi  [ i64 0, [[BB1:.*]] ],  [ i64 [[VP4:%.*]], [[BB2:.*]] ]
; CHECK-NEXT:     i32 [[VP5:%.*]] = trunc i64 [[VP3]] to i32
; CHECK-NEXT:     i32 [[VP6:%.*]] = add i32 [[VP0]] i32 [[VP5]]
; CHECK-NEXT:     ptr [[VP_SUBSCRIPT:%.*]] = subscript inbounds ptr [[A0:%.*]] i64 [[VP3]]
; CHECK-NEXT:     store i32 [[VP6]] ptr [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i64 [[VP4]] = add i64 [[VP3]] i64 1
; CHECK-NEXT:     i1 [[VP7:%.*]] = icmp slt i64 [[VP4]] i64 [[UB_INC]]
;
entry:
  %cmp93 = icmp sgt i32 %n, 0
  br i1 %cmp93, label %for.cond1.preheader.lr.ph, label %for.end48

for.cond1.preheader.lr.ph:                        ; preds = %entry
  %mul = shl nsw i32 %C, 1
  %wide.trip.count = sext i32 %n to i64
  br label %for.cond4.preheader.preheader

for.cond4.preheader.preheader:                    ; preds = %for.cond1.preheader.lr.ph, %for.inc46
  %i1.094 = phi i32 [ 0, %for.cond1.preheader.lr.ph ], [ %inc47, %for.inc46 ]
  br label %for.cond7.preheader.preheader

for.cond7.preheader.preheader:                    ; preds = %for.cond4.preheader.preheader, %for.inc43
  %i2.092 = phi i32 [ %inc44, %for.inc43 ], [ 0, %for.cond4.preheader.preheader ]
  br label %for.cond10.preheader.preheader

for.cond10.preheader.preheader:                   ; preds = %for.cond7.preheader.preheader, %for.inc40
  %i3.090 = phi i32 [ %inc41, %for.inc40 ], [ 0, %for.cond7.preheader.preheader ]
  br label %for.cond13.preheader.preheader

for.cond13.preheader.preheader:                   ; preds = %for.cond10.preheader.preheader, %for.inc37
  %i4.088 = phi i32 [ %inc38, %for.inc37 ], [ 0, %for.cond10.preheader.preheader ]
  br label %for.cond16.preheader.preheader

for.cond16.preheader.preheader:                   ; preds = %for.cond13.preheader.preheader, %for.inc34
  %i5.086 = phi i32 [ %inc35, %for.inc34 ], [ 0, %for.cond13.preheader.preheader ]
  br label %for.cond19.preheader.preheader

for.cond19.preheader.preheader:                   ; preds = %for.cond16.preheader.preheader, %for.inc31
  %i6.084 = phi i32 [ %inc32, %for.inc31 ], [ 0, %for.cond16.preheader.preheader ]
  br label %for.cond22.preheader.preheader

for.cond22.preheader.preheader:                   ; preds = %for.cond19.preheader.preheader, %for.inc28
  %i7.082 = phi i32 [ %inc29, %for.inc28 ], [ 0, %for.cond19.preheader.preheader ]
  br label %for.body24.preheader

for.body24.preheader:                             ; preds = %for.cond22.preheader.preheader, %for.inc25
  %i8.080 = phi i32 [ %inc26, %for.inc25 ], [ 0, %for.cond22.preheader.preheader ]
  br label %for.body24

for.body24:                                       ; preds = %for.body24, %for.body24.preheader
  %indvars.iv = phi i64 [ 0, %for.body24.preheader ], [ %indvars.iv.next, %for.body24 ]
  %0 = trunc i64 %indvars.iv to i32
  %add = add nsw i32 %mul, %0
  %ptridx = getelementptr inbounds i32, ptr %A, i64 %indvars.iv
  store i32 %add, ptr %ptridx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.inc25, label %for.body24

for.inc25:                                        ; preds = %for.body24
  %inc26 = add nuw nsw i32 %i8.080, 1
  %exitcond95 = icmp eq i32 %inc26, %n
  br i1 %exitcond95, label %for.inc28, label %for.body24.preheader

for.inc28:                                        ; preds = %for.inc25
  %inc29 = add nuw nsw i32 %i7.082, 1
  %exitcond96 = icmp eq i32 %inc29, %n
  br i1 %exitcond96, label %for.inc31, label %for.cond22.preheader.preheader

for.inc31:                                        ; preds = %for.inc28
  %inc32 = add nuw nsw i32 %i6.084, 1
  %exitcond97 = icmp eq i32 %inc32, %n
  br i1 %exitcond97, label %for.inc34, label %for.cond19.preheader.preheader

for.inc34:                                        ; preds = %for.inc31
  %inc35 = add nuw nsw i32 %i5.086, 1
  %exitcond98 = icmp eq i32 %inc35, %n
  br i1 %exitcond98, label %for.inc37, label %for.cond16.preheader.preheader

for.inc37:                                        ; preds = %for.inc34
  %inc38 = add nuw nsw i32 %i4.088, 1
  %exitcond99 = icmp eq i32 %inc38, %n
  br i1 %exitcond99, label %for.inc40, label %for.cond13.preheader.preheader

for.inc40:                                        ; preds = %for.inc37
  %inc41 = add nuw nsw i32 %i3.090, 1
  %exitcond100 = icmp eq i32 %inc41, %n
  br i1 %exitcond100, label %for.inc43, label %for.cond10.preheader.preheader

for.inc43:                                        ; preds = %for.inc40
  %inc44 = add nuw nsw i32 %i2.092, 1
  %exitcond101 = icmp eq i32 %inc44, %n
  br i1 %exitcond101, label %for.inc46, label %for.cond7.preheader.preheader

for.inc46:                                        ; preds = %for.inc43
  %inc47 = add nuw nsw i32 %i1.094, 1
  %exitcond102 = icmp eq i32 %inc47, %n
  br i1 %exitcond102, label %for.end48.loopexit, label %for.cond4.preheader.preheader

for.end48.loopexit:                               ; preds = %for.inc46
  br label %for.end48

for.end48:                                        ; preds = %for.end48.loopexit, %entry
  ret void
}

