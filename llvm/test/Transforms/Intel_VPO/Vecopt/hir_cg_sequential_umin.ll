; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -disable-output -print-after=hir-vplan-vec -vplan-force-vf=4 2>&1 | FileCheck %s
; RUN: opt < %s -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -disable-output -print-after=hir-vplan-vec -vplan-force-vf=4 2>&1 | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"

define void @foo(i8* %p1, i8* %p2, i1* %p3) {
; CHECK-LABEL:  BEGIN REGION { modified }
; CHECK-NEXT:        + DO i1 = 0, 1023, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:        |   [[DOTVEC0:%.*]] = (<4 x i8>*)([[P10:%.*]])[i1]
; CHECK-NEXT:        |   [[DOTVEC20:%.*]] = (<4 x i8>*)([[P20:%.*]])[i1]
; CHECK-NEXT:        |   [[DOTVEC30:%.*]] = [[DOTVEC0]] == 0
; CHECK-NEXT:        |   [[DOTVEC40:%.*]] = [[DOTVEC20]] == 0
; CHECK-NEXT:        |   [[DOTVEC50:%.*]] = [[DOTVEC30]] + -1 == zeroinitializer
; CHECK-NEXT:        |   [[DOTVEC60:%.*]] = [[DOTVEC40]] + -1 == zeroinitializer
; CHECK-NEXT:        |   [[DOTVEC70:%.*]] = ([[DOTVEC50]] == 1) ? 1 : [[DOTVEC60]]
; CHECK-NEXT:        |   [[DOTVEC80:%.*]] = ([[DOTVEC30]] + -1 <u [[DOTVEC40]] + -1) ? [[DOTVEC30]] + -1 : [[DOTVEC40]] + -1
; CHECK-NEXT:        |   [[DOTVEC90:%.*]] = ([[DOTVEC70]] == 1) ? zeroinitializer : [[DOTVEC80]]
; CHECK-NEXT:        |   (<4 x i1>*)([[P30:%.*]])[i1 + <i64 0, i64 1, i64 2, i64 3>] = [[DOTVEC90]] + -1
; CHECK-NEXT:        + END LOOP
; CHECK:        [[PHI_TEMP0:%.*]] = 1024
; CHECK-NEXT:        ret
; CHECK-NEXT:  END REGION
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %arrayidx1 = getelementptr inbounds i8, i8* %p1, i64 %indvars.iv
  %0 = load i8, i8* %arrayidx1, align 1
  %arrayidx2 = getelementptr inbounds i8, i8* %p2, i64 %indvars.iv
  %1 = load i8, i8* %arrayidx2, align 1
  %cmp1 = icmp eq i8 %0, 0
  %cmp2 = icmp eq i8 %1, 0
  %or.cond = select i1 %cmp1, i1 true, i1 %cmp2
  %arrayidx3 = getelementptr inbounds i1, i1* %p3, i64 %indvars.iv
  store i1 %or.cond, i1* %arrayidx3, align 1

  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:                                          ; preds = %for.end.loopexit, %for.end.split.loop.exit
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
