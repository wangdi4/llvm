; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Check that VPlan HIR vectorizer codegen generates correct sequence of instructions
; to revectorize incoming vector loads/stores as gathers/scatters.

; Incoming HIR
;    BEGIN REGION { }
;          %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
;
;          + DO i1 = 0, 1023, 1   <DO_LOOP> <ivdep>
;          |   %val = (<2 x float>*)(%src)[2 * i1];
;          |   %add7 = %val  +  <float 7.000000e+00, float 7.000000e+00>;
;          |   (<2 x float>*)(%dst)[3 * i1] = %add7;
;          + END LOOP
;
;          @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
;    END REGION

; RUN: opt -passes='hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>,hir-cg' -vplan-force-vf=4 -S < %s 2>&1 | FileCheck %s

; Check vector HIR generated by VPlan.
; CHECK-LABEL: Function: foo
; CHECK:        BEGIN REGION { modified }
; CHECK-NEXT:          + DO i1 = 0, 1023, 4   <DO_LOOP> <auto-vectorized> <novectorize> <ivdep>
; CHECK-NEXT:          |   %.replicated.elts = shufflevector &((<4 x float*>)(%src)[2 * i1 + 2 * <i64 0, i64 1, i64 2, i64 3>]),  undef,  <i32 0, i32 0, i32 1, i32 1, i32 2, i32 2, i32 3, i32 3>;
; CHECK-NEXT:          |   %.vec = (<8 x float>*)(%.replicated.elts)[<i64 0, i64 1, i64 0, i64 1, i64 0, i64 1, i64 0, i64 1>];
; CHECK-NEXT:          |   %.vec1 = %.vec  +  <float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00>;
; CHECK-NEXT:          |   %.replicated.elts2 = shufflevector &((<4 x float*>)(%dst)[3 * i1 + 3 * <i64 0, i64 1, i64 2, i64 3>]),  undef,  <i32 0, i32 0, i32 1, i32 1, i32 2, i32 2, i32 3, i32 3>;
; CHECK-NEXT:          |   (<8 x float>*)(%.replicated.elts2)[<i64 0, i64 1, i64 0, i64 1, i64 0, i64 1, i64 0, i64 1>] = %.vec1;
; CHECK-NEXT:          + END LOOP
; CHECK:    END REGION

; Check vector LLVM-IR generated by HIR-CG from vector HIR.
; CHECK-LABEL: @foo(
; CHECK:       loop.20:
; CHECK:         [[TMP3:%.*]] = getelementptr inbounds %"struct.std::complex", <4 x %"struct.std::complex"*> [[DOTSPLAT:%.*]], <4 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x %"struct.std::complex"*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[DOTREPLICATED_ELTS5:%.*]] = shufflevector <4 x float*> [[TMP4]], <4 x float*> undef, <8 x i32> <i32 0, i32 0, i32 1, i32 1, i32 2, i32 2, i32 3, i32 3>
; CHECK-NEXT:    store <8 x float*> [[DOTREPLICATED_ELTS5]], <8 x float*>* [[T20:%.*]], align 64
; CHECK-NEXT:    [[T20_:%.*]] = load <8 x float*>, <8 x float*>* [[T20]], align 64
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds float, <8 x float*> [[T20_]], <8 x i64> <i64 0, i64 1, i64 0, i64 1, i64 0, i64 1, i64 0, i64 1>
; CHECK-NEXT:    [[TMP6:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP5]], i32 4, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> poison)

; CHECK:         [[TMP11:%.*]] = getelementptr inbounds %"struct.std::complex", <4 x %"struct.std::complex"*> [[DOTSPLAT7:%.*]], <4 x i64> [[TMP10:%.*]]
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast <4 x %"struct.std::complex"*> [[TMP11]] to <4 x float*>
; CHECK-NEXT:    [[DOTREPLICATED_ELTS210:%.*]] = shufflevector <4 x float*> [[TMP12]], <4 x float*> undef, <8 x i32> <i32 0, i32 0, i32 1, i32 1, i32 2, i32 2, i32 3, i32 3>
; CHECK-NEXT:    store <8 x float*> [[DOTREPLICATED_ELTS210]], <8 x float*>* [[T26:%.*]], align 64
; CHECK-NEXT:    [[T26_:%.*]] = load <8 x float*>, <8 x float*>* [[T26]], align 64
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds float, <8 x float*> [[T26_]], <8 x i64> <i64 0, i64 1, i64 0, i64 1, i64 0, i64 1, i64 0, i64 1>
; CHECK-NEXT:    [[T23_:%.*]] = load <8 x float>, <8 x float>* [[T23:%.*]], align 32
; CHECK-NEXT:    call void @llvm.masked.scatter.v8f32.v8p0f32(<8 x float> [[T23_]], <8 x float*> [[TMP13]], i32 4, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>)

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"struct.std::complex" = type { { float, float } }

define dso_local void @foo(%"struct.std::complex"* nocapture readonly %src, %"struct.std::complex"* nocapture %dst) {
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %mul.ld = mul nsw i64 %indvars.iv, 2
  %ptr.ld = getelementptr inbounds %"struct.std::complex", %"struct.std::complex"* %src, i64 %mul.ld
  %bc.ld = bitcast %"struct.std::complex"* %ptr.ld to <2 x float>*
  %val = load <2 x float>, <2 x float>* %bc.ld, align 4
  %add7 = fadd fast <2 x float> %val, <float 7.0, float 7.0>
  %mul.st = mul nsw i64 %indvars.iv, 3
  %ptr.st = getelementptr inbounds %"struct.std::complex", %"struct.std::complex"* %dst, i64 %mul.st
  %bc.st = bitcast %"struct.std::complex"* %ptr.st to <2 x float>*
  store <2 x float> %add7, <2 x float>* %bc.st, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp ult i64 %indvars.iv.next, 1024
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !1

for.end:                                          ; preds = %for.body
  ret void
}

!1 = distinct !{!1, !2, !3}
!2 = !{!"llvm.loop.mustprogress"}
!3 = !{!"llvm.loop.vectorize.ivdep_back"}
