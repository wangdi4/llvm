; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt %s -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -print-after=hir-vplan-vec -disable-output 2>&1 | FileCheck %s

@g = global i32 0
@a = global i32 0

define i32 @main() {
; CHECK:      BEGIN REGION { modified }
; CHECK-NEXT:       [[TGU0:%.*]] = (sext.i32.i64([[TMP2:%.*]]) + -1 * sext.i32.i64([[TMP3:%.*]]))/u4
; CHECK-NEXT:       if (0 <u 4 * [[TGU0]])
; CHECK-NEXT:       {
; CHECK-NEXT:             [[RED_VAR0:%.*]] = [[TMP13:%.*]];
; CHECK-NEXT:             [[RED_VAR10:%.*]] = -1
; CHECK-NEXT:             [[RED_VAR20:%.*]] = [[TMP10:%.*]];
; CHECK-NEXT:             [[RED_VAR30:%.*]] = [[TMP12:%.*]];
; CHECK-NEXT:             [[RED_VAR40:%.*]] = -1
; CHECK-NEXT:             [[RED_VAR50:%.*]] = [[TMP9:%.*]];
; CHECK-NEXT:          + DO i1 = 0, 4 * [[TGU0]] + -1, 4   <DO_LOOP> <auto-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:          |   [[DOTVEC0:%.*]] = [[RED_VAR0]] > 0.000000e+00
; CHECK-NEXT:          |   [[RED_VAR10]] = ([[RED_VAR0]] > 0.000000e+00) ? i1 + <i64 0, i64 1, i64 2, i64 3> : [[RED_VAR10]]
; CHECK-NEXT:          |   [[RED_VAR20]] = ([[RED_VAR0]] > 0.000000e+00) ? i1 + sext.i32.i64([[TMP3]]) + <i64 0, i64 1, i64 2, i64 3> : [[RED_VAR20]]
; CHECK-NEXT:          |   [[RED_VAR0]] = ([[RED_VAR0]] > 0.000000e+00) ? 0.000000e+00 : [[RED_VAR0]]
; CHECK-NEXT:          |   [[DOTVEC140:%.*]] = [[RED_VAR30]] > 0.000000e+00
; CHECK-NEXT:          |   [[RED_VAR40]] = ([[RED_VAR30]] > 0.000000e+00) ? i1 + <i64 0, i64 1, i64 2, i64 3> : [[RED_VAR40]]
; CHECK-NEXT:          |   [[RED_VAR50]] = ([[RED_VAR30]] > 0.000000e+00) ? i1 + sext.i32.i64([[TMP3]]) + <i64 0, i64 1, i64 2, i64 3> : [[RED_VAR50]]
; CHECK-NEXT:          |   [[RED_VAR30]] = ([[RED_VAR30]] > 0.000000e+00) ? 0.000000e+00 : [[RED_VAR30]]
; CHECK-NEXT:          + END LOOP
; CHECK-NEXT:             [[TMP13]] = @llvm.vector.reduce.fmin.v4f64([[RED_VAR0]])
; CHECK-NEXT:             [[IDX_BLEND0:%.*]] = ([[TMP13]] == [[RED_VAR0]]) ? [[RED_VAR10]] : <i64 9223372036854775807, i64 9223372036854775807, i64 9223372036854775807, i64 9223372036854775807>
; CHECK-NEXT:             [[VEC_REDUCE0:%.*]] = @llvm.vector.reduce.smin.v4i64([[IDX_BLEND0]])
; CHECK-NEXT:             [[MMIDX_CMP_0:%.*]] = [[VEC_REDUCE0]] == [[RED_VAR10]]
; CHECK-NEXT:             [[BSFINTMASK0:%.*]] = bitcast.<4 x i1>.i4([[MMIDX_CMP_0]])
; CHECK-NEXT:             [[BSF0:%.*]] = @llvm.cttz.i4([[BSFINTMASK0]],  1)
; CHECK-NEXT:             [[TMP10]] = extractelement [[RED_VAR20]],  [[BSF0]]
; CHECK-NEXT:             [[TMP12]] = @llvm.vector.reduce.fmin.v4f64([[RED_VAR30]])
; CHECK-NEXT:             [[IDX_BLEND190:%.*]] = ([[TMP12]] == [[RED_VAR30]]) ? [[RED_VAR40]] : <i64 9223372036854775807, i64 9223372036854775807, i64 9223372036854775807, i64 9223372036854775807>
; CHECK-NEXT:             [[VEC_REDUCE200:%.*]] = @llvm.vector.reduce.smin.v4i64([[IDX_BLEND190]])
; CHECK-NEXT:             [[MMIDX_CMP_210:%.*]] = [[VEC_REDUCE200]] == [[RED_VAR40]]
; CHECK-NEXT:             [[BSFINTMASK220:%.*]] = bitcast.<4 x i1>.i4([[MMIDX_CMP_210]])
; CHECK-NEXT:             [[BSF230:%.*]] = @llvm.cttz.i4([[BSFINTMASK220]],  1)
; CHECK-NEXT:             [[TMP9]] = extractelement [[RED_VAR50]],  [[BSF230]]
; CHECK-NEXT:       }
;
; CHECK:            + DO i1 = 4 * [[TGU0]], sext.i32.i64([[TMP2]]) + -1 * sext.i32.i64([[TMP3]]) + -1, 1   <DO_LOOP>  <MAX_TC_EST = 3> <nounroll> <novectorize> <max_trip_count = 3>
; CHECK-NEXT:       |   [[TMP10]] = ([[TMP13]] > 0.000000e+00) ? i1 + sext.i32.i64([[TMP3]]) : [[TMP10]]
; CHECK-NEXT:       |   [[TMP13]] = ([[TMP13]] > 0.000000e+00) ? 0.000000e+00 : [[TMP13]]
; CHECK-NEXT:       |   [[TMP9]] = ([[TMP12]] > 0.000000e+00) ? i1 + sext.i32.i64([[TMP3]]) : [[TMP9]]
; CHECK-NEXT:       |   [[TMP12]] = ([[TMP12]] > 0.000000e+00) ? 0.000000e+00 : [[TMP12]]
; CHECK-NEXT:       + END LOOP
; CHECK-NEXT: END REGION
;
  %1 = tail call i32 (i32*, i8*, ...) @fscanf(i32* undef, i8* undef)
  %2 = load i32, i32* @a
  %3 = load i32, i32* @g
  %4 = icmp slt i32 %3, %2
  br i1 %4, label %5, label %27

5:                                                ; preds = %0
  %6 = sext i32 %3 to i64
  %7 = sext i32 %2 to i64
  br label %8

8:                                                ; preds = %8, %5
  %9 = phi i32 [ 1, %5 ], [ %20, %8 ]
  %10 = phi i32 [ 1, %5 ], [ %16, %8 ]
  %11 = phi i64 [ %6, %5 ], [ %22, %8 ]
  %12 = phi double [ undef, %5 ], [ %21, %8 ]
  %13 = phi double [ undef, %5 ], [ %17, %8 ]
  %14 = fcmp fast ogt double %13, 0.000000e+00
  %15 = trunc i64 %11 to i32
  %16 = select i1 %14, i32 %15, i32 %10
  %17 = select i1 %14, double 0.000000e+00, double %13
  %18 = fcmp fast ogt double %12, 0.000000e+00
  %19 = trunc i64 %11 to i32
  %20 = select i1 %18, i32 %19, i32 %9
  %21 = select i1 %18, double 0.000000e+00, double %12
  %22 = add nsw i64 %11, 1
  %23 = icmp eq i64 %22, %7
  br i1 %23, label %24, label %8

24:                                               ; preds = %8
  %25 = phi i32 [ %16, %8 ]
  %26 = phi i32 [ %20, %8 ]
  store i32 %2, i32* @g, align 4
  br label %27

27:
  ret i32 0
}

declare i32 @fscanf(i32*, i8*, ...)
