; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -passes="vplan-vec" -mtriple=x86_64-unknown-linux-gnu < %s | FileCheck %s

define void @foo() {
; CHECK-LABEL: @foo(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VPLANNEDBB2:%.+]] ], [ [[TMP2:%.*]], [[VECTOR_BODY:%.+]] ]
; CHECK-NEXT:    [[UNI_PHI4:%.*]] = phi i64 [ undef, [[VPLANNEDBB2]] ], [ [[TMP1:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i64> [ undef, [[VPLANNEDBB2]] ], [ [[TMP0:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP0]] = add nsw <2 x i64> [[VEC_PHI]], zeroinitializer
; CHECK-NEXT:    [[TMP1]] = add nsw i64 [[UNI_PHI4]], 0
; CHECK-NEXT:    [[TMP2]] = add i64 [[UNI_PHI]], 2
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ult i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[TMP3]], label [[VECTOR_BODY]], label [[VPLANNEDBB5:%.*]], !llvm.loop [[LOOP0:![0-9]+]]
;
entry:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %body

body:
  %1 = phi i64 [ undef, %entry ], [ %3, %body ]
  %2 = getelementptr inbounds i8, i8* undef, i64 undef
  %3 = add nsw i64 %1, undef
  %4 = icmp sgt i64 undef, undef
  br i1 %4, label %body, label %exit

exit:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

