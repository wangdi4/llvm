; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt %s -disable-output -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -print-after=hir-vplan-vec -vplan-force-vf=8 2>&1 | FileCheck %s
; RUN: opt %s -disable-output -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -vplan-force-vf=8 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local void @_Z3vecPlil(i64* nocapture noundef writeonly %A, i32 noundef %c, i64 noundef %N) local_unnamed_addr {
; CHECK-LABEL:  Function: _Z3vecPlil
; CHECK:             [[LOOP_UB0:%.*]] = [[VEC_TC20:%.*]]  -  1
; CHECK:             + DO i1 = 0, [[LOOP_UB0]], 32   <DO_LOOP> <auto-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:        |   (<8 x i64>*)([[A0:%.*]])[i1] = i1 + sext.i32.i64([[C0:%.*]]) + <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7>
; CHECK-NEXT:        |   (<8 x i64>*)([[A0]])[i1 + 8] = i1 + sext.i32.i64([[C0]]) + <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7> + 8
; CHECK-NEXT:        |   (<8 x i64>*)([[A0]])[i1 + 16] = i1 + sext.i32.i64([[C0]]) + <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7> + 16
; CHECK-NEXT:        |   (<8 x i64>*)([[A0]])[i1 + 24] = i1 + sext.i32.i64([[C0]]) + <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7> + 24
; CHECK-NEXT:        + END LOOP
; CHECK:             [[LOOP_UB80:%.*]] = [[N0:%.*]]  -  1
; CHECK:             + DO i1 = [[PHI_TEMP0:%.*]], [[LOOP_UB80]], 8   <DO_LOOP>  <MAX_TC_EST = 1>  <LEGAL_MAX_TC = 1> <vector-remainder> <nounroll> <novectorize> <max_trip_count = 1>
; CHECK-NEXT:        |   [[DOTVEC90:%.*]] = i1 + <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7> <u [[N0]]
; CHECK-NEXT:        |   (<8 x i64>*)([[A0]])[i1] = i1 + sext.i32.i64([[C0]]) + <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7>, Mask = @{[[DOTVEC90]]}
; CHECK-NEXT:        |   [[DOTVEC100:%.*]] = i1 + <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7> + 8 <u [[N0]]
; CHECK:             + END LOOP
entry:
  %conv = sext i32 %c to i64
  br label %for.body

for.cond.cleanup:
  ret void

for.body:
  %i.06 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %add = add nsw i64 %i.06, %conv
  %arrayidx = getelementptr inbounds i64, i64* %A, i64 %i.06
  store i64 %add, i64* %arrayidx, align 8
  %inc = add nuw nsw i64 %i.06, 1
  %exitcond.not = icmp eq i64 %inc, %N
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !llvm.loop !1
}

!1 = distinct !{!1, !2, !3, !4}
!2 = !{!"llvm.loop.mustprogress"}
!3 = !{!"llvm.loop.unroll.count", i32 4}
!4 = !{!"llvm.loop.intel.vector.vecremainder", !"true"}
