; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Check scalar live-inout descriptor creation.
; Both reduction and induction are live out.
; RUN: opt -vplan-vec -vplan-print-after-live-inout-list -vplan-dump-live-inout -vplan-entities-dump -S < %s 2>&1 | FileCheck %s


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

;int foo(int *A, int N, int Init) {
;  int Sum = Init;
;  int i;
;#pragma opt simd
;  for (i = 0; i<N; i++)
;    Sum+= A[i];
;  return Sum + i;
;}

define i32 @foo(i32* nocapture readonly %A, i32 %N, i32 %Init) {
;
; CHECK-LABEL:  VPlan after live in/out lists creation:
; CHECK-NEXT:  VPlan IR for: foo:for.body
; CHECK-NEXT:  Live-in values:
; CHECK-NEXT:  ID: 0 Value: i32 [[INIT0:%.*]]
; CHECK-NEXT:  ID: 1 Value: i64 0
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   (+) Start: i32 [[INIT0]] Exit: i32 [[VP_ADD:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP_SUM_07:%.*]], i32 [[VP_ADD]], i32 [[VP_SUM_07_RED_INIT:%.*]], i32 [[VP_SUM_07_RED_FINAL:%.*]],
; CHECK:       Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: i64 2147483647 BinOp: i64 [[VP_INDVARS_IV_NEXT:%.*]] = add i64 [[VP_INDVARS_IV:%.*]] i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP_INDVARS_IV]], i64 [[VP_INDVARS_IV_NEXT]], i64 [[VP_INDVARS_IV_IND_INIT:%.*]], i64 [[VP_INDVARS_IV_IND_INIT_STEP]], i64 [[VP_INDVARS_IV_IND_FINAL:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i32 [[VP_SUM_07_RED_INIT]] = reduction-init i32 0 i32 live-in0
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT]] = induction-init{add} i64 live-in1 i64 1
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT_STEP]] = induction-init-step{add} i64 1
; CHECK-NEXT:     i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[WIDE_TRIP_COUNT0:%.*]], UF = 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB0]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV]] = phi  [ i64 [[VP_INDVARS_IV_NEXT]], [[BB0]] ],  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB2]] ]
; CHECK-NEXT:     i32 [[VP_SUM_07]] = phi  [ i32 [[VP_ADD]], [[BB0]] ],  [ i32 [[VP_SUM_07_RED_INIT]], [[BB2]] ]
; CHECK-NEXT:     i32* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i32* [[A0:%.*]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     i32 [[VP_A_I:%.*]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:     i32 [[VP_ADD]] = add i32 [[VP_A_I]] i32 [[VP_SUM_07]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP_EXITCOND:%.*]] = icmp uge i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     br i1 [[VP_EXITCOND]], [[BB3:BB[0-9]+]], [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP_SUM_07_RED_FINAL]] = reduction-final{u_add} i32 [[VP_ADD]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_FINAL]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  Live-out values:
; CHECK-NEXT:  live-out0(i32 [[VP_SUM_07_RED_FINAL]])
; CHECK-NEXT:  live-out1(i64 [[VP_INDVARS_IV_IND_FINAL]])
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0     [[ADD_LCSSA0:%.*]] = phi i32 [ [[ADD0:%.*]], [[FOR_BODY0:%.*]] ] i32 [[VP_SUM_07_RED_FINAL]] -> i32 [[ADD0]]
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1     [[IND_LCSSA0:%.*]] = phi i64 [ [[INDVARS_IV_NEXT0:%.*]], [[FOR_BODY0]] ] i64 [[VP_INDVARS_IV_IND_FINAL]] -> i64 [[INDVARS_IV_NEXT0]]
; CHECK-EMPTY:
; CHECK-NEXT:  Original loop live-ins/live-outs:
; CHECK-NEXT:    Id: 1
; CHECK-NEXT:      Phi:   [[INDVARS_IV0:%.*]] = phi i64 [ [[INDVARS_IV_NEXT0]], [[FOR_BODY0]] ], [ 0, [[FOR_BODY_PH0:%.*]] ]    Start op: 1
; CHECK-NEXT:      Live-Out:   [[INDVARS_IV_NEXT0]] = add nuw nsw i64 [[INDVARS_IV0]], 1
; CHECK-NEXT:    Id: 0
; CHECK-NEXT:      Phi:   [[SUM_070:%.*]] = phi i32 [ [[ADD0]], [[FOR_BODY0]] ], [ [[INIT0]], [[FOR_BODY_PH0]] ]    Start op: 1
; CHECK-NEXT:      Live-Out:   [[ADD0]] = add nsw i32 [[A_I0:%.*]], [[SUM_070]]
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %DIR.QUAL.LIST.END.2

DIR.QUAL.LIST.END.2:
  %cmp6 = icmp sgt i32 %N, 0
  br i1 %cmp6, label %for.body.ph, label %for.cond.cleanup

for.body.ph:                                 ; preds = %0
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.body:                                           ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.ph ]
  %Sum.07 = phi i32 [ %add, %for.body ], [ %Init, %for.body.ph ]
  %arrayidx = getelementptr inbounds i32, i32* %A, i64 %indvars.iv
  %A.i = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %A.i, %Sum.07
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body

for.cond.cleanup.loopexit:                             ; preds = %for.body
  %add.lcssa = phi i32 [ %add, %for.body ]
  %ind.lcssa = phi i64 [ %indvars.iv.next, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                      ; preds = %for.cond.cleanup.loopexit, %0
  %Sum.0.lcssa = phi i32 [ %Init, %DIR.QUAL.LIST.END.2 ], [ %add.lcssa, %for.cond.cleanup.loopexit ]
  %ind.0.lcssa = phi i64 [ 0, %DIR.QUAL.LIST.END.2 ], [ %ind.lcssa, %for.cond.cleanup.loopexit ]
  %ind32 = trunc i64 %ind.0.lcssa to i32
  %s = add i32 %Sum.0.lcssa, %ind32
  br label %end.simd

end.simd:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.QUAL.LIST.END.3

DIR.QUAL.LIST.END.3:
  ret i32 %s

}
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
