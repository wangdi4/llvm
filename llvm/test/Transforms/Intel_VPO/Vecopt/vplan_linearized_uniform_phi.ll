; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -VPlanDriver -vplan-force-vf=2 -S -vplan-print-after-linearization 2>&1 | FileCheck %s
define void @foo(i64 *%p, i1 %uniform) #0 {
; CHECK-LABEL:  VPlan after predication and linearization:
; CHECK-NEXT:  Live-in values:
; CHECK-NEXT:  ID: 0 Value: i64 0
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     [DA: Uni] i1 [[VP_UNIFORM_NOT:%.*]] = not i1 [[UNIFORM0:%.*]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_IV_IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VF:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop header
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_IV_NEXT:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_COND:%.*]] = icmp sgt i64 [[VP_IV]] i64 0
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM_NOT:%.*]] = and i1 [[VP_COND]] i1 [[VP_UNIFORM_NOT]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB3_BR_VP_UNIFORM:%.*]] = and i1 [[VP_COND]] i1 [[UNIFORM0]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB6:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM_NOT]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP2:%.*]] = block-predicate i1 [[VP_BB3_BR_VP_UNIFORM]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB8:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_BLEND_BLEND_BB5:%.*]] = blend [ i64 2, i1 [[VP_BB3_BR_VP_UNIFORM_NOT]] ], [ i64 1, i1 [[VP_BB3_BR_VP_UNIFORM]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_COND]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VAL:%.*]] = add i64 [[VP_BLEND_BLEND_BB5]] i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB9:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_COND]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB8]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_ST_BLEND_BB8:%.*]] = blend [ i64 -1, i1 true ], [ i64 [[VP_VAL]], i1 [[VP_COND]] ]
; CHECK-NEXT:     [DA: Div] i64* [[VP_GEP:%.*]] = getelementptr i64* [[P0:%.*]] i64 [[VP_IV]]
; CHECK-NEXT:     [DA: Div] store i64 [[VP_ST_BLEND_BB8]] i64* [[VP_GEP]]
; CHECK-NEXT:     [DA: Div] i64 [[VP_IV_NEXT]] = add i64 [[VP_IV]] i64 [[VP_IV_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_LOOP_IV_NEXT]] = add i64 [[VP_VECTOR_LOOP_IV]] i64 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp eq i64 [[VP_VECTOR_LOOP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB10:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]:
; CHECK-NEXT:     [DA: Uni] i64 [[VP_IV_IND_FINAL:%.*]] = induction-final{add} i64 live-in0 i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB11:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i64 [[VP_IV_IND_FINAL]]
;
; CHECK:  define void @foo(i64* [[P0]], i1 [[UNIFORM0]]) #0 {
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VECTOR_PH0:%.*]] ], [ [[TMP8:%.*]], [[VECTOR_BODY0:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI10:%.*]] = phi i64 [ 0, [[VECTOR_PH0]] ], [ [[TMP7:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i64> [ <i64 0, i64 1>, [[VECTOR_PH0]] ], [ [[TMP6:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp sgt <2 x i64> [[VEC_PHI0]], zeroinitializer
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i1> [[TMP1]], [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = and <2 x i1> [[TMP1]], [[BROADCAST_SPLAT0:%.*]]
; CHECK-NEXT:    [[PREDBLEND0:%.*]] = select <2 x i1> [[TMP3]], <2 x i64> <i64 1, i64 1>, <2 x i64> <i64 2, i64 2>
; FIXME: This extract is invalid, lane zero might be inactive and contain garbage.
;        DA's uniformity only guarantees that the *active* lanes contain uniform value.
; CHECK-NEXT:    [[PREDBLEND_EXTRACT_0_0:%.*]] = extractelement <2 x i64> [[PREDBLEND0]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = add i64 [[PREDBLEND_EXTRACT_0_0]], 1
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT20:%.*]] = insertelement <2 x i64> undef, i64 [[TMP4]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT30:%.*]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT20]], <2 x i64> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[PREDBLEND40:%.*]] = select <2 x i1> [[TMP1]], <2 x i64> [[BROADCAST_SPLAT30]], <2 x i64> <i64 -1, i64 -1>
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr i64, i64* [[P0]], i64 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i64* [[SCALAR_GEP0]] to <2 x i64>*
; CHECK-NEXT:    store <2 x i64> [[PREDBLEND40]], <2 x i64>* [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6]] = add nuw nsw <2 x i64> [[VEC_PHI0]], <i64 2, i64 2>
; CHECK-NEXT:    [[TMP7]] = add nuw nsw i64 [[UNI_PHI10]], 2
; CHECK-NEXT:    [[TMP8]] = add i64 [[UNI_PHI0]], 2
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP8]], 4
; CHECK-NEXT:    br i1 [[TMP9]], label [[VPLANNEDBB0:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cond = icmp sgt i64 %iv, 0
  br i1 %cond, label %uni.start, label %latch

uni.start:
  br i1 %uniform, label %if.then, label %if.else

if.then:
  br label %if.end

if.else:
  br label %if.end

if.end:
  %blend = phi i64 [ 1, %if.then ], [ 2, %if.else]
  %val = add nsw nuw i64 %blend, 1
  br label %uni.end

uni.end:
  br label %latch

latch:
  %st = phi i64 [ -1, %header ], [ %val, %uni.end]
  %gep = getelementptr i64, i64 *%p, i64 %iv
  store i64 %st, i64 *%gep
  %iv.next = add nsw nuw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 4
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; This could be used to test through 'lli' like
;
; Original incorrect behavior:
; $ opt -VPlanDriver -vplan-force-vf=2 -remove-region-directives -S %s | lli  ; echo $?
; 3
; Expected correct results:
; $ opt -remove-region-directives -S %s | lli  ; echo $?
; 2
;
; define i32 @main() {
;   %p = alloca i64, i64 42
;   call void @foo(i64 *%p, i1 true)
;   %q = getelementptr i64, i64 *%p, i64 1
;   %ret = load i64, i64 *%q
;   %trunc = trunc i64 %ret to i32
;   ret i32 %trunc
; }

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)

attributes #0 = { noinline }
