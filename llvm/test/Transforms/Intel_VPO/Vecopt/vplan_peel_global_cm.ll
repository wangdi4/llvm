; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -vplan-vec -vplan-enable-general-peeling=true  -debug-only=LoopVectorizationPlanner -disable-output < %s 2>&1 | FileCheck %s --check-prefix=VPLAN-CM-PEELING
; RUN: opt -S -vplan-vec -vplan-enable-general-peeling=false -debug-only=LoopVectorizationPlanner -disable-output < %s 2>&1 | FileCheck %s --check-prefix=VPLAN-CM-NO-PEELING
; REQUIRES: asserts

target triple = "x86_64-unknown-linux-gnu"

define void @test(i32* %buf1, i32* %buf2, i32* %buf3) {
; VPLAN-CM-PEELING:  Selecting VF for VPlan test:for.body.#{{[0-9]+}}
; VPLAN-CM-PEELING-NEXT:  Cost of Scalar VPlan: 51200
; VPLAN-CM-PEELING-NEXT:  '#pragma vector always'/ '#pragma omp simd' is used for the given loop
; VPLAN-CM-PEELING-NEXT:  Selected peeling: Static(1)
; VPLAN-CM-PEELING-NEXT:  Using cost model to enable peeling. Trip count is known. GoUnaligned = UnalignedGain > AlignedGain: -16000 > -15676.9375 = 0
; VPLAN-CM-PEELING-NEXT:  Scalar Cost = 10240 x 5 = 51200 < VectorCost = 5 + 5119 x 13.0625 + 5 = 66876.9375
; VPLAN-CM-PEELING-NEXT:  Peel loop cost = 5 (scalar peel loop)
; VPLAN-CM-PEELING-NEXT:  Main loop vector cost = 66866.9375
; VPLAN-CM-PEELING-NEXT:  Remainder loop cost = 5 (scalar remainder loop)
; VPLAN-CM-PEELING-NEXT:   VectorCostWithoutPeel = 5120 x 13.125 = 67200
; VPLAN-CM-PEELING-NEXT:  Main loop vector cost without peel = 67200
; VPLAN-CM-PEELING-NEXT:  Remainder loop cost without peel = 0 (no remainder loop)
; VPLAN-CM-PEELING-NEXT:  Peeling will be performed.
; VPLAN-CM-PEELING-NEXT:  Selected peeling: Static(1)
; VPLAN-CM-PEELING-NEXT:  Using cost model to enable peeling. Trip count is known. GoUnaligned = UnalignedGain > AlignedGain: -6400 > -5917.6875 = 0
; VPLAN-CM-PEELING-NEXT:  Scalar Cost = 10240 x 5 = 51200 < VectorCost = 5 + 2559 x 22.3125 + 15 = 57117.6875
; VPLAN-CM-PEELING-NEXT:  Peel loop cost = 5 (scalar peel loop)
; VPLAN-CM-PEELING-NEXT:  Main loop vector cost = 57097.6875
; VPLAN-CM-PEELING-NEXT:  Remainder loop cost = 15 (scalar remainder loop)
; VPLAN-CM-PEELING-NEXT:   VectorCostWithoutPeel = 2560 x 22.5 = 57600
; VPLAN-CM-PEELING-NEXT:  Main loop vector cost without peel = 57600
; VPLAN-CM-PEELING-NEXT:  Remainder loop cost without peel = 0 (no remainder loop)
; VPLAN-CM-PEELING-NEXT:  Peeling will be performed.
; VPLAN-CM-PEELING-NEXT:  Selecting VPlan with VF=4
;
; VPLAN-CM-NO-PEELING:  Selecting VF for VPlan test:for.body.#{{[0-9]+}}
; VPLAN-CM-NO-PEELING-NEXT:  Cost of Scalar VPlan: 51200
; VPLAN-CM-NO-PEELING-NEXT:  '#pragma vector always'/ '#pragma omp simd' is used for the given loop
; VPLAN-CM-NO-PEELING-NEXT:  Selected peeling: None
; VPLAN-CM-NO-PEELING-NEXT:  Scalar Cost = 10240 x 5 = 51200 < VectorCost = 0 + 5120 x 13.125 + 0 = 67200
; VPLAN-CM-NO-PEELING-NEXT:  Peel loop cost = 0 (no peel loop)
; VPLAN-CM-NO-PEELING-NEXT:  Main loop vector cost = 67200
; VPLAN-CM-NO-PEELING-NEXT:  Remainder loop cost = 0 (no remainder loop)
; VPLAN-CM-NO-PEELING-NEXT:   VectorCostWithoutPeel = 5120 x 13.125 = 67200
; VPLAN-CM-NO-PEELING-NEXT:  Main loop vector cost without peel = 67200
; VPLAN-CM-NO-PEELING-NEXT:  Remainder loop cost without peel = 0 (no remainder loop)
; VPLAN-CM-NO-PEELING-NEXT:  Peeling will not be performed.
; VPLAN-CM-NO-PEELING-NEXT:  Selected peeling: None
; VPLAN-CM-NO-PEELING-NEXT:  Scalar Cost = 10240 x 5 = 51200 < VectorCost = 0 + 2560 x 22.5 + 0 = 57600
; VPLAN-CM-NO-PEELING-NEXT:  Peel loop cost = 0 (no peel loop)
; VPLAN-CM-NO-PEELING-NEXT:  Main loop vector cost = 57600
; VPLAN-CM-NO-PEELING-NEXT:  Remainder loop cost = 0 (no remainder loop)
; VPLAN-CM-NO-PEELING-NEXT:   VectorCostWithoutPeel = 2560 x 22.5 = 57600
; VPLAN-CM-NO-PEELING-NEXT:  Main loop vector cost without peel = 57600
; VPLAN-CM-NO-PEELING-NEXT:  Remainder loop cost without peel = 0 (no remainder loop)
; VPLAN-CM-NO-PEELING-NEXT:  Peeling will not be performed.
; VPLAN-CM-NO-PEELING-NEXT:  Selecting VPlan with VF=4
;
real_entry:
  %buf1.asInt = ptrtoint i32* %buf1 to i64
  %buf2.asInt = ptrtoint i32* %buf2 to i64
  %buf3.asInt = ptrtoint i32* %buf3 to i64
  %tmp1 = and i64 %buf1.asInt, -64
  %tmp2 = and i64 %buf2.asInt, -64
  %tmp3 = and i64 %buf3.asInt, -64
  %ptr1.asInt = or i64 %tmp1, 52
  %ptr2.asInt = or i64 %tmp2, 12
  %ptr3.asInt = or i64 %tmp3, 24
  %ptr1 = inttoptr i64 %ptr1.asInt to i32*
  %ptr2 = inttoptr i64 %ptr2.asInt to i32*
  %ptr3 = inttoptr i64 %ptr3.asInt to i32*
  br label %entry

entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %counter = phi i64 [ 0, %entry ], [ %counter.next, %for.body ]
  %count32 = trunc i64 %counter to i32
  %p1 = getelementptr inbounds i32, i32* %ptr1, i64 %counter
  %p2 = getelementptr inbounds i32, i32* %ptr2, i64 %counter
  %p3 = getelementptr inbounds i32, i32* %ptr3, i64 %counter
  store i32 %count32, i32* %p1
  store i32 %count32, i32* %p2
  store i32 %count32, i32* %p3
  %counter.next = add nsw i64 %counter, 1
  %exitcond = icmp sge i64 %counter.next, 10240
  br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !1

for.end:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

!0 = !{!"llvm.loop.vectorize.dynamic_align", i1 true}
!1 = distinct !{!1, !0}
