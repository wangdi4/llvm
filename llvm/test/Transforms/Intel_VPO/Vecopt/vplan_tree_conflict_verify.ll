; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Checks if tree conflict is lowered to double permute tree reduction

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; RUN: opt -opaque-pointers=0 -S -mattr=+avx512vl,+avx512cd -vplan-force-vf=4 -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-lower-tree-conflict -disable-output < %s 2>&1 | FileCheck %s

; Verify lowering of tree conflict right after the transformation.

; Function Attrs: nofree norecurse nosync nounwind uwtable
define dso_local void @foo(float* noalias nocapture noundef %A, i32* nocapture noundef readonly %B, float* noalias nocapture noundef readonly %C) local_unnamed_addr #0 {
;
; float A[8], C[8];
; int B[8]; // conflict idx
; for (int i=0; i<8; ++i) {
;   int index = B[i];
;   A[index] = A[index] + C[i];
; }
;
; CHECK-LABEL:  VPlan after VPlanLowerTreeConflict:
; CHECK-NEXT:  VPlan IR for: Initial VPlan for VF=4
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%B}
; CHECK-DAG:     [[VP1:%.*]] = {%A}
; CHECK-DAG:     [[VP2:%.*]] = {%C}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB1:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 8, UF = 1 (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Div, SVA: (F  )] i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1 (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB2:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     [DA: Div, SVA: (F  )] i64 [[VP3:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP4:%.*]], [[BB3]] ] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Div, SVA: (F  )] i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[B0:%.*]] i64 [[VP3]] (SVAOpBits 0->F 1->F 2->F 3->F )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]] (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Div, SVA: (F  )] float* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds float* [[C0:%.*]] i64 [[VP3]] (SVAOpBits 0->F 1->F 2->F 3->F )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] float [[VP_LOAD_1:%.*]] = load float* [[VP_SUBSCRIPT_1]] (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i64 [[VP_VCONFLICT_INDEX:%.*]] = sext i32 [[VP_LOAD]] to i64 (SVAOpBits 0->V )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] float* [[VP_SUBSCRIPT_2:%.*]] = subscript inbounds float* [[A0:%.*]] i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0->V 1->V 2->V 3->V )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] float [[VP_LOAD_2:%.*]] = load float* [[VP_SUBSCRIPT_2]] (SVAOpBits 0->V )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] float* [[VP_SUBSCRIPT_3:%.*]] = subscript inbounds float* [[A0]] i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0->V 1->V 2->V 3->V )
; CHECK-NEXT:     [DA: Div, SVA: (   )] i64 [[VP_VPCONFLICT_INTRINSIC:%.*]] = vpconflict-insn i64 [[VP_VCONFLICT_INDEX]] (SVAOpBits 0-> )
; CHECK-NEXT:     [DA: Div, SVA: (   )] i64 [[VP_CTLZ:%.*]] = call i64 [[VP_VPCONFLICT_INTRINSIC]] i1 false llvm.ctlz [x 1] (SVAOpBits 0-> 1-> 2-> )
; CHECK-NEXT:     [DA: Div, SVA: (   )] i64 [[VP6:%.*]] = sub i64 63 i64 [[VP_CTLZ]] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:     [DA: Div, SVA: (   )] i32 [[VP7:%.*]] = trunc i64 [[VP6]] to i32 (SVAOpBits 0-> )
; CHECK-NEXT:     [DA: Div, SVA: (   )] i1 [[VP_MASK_TODO:%.*]] = icmp ne i32 [[VP7]] i32 -1 (SVAOpBits 0-> 1-> )
; CHECK-NEXT:     [DA: Uni, SVA: (   )] i1 [[VP_CONFLICT_TOP_TEST:%.*]] = all-zero-check i1 [[VP_MASK_TODO]] (SVAOpBits 0-> )
; CHECK-NEXT:     [DA: Uni, SVA: (   )] br i1 [[VP_CONFLICT_TOP_TEST]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Uni, SVA: (   )] br [[BB6:BB[0-9]+]] (SVAOpBits 0-> )
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]: # preds: [[BB5]], [[BB6]]
; CHECK-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_CURR_VPERM_CONTROL:%.*]] = phi  [ i32 [[VP7]], [[BB5]] ],  [ i32 [[VP_VPERM_CONTROL_SELECT:%.*]], [[BB6]] ] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] float [[VP_CURR_VRES:%.*]] = phi  [ float [[VP_LOAD_1]], [[BB5]] ],  [ float [[VP_VRES_NEXT:%.*]], [[BB6]] ] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_CURR_MASK_TODO:%.*]] = phi  [ i1 [[VP_MASK_TODO]], [[BB5]] ],  [ i1 [[VP_MASK_TODO_NEXT:%.*]], [[BB6]] ] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] float [[VP_VTMP:%.*]] = permute float [[VP_CURR_VRES]] i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_DUMMY_CMP:%.*]] = icmp eq i1 [[VP_CURR_MASK_TODO]] i1 true (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] float [[VP_VTMP_SELECT:%.*]] = select i1 [[VP_DUMMY_CMP]] float [[VP_VTMP]] float 0.000000e+00 (SVAOpBits 0-> 1-> 2-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] float [[VP8:%.*]] = fadd float [[VP_VTMP_SELECT]] float [[VP_CURR_VRES]] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] float [[VP_VRES_NEXT]] = select i1 [[VP_DUMMY_CMP]] float [[VP8]] float [[VP_CURR_VRES]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] float [[VP9:%.*]] = bitcast i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] float [[VP_VPERM_CONTROL_NEXT:%.*]] = permute float [[VP9]] i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] i32 [[VP10:%.*]] = bitcast float [[VP_VPERM_CONTROL_NEXT]] (SVAOpBits 0-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] i32 [[VP_VPERM_CONTROL_SELECT]] = select i1 [[VP_DUMMY_CMP]] i32 [[VP10]] i32 [[VP_CURR_VPERM_CONTROL]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-NEXT:       [DA: Div, SVA: (   )] i1 [[VP_MASK_TODO_NEXT]] = icmp ne i32 [[VP_VPERM_CONTROL_SELECT]] i32 -1 (SVAOpBits 0-> 1-> )
; CHECK-NEXT:       [DA: Uni, SVA: (   )] i1 [[VP_LATCH_COND:%.*]] = all-zero-check i1 [[VP_MASK_TODO_NEXT]] (SVAOpBits 0-> )
; CHECK-NEXT:       [DA: Uni, SVA: (   )] i1 [[VP_LATCH_COND_NOT:%.*]] = not i1 [[VP_LATCH_COND]] (SVAOpBits 0-> )
; CHECK-NEXT:       [DA: Uni, SVA: (   )] br i1 [[VP_LATCH_COND_NOT]], [[BB6]], [[BB7:BB[0-9]+]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:       [DA: Uni, SVA: (   )] br [[BB4]] (SVAOpBits 0-> )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB7]], [[BB2]]
; CHECK-NEXT:     [DA: Div, SVA: (   )] float [[VP_FINAL_RESULT:%.*]] = phi  [ float [[VP_LOAD_1]], [[BB2]] ],  [ float [[VP_VRES_NEXT]], [[BB6]] ] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:     [DA: Div, SVA: (   )] float [[VP11:%.*]] = fadd float [[VP_LOAD_2]] float [[VP_FINAL_RESULT]] (SVAOpBits 0-> 1-> )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] store float [[VP11]] float* [[VP_SUBSCRIPT_3]] (SVAOpBits 0->V 1->V )
; CHECK-NEXT:     [DA: Uni, SVA: (   )] br [[BB3]] (SVAOpBits 0-> )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]]
; CHECK-NEXT:     [DA: Div, SVA: (F  )] i64 [[VP4]] = add i64 [[VP3]] i64 [[VP__IND_INIT_STEP]] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP12:%.*]] = icmp slt i64 [[VP4]] i64 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (   )] br i1 [[VP12]], [[BB2]], [[BB8:BB[0-9]+]] (SVAOpBits 0-> 1-> 2-> )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB9:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br <External Block> (SVAOpBits )
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i64 [[VP__IND_FINAL]]
;
entry:
  br label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %B, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 8
  %idxprom1 = sext i32 %0 to i64
  %arrayidx2 = getelementptr inbounds float, float* %A, i64 %idxprom1
  %1 = load float, float* %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds float, float* %C, i64 %indvars.iv
  %2 = load float, float* %arrayidx4, align 4
  %add = fadd fast float %2, %1
  store float %add, float* %arrayidx2, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 8
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}

attributes #0 = { nofree norecurse nosync nounwind uwtable "approx-func-fp-math"="true" "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "frame-pointer"="none" "loopopt-pipeline"="light" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "pre_loopopt" "stack-protector-buffer-size"="8" "target-cpu"="skylake-avx512" "target-features"="+adx,+aes,+avx,+avx2,+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl,+bmi,+bmi2,+clflushopt,+clwb,+crc32,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+pku,+popcnt,+prfchw,+rdrnd,+rdseed,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsavec,+xsaveopt,+xsaves" "unsafe-fp-math"="true" "prefer-vector-width"="512" }
