; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -disable-output -opaque-pointers -passes=vplan-vec -vplan-force-vf=2 -vplan-enable-soa -vplan-dump-da-shapes -vplan-dump-da %s 2>&1 | FileCheck %s

define void @loop_strided_soa_geps() {
; CHECK-NOT: SOA
entry:
  %arr.soa.priv64 = alloca [1024 x i64], align 4
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"(ptr %arr.soa.priv64, i64 zeroinitializer, i64 1024)]
  br label %simd.loop.preheader

simd.loop.preheader:
  %ptr0 = getelementptr inbounds [1024 x i64], ptr %arr.soa.priv64, i64 0
  br label %simd.loop

simd.loop:
  %iv1 = phi i64 [ 0, %simd.loop.preheader ], [ %iv1.next, %simd.latch]
  br label %inner.loop
inner.loop:
  %iv2 = phi i64 [ 0, %simd.loop ], [ %iv2.next, %inner.loop]
  %ptr1 = phi ptr [%ptr0, %simd.loop], [%ptr.inc, %inner.loop]
  %ptr.inc = getelementptr inbounds [1024 x i64], ptr %ptr1, i64 1
  %ld = load i64, ptr %ptr.inc, align 4
  %ptr.uni = getelementptr inbounds [1024 x i64], ptr %ptr0, i64 1
  %ld2 = load i64, ptr %ptr.uni, align 4
  %iv2.next = add nuw nsw i64 %iv2, 1
  %cmp2 = icmp ult i64 %iv2.next, 1024
  br i1 %cmp2, label %inner.loop, label %simd.latch
simd.latch:
  %iv1.next = add nuw nsw i64 %iv1, 1
  %cmp = icmp ult i64 %iv1.next, 1024
  br i1 %cmp, label %simd.loop, label %simd.end
simd.end:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)
declare dso_local i64 @helper(i64*)
