; A stress test to check correctness of VPPHINode optimizations and placement generated by VPlan HIR decomposer.
; Input LLVM IR is generated for below code with command:  icx -O2 -mllvm -print-module-before-loopopt

; int a[1024];
; int b[1024];
; int c[1024];
; int d[1024];
;
; int  foo(int N)
; {
;     int t1 = N *2;
;     int i, j;
;     int t2, t3;
;
;     for (i = 0; i < 1024; i++) {
;         if (a[i] < i)
;             t1 = a[i];
;         else
;             t1 = a[i+1];
;
;         b[i] = t1;
;         c[i] = t1 + 2 * N;
;         if (i <= c[i] + d[i])
;             t1 = d[i];
;
;         d[i] = t1;
;     }
;
;     return b[0] + c[0] + d[0];
; }

; Input HIR
; + DO i1 = 0, 1023, 1   <DO_LOOP>
; |   %0 = (@a)[0][i1];
; |   %t1.0 = %0;
; |   if (i1 <= %0)
; |   {
; |      %t1.0 = (@a)[0][i1 + 1];
; |   }
; |   (@b)[0][i1] = %t1.0;
; |   (@c)[0][i1] = %t1.0 + 2 * %N;
; |   %3 = (@d)[0][i1];
; |   %spec.select = (i1 > %t1.0 + 2 * %N + %3) ? %t1.0 : %3;
; |   (@d)[0][i1] = %spec.select;
; + END LOOP


; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-plain-cfg -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-plain-cfg -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-plain-cfg -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -vplan-print-after-plain-cfg -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=1 | FileCheck %s


; Check decomposed VPInstructions
; CHECK: i32 [[PHI:%vp.*]] = phi  [ i32 [[IFT:%vp.*]], [[TBB:BB.*]] ],  [ i32 [[IFF:%vp.*]], [[FBB:BB.*]] ]
; CHECK-NEXT: i32* [[GEPB:%vp.*]] = subscript inbounds [1024 x i32]* @b i64 0 i64 [[IV:%vp.*]]
; CHECK-NEXT: store i32 [[PHI]] i32* [[GEPB]]
; CHECK-NEXT: i32 [[MUL1:%vp.*]] = mul i32 {{.*}} i32 2
; CHECK-NEXT: i32 [[ADD1:%vp.*]] = add i32 [[PHI]] i32 [[MUL1]]
; CHECK-NEXT: i32* [[GEPC:%vp.*]] = subscript inbounds [1024 x i32]* @c i64 0 i64 [[IV]]
; CHECK-NEXT: store i32 [[ADD1]] i32* [[GEPC]]
; CHECK-NEXT: i32* [[GEPD:%vp.*]] = subscript inbounds [1024 x i32]* @d i64 0 i64 [[IV]]
; CHECK-NEXT: i32 [[D_I1:%vp.*]] = load i32* [[GEPD]]
; CHECK-NEXT: i32 [[ADD3:%vp.*]] = add i32 [[ADD1]] i32 [[D_I1]]
; CHECK-NEXT: i64 [[SEXT:%vp.*]] = sext i32 [[ADD3]] to i64
; CHECK-NEXT: i1 [[CMP:%vp.*]] = icmp sgt i64 [[IV:%vp.*]] i64 [[SEXT]]
; CHECK-NEXT: i32 [[SEL:%vp.*]] = select i1 [[CMP]] i32 [[PHI]] i32 [[D_I1]]
; CHECK-NEXT: i32* [[GEPD:%vp.*]] = subscript inbounds [1024 x i32]* @d i64 0 i64 [[IV]]
; CHECK-NEXT: store i32 [[SEL]] i32* [[GEPD]]
; CHECK-NOT: phi


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@b = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@c = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16
@d = common dso_local local_unnamed_addr global [1024 x i32] zeroinitializer, align 16

; Function Attrs: norecurse nounwind uwtable
define dso_local i32 @foo(i32 %N) local_unnamed_addr {
entry:
  %mul8 = shl nsw i32 %N, 1
  br label %for.body

for.body:                                         ; preds = %if.end, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %.pre, %if.end ]
  %arrayidx = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %1 = sext i32 %0 to i64
  %cmp1 = icmp sgt i64 %indvars.iv, %1
  %.pre = add nuw nsw i64 %indvars.iv, 1
  br i1 %cmp1, label %if.end, label %if.else

if.else:                                          ; preds = %for.body
  %arrayidx5 = getelementptr inbounds [1024 x i32], [1024 x i32]* @a, i64 0, i64 %.pre, !intel-tbaa !2
  %2 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %for.body, %if.else
  %t1.0 = phi i32 [ %2, %if.else ], [ %0, %for.body ]
  %arrayidx7 = getelementptr inbounds [1024 x i32], [1024 x i32]* @b, i64 0, i64 %indvars.iv, !intel-tbaa !2
  store i32 %t1.0, i32* %arrayidx7, align 4, !tbaa !2
  %add9 = add nsw i32 %t1.0, %mul8
  %arrayidx11 = getelementptr inbounds [1024 x i32], [1024 x i32]* @c, i64 0, i64 %indvars.iv, !intel-tbaa !2
  store i32 %add9, i32* %arrayidx11, align 4, !tbaa !2
  %arrayidx15 = getelementptr inbounds [1024 x i32], [1024 x i32]* @d, i64 0, i64 %indvars.iv, !intel-tbaa !2
  %3 = load i32, i32* %arrayidx15, align 4, !tbaa !2
  %add16 = add nsw i32 %3, %add9
  %4 = sext i32 %add16 to i64
  %cmp17 = icmp sgt i64 %indvars.iv, %4
  %spec.select = select i1 %cmp17, i32 %t1.0, i32 %3
  store i32 %spec.select, i32* %arrayidx15, align 4, !tbaa !2
  %exitcond = icmp eq i64 %.pre, 1024
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %if.end
  %5 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @b, i64 0, i64 0), align 16, !tbaa !2
  %6 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @c, i64 0, i64 0), align 16, !tbaa !2
  %add24 = add nsw i32 %6, %5
  %7 = load i32, i32* getelementptr inbounds ([1024 x i32], [1024 x i32]* @d, i64 0, i64 0), align 16, !tbaa !2
  %add25 = add nsw i32 %add24, %7
  ret i32 %add25
}


!2 = !{!3, !4, i64 0}
!3 = !{!"array@_ZTSA1024_i", !4, i64 0}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}

