; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt %s -disable-output -vplan-vec \
; RUN:  -vplan-enable-masked-vectorized-remainder \
; RUN: -vplan-enable-non-masked-vectorized-remainder -vplan-print-vec-scenario 2>&1 | FileCheck %s
;
target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "x86_64-unknown-linux-gnu"

define void @main1() {
;
; CHECK-LABEL:  Updated scenario for VF: 2
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=2
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: masked, VF=2,
; CHECK-NEXT:  Updated scenario for VF: 4
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=4
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: unmasked, VF=2,scalar,
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=4
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: unmasked, VF=2,scalar,
;
entry:
  br label %preheader

preheader:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header
header:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %latch ]
  %iv.next = add nsw i32 %iv, 1
  br label %latch

latch:
  %t = sext i32 %iv to i64
  %x = add nsw i64 %t, 1
  %bottom_test = icmp eq i32 %iv.next, 131
  br i1 %bottom_test, label %loopexit, label %header, !llvm.loop !7

loopexit:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret void
}

define void @main2() {
;
; CHECK-LABEL:  Updated scenario for VF: 2
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=2
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: scalar,
; CHECK-NEXT:  Updated scenario for VF: 4
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=4
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: scalar,
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=4
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: scalar,
;
entry:
  br label %preheader

preheader:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header
header:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %latch ]
  %iv.next = add nsw i32 %iv, 1
  br label %latch

latch:
  %t = sext i32 %iv to i64
  %x = add nsw i64 %t, 1
  %bottom_test = icmp eq i32 %iv.next, 131
  br i1 %bottom_test, label %loopexit, label %header, !llvm.loop !10

loopexit:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret void
}

define void @main3() {
;
; CHECK-LABEL:  Updated scenario for VF: 2
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=2
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: scalar,
; CHECK-NEXT:  Updated scenario for VF: 4
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=4
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: unmasked, VF=2,scalar,
; CHECK-NEXT:  Single loop scenario:
; CHECK-NEXT:   MainLoop: unmasked, VF=4
; CHECK-NEXT:   PeelLoop: none
; CHECK-NEXT:   Remainders: unmasked, VF=2,scalar,
;
entry:
  br label %preheader

preheader:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header
header:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %latch ]
  %iv.next = add nsw i32 %iv, 1
  br label %latch

latch:
  %t = sext i32 %iv to i64
  %x = add nsw i64 %t, 1
  %bottom_test = icmp eq i32 %iv.next, 131
  br i1 %bottom_test, label %loopexit, label %header, !llvm.loop !11

loopexit:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  ret void
}


declare token @llvm.directive.region.entry() nounwind
declare void @llvm.directive.region.exit(token) nounwind

!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.intel.vector.vecremainder", !"true"}
!9 = !{!"llvm.loop.intel.vector.novecremainder", !"true"}
!10 = distinct !{!10, !9}
!11 = distinct !{!11}
