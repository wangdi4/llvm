; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -S -VPlanDriver | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"

define void @foo() {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  DIR.OMP.SIMD.1:
; CHECK-NEXT:    [[DOTSOA_VEC:%.*]] = alloca [12 x <4 x i16>], align 8
; CHECK-NEXT:    br label [[DIR_OMP_SIMD_112:%.*]]
; CHECK:       DIR.OMP.SIMD.112:
; CHECK-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds [12 x i16], [12 x i16]* undef, i64 0, i64 1
; CHECK-NEXT:    br label [[VPLANNEDBB:%.*]]
; CHECK:       VPlannedBB:
; CHECK-NEXT:    br label [[VPLANNEDBB1:%.*]]
; CHECK:       VPlannedBB1:
; CHECK-NEXT:    br i1 true, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[SOA_SCALAR_GEP:%.*]] = getelementptr inbounds [12 x <4 x i16>], [12 x <4 x i16>]* [[DOTSOA_VEC]], i64 0, i64 1
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[TMP2:%.*]], [[VPLANNEDBB5:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI3:%.*]] = phi i32 [ [[TMP1:%.*]], [[VPLANNEDBB5]] ], [ undef, [[VECTOR_PH]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i32> [ [[TMP0:%.*]], [[VPLANNEDBB5]] ], [ undef, [[VECTOR_PH]] ]
; CHECK-NEXT:    br i1 undef, label [[VPLANNEDBB4:%.*]], label [[VPLANNEDBB5]]
; CHECK:       VPlannedBB4:
; CHECK-NEXT:    store <4 x i16> <i16 1, i16 1, i16 1, i16 1>, <4 x i16>* [[SOA_SCALAR_GEP]], align 2
; CHECK-NEXT:    br label [[VPLANNEDBB5]]
; CHECK:       VPlannedBB5:
; CHECK-NEXT:    [[TMP0]] = add nuw nsw <4 x i32> [[VEC_PHI]], <i32 4, i32 4, i32 4, i32 4>
; CHECK-NEXT:    [[TMP1]] = add nuw nsw i32 [[UNI_PHI3]], 4
; CHECK-NEXT:    [[TMP2]] = add i32 [[UNI_PHI]], 4
; CHECK-NEXT:    [[TMP3:%.*]] = icmp uge i32 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[TMP3]], label [[VPLANNEDBB6:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       VPlannedBB6:
; CHECK-NEXT:    br label [[ARRAY_LAST_PRIVATE_LOOP:%.*]]
; CHECK:       array.last.private.loop:
; CHECK-NEXT:    [[TMP4:%.*]] = phi i64 [ 0, [[VPLANNEDBB6]] ], [ [[TMP8:%.*]], [[ARRAY_LAST_PRIVATE_LOOP]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [12 x <4 x i16>], [12 x <4 x i16>]* [[DOTSOA_VEC]], i64 0, i64 [[TMP4]], i64 3
; CHECK-NEXT:    [[TMP6:%.*]] = load i16, i16* [[TMP5]], align 2
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [12 x i16], [12 x i16]* undef, i64 0, i64 [[TMP4]]
; CHECK-NEXT:    store i16 [[TMP6]], i16* [[TMP7]], align 2
; CHECK-NEXT:    [[TMP8]] = add i64 [[TMP4]], 1
; CHECK-NEXT:    [[TMP9:%.*]] = icmp ult i64 [[TMP8]], 12
; CHECK-NEXT:    br i1 [[TMP9]], label [[ARRAY_LAST_PRIVATE_LOOP]], label [[ARRAY_LAST_PRIVATE_LOOP_EXIT:%.*]]
; CHECK:       array.last.private.loop.exit:
; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]
;
DIR.OMP.SIMD.1:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LASTPRIVATE"([12 x i16]* undef) ]
  br label %DIR.OMP.SIMD.112

DIR.OMP.SIMD.112:                                 ; preds = %DIR.OMP.SIMD.1
  %arrayidx.i = getelementptr inbounds [12 x i16], [12 x i16]* undef, i64 0, i64 1
  br label %omp.inner.for.body.i

omp.inner.for.body.i:                             ; preds = %omp.body.continue.i, %DIR.OMP.SIMD.112
  %.omp.iv.i.local.03 = phi i32 [ %add5.i, %omp.body.continue.i ], [ undef, %DIR.OMP.SIMD.112 ]
  br i1 undef, label %if.then.i, label %omp.body.continue.i

if.then.i:                                        ; preds = %omp.inner.for.body.i
  store i16 1, i16* %arrayidx.i, align 2
  br label %omp.body.continue.i

omp.body.continue.i:                              ; preds = %if.then.i, %omp.inner.for.body.i
  %add5.i = add nuw nsw i32 %.omp.iv.i.local.03, 1
  %exitcond.not = icmp eq i32 %.omp.iv.i.local.03, undef
  br i1 %exitcond.not, label %omp.inner.for.cond.i.DIR.OMP.END.SIMD.5.i.loopexit_crit_edge, label %omp.inner.for.body.i

omp.inner.for.cond.i.DIR.OMP.END.SIMD.5.i.loopexit_crit_edge: ; preds = %omp.body.continue.i
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
