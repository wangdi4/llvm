; Check that vectorized HIR generated by VPlan for a search loop with outer loop
; passes HIR verification, specifically for the number of exits from the outer loop.

; NOTE: Outer loop with inner multi-exit loop is needed in this test to verify updateNumLoopExits
; functionality.

; Input HIR:
;  BEGIN REGION { modified }
;        + DO i1 = 0, 63, 1   <DO_MULTI_EXIT_LOOP>
;        |   %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
;        |
;        |   + DO i2 = 0, 63, 1   <DO_MULTI_EXIT_LOOP> <vectorize>
;        |   |   if ((@C)[0][i1][i2] !=u %val)
;        |   |   {
;        |   |      %indvars.iv.out = i2;
;        |   |      goto early.exit;
;        |   |   }
;        |   + END LOOP
;        |      %indvars.iv.out = 63;
;        |
;        |   @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
;        + END LOOP
;  END REGION

; RUN: opt < %s -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-last-value-computation,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -allow-memory-speculation 2>&1 | FileCheck %s

; CHECK:  DO i1 = 0, 63, 1   <DO_MULTI_EXIT_LOOP>
; CHECK:  DO i2 = 0, 16 * %tgu + -1, 16   <DO_MULTI_EXIT_LOOP> <auto-vectorized> <nounroll> <novectorize>


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@i = dso_local local_unnamed_addr global i32 0, align 4
@C = dso_local local_unnamed_addr global [64 x [64 x float]] zeroinitializer, align 16

; Function Attrs: norecurse nounwind readonly uwtable
define dso_local i32 @_Z3fooiPKaPaa(float %val) local_unnamed_addr #0 {
entry:
  br label %for.body.preheader

for.body.preheader:                               ; preds = %entry, %outer.inc
  %outer.iv = phi i64 [ 0, %entry ], [ %outer.iv.next, %outer.inc ]
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds [64 x [64 x float]], ptr @C, i64 0, i64 %outer.iv, i64 %indvars.iv
  %0 = load float, ptr %arrayidx, align 4
  %cmp2 = fcmp fast oeq float %0, %val
  br i1 %cmp2, label %for.inc, label %early.exit

early.exit:                                      ; preds = %for.body
  %indvars.iv.lcssa = phi i64 [ %indvars.iv, %for.body ]
  %1 = trunc i64 %indvars.iv.lcssa to i32
  store i32 %1, ptr @i, align 4
  unreachable

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp slt i64 %indvars.iv.next, 64
  br i1 %cmp, label %for.body, label %outer.inc, !llvm.loop !5

outer.inc:
  %outer.iv.next = add nuw nsw i64 %outer.iv, 1
  %outer.cmp = icmp slt i64 %outer.iv.next, 64
  br i1 %outer.cmp, label %for.body.preheader, label %cleanup

cleanup:                                          ; preds = %outer.inc
  ret i32 0
}

attributes #0 = { norecurse nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "pre_loopopt" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!5 = distinct !{!5, !6, !7}
!6 = !{!"llvm.loop.vectorize.ignore_profitability"}
!7 = !{!"llvm.loop.vectorize.enable", i1 true}

