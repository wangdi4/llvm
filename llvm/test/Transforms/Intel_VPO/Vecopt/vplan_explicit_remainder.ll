; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -S -VPlanDriver -vplan-enable-cfg-merge -vplan-force-vf=4 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @foo(i64* nocapture %ptr, i64 %n) local_unnamed_addr #0 {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VPLANNEDBB:%.*]]
; CHECK:       VPlannedBB:
; CHECK-NEXT:    br label [[VPLANNEDBB1:%.*]]
; CHECK:       VPlannedBB1:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[N:%.*]], 4
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[N]], [[N_MOD_VF]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i64 0, [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP0]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[TMP4:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[UNI_PHI3:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[TMP2:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VECTOR_PH]] ], [ [[TMP1:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[VEC_PHI4:%.*]] = phi <4 x i64> [ zeroinitializer, [[VECTOR_PH]] ], [ [[TMP3:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[TMP1]] = add nuw nsw <4 x i64> [[VEC_PHI]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP2]] = add nuw nsw i64 [[UNI_PHI3]], 4
; CHECK-NEXT:    [[TMP3]] = add nuw nsw <4 x i64> [[VEC_PHI4]], [[VEC_PHI]]
; CHECK-NEXT:    [[TMP4]] = add i64 [[UNI_PHI]], 4
; CHECK-NEXT:    [[TMP5:%.*]] = icmp uge i64 [[TMP4]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP5]], label [[VPLANNEDBB5:%.*]], label [[VECTOR_BODY]], [[LOOP0:!llvm.loop !.*]]
; CHECK:       VPlannedBB5:
; CHECK-NEXT:    [[TMP6:%.*]] = call i64 @llvm.vector.reduce.add.v4i64(<4 x i64> [[TMP3]])
; CHECK-NEXT:    [[TMP7:%.*]] = sub i64 [[N_VEC]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = mul i64 1, [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = add i64 0, [[TMP8]]
; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[TMP10:%.*]] = icmp ne i64 [[N]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP10]], label [[SCALAR_PH]], label [[VPLANNEDBB6:%.*]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[UNI_PHI7:%.*]] = phi i64 [ [[TMP9]], [[MIDDLE_BLOCK]] ], [ 0, [[VPLANNEDBB1]] ]
; CHECK-NEXT:    [[UNI_PHI8:%.*]] = phi i64 [ [[TMP6]], [[MIDDLE_BLOCK]] ], [ 0, [[VPLANNEDBB1]] ]
; CHECK-NEXT:    br label [[VPLANNEDBB9:%.*]]
; CHECK:       VPlannedBB9:
; CHECK-NEXT:    br label [[HEADER:%.*]]
; CHECK:       VPlannedBB6:
; CHECK-NEXT:    [[UNI_PHI10:%.*]] = phi i64 [ [[IV:%.*]], [[HEADER]] ], [ [[TMP9]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    [[UNI_PHI11:%.*]] = phi i64 [ [[RED_NEXT:%.*]], [[HEADER]] ], [ [[TMP6]], [[MIDDLE_BLOCK]] ]
; CHECK-NEXT:    br label [[VPLANNEDBB12:%.*]]
; CHECK:       VPlannedBB12:
; CHECK-NEXT:    br label [[LOOPEXIT:%.*]]
; CHECK:       header:
; CHECK-NEXT:    [[IV]] = phi i64 [ [[UNI_PHI7]], [[VPLANNEDBB9]] ], [ [[IV_NEXT:%.*]], [[HEADER]] ]
; CHECK-NEXT:    [[RED:%.*]] = phi i64 [ [[UNI_PHI8]], [[VPLANNEDBB9]] ], [ [[RED_NEXT]], [[HEADER]] ]
; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
; CHECK-NEXT:    [[RED_NEXT]] = add nuw nsw i64 [[RED]], [[IV]]
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[IV_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[VPLANNEDBB6]], label [[HEADER]], [[LOOP2:!llvm.loop !.*]]
; CHECK:       loopexit:
; CHECK-NEXT:    [[INDUCTION_LIVEOUT:%.*]] = phi i64 [ [[UNI_PHI10]], [[VPLANNEDBB12]] ]
; CHECK-NEXT:    [[REDUCTION_LIVEOUT:%.*]] = phi i64 [ [[UNI_PHI11]], [[VPLANNEDBB12]] ]
; CHECK-NEXT:    br label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %red = phi i64 [ 0, %entry ], [ %red.next, %header ]
  %iv.next = add nuw nsw i64 %iv, 1
  %red.next = add nsw nuw i64 %red, %iv
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %loopexit, label %header

loopexit:
  %induction.liveout = phi i64 [ %iv, %header ]
  %reduction.liveout = phi i64 [ %red.next, %header ]
  br label %exit

exit:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
