; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -S -VPlanDriver -vplan-enable-cfg-merge -vplan-force-vf=4 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @foo(i64* nocapture %ptr, i64 %n) local_unnamed_addr #0 {
; CHECK:  define void @foo(i64* nocapture [[PTR0:%.*]], i64 [[N0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VPLANNEDBB0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    br label [[VPLANNEDBB10:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB1:
; CHECK-NEXT:    [[N_MOD_VF0:%.*]] = urem i64 [[N0]], 4
; CHECK-NEXT:    [[N_VEC0:%.*]] = sub nuw nsw i64 [[N0]], [[N_MOD_VF0]]
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i64 0, [[N_VEC0]]
; CHECK-NEXT:    br i1 [[TMP0]], label [[SCALAR_PH0:%.*]], label [[VECTOR_PH0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VECTOR_PH0]] ], [ [[TMP2:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VECTOR_PH0]] ], [ [[TMP1:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI30:%.*]] = phi <4 x i64> [ zeroinitializer, [[VECTOR_PH0]] ], [ [[TMP3:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[TMP1]] = add nuw nsw <4 x i64> [[VEC_PHI0]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP2]] = add nuw nsw i64 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP3]] = add nuw nsw <4 x i64> [[VEC_PHI30]], [[VEC_PHI0]]
; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[TMP2]], [[N_VEC0]]
; CHECK-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB40:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB4:
; CHECK-NEXT:    [[TMP5:%.*]] = call i64 @llvm.vector.reduce.add.v4i64(<4 x i64> [[TMP3]])
; CHECK-NEXT:    [[TMP6:%.*]] = sub i64 [[N_VEC0]], 1
; CHECK-NEXT:    [[TMP7:%.*]] = mul i64 1, [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = add i64 0, [[TMP7]]
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    [[TMP9:%.*]] = icmp ne i64 [[N0]], [[N_VEC0]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[SCALAR_PH0]], label [[VPLANNEDBB50:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    [[UNI_PHI60:%.*]] = phi i64 [ [[TMP8]], [[MIDDLE_BLOCK0]] ], [ 0, [[VPLANNEDBB10]] ]
; CHECK-NEXT:    [[UNI_PHI70:%.*]] = phi i64 [ [[TMP5]], [[MIDDLE_BLOCK0]] ], [ 0, [[VPLANNEDBB10]] ]
; CHECK-NEXT:    br label [[VPLANNEDBB80:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB8:
; CHECK-NEXT:    br label [[HEADER0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB5:
; CHECK-NEXT:    [[UNI_PHI90:%.*]] = phi i64 [ [[IV0:%.*]], [[HEADER0]] ], [ [[TMP8]], [[MIDDLE_BLOCK0]] ]
; CHECK-NEXT:    [[UNI_PHI100:%.*]] = phi i64 [ [[RED_NEXT0:%.*]], [[HEADER0]] ], [ [[TMP5]], [[MIDDLE_BLOCK0]] ]
; CHECK-NEXT:    br label [[VPLANNEDBB110:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB11:
; CHECK-NEXT:    br label [[LOOPEXIT0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  header:
; CHECK-NEXT:    [[IV0]] = phi i64 [ [[UNI_PHI60]], [[VPLANNEDBB80]] ], [ [[IV_NEXT0:%.*]], [[HEADER0]] ]
; CHECK-NEXT:    [[RED0:%.*]] = phi i64 [ [[UNI_PHI70]], [[VPLANNEDBB80]] ], [ [[RED_NEXT0]], [[HEADER0]] ]
; CHECK-NEXT:    [[IV_NEXT0]] = add nuw nsw i64 [[IV0]], 1
; CHECK-NEXT:    [[RED_NEXT0]] = add nuw nsw i64 [[RED0]], [[IV0]]
; CHECK-NEXT:    [[EXITCOND0:%.*]] = icmp eq i64 [[IV_NEXT0]], [[N0]]
; CHECK-NEXT:    br i1 [[EXITCOND0]], label [[VPLANNEDBB50]], label [[HEADER0]], !llvm.loop !2
; CHECK-EMPTY:
; CHECK-NEXT:  loopexit:
; CHECK-NEXT:    [[INDUCTION_LIVEOUT0:%.*]] = phi i64 [ [[UNI_PHI90]], [[VPLANNEDBB110]] ]
; CHECK-NEXT:    [[REDUCTION_LIVEOUT0:%.*]] = phi i64 [ [[UNI_PHI100]], [[VPLANNEDBB110]] ]
; CHECK-NEXT:    br label [[EXIT0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  exit:
; CHECK-NEXT:    ret void
; CHECK-NEXT:  }
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %red = phi i64 [ 0, %entry ], [ %red.next, %header ]
  %iv.next = add nuw nsw i64 %iv, 1
  %red.next = add nsw nuw i64 %red, %iv
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %loopexit, label %header

loopexit:
  %induction.liveout = phi i64 [ %iv, %header ]
  %reduction.liveout = phi i64 [ %red.next, %header ]
  br label %exit

exit:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
