; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -S -passes=vplan-vec  -vplan-force-vf=4 2>&1 | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @foo(ptr nocapture %ptr, i64 %n) local_unnamed_addr #0 {
; CHECK:  define void @foo(ptr nocapture [[PTR0:%.*]], i64 [[N0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[VPLANNEDBB0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    [[TMP0:%.*]] = and i64 [[N0]], 4294967292
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 0, [[TMP0]]
; CHECK-NEXT:    br i1 [[TMP1]], label %[[MERGE_BLK0:.*]], label [[VPLANNEDBB10:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB1:
; CHECK-NEXT:    br label [[VPLANNEDBB20:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB2:
; CHECK-NEXT:    [[TMP2:%.*]] = and i64 [[N0]], 4294967292
; CHECK-NEXT:    br label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VPLANNEDBB20]] ], [ [[TMP4:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VPLANNEDBB20]] ], [ [[TMP3:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI40:%.*]] = phi <4 x i64> [ zeroinitializer, [[VPLANNEDBB20]] ], [ [[TMP5:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[TMP3]] = add nuw nsw <4 x i64> [[VEC_PHI0]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP4]] = add nuw nsw i64 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP5]] = add <4 x i64> [[VEC_PHI40]], [[VEC_PHI0]]
; CHECK-NEXT:    [[TMP6:%.*]] = icmp uge i64 [[TMP4]], [[TMP2]]
; CHECK-NEXT:    br i1 [[TMP6]], label [[VPLANNEDBB50:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB5:
; CHECK-NEXT:    [[TMP7:%.*]] = call i64 @llvm.vector.reduce.add.v4i64(<4 x i64> [[TMP5]])
; CHECK-NEXT:    [[TMP8:%.*]] = sub i64 [[TMP2]], 1
; CHECK-NEXT:    [[TMP9:%.*]] = mul i64 1, [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = add i64 0, [[TMP9]]
; CHECK-NEXT:    br label [[VPLANNEDBB60:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB6:
; CHECK-NEXT:    br label [[VPLANNEDBB70:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB7:
; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[N0]], [[TMP2]]
; CHECK-NEXT:    br i1 [[TMP11]], label [[FINAL_MERGE0:%.*]], label %[[MERGE_BLK0]]
; CHECK-EMPTY:
; CHECK-NEXT:  [[MERGE_BLK0]]:
; CHECK-NEXT:    [[UNI_PHI80:%.*]] = phi i64 [ [[TMP10]], [[VPLANNEDBB70]] ], [ 0, [[VPLANNEDBB0]] ]
; CHECK-NEXT:    [[UNI_PHI90:%.*]] = phi i64 [ [[TMP7]], [[VPLANNEDBB70]] ], [ 0, [[VPLANNEDBB0]] ]
; CHECK-NEXT:    br label %[[REMBLK0:.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  [[REMBLK0]]:
; CHECK-NEXT:    br label [[HEADER0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB10:
; CHECK-NEXT:    br label [[FINAL_MERGE0]]
; CHECK-EMPTY:
; CHECK-NEXT:  final.merge:
; CHECK-NEXT:    [[UNI_PHI110:%.*]] = phi i64 [ [[IV0:%.*]], [[VPLANNEDBB100:%.*]] ], [ [[TMP10]], [[VPLANNEDBB70]] ]
; CHECK-NEXT:    [[UNI_PHI120:%.*]] = phi i64 [ [[RED_NEXT0:%.*]], [[VPLANNEDBB100]] ], [ [[TMP7]], [[VPLANNEDBB70]] ]
; CHECK-NEXT:    br label [[LOOPEXIT0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  header:
; CHECK-NEXT:    [[IV0]] = phi i64 [ [[UNI_PHI80]], %[[REMBLK0]] ], [ [[IV_NEXT0:%.*]], [[HEADER0]] ]
; CHECK-NEXT:    [[RED0:%.*]] = phi i64 [ [[UNI_PHI90]], %[[REMBLK0]] ], [ [[RED_NEXT0]], [[HEADER0]] ]
; CHECK-NEXT:    [[IV_NEXT0]] = add nuw nsw i64 [[IV0]], 1
; CHECK-NEXT:    [[RED_NEXT0]] = add nuw nsw i64 [[RED0]], [[IV0]]
; CHECK-NEXT:    [[EXITCOND0:%.*]] = icmp eq i64 [[IV_NEXT0]], [[N0]]
; CHECK-NEXT:    br i1 [[EXITCOND0]], label [[VPLANNEDBB100]], label [[HEADER0]], !llvm.loop !2
; CHECK-EMPTY:
; CHECK-NEXT:  loopexit:
; CHECK-NEXT:    [[INDUCTION_LIVEOUT0:%.*]] = phi i64 [ [[UNI_PHI110]], [[FINAL_MERGE0]] ]
; CHECK-NEXT:    [[REDUCTION_LIVEOUT0:%.*]] = phi i64 [ [[UNI_PHI120]], [[FINAL_MERGE0]] ]
; CHECK-NEXT:    br label [[EXIT0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  exit:
; CHECK-NEXT:    ret void
; CHECK-NEXT:  }
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %red = phi i64 [ 0, %entry ], [ %red.next, %header ]
  %iv.next = add nuw nsw i64 %iv, 1
  %red.next = add nsw nuw i64 %red, %iv
  %exitcond = icmp eq i64 %iv.next, %n
  br i1 %exitcond, label %loopexit, label %header

loopexit:
  %induction.liveout = phi i64 [ %iv, %header ]
  %reduction.liveout = phi i64 [ %red.next, %header ]
  br label %exit

exit:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
