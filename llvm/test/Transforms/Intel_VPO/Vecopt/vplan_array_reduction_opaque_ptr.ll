; Test to verify that VPlan vectorizer handles array reduction
; idioms using opaque pointers identified in incoming IR.

; C/C++ source
; float B[5] = {0, 0, 0, 0, 0};
; void foo()
; {
;   long l1;
; #pragma omp simd reduction(max:B)
;   for (l1 = 0; l1 < 100; l1++) {
;     B[l1 % 5] = B[l1 % 5] < l1 ? l1 : B[l1 %5];
;   }
; }

; REQUIRES: asserts
; RUN: opt -passes=vplan-vec -vplan-force-vf=2 -vplan-print-after-vpentity-instrs -vplan-entities-dump -print-after=vplan-vec -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -vplan-force-vf=2 -debug-only=VPlanLegality -debug-only=VPlanDriver -print-after=hir-vplan-vec -disable-output < %s 2>&1 | FileCheck %s --check-prefix=HIRVEC
; RUN: opt -passes=hir-ssa-deconstruction,hir-vplan-vec,hir-cg,simplifycfg,intel-ir-optreport-emitter -vplan-force-vf=2 -disable-output -intel-opt-report=high < %s 2>&1 | FileCheck %s --check-prefix=OPTRPTHI

; Non-alloca inst pointers in SIMD clauses are not supported in HIR path.
; HIRVEC: Non-alloca instruction in reduction clause.
; HIRVEC: VD: Not vectorizing: Cannot prove legality.
; HIRVEC: Function: foo

; OPTRPTMED: remark #15436: loop was not vectorized:
; OPTRPTHI: remark #15436: loop was not vectorized: HIR: Non-alloca instruction in reduction clause.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @foo() {
; CHECK: VPlan after insertion of VPEntities instructions:
; CHECK: Reduction list
; CHECK:  (FloatMax) Start: ptr [[B_RED:%.*]]
; CHECK:   Linked values: ptr [[VP_B_RED:%.*]],
; CHECK:  Memory: ptr [[B_RED]]

; CHECK: ptr [[VP_B_RED]] = allocate-priv [5 x float], OrigAlign = 16
; CHECK: ptr [[VP_B_RED_GEP:%.*]] = getelementptr inbounds [5 x float], ptr [[VP_B_RED]] i64 0 i64 0
; CHECK: reduction-init-arr float 0xFFF0000000000000 ptr [[VP_B_RED]]
; CHECK: [5 x float] [[VP_RED_FINAL_ARR:%.*]] = reduction-final-arr{fmax} ptr [[VP_B_RED]] ptr [[B_RED]]

; Checks for code generated by LLVM-IR vectorizer.
; CHECK-LABEL: define {{[^@]+}}@foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[B_RED:%.*]] = alloca [5 x float], align 16
; CHECK-NEXT:    [[B_RED_GEP:%.*]] = getelementptr inbounds [5 x float], ptr [[B_RED]], i64 0, i64 0
; CHECK-NEXT:    [[B_RED_VEC:%.*]] = alloca [2 x [5 x float]], align 4
; CHECK-NEXT:    [[B_RED_VEC_BASE_ADDR:%.*]] = getelementptr [5 x float], ptr [[B_RED_VEC]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[B_RED_VEC_BASE_ADDR_EXTRACT_1_:%.*]] = extractelement <2 x ptr> [[B_RED_VEC_BASE_ADDR]], i32 1
; CHECK-NEXT:    [[B_RED_VEC_BASE_ADDR_EXTRACT_0_:%.*]] = extractelement <2 x ptr> [[B_RED_VEC_BASE_ADDR]], i32 0
; CHECK-NEXT:    br label [[BEGIN_SIMD:%.*]]

; CHECK:       VPlannedBB1:
; CHECK:         [[MM_VECTORGEP:%.*]] = getelementptr inbounds [5 x float], <2 x ptr> [[B_RED_VEC_BASE_ADDR]], <2 x i64> zeroinitializer, <2 x i64> zeroinitializer
; CHECK-NEXT:    br label [[ARRAY_REDN_INIT_LOOP:%.*]]

; CHECK:       array.redn.init.loop:
; CHECK-NEXT:    [[CUR_ELEM_IDX:%.*]] = phi i64 [ 0, [[VPLANNEDBB1:%.*]] ], [ [[NEXT_ELEM_IDX:%.*]], [[ARRAY_REDN_INIT_LOOP]] ]
; CHECK-NEXT:    [[CUR_ELEM_PTR:%.*]] = getelementptr float, ptr [[B_RED_VEC_BASE_ADDR_EXTRACT_0_]], i64 [[CUR_ELEM_IDX]]
; CHECK-NEXT:    store float 0xFFF0000000000000, ptr [[CUR_ELEM_PTR]], align 4
; CHECK-NEXT:    [[NEXT_ELEM_IDX]] = add i64 [[CUR_ELEM_IDX]], 1
; CHECK-NEXT:    [[INITLOOP_COND:%.*]] = icmp ult i64 [[NEXT_ELEM_IDX]], 10
; CHECK-NEXT:    br i1 [[INITLOOP_COND]], label [[ARRAY_REDN_INIT_LOOP]], label [[ARRAY_REDN_INIT_LOOPEXIT:%.*]]

; CHECK:       array.redn.final.main.loop:
; CHECK-NEXT:    [[MAIN_ELEM_IDX:%.*]] = phi i64 [ 0, [[VPLANNEDBB4:%.*]] ], [ [[NEXT_MAIN_ELEM_IDX:%.*]], [[ARRAY_REDN_FINAL_MAIN_LOOP:%.*]] ]
; CHECK-NEXT:    [[ORIG_ARR_GEP:%.*]] = getelementptr [5 x float], ptr [[B_RED]], i64 0, i64 [[MAIN_ELEM_IDX]]
; CHECK-NEXT:    [[ORIG_ARR_LD:%.*]] = load <4 x float>, ptr [[ORIG_ARR_GEP]], align 4
; CHECK-NEXT:    [[PRIV_ARR_GEP_LANE0:%.*]] = getelementptr [5 x float], ptr [[B_RED_VEC_BASE_ADDR_EXTRACT_0_]], i64 0, i64 [[MAIN_ELEM_IDX]]
; CHECK-NEXT:    [[PRIV_ARR_LD_LANE0:%.*]] = load <4 x float>, ptr [[PRIV_ARR_GEP_LANE0]], align 4
; CHECK-NEXT:    [[ARR_FIN_RED:%.*]] = call fast <4 x float> @llvm.maxnum.v4f32(<4 x float> [[ORIG_ARR_LD]], <4 x float> [[PRIV_ARR_LD_LANE0]])
; CHECK-NEXT:    [[PRIV_ARR_GEP_LANE1:%.*]] = getelementptr [5 x float], ptr [[B_RED_VEC_BASE_ADDR_EXTRACT_1_]], i64 0, i64 [[MAIN_ELEM_IDX]]
; CHECK-NEXT:    [[PRIV_ARR_LD_LANE1:%.*]] = load <4 x float>, ptr [[PRIV_ARR_GEP_LANE1]], align 4
; CHECK-NEXT:    [[ARR_FIN_RED5:%.*]] = call fast <4 x float> @llvm.maxnum.v4f32(<4 x float> [[ARR_FIN_RED]], <4 x float> [[PRIV_ARR_LD_LANE1]])
; CHECK-NEXT:    store <4 x float> [[ARR_FIN_RED5]], ptr [[ORIG_ARR_GEP]], align 4
; CHECK-NEXT:    [[NEXT_MAIN_ELEM_IDX]] = add i64 [[MAIN_ELEM_IDX]], 4
; CHECK-NEXT:    [[FINAL_MAINLOOP_COND:%.*]] = icmp ult i64 [[NEXT_MAIN_ELEM_IDX]], 4
; CHECK-NEXT:    br i1 [[FINAL_MAINLOOP_COND]], label [[ARRAY_REDN_FINAL_MAIN_LOOP]], label [[ARRAY_REDN_FINAL_REM_LOOP:%.*]]

; CHECK:       array.redn.final.rem.loop:
; CHECK-NEXT:    [[REM_ELEM_IDX:%.*]] = phi i64 [ 4, [[ARRAY_REDN_FINAL_MAIN_LOOP]] ], [ [[NEXT_REM_ELEM_IDX:%.*]], [[ARRAY_REDN_FINAL_REM_LOOP]] ]
; CHECK-NEXT:    [[ORIG_ARR_GEP6:%.*]] = getelementptr [5 x float], ptr [[B_RED]], i64 0, i64 [[REM_ELEM_IDX]]
; CHECK-NEXT:    [[ORIG_ARR_LD7:%.*]] = load float, ptr [[ORIG_ARR_GEP6]], align 4
; CHECK-NEXT:    [[PRIV_ARR_GEP_LANE08:%.*]] = getelementptr [5 x float], ptr [[B_RED_VEC_BASE_ADDR_EXTRACT_0_]], i64 0, i64 [[REM_ELEM_IDX]]
; CHECK-NEXT:    [[PRIV_ARR_LD_LANE09:%.*]] = load float, ptr [[PRIV_ARR_GEP_LANE08]], align 4
; CHECK-NEXT:    [[ARR_FIN_RED10:%.*]] = call fast float @llvm.maxnum.f32(float [[ORIG_ARR_LD7]], float [[PRIV_ARR_LD_LANE09]])
; CHECK-NEXT:    [[PRIV_ARR_GEP_LANE111:%.*]] = getelementptr [5 x float], ptr [[B_RED_VEC_BASE_ADDR_EXTRACT_1_]], i64 0, i64 [[REM_ELEM_IDX]]
; CHECK-NEXT:    [[PRIV_ARR_LD_LANE112:%.*]] = load float, ptr [[PRIV_ARR_GEP_LANE111]], align 4
; CHECK-NEXT:    [[ARR_FIN_RED13:%.*]] = call fast float @llvm.maxnum.f32(float [[ARR_FIN_RED10]], float [[PRIV_ARR_LD_LANE112]])
; CHECK-NEXT:    store float [[ARR_FIN_RED13]], ptr [[ORIG_ARR_GEP6]], align 4
; CHECK-NEXT:    [[NEXT_REM_ELEM_IDX]] = add i64 [[REM_ELEM_IDX]], 1
; CHECK-NEXT:    [[FINAL_REMLOOP_COND:%.*]] = icmp ult i64 [[NEXT_REM_ELEM_IDX]], 5
; CHECK-NEXT:    br i1 [[FINAL_REMLOOP_COND]], label [[ARRAY_REDN_FINAL_REM_LOOP]], label [[ARRAY_REDN_FINAL_EXIT:%.*]]
;
entry:
  %B.red = alloca [5 x float], align 16
  %B.red.gep = getelementptr inbounds [5 x float], ptr %B.red, i64 0, i64 0
  br label %begin.simd

begin.simd:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.MAX:TYPED"(ptr %B.red.gep, float 0.000000e+00, i64 5) ]
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %begin.simd ]
  %rem = urem i64 %indvars.iv, 5
  %arrayidx = getelementptr inbounds [5 x float], ptr %B.red.gep, i64 0, i64 %rem
  %B.i = load float, ptr %arrayidx, align 4
  %conv = sitofp i64 %indvars.iv to float
  %cmp = fcmp fast olt float %B.i, %conv
  %sel = select fast i1 %cmp, float %conv, float %B.i
  store float %sel, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp slt i64 %indvars.iv.next, 100
  br i1 %exitcond, label %for.body, label %for.cond.cleanup.loopexit

for.cond.cleanup.loopexit:                             ; preds = %for.body
  br label %end.simd

end.simd:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.QUAL.LIST.END.3

DIR.QUAL.LIST.END.3:
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
