; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Check that private structs are correctly handled in VPlan CodeGen.

; RUN: opt -S -passes=vplan-vec -vplan-force-vf=2 %s  | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

%struct.ndrange_t.6 = type { i32, [3 x i64], [3 x i64], [3 x i64] }

; CHECK:  define dso_local void @_ZGVdN8u___block_fn_block_invoke_kernel(ptr addrspace(4) [[INP_ARG:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[NDRANGE_I_I0:%.*]] = alloca [[STRUCT_NDRANGE_T_60:%.*]], align 8
; CHECK-NEXT:    [[BLOCK0:%.*]] = alloca <{ i32, i32, ptr addrspace(4), ptr addrspace(1), i32 }>, align 8
; CHECK-NEXT:    [[TMP0:%.*]] = alloca [[STRUCT_NDRANGE_T_60]], align 8
; CHECK-NEXT:    [[CALL_I_I0:%.*]] = tail call i64 @_Z13get_global_idj(i32 0)
; CHECK-NEXT:    [[TMP_VEC0:%.*]] = alloca [2 x %struct.ndrange_t.6], align 8
; CHECK-NEXT:    [[TMP_VEC_BASE_ADDR0:%.*]] = getelementptr [[STRUCT_NDRANGE_T_60]], ptr [[TMP_VEC0]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP_VEC_BASE_ADDR_EXTRACT0:%.*]] = extractelement <2 x ptr> [[TMP_VEC_BASE_ADDR0]], i32 0
; CHECK-NEXT:    [[BLOCK_VEC0:%.*]] = alloca [2 x <{ i32, i32, ptr addrspace(4), ptr addrspace(1), i32 }>], align 8
; CHECK-NEXT:    [[BLOCK_VEC_BASE_ADDR0:%.*]] = getelementptr <{ i32, i32, ptr addrspace(4), ptr addrspace(1), i32 }>, ptr [[BLOCK_VEC0]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[BLOCK_VEC_BASE_ADDR_EXTRACT0:%.*]] = extractelement <2 x ptr> [[BLOCK_VEC_BASE_ADDR0]], i32 0
; CHECK-NEXT:    [[NDRANGE_I_I_VEC0:%.*]] = alloca [2 x %struct.ndrange_t.6], align 8
; CHECK-NEXT:    [[NDRANGE_I_I_VEC_BASE_ADDR0:%.*]] = getelementptr [[STRUCT_NDRANGE_T_60]], ptr [[NDRANGE_I_I_VEC0]], <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[NDRANGE_I_I_VEC_BASE_ADDR_EXTRACT0:%.*]] = extractelement <2 x ptr> [[NDRANGE_I_I_VEC_BASE_ADDR0]], i32 0
; CHECK-NEXT:    br label [[SIMD_BEGIN_REGION0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  simd.begin.region:
; CHECK-NEXT:    br label [[VPLANNEDBB0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT0:%.*]] = insertelement <2 x i64> poison, i64 [[CALL_I_I0]], i64 0
; CHECK-NEXT:    [[BROADCAST_SPLAT0:%.*]] = shufflevector <2 x i64> [[BROADCAST_SPLATINSERT0]], <2 x i64> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    br label [[VPLANNEDBB10:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB1:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 160, ptr [[TMP_VEC_BASE_ADDR_EXTRACT0]]) 
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 56, ptr [[BLOCK_VEC_BASE_ADDR_EXTRACT0]]) 
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 160, ptr [[NDRANGE_I_I_VEC_BASE_ADDR_EXTRACT0]]) 
; CHECK-NEXT:    br label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i32 [ 0, [[VPLANNEDBB10]] ], [ [[TMP12:%.*]], [[VPLANNEDBB50:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VPLANNEDBB10]] ], [ [[TMP11:%.*]], [[VPLANNEDBB50]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = sext <2 x i32> [[VEC_PHI0]] to <2 x i64>
; CHECK-NEXT:    [[TMP2:%.*]] = add nuw <2 x i64> [[TMP1]], [[BROADCAST_SPLAT0]]
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[INP_ARG]], i64 16
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr addrspace(1), ptr addrspace(4) [[SCALAR_GEP0]], align 8
; CHECK-NEXT:    [[SCALAR_GEP30:%.*]] = getelementptr inbounds i8, ptr addrspace(4) [[INP_ARG]], i64 24
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr addrspace(4) [[SCALAR_GEP30]], align 8
; CHECK-NEXT:    [[TMP10:%.*]] = icmp slt i32 [[TMP6]], 1
; CHECK-NEXT:    br i1 [[TMP10]], label [[VPLANNEDBB40:%.*]], label [[VPLANNEDBB50]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB4:
; CHECK-NEXT:    br label [[VPLANNEDBB50]]

; Function Attrs: nounwind
define dso_local void @_ZGVdN8u___block_fn_block_invoke_kernel(ptr addrspace(4)) {
entry:
  %ndrange.i.i = alloca %struct.ndrange_t.6, align 8
  %block = alloca <{ i32, i32, ptr addrspace(4), ptr addrspace(1), i32 }>, align 8
  %tmp = alloca %struct.ndrange_t.6, align 8
  %call.i.i = tail call i64 @_Z13get_global_idj(i32 0)
  br label %simd.begin.region

simd.begin.region:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.UNIFORM:TYPED"(ptr addrspace(4) %0, i8 0, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %ndrange.i.i, %struct.ndrange_t.6 zeroinitializer, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %block, <{ i32, i32, ptr addrspace(4), ptr addrspace(1), i32 }> zeroinitializer, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr %tmp, %struct.ndrange_t.6 zeroinitializer, i32 1), "QUAL.OMP.SIMDLEN"(i32 8) ]
  br label %simd.loop

simd.loop:
  %index = phi i32 [ 0, %simd.begin.region ], [ %indvar, %simd.loop.exit ]
  %1 = sext i32 %index to i64
  %add = add nuw i64 %1, %call.i.i
  %block.capture.addr.i = getelementptr inbounds i8, ptr addrspace(4) %0, i64 16
  %2 = load ptr addrspace(1), ptr addrspace(4) %block.capture.addr.i, align 8
  %block.capture.addr1.i = getelementptr inbounds i8, ptr addrspace(4) %0, i64 24
  %3 = load i32, ptr addrspace(4) %block.capture.addr1.i, align 8
  call void @llvm.lifetime.start.p0(i64 28, ptr nonnull %block)
  call void @llvm.lifetime.start.p0(i64 80, ptr nonnull %tmp)
  call void @llvm.lifetime.start.p0(i64 80, ptr nonnull %ndrange.i.i)
  %cmp.i.i = icmp slt i32 %3, 1
  br i1 %cmp.i.i, label %__block_fn_block_invoke.exit, label %simd.loop.exit

__block_fn_block_invoke.exit:
  call void @llvm.lifetime.end.p0(i64 80, ptr nonnull %ndrange.i.i)
  call void @llvm.lifetime.end.p0(i64 28, ptr nonnull %block)
  call void @llvm.lifetime.end.p0(i64 80, ptr nonnull %tmp)
  br label %simd.loop.exit

simd.loop.exit:
  %indvar = add nuw i32 %index, 1
  %vl.cond = icmp ult i32 %indvar, 8
  br i1 %vl.cond, label %simd.loop, label %simd.end.region

simd.end.region:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:
  ret void
}

declare void @llvm.lifetime.start.p0(i64, ptr nocapture)
declare void @llvm.lifetime.end.p0(i64, ptr nocapture)
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
declare i64 @_Z13get_global_idj(i32)

