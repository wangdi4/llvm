; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of SVA results for a loop header PHI that is used
; only by another header PHI. Such a PHI should be skipped from processing as
; correct results for it will be obtained during back propagation triggered by
; the user PHI.

; REQUIRES: asserts
; RUN: opt -S < %s -passes=vplan-vec -vplan-force-vf=2 -disable-output -vplan-enable-scalvec-analysis -vplan-print-scalvec-results | FileCheck %s

define void @test_uni_inner(ptr %p) {
;
; CHECK-LABEL:  VPlan after ScalVec analysis:
; CHECK-NEXT:  VPlan IR for: test_uni_inner:simd.header
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=2 UF=1 (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=2 UF=1 (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB1:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_SIMD_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_SIMD_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1 (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 64, UF = 1 (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB2:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_SIMD_IV:%.*]] = phi  [ i64 [[VP_SIMD_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_SIMD_IV_NEXT:%.*]], [[BB3]] ] (SVAOpBits 0->FV 1->FV )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] ptr [[VP_GEP:%.*]] = getelementptr i64, ptr [[P0:%.*]] i64 [[VP_SIMD_IV]] (SVAOpBits 0->V 1->V )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB4:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_LANE:%.*]] = trunc i64 [[VP_SIMD_IV]] to i32 (SVAOpBits 0->V )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB5:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 0, [[BB4]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[BB5]] ] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_VEC:%.*]] = phi  [ i32 [[VP_LANE]], [[BB4]] ],  [ i32 [[VP_VEC_NEXT:%.*]], [[BB5]] ] (SVAOpBits 0->V 1->V )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_PHI1:%.*]] = phi  [ i32 0, [[BB4]] ],  [ i32 [[VP_PHI2:%.*]], [[BB5]] ] (SVAOpBits 0->V 1->V )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_PHI2]] = phi  [ i32 1, [[BB4]] ],  [ i32 [[VP_INST:%.*]], [[BB5]] ] (SVAOpBits 0->V 1->V )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_INST]] = bitcast i32 [[VP_VEC]] (SVAOpBits 0->V )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_VEC_NEXT]] = add i32 [[VP_VEC]] i32 1 (SVAOpBits 0->V 1->V )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP_EXIT_COND:%.*]] = icmp eq i32 [[VP_LOOP_IV]] i32 42 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br i1 [[VP_EXIT_COND]], [[BB6:BB[0-9]+]], [[BB5]] (SVAOpBits 0->F 1->F 2->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB3]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_SIMD_IV_NEXT]] = add i64 [[VP_SIMD_IV]] i64 [[VP_SIMD_IV_IND_INIT_STEP]] (SVAOpBits 0->FV 1->FV )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_SIMD_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB7:BB[0-9]+]], [[BB2]] (SVAOpBits 0->F 1->F 2->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_SIMD_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB8:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br final.merge (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    final.merge: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP0:%.*]] = phi-merge  [ i64 live-out0, [[BB8]] ] (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br <External Block> (SVAOpBits )
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i64 [[VP_SIMD_IV_IND_FINAL]]
;
simd.preheader:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %simd.header

simd.header:
  %simd.iv = phi i64 [ 0, %simd.preheader ], [ %simd.iv.next, %simd.latch ]
  %gep = getelementptr i64, ptr %p, i64 %simd.iv
  br label %entry

entry:
  %lane = trunc i64 %simd.iv to i32
  br label %header

header:
  %loop_iv = phi i32 [ 0, %entry ], [ %loop_iv.next, %header ]
  %vec = phi i32 [ %lane, %entry ], [ %vec.next, %header ]

  %phi1 = phi i32 [ 0, %entry ], [ %phi2, %header ]
  %phi2 = phi i32 [ 1, %entry ], [ %inst, %header ]

  %inst = bitcast i32 %vec to i32

  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %vec.next = add nsw nuw i32 %vec, 1
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %exit, label %header

exit:
  br label %simd.latch

simd.latch:
  %simd.iv.next = add nsw nuw i64 %simd.iv, 1
  %simd.exitcond = icmp eq i64 %simd.iv.next, 64
  br i1 %simd.exitcond, label %simd.end, label %simd.header

simd.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

define void @test_self_user_phi(ptr %p) {
; CHECK-LABEL:  VPlan after ScalVec analysis:
; CHECK-NEXT:  VPlan IR for: test_self_user_phi:simd.header
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=2 UF=1 (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=2 UF=1 (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB1:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_SIMD_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_SIMD_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1 (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 64, UF = 1 (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB2:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_SIMD_IV:%.*]] = phi  [ i64 [[VP_SIMD_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_SIMD_IV_NEXT:%.*]], [[BB3]] ] (SVAOpBits 0->FV 1->FV )
; CHECK-NEXT:     [DA: Div, SVA: ( V )] ptr [[VP_GEP:%.*]] = getelementptr i64, ptr [[P0:%.*]] i64 [[VP_SIMD_IV]] (SVAOpBits 0->V 1->V )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB4:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:     [DA: Div, SVA: ( V )] i32 [[VP_LANE:%.*]] = trunc i64 [[VP_SIMD_IV]] to i32 (SVAOpBits 0->V )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB5:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 0, [[BB4]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[BB5]] ] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP_VEC:%.*]] = phi  [ i32 undef, [[BB4]] ],  [ i32 [[VP_VEC]], [[BB5]] ] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP_INST:%.*]] = bitcast i32 [[VP_VEC]] (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP_VEC_NEXT:%.*]] = add i32 [[VP_VEC]] i32 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP_EXIT_COND:%.*]] = icmp eq i32 [[VP_LOOP_IV]] i32 42 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br i1 [[VP_EXIT_COND]], [[BB6:BB[0-9]+]], [[BB5]] (SVAOpBits 0->F 1->F 2->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB3]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_SIMD_IV_NEXT]] = add i64 [[VP_SIMD_IV]] i64 [[VP_SIMD_IV_IND_INIT_STEP]] (SVAOpBits 0->FV 1->FV )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_SIMD_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB7:BB[0-9]+]], [[BB2]] (SVAOpBits 0->F 1->F 2->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_SIMD_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br [[BB8:BB[0-9]+]] (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br final.merge (SVAOpBits 0->F )
; CHECK-EMPTY:
; CHECK-NEXT:    final.merge: # preds: [[BB8]]
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP0:%.*]] = phi-merge  [ i64 live-out0, [[BB8]] ] (SVAOpBits 0->F )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; CHECK-NEXT:     [DA: Uni, SVA: (F  )] br <External Block> (SVAOpBits )
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i64 [[VP_SIMD_IV_IND_FINAL]]
;
simd.preheader:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %simd.header

simd.header:
  %simd.iv = phi i64 [ 0, %simd.preheader ], [ %simd.iv.next, %simd.latch ]
  %gep = getelementptr i64, ptr %p, i64 %simd.iv
  br label %entry

entry:
  %lane = trunc i64 %simd.iv to i32
  br label %header

header:
  %loop_iv = phi i32 [ 0, %entry ], [ %loop_iv.next, %header ]
  %vec = phi i32 [ undef, %entry ], [ %vec, %header ]

  %inst = bitcast i32 %vec to i32

  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %vec.next = add nsw nuw i32 %vec, 1
  %exit_cond = icmp eq i32 %loop_iv, 42
  br i1 %exit_cond, label %exit, label %header

exit:
  br label %simd.latch

simd.latch:
  %simd.iv.next = add nsw nuw i64 %simd.iv, 1
  %simd.exitcond = icmp eq i64 %simd.iv.next, 64
  br i1 %simd.exitcond, label %simd.end, label %simd.header

simd.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
