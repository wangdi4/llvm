; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; Auto generated checks were manually updated to reflect differences in mixed and
; VPValue based CG modes caused by mixed mode reusing the same ref for assignments
; to the same HIR temp.

; Test to check correctness of VPlan pseudo SSA deconstruction transform and
; vector CG for simple if-else construct based on a uniform condition.

; Incoming HIR
;   BEGIN REGION { }
;         %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
;
;         + DO i1 = 0, 99, 1   <DO_LOOP>
;         |   if (%n1 == 0)
;         |   {
;         |      %ld.true = (%arr1)[i1];
;         |      %merge.phi = %ld.true;
;         |   }
;         |   else
;         |   {
;         |      %ld.false = (%arr2)[i1];
;         |      %merge.phi = %ld.false;
;         |   }
;         |   %red.phi = %merge.phi  +  %red.phi; <Safe Reduction>
;         + END LOOP
;
;         @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
;   END REGION


; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -VPlanDriverHIR -vplan-force-linearization-hir=false -vplan-force-vf=4 -print-after=VPlanDriverHIR -vplan-print-after-ssa-deconstruction -vplan-dump-external-defs-hir=0 -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,vplan-driver-hir" -vplan-force-linearization-hir=false -vplan-force-vf=4 -print-after=vplan-driver-hir -vplan-print-after-ssa-deconstruction -vplan-dump-external-defs-hir=0 -disable-output < %s 2>&1 | FileCheck %s

define void @foo(float* noalias nocapture %arr1, float* noalias nocapture %arr2, i32 %n1) {
; CHECK-LABEL:  VPlan after SSA deconstruction:
; CHECK-NEXT:  VPlan IR for: Initial VPlan for VF=4
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 99, UF = 1
; CHECK-NEXT:     [DA: Div] float [[VP__RED_INIT:%.*]] = reduction-init float 0.000000e+00
; CHECK-NEXT:     [DA: Div] i64 [[VP__IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP__IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     [DA: Div] float [[VP0:%.*]] = phi  [ float [[VP__RED_INIT]], [[BB1]] ],  [ float [[VP1:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i64 [[VP2:%.*]] = phi  [ i64 [[VP__IND_INIT]], [[BB1]] ],  [ i64 [[VP3:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Uni] i1 [[VP4:%.*]] = icmp eq i32 [[N10:%.*]] i32 0
; CHECK-NEXT:     [DA: Uni] br i1 [[VP4]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB5]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] float* [[VP_SUBSCRIPT:%.*]] = subscript inbounds float* [[ARR20:%.*]] i64 [[VP2]]
; CHECK-NEXT:       [DA: Div] float [[VP_LOAD:%.*]] = load float* [[VP_SUBSCRIPT]]
; CHECK-NEXT:       [DA: Div] float [[VP5:%.*]] = hir-copy float [[VP_LOAD]] , OriginPhiId: -1
; CHECK-NEXT:       [DA: Div] float [[VP6:%.*]] = hir-copy float [[VP0]] , OriginPhiId: 0
; CHECK-NEXT:       [DA: Div] float [[VP7:%.*]] = hir-copy float [[VP5]] , OriginPhiId: 1
; CHECK-NEXT:       [DA: Uni] br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] float* [[VP_SUBSCRIPT_1:%.*]] = subscript inbounds float* [[ARR10:%.*]] i64 [[VP2]]
; CHECK-NEXT:       [DA: Div] float [[VP_LOAD_1:%.*]] = load float* [[VP_SUBSCRIPT_1]]
; CHECK-NEXT:       [DA: Div] float [[VP8:%.*]] = hir-copy float [[VP_LOAD_1]] , OriginPhiId: -1
; CHECK-NEXT:       [DA: Div] float [[VP9:%.*]] = hir-copy float [[VP0]] , OriginPhiId: 0
; CHECK-NEXT:       [DA: Div] float [[VP10:%.*]] = hir-copy float [[VP8]] , OriginPhiId: 1
; CHECK-NEXT:       [DA: Uni] br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB4]], [[BB5]]
; CHECK-NEXT:     [DA: Div] float [[VP11:%.*]] = phi  [ float [[VP9]], [[BB4]] ],  [ float [[VP6]], [[BB5]] ]
; CHECK-NEXT:     [DA: Div] float [[VP12:%.*]] = phi  [ float [[VP10]], [[BB4]] ],  [ float [[VP7]], [[BB5]] ]
; CHECK-NEXT:     [DA: Div] float [[VP1]] = fadd float [[VP12]] float [[VP11]]
; CHECK-NEXT:     [DA: Div] i64 [[VP3]] = add i64 [[VP2]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP13:%.*]] = icmp sle i64 [[VP3]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP13]], [[BB2]], [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB3]]
; CHECK-NEXT:     [DA: Uni] float [[VP__RED_FINAL:%.*]] = reduction-final{fadd} float [[VP1]] float live-in1
; CHECK-NEXT:     [DA: Uni] i64 [[VP__IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     [DA: Uni] br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     [DA: Uni] br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i64 [[VP__IND_FINAL]]
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1   float [[VP__RED_FINAL]] -> [[VP14:%.*]] = {%red.phi}
; CHECK-EMPTY:
; CHECK-NEXT:  *** IR Dump After{{.+}}VPlan{{.*}}Driver{{.*}}HIR{{.*}} ***
; CHECK-NEXT:  Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:  <0>          BEGIN REGION { modified }
; CHECK-NEXT:  <27>                  [[RED_VAR0:%.*]] = 0.000000e+00
; CHECK-NEXT:  <26>               + DO i1 = 0, 99, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; CHECK-NEXT:  <29>               |   [[DOTVEC0:%.*]] = [[N10]] == 0
; CHECK-NEXT:  <30>               |   [[UNIFCOND0:%.*]] = extractelement [[DOTVEC0]],  0
; CHECK-NEXT:  <31>               |   if ([[UNIFCOND0]] == 1)
; CHECK-NEXT:  <31>               |   {
; CHECK-NEXT:  <32>               |      goto [[BB4]].40
; CHECK-NEXT:  <31>               |   }
; CHECK-NEXT:  <35>               |   [[DOTVEC20:%.*]] = (<4 x float>*)([[ARR20]])[i1]
; CHECK-NEXT:  <36>               |   [[DOTCOPY0:%.*]] = [[DOTVEC20]]
; CHECK-NEXT:  <37>               |   [[PHI_TEMP0:%.*]] = [[RED_VAR0]]
; CHECK-NEXT:  <38>               |   [[PHI_TEMP40:%.*]] = [[DOTCOPY0]]
; CHECK-NEXT:  <39>               |   goto [[BB3]].46
; CHECK-NEXT:  <40>               |   [[BB4]].40:
; CHECK-NEXT:  <41>               |   [[DOTVEC60:%.*]] = (<4 x float>*)([[ARR10]])[i1]
; CHECK-NEXT:  <42>               |   [[DOTCOPY70:%.*]] = [[DOTVEC60]]
; CHECK-NEXT:  <43>               |   [[PHI_TEMP0]] = [[RED_VAR0]]
; CHECK-NEXT:  <44>               |   [[PHI_TEMP40]] = [[DOTCOPY70]]
; CHECK-NEXT:  <46>               |   [[BB3]].46:
; CHECK-NEXT:  <47>               |   [[RED_VAR0]] = [[PHI_TEMP40]]  +  [[PHI_TEMP0]]
; CHECK-NEXT:  <26>               + END LOOP
; CHECK-NEXT:  <48>                  [[RED_PHI0:%.*]] = @llvm.vector.reduce.fadd.v4f32([[RED_PHI0]],  [[RED_VAR0]])
; CHECK-NEXT:  <0>          END REGION
;

entry:
  %tobool = icmp eq i32 %n1, 0
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %red.phi = phi float [0.0, %entry], [%red.add, %for.inc]
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %arrayidx = getelementptr inbounds float, float* %arr1, i64 %indvars.iv
  %ld.true = load float, float* %arrayidx, align 4
  br label %for.inc

if.else:
  %arrayidx2 = getelementptr inbounds float, float* %arr2, i64 %indvars.iv
  %ld.false = load float, float* %arrayidx2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %merge.phi = phi float [%ld.true, %if.then], [%ld.false, %if.else]
  %red.add = fadd fast float %merge.phi, %red.phi
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  ret void
}

