; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN:  opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -print-after=hir-vplan-vec -disable-output < %s 2>&1 | FileCheck %s -check-prefix=CHECK-HIR
; RUN:  opt -enable-new-pm=0 -vplan-vec -print-after=vplan-vec -vplan-force-uf=2 -disable-output < %s 2>&1 | FileCheck %s -check-prefix=CHECK-LLVM-IR
; RUN:  opt -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir>' -disable-output < %s 2>&1 | FileCheck %s -check-prefix=CHECK-HIR
; RUN:  opt -passes='vplan-vec' -print-after=vplan-vec -vplan-force-uf=2 -disable-output < %s 2>&1 | FileCheck %s -check-prefix=CHECK-LLVM-IR


target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

;
; Input source code is:
; int a[4];
;
; void foo() {
;  int i, x;
;
; #pragma omp simd simdlen(4)
; #pragma unroll 2
;   for(i = 0; i < 4; i++)
;     x = a[i];
; }
;
; The test verifies that VPlan bails out to scalar VPlan.

@a = dso_local local_unnamed_addr global [4 x i32] zeroinitializer, align 16

; Function Attrs: nounwind uwtable
define dso_local void @foo() {
;                   *** IR Dump After VPlan HIR Vectorizer (hir-vplan-vec) ***
; CHECK-HIR:       Function: foo
; CHECK-HIR-EMPTY:
; CHECK-HIR-NEXT:  <0>          BEGIN REGION { }
; CHECK-HIR-NEXT:  <2>                [[TMP0:%.*]] = @llvm.directive.region.entry()
; CHECK-HIR-NEXT:  <17>
; CHECK-HIR-NEXT:  <17>               + DO i1 = 0, 3, 1   <DO_LOOP> <simd> <unroll = 2> <vectorize>
; CHECK-HIR-NEXT:  <7>                |   [[TMP1:%.*]] = (@a)[0][i1]
; CHECK-HIR-NEXT:  <17>               + END LOOP
; CHECK-HIR-NEXT:  <17>
; CHECK-HIR-NEXT:  <15>               @llvm.directive.region.exit([[TMP0]])
; CHECK-HIR-NEXT:  <16>               ret
; CHECK-HIR-NEXT:  <0>          END REGION
;
;
; CHECK-LLVM-IR:  define dso_local void @foo() {
; CHECK-LLVM-IR-NEXT:  entry:
; CHECK-LLVM-IR-NEXT:    [[I_LINEAR_IV0:%.*]] = alloca i32, align 4
; CHECK-LLVM-IR-NEXT:    br label [[OMP_INNER_FOR_BODY_LR_PH0:%.*]]
; CHECK-LLVM-IR-EMPTY:
; CHECK-LLVM-IR-NEXT:  omp.inner.for.body.lr.ph:
; CHECK-LLVM-IR-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4),  "QUAL.OMP.LINEAR:IV.TYPED"(i32* [[I_LINEAR_IV0]], i32 0, i32 1, i32 1) ]
; CHECK-LLVM-IR-NEXT:    br label [[OMP_INNER_FOR_BODY0:%.*]]
; CHECK-LLVM-IR-EMPTY:
; CHECK-LLVM-IR-NEXT:  omp.inner.for.body:
; CHECK-LLVM-IR-NEXT:    [[IV0:%.*]] = phi i64 [ 0, [[OMP_INNER_FOR_BODY_LR_PH0]] ], [ [[IV_NEXT0:%.*]], [[OMP_INNER_FOR_BODY0]] ]
; CHECK-LLVM-IR-NEXT:    [[IDX0:%.*]] = getelementptr inbounds [4 x i32], [4 x i32]* @a, i64 0, i64 [[IV0]]
; CHECK-LLVM-IR-NEXT:    [[TMP1:%.*]] = load i32, i32* [[IDX0]], align 4
; CHECK-LLVM-IR-NEXT:    [[IV_NEXT0]] = add nuw nsw i64 [[IV0]], 1
; CHECK-LLVM-IR-NEXT:    [[EXITCOND0:%.*]] = icmp eq i64 [[IV_NEXT0]], 4
; CHECK-LLVM-IR-NEXT:    br i1 [[EXITCOND0]], label [[DIR_OMP_END_SIMD_40:%.*]], label [[OMP_INNER_FOR_BODY0]], !llvm.loop !0
; CHECK-LLVM-IR-EMPTY:
; CHECK-LLVM-IR-NEXT:  DIR.OMP.END.SIMD.4:
; CHECK-LLVM-IR-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.SIMD"() ]
; CHECK-LLVM-IR-NEXT:    ret void
; CHECK-LLVM-IR-NEXT:  }
;
entry:
  %i.linear.iv = alloca i32, align 4
  br label %omp.inner.for.body.lr.ph

omp.inner.for.body.lr.ph:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4), "QUAL.OMP.LINEAR:IV.TYPED"(i32* %i.linear.iv, i32 0, i32 1, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body.lr.ph, %omp.inner.for.body
  %iv = phi i64 [ 0, %omp.inner.for.body.lr.ph ], [ %iv.next, %omp.inner.for.body ]
  %idx = getelementptr inbounds [4 x i32], [4 x i32]* @a, i64 0, i64 %iv
  %1 = load i32, i32* %idx, align 4
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 4
  br i1 %exitcond, label %DIR.OMP.END.SIMD.4, label %omp.inner.for.body, !llvm.loop !8

DIR.OMP.END.SIMD.4:                               ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }
!7 = distinct !{}
!8 = distinct !{!8, !9, !10}
!9 = !{!"llvm.loop.unroll.count", i32 2}
!10 = !{!"llvm.loop.parallel_accesses", !7}
