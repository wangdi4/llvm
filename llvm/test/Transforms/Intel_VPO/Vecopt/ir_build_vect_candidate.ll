; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -vplan-build-vect-candidates=1 -VPlanDriver -vplan-force-vf=4 -S -vplan-print-after-linearization %s | FileCheck %s
; RUN: opt -vplan-build-vect-candidates=1 -passes="vplan-driver" -vplan-force-vf=4 -S -vplan-print-after-linearization %s | FileCheck %s
;
; LIT test to check -vplan-build-vect-candidates functionality. The
; vplan-build-vect-candidates switch is used to generate candidate loops for
; VPlan vectorization using community loop vectorizer's legality checks. VPlan
; pipeline is expected to handle such candidate loops properly. The test checks
; for correct VPlan dump after predication and vector code generation.
;
; Removed unnecessary auto-generated checks in generated vector code.
;
define void @foo(i64* nocapture %larr) {
; CHECK-LABEL:  VPlan after predication and linearization:
; CHECK-NEXT:  Live-in values:
; CHECK-NEXT:  ID: 0 Value: i64 0
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_L1_IND_INIT:%.*]] = induction-init{add} i64 live-in0 i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_L1_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VF:%.*]] = induction-init-step{add} i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop for.body
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i64 0, [[BB1]] ],  [ i64 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB3:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i64 [[VP_L1:%.*]] = phi  [ i64 [[VP_L1_IND_INIT]], [[BB1]] ],  [ i64 [[VP_INC:%.*]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i64* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i64* [[LARR0:%.*]] i64 [[VP_L1]]
; CHECK-NEXT:     [DA: Div] i64 [[VP_LDVAL:%.*]] = load i64* [[VP_ARRAYIDX]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LDVALCMP:%.*]] = icmp i64 [[VP_LDVAL]] i64 1111
; CHECK-NEXT:     [DA: Div] i1 [[VP_LDVALCMP_NOT:%.*]] = not i1 [[VP_LDVALCMP]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_LDVALCMP_NOT]]
; CHECK-NEXT:     [DA: Div] store i64 2222 i64* [[VP_ARRAYIDX]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB5:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_LDVALCMP]]
; CHECK-NEXT:     [DA: Div] store i64 3333 i64* [[VP_ARRAYIDX]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     [DA: Div] i64 [[VP_INC]] = add i64 [[VP_L1]] i64 [[VP_L1_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_VECTOR_LOOP_IV_NEXT]] = add i64 [[VP_VECTOR_LOOP_IV]] i64 [[VP_VF]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp i64 [[VP_VECTOR_LOOP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB6:BB[0-9]+]](i1 [[VP_VECTOR_LOOP_EXITCOND]]), [[BB2]](!i1 [[VP_VECTOR_LOOP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(1): [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]:
; CHECK-NEXT:     [DA: Uni] i64 [[VP_L1_IND_FINAL:%.*]] = induction-final{add} i64 live-in0 i64 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB7:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i64 [[VP_L1_IND_FINAL]]
;
; CHECK:  define void @foo(i64* nocapture [[LARR0]]) {
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VECTOR_PH0:%.*]] ], [ [[TMP7:%.*]], [[VECTOR_BODY0:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI10:%.*]] = phi i64 [ 0, [[VECTOR_PH0]] ], [ [[TMP6:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VECTOR_PH0]] ], [ [[TMP5:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr inbounds i64, i64* [[LARR0]], i64 [[UNI_PHI10]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i64* [[SCALAR_GEP0]] to <4 x i64>*
; CHECK-NEXT:    [[WIDE_LOAD0:%.*]] = load <4 x i64>, <4 x i64>* [[TMP0]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <4 x i64> [[WIDE_LOAD0]], <i64 1111, i64 1111, i64 1111, i64 1111>
; CHECK-NEXT:    [[TMP2:%.*]] = xor <4 x i1> [[TMP1]], <i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i64* [[SCALAR_GEP0]] to <4 x i64>*
; CHECK-NEXT:    call void @llvm.masked.store.v4i64.p0v4i64(<4 x i64> <i64 2222, i64 2222, i64 2222, i64 2222>, <4 x i64>* [[TMP3]], i32 8, <4 x i1> [[TMP2]])
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i64* [[SCALAR_GEP0]] to <4 x i64>*
; CHECK-NEXT:    call void @llvm.masked.store.v4i64.p0v4i64(<4 x i64> <i64 3333, i64 3333, i64 3333, i64 3333>, <4 x i64>* [[TMP4]], i32 8, <4 x i1> [[TMP1]])
; CHECK-NEXT:    [[TMP5]] = add nuw nsw <4 x i64> [[VEC_PHI0]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP6]] = add nuw nsw i64 [[UNI_PHI10]], 4
; CHECK-NEXT:    [[TMP7]] = add i64 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i64 [[TMP7]], 100
; CHECK-NEXT:    br i1 [[TMP8]], label [[VPLANNEDBB0:%.*]], label [[VECTOR_BODY0]]
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %l1 = phi i64 [ 0, %entry ], [ %inc, %for.inc ]
  %arrayidx = getelementptr inbounds i64, i64* %larr, i64 %l1
  %ldval = load i64, i64* %arrayidx, align 8
  %ldvalcmp = icmp eq i64 %ldval, 1111
  br i1 %ldvalcmp, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  store i64 2222, i64* %arrayidx, align 8
  br label %for.inc

if.else:                                          ; preds = %for.body
  store i64 3333, i64* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.then, %if.else
  %inc = add nuw nsw i64 %l1, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  ret void
}

