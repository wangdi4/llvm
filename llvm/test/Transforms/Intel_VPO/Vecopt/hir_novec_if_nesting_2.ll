; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -analyze -hir-parvec-analysis -debug-only=parvec-analysis < %s 2>&1 | FileCheck %s
; RUN: opt -passes='hir-ssa-deconstruction,print<hir-parvec-analysis>' -debug-only=parvec-analysis -disable-output < %s 2>&1 | FileCheck %s

; Check that vectorization is blocked due to dependence between %dn array references in different if paths.
; Function: main
;
; <0>          BEGIN REGION { }
; <42>               + DO i1 = 0, 76, 1   <DO_LOOP>
; <4>                |   if (-1 * i1 + 67 != 0)
; <4>                |   {
; <8>                |      %nc6.039 = %nc6.039  +  -1;
; <10>               |      if (%nc6.039 == 0)
; <10>               |      {
; <15>               |         (%dn)[0][i1 + 3] = 0;
; <16>               |         %nc6.039 = 0;
; <10>               |      }
; <10>               |      else
; <10>               |      {
; <19>               |         %nc7.040 = %nc7.040  +  -1;
; <21>               |         if (%nc7.040 == 0)
; <21>               |         {
; <32>               |            %nc7.040 = 0;
; <21>               |         }
; <21>               |         else
; <21>               |         {
; <27>               |            %2 = (%dn)[0][i1 + 2];
; <29>               |            (%dn)[0][i1 + 2] = %2 + -1;
; <21>               |         }
; <10>               |      }
; <4>                |   }
; <42>               + END LOOP
; <0>          END REGION

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nofree nounwind uwtable
define dso_local i32 @main() {
; CHECK:  15:27 ([[DN0:%.*]])[0][i1 + 3] --> ([[DN0]])[0][i1 + 2] FLOW (<) (1)
; CHECK-NEXT:    DV is not refinable - unsafe to vectorize
; CHECK-NEXT:  15:29 ([[DN0]])[0][i1 + 3] --> ([[DN0]])[0][i1 + 2] OUTPUT (<) (1)
; CHECK-NEXT:    DV is not refinable - unsafe to vectorize

entry:
  %dn = alloca [100 x i32], align 16
  %0 = bitcast [100 x i32]* %dn to i8*
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 3, %entry ], [ %indvars.iv.next, %for.inc ]
  %nc7.040 = phi i32 [ 27, %entry ], [ %nc7.1, %for.inc ]
  %nc6.039 = phi i32 [ 31, %entry ], [ %nc6.1, %for.inc ]
  %nc5.038 = phi i32 [ 68, %entry ], [ %dec, %for.inc ]
  %dec = add nsw i32 %nc5.038, -1
  %tobool.not = icmp eq i32 %dec, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %dec1 = add i32 %nc6.039, -1
  %tobool2.not = icmp eq i32 %dec1, 0
  br i1 %tobool2.not, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.then
  %dec4 = add i32 %nc7.040, -1
  %tobool5.not = icmp eq i32 %dec4, 0
  br i1 %tobool5.not, label %for.inc, label %if.then6

if.then6:                                         ; preds = %if.then3
  %1 = add nsw i64 %indvars.iv, -1
  %arrayidx7 = getelementptr inbounds [100 x i32], [100 x i32]* %dn, i64 0, i64 %1
  %2 = load i32, i32* %arrayidx7, align 4
  %sub8 = add i32 %2, -1
  store i32 %sub8, i32* %arrayidx7, align 4
  br label %for.inc

if.else:                                          ; preds = %if.then
  %arrayidx10 = getelementptr inbounds [100 x i32], [100 x i32]* %dn, i64 0, i64 %indvars.iv
  store i32 0, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then6, %if.then3, %for.body
  %nc6.1 = phi i32 [ %dec1, %if.then6 ], [ %dec1, %if.then3 ], [ 0, %if.else ], [ %nc6.039, %for.body ]
  %nc7.1 = phi i32 [ %dec4, %if.then6 ], [ 0, %if.then3 ], [ %nc7.040, %if.else ], [ %nc7.040, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 80
  br i1 %exitcond.not, label %checkSum.exit, label %for.body

checkSum.exit:                                    ; preds = %for.body.i
  ret i32 0
}
