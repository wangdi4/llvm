; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -S -enable-intel-advanced-opts -slp-multinode -slp-vectorizer -slp-threshold=10000 -mattr=+avx2 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%class.Mychar_ = type { i8 }

; Issue related to saving backup data for IR after Multi-Node reordering.
; Thus after changing design to not modify underlying IR the test can be discarded.
; Here specifically operands op1, op2 and op3 were reordered for lane 1
; In the original MN lane1: op2 and op3 are siblings. Op2 visited first but
; we did not search for a sibling as it is left operand. Then we visited Op3
; and we looked for sibling because we were updating frontier.
; We overrided originally saved data with incorrect one for sibling (because
; operand update has already been done for it).

; (Note: changes made to IR, reordered operands and reversed Frontier opcodes marked with '!')
; Original:                             Reordered:
;op2:%i1 op3:0   op2:%i1 op3:%i5          !op2:%i0  !op3:%i1  !op2:%i5  !op3:undef
;    \   /            \   /                       \   /               \    /
;     ADD              ADD                         ADD                !SUB
;      |                |                           |                   |
;     %i2  op1:%i0     %i6   op1:undef             %i2  !op1:0         %i6   !op1:%i1
;       \   /             \   /                      \   /               \   /
;        ADD               SUB                        ADD                !ADD
;         |                 |                          |                   |
;        %i3  op0:undef    %i7   op0:0                 %i3  op0:undef     %i7   op0:0
;           \   /            \   /                        \   /              \   /
;            SUB              ADD                          SUB                ADD
;             |                |                            |                  |
;    lane 0: %i4      lane 1: %i8                  lane 0: %i4        lane 1: %i8

define dso_local i1 @_test() local_unnamed_addr {
; CHECK-LABEL: @_test(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[I0:%.*]] = shl i64 undef, 6
; CHECK-NEXT:    [[I1:%.*]] = ptrtoint %class.Mychar_* undef to i64
; CHECK-NEXT:    [[I2:%.*]] = add i64 0, [[I1]]
; CHECK-NEXT:    [[I3:%.*]] = add i64 [[I2]], [[I0]]
; CHECK-NEXT:    [[I4:%.*]] = sub i64 [[I3]], undef
; CHECK-NEXT:    [[I5:%.*]] = ptrtoint %class.Mychar_* undef to i64
; CHECK-NEXT:    [[I6:%.*]] = add i64 [[I1]], [[I5]]
; CHECK-NEXT:    [[I7:%.*]] = sub i64 [[I6]], undef
; CHECK-NEXT:    [[I8:%.*]] = add i64 [[I7]], 0
; CHECK-NEXT:    [[I9:%.*]] = lshr i64 [[I8]], 1
; CHECK-NEXT:    [[I10:%.*]] = icmp ult i64 [[I4]], [[I9]]
; CHECK-NEXT:    ret i1 [[I10]]
;
bb:
  %i0 = shl i64 undef, 6
  %i1 = ptrtoint %class.Mychar_* undef to i64
  %i2 = add i64 0, %i1
  %i3 = add i64 %i2, %i0
  %i4 = sub i64 %i3, undef
  %i5 = ptrtoint %class.Mychar_* undef to i64
  %i6 = add i64 %i1, %i5
  %i7 = sub i64 %i6, undef
  %i8 = add i64 %i7, 0
  %i9 = lshr i64 %i8, 1
  %i10 = icmp ult i64 %i4, %i9
  ret i1 %i10
}
