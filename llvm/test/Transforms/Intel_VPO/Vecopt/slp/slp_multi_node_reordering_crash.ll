; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -slp-vectorizer -enable-intel-advanced-opts -mcpu=haswell -multi-node-verifier-checks=true -S | FileCheck %s

; CMPLRLLVM-20603
; SLP found a multi-node here and tried to reorder its operands (reordering is
; effectively swapping of operands of different instructions within the same
; Multi-node).

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local i32 @main() local_unnamed_addr {
; CHECK-LABEL: @main(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[Y:%.*]] = alloca [100 x i32], align 16
; CHECK-NEXT:    [[CL7:%.*]] = alloca [100 x i32], align 16
; CHECK-NEXT:    [[D5:%.*]] = alloca [100 x i32], align 16
; CHECK-NEXT:    [[ARRAYIDX664:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[Y]], i64 0, i64 11
; CHECK-NEXT:    [[ARRAYIDX667:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[CL7]], i64 0, i64 11
; CHECK-NEXT:    [[ARRAYIDX677:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[D5]], i64 0, i64 10
; CHECK-NEXT:    [[ARRAYIDX869:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[D5]], i64 0, i64 2
; CHECK-NEXT:    [[I127:%.*]] = bitcast i32* [[ARRAYIDX869]] to <8 x i32>*
; CHECK-NEXT:    [[I130:%.*]] = load <8 x i32>, <8 x i32>* [[I127]], align 8
; CHECK-NEXT:    [[I131:%.*]] = extractelement <8 x i32> [[I130]], i32 7
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[ARRAYIDX664]] to <4 x i32>*
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, <4 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32* [[ARRAYIDX667]] to <4 x i32>*
; CHECK-NEXT:    [[TMP3:%.*]] = load <4 x i32>, <4 x i32>* [[TMP2]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = sub <4 x i32> [[TMP3]], [[TMP1]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i32* [[ARRAYIDX677]] to <4 x i32>*
; CHECK-NEXT:    [[TMP6:%.*]] = load <4 x i32>, <4 x i32>* [[TMP5]], align 8
; CHECK-NEXT:    [[TMP7:%.*]] = insertelement <4 x i32> poison, i32 [[I131]], i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i32> [[TMP7]], <4 x i32> [[TMP6]], <4 x i32> <i32 0, i32 4, i32 5, i32 6>
; CHECK-NEXT:    [[TMP9:%.*]] = sub <4 x i32> [[TMP6]], [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = add <4 x i32> [[TMP9]], [[TMP4]]
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast i32* [[ARRAYIDX667]] to <4 x i32>*
; CHECK-NEXT:    store <4 x i32> [[TMP10]], <4 x i32>* [[TMP11]], align 4
; CHECK-NEXT:    [[ARRAYIDX880:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[Y]], i64 0, i64 2
; CHECK-NEXT:    [[GEPLOAD881:%.*]] = load i32, i32* [[ARRAYIDX880]], align 8
; CHECK-NEXT:    [[ARRAYIDX883:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[CL7]], i64 0, i64 2
; CHECK-NEXT:    [[GEPLOAD884:%.*]] = load i32, i32* [[ARRAYIDX883]], align 8
; CHECK-NEXT:    [[I151:%.*]] = sub i32 [[GEPLOAD884]], [[GEPLOAD881]]
; CHECK-NEXT:    store i32 [[I151]], i32* [[ARRAYIDX883]], align 8
; CHECK-NEXT:    ret i32 0
;
entry:
  %y = alloca [100 x i32], align 16
  %cl7 = alloca [100 x i32], align 16
  %d5 = alloca [100 x i32], align 16

  %arrayIdx592 = getelementptr inbounds [100 x i32], [100 x i32]* %y, i64 0, i64 14
  %gepload593 = load i32, i32* %arrayIdx592, align 8
  %arrayIdx595 = getelementptr inbounds [100 x i32], [100 x i32]* %cl7, i64 0, i64 14
  %gepload596 = load i32, i32* %arrayIdx595, align 8
  %i115 = sub i32 %gepload596, %gepload593
  %arrayIdx605 = getelementptr inbounds [100 x i32], [100 x i32]* %d5, i64 0, i64 13
  %gepload606 = load i32, i32* %arrayIdx605, align 4

  %arrayIdx616 = getelementptr inbounds [100 x i32], [100 x i32]* %y, i64 0, i64 13
  %gepload617 = load i32, i32* %arrayIdx616, align 4
  %arrayIdx619 = getelementptr inbounds [100 x i32], [100 x i32]* %cl7, i64 0, i64 13
  %gepload620 = load i32, i32* %arrayIdx619, align 4
  %i118 = sub i32 %gepload620, %gepload617
  %arrayIdx629 = getelementptr inbounds [100 x i32], [100 x i32]* %d5, i64 0, i64 12
  %gepload630 = load i32, i32* %arrayIdx629, align 16

  %i119 = sub i32 %gepload606, %gepload630
  %i120 = add i32 %i119, %i115
  store i32 %i120, i32* %arrayIdx595, align 8

  %arrayIdx640 = getelementptr inbounds [100 x i32], [100 x i32]* %y, i64 0, i64 12
  %gepload641 = load i32, i32* %arrayIdx640, align 16
  %arrayIdx643 = getelementptr inbounds [100 x i32], [100 x i32]* %cl7, i64 0, i64 12
  %gepload644 = load i32, i32* %arrayIdx643, align 16
  %i121 = sub i32 %gepload644, %gepload641
  %arrayIdx653 = getelementptr inbounds [100 x i32], [100 x i32]* %d5, i64 0, i64 11
  %gepload654 = load i32, i32* %arrayIdx653, align 4

  %i122 = sub i32 %gepload630, %gepload654
  %i123 = add i32 %i122, %i118
  store i32 %i123, i32* %arrayIdx619, align 4

  %arrayIdx664 = getelementptr inbounds [100 x i32], [100 x i32]* %y, i64 0, i64 11
  %gepload665 = load i32, i32* %arrayIdx664, align 4
  %arrayIdx667 = getelementptr inbounds [100 x i32], [100 x i32]* %cl7, i64 0, i64 11
  %gepload668 = load i32, i32* %arrayIdx667, align 4

; Problem happened here when operand %131 of instruction %128
; swapped with operand %gepload665 of instruction %124 and that resulted in
; use before def condition. The reordering legality check did only check
; it in terms of preserving expression semantics but did not check for
; IR legality.

  %i124 = sub i32 %gepload668, %gepload665
  %arrayIdx677 = getelementptr inbounds [100 x i32], [100 x i32]* %d5, i64 0, i64 10
  %gepload678 = load i32, i32* %arrayIdx677, align 8
  %i125 = sub i32 %gepload654, %gepload678
  %i126 = add i32 %i125, %i121
  store i32 %i126, i32* %arrayIdx643, align 16

  %arrayIdx869 = getelementptr inbounds [100 x i32], [100 x i32]* %d5, i64 0, i64 2
  %i127 = bitcast i32* %arrayIdx869 to <8 x i32>*
  %i130 = load <8 x i32>, <8 x i32>* %i127, align 8
  %i131 = extractelement <8 x i32> %i130, i32 7
  %i128 = sub i32 %gepload678, %i131
  %i129 = add i32 %i128, %i124
  store i32 %i129, i32* %arrayIdx667, align 4

  %arrayIdx880 = getelementptr inbounds [100 x i32], [100 x i32]* %y, i64 0, i64 2
  %gepload881 = load i32, i32* %arrayIdx880, align 8
  %arrayIdx883 = getelementptr inbounds [100 x i32], [100 x i32]* %cl7, i64 0, i64 2
  %gepload884 = load i32, i32* %arrayIdx883, align 8
  %i151 = sub i32 %gepload884, %gepload881
  store i32 %i151, i32* %arrayIdx883, align 8

  ret i32 0
}
