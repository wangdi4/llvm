; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=slp-vectorizer -enable-intel-advanced-opts -slp-multinode -mtriple=x86_64 -mattr=+avx2 -S | FileCheck %s

; CMPLRLLVM-20603
; SLP found a multi-node here and tried to reorder its operands (reordering is
; effectively swapping of operands of different instructions within the same
; Multi-node).

define i32 @test() {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[Y:%.*]] = alloca [100 x i32], align 16
; CHECK-NEXT:    [[CL7:%.*]] = alloca [100 x i32], align 16
; CHECK-NEXT:    [[D5:%.*]] = alloca [100 x i32], align 16
; CHECK-NEXT:    [[ARRAYIDX664:%.*]] = getelementptr inbounds [100 x i32], ptr [[Y]], i64 0, i64 11
; CHECK-NEXT:    [[ARRAYIDX667:%.*]] = getelementptr inbounds [100 x i32], ptr [[CL7]], i64 0, i64 11
; CHECK-NEXT:    [[ARRAYIDX677:%.*]] = getelementptr inbounds [100 x i32], ptr [[D5]], i64 0, i64 10
; CHECK-NEXT:    [[ARRAYIDX869:%.*]] = getelementptr inbounds [100 x i32], ptr [[D5]], i64 0, i64 2
; CHECK-NEXT:    [[I130:%.*]] = load <8 x i32>, ptr [[ARRAYIDX869]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[ARRAYIDX664]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr [[ARRAYIDX667]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = sub <4 x i32> [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = load <4 x i32>, ptr [[ARRAYIDX677]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x i32> [[I130]], <8 x i32> poison, <4 x i32> <i32 7, i32 undef, i32 undef, i32 undef>
; CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x i32> [[TMP3]], <4 x i32> poison, <4 x i32> <i32 undef, i32 0, i32 1, i32 2>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x i32> [[TMP4]], <4 x i32> [[TMP5]], <4 x i32> <i32 0, i32 5, i32 6, i32 7>
; CHECK-NEXT:    [[TMP7:%.*]] = sub <4 x i32> [[TMP3]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = add <4 x i32> [[TMP7]], [[TMP2]]
; CHECK-NEXT:    store <4 x i32> [[TMP8]], ptr [[ARRAYIDX667]], align 4
; CHECK-NEXT:    [[ARRAYIDX880:%.*]] = getelementptr inbounds [100 x i32], ptr [[Y]], i64 0, i64 2
; CHECK-NEXT:    [[GEPLOAD881:%.*]] = load i32, ptr [[ARRAYIDX880]], align 8
; CHECK-NEXT:    [[ARRAYIDX883:%.*]] = getelementptr inbounds [100 x i32], ptr [[CL7]], i64 0, i64 2
; CHECK-NEXT:    [[GEPLOAD884:%.*]] = load i32, ptr [[ARRAYIDX883]], align 8
; CHECK-NEXT:    [[I151:%.*]] = sub i32 [[GEPLOAD884]], [[GEPLOAD881]]
; CHECK-NEXT:    store i32 [[I151]], ptr [[ARRAYIDX883]], align 8
; CHECK-NEXT:    ret i32 0
;
entry:
  %y = alloca [100 x i32], align 16
  %cl7 = alloca [100 x i32], align 16
  %d5 = alloca [100 x i32], align 16

  %arrayIdx592 = getelementptr inbounds [100 x i32], ptr %y, i64 0, i64 14
  %gepload593 = load i32, ptr %arrayIdx592, align 8
  %arrayIdx595 = getelementptr inbounds [100 x i32], ptr %cl7, i64 0, i64 14
  %gepload596 = load i32, ptr %arrayIdx595, align 8
  %i115 = sub i32 %gepload596, %gepload593
  %arrayIdx605 = getelementptr inbounds [100 x i32], ptr %d5, i64 0, i64 13
  %gepload606 = load i32, ptr %arrayIdx605, align 4

  %arrayIdx616 = getelementptr inbounds [100 x i32], ptr %y, i64 0, i64 13
  %gepload617 = load i32, ptr %arrayIdx616, align 4
  %arrayIdx619 = getelementptr inbounds [100 x i32], ptr %cl7, i64 0, i64 13
  %gepload620 = load i32, ptr %arrayIdx619, align 4
  %i118 = sub i32 %gepload620, %gepload617
  %arrayIdx629 = getelementptr inbounds [100 x i32], ptr %d5, i64 0, i64 12
  %gepload630 = load i32, ptr %arrayIdx629, align 16

  %i119 = sub i32 %gepload606, %gepload630
  %i120 = add i32 %i119, %i115
  store i32 %i120, ptr %arrayIdx595, align 8

  %arrayIdx640 = getelementptr inbounds [100 x i32], ptr %y, i64 0, i64 12
  %gepload641 = load i32, ptr %arrayIdx640, align 16
  %arrayIdx643 = getelementptr inbounds [100 x i32], ptr %cl7, i64 0, i64 12
  %gepload644 = load i32, ptr %arrayIdx643, align 16
  %i121 = sub i32 %gepload644, %gepload641
  %arrayIdx653 = getelementptr inbounds [100 x i32], ptr %d5, i64 0, i64 11
  %gepload654 = load i32, ptr %arrayIdx653, align 4

  %i122 = sub i32 %gepload630, %gepload654
  %i123 = add i32 %i122, %i118
  store i32 %i123, ptr %arrayIdx619, align 4

  %arrayIdx664 = getelementptr inbounds [100 x i32], ptr %y, i64 0, i64 11
  %gepload665 = load i32, ptr %arrayIdx664, align 4
  %arrayIdx667 = getelementptr inbounds [100 x i32], ptr %cl7, i64 0, i64 11
  %gepload668 = load i32, ptr %arrayIdx667, align 4

; Problem happened here when operand %131 of instruction %128
; swapped with operand %gepload665 of instruction %124 and that resulted in
; use before def condition. The reordering legality check did only check
; it in terms of preserving expression semantics but did not check for
; IR legality.

  %i124 = sub i32 %gepload668, %gepload665
  %arrayIdx677 = getelementptr inbounds [100 x i32], ptr %d5, i64 0, i64 10
  %gepload678 = load i32, ptr %arrayIdx677, align 8
  %i125 = sub i32 %gepload654, %gepload678
  %i126 = add i32 %i125, %i121
  store i32 %i126, ptr %arrayIdx643, align 16

  %arrayIdx869 = getelementptr inbounds [100 x i32], ptr %d5, i64 0, i64 2
  %i130 = load <8 x i32>, ptr %arrayIdx869, align 8
  %i131 = extractelement <8 x i32> %i130, i32 7
  %i128 = sub i32 %gepload678, %i131
  %i129 = add i32 %i128, %i124
  store i32 %i129, ptr %arrayIdx667, align 4

  %arrayIdx880 = getelementptr inbounds [100 x i32], ptr %y, i64 0, i64 2
  %gepload881 = load i32, ptr %arrayIdx880, align 8
  %arrayIdx883 = getelementptr inbounds [100 x i32], ptr %cl7, i64 0, i64 2
  %gepload884 = load i32, ptr %arrayIdx883, align 8
  %i151 = sub i32 %gepload884, %gepload881
  store i32 %i151, ptr %arrayIdx883, align 8

  ret i32 0
}
