; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s  -passes=slp-vectorizer -enable-intel-advanced-opts -slp-multinode -mtriple=x86_64 -mcpu=core-avx2 -S | FileCheck %s

@a = dso_local local_unnamed_addr global i32 0, align 4
@e = dso_local local_unnamed_addr global i32 0, align 4
@d = dso_local local_unnamed_addr global i32 0, align 4
@c = dso_local local_unnamed_addr global i32 0, align 4
@b = dso_local local_unnamed_addr global i32 0, align 4

define dso_local i32 @main() local_unnamed_addr {
; CHECK-LABEL: @main(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* @a, align 4
; CHECK-NEXT:    store i32 [[TMP0]], i32* @e, align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32* @d, align 4
; CHECK-NEXT:    [[MUL:%.*]] = shl i32 [[TMP1]], 3
; CHECK-NEXT:    [[MUL1:%.*]] = mul i32 [[MUL]], [[TMP1]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32* @c, align 4
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32* @b, align 4
; CHECK-NEXT:    [[MUL2:%.*]] = mul nsw i32 [[TMP3]], [[TMP2]]
; CHECK-NEXT:    [[MUL3:%.*]] = mul nsw i32 [[MUL2]], [[TMP3]]
; CHECK-NEXT:    [[SUB:%.*]] = add i32 [[TMP2]], [[TMP0]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[SUB]], [[MUL1]]
; CHECK-NEXT:    [[ADD4:%.*]] = sub i32 [[ADD]], [[MUL3]]
; CHECK-NEXT:    store i32 [[ADD4]], i32* @a, align 4
; CHECK-NEXT:    [[MUL5:%.*]] = mul nsw i32 [[ADD4]], [[TMP0]]
; CHECK-NEXT:    [[REASS_ADD17:%.*]] = sub i32 4, [[TMP0]]
; CHECK-NEXT:    [[REASS_MUL:%.*]] = mul i32 [[REASS_ADD17]], [[TMP2]]
; CHECK-NEXT:    [[ADD12:%.*]] = sub i32 [[TMP3]], [[MUL2]]
; CHECK-NEXT:    [[ADD13:%.*]] = add i32 [[ADD12]], [[REASS_MUL]]
; CHECK-NEXT:    [[SUB14_NEG:%.*]] = sub i32 [[ADD13]], [[ADD4]]
; CHECK-NEXT:    [[SUB15:%.*]] = sub i32 [[SUB14_NEG]], [[MUL5]]
; CHECK-NEXT:    store i32 [[SUB15]], i32* @b, align 4
; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[SUB15]], 0
; CHECK-NEXT:    br i1 [[TOBOOL]], label [[IF_END:%.*]], label [[FOR_COND:%.*]]
; CHECK:       for.cond:
; CHECK-NEXT:    br label [[FOR_COND]]
; CHECK:       if.end:
; CHECK-NEXT:    ret i32 0
;
entry:
  %0 = load i32, i32* @a, align 4
  store i32 %0, i32* @e, align 4
  %1 = load i32, i32* @d, align 4
  %mul = shl i32 %1, 3
  %mul1 = mul i32 %mul, %1
  %2 = load i32, i32* @c, align 4
  %3 = load i32, i32* @b, align 4
  %mul2 = mul nsw i32 %3, %2
  %mul3 = mul nsw i32 %mul2, %3
  %sub = add i32 %2, %0
  %add = add i32 %sub, %mul1
  %add4 = sub i32 %add, %mul3
  store i32 %add4, i32* @a, align 4

; Vectorizable tree started with following scalars
; which formed alternate Ops tree entry:
; VL[0]:  %sub14.neg = sub i32 %add13, %add4
; VL[1]:  %mul5 = mul nsw i32 %add4, %0
; Note that instruction %add4 is used in both left and right sides.
; While processed left side %add4 instruction has been
; changed (replaced) by MultiNode reoreding stuff. Thus when we returned
; back after processing left side operands local variable holding operands
; of the right side turned out containing trash.
; The the rest of the tree then built ill formed and eventually that
; caused crash.

  %mul5 = mul nsw i32 %add4, %0
  %reass.add17 = sub i32 4, %0
  %reass.mul = mul i32 %reass.add17, %2
  %add12 = sub i32 %3, %mul2
  %add13 = add i32 %add12, %reass.mul
  %sub14.neg = sub i32 %add13, %add4
  %sub15 = sub i32 %sub14.neg, %mul5
  store i32 %sub15, i32* @b, align 4
  %tobool = icmp eq i32 %sub15, 0
  br i1 %tobool, label %if.end, label %for.cond

for.cond:                                         ; preds = %entry, %for.cond
  br label %for.cond

if.end:                                           ; preds = %entry
  ret i32 0
}
