; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -slp-vectorizer -enable-intel-advanced-opts -slp-multinode=false -slp-multinode-legacy -mtriple=x86_64 -mcpu=core-avx2 -slp-threshold=-10 -S < %s | FileCheck %s
; RUN: opt -slp-vectorizer -enable-intel-advanced-opts -slp-multinode -mtriple=x86_64 -mcpu=core-avx2 -slp-threshold=-10 -S < %s | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"

%class.B = type { %class.A, %class.A }
%class.A = type { [3 x i32] }

; Function Attrs: norecurse nounwind uwtable
define void @foo(%class.B* nocapture readonly %this, i32* nocapture dereferenceable(4) %dir) local_unnamed_addr align 2 {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds [[CLASS_B:%.*]], %class.B* [[THIS:%.*]], i64 0, i32 1, i32 0, i64 0, !intel-tbaa !0
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[ARRAYIDX_I]], align 4, !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    [[ARRAYIDX_I14:%.*]] = getelementptr inbounds [[CLASS_B]], %class.B* [[THIS]], i64 0, i32 0, i32 0, i64 0, !intel-tbaa !7
; CHECK-NEXT:    [[SUB:%.*]] = add i32 [[TMP0]], 1
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[CLASS_B]], %class.B* [[THIS]], i64 0, i32 1, i32 0, i64 1
; CHECK-NEXT:    [[GEPLOAD:%.*]] = load i32, i32* [[ARRAYIDX]], align 4, !tbaa [[TBAA0]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32* [[ARRAYIDX_I14]] to <2 x i32>*
; CHECK-NEXT:    [[TMP2:%.*]] = load <2 x i32>, <2 x i32>* [[TMP1]], align 4, !tbaa [[TBAA7:![0-9]+]]
; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x i32> poison, i32 [[SUB]], i32 0
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x i32> [[TMP3]], i32 [[GEPLOAD]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = sub <2 x i32> [[TMP4]], [[TMP2]]
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x i32> [[TMP5]], i32 1
; CHECK-NEXT:    [[TMP7:%.*]] = add i32 [[TMP6]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <2 x i32> [[TMP5]], i32 0
; CHECK-NEXT:    [[HIR_CMP_39:%.*]] = icmp sgt i32 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[HIR_CMP_39]], label [[THEN_39:%.*]], label [[IFMERGE_39:%.*]]
; CHECK:       then.39:
; CHECK-NEXT:    store i32 1, i32* [[DIR:%.*]], align 4, !tbaa [[TBAA8:![0-9]+]]
; CHECK-NEXT:    br label [[IFMERGE_39]]
; CHECK:       ifmerge.39:
; CHECK-NEXT:    [[T3_0:%.*]] = phi i32 [ 1, [[THEN_39]] ], [ [[TMP8]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX21:%.*]] = getelementptr inbounds [[CLASS_B]], %class.B* [[THIS]], i64 0, i32 1, i32 0, i64 2
; CHECK-NEXT:    [[GEPLOAD22:%.*]] = load i32, i32* [[ARRAYIDX21]], align 4, !tbaa [[TBAA0]]
; CHECK-NEXT:    [[ARRAYIDX23:%.*]] = getelementptr inbounds [[CLASS_B]], %class.B* [[THIS]], i64 0, i32 0, i32 0, i64 2
; CHECK-NEXT:    [[GEPLOAD24:%.*]] = load i32, i32* [[ARRAYIDX23]], align 4, !tbaa [[TBAA7]]
; CHECK-NEXT:    [[TMP9:%.*]] = sub i32 [[GEPLOAD22]], [[GEPLOAD24]]
; CHECK-NEXT:    [[TMP10:%.*]] = add i32 [[TMP9]], 1
; CHECK-NEXT:    [[HIR_CMP_17:%.*]] = icmp sgt i32 [[TMP10]], [[T3_0]]
; CHECK-NEXT:    br i1 [[HIR_CMP_17]], label [[THEN_17:%.*]], label [[IFMERGE_17:%.*]]
; CHECK:       then.17:
; CHECK-NEXT:    store i32 2, i32* [[DIR]], align 4, !tbaa [[TBAA8]]
; CHECK-NEXT:    br label [[IFMERGE_17]]
; CHECK:       ifmerge.17:
; CHECK-NEXT:    ret void
;
entry:
  %arrayidx.i = getelementptr inbounds %class.B, %class.B* %this, i64 0, i32 1, i32 0, i64 0, !intel-tbaa !0
  %0 = load i32, i32* %arrayidx.i, align 4, !tbaa !0
  %arrayidx.i14 = getelementptr inbounds %class.B, %class.B* %this, i64 0, i32 0, i32 0, i64 0, !intel-tbaa !7
  %1 = load i32, i32* %arrayidx.i14, align 4, !tbaa !7
  %sub = add i32 %0, 1
  %add = sub i32 %sub, %1
  %arrayIdx = getelementptr inbounds %class.B, %class.B* %this, i64 0, i32 1, i32 0, i64 1
  %gepload = load i32, i32* %arrayIdx, align 4, !tbaa !0
  %arrayIdx19 = getelementptr inbounds %class.B, %class.B* %this, i64 0, i32 0, i32 0, i64 1
  %gepload20 = load i32, i32* %arrayIdx19, align 4, !tbaa !7
  %2 = sub i32 %gepload, %gepload20
  %3 = add i32 %2, 1
  %hir.cmp.39 = icmp sgt i32 %3, %add
  br i1 %hir.cmp.39, label %then.39, label %ifmerge.39

then.39:                                          ; preds = %entry
  store i32 1, i32* %dir, align 4, !tbaa !8
  br label %ifmerge.39

ifmerge.39:                                       ; preds = %then.39, %entry
  %t3.0 = phi i32 [ 1, %then.39 ], [ %add, %entry ]
  %arrayIdx21 = getelementptr inbounds %class.B, %class.B* %this, i64 0, i32 1, i32 0, i64 2
  %gepload22 = load i32, i32* %arrayIdx21, align 4, !tbaa !0
  %arrayIdx23 = getelementptr inbounds %class.B, %class.B* %this, i64 0, i32 0, i32 0, i64 2
  %gepload24 = load i32, i32* %arrayIdx23, align 4, !tbaa !7
  %4 = sub i32 %gepload22, %gepload24
  %5 = add i32 %4, 1
  %hir.cmp.17 = icmp sgt i32 %5, %t3.0
  br i1 %hir.cmp.17, label %then.17, label %ifmerge.17

then.17:                                          ; preds = %ifmerge.39
  store i32 2, i32* %dir, align 4, !tbaa !8
  br label %ifmerge.17

ifmerge.17:                                       ; preds = %then.17, %ifmerge.39
  ret void
}

!0 = !{!1, !4, i64 12}
!1 = !{!"struct@_ZTS1B", !2, i64 0, !2, i64 12}
!2 = !{!"struct@_ZTS1A", !3, i64 0}
!3 = !{!"array@_ZTSA3_i", !4, i64 0}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C++ TBAA"}
!7 = !{!1, !4, i64 0}
!8 = !{!4, !4, i64 0}
