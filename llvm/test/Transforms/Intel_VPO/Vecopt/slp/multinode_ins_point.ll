; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -mtriple=x86_64 -passes=slp-vectorizer -mattr=+avx2 -enable-intel-advanced-opts -S < %s  | FileCheck %s

target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"

; CMPLRLLVM-52925. Test exposing issue with determining insertion point
; for a MultiNode trunk node (so end up with emitting an instruction not
; dominating its users). Since MN allows reordering operands across
; trunk nodes (i.e. across instructions), it is incorrect to use
; scheduler predicate for that because it looks directly at instruction
; without taking into account operands information stored in the tree node.

define void @test(i64 %a, ptr noalias %p, ptr noalias %y) {
; CHECK-LABEL: define void @test(
; CHECK-SAME: i64 [[A:%.*]], ptr noalias [[P:%.*]], ptr noalias [[Y:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[I2:%.*]] = load i64, ptr [[Y]], align 8
; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x i64> poison, i64 [[A]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i64> [[TMP1]], i64 [[I2]], i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = add <2 x i64> [[TMP2]], zeroinitializer
; CHECK-NEXT:    [[TMP4:%.*]] = add <2 x i64> [[TMP3]], <i64 1, i64 0>
; CHECK-NEXT:    store <2 x i64> [[TMP4]], ptr [[P]], align 8
; CHECK-NEXT:    ret void
;
  %i = add i64 %a, 1
  %i1 = add i64 %i, 0
  store i64 %i1, ptr %p, align 8
  %i2 = load i64, ptr %y, align 8
  %i3 = add i64 0, 0
  %i4 = add i64 %i3, %i2
  %p1 = getelementptr inbounds i64, ptr %p, i64 1
  store i64 %i4, ptr %p1, align 8
  ret void
}
