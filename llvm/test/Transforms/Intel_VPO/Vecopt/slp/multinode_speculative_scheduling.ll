; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes=slp-vectorizer -enable-intel-advanced-opts -mattr=+avx2 -mtriple=x86_64 -S -slp-threshold=-8 < %s  | FileCheck %s

; Below is portion of log that shows what was the problem.
; Instructions pair {%f20, %f21} form root of a multinode which then extended
; with {%f0, %f1}. The problem here is that dependencies for multiNode
; trunk nodes were resolved before reordered. Hence %op2.0 was placed in
; ready-list as an operand of %f20 but reordering actullay swaps operand
; %op2.0 with %op0.0 (across instructions). This discrepancy eventually leads
; to inconsistent sheduler state as when we reach operands of multinode trunk
; node {%f0, %f1}, instruction %op2.0 turns out already scheduled.
; Related extract from -debug-only=SLP log:
; try schedule bundle [  %f20 = add i32 %f0, %op2.0;  %f21 = add i32 %f1, poison] in block entry
;       update deps of /   %f21 = add i32 %f1, poison
;    initially in ready list: [  store i32 %i4, ptr %arrayidx.i2714, align 4;  store i32 %i10, ptr %arrayidx.i2728, align 4]
;   schedule [  store i32 %i4, ptr %arrayidx.i2714, align 4;  store i32 %i10, ptr %arrayidx.i2728, align 4]
;           {...skipped...}
;   schedule [  %i2 = xor i32 %i1, %f20;  %i8 = xor i32 %i5, %f21]
;    gets ready (def):   %i5 = load i32, ptr poison, align 4
;    gets ready (def): [  %f20 = add i32 %f0, %op2.0;  %f21 = add i32 %f1, poison]
; We are able to schedule this bundle.
; added a vector of un/bin op.
; begin MultiNode.
;  bundle:   %f0 = add i32 %op0.0, 490006438
; try schedule bundle [  %f0 = add i32 %op0.0, 490006438;  %f1 = add i32 poison, 690009417] in block entry
;       update deps of [  %f0 = add i32 %op0.0, 490006438;  %f1 = add i32 poison, 690009417]
;       update deps of /   %f1 = add i32 poison, 690009417
;   schedule [  %f20 = add i32 %f0, %op2.0;  %f21 = add i32 %f1, poison]
;    gets ready (def):   %op2.0 = mul i32 %i1, 70004807
;    gets ready (def): [  %f0 = add i32 %op0.0, 490006438;  %f1 = add i32 poison, 690009417]
; We are able to schedule this bundle.
; added a vector of un/bin op.
; built MultiNode of size 2.
; MultiNode: calculating best operands order.


define void @test_scheduler_crash(ptr %p) {
; CHECK-LABEL: define void @test_scheduler_crash
; CHECK-SAME: (ptr [[P:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[OR1454:%.*]] = or i32 poison, poison
; CHECK-NEXT:    [[OP0_0:%.*]] = add i32 poison, poison
; CHECK-NEXT:    [[I1:%.*]] = load i32, ptr poison, align 4
; CHECK-NEXT:    [[OP2_0:%.*]] = mul i32 [[I1]], 70004807
; CHECK-NEXT:    [[I5:%.*]] = load i32, ptr poison, align 4
; CHECK-NEXT:    [[ARRAYIDX_I2714:%.*]] = getelementptr inbounds i32, ptr [[P]], i64 1
; CHECK-NEXT:    [[SHR10_I2686:%.*]] = lshr i32 [[OR1454]], 3
; CHECK-NEXT:    [[TMP0:%.*]] = insertelement <2 x i32> poison, i32 [[OP2_0]], i32 0
; CHECK-NEXT:    [[TMP1:%.*]] = add <2 x i32> [[TMP0]], <i32 490006438, i32 690009417>
; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> poison, i32 [[OP0_0]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = add <2 x i32> [[TMP1]], [[TMP2]]
; CHECK-NEXT:    [[I6:%.*]] = xor i32 [[SHR10_I2686]], poison
; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x i32> poison, i32 [[SHR10_I2686]], i32 0
; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <2 x i32> [[TMP4]], i32 [[I6]], i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = xor <2 x i32> [[TMP5]], <i32 poison, i32 1>
; CHECK-NEXT:    [[TMP7:%.*]] = insertelement <2 x i32> poison, i32 [[I1]], i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = insertelement <2 x i32> [[TMP7]], i32 [[I5]], i32 1
; CHECK-NEXT:    [[TMP9:%.*]] = xor <2 x i32> [[TMP8]], [[TMP3]]
; CHECK-NEXT:    [[TMP10:%.*]] = xor <2 x i32> [[TMP9]], [[TMP6]]
; CHECK-NEXT:    [[TMP11:%.*]] = xor <2 x i32> [[TMP10]], [[TMP3]]
; CHECK-NEXT:    store <2 x i32> [[TMP11]], ptr [[ARRAYIDX_I2714]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %or1454 = or i32 poison, poison
  %op0.0 = add i32 poison, poison
  %shr10.i2686 = lshr i32 %or1454, 3
  %i0 = xor i32 %shr10.i2686, poison
  %i1 = load i32, ptr poison, align 4
  %op2.0 = mul i32 %i1, 70004807
  %f0 = add i32 %op0.0, 490006438
  %f20 = add i32 %f0, %op2.0

  %i2 = xor i32 %i1, %f20
  %i3 = xor i32 %i2, %i0
  %i4 = xor i32 %i3, %f20

  %i5 = load i32, ptr poison, align 4
  %f1 = add i32 poison, 690009417
  %f21 = add i32 %f1, poison
  %i6 = xor i32 %shr10.i2686, poison
  %i7 = xor i32 %i6, 1

  %i8 = xor i32 %i5, %f21
  %i9 = xor i32 %i8, %i7
  %i10 = xor i32 %i9, %f21

  %arrayidx.i2714 = getelementptr inbounds i32, ptr %p, i64 1
  store i32 %i4, ptr %arrayidx.i2714, align 4
  %arrayidx.i2728 = getelementptr inbounds i32, ptr %p, i64 2
  store i32 %i10, ptr %arrayidx.i2728, align 4
  ret void
}
