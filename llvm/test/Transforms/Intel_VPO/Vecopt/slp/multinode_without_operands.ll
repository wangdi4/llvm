; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s  -slp-vectorizer -enable-intel-advanced-opts -slp-multinode -mcpu=skylake -slp-threshold=100 -S  | FileCheck %s

; Vectorization starts from stores at bottom. Once we reach processing of
; phi operands: {%add5, %add6, %add7, %add8}, they form a multinode root.
; Then the multinode trunk extended by {%add1, %add2, %add3, %add4} but
; then none of the instructions operands could be added as reorderable
; miltinode operands because each of these sets contain %ld2, %ld3, %ld4
; or %ld5, and these instructions are already in the vectorization tree
; because instructions from bb1 were visited earlier via phi.
; Crash happened on an attempt to steer path for the multinode [which is
; without operands].

target triple = "x86_64"

define void @test(i32* nocapture noundef %ptr1, i32 noundef %pred) {
; CHECK-LABEL: @test(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i32, i32* [[PTR1:%.*]], i64 17
; CHECK-NEXT:    [[I6:%.*]] = bitcast i32* [[GEP1]] to <4 x i32>*
; CHECK-NEXT:    [[I7:%.*]] = load <4 x i32>, <4 x i32>* [[I6]], align 4
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 21
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 22
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 23
; CHECK-NEXT:    [[GEP5:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 24
; CHECK-NEXT:    [[LD4:%.*]] = load i32, i32* [[GEP4]], align 4
; CHECK-NEXT:    [[LD5:%.*]] = load i32, i32* [[GEP5]], align 4
; CHECK-NEXT:    [[IX:%.*]] = extractelement <4 x i32> [[I7]], i64 3
; CHECK-NEXT:    [[LD2:%.*]] = load i32, i32* [[GEP2]], align 4
; CHECK-NEXT:    [[LD3:%.*]] = load i32, i32* [[GEP3]], align 4
; CHECK-NEXT:    [[ADD1:%.*]] = add i32 [[LD3]], [[IX]]
; CHECK-NEXT:    [[SHL1:%.*]] = shl i32 [[LD2]], 1
; CHECK-NEXT:    [[ADD2:%.*]] = add i32 [[LD4]], [[LD2]]
; CHECK-NEXT:    [[SHL2:%.*]] = shl i32 [[LD3]], 1
; CHECK-NEXT:    [[ADD3:%.*]] = add i32 [[LD5]], [[LD3]]
; CHECK-NEXT:    [[SHL3:%.*]] = shl i32 [[LD4]], 1
; CHECK-NEXT:    [[ADD4:%.*]] = add i32 [[LD4]], 2
; CHECK-NEXT:    [[ADD5:%.*]] = add i32 [[ADD1]], [[SHL1]]
; CHECK-NEXT:    [[ADD6:%.*]] = add i32 [[ADD2]], [[SHL2]]
; CHECK-NEXT:    [[ADD7:%.*]] = add i32 [[ADD3]], [[SHL3]]
; CHECK-NEXT:    [[ADD8:%.*]] = add i32 [[ADD4]], [[LD5]]
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[PRED:%.*]], 0
; CHECK-NEXT:    br i1 [[COND]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[A0:%.*]] = shl i32 [[LD2]], 1
; CHECK-NEXT:    [[B0:%.*]] = shl i32 [[LD3]], 1
; CHECK-NEXT:    [[C0:%.*]] = shl i32 [[LD4]], 1
; CHECK-NEXT:    [[D0:%.*]] = shl i32 [[LD5]], 1
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[A:%.*]] = phi i32 [ [[A0]], [[BB1]] ], [ [[ADD5]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[B:%.*]] = phi i32 [ [[B0]], [[BB1]] ], [ [[ADD6]], [[ENTRY]] ]
; CHECK-NEXT:    [[C:%.*]] = phi i32 [ [[C0]], [[BB1]] ], [ [[ADD7]], [[ENTRY]] ]
; CHECK-NEXT:    [[D:%.*]] = phi i32 [ [[D0]], [[BB1]] ], [ [[ADD8]], [[ENTRY]] ]
; CHECK-NEXT:    [[ID3:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 103
; CHECK-NEXT:    [[ID2:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 102
; CHECK-NEXT:    [[ID1:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 101
; CHECK-NEXT:    [[ID0:%.*]] = getelementptr inbounds i32, i32* [[PTR1]], i64 100
; CHECK-NEXT:    store i32 [[A]], i32* [[ID0]], align 4
; CHECK-NEXT:    store i32 [[B]], i32* [[ID1]], align 4
; CHECK-NEXT:    store i32 [[C]], i32* [[ID2]], align 4
; CHECK-NEXT:    store i32 [[D]], i32* [[ID3]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %gep1 = getelementptr inbounds i32, i32* %ptr1, i64 17
  %i6 = bitcast i32* %gep1 to <4 x i32>*
  %i7 = load <4 x i32>, <4 x i32>* %i6, align 4

  %gep2 = getelementptr inbounds i32, i32* %ptr1, i64 21
  %gep3 = getelementptr inbounds i32, i32* %ptr1, i64 22
  %gep4 = getelementptr inbounds i32, i32* %ptr1, i64 23
  %gep5 = getelementptr inbounds i32, i32* %ptr1, i64 24

  %ld4 = load i32, i32* %gep4, align 4
  %ld5 = load i32, i32* %gep5, align 4
  %ix = extractelement <4 x i32> %i7, i64 3
  %ld2 = load i32, i32* %gep2, align 4
  %ld3 = load i32, i32* %gep3, align 4
  %add1 = add i32 %ld3, %ix
  %shl1 = shl i32 %ld2, 1
  %add2 = add i32 %ld4, %ld2
  %shl2 = shl i32 %ld3, 1
  %add3 = add i32 %ld5, %ld3
  %shl3 = shl i32 %ld4, 1
  %add4 = add i32 %ld4, 2
  %add5 = add i32 %add1, %shl1
  %add6 = add i32 %add2, %shl2
  %add7 = add i32 %add3, %shl3
  %add8 = add i32 %add4, %ld5
  %cond = icmp eq i32 %pred, 0
  br i1 %cond, label %bb1, label %bb2

bb1:                                              ; preds = %entry
  %a0 = shl i32 %ld2, 1
  %b0 = shl i32 %ld3, 1
  %c0 = shl i32 %ld4, 1
  %d0 = shl i32 %ld5, 1
  br label %bb2

bb2:                                              ; preds = %bb1, %entry
  %a = phi i32 [ %a0, %bb1 ], [ %add5, %entry ]
  %b = phi i32 [ %b0, %bb1 ], [ %add6, %entry ]
  %c = phi i32 [ %c0, %bb1 ], [ %add7, %entry ]
  %d = phi i32 [ %d0, %bb1 ], [ %add8, %entry ]
  %id3 = getelementptr inbounds i32, i32* %ptr1, i64 103
  %id2 = getelementptr inbounds i32, i32* %ptr1, i64 102
  %id1 = getelementptr inbounds i32, i32* %ptr1, i64 101
  %id0 = getelementptr inbounds i32, i32* %ptr1, i64 100

  store i32 %a, i32* %id0, align 4
  store i32 %b, i32* %id1, align 4
  store i32 %c, i32* %id2, align 4
  store i32 %d, i32* %id3, align 4
  ret void
}
