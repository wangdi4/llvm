; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Check VPlan vectorizer generates valid vector sincos call given
; the target CPU and ISA restrictions of available vector-variants.

; RUN: opt -S -VPlanDriver -vector-library=SVML -mcpu=core-avx2 -vplan-force-vf=4 < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local void @test() local_unnamed_addr {
; CHECK-LABEL: @test(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i64 [ 0, [[VECTOR_PH:%.*]] ], [ [[TMP2:%.*]], [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VECTOR_PH]] ], [ [[TMP1:%.*]], [[VECTOR_BODY]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr inbounds [128 x float], [128 x float]* [[PHASE:%.*]], i64 0, i64 [[UNI_PHI]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast float* [[SCALAR_GEP]] to <4 x float>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x float>, <4 x float>* [[TMP0]], align 4
; FIXME: This call leads to SEGV on CORE-AVX2 target, since vector-variant's ISA corresponds to
; SSE4.2 and passing arguments on YMM registers is not allowed.
; CHECK-NEXT:    call void @_ZGVbN4vvv_sincosf(<4 x float> [[WIDE_LOAD]], <4 x float*> nonnull [[SINVAL_VEC_BASE_ADDR:%.*]], <4 x float*> nonnull [[COSVAL_VEC_BASE_ADDR:%.*]])
; CHECK-NEXT:    [[TMP1]] = add nuw nsw <4 x i64> [[VEC_PHI]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP2]] = add nuw nsw i64 [[UNI_PHI]], 4
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i64 [[TMP2]], 128
; CHECK-NEXT:    br i1 [[TMP3]], label [[VPLANNEDBB3:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]
;
DIR.OMP.SIMD.1338:
  %phase = alloca [128 x float], align 16
  %sinval = alloca float
  %cosval = alloca float
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %DIR.OMP.SIMD.1338
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE"(float* %cosval), "QUAL.OMP.PRIVATE"(float* %sinval) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %DIR.OMP.SIMD.1, %omp.inner.for.body
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %indvars.iv.next, %omp.inner.for.body ]
  %arrayidx4 = getelementptr inbounds [128 x float], [128 x float]* %phase, i64 0, i64 %indvars.iv
  %phase.ld = load float, float* %arrayidx4, align 4
  call void @sincosf(float %phase.ld, float* nonnull %sinval, float* nonnull %cosval)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 128
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.2, label %omp.inner.for.body

DIR.OMP.END.SIMD.2:                               ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry()

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token)

; Function Attrs: nofree nounwind
declare dso_local void @sincosf(float, float*, float*) local_unnamed_addr #8

attributes #8 = { nofree nounwind "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "frame-pointer"="none" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="core-avx2" "target-features"="+avx,+avx2,+bmi,+bmi2,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+popcnt,+rdrnd,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsaveopt" "unsafe-fp-math"="true" "vector-variants"="_ZGVbN4vvv_sincosf,_ZGVcN8vvv_sincosf,_ZGVdN8vvv_sincosf,_ZGVeN16vvv_sincosf" }
