; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; LLVM IR generated from the following testcase using icx -O1 -S -emit-llvm
; struct S1 {
;   unsigned short a1;
;   unsigned short a2;
;   unsigned short a3;
;   unsigned short a4;
; } *s1p;
;
; double foo(unsigned n, double d)
; {
;   int i1;
;
;   double sum = 0;
;   for (i1 = 0; i1 < n; i1++) {
;     sum +=    s1p[-1 * i1].a3 * d;
;     sum +=    s1p[-1 * i1].a1 * d;
;   }
;
;   return sum;
; }
; RUN: opt -enable-new-pm=0 -vplan-force-vf=4 -hir-ssa-deconstruction -hir-vec-dir-insert -disable-hir-loop-reversal -hir-vplan-vec -print-after=hir-vplan-vec -enable-blob-coeff-vec -enable-nested-blob-vec -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -vplan-force-vf=4 -disable-hir-loop-reversal -enable-blob-coeff-vec -enable-nested-blob-vec -disable-output < %s 2>&1 | FileCheck %s

; It used to be a lit test for performance WA bail out in HIR CG.
; Now it checks that the input code can be vectorized with VF=4.
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.S1 = type { i16, i16, i16, i16 }

@s1p = common local_unnamed_addr global %struct.S1* null, align 8

; Function Attrs: noinline norecurse nounwind readonly uwtable
define double @foo(i32 %n, double %d) local_unnamed_addr #0 {
; CHECK:       Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK-NEXT:        [[TGU0:%.*]] = (sext.i32.i64([[N0:%.*]]))/u4
; CHECK-NEXT:        if (0 <u 4 * [[TGU0]])
; CHECK-NEXT:        {
; CHECK-NEXT:           [[RED_INIT0:%.*]] = 0.000000e+00
; CHECK-NEXT:           [[PHI_TEMP0:%.*]] = [[RED_INIT0]]
;
; CHECK:                + DO i1 = 0, 4 * [[TGU0]] + -1, 4   <DO_LOOP>  <MAX_TC_EST = 536870911>  <LEGAL_MAX_TC = 536870911> <auto-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:           |   [[DOTVEC0:%.*]] = (<4 x i16>*)([[TMP0:%.*]])[-1 * i1 + -1 * <i64 0, i64 1, i64 2, i64 3>].2
; CHECK-NEXT:           |   [[DOTVEC10:%.*]] = uitofp.<4 x i16>.<4 x double>([[DOTVEC0]])
; CHECK-NEXT:           |   [[DOTVEC20:%.*]] = [[DOTVEC10]]  *  [[D0:%.*]]
; CHECK-NEXT:           |   [[DOTVEC30:%.*]] = [[PHI_TEMP0]]  +  [[DOTVEC20]]
; CHECK-NEXT:           |   [[DOTVEC40:%.*]] = (<4 x i16>*)([[TMP0]])[-1 * i1 + -1 * <i64 0, i64 1, i64 2, i64 3>].0
; CHECK-NEXT:           |   [[DOTVEC50:%.*]] = uitofp.<4 x i16>.<4 x double>([[DOTVEC40]])
; CHECK-NEXT:           |   [[DOTVEC60:%.*]] = [[DOTVEC50]]  *  [[D0]]
; CHECK-NEXT:           |   [[DOTVEC70:%.*]] = [[DOTVEC30]]  +  [[DOTVEC60]]
; CHECK-NEXT:           |   [[PHI_TEMP0]] = [[DOTVEC70]]
; CHECK-NEXT:           + END LOOP
;
; CHECK:                [[SUM_0200:%.*]] = @llvm.vector.reduce.fadd.v4f64([[SUM_0200]],  [[DOTVEC70]])
; CHECK-NEXT:        }
;
; CHECK:             + DO i1 = 4 * [[TGU0]], sext.i32.i64([[N0]]) + -1, 1   <DO_LOOP>  <MAX_TC_EST = 3>  <LEGAL_MAX_TC = 3> <nounroll> <novectorize> <max_trip_count = 3>
; CHECK-NEXT:        |   [[TMP2:%.*]] = ([[TMP0]])[-1 * i1].2
; CHECK-NEXT:        |   [[CONV10:%.*]] = uitofp.i16.double([[TMP2]])
; CHECK-NEXT:        |   [[MUL20:%.*]] = [[CONV10]]  *  [[D0]]
; CHECK-NEXT:        |   [[ADD0:%.*]] = [[SUM_0200]]  +  [[MUL20]]
; CHECK-NEXT:        |   [[TMP3:%.*]] = ([[TMP0]])[-1 * i1].0
; CHECK-NEXT:        |   [[CONV70:%.*]] = uitofp.i16.double([[TMP3]])
; CHECK-NEXT:        |   [[MUL80:%.*]] = [[CONV70]]  *  [[D0]]
; CHECK-NEXT:        |   [[SUM_0200]] = [[ADD0]]  +  [[MUL80]]
; CHECK-NEXT:        + END LOOP
; CHECK-NEXT:  END REGION
;
entry:
  %cmp18 = icmp sgt i32 %n, 0
  br i1 %cmp18, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %0 = load %struct.S1*, %struct.S1** @s1p, align 8, !tbaa !0
  %wide.trip.count = sext i32 %n to i64
  br label %for.body

for.body:                                         ; preds = %for.body, %for.body.lr.ph
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %sum.020 = phi double [ 0.000000e+00, %for.body.lr.ph ], [ %add9, %for.body ]
  %1 = sub nsw i64 0, %indvars.iv
  %a3 = getelementptr inbounds %struct.S1, %struct.S1* %0, i64 %1, i32 2
  %2 = load i16, i16* %a3, align 2, !tbaa !4
  %conv1 = uitofp i16 %2 to double
  %mul2 = fmul fast double %conv1, %d
  %add = fadd fast double %sum.020, %mul2
  %a1 = getelementptr inbounds %struct.S1, %struct.S1* %0, i64 %1, i32 0
  %3 = load i16, i16* %a1, align 2, !tbaa !7
  %conv7 = uitofp i16 %3 to double
  %mul8 = fmul fast double %conv7, %d
  %add9 = fadd fast double %add, %mul8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %for.body
  %add9.lcssa = phi double [ %add9, %for.body ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %sum.0.lcssa = phi double [ 0.000000e+00, %entry ], [ %add9.lcssa, %for.end.loopexit ]
  ret double %sum.0.lcssa
}

attributes #0 = { noinline norecurse nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="true" "use-soft-float"="false" }

!0 = !{!1, !1, i64 0}
!1 = !{!"unspecified pointer", !2, i64 0}
!2 = !{!"omnipotent char", !3, i64 0}
!3 = !{!"Simple C/C++ TBAA"}
!4 = !{!5, !6, i64 4}
!5 = !{!"struct@S1", !6, i64 0, !6, i64 2, !6, i64 4, !6, i64 6}
!6 = !{!"short", !2, i64 0}
!7 = !{!5, !6, i64 0}
