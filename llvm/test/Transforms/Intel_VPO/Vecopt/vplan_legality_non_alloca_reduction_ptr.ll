; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt %s -VPlanDriver -vplan-force-vf=2 -disable-output -vplan-entities-dump -vplan-print-after-vpentity-instrs | FileCheck %s

; Verify that legality does not crash on non AllocaInst used in simd-reduction declaration.


define internal void @test_legality_non_alloca(i8** %arr) #3 {
; CHECK-LABEL:  After insertion VPEntities instructions:
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   signed (+) Start: i32 [[ZII_RED_CAST_PROMOTED0:%.*]] Exit: i32 [[VP_ADD4:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP0:%.*]], i32 [[VP_ADD4]], i32* [[VP_ZII_RED_CAST:%.*]], i32 [[VP_ZII_RED_CAST_RED_INIT:%.*]], i32 [[VP1:%.*]], i32 [[VP_ZII_RED_CAST_RED_FINAL:%.*]],
; CHECK-NEXT:   Memory: i32* [[ZII_RED_CAST0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i32 0 Step: i32 1 BinOp: i32 [[VP_INDVARS_IV_NEXT:%.*]] = add i32 [[VP_INDVARS_IV:%.*]] i32 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP_INDVARS_IV]], i32 [[VP_INDVARS_IV_NEXT]], i32 [[VP_INDVARS_IV_IND_INIT:%.*]], i32 [[VP_INDVARS_IV_IND_FINAL:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    SUCCESSORS(1):[[BB2:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]:
; CHECK-NEXT:     i32* [[VP_ZII_RED_CAST]] = allocate-priv i32*
; CHECK-NEXT:     i32 [[VP_ZII_RED_CAST_RED_INIT]] = reduction-init i32 0 i32 [[ZII_RED_CAST_PROMOTED0]]
; CHECK-NEXT:     store i32 [[VP_ZII_RED_CAST_RED_INIT]] i32* [[VP_ZII_RED_CAST]]
; CHECK-NEXT:     i32 [[VP_INDVARS_IV_IND_INIT]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_INDVARS_IV_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB0]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]:
; CHECK-NEXT:     i32 [[VP_INDVARS_IV]] = phi  [ i32 [[VP_INDVARS_IV_NEXT]], [[BB0]] ],  [ i32 [[VP_INDVARS_IV_IND_INIT]], [[BB2]] ]
; CHECK-NEXT:     i32 [[VP0]] = phi  [ i32 [[VP_ADD4]], [[BB0]] ],  [ i32 [[VP_ZII_RED_CAST_RED_INIT]], [[BB2]] ]
; CHECK-NEXT:     i32 [[VP_ADD4]] = add i32 [[VP_INDVARS_IV]] i32 [[VP0]]
; CHECK-NEXT:     i32 [[VP_INDVARS_IV_NEXT]] = add i32 [[VP_INDVARS_IV]] i32 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP_CMP:%.*]] = icmp i32 1024 i32 [[VP_INDVARS_IV_NEXT]]
; CHECK-NEXT:    SUCCESSORS(2):[[BB3:BB[0-9]+]](i1 [[VP_CMP]]), [[BB0]](!i1 [[VP_CMP]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB0]] [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     i32 [[VP_ZII_RED_CAST_RED_FINAL]] = reduction-final{u_add} i32 [[VP_ADD4]]
; CHECK-NEXT:     store i32 [[VP_ZII_RED_CAST_RED_FINAL]] i32* [[ZII_RED_CAST0]]
; CHECK-NEXT:     i32 [[VP_INDVARS_IV_IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB4:BB[0-9]+]]
; CHECK-NEXT:    PREDECESSORS(1): [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]:
; CHECK-NEXT:     <Empty Block>
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:    [[ADD4_LCSSA0:%.*]] = phi i32 [ [[ADD40:%.*]], [[OMP_INNER_FOR_BODY0:%.*]] ]i32 [[VP_ZII_RED_CAST_RED_FINAL]] -> i32 [[ADD40]]
;
DIR.OMP.SIMD.4:
  %zii.shr3 = load i8*, i8** %arr, align 8
  %zii.red = tail call i8* @bar(i8* %zii.shr3) #2
  %zii.red.cast = bitcast i8* %zii.red to i32*
  br label %omp.inner.for.body.lr.ph

DIR.OMP.END.TASKLOOP.8.exitStub:                  ; preds = %DIR.OMP.SIMD.4, %DIR.OMP.END.SIMD.2
  ret void

omp.inner.for.body.lr.ph:                         ; preds = %DIR.OMP.SIMD.4
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(i32* %zii.red.cast) ]
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %omp.inner.for.body.lr.ph
  %zii.red.cast.promoted = load i32, i32* %zii.red.cast, align 4
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.1
  %indvars.iv = phi i32 [ %indvars.iv.next, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.1 ]
  %1 = phi i32 [ %add4, %omp.inner.for.body ], [ %zii.red.cast.promoted, %DIR.OMP.SIMD.1 ]
  %add4 = add nsw i32 %indvars.iv, %1
  %indvars.iv.next = add i32 %indvars.iv, 1
  %cmp = icmp ult i32 1024, %indvars.iv.next
  br i1 %cmp, label %omp.inner.for.cond.omp.loop.exit.split_crit_edge, label %omp.inner.for.body

omp.inner.for.cond.omp.loop.exit.split_crit_edge: ; preds = %omp.inner.for.body
  %add4.lcssa = phi i32 [ %add4, %omp.inner.for.body ]
  store i32 %add4.lcssa, i32* %zii.red.cast, align 4
  br label %DIR.OMP.END.SIMD.2

DIR.OMP.END.SIMD.2:                               ; preds = %omp.inner.for.cond.omp.loop.exit.split_crit_edge
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.TASKLOOP.8.exitStub
}

declare token @llvm.directive.region.entry() nounwind
declare void @llvm.directive.region.exit(token) nounwind
declare i8* @bar(i8*)
