; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Check scalar live-in/out descriptor creation for HIR input.
; Both reduction and induction are live out.
; RUN: opt -opaque-pointers=0 -passes=hir-ssa-deconstruction,hir-vplan-vec -vplan-print-after-live-inout-list -vplan-dump-live-inout -vplan-entities-dump -disable-output < %s 2>&1 | FileCheck %s

;int foo(int *A, int N, int Init) {
;  int Sum = Init;
;  int i;
;#pragma opt simd
;  for (i = 0; i<N; i++)
;    Sum+= A[i];
;  return Sum + i;
;}

; Input HIR
; BEGIN REGION { }
;       %tok = @llvm.directive.region.entry(); [ DIR.OMP.SIMD() ]
;       %Sum.0.lcssa = %Init;
;       %ind.0.lcssa = 0;
;
;          %Sum.07 = %Init;
;       + DO i1 = 0, zext.i32.i64(%N) + -1, 1   <DO_LOOP>  <MAX_TC_EST = 2147483647> <simd>
;       |   %A.i = (%A)[i1];
;       |   %Sum.07 = %A.i  +  %Sum.07;
;       |   %indvars.iv.next = i1  +  1;
;       + END LOOP
;          %Sum.0.lcssa = %Sum.07;
;          %ind.0.lcssa = %indvars.iv.next;
;
;       @llvm.directive.region.exit(%tok); [ DIR.OMP.END.SIMD() ]
; END REGION


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define i32 @foo(i32* nocapture readonly %A, i32 %N, i32 %Init) {
; CHECK-LABEL:  VPlan after live in/out lists creation:
; CHECK-NEXT:  VPlan IR for: foo:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%Sum.07}
; CHECK-DAG:     [[VP1:%.*]] = {%A}
; CHECK-DAG:     [[VP2:%.*]] = {%indvars.iv.next}
; CHECK-DAG:     [[VP3:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:  Live-in values:
; CHECK-NEXT:  ID: 0 Value: i32 [[SUM_070:%.*]]
; CHECK-NEXT:  ID: 1 Value: i64 undef
; CHECK-NEXT:  ID: 2 Value: i64 0
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   (+) Start: i32 [[SUM_070]] Exit: i32 [[VP4:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP5:%.*]], i32 [[VP4]], i32 [[VP_RED_INIT:%.*]], i32 [[VP_RED_FINAL:%.*]],
; CHECK:       Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: ? BinOp: i64 [[VP6:%.*]] = add i64 [[VP7:%.*]] i64 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP7]], i64 [[VP6]], i64 [[VP__IND_INIT:%.*]], i64 [[VP__IND_INIT_STEP]], i64 [[VP__IND_FINAL:%.*]],
; CHECK:       Private list
; CHECK-EMPTY:
; CHECK-NEXT:    Exit instr: i64 [[VP8:%.*]] = add i64 [[VP7]] i64 1
; CHECK-NEXT:    Linked values: i64 [[VP8]], i64 [[VP__PRIV_FINAL:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i64 [[VP9:%.*]] = add i64 [[VP3]] i64 1
; CHECK-NEXT:     i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 [[VP9]], UF = 1
; CHECK-NEXT:     i32 [[VP_RED_INIT]] = reduction-init i32 0 i32 live-in0
; CHECK-NEXT:     i64 [[VP__IND_INIT]] = induction-init{add} i64 live-in2 i64 1
; CHECK-NEXT:     i64 [[VP__IND_INIT_STEP]] = induction-init-step{add} i64 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB0]]
; CHECK-NEXT:     i32 [[VP5]] = phi  [ i32 [[VP_RED_INIT]], [[BB2]] ],  [ i32 [[VP4]], [[BB0]] ]
; CHECK-NEXT:     i64 [[VP7]] = phi  [ i64 [[VP__IND_INIT]], [[BB2]] ],  [ i64 [[VP6]], [[BB0]] ]
; CHECK-NEXT:     i32* [[VP_SUBSCRIPT:%.*]] = subscript inbounds i32* [[A0:%.*]] i64 [[VP7]]
; CHECK-NEXT:     i32 [[VP_LOAD:%.*]] = load i32* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     i32 [[VP4]] = add i32 [[VP_LOAD]] i32 [[VP5]]
; CHECK-NEXT:     i64 [[VP8]] = add i64 [[VP7]] i64 1
; CHECK-NEXT:     i64 [[VP6]] = add i64 [[VP7]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP10:%.*]] = icmp slt i64 [[VP6]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     br i1 [[VP10]], [[BB0]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     i32 [[VP_RED_FINAL]] = reduction-final{u_add} i32 [[VP4]]
; CHECK-NEXT:     i64 [[VP__IND_FINAL]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     i64 [[VP__PRIV_FINAL]] = private-final-uc i64 [[VP8]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  Live-out values:
; CHECK-NEXT:  live-out0(i32 [[VP_RED_FINAL]])
; CHECK-NEXT:  live-out1(i64 [[VP__PRIV_FINAL]])
; CHECK-NEXT:  live-out2(i64 [[VP__IND_FINAL]])
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   i32 [[VP_RED_FINAL]] -> [[VP11:%.*]] = {%Sum.07}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1   i64 [[VP__PRIV_FINAL]] -> [[VP12:%.*]] = {%indvars.iv.next}
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 2   no underlying for i64 [[VP__IND_FINAL]]
; CHECK-EMPTY:
; CHECK-NEXT:  Original loop live-ins/live-outs:
; CHECK-NEXT:    Id: 2
; CHECK-NEXT:      HIR Temp: zext.i32.i64([[N0:%.*]]) + -1    IsMainLoopIV: 1
; CHECK-NEXT:    Id: 0
; CHECK-NEXT:      HIR Temp: [[SUM_070]]    IsMainLoopIV: 0
; CHECK-NEXT:    Id: 1
; CHECK-NEXT:      HIR Temp: [[INDVARS_IV_NEXT0:%.*]]    IsMainLoopIV: 0
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %DIR.QUAL.LIST.END.2

DIR.QUAL.LIST.END.2:
  %cmp6 = icmp sgt i32 %N, 0
  br i1 %cmp6, label %for.body.ph, label %for.cond.cleanup

for.body.ph:                                 ; preds = %0
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.body:                                           ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.ph ]
  %Sum.07 = phi i32 [ %add, %for.body ], [ %Init, %for.body.ph ]
  %arrayidx = getelementptr inbounds i32, i32* %A, i64 %indvars.iv
  %A.i = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %A.i, %Sum.07
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body

for.cond.cleanup.loopexit:                             ; preds = %for.body
  %add.lcssa = phi i32 [ %add, %for.body ]
  %ind.lcssa = phi i64 [ %indvars.iv.next, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                      ; preds = %for.cond.cleanup.loopexit, %0
  %Sum.0.lcssa = phi i32 [ %Init, %DIR.QUAL.LIST.END.2 ], [ %add.lcssa, %for.cond.cleanup.loopexit ]
  %ind.0.lcssa = phi i64 [ 0, %DIR.QUAL.LIST.END.2 ], [ %ind.lcssa, %for.cond.cleanup.loopexit ]
  br label %end.simd

end.simd:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  %ind32 = trunc i64 %ind.0.lcssa to i32
  %s = add i32 %Sum.0.lcssa, %ind32
  br label %DIR.QUAL.LIST.END.3

DIR.QUAL.LIST.END.3:
  ret i32 %s

}
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
