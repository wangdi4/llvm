; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -enable-new-pm=0 -hir-ssa-deconstruction -hir-temp-cleanup -hir-vec-dir-insert -hir-vplan-vec -vplan-enable-masked-vectorized-remainder -disable-output -hir-details -print-after=hir-vplan-vec -vplan-force-vf=8 -vplan-enable-peel-rem-strip=0 %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-temp-cleanup,hir-vec-dir-insert,hir-vplan-vec" -vplan-enable-masked-vectorized-remainder -disable-output -hir-details -print-after=hir-vplan-vec -vplan-force-vf=8 -vplan-enable-peel-rem-strip=0 %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Test to check we correctly adjust upper bound of the masked mode loop.
; Incoming HIR
; BEGIN REGION { }
;  + DO i1 = 0, 0, 1   <DO_LOOP>
;  |   %"val$[]671_fetch.1074" = (%p1)[0];
;  |   %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
;  |
;  |   + DO i2 = 0, -1 * %"val$[]671_fetch.1074" + %N + -1, 1   <DO_LOOP>
;  |   |   (bitcast ([16 x i8]* @mbc_int_ to i64*))[undef + -1] = %N;
;  |   + END LOOP
;  |
;  |   @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
;  + END LOOP
; END REGION


@mbc_int_ = external unnamed_addr global [16 x i8], align 32

; Function Attrs: nounwind readnone speculatable
declare i64* @llvm.intel.subscript.p0i64.i64.i64.p0i64.i64(i8, i64, i64, i64*, i64) #0

define void @bas_geobas_build_(i1 %c1, i64* %p1, i64 %N) local_unnamed_addr #1 {
; CHECK-LABEL:  Function: bas_geobas_build_
; Main loop
; CHECK:             |   + DO i64 i2 = 0, [[LOOP_UB0:%.*]], 8   <DO_LOOP> <auto-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:        |   | <RVAL-REG> LINEAR i64 %loop.ub{def@1} {sb:21}
; skipping body
; CHECK:             |   + END LOOP
;
; CHECK:             |   [[IND_FINAL0:%.*]] = 0 + [[TMP0:%.*]]
; CHECK:             |   + DO i64 i2 = [[PHI_TEMP0:%.*]], [[LOOP_UB90:%.*]], 8   <DO_LOOP>  <MAX_TC_EST = 1>  <LEGAL_MAX_TC = 1> <vector-remainder> <nounroll> <novectorize> <max_trip_count = 1>
; CHECK-NEXT:        |   | <RVAL-REG> LINEAR i64 %phi.temp{def@1} {sb:17}
; CHECK-NEXT:        |   | <RVAL-REG> LINEAR i64 %loop.ub9{def@1} {sb:29}
; skipping body
; CHECK:             |   + END LOOP
;
alloca_11:
  br i1 %c1, label %bb_new2009_then, label %bb400_endif

bb_new2009_then:                                  ; preds = %alloca_11
  unreachable

bb400_endif:                                      ; preds = %alloca_11
  br label %bb433

bb433:                                            ; preds = %bb442_endif, %bb400_endif
  %"val$[]671_fetch.1074" = load i64, i64* %p1, align 8
  br label %bb437

bb437:                                            ; preds = %bb437, %bb433
  %add.1411544 = phi i64 [ %"val$[]671_fetch.1074", %bb433 ], [ %add.141, %bb437 ]
  %"val$[]675" = call i64* @llvm.intel.subscript.p0i64.i64.i64.p0i64.i64(i8 0, i64 1, i64 8, i64* elementtype(i64) bitcast ([16 x i8]* @mbc_int_ to i64*), i64 undef)
  store i64 %N, i64* %"val$[]675", align 8
  %add.141 = add i64 %add.1411544, 1
  %exitcond1552.not = icmp eq i64 %add.141, %N
  br i1 %exitcond1552.not, label %bb442_endif, label %bb437

bb442_endif:                                      ; preds = %bb437
  %exitcond1553 = icmp eq i64 undef, undef
  br i1 %exitcond1553, label %bb434.loopexit, label %bb433

bb434.loopexit:                                   ; preds = %bb442_endif
  ret void
}

attributes #0 = { nounwind readnone speculatable }
attributes #1 = { "target-features"="+adx,+aes,+avx,+avx2,+avx512bw,+avx512cd,+avx512dq,+avx512f,+avx512vl,+bmi,+bmi2,+clflushopt,+clwb,+crc32,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+pclmul,+pku,+popcnt,+prfchw,+rdrnd,+rdseed,+sahf,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave,+xsavec,+xsaveopt,+xsaves" }

!omp_offload.info = !{}
