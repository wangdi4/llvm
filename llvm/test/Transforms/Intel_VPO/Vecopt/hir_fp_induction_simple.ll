; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to verify VPlan's support for FP inductions that are auto-
; recognized by LoopOpt framework.

; HIR before vectorizer -
;  BEGIN REGION { }
;        %entry.region = @llvm.directive.region.entry(); [ DIR.VPO.AUTO.VEC() ]
;
;        + DO i1 = 0, zext.i32.i64(%N) + -1, 1   <DO_LOOP>  <MAX_TC_EST = 2147483647>  <LEGAL_MAX_TC = 2147483647>
;        |   %r.014 = %r.014  +  1.000000e+00;
;        |   %0 = (%A)[i1];
;        |   %mul = %r.014  *  %r.014;
;        |   %mul2 = %mul  *  %0;
;        |   %sum.013 = %mul2  +  %sum.013; <Safe Reduction>
;        + END LOOP
;
;        @llvm.directive.region.exit(%entry.region); [ DIR.VPO.END.AUTO.VEC() ]
;  END REGION

; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-print-after-vpentity-instrs -vplan-entities-dump -print-after=hir-vplan-vec -disable-output < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind readonly willreturn uwtable
define dso_local noundef float @_Z3subPfi(float* nocapture noundef readonly %A, i32 noundef %N) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK-NEXT:  VPlan IR for: _Z3subPfi:HIR.#{{[0-9]+}}
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%sum.013}
; CHECK-DAG:     [[VP1:%.*]] = {zext.i32.i64(%N) + -1}
; CHECK-DAG:     [[VP2:%.*]] = {%A}
; CHECK-DAG:     [[VP3:%.*]] = {%r.014}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   (+) Start: float [[SUM_0130:%.*]] Exit: float [[VP4:%.*]]
; CHECK-NEXT:    Linked values: float [[VP5:%.*]], float [[VP4]], float [[VP_RED_INIT:%.*]], float [[VP_RED_FINAL:%.*]],
; CHECK:       Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: ? BinOp: i64 [[VP6:%.*]] = add i64 [[VP7:%.*]] i64 [[VP__IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP7]], i64 [[VP6]], i64 [[VP__IND_INIT:%.*]], i64 [[VP__IND_INIT_STEP]], i64 [[VP__IND_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK-NEXT:   FpInduction(+) Start: float [[R_0140:%.*]] Step: float 1.000000e+00 StartVal: ? EndVal: ? BinOp: float [[VP8:%.*]] = fadd float [[VP9:%.*]] float 1.000000e+00 need close form
; CHECK-NEXT:    Linked values: float [[VP9]], float [[VP8]], float [[VP__IND_INIT_1:%.*]], float [[VP__IND_INIT_STEP_1:%.*]], float [[VP10:%.*]], float [[VP__IND_FINAL_1:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     i64 [[VP11:%.*]] = add i64 [[VP1]] i64 1
; CHECK-NEXT:     float [[VP_RED_INIT]] = reduction-init float 0.000000e+00
; CHECK-NEXT:     i64 [[VP__IND_INIT]] = induction-init{add} i64 0 i64 1
; CHECK-NEXT:     i64 [[VP__IND_INIT_STEP]] = induction-init-step{add} i64 1
; CHECK-NEXT:     float [[VP__IND_INIT_1]] = induction-init{fadd} float [[R_0140]] float 1.000000e+00
; CHECK-NEXT:     float [[VP__IND_INIT_STEP_1]] = induction-init-step{fadd} float 1.000000e+00
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB0]]
; CHECK-NEXT:     float [[VP5]] = phi  [ float [[VP_RED_INIT]], [[BB2]] ],  [ float [[VP4]], [[BB0]] ]
; CHECK-NEXT:     float [[VP9]] = phi  [ float [[VP__IND_INIT_1]], [[BB2]] ],  [ float [[VP10]], [[BB0]] ]
; CHECK-NEXT:     i64 [[VP7]] = phi  [ i64 [[VP__IND_INIT]], [[BB2]] ],  [ i64 [[VP6]], [[BB0]] ]
; CHECK-NEXT:     float [[VP10]] = fadd float [[VP9]] float [[VP__IND_INIT_STEP_1]]
; CHECK-NEXT:     float [[VP8]] = fadd float [[VP9]] float 1.000000e+00
; CHECK-NEXT:     float* [[VP_SUBSCRIPT:%.*]] = subscript inbounds float* [[A0:%.*]] i64 [[VP7]]
; CHECK-NEXT:     float [[VP_LOAD:%.*]] = load float* [[VP_SUBSCRIPT]]
; CHECK-NEXT:     float [[VP12:%.*]] = fmul float [[VP8]] float [[VP8]]
; CHECK-NEXT:     float [[VP13:%.*]] = fmul float [[VP12]] float [[VP_LOAD]]
; CHECK-NEXT:     float [[VP4]] = fadd float [[VP13]] float [[VP5]]
; CHECK-NEXT:     i64 [[VP6]] = add i64 [[VP7]] i64 [[VP__IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP14:%.*]] = icmp slt i64 [[VP6]] i64 [[VP11]]
; CHECK-NEXT:     br i1 [[VP14]], [[BB0]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     float [[VP_RED_FINAL]] = reduction-final{fadd} float [[VP4]] float [[SUM_0130]]
; CHECK-NEXT:     i64 [[VP__IND_FINAL]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     float [[VP__IND_FINAL_1]] = induction-final{fadd} float [[R_0140]] float 1.000000e+00
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   float [[VP_RED_FINAL]] -> [[VP15:%.*]] = {%sum.013}
; CHECK-EMPTY:
; CHECK-NEXT:  *** IR Dump After vpo::VPlanDriverHIRPass ***
; CHECK-NEXT:  Function: _Z3subPfi
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK:             %red.init = 0.000000e+00;
; CHECK-NEXT:        %ind.vec.step = 1.000000e+00  *  <float 0.000000e+00, float 1.000000e+00, float 2.000000e+00, float 3.000000e+00>;
; CHECK-NEXT:        %0 = %r.014  +  %ind.vec.step;
; CHECK-NEXT:        %ind.step.init = 1.000000e+00  *  4.000000e+00;
; CHECK-NEXT:        %phi.temp7 = %red.init;
; CHECK-NEXT:        %phi.temp9 = %0;
; CHECK-NEXT:        %loop.ub = %vec.tc6  -  1;

; CHECK:             + DO i1 = 0, %loop.ub, 4   <DO_LOOP>  <MAX_TC_EST = 536870911>  <LEGAL_MAX_TC = 536870911> <auto-vectorized> <nounroll> <novectorize>
; CHECK-NEXT:        |   %.vec11 = %phi.temp9  +  %ind.step.init;
; CHECK-NEXT:        |   %.vec12 = %phi.temp9  +  1.000000e+00;
; CHECK-NEXT:        |   %.vec13 = (<4 x float>*)(%A)[i1];
; CHECK-NEXT:        |   %.vec14 = %.vec12  *  %.vec12;
; CHECK-NEXT:        |   %.vec15 = %.vec14  *  %.vec13;
; CHECK-NEXT:        |   %.vec16 = %.vec15  +  %phi.temp7;
; CHECK-NEXT:        |   %phi.temp7 = %.vec16;
; CHECK-NEXT:        |   %phi.temp9 = %.vec11;
; CHECK-NEXT:        + END LOOP

; CHECK:             %sum.013 = @llvm.vector.reduce.fadd.v4f32(%sum.013,  %.vec16);
; CHECK-NEXT:        %ind.final = 0  +  %vec.tc6;
; CHECK-NEXT:        %cast.crd = sitofp.i64.float(%vec.tc6);
; CHECK-NEXT:        %1 = 1.000000e+00  *  %cast.crd;
; CHECK-NEXT:        %r.014 = %r.014  +  %1;
; CHECK:       END REGION
;
entry:
  %cmp12 = icmp sgt i32 %N, 0
  br i1 %cmp12, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %N to i64
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  %add3.lcssa = phi float [ %add3, %for.body ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sum.0.lcssa = phi float [ 0.000000e+00, %entry ], [ %add3.lcssa, %for.cond.cleanup.loopexit ]
  ret float %sum.0.lcssa

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %r.014 = phi float [ -1.000000e+00, %for.body.preheader ], [ %conv1, %for.body ]
  %sum.013 = phi float [ 0.000000e+00, %for.body.preheader ], [ %add3, %for.body ]
  %conv1 = fadd fast float %r.014, 1.000000e+00
  %arrayidx = getelementptr inbounds float, float* %A, i64 %indvars.iv
  %0 = load float, float* %arrayidx, align 4
  %mul = fmul fast float %conv1, %conv1
  %mul2 = fmul fast float %mul, %0
  %add3 = fadd fast float %mul2, %sum.013
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body
}
