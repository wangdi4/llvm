; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -vplan-vec -S -vplan-vec-scenario="n1;v16;m16" -vplan-print-after-vpentity-instrs -vplan-print-after-create-masked-vplan -vplan-enable-masked-variant -vplan-print-after-final-cond-transform < %s 2>&1 | FileCheck %s
; RUN: opt -passes="vplan-vec" -S -vplan-vec-scenario="n1;v16;m16" -vplan-print-after-vpentity-instrs -vplan-print-after-create-masked-vplan -vplan-enable-masked-variant -vplan-print-after-final-cond-transform < %s 2>&1 | FileCheck %s

; RUN: opt -disable-output -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -print-after=hir-vplan-vec -vplan-vec-scenario="n1;v16;m16" -vplan-print-after-vpentity-instrs -vplan-print-after-create-masked-vplan -vplan-enable-masked-variant-hir -vplan-print-after-final-cond-transform < %s 2>&1 | FileCheck %s --check-prefix=HIR
; RUN: opt -disable-output -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -vplan-vec-scenario="n1;v16;m16" -vplan-print-after-vpentity-instrs -vplan-print-after-create-masked-vplan -vplan-enable-masked-variant-hir -vplan-print-after-final-cond-transform < %s 2>&1 | FileCheck %s --check-prefix=HIR

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"


define i32 @main() {
; CHECK-LABEL:  VPlan after insertion of VPEntities instructions:
; CHECK:          i32* [[VP_X:%.*]] = allocate-priv i32*, OrigAlign = 4
;
; CHECK:          i32 [[VP_XV:%.*]] = add i32 [[VP_IV:%.*]] i32 1
; CHECK-NEXT:     store i32 [[VP_XV]] i32* [[VP_X]]
;
; CHECK:          i32 [[VP_LOAD:%.*]] = load i32* [[VP_X]]
; CHECK-NEXT:     i32 [[VP_LOADED_PRIV_FINAL:%.*]] = private-final-uc-mem i32 [[VP_LOAD]]
; CHECK-NEXT:     store i32 [[VP_LOADED_PRIV_FINAL]] i32* [[X0:%.*]]
;
; CHECK-LABEL: VPlan after emitting masked variant:
; CHECK:          [DA: Div] i32* [[VP0:%.*]] = allocate-priv i32*, OrigAlign = 4
; CHECK:          [DA: Div] i32 [[VP_IV_1:%.*]] = phi  [ i32 [[VP1:%.*]], [[BB7:BB[0-9]+]] ],  [ i32 [[VP_IV_NEXT_1:%.*]], new_latch ]
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = icmp ult i32 [[VP_IV_1]] i32 128
; CHECK-NEXT:     [DA: Div] br i1 [[VP3]], [[BB9:BB[0-9]+]], new_latch
;
; CHECK:            [DA: Div] i32 [[VP_XV_1:%.*]] = add i32 [[VP_IV_1]] i32 1
; CHECK-NEXT:       [DA: Div] store i32 [[VP_XV_1]] i32* [[VP0]]
;
; CHECK:         new_latch:
; CHECK-NEXT:     [DA: Div] i32 [[VP_IV_NEXT_1:%.*]] = add i32 [[VP_IV_1:.*]] i32 [[VP2:%.*]]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = icmp ult i32 [[VP_IV_NEXT_1]] i32 128
; CHECK-NEXT:     [DA: Uni] i1 [[VP5:%.*]] = all-zero-check i1 [[VP4]]
;
; CHECK:         [[BB11:BB[0-9]+]]: # preds: new_latch
; CHECK-NEXT:     [DA: Uni] i32 [[VP6:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Div] i32 [[VP7:%.*]] = load i32* [[VP0:.*]]
; CHECK-NEXT:     [DA: Uni] i32 [[VP8:%.*]] = private-final-masked-mem i32 [[VP7]] i1 [[VP3]]
; CHECK-NEXT:     [DA: Uni] store i32 [[VP8]] i32* [[X0]]
;
; CHECK-LABEL: VPlan after private finalization instructions transformation:
; CHECK:           [[BB11]]: # preds: new_latch
; CHECK-NEXT:       [DA: Uni] i32 [[VP6]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:       [DA: Div] i32 [[VP7]] = load i32* [[VP0]]
; CHECK-NEXT:       [DA: Uni] i1 [[VP13:%.*]] = all-zero-check i1 [[VP3]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP13]], [[BB14:BB[0-9]+]], [[BB15:BB[0-9]+]]
;
; CHECK:             [[BB15]]: # preds: [[BB11]]
; CHECK-NEXT:         [DA: Uni] i32 [[VP8]] = private-final-masked-mem i32 [[VP7]] i1 [[VP3]]
; CHECK-NEXT:         [DA: Uni] store i32 [[VP8]] i32* [[X0]]
; CHECK-NEXT:         [DA: Uni] br [[BB14]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB14]]: # preds: [[BB15]], [[BB11]]
; CHECK-NEXT:       [DA: Div] i8* [[VP0_BCAST:%.*]] = bitcast i32* [[VP0]]
; CHECK-NEXT:       [DA: Div] call i64 4 i8* [[VP0_BCAST]] void (i64, i8*)* @llvm.lifetime.end.p0i8
; CHECK-NEXT:       [DA: Uni] br [[BB12:BB[0-9]+]]
;================ generated code
; CHECK:  define i32 @main() {
; CHECK:       VPlannedBB16:
; CHECK-NEXT:    [[WIDE_LOAD170:%.*]] = load <16 x i32>, <16 x i32>* [[DOTVEC0:%.*]], align 1
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast <16 x i1> [[TMP5:%.*]] to i16
; CHECK-NEXT:    [[TMP13:%.*]] = icmp eq i16 [[TMP12]], 0
; CHECK-NEXT:    br i1 [[TMP13]], label [[VPLANNEDBB180:%.*]], label [[VPLANNEDBB190:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB19:
; CHECK-NEXT:    [[TMP14:%.*]] = bitcast <16 x i1> [[TMP5]] to i16
; CHECK-NEXT:    [[CTLZ0:%.*]] = call i16 @llvm.ctlz.i16(i16 [[TMP14]], i1 true)
; CHECK-NEXT:    [[TMP15:%.*]] = sub i16 15, [[CTLZ0]]
; CHECK-NEXT:    [[PRIV_EXTRACT0:%.*]] = extractelement <16 x i32> [[WIDE_LOAD170]], i16 [[TMP15]]
; CHECK-NEXT:    store i32 [[PRIV_EXTRACT0]], i32* [[X0]], align 1
; CHECK-NEXT:    br label [[VPLANNEDBB180]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB18:
; CHECK-NEXT:    [[VEC_BCAST:%.*]] = bitcast <16 x i32>* [[VEC:%.*]] to i8*
; CHECK-NEXT:    call void @llvm.lifetime.end.p0i8(i64 64, i8* [[VEC_BCAST]])
; CHECK-NEXT:    br label [[VPLANNEDBB200:%.*]]
;
; HIR-LABEL:  VPlan after insertion of VPEntities instructions
; HIR:          i32 [[VP_LOAD:%.*]] = load i32* [[VP_X:%.*]]
; HIR-NEXT:     i32 [[VP_LOADED_PRIV_FINAL:%.*]] = private-final-uc-mem i32 [[VP_LOAD]]
; HIR-NEXT:     store i32 [[VP_LOADED_PRIV_FINAL]] i32* [[X0:%.*]]
;
; HIR:       VPlan after emitting masked variant
; HIR-NEXT:  VPlan IR for: main:HIR.#{{[0-9]+}}.cloned.masked
; HIR:          [DA: Div] i32* [[VP5:%.*]] = allocate-priv i32*, OrigAlign = 4
; HIR:            [DA: Div] store i32 [[VP11:%.*]] i32* [[VP5]]
; HIR:          [DA: Div] i32 [[VP15:%.*]] = load i32* [[VP5]]
; HIR-NEXT:     [DA: Uni] i32 [[VP16:%.*]] = private-final-masked-mem i32 [[VP15]] i1 [[VP10:%.*]]
; HIR-NEXT:     [DA: Uni] store i32 [[VP16]] i32* [[X0]]
;
; HIR:       VPlan after private finalization instructions transformation
; HIR:            [DA: Div] i32* [[VP_X]] = allocate-priv i32*, OrigAlign = 4
; HIR:            [DA: Div] i32 [[VP_LOAD:%.*]] = load i32* [[VP_X]]
; HIR-NEXT:       [DA: Uni] i32 [[VP_LOADED_PRIV_FINAL]] = private-final-uc-mem i32 [[VP_LOAD]]
; HIR-NEXT:       [DA: Uni] store i32 [[VP_LOADED_PRIV_FINAL]] i32* [[X0]]
;
; HIR:            [DA: Div] i32* [[VP5]] = allocate-priv i32*, OrigAlign = 4
;
; HIR:           [[BB7:BB[0-9]+]]: # preds: [[BB6:BB[0-9]+]], new_latch
; HIR-NEXT:       [DA: Div] i32 [[VP8:%.*]] = phi  [ i32 [[VP6:%.*]], [[BB6]] ],  [ i32 [[VP9:%.*]], new_latch ]
; HIR-NEXT:       [DA: Div] i1 [[VP10]] = icmp ult i32 [[VP8:%.*]] i32 128
;
; HIR:            [DA: Div] i1 [[VP19:%.*]] = block-predicate i1 [[VP10]]
; HIR-NEXT:       [DA: Div] i32 [[VP11]] = add i32 [[VP8]] i32 1
; HIR-NEXT:       [DA: Div] store i32 [[VP11]] i32* [[VP5]]
; HIR-NEXT:       [DA: Uni] br new_latch
;
; HIR:           new_latch:
; HIR-NEXT:       [DA: Div] i32 [[VP9]] = add i32 [[VP8]] i32 [[VP7:%.*]]
; HIR-NEXT:       [DA: Div] i1 [[VP12:%.*]] = icmp ult i32 [[VP9]] i32 128
; HIR-NEXT:       [DA: Uni] i1 [[VP13:%.*]] = all-zero-check i1 [[VP12]]
; HIR-NEXT:       [DA: Uni] br i1 [[VP13]], [[BB9:BB[0-9]+]], [[BB7]]
;
; HIR:           [[BB9]]: # preds: new_latch
; HIR-NEXT:       [DA: Uni] i32 [[VP14:%.*]] = induction-final{add} i32 0 i32 1
; HIR-NEXT:       [DA: Div] i32 [[VP15]] = load i32* [[VP5]]
; HIR-NEXT:       [DA: Uni] i1 [[VP20:%.*]] = all-zero-check i1 [[VP10]]
; HIR-NEXT:       [DA: Uni] br i1 [[VP20]], [[BB12:BB[0-9]+]], [[BB13:BB[0-9]+]]
; 
; HIR:             [[BB13]]: # preds: [[BB9]]
; HIR-NEXT:         [DA: Uni] i32 [[VP16]] = private-final-masked-mem i32 [[VP15]] i1 [[VP10]]
; HIR-NEXT:         [DA: Uni] store i32 [[VP16]] i32* [[X0]]
; HIR-NEXT:         [DA: Uni] br [[BB12]]
;
; HIR-LABEL: Function: main
; HIR-EMPTY:
; HIR:       BEGIN REGION { modified }
; HIR:             [[DOTVEC20:%.*]] = (<16 x i32>*)([[PRIV_MEM0:%.*]])[0]
; HIR-NEXT:        [[EXTRACTED_PRIV0:%.*]] = extractelement [[DOTVEC20]],  15
; HIR-NEXT:        ([[X0]])[0] = [[EXTRACTED_PRIV0]]
;
; HIR:             + DO i1 = [[PHI_TEMP0:%.*]], 127, 16   <DO_LOOP> <vector-remainder> <nounroll> <novectorize>
; HIR-NEXT:        |   [[DOTVEC100:%.*]] = i1 + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> <u 128
; HIR-NEXT:        |   (<16 x i32>*)([[PRIV_MEM80:%.*]])[0] = i1 + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> + 1, Mask = @{[[DOTVEC100]]}
; HIR-NEXT:        |   [[DOTVEC110:%.*]] = i1 + <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15> + 16 <u 128
; HIR-NEXT:        |   [[TMP0:%.*]] = bitcast.<16 x i1>.i16([[DOTVEC110]])
; HIR-NEXT:        |   [[CMP0:%.*]] = [[TMP0]] == 0
; HIR-NEXT:        |   [[ALL_ZERO_CHECK0:%.*]] = [[CMP0]]
; HIR-NEXT:        + END LOOP
;
; HIR:             [[DOTVEC120:%.*]] = (<16 x i32>*)([[PRIV_MEM80]])[0]
; HIR-NEXT:        [[TMP1:%.*]] = bitcast.<16 x i1>.i16([[DOTVEC100]])
; HIR-NEXT:        [[CMP130:%.*]] = [[TMP1]] == 0
; HIR-NEXT:        [[ALL_ZERO_CHECK140:%.*]] = [[CMP130]]
; HIR-NEXT:        if ([[CMP130]] == 1)
; HIR-NEXT:        {
; HIR-NEXT:           goto [[BB12]].77
; HIR-NEXT:        }
; HIR-NEXT:        [[BSFINTMASK0:%.*]] = bitcast.<16 x i1>.i16([[DOTVEC100]])
; HIR-NEXT:        [[BSF0:%.*]] = @llvm.ctlz.i16([[BSFINTMASK0]],  1)
; HIR-NEXT:        [[EXTLANE:%.*]] = 15 - [[BSF0]]
; HIR-NEXT:        [[PRIV_EXTRACT0:%.*]] = extractelement [[DOTVEC120]],  [[EXTLANE]]
; HIR-NEXT:        ([[X0]])[0] = [[PRIV_EXTRACT0]]
; HIR-NEXT:        [[BB12]].77:
; HIR-NEXT:        [[PHI_TEMP50:%.*]] = 128
; HIR-NEXT:        final.merge.50:
; HIR-NEXT:  END REGION
entry:
  %x = alloca i32, align 4
  br label %preheader

preheader:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LASTPRIVATE:TYPED"(i32* %x, i32 0, i32 1) ]
  br label %header
header:
  %iv = phi i32 [ 0, %preheader ], [ %iv.next, %latch ]
  %iv.next = add nsw i32 %iv, 1
  br label %latch

latch:
  %xv = add nsw i32 %iv, 1
  store i32 %xv, i32* %x, align 4
  %bottom_test = icmp eq i32 %iv.next, 128
  br i1 %bottom_test, label %loopexit, label %header

loopexit:
  br label %endloop

endloop:
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %exit

exit:
  %r = load i32, i32* %x, align 4
  ret i32 %r
}

declare token @llvm.directive.region.entry() nounwind
declare void @llvm.directive.region.exit(token) nounwind
