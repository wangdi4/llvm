; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=vplan-vec -S < %s -vplan-force-vf=2 | FileCheck %s

declare ptr @get_i64_ptr()
declare <2 x ptr> @get_vec_i64_ptr()
declare ptr @get_arr_i8_ptr()

declare <2 x i64> @get_idx()

declare void @use_i64(<2 x ptr>)
declare void @use_i8(<2 x ptr> )

define void @test_revectorized_geps() {
; CHECK-LABEL: @test_revectorized_geps(
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1
  %vec.idx = call <2 x i64> @get_idx()
; CHECK:         [[VEC_IDX_0:%.*]] = call <2 x i64> @get_idx()
; CHECK-NEXT:    [[VEC_IDX_1:%.*]] = call <2 x i64> @get_idx()
; CHECK-NEXT:    [[VEC_IDX:%.*]] = shufflevector <2 x i64> [[VEC_IDX_0]], <2 x i64> [[VEC_IDX_1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>

  %p = call ptr @get_i64_ptr()
; CHECK:         [[P0:%.*]] = call ptr @get_i64_ptr()
; CHECK-NEXT:    [[P0_INSERT:%.*]] = insertelement <2 x ptr> undef, ptr [[P0]], i32 0
; CHECK-NEXT:    [[P1:%.*]] = call ptr @get_i64_ptr()
; CHECK-NEXT:    [[P:%.*]] = insertelement <2 x ptr> [[P0_INSERT]], ptr [[P1]], i32 1
  %gep.p = getelementptr i64, ptr %p, <2 x i64> %vec.idx
; CHECK-NEXT:    [[P_REPLICATE:%.*]] = shufflevector <2 x ptr> [[P]], <2 x ptr> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[GEP_P:%.*]] = getelementptr i64, <4 x ptr> [[P_REPLICATE]], <4 x i64> [[VEC_IDX]]
  call void @use_i64(<2 x ptr> %gep.p)

  %vec.ptr = call <2 x ptr> @get_vec_i64_ptr()
; CHECK:         [[VEC_P_0:%.*]] = call <2 x ptr> @get_vec_i64_ptr()
; CHECK-NEXT:    [[VEC_P_1:%.*]] = call <2 x ptr> @get_vec_i64_ptr()
; CHECK-NEXT:    [[VEC_P:%.*]] = shufflevector <2 x ptr> [[VEC_P_0]], <2 x ptr> [[VEC_P_1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %gep.vec.p = getelementptr i64, <2 x ptr>%vec.ptr, <2 x i64> %vec.idx
; CHECK-NEXT:    [[GEP_VEC_P:%.*]] = getelementptr i64, <4 x ptr> [[VEC_P]], <4 x i64> [[VEC_IDX]]
  call void @use_i64(<2 x ptr> %gep.vec.p)
  %gep.vec.p2 = getelementptr i64, <2 x ptr>%vec.ptr, i64 42
; CHECK:         [[GEP_VEC_P2:%.*]] = getelementptr i64, <4 x ptr> [[VEC_P]], <4 x i64> <i64 42, i64 42, i64 42, i64 42>
  call void @use_i64(<2 x ptr> %gep.vec.p2)

  %q = call ptr @get_arr_i8_ptr()
; CHECK:         [[Q0:%.*]] = call ptr @get_arr_i8_ptr()
; CHECK-NEXT:    [[Q0_INSERT:%.*]] = insertelement <2 x ptr> undef, ptr [[Q0]], i32 0
; CHECK-NEXT:    [[Q1:%.*]] = call ptr @get_arr_i8_ptr()
; CHECK-NEXT:    [[Q:%.*]] = insertelement <2 x ptr> [[Q0_INSERT]], ptr [[Q1]], i32 1
  %gep.q1 = getelementptr [8 x i8], ptr %q, <2 x i64> zeroinitializer, <2 x i64> %vec.idx
; CHECK-NEXT:    [[Q_REPLICATE:%.*]] = shufflevector <2 x ptr> [[Q]], <2 x ptr> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[GEP_Q1:%.*]] = getelementptr [8 x i8], <4 x ptr> [[Q_REPLICATE]], <4 x i64> zeroinitializer, <4 x i64> [[VEC_IDX]]
  call void @use_i8(<2 x ptr> %gep.q1)

  %gep.q2 = getelementptr [8 x i8], ptr %q, i64 0, <2 x i64> %vec.idx
; CHECK:         [[Q_REPLICATE2:%.*]] = shufflevector <2 x ptr> [[Q]], <2 x ptr> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[GEP_Q2:%.*]] = getelementptr [8 x i8], <4 x ptr> [[Q_REPLICATE2]], <4 x i64> zeroinitializer, <4 x i64> [[VEC_IDX]]
  call void @use_i8(<2 x ptr> %gep.q2)

  %exitcond = icmp eq i64 %iv.next, 42
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)
