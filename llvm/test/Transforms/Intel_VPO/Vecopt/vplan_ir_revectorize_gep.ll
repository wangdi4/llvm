; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -opaque-pointers=0 -passes=vplan-vec -S < %s -vplan-force-vf=2 | FileCheck %s

declare i64 *@get_i64_ptr()
declare <2 x i64*> @get_vec_i64_ptr()
declare [8 x i8] *@get_arr_i8_ptr()

declare <2 x i64> @get_idx()

declare void @use_i64(<2 x i64 *>)
declare void @use_i8(<2 x i8 *> )

define void @test_revectorized_geps() {
; CHECK-LABEL: @test_revectorized_geps(
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]
  %iv.next = add nsw i64 %iv, 1
  %vec.idx = call <2 x i64> @get_idx()
; CHECK:         [[VEC_IDX_0:%.*]] = call <2 x i64> @get_idx()
; CHECK-NEXT:    [[VEC_IDX_1:%.*]] = call <2 x i64> @get_idx()
; CHECK-NEXT:    [[VEC_IDX:%.*]] = shufflevector <2 x i64> [[VEC_IDX_0]], <2 x i64> [[VEC_IDX_1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>

  %p = call i64 *@get_i64_ptr()
; CHECK:         [[P0:%.*]] = call i64* @get_i64_ptr()
; CHECK-NEXT:    [[P0_INSERT:%.*]] = insertelement <2 x i64*> undef, i64* [[P0]], i32 0
; CHECK-NEXT:    [[P1:%.*]] = call i64* @get_i64_ptr()
; CHECK-NEXT:    [[P:%.*]] = insertelement <2 x i64*> [[P0_INSERT]], i64* [[P1]], i32 1
  %gep.p = getelementptr i64, i64 *%p, <2 x i64> %vec.idx
; CHECK-NEXT:    [[P_REPLICATE:%.*]] = shufflevector <2 x i64*> [[P]], <2 x i64*> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[GEP_P:%.*]] = getelementptr i64, <4 x i64*> [[P_REPLICATE]], <4 x i64> [[VEC_IDX]]
  call void @use_i64(<2 x i64 *> %gep.p)

  %vec.ptr = call <2 x i64*> @get_vec_i64_ptr()
; CHECK:         [[VEC_P_0:%.*]] = call <2 x i64*> @get_vec_i64_ptr()
; CHECK-NEXT:    [[VEC_P_1:%.*]] = call <2 x i64*> @get_vec_i64_ptr()
; CHECK-NEXT:    [[VEC_P:%.*]] = shufflevector <2 x i64*> [[VEC_P_0]], <2 x i64*> [[VEC_P_1]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %gep.vec.p = getelementptr i64, <2 x i64 *>%vec.ptr, <2 x i64> %vec.idx
; CHECK-NEXT:    [[GEP_VEC_P:%.*]] = getelementptr i64, <4 x i64*> [[VEC_P]], <4 x i64> [[VEC_IDX]]
  call void @use_i64(<2 x i64 *> %gep.vec.p)
  %gep.vec.p2 = getelementptr i64, <2 x i64 *>%vec.ptr, i64 42
; CHECK:         [[GEP_VEC_P2:%.*]] = getelementptr i64, <4 x i64*> [[VEC_P]], <4 x i64> <i64 42, i64 42, i64 42, i64 42>
  call void @use_i64(<2 x i64 *> %gep.vec.p2)

  %q = call [8 x i8] *@get_arr_i8_ptr()
; CHECK:         [[Q0:%.*]] = call [8 x i8]* @get_arr_i8_ptr()
; CHECK-NEXT:    [[Q0_INSERT:%.*]] = insertelement <2 x [8 x i8]*> undef, [8 x i8]* [[Q0]], i32 0
; CHECK-NEXT:    [[Q1:%.*]] = call [8 x i8]* @get_arr_i8_ptr()
; CHECK-NEXT:    [[Q:%.*]] = insertelement <2 x [8 x i8]*> [[Q0_INSERT]], [8 x i8]* [[Q1]], i32 1
  %gep.q1 = getelementptr [8 x i8], [8 x i8] *%q, <2 x i64> zeroinitializer, <2 x i64> %vec.idx
; CHECK-NEXT:    [[Q_REPLICATE:%.*]] = shufflevector <2 x [8 x i8]*> [[Q]], <2 x [8 x i8]*> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[GEP_Q1:%.*]] = getelementptr [8 x i8], <4 x [8 x i8]*> [[Q_REPLICATE]], <4 x i64> zeroinitializer, <4 x i64> [[VEC_IDX]]
  call void @use_i8(<2 x i8 *> %gep.q1)

  %gep.q2 = getelementptr [8 x i8], [8 x i8] *%q, i64 0, <2 x i64> %vec.idx
; CHECK:         [[Q_REPLICATE2:%.*]] = shufflevector <2 x [8 x i8]*> [[Q]], <2 x [8 x i8]*> undef, <4 x i32> <i32 0, i32 0, i32 1, i32 1>
; CHECK-NEXT:    [[GEP_Q2:%.*]] = getelementptr [8 x i8], <4 x [8 x i8]*> [[Q_REPLICATE2]], <4 x i64> zeroinitializer, <4 x i64> [[VEC_IDX]]
  call void @use_i8(<2 x i8 *> %gep.q2)

  %exitcond = icmp eq i64 %iv.next, 42
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token %0)
