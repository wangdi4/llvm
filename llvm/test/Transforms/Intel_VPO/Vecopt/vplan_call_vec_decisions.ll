; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of CallVecDecisions analysis for different scenarios.

; RUN: opt < %s -passes=vplan-vec -disable-output -vplan-print-after-call-vec-decisions -vector-library=SVML | FileCheck %s --check-prefix=CALLVECDEC
; RUN: opt < %s -passes=vplan-vec -disable-output -vplan-print-scalvec-results -vector-library=SVML | FileCheck %s --check-prefix=SVAPREFIX

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@src = common dso_local local_unnamed_addr global [1024 x float] zeroinitializer, align 16
@dst = common dso_local local_unnamed_addr global [1024 x float] zeroinitializer, align 16
; Function Attrs: nounwind uwtable
define dso_local void @foo() local_unnamed_addr #0 {
; CALLVECDEC-LABEL:  VPlan after CallVecDecisions analysis for merged CFG:
; CALLVECDEC-NEXT:  VPlan IR for: foo:omp.inner.for.body
; CALLVECDEC-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CALLVECDEC-NEXT:     [DA: Uni] pushvf VF=4 UF=1
; CALLVECDEC-NEXT:     [DA: Uni] pushvf VF=4 UF=1
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB1]]: # preds: [[BB0]]
; CALLVECDEC-NEXT:     [DA: Div] i64 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CALLVECDEC-NEXT:     [DA: Div] i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ],  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ]
; CALLVECDEC-NEXT:     [DA: Div] ptr [[VP_ARRAYIDX:%.*]] = getelementptr inbounds [1024 x float], ptr @src i64 0 i64 [[VP_INDVARS_IV]]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP0:%.*]] = load ptr [[VP_ARRAYIDX]]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_SERIAL_CALL:%.*]] = call float [[VP0]] ptr @bar [Serial]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_VEC_VARIANT:%.*]] = call float [[VP0]] _ZGVbM4v_simdBar [x 1] [@CurrMask]
; CALLVECDEC-NEXT:     [DA: Div] double [[VP_CONV:%.*]] = fpext float [[VP0]] to double
; CALLVECDEC-NEXT:     [DA: Div] double [[VP_LIB_CALL:%.*]] = call double [[VP_CONV]] __svml_sin4 [x 1]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_LIB_TRUNC:%.*]] = fptrunc double [[VP_LIB_CALL]] to float
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_INTRIN:%.*]] = call float [[VP0]] float [[VP_SERIAL_CALL]] float [[VP_VEC_VARIANT]] llvm.fmuladd.v4f32 [x 1]
; CALLVECDEC-NEXT:     [DA: Div] i64 [[VP_COND:%.*]] = and i64 [[VP_INDVARS_IV]] i64 1
; CALLVECDEC-NEXT:     [DA: Div] i1 [[VP_CMP13:%.*]] = icmp eq i64 [[VP_COND]] i64 0
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB4]]: # preds: [[BB2]]
; CALLVECDEC-NEXT:     [DA: Div] i1 [[VP1:%.*]] = block-predicate i1 [[VP_CMP13]]
; CALLVECDEC-NEXT:     [DA: Div] double [[VP_MASK_LIB_CALL:%.*]] = call double [[VP_CONV]] __svml_log4_mask [x 1] [@CurrMask]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_MASK_LIB_TRUNC:%.*]] = fptrunc double [[VP_MASK_LIB_CALL]] to float
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_MASK_VEC_VARIANT:%.*]] = call float [[VP0]] _ZGVbM4v_simdBar [x 1] [@CurrMask]
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB3]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB3]]: # preds: [[BB4]]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_PHI_MASK_LIB_BLEND_BB3:%.*]] = blend [ float 0.000000e+00, i1 true ], [ float [[VP_MASK_LIB_TRUNC]], i1 [[VP_CMP13]] ]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP_PHI_MASK_VV_BLEND_BB3:%.*]] = blend [ float 0.000000e+00, i1 true ], [ float [[VP_MASK_VEC_VARIANT]], i1 [[VP_CMP13]] ]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP2:%.*]] = fadd float [[VP_SERIAL_CALL]] float [[VP_VEC_VARIANT]]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP3:%.*]] = fadd float [[VP2]] float [[VP_PHI_MASK_VV_BLEND_BB3]]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP4:%.*]] = fadd float [[VP3]] float [[VP_LIB_TRUNC]]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP5:%.*]] = fadd float [[VP4]] float [[VP_PHI_MASK_LIB_BLEND_BB3]]
; CALLVECDEC-NEXT:     [DA: Div] float [[VP6:%.*]] = fadd float [[VP5]] float [[VP_INTRIN]]
; CALLVECDEC-NEXT:     [DA: Div] ptr [[VP_ARRAYIDX2:%.*]] = getelementptr inbounds [1024 x float], ptr @dst i64 0 i64 [[VP_INDVARS_IV]]
; CALLVECDEC-NEXT:     [DA: Div] store float [[VP6]] ptr [[VP_ARRAYIDX2]]
; CALLVECDEC-NEXT:     [DA: Div] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CALLVECDEC-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CALLVECDEC-NEXT:     [DA: Uni] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB5:BB[0-9]+]], [[BB2]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB5]]: # preds: [[BB3]]
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB6]]: # preds: [[BB5]]
; CALLVECDEC-NEXT:     [DA: Uni] popvf
; CALLVECDEC-NEXT:     [DA: Uni] br final.merge
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    final.merge: # preds: [[BB6]]
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP7:%.*]] = phi-merge  [ i64 live-out0, [[BB6]] ]
; CALLVECDEC-NEXT:     [DA: Uni] popvf
; CALLVECDEC-NEXT:     [DA: Uni] br <External Block>
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:  External Uses:
; CALLVECDEC-NEXT:  Id: 0   no underlying for i64 [[VP_INDVARS_IV_IND_FINAL]]
;
; SVAPREFIX-LABEL:  VPlan after ScalVec analysis:
; SVAPREFIX-NEXT:  VPlan IR for: foo:omp.inner.for.body
; SVAPREFIX-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=4 UF=1 (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=4 UF=1 (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB1:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB1]]: # preds: [[BB0]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_INDVARS_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB2:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB3]] ],  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB1]] ] (SVAOpBits 0->FV 1->FV )
; SVAPREFIX-NEXT:     [DA: Div, SVA: (F  )] ptr [[VP_ARRAYIDX:%.*]] = getelementptr inbounds [1024 x float], ptr @src i64 0 i64 [[VP_INDVARS_IV]] (SVAOpBits 0->F 1->F 2->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP0:%.*]] = load ptr [[VP_ARRAYIDX]] (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_SERIAL_CALL:%.*]] = call float [[VP0]] ptr @bar [Serial] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_VEC_VARIANT:%.*]] = call float [[VP0]] _ZGVbM4v_simdBar [x 1] [@CurrMask] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] double [[VP_CONV:%.*]] = fpext float [[VP0]] to double (SVAOpBits 0->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] double [[VP_LIB_CALL:%.*]] = call double [[VP_CONV]] __svml_sin4 [x 1] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_LIB_TRUNC:%.*]] = fptrunc double [[VP_LIB_CALL]] to float (SVAOpBits 0->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_INTRIN:%.*]] = call float [[VP0]] float [[VP_SERIAL_CALL]] float [[VP_VEC_VARIANT]] llvm.fmuladd.v4f32 [x 1] (SVAOpBits 0->V 1->V 2->V 3->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] i64 [[VP_COND:%.*]] = and i64 [[VP_INDVARS_IV]] i64 1 (SVAOpBits 0->V 1->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] i1 [[VP_CMP13:%.*]] = icmp eq i64 [[VP_COND]] i64 0 (SVAOpBits 0->V 1->V )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB4:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB4]]: # preds: [[BB2]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] i1 [[VP1:%.*]] = block-predicate i1 [[VP_CMP13]] (SVAOpBits 0->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] double [[VP_MASK_LIB_CALL:%.*]] = call double [[VP_CONV]] __svml_log4_mask [x 1] [@CurrMask] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_MASK_LIB_TRUNC:%.*]] = fptrunc double [[VP_MASK_LIB_CALL]] to float (SVAOpBits 0->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_MASK_VEC_VARIANT:%.*]] = call float [[VP0]] _ZGVbM4v_simdBar [x 1] [@CurrMask] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB3]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB3]]: # preds: [[BB4]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_PHI_MASK_LIB_BLEND_BB3:%.*]] = blend [ float 0.000000e+00, i1 true ], [ float [[VP_MASK_LIB_TRUNC]], i1 [[VP_CMP13]] ] (SVAOpBits 0->V 1->V 2->V 3->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP_PHI_MASK_VV_BLEND_BB3:%.*]] = blend [ float 0.000000e+00, i1 true ], [ float [[VP_MASK_VEC_VARIANT]], i1 [[VP_CMP13]] ] (SVAOpBits 0->V 1->V 2->V 3->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP2:%.*]] = fadd float [[VP_SERIAL_CALL]] float [[VP_VEC_VARIANT]] (SVAOpBits 0->V 1->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP3:%.*]] = fadd float [[VP2]] float [[VP_PHI_MASK_VV_BLEND_BB3]] (SVAOpBits 0->V 1->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP4:%.*]] = fadd float [[VP3]] float [[VP_LIB_TRUNC]] (SVAOpBits 0->V 1->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP5:%.*]] = fadd float [[VP4]] float [[VP_PHI_MASK_LIB_BLEND_BB3]] (SVAOpBits 0->V 1->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] float [[VP6:%.*]] = fadd float [[VP5]] float [[VP_INTRIN]] (SVAOpBits 0->V 1->V )
; SVAPREFIX-NEXT:     [DA: Div, SVA: (F  )] ptr [[VP_ARRAYIDX2:%.*]] = getelementptr inbounds [1024 x float], ptr @dst i64 0 i64 [[VP_INDVARS_IV]] (SVAOpBits 0->F 1->F 2->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] store float [[VP6]] ptr [[VP_ARRAYIDX2]] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]] (SVAOpBits 0->FV 1->FV )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB5:BB[0-9]+]], [[BB2]] (SVAOpBits 0->F 1->F 2->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB5]]: # preds: [[BB3]]
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_INDVARS_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB6:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB6]]: # preds: [[BB5]]
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br final.merge (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    final.merge: # preds: [[BB6]]
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP7:%.*]] = phi-merge  [ i64 live-out0, [[BB6]] ] (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br <External Block> (SVAOpBits )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:  External Uses:
; SVAPREFIX-NEXT:  Id: 0   no underlying for i64 [[VP_INDVARS_IV_IND_FINAL]]
;
omp.inner.for.body.lr.ph:
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %omp.inner.for.body.lr.ph
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.inc, %DIR.OMP.SIMD.1
  %indvars.iv = phi i64 [ %indvars.iv.next, %omp.inner.for.inc ], [ 0, %DIR.OMP.SIMD.1 ]
  %arrayidx = getelementptr inbounds [1024 x float], ptr @src, i64 0, i64 %indvars.iv
  %1 = load float, ptr %arrayidx, align 4
  ; User call without SIMD variants, should be serialized always.
  %serial.call = call float @bar(float %1) #1
  ; User call with SIMD variant available for VF=4 but masked, should use
  ; masked variant with all-zero mask.
  %vec.variant = call float @simdBar(float %1) #1
  %conv = fpext float %1 to double
  ; Unmasked vector library call.
  %lib.call = call afn double @sin(double %conv) #1
  %lib.trunc = fptrunc double %lib.call to float
  ; Unmasked trivially vectorizable intrinsic call.
  %intrin = call float @llvm.fmuladd.f32(float %1, float %serial.call, float %vec.variant)
  %cond = and i64 %indvars.iv, 1
  %cmp13 = icmp eq i64 %cond, 0
  br i1 %cmp13, label %if.then, label %omp.inner.for.inc

if.then:                                          ; preds = %omp.inner.for.body
  ; Masked vector library call.
  %mask.lib.call = call afn double @log(double %conv) #1
  %mask.lib.trunc = fptrunc double %mask.lib.call to float
  ; User call with SIMD variant available for VF=4 and masked.
  %mask.vec.variant = call float @simdBar(float %1) #1
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %if.then, %omp.inner.for.body
  %phi.mask.lib = phi float [ %mask.lib.trunc, %if.then ], [ 0.0, %omp.inner.for.body ]
  %phi.mask.vv = phi float [ %mask.vec.variant, %if.then ], [ 0.0, %omp.inner.for.body ]

  ; Users of calls
  %2 = fadd float %serial.call, %vec.variant
  %3 = fadd float %2, %phi.mask.vv
  %4 = fadd float %3, %lib.trunc
  %5 = fadd float %4, %phi.mask.lib
  %6 = fadd float %5, %intrin
  %arrayidx2 = getelementptr inbounds [1024 x float], ptr @dst, i64 0, i64 %indvars.iv
  store float %6, ptr %arrayidx2

  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond, label %DIR.OMP.END.SIMD.4, label %omp.inner.for.body

DIR.OMP.END.SIMD.4:                               ; preds = %omp.inner.for.inc
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.2

DIR.OMP.END.SIMD.2:                               ; preds = %DIR.OMP.END.SIMD.4
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @foo_pumping(ptr nocapture %A, ptr nocapture %B, i32 %N) {
; CALLVECDEC-LABEL:  VPlan after CallVecDecisions analysis for merged CFG:
; CALLVECDEC-NEXT:  VPlan IR for: foo_pumping:omp.inner.for.body
; CALLVECDEC-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CALLVECDEC-NEXT:     [DA: Uni] pushvf VF=128 UF=1
; CALLVECDEC-NEXT:     [DA: Uni] i32 [[VP0:%.*]] = vector-trip-count i32 [[N0:%.*]], UF = 1
; CALLVECDEC-NEXT:     [DA: Uni] i1 [[VP_VEC_TC_CHECK:%.*]] = icmp eq i32 0 i32 [[VP0]]
; CALLVECDEC-NEXT:     [DA: Uni] br i1 [[VP_VEC_TC_CHECK]], [[MERGE_BLK0:merge.blk[0-9]+]], [[BB1:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[BB1]]: # preds: [[BB0]]
; CALLVECDEC-NEXT:       [DA: Uni] pushvf VF=128 UF=1
; CALLVECDEC-NEXT:       [DA: Uni] br [[BB2:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[BB2]]: # preds: [[BB1]]
; CALLVECDEC-NEXT:       [DA: Div] i32 [[VP__OMP_IV_LOCAL_014_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CALLVECDEC-NEXT:       [DA: Uni] i32 [[VP__OMP_IV_LOCAL_014_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CALLVECDEC-NEXT:       [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[N0]], UF = 1
; CALLVECDEC-NEXT:       [DA: Uni] br [[BB3:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[BB3]]: # preds: [[BB2]], [[BB3]]
; CALLVECDEC-NEXT:       [DA: Div] i32 [[VP__OMP_IV_LOCAL_014:%.*]] = phi  [ i32 [[VP_ADD6:%.*]], [[BB3]] ],  [ i32 [[VP__OMP_IV_LOCAL_014_IND_INIT]], [[BB2]] ]
; CALLVECDEC-NEXT:       [DA: Div] float [[VP_CONV:%.*]] = sitofp i32 [[VP__OMP_IV_LOCAL_014]] to float
; CALLVECDEC-NEXT:       [DA: Div] float [[VP_PUMP_CALL:%.*]] = call float [[VP_CONV]] __svml_sinf64 [x 2]
; CALLVECDEC-NEXT:       [DA: Div] i64 [[VP_IDXPROM:%.*]] = sext i32 [[VP__OMP_IV_LOCAL_014]] to i64
; CALLVECDEC-NEXT:       [DA: Div] ptr [[VP_ARRAYIDXA:%.*]] = getelementptr inbounds float, ptr [[A0:%.*]] i64 [[VP_IDXPROM]]
; CALLVECDEC-NEXT:       [DA: Div] store float [[VP_PUMP_CALL]] ptr [[VP_ARRAYIDXA]]
; CALLVECDEC-NEXT:       [DA: Div] i32 [[VP_ADD6]] = add i32 [[VP__OMP_IV_LOCAL_014]] i32 [[VP__OMP_IV_LOCAL_014_IND_INIT_STEP]]
; CALLVECDEC-NEXT:       [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i32 [[VP_ADD6]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CALLVECDEC-NEXT:       [DA: Uni] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB4:BB[0-9]+]], [[BB3]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[BB4]]: # preds: [[BB3]]
; CALLVECDEC-NEXT:       [DA: Uni] i32 [[VP__OMP_IV_LOCAL_014_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CALLVECDEC-NEXT:       [DA: Uni] br [[BB5:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[BB5]]: # preds: [[BB4]]
; CALLVECDEC-NEXT:       [DA: Uni] popvf
; CALLVECDEC-NEXT:       [DA: Uni] br [[BB6:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[BB6]]: # preds: [[BB5]]
; CALLVECDEC-NEXT:       [DA: Uni] i1 [[VP_REMTC_CHECK:%.*]] = icmp eq i32 [[N0]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CALLVECDEC-NEXT:       [DA: Uni] br i1 [[VP_REMTC_CHECK]], final.merge, [[MERGE_BLK0]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[MERGE_BLK0]]: # preds: [[BB6]], [[BB0]]
; CALLVECDEC-NEXT:       [DA: Uni] i32 [[VP1:%.*]] = phi-merge  [ i32 live-out0, [[BB6]] ],  [ i32 0, [[BB0]] ]
; CALLVECDEC-NEXT:       [DA: Uni] br [[REMBLK0:RemBlk[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[REMBLK0]]: # preds: [[MERGE_BLK0]]
; CALLVECDEC-NEXT:       [DA: Uni] pushvf VF=1 UF=1
; CALLVECDEC-NEXT:       [DA: Uni] token [[VP_ORIG_LOOP:%.*]] = scalar-remainder omp.inner.for.body, NeedsCloning: 0, LiveInMap:
; CALLVECDEC-NEXT:         {i32 0 in {  [[DOTOMP_IV_LOCAL_0140:%.*]] = phi i32 [ [[ADD60:%.*]], [[OMP_INNER_FOR_BODY0:%.*]] ], [ 0, [[DIR_OMP_SIMD_10:%.*]] ]} -> i32 [[VP1]] }
; CALLVECDEC-NEXT:         {label [[DIR_OMP_END_SIMD_30:%.*]] in {  br i1 [[EXITCOND0:%.*]], label [[DIR_OMP_END_SIMD_30]], label [[OMP_INNER_FOR_BODY0]], !llvm.loop !0} -> label [[BB7:BB[0-9]+]] }
; CALLVECDEC-NEXT:       [DA: Uni] i32 [[VP_ORIG_LIVEOUT:%.*]] = orig-live-out token [[VP_ORIG_LOOP]], liveout:   [[ADD60]] = add nuw nsw i32 [[DOTOMP_IV_LOCAL_0140]], 1
; CALLVECDEC-NEXT:       [DA: Uni] br [[BB7]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:      [[BB7]]: # preds: [[REMBLK0]]
; CALLVECDEC-NEXT:       [DA: Uni] popvf
; CALLVECDEC-NEXT:       [DA: Uni] br final.merge
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    final.merge: # preds: [[BB6]], [[BB7]]
; CALLVECDEC-NEXT:     [DA: Uni] i32 [[VP2:%.*]] = phi-merge  [ i32 [[VP_ORIG_LIVEOUT]], [[BB7]] ],  [ i32 live-out0, [[BB6]] ]
; CALLVECDEC-NEXT:     [DA: Uni] popvf
; CALLVECDEC-NEXT:     [DA: Uni] br <External Block>
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:  External Uses:
; CALLVECDEC-NEXT:  Id: 0   no underlying for i32 [[VP__OMP_IV_LOCAL_014_IND_FINAL]]
;
; SVAPREFIX-LABEL:  VPlan after ScalVec analysis:
; SVAPREFIX-NEXT:  VPlan IR for: foo_pumping:omp.inner.for.body
; SVAPREFIX-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=128 UF=1 (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP0:%.*]] = vector-trip-count i32 [[N0:%.*]], UF = 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP_VEC_TC_CHECK:%.*]] = icmp eq i32 0 i32 [[VP0]] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br i1 [[VP_VEC_TC_CHECK]], [[MERGE_BLK0:merge.blk[0-9]+]], [[BB1:BB[0-9]+]] (SVAOpBits 0->F 1->F 2->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[BB1]]: # preds: [[BB0]]
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] pushvf VF=128 UF=1 (SVAOpBits )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br [[BB2:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[BB2]]: # preds: [[BB1]]
; SVAPREFIX-NEXT:       [DA: Div, SVA: (FV )] i32 [[VP__OMP_IV_LOCAL_014_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1 (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] i32 [[VP__OMP_IV_LOCAL_014_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[N0]], UF = 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br [[BB3:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[BB3]]: # preds: [[BB2]], [[BB3]]
; SVAPREFIX-NEXT:       [DA: Div, SVA: (FV )] i32 [[VP__OMP_IV_LOCAL_014:%.*]] = phi  [ i32 [[VP_ADD6:%.*]], [[BB3]] ],  [ i32 [[VP__OMP_IV_LOCAL_014_IND_INIT]], [[BB2]] ] (SVAOpBits 0->FV 1->FV )
; SVAPREFIX-NEXT:       [DA: Div, SVA: ( V )] float [[VP_CONV:%.*]] = sitofp i32 [[VP__OMP_IV_LOCAL_014]] to float (SVAOpBits 0->V )
; SVAPREFIX-NEXT:       [DA: Div, SVA: ( V )] float [[VP_PUMP_CALL:%.*]] = call float [[VP_CONV]] __svml_sinf64 [x 2] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:       [DA: Div, SVA: (F  )] i64 [[VP_IDXPROM:%.*]] = sext i32 [[VP__OMP_IV_LOCAL_014]] to i64 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:       [DA: Div, SVA: (F  )] ptr [[VP_ARRAYIDXA:%.*]] = getelementptr inbounds float, ptr [[A0:%.*]] i64 [[VP_IDXPROM]] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:       [DA: Div, SVA: ( V )] store float [[VP_PUMP_CALL]] ptr [[VP_ARRAYIDXA]] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:       [DA: Div, SVA: (FV )] i32 [[VP_ADD6]] = add i32 [[VP__OMP_IV_LOCAL_014]] i32 [[VP__OMP_IV_LOCAL_014_IND_INIT_STEP]] (SVAOpBits 0->FV 1->FV )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i32 [[VP_ADD6]] i32 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB4:BB[0-9]+]], [[BB3]] (SVAOpBits 0->F 1->F 2->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[BB4]]: # preds: [[BB3]]
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] i32 [[VP__OMP_IV_LOCAL_014_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1 (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br [[BB5:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[BB5]]: # preds: [[BB4]]
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br [[BB6:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[BB6]]: # preds: [[BB5]]
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] i1 [[VP_REMTC_CHECK:%.*]] = icmp eq i32 [[N0]] i32 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br i1 [[VP_REMTC_CHECK]], final.merge, [[MERGE_BLK0]] (SVAOpBits 0->F 1->F 2->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[MERGE_BLK0]]: # preds: [[BB6]], [[BB0]]
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] i32 [[VP1:%.*]] = phi-merge  [ i32 live-out0, [[BB6]] ],  [ i32 0, [[BB0]] ] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br [[REMBLK0:RemBlk[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[REMBLK0]]: # preds: [[MERGE_BLK0]]
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] pushvf VF=1 UF=1 (SVAOpBits )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] token [[VP_ORIG_LOOP:%.*]] = scalar-remainder omp.inner.for.body, NeedsCloning: 0, LiveInMap:
; SVAPREFIX-NEXT:         {i32 0 in {  [[DOTOMP_IV_LOCAL_0140:%.*]] = phi i32 [ [[ADD60:%.*]], [[OMP_INNER_FOR_BODY0:%.*]] ], [ 0, [[DIR_OMP_SIMD_10:%.*]] ]} -> i32 [[VP1]] }
; SVAPREFIX-NEXT:         {label [[DIR_OMP_END_SIMD_30:%.*]] in {  br i1 [[EXITCOND0:%.*]], label [[DIR_OMP_END_SIMD_30]], label [[OMP_INNER_FOR_BODY0]], !llvm.loop !0} -> label [[BB7:BB[0-9]+]] } (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] i32 [[VP_ORIG_LIVEOUT:%.*]] = orig-live-out token [[VP_ORIG_LOOP]], liveout:   [[ADD60]] = add nuw nsw i32 [[DOTOMP_IV_LOCAL_0140]], 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br [[BB7]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:      [[BB7]]: # preds: [[REMBLK0]]
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; SVAPREFIX-NEXT:       [DA: Uni, SVA: (F  )] br final.merge (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    final.merge: # preds: [[BB6]], [[BB7]]
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i32 [[VP2:%.*]] = phi-merge  [ i32 [[VP_ORIG_LIVEOUT]], [[BB7]] ],  [ i32 live-out0, [[BB6]] ] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br <External Block> (SVAOpBits )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:  External Uses:
; SVAPREFIX-NEXT:  Id: 0   no underlying for i32 [[VP__OMP_IV_LOCAL_014_IND_FINAL]]
;
entry:
  %cmp = icmp sgt i32 %N, 0
  br i1 %cmp, label %DIR.OMP.SIMD.2, label %omp.precond.end

DIR.OMP.SIMD.2:                                   ; preds = %entry
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %DIR.OMP.SIMD.2
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 128) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.1
  %.omp.iv.local.014 = phi i32 [ %add6, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.1 ]
  %conv = sitofp i32 %.omp.iv.local.014 to float
  %pump.call = call afn float @sinf(float %conv)
  %idxprom = sext i32 %.omp.iv.local.014 to i64
  %arrayidxA = getelementptr inbounds float, ptr %A, i64 %idxprom
  store float %pump.call, ptr %arrayidxA, align 4
  %add6 = add nuw nsw i32 %.omp.iv.local.014, 1
  %exitcond = icmp eq i32 %add6, %N
  br i1 %exitcond, label %DIR.OMP.END.SIMD.3, label %omp.inner.for.body

DIR.OMP.END.SIMD.3:                               ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.3, %entry
  ret void
}

; Test for DPCPP's unmasked function call.
declare i1 @some_cond(i64)
declare i1 @ballot(i1) #5
declare <2 x i8> @ballot.vec(<2 x i8>, <2 x i8>)

; Exact type for the active mask will depend on the library implementation, but
; it doesn't matter for the VPlan implementation as long as the library
; implementation for ballot is in sync with that of the first argument (mask)
; for the unmasked functions.
declare void @unmasked_scalar(i1, i64) #6
declare void @unmasked_vector(<2 x i8>, <2 x i64>)
define dso_local void @foo_unmasked_call_in_dpcpp(ptr nocapture %A, ptr nocapture %B, i32 %N) {
; CALLVECDEC-LABEL:  VPlan after CallVecDecisions analysis for merged CFG:
; CALLVECDEC-NEXT:  VPlan IR for: foo_unmasked_call_in_dpcpp:header
; CALLVECDEC-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CALLVECDEC-NEXT:     [DA: Uni] pushvf VF=2 UF=1
; CALLVECDEC-NEXT:     [DA: Uni] pushvf VF=2 UF=1
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB1]]: # preds: [[BB0]]
; CALLVECDEC-NEXT:     [DA: Div] i64 [[VP_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 2, UF = 1
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; CALLVECDEC-NEXT:     [DA: Div] i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_IV_NEXT:%.*]], [[BB3]] ]
; CALLVECDEC-NEXT:     [DA: Div] i1 [[VP_COND:%.*]] = call i64 [[VP_IV]] ptr @some_cond [Serial]
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB4:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB4]]: # preds: [[BB2]]
; CALLVECDEC-NEXT:     [DA: Div] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND]]
; CALLVECDEC-NEXT:     [DA: Uni] i1 [[VP_ACTIVE_MASK:%.*]] = call i1 true _ZGVbM2v_ballot(ballot.vec) [x 1] [@CurrMask]
; CALLVECDEC-NEXT:     [DA: Div] call i1 [[VP_ACTIVE_MASK]] i64 [[VP_IV]] _ZGVbN2vv_unmasked_scalar(unmasked_vector) [UnmaskedWiden]
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB3]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB3]]: # preds: [[BB4]]
; CALLVECDEC-NEXT:     [DA: Div] i64 [[VP_IV_NEXT]] = add i64 [[VP_IV]] i64 [[VP_IV_IND_INIT_STEP]]
; CALLVECDEC-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CALLVECDEC-NEXT:     [DA: Uni] br i1 true, [[BB5:BB[0-9]+]], [[BB2]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB5]]: # preds: [[BB3]]
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1
; CALLVECDEC-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    [[BB6]]: # preds: [[BB5]]
; CALLVECDEC-NEXT:     [DA: Uni] popvf
; CALLVECDEC-NEXT:     [DA: Uni] br final.merge
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:    final.merge: # preds: [[BB6]]
; CALLVECDEC-NEXT:     [DA: Uni] i64 [[VP1:%.*]] = phi-merge  [ i64 live-out0, [[BB6]] ]
; CALLVECDEC-NEXT:     [DA: Uni] popvf
; CALLVECDEC-NEXT:     [DA: Uni] br <External Block>
; CALLVECDEC-EMPTY:
; CALLVECDEC-NEXT:  External Uses:
; CALLVECDEC-NEXT:  Id: 0   no underlying for i64 [[VP_IV_IND_FINAL]]
;
; SVAPREFIX-LABEL:  VPlan after ScalVec analysis:
; SVAPREFIX-NEXT:  VPlan IR for: foo_unmasked_call_in_dpcpp:header
; SVAPREFIX-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=2 UF=1 (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] pushvf VF=2 UF=1 (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB1:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB1]]: # preds: [[BB0]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_IV_IND_INIT:%.*]] = induction-init{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_IV_IND_INIT_STEP:%.*]] = induction-init-step{add} i64 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 2, UF = 1 (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB2:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_IND_INIT]], [[BB1]] ],  [ i64 [[VP_IV_NEXT:%.*]], [[BB3]] ] (SVAOpBits 0->FV 1->FV )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] i1 [[VP_COND:%.*]] = call i64 [[VP_IV]] ptr @some_cond [Serial] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB4:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB4]]: # preds: [[BB2]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] i1 [[VP0:%.*]] = block-predicate i1 [[VP_COND]] (SVAOpBits 0->V )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: ( V )] i1 [[VP_ACTIVE_MASK:%.*]] = call i1 true _ZGVbM2v_ballot(ballot.vec) [x 1] [@CurrMask] (SVAOpBits 0->V 1->F )
; SVAPREFIX-NEXT:     [DA: Div, SVA: ( V )] call i1 [[VP_ACTIVE_MASK]] i64 [[VP_IV]] _ZGVbN2vv_unmasked_scalar(unmasked_vector) [UnmaskedWiden] (SVAOpBits 0->V 1->V 2->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB3]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB3]]: # preds: [[BB4]]
; SVAPREFIX-NEXT:     [DA: Div, SVA: (FV )] i64 [[VP_IV_NEXT]] = add i64 [[VP_IV]] i64 [[VP_IV_IND_INIT_STEP]] (SVAOpBits 0->FV 1->FV )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]] (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br i1 true, [[BB5:BB[0-9]+]], [[BB2]] (SVAOpBits 0->F 1->F 2->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB5]]: # preds: [[BB3]]
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP_IV_IND_FINAL:%.*]] = induction-final{add} i64 0 i64 1 (SVAOpBits 0->F 1->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br [[BB6:BB[0-9]+]] (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    [[BB6]]: # preds: [[BB5]]
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br final.merge (SVAOpBits 0->F )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:    final.merge: # preds: [[BB6]]
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] i64 [[VP1:%.*]] = phi-merge  [ i64 live-out0, [[BB6]] ] (SVAOpBits 0->F )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] popvf (SVAOpBits )
; SVAPREFIX-NEXT:     [DA: Uni, SVA: (F  )] br <External Block> (SVAOpBits )
; SVAPREFIX-EMPTY:
; SVAPREFIX-NEXT:  External Uses:
; SVAPREFIX-NEXT:  Id: 0   no underlying for i64 [[VP_IV_IND_FINAL]]
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 2) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cond = call i1 @some_cond(i64 %iv)
  br i1 %cond, label %if.then, label %latch

if.then:
  %active_mask = call i1 @ballot(i1 true)
  call void @unmasked_scalar(i1 %active_mask, i64 %iv)
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 2
  br i1 %exitcond, label %loop.exit, label %header

loop.exit:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1
; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1
declare dso_local float @bar(float) local_unnamed_addr #2
declare dso_local float @simdBar(float) local_unnamed_addr #3
; Function Attrs: nofree nounwind
declare dso_local double @sin(double) local_unnamed_addr #4
; Function Attrs: nofree nounwind
declare dso_local double @log(double) local_unnamed_addr #4
; Function Attrs: nounwind readnone
declare float @sinf(float) local_unnamed_addr #4
declare float @llvm.fmuladd.f32(float %a, float %b, float %c) nounwind readnone

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "may-have-openmp-directive"="true" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" "vector-variants"="_ZGVbM4v_simdBar,_ZGVcM4v_simdBar,_ZGVdM4v_simdBar,_ZGVeM4v_simdBar" }
attributes #4 = { nofree nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { "vector-variants"="_ZGVbM2v_ballot(ballot.vec)" "opencl-vec-uniform-return" }
attributes #6 = { "vector-variants"="_ZGVbN2vv_unmasked_scalar(unmasked_vector)" "unmasked" }
