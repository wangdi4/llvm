; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt < %s -disable-output -vplan-vec -mtriple=x86_64-unknown-unknown -mattr=+avx2 -vplan-force-vf=4 -vplan-cost-model-print-analysis-for-vf=4 | FileCheck %s --check-prefix=CHECK-IR

; RUN: opt < %s -disable-output -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -mtriple=x86_64-unknown-unknown -mattr=+avx2 -vplan-force-vf=4 -vplan-cost-model-print-analysis-for-vf=4 | FileCheck %s --check-prefix=CHECK-HIR

; The test verifies the cost of reduction-init/final instructions.

@arr.i32  = external local_unnamed_addr global [128 x i32], align 16
@arr.f32 = external local_unnamed_addr global [128 x float], align 16

define i32 @foo_ind_add(i32 %j.init, float %f.init) {
; CHECK-IR:    Cost 2 for i32 [[VP_J_ADD_MERGERED_INIT:%.*]] = reduction-init i32 0 i32 live-in0
; CHECK-IR-NEXT:    Cost 2 for i32 [[VP_J_MUL_MERGERED_INIT:%.*]] = reduction-init i32 1 i32 live-in1
; CHECK-IR-NEXT:    Cost 1 for i32 [[VP_K_ADD_MERGERED_INIT:%.*]] = reduction-init i32 0 i32 live-in2
; CHECK-IR-NEXT:    Cost 1 for i32 [[VP_K_MUL_MERGERED_INIT:%.*]] = reduction-init i32 1 i32 live-in3
; CHECK-IR-NEXT:    Cost 1 for float [[VP_F_ADD_MERGERED_INIT:%.*]] = reduction-init float -0.000000e+00
; CHECK-IR-NEXT:    Cost 1 for float [[VP_F_MUL_MERGERED_INIT:%.*]] = reduction-init float 1.000000e+00
; CHECK-IR-NEXT:    Cost 1 for float [[VP_G_ADD_MERGERED_INIT:%.*]] = reduction-init float -0.000000e+00
; CHECK-IR-NEXT:    Cost 1 for float [[VP_G_MUL_MERGERED_INIT:%.*]] = reduction-init float 1.000000e+00
; CHECK-IR:    Cost 3 for i32 [[VP_J_ADD_MERGERED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_J_ADD_NEXT:%.*]]
; CHECK-IR-NEXT:    Cost 7 for i32 [[VP_J_MUL_MERGERED_FINAL:%.*]] = reduction-final{u_mul} i32 [[VP_J_MUL_NEXT:%.*]]
; CHECK-IR-NEXT:    Cost 3 for i32 [[VP_K_ADD_MERGERED_FINAL:%.*]] = reduction-final{u_add} i32 [[VP_K_ADD_NEXT:%.*]]
; CHECK-IR-NEXT:    Cost 7 for i32 [[VP_K_MUL_MERGERED_FINAL:%.*]] = reduction-final{u_mul} i32 [[VP_K_MUL_NEXT:%.*]]
; CHECK-IR-NEXT:    Cost 7 for float [[VP_F_ADD_MERGERED_FINAL:%.*]] = reduction-final{fadd} float [[VP_F_ADD_NEXT:%.*]] float live-in4
; CHECK-IR-NEXT:    Cost 7 for float [[VP_F_MUL_MERGERED_FINAL:%.*]] = reduction-final{fmul} float [[VP_F_MUL_NEXT:%.*]] float live-in5
; CHECK-IR-NEXT:    Cost 7 for float [[VP_G_ADD_MERGERED_FINAL:%.*]] = reduction-final{fadd} float [[VP_G_ADD_NEXT:%.*]] float live-in6
; CHECK-IR-NEXT:    Cost 7 for float [[VP_G_MUL_MERGERED_FINAL:%.*]] = reduction-final{fmul} float [[VP_G_MUL_NEXT:%.*]] float live-in7

; CHECK-HIR:    Cost 2 for i32 [[VP_RED_INIT:%.*]] = reduction-init i32 1 i32 live-in0
; CHECK-HIR-NEXT:    Cost 1 for float [[VP_RED_INIT_1:%.*]] = reduction-init float -0.000000e+00
; CHECK-HIR-NEXT:    Cost 1 for float [[VP_RED_INIT_2:%.*]] = reduction-init float 1.000000e+00
; CHECK-HIR-NEXT:    Cost 1 for float [[VP_RED_INIT_3:%.*]] = reduction-init float -0.000000e+00
; CHECK-HIR-NEXT:    Cost 1 for float [[VP_RED_INIT_4:%.*]] = reduction-init float 1.000000e+00
; CHECK-HIR:    Cost 7 for i32 [[VP_RED_FINAL:%.*]] = reduction-final{u_mul} i32 [[VP9:%.*]]
; CHECK-HIR-NEXT:    Cost 7 for float [[VP_RED_FINAL_1:%.*]] = reduction-final{fadd} float [[VP7:%.*]] float live-in1
; CHECK-HIR-NEXT:    Cost 7 for float [[VP_RED_FINAL_2:%.*]] = reduction-final{fmul} float [[VP5:%.*]] float live-in2
; CHECK-HIR-NEXT:    Cost 7 for float [[VP_RED_FINAL_3:%.*]] = reduction-final{fadd} float [[VP3:%.*]] float live-in3
; CHECK-HIR-NEXT:    Cost 7 for float [[VP_RED_FINAL_4:%.*]] = reduction-final{fmul} float [[VP1:%.*]] float live-in4

entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %i.merge = phi i32 [ 0, %entry ], [ %i.next, %for.body ]

  %j.add.merge = phi i32 [ %j.init, %entry ], [ %j.add.next, %for.body ]
  %j.mul.merge = phi i32 [ %j.init, %entry ], [ %j.mul.next, %for.body ]
  %k.add.merge = phi i32 [ 42, %entry ], [ %k.add.next, %for.body ]
  %k.mul.merge = phi i32 [ 42, %entry ], [ %k.mul.next, %for.body ]
  %f.add.merge = phi float [ %f.init, %entry ], [ %f.add.next, %for.body ]
  %f.mul.merge = phi float [ %f.init, %entry ], [ %f.mul.next, %for.body ]
  %g.add.merge = phi float [ 42.0E+0, %entry ], [ %g.add.next, %for.body ]
  %g.mul.merge = phi float [ 42.0E+0, %entry ], [ %g.mul.next, %for.body ]

  %idx.i32 = getelementptr inbounds [128 x i32], [128 x i32]* @arr.i32, i32 0, i32 %i.merge
  %load.i32 = load i32, i32* %idx.i32, align 4
  %idx.f32 = getelementptr inbounds [128 x float], [128 x float]* @arr.f32, i32 0, i32 %i.merge
  %load.f32 = load float, float* %idx.f32, align 4
  %i.next = add nuw nsw i32 %i.merge, 1
  %exitcond = icmp eq i32 %i.next, 128

  %j.add.next = add nuw nsw i32 %j.add.merge, %load.i32
  %j.mul.next = mul nuw nsw i32 %j.mul.merge, %load.i32
  %k.add.next = add nuw nsw i32 %k.add.merge, %load.i32
  %k.mul.next = mul nuw nsw i32 %k.mul.merge, %load.i32

  %f.add.next = fadd float %f.add.merge, %load.f32
  %f.mul.next = fmul float %f.mul.merge, %load.f32
  %g.add.next = fadd float %g.add.merge, %load.f32
  %g.mul.next = fmul float %g.mul.merge, %load.f32

  br i1 %exitcond, label %for.exit, label %for.body

for.exit:
  %res.j.add = phi i32 [ %j.add.next, %for.body ]
  %res.j.mul = phi i32 [ %j.mul.next, %for.body ]
  %res.k.add = phi i32 [ %k.add.next, %for.body ]
  %res.k.mul = phi i32 [ %k.mul.next, %for.body ]
  %res.f.add = phi float [ %f.add.next, %for.body ]
  %res.f.mul = phi float [ %f.mul.next, %for.body ]
  %res.g.add = phi float [ %g.add.next, %for.body ]
  %res.g.mul = phi float [ %g.mul.next, %for.body ]

  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]

  %res.j = add nuw nsw i32 %res.j.add, %res.j.mul
  %res.k = add nuw nsw i32 %res.k.add, %res.k.mul
  %res.i32 = add nuw nsw i32 %res.j, %res.k

  %res.f = fadd float %res.f.add, %res.f.mul
  %res.g = fadd float %res.g.add, %res.g.mul
  %res.f32 = fadd float %res.f, %res.g

  %res.cvt = fptosi float %res.f32 to i32
  %res = add nuw nsw i32 %res.i32, %res.cvt

  ret i32 %res.k.mul
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
