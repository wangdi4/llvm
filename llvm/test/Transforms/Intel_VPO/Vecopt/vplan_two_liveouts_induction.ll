; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -vplan-enable-soa=false -passes=vplan-vec -vplan-force-vf=2 -vplan-print-after-live-inout-list -vplan-entities-dump -disable-output %s | FileCheck %s

@arr = external global [1024 x i32]
@i = external global i32

define void @foo() {
; CHECK-LABEL:  VPlan after live in/out lists creation:
; CHECK-NEXT:  VPlan IR for: foo:omp.inner.for.body
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i32 0 Step: i32 1 StartVal: i32 0 EndVal: i32 -2147483648 BinOp: i32 [[VP_ADD3:%.*]] = add i32 [[VP_STOREMERGE10:%.*]] i32 [[VP_STOREMERGE10_IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i32 [[VP_STOREMERGE10]], i32 [[VP_ADD3]], i32 [[VP_STOREMERGE10_IND_INIT:%.*]], i32 [[VP_STOREMERGE10_IND_INIT_STEP]], i32 [[VP_STOREMERGE10_IND_FINAL:%.*]],
; CHECK:       Private list
; CHECK-EMPTY:
; CHECK-NEXT:    Private tag: InMemory
; CHECK-NEXT:    Linked values: i32* [[VP_I:%.*]],
; CHECK-NEXT:   Memory: i32* @i
; CHECK-EMPTY:
; CHECK-NEXT:    Private tag: Array
; CHECK-NEXT:    Linked values: [1024 x i32]* [[VP_ARR:%.*]],
; CHECK-NEXT:   Memory: [1024 x i32]* @arr
; CHECK-EMPTY:
; CHECK-NEXT:    Exit instr: i32 [[VP_STOREMERGE10]] = phi  [ i32 [[VP_ADD3]], [[BB1:BB[0-9]+]] ],  [ i32 [[VP_STOREMERGE10_IND_INIT]], [[BB2:BB[0-9]+]] ]
;
;                  VP_STOREMERGE10_PRIV_FINAL is the additional private
;                  representing the unclassified live-out and VPInductionFinal
;                  corresponding to %add3 the actual VPInductionFinal.
;
; CHECK-NEXT:    Linked values: i32 [[VP_STOREMERGE10]], i32 [[VP_STOREMERGE10_PRIV_FINAL:%.*]],
; CHECK:         [[BB3:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB3]]
; CHECK-NEXT:     [1024 x i32]* [[VP_ARR]] = allocate-priv [1024 x i32]*, OrigAlign = 4
; CHECK-NEXT:     i32* [[VP_I]] = allocate-priv i32*, OrigAlign = 4
; CHECK-NEXT:     i32 [[VP_STOREMERGE10_IND_INIT]] = induction-init{add} i32 live-in1 i32 1
; CHECK-NEXT:     i32 [[VP_STOREMERGE10_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:     i32 [[VP_VF:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     i32 [[VP_ORIG_TRIP_COUNT:%.*]] = orig-trip-count for original loop omp.inner.for.body
; CHECK-NEXT:     i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 [[VP_ORIG_TRIP_COUNT]], UF = 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB1]]
; CHECK-NEXT:     i32 [[VP_VECTOR_LOOP_IV:%.*]] = phi  [ i32 0, [[BB2]] ],  [ i32 [[VP_VECTOR_LOOP_IV_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:     i32 [[VP_STOREMERGE10]] = phi  [ i32 [[VP_ADD3]], [[BB1]] ],  [ i32 [[VP_STOREMERGE10_IND_INIT]], [[BB2]] ]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB0]], [[BB4]]
; CHECK-NEXT:     br i1 undef, [[BB1]], [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB4]]
; CHECK-NEXT:     i32 [[VP_ADD3]] = add i32 [[VP_STOREMERGE10]] i32 [[VP_STOREMERGE10_IND_INIT_STEP]]
; CHECK-NEXT:     i32 [[VP_VECTOR_LOOP_IV_NEXT]] = add i32 [[VP_VECTOR_LOOP_IV]] i32 [[VP_VF]]
; CHECK-NEXT:     i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp ult i32 [[VP_VECTOR_LOOP_IV_NEXT]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB0]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB1]]
; CHECK-NEXT:     i32 [[VP_STOREMERGE10_IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_STOREMERGE10_PRIV_FINAL]] = private-final-uc i32 [[VP_STOREMERGE10]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0     [[STOREMERGE10_LCSSA0:%.*]] = phi i32 [ [[STOREMERGE100:%.*]], [[OMP_INNER_FOR_INC0:%.*]] ] i32 [[VP_STOREMERGE10_PRIV_FINAL]] -> i32 [[STOREMERGE100]]
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1     [[ADD3_LCSSA0:%.*]] = phi i32 [ [[ADD30:%.*]], [[OMP_INNER_FOR_INC0]] ] i32 [[VP_STOREMERGE10_IND_FINAL]] -> i32 [[ADD30]]
; CHECK-EMPTY:
; CHECK-NEXT:  Original loop live-ins/live-outs:
; CHECK-NEXT:    Id: 1
; CHECK-NEXT:      Phi:   [[STOREMERGE100]] = phi i32 [ [[ADD30]], [[OMP_INNER_FOR_INC0]] ], [ 0, [[ENTRY0:%.*]] ]    Start op: 1
; CHECK-NEXT:      Live-Out:   [[ADD30]] = add nuw nsw i32 [[STOREMERGE100]], 1
; CHECK-NEXT:    Id: 0
; CHECK-NEXT:      Phi:   [[STOREMERGE100]] = phi i32 [ [[ADD30]], [[OMP_INNER_FOR_INC0]] ], [ 0, [[ENTRY0]] ]    Start op: 1
; CHECK-NEXT:      Live-Out:   [[STOREMERGE100]] = phi i32 [ [[ADD30]], [[OMP_INNER_FOR_INC0]] ], [ 0, [[ENTRY0]] ]
;
entry:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE:TYPED"([1024 x i32]* @arr, i32 0, i32 1024), "QUAL.OMP.LASTPRIVATE:TYPED"(i32* @i, i32 0, i32 1) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.inc, %entry
  %storemerge10 = phi i32 [ %add3, %omp.inner.for.inc ], [ 0, %entry ]
  br label %for.body

for.body:                                         ; preds = %for.body, %omp.inner.for.body
  br i1 undef, label %omp.inner.for.inc, label %for.body

omp.inner.for.inc:                                ; preds = %for.body
  %add3 = add nuw nsw i32 %storemerge10, 1
  %cmp = icmp slt i32 %storemerge10, undef
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.omp.loop.exit_crit_edge

omp.inner.for.cond.omp.loop.exit_crit_edge:       ; preds = %omp.inner.for.inc
  %add3.lcssa = phi i32 [ %add3, %omp.inner.for.inc ]
  %storemerge10.lcssa = phi i32 [ %storemerge10, %omp.inner.for.inc ]
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
