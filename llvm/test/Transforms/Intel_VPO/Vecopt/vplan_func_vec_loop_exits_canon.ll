; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -opaque-pointers=0 -passes=vplan-func-vec -print-after-vplan-func-vec-loop-exit-canon < %s -disable-output | FileCheck %s
define void @test_no_massage() {
; CHECK-LABEL:  VPlan IR for: test_no_massage
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_ADD:%.*]] = add i32 [[VP_LANE]] i32 42
; CHECK-NEXT:     ret
; CHECK-NEXT:     br <External Block>
;
  %lane = call i32 @llvm.vplan.laneid()
  %add = add i32 %lane, 42
  ret void
}

define void @test_simple_while() {
; CHECK-LABEL:  VPlan IR for: test_simple_while
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]]
; CHECK-NEXT:     i32 [[VP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_IV_NEXT:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     i1 [[VP_EXITCOND:%.*]] = icmp eq i32 [[VP_IV]] i32 42
; CHECK-NEXT:     br i1 [[VP_EXITCOND]], [[NEW_LOOP_LATCH0]], [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]: # preds: [[BB2]], [[BB1]]
; CHECK-NEXT:     i1 [[VP_TAKEBACKEDGECOND:%.*]] = phi  [ i1 true, [[BB2]] ],  [ i1 false, [[BB1]] ]
; CHECK-NEXT:     br i1 [[VP_TAKEBACKEDGECOND]], [[BB1]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[NEW_LOOP_LATCH0]]
; CHECK-NEXT:     ret
; CHECK-NEXT:     br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %latch]
  %iv.next = add nsw nuw i32 %iv, 1
  %exitcond = icmp eq i32 %iv, 42
  br i1 %exitcond, label %loop.exit, label %latch

latch:
  br label %header

loop.exit:
  ret void
}

define void @test_multi_exit() {
; CHECK-LABEL:  VPlan IR for: test_multi_exit
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]]
; CHECK-NEXT:     i32 [[VP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_IV_NEXT:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     i1 [[VP_SIDEEXIT_COND:%.*]] = icmp eq i32 [[VP_IV]] i32 [[VP_LANE]]
; CHECK-NEXT:     br i1 [[VP_SIDEEXIT_COND]], [[INTERMEDIATE_BB0:intermediate.bb[0-9]+]], [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       i1 [[VP_EXIT_COND:%.*]] = icmp eq i32 [[VP_IV]] i32 42
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[INTERMEDIATE_BB0]]: # preds: [[BB1]]
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]: # preds: [[BB2]], [[INTERMEDIATE_BB0]]
; CHECK-NEXT:     i32 [[VP_EXIT_ID_PHI:%.*]] = phi  [ i32 0, [[BB2]] ],  [ i32 1, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     i1 [[VP_TAKE_BACKEDGE_COND:%.*]] = phi  [ i1 [[VP_EXIT_COND]], [[BB2]] ],  [ i1 true, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     br i1 [[VP_TAKE_BACKEDGE_COND]], [[BB3:BB[0-9]+]], [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[NEW_LOOP_LATCH0]]
; CHECK-NEXT:     ret
; CHECK-NEXT:     br <External Block>
;
; FIXME: VP_TAKE_BACKEDGE_COND name is misleading here. In fact, it's EXIT_COND, not CONTINUE_COND.
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %latch]
  %iv.next = add nsw nuw i32 %iv, 1
  %sideexit.cond = icmp eq i32 %iv, %lane
  br i1 %sideexit.cond, label %loop.exit, label %latch

latch:
  %exit.cond = icmp eq i32 %iv, 42
  br i1 %exit.cond, label %loop.exit, label %header

loop.exit:
  ret void
}

; TODO: Use DA to avoid massaging loops with uniform backedge.
define void @test_while_loop_with_allzero() {
; CHECK-LABEL:  VPlan IR for: test_while_loop_with_allzero
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_MUL:%.*]] = mul i32 [[VP_LANE]] i32 [[VP_LANE]]
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]]
; CHECK-NEXT:     i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 [[VP_MUL]], [[BB0]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     i1 [[VP_MASK:%.*]] = phi  [ i1 true, [[BB0]] ],  [ i1 [[VP_MASK_NEXT:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     i32 [[VP_LIVEOUT_PREV:%.*]] = phi  [ i32 undef, [[BB0]] ],  [ i32 [[VP_LIVEOUT:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     br i1 [[VP_MASK]], [[BB2:BB[0-9]+]], [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       i32 [[VP_ADD:%.*]] = add i32 [[VP_LOOP_IV]] i32 7
; CHECK-NEXT:       br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB1]], [[BB2]]
; CHECK-NEXT:     i32 [[VP_LIVEOUT]] = phi  [ i32 [[VP_LIVEOUT_PREV]], [[BB1]] ],  [ i32 [[VP_LOOP_IV]], [[BB2]] ]
; CHECK-NEXT:     i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:     i1 [[VP_DIV_EXIT_COND:%.*]] = icmp eq i32 [[VP_LOOP_IV]] i32 42
; CHECK-NEXT:     i1 [[VP_NOT:%.*]] = xor i1 [[VP_DIV_EXIT_COND]] i1 true
; CHECK-NEXT:     i1 [[VP_MASK_NEXT]] = and i1 [[VP_MASK]] i1 [[VP_NOT]]
; CHECK-NEXT:     i1 [[VP_EXIT_COND:%.*]] = call i1 [[VP_MASK_NEXT]] i1 (i1)* @allzero
; CHECK-NEXT:     br i1 [[VP_EXIT_COND]], [[NEW_LOOP_LATCH0]], [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]: # preds: [[BB4]], [[BB3]]
; CHECK-NEXT:     i1 [[VP_TAKEBACKEDGECOND:%.*]] = phi  [ i1 true, [[BB4]] ],  [ i1 false, [[BB3]] ]
; CHECK-NEXT:     br i1 [[VP_TAKEBACKEDGECOND]], [[BB1]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[NEW_LOOP_LATCH0]]
; CHECK-NEXT:     i32 [[VP_LIVEOUT_USE:%.*]] = phi  [ i32 [[VP_LIVEOUT]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     ret
; CHECK-NEXT:     br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %mul = mul nsw nuw i32 %lane, %lane
  br label %header

header:
  %loop_iv = phi i32 [ %mul, %entry ], [ %loop_iv.next, %latch ]
  %mask = phi i1 [ true, %entry ], [ %mask.next, %latch ]
  %liveout.prev = phi i32 [ undef, %entry ], [ %liveout, %latch ]
  br i1 %mask, label %active, label %exiting

active:
  %add = add i32 %loop_iv, 7
  br label %exiting

exiting:
  %liveout = phi i32 [ %liveout.prev, %header ], [ %loop_iv, %active ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %div_exit_cond = icmp eq i32 %loop_iv, 42
  %not = xor i1 %div_exit_cond, true
  %mask.next = and i1 %mask, %not
  %exit_cond = call i1 @allzero(i1 %mask.next)
  br i1 %exit_cond, label %exit, label %latch

latch:
  br label %header

exit:
  %liveout.use = phi i32 [ %liveout, %exiting ]
  ret void
}

declare i1 @foo(i32)
define void @test_const_latch_cond() {
; CHECK-LABEL:  VPlan IR for: test_const_latch_cond
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_MUL:%.*]] = mul i32 [[VP_LANE]] i32 [[VP_LANE]]
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]]
; CHECK-NEXT:     i1 [[VP_COND:%.*]] = call i32 [[VP_LANE]] i1 (i32)* @foo
; CHECK-NEXT:     br i1 [[VP_COND]], [[BB2:BB[0-9]+]], [[INTERMEDIATE_BB0:intermediate.bb[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[INTERMEDIATE_BB0]]: # preds: [[BB1]]
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:       br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]: # preds: [[BB2]], [[INTERMEDIATE_BB0]]
; CHECK-NEXT:     i32 [[VP_EXIT_ID_PHI:%.*]] = phi  [ i32 0, [[BB2]] ],  [ i32 1, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     i1 [[VP_TAKE_BACKEDGE_COND:%.*]] = phi  [ i1 false, [[BB2]] ],  [ i1 true, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     br i1 [[VP_TAKE_BACKEDGE_COND]], [[BB3:BB[0-9]+]], [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[NEW_LOOP_LATCH0]]
; CHECK-NEXT:     ret
; CHECK-NEXT:     br <External Block>
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %mul = mul nsw nuw i32 %lane, %lane
  br label %header

header:
  %cond = call i1 @foo(i32 %lane)
  br i1 %cond, label %latch, label %exit

latch:
  ; This non-instruction cond bit used to cause a crash.
  br i1 false, label %exit, label %header

exit:
  ret void
}
declare i32 @llvm.vplan.laneid()

declare i1 @allzero(i1) #0

attributes #0 = { "opencl-vec-uniform-return" }
