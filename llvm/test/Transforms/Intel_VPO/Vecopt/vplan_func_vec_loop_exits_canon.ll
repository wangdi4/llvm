; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -vplan-func-vec -print-after-vplan-func-vec-loop-exit-canon < %s -disable-output | FileCheck %s
define void @test_no_massage() {
; CHECK-LABEL:  VPlan IR for: test_no_massage
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_ADD:%.*]] = add i32 [[VP_LANE]] i32 42
; CHECK-NEXT:     void [[VP0:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    no PREDECESSORS
;
  %lane = call i32 @llvm.vplan.laneid()
  %add = add i32 %lane, 42
  ret void
}

define void @test_simple_while() {
; CHECK-LABEL:  VPlan IR for: test_simple_while
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     i32 [[VP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_IV_NEXT:%.*]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]] ]
; CHECK-NEXT:     i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     i1 [[VP_EXITCOND:%.*]] = icmp i32 [[VP_IV]] i32 42
; CHECK-NEXT:    SUCCESSORS(2):[[NEW_LOOP_LATCH0]](i1 [[VP_EXITCOND]]), [[BB2:BB[0-9]+]](!i1 [[VP_EXITCOND]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB0]] [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[NEW_LOOP_LATCH0]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]:
; CHECK-NEXT:     i1 [[VP_TAKEBACKEDGECOND:%.*]] = phi  [ i1 true, [[BB2]] ],  [ i1 false, [[BB1]] ]
; CHECK-NEXT:    SUCCESSORS(2):[[BB1]](i1 [[VP_TAKEBACKEDGECOND]]), [[BB3:BB[0-9]+]](!i1 [[VP_TAKEBACKEDGECOND]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB2]] [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     void [[VP0:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[NEW_LOOP_LATCH0]]
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %latch]
  %iv.next = add nsw nuw i32 %iv, 1
  %exitcond = icmp eq i32 %iv, 42
  br i1 %exitcond, label %loop.exit, label %latch

latch:
  br label %header

loop.exit:
  ret void
}

define void @test_multi_exit() {
; CHECK-LABEL:  VPlan IR for: test_multi_exit
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     i32 [[VP_IV:%.*]] = phi  [ i32 0, [[BB0]] ],  [ i32 [[VP_IV_NEXT:%.*]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]] ]
; CHECK-NEXT:     i32 [[VP_IV_NEXT]] = add i32 [[VP_IV]] i32 1
; CHECK-NEXT:     i1 [[VP_SIDEEXIT_COND:%.*]] = icmp i32 [[VP_IV]] i32 [[VP_LANE]]
; CHECK-NEXT:    SUCCESSORS(2):[[INTERMEDIATE_BB0:intermediate.bb[0-9]+]](i1 [[VP_SIDEEXIT_COND]]), [[BB2:BB[0-9]+]](!i1 [[VP_SIDEEXIT_COND]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB0]] [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       i1 [[VP_EXIT_COND:%.*]] = icmp i32 [[VP_IV]] i32 42
; CHECK-NEXT:      SUCCESSORS(1):[[NEW_LOOP_LATCH0]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[INTERMEDIATE_BB0]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[NEW_LOOP_LATCH0]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]:
; CHECK-NEXT:     i32 [[VP_EXIT_ID_PHI:%.*]] = phi  [ i32 0, [[BB2]] ],  [ i32 1, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:     i1 [[VP_TAKE_BACKEDGE_COND:%.*]] = phi  [ i1 [[VP_EXIT_COND]], [[BB2]] ],  [ i1 true, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:    SUCCESSORS(2):[[BB3:BB[0-9]+]](i1 [[VP_TAKE_BACKEDGE_COND]]), [[BB1]](!i1 [[VP_TAKE_BACKEDGE_COND]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB2]] [[INTERMEDIATE_BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     void [[VP0:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[NEW_LOOP_LATCH0]]
;
; FIXME: VP_TAKE_BACKEDGE_COND name is misleading here. In fact, it's EXIT_COND, not CONTINUE_COND.
entry:
  %lane = call i32 @llvm.vplan.laneid()
  br label %header

header:
  %iv = phi i32 [ 0, %entry ], [ %iv.next, %latch]
  %iv.next = add nsw nuw i32 %iv, 1
  %sideexit.cond = icmp eq i32 %iv, %lane
  br i1 %sideexit.cond, label %loop.exit, label %latch

latch:
  %exit.cond = icmp eq i32 %iv, 42
  br i1 %exit.cond, label %loop.exit, label %header

loop.exit:
  ret void
}

; TODO: Use DA to avoid massaging loops with uniform backedge.
define void @test_while_loop_with_allzero() {
; CHECK-LABEL:  VPlan IR for: test_while_loop_with_allzero
; CHECK-NEXT:    [[BB0:BB[0-9]+]]:
; CHECK-NEXT:     i32 [[VP_LANE:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     i32 [[VP_MUL:%.*]] = mul i32 [[VP_LANE]] i32 [[VP_LANE]]
; CHECK-NEXT:    SUCCESSORS(1):[[BB1:BB[0-9]+]]
; CHECK-NEXT:    no PREDECESSORS
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]:
; CHECK-NEXT:     i32 [[VP_LOOP_IV:%.*]] = phi  [ i32 [[VP_MUL]], [[BB0]] ],  [ i32 [[VP_LOOP_IV_NEXT:%.*]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]] ]
; CHECK-NEXT:     i1 [[VP_MASK:%.*]] = phi  [ i1 true, [[BB0]] ],  [ i1 [[VP_MASK_NEXT:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     i32 [[VP_LIVEOUT_PREV:%.*]] = phi  [ i32 undef, [[BB0]] ],  [ i32 [[VP_LIVEOUT:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:    SUCCESSORS(2):[[BB2:BB[0-9]+]](i1 [[VP_MASK]]), [[BB3:BB[0-9]+]](!i1 [[VP_MASK]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB0]] [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB2]]:
; CHECK-NEXT:       i32 [[VP_ADD:%.*]] = add i32 [[VP_LOOP_IV]] i32 7
; CHECK-NEXT:      SUCCESSORS(1):[[BB3]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]:
; CHECK-NEXT:     i32 [[VP_LIVEOUT]] = phi  [ i32 [[VP_LIVEOUT_PREV]], [[BB1]] ],  [ i32 [[VP_LOOP_IV]], [[BB2]] ]
; CHECK-NEXT:     i32 [[VP_LOOP_IV_NEXT]] = add i32 [[VP_LOOP_IV]] i32 1
; CHECK-NEXT:     i1 [[VP_DIV_EXIT_COND:%.*]] = icmp i32 [[VP_LOOP_IV]] i32 42
; CHECK-NEXT:     i1 [[VP_NOT:%.*]] = xor i1 [[VP_DIV_EXIT_COND]] i1 true
; CHECK-NEXT:     i1 [[VP_MASK_NEXT]] = and i1 [[VP_MASK]] i1 [[VP_NOT]]
; CHECK-NEXT:     i1 [[VP_EXIT_COND:%.*]] = call i1 [[VP_MASK_NEXT]] i1 (i1)* @allzero
; CHECK-NEXT:    SUCCESSORS(2):[[NEW_LOOP_LATCH0]](i1 [[VP_EXIT_COND]]), [[BB4:BB[0-9]+]](!i1 [[VP_EXIT_COND]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB1]] [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]:
; CHECK-NEXT:       <Empty Block>
; CHECK-NEXT:      SUCCESSORS(1):[[NEW_LOOP_LATCH0]]
; CHECK-NEXT:      PREDECESSORS(1): [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]:
; CHECK-NEXT:     i1 [[VP_TAKEBACKEDGECOND:%.*]] = phi  [ i1 true, [[BB4]] ],  [ i1 false, [[BB3]] ]
; CHECK-NEXT:    SUCCESSORS(2):[[BB1]](i1 [[VP_TAKEBACKEDGECOND]]), [[BB5:BB[0-9]+]](!i1 [[VP_TAKEBACKEDGECOND]])
; CHECK-NEXT:    PREDECESSORS(2): [[BB4]] [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]:
; CHECK-NEXT:     i32 [[VP_LIVEOUT_USE:%.*]] = phi  [ i32 [[VP_LIVEOUT]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:     void [[VP0:%.*]] = ret
; CHECK-NEXT:    no SUCCESSORS
; CHECK-NEXT:    PREDECESSORS(1): [[NEW_LOOP_LATCH0]]
;
entry:
  %lane = call i32 @llvm.vplan.laneid()
  %mul = mul nsw nuw i32 %lane, %lane
  br label %header

header:
  %loop_iv = phi i32 [ %mul, %entry ], [ %loop_iv.next, %latch ]
  %mask = phi i1 [ true, %entry ], [ %mask.next, %latch ]
  %liveout.prev = phi i32 [ undef, %entry ], [ %liveout, %latch ]
  br i1 %mask, label %active, label %exiting

active:
  %add = add i32 %loop_iv, 7
  br label %exiting

exiting:
  %liveout = phi i32 [ %liveout.prev, %header ], [ %loop_iv, %active ]
  %loop_iv.next = add nsw nuw i32 %loop_iv, 1
  %div_exit_cond = icmp eq i32 %loop_iv, 42
  %not = xor i1 %div_exit_cond, true
  %mask.next = and i1 %mask, %not
  %exit_cond = call i1 @allzero(i1 %mask.next)
  br i1 %exit_cond, label %exit, label %latch

latch:
  br label %header

exit:
  %liveout.use = phi i32 [ %liveout, %exiting ]
  ret void
}

declare i32 @llvm.vplan.laneid()

declare i1 @allzero(i1) #0

attributes #0 = { "opencl-vec-uniform-return" }
