; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -vplan-force-vf=4 -disable-output -print-after=hir-vplan-vec  < %s 2>&1 | FileCheck %s

target triple = "x86_64-unknown-linux-gnu"
%struct.S1 = type { i64, i64 }

define dso_local void @foo(i32* noalias nocapture %arr, %struct.S1* noalias nocapture readonly %sarr) {
; CHECK:       + DO i1 = 0, 99, 4   <DO_LOOP> <auto-vectorized> <novectorize>
; CHECK-NEXT:  |   %.vls.load = undef;
; CHECK-NEXT:  |   %.vec = i1 + <i64 0, i64 1, i64 2, i64 3> != 42;
; CHECK-NEXT:  |   %gep.base = &((i64*)(%sarr)[i1].1);
; CHECK-NEXT:  |   %vls.mask = shufflevector %.vec,  zeroinitializer,  <i32 0, i32 0, i32 1, i32 1, i32 2, i32 2, i32 3, i32 3>;
; CHECK-NEXT:  |   %.vls.load = (<8 x i64>*)(%gep.base)[-1], Mask = @{%vls.mask};
; CHECK-NEXT:  |   %vls.extract = shufflevector %.vls.load,  %.vls.load,  <i32 0, i32 2, i32 4, i32 6>;
; CHECK-NEXT:  |   %vls.extract1 = shufflevector %.vls.load,  %.vls.load,  <i32 1, i32 3, i32 5, i32 7>;
; CHECK-NEXT:  |   (<4 x i32>*)(%arr)[i1] = %vls.extract + %vls.extract1, Mask = @{%.vec};
; CHECK-NEXT:  + END LOOP
entry:
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %latch ]
  %cond = icmp eq i64 %iv, 42
  br i1 %cond, label %latch, label %bb

bb:
  %b = getelementptr inbounds %struct.S1, %struct.S1* %sarr, i64 %iv, i32 1
  %0 = load i64, i64* %b, align 8
  %a = getelementptr inbounds %struct.S1, %struct.S1* %sarr, i64 %iv, i32 0
  %1 = load i64, i64* %a, align 8

  %add = add nsw i64 %1, %0
  %conv = trunc i64 %add to i32
  %ptridx2 = getelementptr inbounds i32, i32* %arr, i64 %iv
  store i32 %conv, i32* %ptridx2, align 4
  br label %latch

latch:
  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 100
  br i1 %exitcond, label %for.end, label %header

for.end:
  ret void
}
