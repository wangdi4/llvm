; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -passes=vplan-vec -disable-output -vplan-print-after-vls < %s | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%S2 = type { <2 x i32>, i64 }

define void @test_vec_opaque(ptr %p) {
; CHECK-LABEL:  VPlan after VPlan-to-VPlan VLS transformation:
; CHECK-NEXT:  VPlan IR for: test_vec_opaque:header
; CHECK:            [DA: Div] i64 [[VP_IV:%.*]] = phi  [ i64 [[VP_IV_IND_INIT:%.*]], [[BB1:.*]] ],  [ i64 [[VP_IV_NEXT:%.*]], [[BB2:.*]] ]
; CHECK-NEXT:       [DA: Div] i64 [[VP_NEG:%.*]] = sub i64 0 i64 [[VP_IV]]
; CHECK-NEXT:       [DA: Div] ptr [[VP_P0:%.*]] = getelementptr inbounds %S2, ptr [[P0:%.*]] i64 [[VP_NEG]] i32 0
; CHECK-NEXT:       [DA: Div] ptr [[VP_P0_REVERSE_ADJUST:%.*]] = getelementptr i64, ptr [[VP_P0]] i64 -2
; CHECK-NEXT:       [DA: Uni] <4 x i64> [[VP_VLS_LOAD:%.*]] = vls-load ptr [[VP_P0_REVERSE_ADJUST]], group_size=2, group_stride=-2, align=8
; CHECK-NEXT:       [DA: Uni] <4 x i64> [[VP_VLS_LOAD_REVERSE:%.*]] = shufflevector <4 x i64> [[VP_VLS_LOAD]] <4 x i64> [[VP_VLS_LOAD]] <4 x i64> <i64 2, i64 3, i64 0, i64 1>
; CHECK-NEXT:       [DA: Div] i64 [[VP_LD0:%.*]] = vls-extract <4 x i64> [[VP_VLS_LOAD_REVERSE]], group_size=2, group_stride=-2, offset=0
; CHECK-NEXT:       [DA: Div] <2 x i32> [[VP0:%.*]] = bitcast i64 [[VP_LD0]]
; CHECK-NEXT:       [DA: Div] i64 [[VP_LD1:%.*]] = vls-extract <4 x i64> [[VP_VLS_LOAD_REVERSE]], group_size=2, group_stride=-2, offset=1
; CHECK-NEXT:       [DA: Div] i64 [[VP_IV_NEXT]] = add i64 [[VP_IV]] i64 [[VP_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:       [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT:%.*]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB3:BB[0-9]+]], [[BB2]]
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 2) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  %neg = sub i64 0, %iv
  %p0 = getelementptr inbounds %S2, ptr %p, i64 %neg, i32 0
  %p1 = getelementptr inbounds %S2, ptr %p, i64 %neg, i32 1

  %ld0 = load <2 x i32>, ptr %p0
  %ld1 = load i64, ptr %p1

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 128
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
