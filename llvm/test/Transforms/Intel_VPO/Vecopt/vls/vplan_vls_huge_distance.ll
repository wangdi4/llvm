; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -passes=vplan-vec -disable-output -debug-only=ovls < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

;
define void @foo(i32* nocapture %ary) {
; CHECK-LABEL:  Received a request from Client---FORM GROUPS
; CHECK-NEXT:    Received a vector of memrefs (3):
; CHECK-NEXT:    #1 <4 x 32> SStore: store i32 0 i32* [[VP_P0:%.*]]
; CHECK-NEXT:    #2 <4 x 32> SStore: store i32 1 i32* [[VP_P1:%.*]]
; CHECK-NEXT:    #3 <4 x 32> SStore: store i32 3 i32* [[VP_P2:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:    Split the vector memrefs into sub groups of adjacacent memrefs:
; CHECK-NEXT:      Distance is (in bytes) from the first memref of the set
; CHECK:         Set #1
; CHECK-NEXT:    #3 <4 x 32> SStore: store i32 3 i32* [[VP_P2]]   Dist: 0
; CHECK-NEXT:    Set #2
; CHECK-NEXT:    #2 <4 x 32> SStore: store i32 1 i32* [[VP_P1]]   Dist: 0
; CHECK-NEXT:    Set #3
; CHECK-NEXT:    #1 <4 x 32> SStore: store i32 0 i32* [[VP_P0]]   Dist: 0
; CHECK-EMPTY:
; CHECK-NEXT:    Printing Groups- Total Groups 3
; CHECK-NEXT:    Group#1:
; CHECK-NEXT:      Vector Length(in bytes): 64
; CHECK-NEXT:      AccType: SStore, Stride (in bytes): 48
; CHECK-NEXT:      AccessMask(per byte, R to L): 1111
; CHECK-NEXT:     #3 <4 x 32> SStore: store i32 3 i32* [[VP_P2]]
; CHECK-NEXT:    Group#2:
; CHECK-NEXT:      Vector Length(in bytes): 64
; CHECK-NEXT:      AccType: SStore, Stride (in bytes): 48
; CHECK-NEXT:      AccessMask(per byte, R to L): 1111
; CHECK-NEXT:     #2 <4 x 32> SStore: store i32 1 i32* [[VP_P1]]
; CHECK-NEXT:    Group#3:
; CHECK-NEXT:      Vector Length(in bytes): 64
; CHECK-NEXT:      AccType: SStore, Stride (in bytes): 48
; CHECK-NEXT:      AccessMask(per byte, R to L): 1111
; CHECK-NEXT:     #1 <4 x 32> SStore: store i32 0 i32* [[VP_P0]]
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %for.body

for.body:
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %mul = mul nsw i64 %indvars.iv, 4

  ; t0 = ary[4*i + 0];
  %p0 = getelementptr inbounds i32, i32* %ary, i64 %mul
  ; %t0 = load i32, i32* %p0, align 4
  store i32 0, i32* %p0

  ; t1 = ary[4*i + 1];
  %i1 = sub nsw i64 %mul, 400
  %p1 = getelementptr inbounds i32, i32* %ary, i64 %i1
  ; %t1 = load i32, i32* %p1, align 4
  store i32 1, i32* %p1

  ; t2 = ary[4*i - 1001];
  %i2 = sub nsw i64 %mul, 200
  %p2 = getelementptr inbounds i32, i32* %ary, i64 %i2
  ; %t2 = load i32, i32* %p2, align 4
  store i32 3, i32* %p2

  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 3
  %cmp = icmp ult i64 %indvars.iv.next, 3072
  br i1 %cmp, label %for.body, label %for.end

for.end:
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
