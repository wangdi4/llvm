; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -passes=vplan-vec -disable-output -vplan-print-after-vls < %s | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%S1 = type { i64, ptr }

define void @test1(ptr %p) {
; CHECK-LABEL:  VPlan after VPlan-to-VPlan VLS transformation:
; CHECK:            [DA: Uni] <8 x i64> [[VP_VLS_LOAD:%.*]] = vls-load ptr [[VP_P_I64:%.*]], group_size=2, align=8
; CHECK-NEXT:       [DA: Div] i64 [[VP_LD_I64:%.*]] = vls-extract <8 x i64> [[VP_VLS_LOAD]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Div] i64 [[VP_LD_PTR:%.*]] = vls-extract <8 x i64> [[VP_VLS_LOAD]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] ptr [[VP0:%.*]] = inttoptr i64 [[VP_LD_PTR]] to ptr
; CHECK-NEXT:       [DA: Div] ptr [[VP_GEP:%.*]] = getelementptr i8, ptr [[VP0]] i64 [[VP_IV:%.*]]
; CHECK-NEXT:       [DA: Uni] <8 x i64> [[VP_VLS_INSERT:%.*]] = vls-insert <8 x i64> undef i64 [[VP_IV]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Div] i64 [[VP1:%.*]] = ptrtoint ptr [[VP_GEP]] to i64
; CHECK-NEXT:       [DA: Uni] <8 x i64> [[VP_VLS_INSERT_1:%.*]] = vls-insert <8 x i64> [[VP_VLS_INSERT]] i64 [[VP1]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] vls-store <8 x i64> [[VP_VLS_INSERT_1]] ptr [[VP_P_I64]], group_size=2, align=8
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  %p.i64 = getelementptr inbounds %S1, ptr %p, i64 %iv, i32 0
  %p.ptr = getelementptr inbounds %S1, ptr %p, i64 %iv, i32 1

  %ld.i64 = load i64, ptr %p.i64
  %ld.ptr = load ptr, ptr %p.ptr

  %gep = getelementptr i8, ptr %ld.ptr, i64 %iv

  store i64 %iv, ptr %p.i64
  store ptr %gep, ptr %p.ptr

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 128
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

%S2 = type { double, ptr addrspace(1) }

define void @test2(ptr %p) {
; CHECK-LABEL:  VPlan after VPlan-to-VPlan VLS transformation:
; CHECK:            [DA: Uni] <8 x double> [[VP_VLS_LOAD:%.*]] = vls-load ptr [[VP_P_DBL:%.*]], group_size=2, align=8
; CHECK-NEXT:       [DA: Div] double [[VP_LD_DBL:%.*]] = vls-extract <8 x double> [[VP_VLS_LOAD]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Div] double [[VP_LD_PTR:%.*]] = vls-extract <8 x double> [[VP_VLS_LOAD]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] i64 [[VP0:%.*]] = bitcast double [[VP_LD_PTR]]
; CHECK-NEXT:       [DA: Div] ptr addrspace(1) [[VP1:%.*]] = inttoptr i64 [[VP0]] to ptr addrspace(1)
; CHECK-NEXT:       [DA: Div] ptr addrspace(1) [[VP_GEP:%.*]] = getelementptr i8, ptr addrspace(1) [[VP1]] i64 [[VP_IV:%.*]]
; CHECK-NEXT:       [DA: Div] double [[VP_FP:%.*]] = sitofp i64 [[VP_IV]] to double
; CHECK-NEXT:       [DA: Uni] <8 x double> [[VP_VLS_INSERT:%.*]] = vls-insert <8 x double> undef double [[VP_FP]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Div] i64 [[VP2:%.*]] = ptrtoint ptr addrspace(1) [[VP_GEP]] to i64
; CHECK-NEXT:       [DA: Div] double [[VP3:%.*]] = bitcast i64 [[VP2]]
; CHECK-NEXT:       [DA: Uni] <8 x double> [[VP_VLS_INSERT_1:%.*]] = vls-insert <8 x double> [[VP_VLS_INSERT]] double [[VP3]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] vls-store <8 x double> [[VP_VLS_INSERT_1]] ptr [[VP_P_DBL]], group_size=2, align=8
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  %p.dbl = getelementptr inbounds %S2, ptr %p, i64 %iv, i32 0
  %p.ptr = getelementptr inbounds %S2, ptr %p, i64 %iv, i32 1

  %ld.dbl = load double, ptr %p.dbl
  %ld.ptr = load ptr addrspace(1), ptr %p.ptr

  %gep = getelementptr i8, ptr addrspace(1) %ld.ptr, i64 %iv

  %fp = sitofp i64 %iv to double

  store double %fp, ptr %p.dbl
  store ptr addrspace(1) %gep, ptr %p.ptr

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 128
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

%S3 = type { ptr, ptr addrspace(1) }

define void @test3(ptr %p) {
; CHECK-LABEL:  VPlan after VPlan-to-VPlan VLS transformation:
; CHECK:            [DA: Uni] <8 x i64> [[VP_VLS_LOAD:%.*]] = vls-load ptr [[VP_P_PTR1:%.*]], group_size=2, align=8
; CHECK-NEXT:       [DA: Div] i64 [[VP_LD_PTR1:%.*]] = vls-extract <8 x i64> [[VP_VLS_LOAD]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Div] ptr [[VP0:%.*]] = inttoptr i64 [[VP_LD_PTR1]] to ptr
; CHECK-NEXT:       [DA: Div] i64 [[VP_LD_PTR2:%.*]] = vls-extract <8 x i64> [[VP_VLS_LOAD]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] ptr addrspace(1) [[VP1:%.*]] = inttoptr i64 [[VP_LD_PTR2]] to ptr addrspace(1)
; CHECK-NEXT:       [DA: Div] ptr [[VP_GEP1:%.*]] = getelementptr i32, ptr [[VP0]] i64 [[VP_IV:%.*]]
; CHECK-NEXT:       [DA: Div] ptr addrspace(1) [[VP_GEP2:%.*]] = getelementptr i8, ptr addrspace(1) [[VP1]] i64 [[VP_IV]]
; CHECK-NEXT:       [DA: Div] i64 [[VP2:%.*]] = ptrtoint ptr [[VP_GEP1]] to i64
; CHECK-NEXT:       [DA: Uni] <8 x i64> [[VP_VLS_INSERT:%.*]] = vls-insert <8 x i64> undef i64 [[VP2]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Div] i64 [[VP3:%.*]] = ptrtoint ptr addrspace(1) [[VP_GEP2]] to i64
; CHECK-NEXT:       [DA: Uni] <8 x i64> [[VP_VLS_INSERT_1:%.*]] = vls-insert <8 x i64> [[VP_VLS_INSERT]] i64 [[VP3]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] vls-store <8 x i64> [[VP_VLS_INSERT_1]] ptr [[VP_P_PTR1]], group_size=2, align=8
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  %p.ptr1 = getelementptr inbounds %S3, ptr %p, i64 %iv, i32 0
  %p.ptr2 = getelementptr inbounds %S3, ptr %p, i64 %iv, i32 1

  %ld.ptr1 = load ptr, ptr %p.ptr1
  %ld.ptr2 = load ptr addrspace(1), ptr %p.ptr2

  %gep1 = getelementptr i32, ptr %ld.ptr1, i64 %iv
  %gep2 = getelementptr i8, ptr addrspace(1) %ld.ptr2, i64 %iv

  store ptr %gep1, ptr %p.ptr1
  store ptr addrspace(1) %gep2, ptr %p.ptr2

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 128
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

%S4 = type { <2 x i32>, ptr }

define void @test4(ptr %p) {
; CHECK-LABEL:  VPlan after VPlan-to-VPlan VLS transformation:
; CHECK:            [DA: Uni] <8 x ptr> [[VP_VLS_LOAD:%.*]] = vls-load ptr [[VP_P_VECINT:%.*]], group_size=2, align=8
; CHECK-NEXT:       [DA: Div] ptr [[VP_LD_VECINT:%.*]] = vls-extract <8 x ptr> [[VP_VLS_LOAD]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Div] i64 [[VP0:%.*]] = ptrtoint ptr [[VP_LD_VECINT]] to i64
; CHECK-NEXT:       [DA: Div] <2 x i32> [[VP1:%.*]] = bitcast i64 [[VP0]]
; CHECK-NEXT:       [DA: Div] ptr [[VP_LD_PTR:%.*]] = vls-extract <8 x ptr> [[VP_VLS_LOAD]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] <2 x i32> [[VP_SHFL:%.*]] = shufflevector <2 x i32> [[VP1]] <2 x i32> undef <2 x i32> <i32 1, i32 0>
; CHECK-NEXT:       [DA: Div] ptr [[VP_GEP:%.*]] = getelementptr i64, ptr [[VP_LD_PTR]] i64 [[VP_IV:%.*]]
; CHECK-NEXT:       [DA: Div] i64 [[VP2:%.*]] = bitcast <2 x i32> [[VP_SHFL]]
; CHECK-NEXT:       [DA: Div] ptr [[VP3:%.*]] = inttoptr i64 [[VP2]] to ptr
; CHECK-NEXT:       [DA: Uni] <8 x ptr> [[VP_VLS_INSERT:%.*]] = vls-insert <8 x ptr> undef ptr [[VP3]], group_size=2, offset=0
; CHECK-NEXT:       [DA: Uni] <8 x ptr> [[VP_VLS_INSERT_1:%.*]] = vls-insert <8 x ptr> [[VP_VLS_INSERT]] ptr [[VP_GEP]], group_size=2, offset=1
; CHECK-NEXT:       [DA: Div] vls-store <8 x ptr> [[VP_VLS_INSERT_1]] ptr [[VP_P_VECINT]], group_size=2, align=8
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %header

header:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %header ]

  %p.vecint = getelementptr inbounds %S4, ptr %p, i64 %iv, i32 0
  %p.ptr = getelementptr inbounds %S4, ptr %p, i64 %iv, i32 1

  %ld.vecint = load <2 x i32>, ptr %p.vecint
  %ld.ptr = load ptr, ptr %p.ptr

  %shfl = shufflevector <2 x i32> %ld.vecint, <2 x i32> undef, <2 x i32><i32 1, i32 0>
  %gep = getelementptr i64, ptr %ld.ptr, i64 %iv

  store <2 x i32> %shfl, ptr %p.vecint
  store ptr %gep, ptr %p.ptr

  %iv.next = add nuw nsw i64 %iv, 1
  %exitcond = icmp eq i64 %iv.next, 128
  br i1 %exitcond, label %exit, label %header

exit:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
