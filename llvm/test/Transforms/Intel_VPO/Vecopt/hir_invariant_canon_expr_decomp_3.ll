; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -disable-output -vplan-print-after-plain-cfg -vplan-force-invariant-decomposition=0 -vplan-dump-external-defs-hir < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -disable-output -vplan-print-after-plain-cfg -vplan-force-invariant-decomposition=0 -vplan-dump-external-defs-hir < %s 2>&1 | FileCheck %s

;
; LIT test to check that invariant canon expressions are not decomposed and
; get treated as external defs. The loop being vectorized is the inner
; loop in the following:
;
;   for (i1 = 0; i1 < 10; i1++) {
;     mul = n1 * i1;
;     for (i2 = 0; i2 < 100; i2++) {
;       arr[i2] = mul;
;     }
;   }
;
; The use of mul inside the inner loop is invariant. The canon expression
; corresponding to the same is (n1 * i1) and there is no need to decompose
; the same. The test checks that we create an external def for (n1 * i1)
; and that it used correctly in decomposition.
;
; The auto generated checks for external defs are done using CHECK-DAG
; as the order of printing of external defs is non-deterministic. Auto
; generated checks that were unnecessary were also removed.
;

@arr = dso_local local_unnamed_addr global [100 x i64] zeroinitializer, align 16

define dso_local void @foo(i64 %n1) local_unnamed_addr #0 {
; CHECK-LABEL:  VPlan after importing plain CFG
; CHECK-NEXT:  VPlan IR for: foo:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:   [[VP0:%.*]] = {%n1 * i1}
; CHECK-DAG:   [[VP1:%.*]] = {@arr}
; CHECK-NEXT:  External Defs End:
; CHECK:          i64 [[VP2:%.*]] = phi  [ i64 0, {{.*}} ],  [ i64 [[VP3:%.*]], {{.*}} ]
; CHECK-NEXT:     i64* [[VP4:%.*]] = subscript inbounds [100 x i64]* @arr i64 0 i64 [[VP2]]
; CHECK-NEXT:     store i64 [[VP0]] i64* [[VP4]]
;
entry:
  br label %for.body

for.body:                                         ; preds = %for.inc5, %entry
  %i1.016 = phi i64 [ 0, %entry ], [ %inc6, %for.inc5 ]
  %mul1 = mul nsw i64 %i1.016, %n1
  br label %for.body4

for.body4:                                        ; preds = %for.body4, %for.body
  %i2.015 = phi i64 [ 0, %for.body ], [ %inc, %for.body4 ]
  %arrayidx = getelementptr inbounds [100 x i64], [100 x i64]* @arr, i64 0, i64 %i2.015
  store i64 %mul1, i64* %arrayidx, align 8
  %inc = add nuw nsw i64 %i2.015, 1
  %exitcond = icmp eq i64 %inc, 100
  br i1 %exitcond, label %for.inc5, label %for.body4

for.inc5:                                         ; preds = %for.body4
  %inc6 = add nuw nsw i64 %i1.016, 1
  %exitcond17 = icmp eq i64 %inc6, 10
  br i1 %exitcond17, label %for.end7, label %for.body

for.end7:                                         ; preds = %for.inc5
  ret void
}
