; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -disable-output -passes="vplan-vec" -vplan-print-after-initial-transforms -vplan-entities-dump -disable-vplan-codegen -vplan-force-vf=2 -vplan-force-inscan-reduction-vectorization=true -S < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

;; This test is meant as a baseline to demonstrate the changes that would
;; be performed by exclusive scan loop transformation. The future
;; transformation would exchange input and scan phases of inscan reduction.

;; float foo(float *A, float *B, int N) {
;;   float x = 1.0f;
;; #pragma omp simd reduction(inscan, + : x)
;;   for (int i=0; i<N; i++) {
;;     B[i] = x;
;; #pragma omp scan exclusive(x)
;;     x += A[i];
;;   }
;;   return x;
;; }

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define float @_Z3fooPfS_(ptr %A, ptr %B) {
;
; CHECK-LABEL:  VPlan after initial VPlan transforms:
; CHECK-NEXT:  VPlan IR for: _Z3fooPfS_:DIR.VPO.END.GUARD.MEM.MOTION.426.#{{[0-9]+}}
; CHECK-NEXT:  Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Reduction list
; CHECK-NEXT:   (+) Start: ptr [[X_RED0:%.*]]
; CHECK-NEXT:    Linked values: ptr [[VP_X_RED:%.*]], float [[VP_X_REDINSCAN_RED_INIT:%.*]], void [[VP_STORE:%.*]], float [[VP_X_REDINSCAN_RED_FINAL:%.*]],
; CHECK-NEXT:    inscan ReductionKind: exclusive
; CHECK-NEXT:   Memory: ptr [[X_RED0]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: i64 1024 BinOp: i64 [[VP_INDVARS_IV_NEXT:%.*]] = add i64 [[VP_INDVARS_IV:%.*]] i64 [[VP_INDVARS_IV_IND_INIT_STEP:%.*]]
; CHECK-NEXT:    Linked values: i64 [[VP_INDVARS_IV]], i64 [[VP_INDVARS_IV_NEXT]], i64 [[VP_INDVARS_IV_IND_INIT:%.*]], i64 [[VP_INDVARS_IV_IND_INIT_STEP]], i64 [[VP_INDVARS_IV_IND_FINAL:%.*]],
; CHECK-EMPTY:
; CHECK-NEXT:   IntInduction(+) Start: i32 [[VP0:%.*]] Step: i32 1 StartVal: ? EndVal: ? need close form
; CHECK-NEXT:    Linked values: ptr [[VP_I_LINEAR_IV:%.*]], i32 [[VP_I_LINEAR_IV_IND_INIT:%.*]], i32 [[VP_I_LINEAR_IV_IND_INIT_STEP:%.*]], void [[VP_STORE_1:%.*]], i32 [[VP_I_LINEAR_IV_IND_FINAL:%.*]],
; CHECK-NEXT:   Memory: ptr [[I_LINEAR_IV0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  Private list
; CHECK-EMPTY:
; CHECK-NEXT:    Exit instr: float [[VP_ADD3:%.*]] = fadd float [[VP1:%.*]] float [[VP2:%.*]]
; CHECK-NEXT:    Linked values: float [[VP_ADD3]], float [[VP_ADD3_PRIV_FINAL:%.*]],
; CHECK:         [[BB1:BB[0-9]+]]: # preds:
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]]
; CHECK-NEXT:     ptr [[VP_I_LINEAR_IV]] = allocate-priv ptr, OrigAlign = 4
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     ptr [[VP_X_RED]] = allocate-priv ptr, OrigAlign = 4
; CHECK-NEXT:     call i64 4 ptr [[VP_X_RED]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     float [[VP_LOAD:%.*]] = load ptr [[X_RED0]]
; CHECK-NEXT:     float [[VP_X_REDINSCAN_RED_INIT]] = reduction-init-scalar float 0.000000e+00 float [[VP_LOAD]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT]] = induction-init{add} i64 live-in1 i64 1
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_INIT_STEP]] = induction-init-step{add} i64 1
; CHECK-NEXT:     i32 [[VP_LOAD_1:%.*]] = load ptr [[I_LINEAR_IV0]]
; CHECK-NEXT:     i32 [[VP_I_LINEAR_IV_IND_INIT]] = induction-init{add} i32 [[VP_LOAD_1]] i32 1
; CHECK-NEXT:     store i32 [[VP_I_LINEAR_IV_IND_INIT]] ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     i32 [[VP_I_LINEAR_IV_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:     i64 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i64 1024, UF = 1
; CHECK-NEXT:     br [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB0]]: # preds: [[BB2]], [[BB3:BB[0-9]+]]
; CHECK-NEXT:     i64 [[VP_INDVARS_IV]] = phi  [ i64 [[VP_INDVARS_IV_IND_INIT]], [[BB2]] ],  [ i64 [[VP_INDVARS_IV_NEXT]], [[BB3]] ]
; CHECK-NEXT:     float [[VP_INSCAN_ACCUM:%.*]] = phi  [ float [[VP_X_REDINSCAN_RED_INIT]], [[BB2]] ],  [ float [[VP3:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32 [[VP4:%.*]] = phi  [ i32 [[VP_I_LINEAR_IV_IND_INIT]], [[BB2]] ],  [ i32 [[VP5:%.*]], [[BB3]] ]
; CHECK-NEXT:     store i32 [[VP4]] ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     store float 0.000000e+00 ptr [[VP_X_RED]]
; CHECK-NEXT:     br [[BB3:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB0]]
; CHECK-NEXT:     br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:     br [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB4]]
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     i32 [[VP0]] = trunc i64 [[VP_INDVARS_IV]] to i32
; CHECK-NEXT:     store i32 [[VP0]] ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     float [[VP6:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     ptr [[VP_ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[B0:%.*]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     store float [[VP6]] ptr [[VP_ARRAYIDX]]
; CHECK-NEXT:     br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     br [[BB7:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB6]]
; CHECK-NEXT:     float [[VP_LOAD_2:%.*]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP_EXCL_SCAN:%.*]] = running-exclusive-reduction float [[VP_LOAD_2]] float [[VP_INSCAN_ACCUM]] float 0.000000e+00
; CHECK-NEXT:     store float [[VP_EXCL_SCAN]] ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP7:%.*]] = extract-last-vector-lane float [[VP_EXCL_SCAN]]
; CHECK-NEXT:     float [[VP8:%.*]] = extract-last-vector-lane float [[VP_LOAD_2]]
; CHECK-NEXT:     float [[VP3]] = fadd float [[VP7]] float [[VP8]]
; CHECK-NEXT:     br [[BB8:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB7]]
; CHECK-NEXT:     br [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB8]]
; CHECK-NEXT:     i32 [[VP9:%.*]] = load ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     i64 [[VP_IDXPROM1:%.*]] = sext i32 [[VP9]] to i64
; CHECK-NEXT:     ptr [[VP_ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[A0:%.*]] i64 [[VP_IDXPROM1]]
; CHECK-NEXT:     float [[VP2]] = load ptr [[VP_ARRAYIDX2]]
; CHECK-NEXT:     float [[VP1]] = load ptr [[VP_X_RED]]
; CHECK-NEXT:     float [[VP_ADD3]] = fadd float [[VP1]] float [[VP2]]
; CHECK-NEXT:     store float [[VP_ADD3]] ptr [[VP_X_RED]]
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 [[VP_INDVARS_IV_IND_INIT_STEP]]
; CHECK-NEXT:     br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]]
; CHECK-NEXT:     br [[BB11:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]: # preds: [[BB10]]
; CHECK-NEXT:     i32 [[VP5]] = add i32 [[VP4]] i32 [[VP_I_LINEAR_IV_IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp uge i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB12:BB[0-9]+]], [[BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]: # preds: [[BB11]]
; CHECK-NEXT:     float [[VP_X_REDINSCAN_RED_FINAL]] = reduction-final-inscan float [[VP3]]
; CHECK-NEXT:     store float [[VP_X_REDINSCAN_RED_FINAL]] ptr [[X_RED0]]
; CHECK-NEXT:     call i64 4 ptr [[VP_X_RED]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     i64 [[VP_INDVARS_IV_IND_FINAL]] = induction-final{add} i64 0 i64 1
; CHECK-NEXT:     i32 [[VP_LOAD_3:%.*]] = load ptr [[VP_I_LINEAR_IV]]
; CHECK-NEXT:     i32 [[VP_I_LINEAR_IV_IND_FINAL]] = induction-final{add} i32 [[VP_LOAD_1]] i32 1
; CHECK-NEXT:     store i32 [[VP_I_LINEAR_IV_IND_FINAL]] ptr [[I_LINEAR_IV0]]
; CHECK-NEXT:     call i64 4 ptr [[VP_I_LINEAR_IV]] ptr @llvm.lifetime.end.p0
; CHECK-NEXT:     float [[VP_ADD3_PRIV_FINAL]] = private-final-uc float [[VP_ADD3]]
; CHECK-NEXT:     br [[BB13:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]: # preds: [[BB12]]
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0     [[ADD3_LCSSA0:%.*]] = phi float [ [[ADD30:%.*]], [[DIR_OMP_END_SCAN_2280:%.*]] ] float [[VP_ADD3_PRIV_FINAL]] -> float [[ADD30]]
; CHECK-EMPTY:
; CHECK-NEXT:  Id: 1   no underlying for i64 [[VP_INDVARS_IV_IND_FINAL]]
;
DIR.OMP.SIMD.1:
  %x.red = alloca float, align 4
  %i.linear.iv = alloca i32, align 4
  store float 1.000000e+00, ptr %x.red, align 4
  br label %DIR.OMP.SIMD.126

DIR.OMP.SIMD.126:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD:INSCAN.TYPED"(ptr %x.red, float 0.000000e+00, i32 1, i64 1), "QUAL.OMP.NORMALIZED.IV:TYPED"(ptr null, i32 0), "QUAL.OMP.NORMALIZED.UB:TYPED"(ptr null, i32 0), "QUAL.OMP.LINEAR:IV.TYPED"(ptr %i.linear.iv, i32 0, i32 1, i32 1) ]
  br label %DIR.VPO.END.GUARD.MEM.MOTION.426

DIR.VPO.END.GUARD.MEM.MOTION.426:                 ; preds = %DIR.OMP.SIMD.126, %DIR.VPO.END.GUARD.MEM.MOTION.4
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.126 ], [ %indvars.iv.next, %DIR.VPO.END.GUARD.MEM.MOTION.4 ]
  br label %DIR.VPO.GUARD.MEM.MOTION.2

DIR.VPO.GUARD.MEM.MOTION.2:                       ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.426
  %guard.start = call token @llvm.directive.region.entry() [ "DIR.VPO.GUARD.MEM.MOTION"(), "QUAL.OMP.LIVEIN"(ptr %x.red) ]
  br label %DIR.OMP.SIMD.139

DIR.OMP.SIMD.139:                                 ; preds = %DIR.VPO.GUARD.MEM.MOTION.2
  br label %DIR.OMP.END.SCAN.2

DIR.OMP.END.SCAN.2:                               ; preds = %DIR.OMP.SIMD.139
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %i.linear.iv)
  %1 = trunc i64 %indvars.iv to i32
  store i32 %1, ptr %i.linear.iv, align 4
  %2 = load float, ptr %x.red, align 4
  %arrayidx = getelementptr inbounds float, ptr %B, i64 %indvars.iv
  store float %2, ptr %arrayidx, align 4
  br label %DIR.OMP.SCAN.2

DIR.OMP.SCAN.2:                                   ; preds = %DIR.OMP.END.SCAN.2
  %3 = call token @llvm.directive.region.entry() [ "DIR.OMP.SCAN"(), "QUAL.OMP.EXCLUSIVE:TYPED"(ptr %x.red, float 0.000000e+00, i32 1, i64 1) ]
  br label %DIR.OMP.SCAN.1

DIR.OMP.SCAN.1:                                   ; preds = %DIR.OMP.SCAN.2
  fence acq_rel
  br label %DIR.OMP.END.SCAN.4

DIR.OMP.END.SCAN.4:                               ; preds = %DIR.OMP.SCAN.1
  call void @llvm.directive.region.exit(token %3) [ "DIR.OMP.END.SCAN"() ]
  br label %DIR.OMP.END.SCAN.228

DIR.OMP.END.SCAN.228:                             ; preds = %DIR.OMP.END.SCAN.4
  %4 = load i32, ptr %i.linear.iv, align 4
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds float, ptr %A, i64 %idxprom1
  %5 = load float, ptr %arrayidx2, align 4
  %6 = load float, ptr %x.red, align 4
  %add3 = fadd fast float %6, %5
  store float %add3, ptr %x.red, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %i.linear.iv)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %DIR.VPO.END.GUARD.MEM.MOTION.8

DIR.VPO.END.GUARD.MEM.MOTION.8:                   ; preds = %DIR.OMP.END.SCAN.228
  call void @llvm.directive.region.exit(token %guard.start) [ "DIR.VPO.END.GUARD.MEM.MOTION"() ]
  br label %DIR.VPO.END.GUARD.MEM.MOTION.4

DIR.VPO.END.GUARD.MEM.MOTION.4:                   ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.8
  %exitcond.not = icmp eq i64 %indvars.iv.next, 1024
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.6, label %DIR.VPO.END.GUARD.MEM.MOTION.426

DIR.OMP.END.SIMD.6:                               ; preds = %DIR.OMP.END.SCAN.228
  %add3.lcssa = phi float [ %add3, %DIR.VPO.END.GUARD.MEM.MOTION.4 ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:                               ; preds = %DIR.OMP.END.SIMD.6
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %DIR.OMP.END.SIMD.1
  ret float %add3.lcssa
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)

declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)
