; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -hir-cg -disable-output -print-after=hir-vplan-vec  -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>,hir-cg" -disable-output -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
;
; LIT test to check that mask elements are replicated appropriately when
; generating masked loads and stores when the incoming data type is a vector.
; Incoming HIR looks like the following:
;
;        + DO i1 = 0, 127, 1   <DO_LOOP> <simd>
;        |   if (i1 < %n1)
;        |   {
;        |      %0 = (<2 x i64>*)(%larr.bc)[2 * i1];
;        |      %add = %0  +  %val;
;        |      (<2 x i64>*)(%larr.bc)[2 * i1] = %add;
;        |   }
;        + END LOOP
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nofree norecurse nosync nounwind uwtable
define dso_local void @foo(<2 x i64>* noalias nocapture %larr, <2 x i64> %val, i64 %n1) local_unnamed_addr #0 {
; CHECK-LABEL:  Function: foo
; CHECK-EMPTY:
; CHECK-NEXT:    BEGIN REGION { modified }
; CHECK:              + DO i1 = 0, 127, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:         |   %.vec2 = undef
; CHECK-NEXT:         |   %.vec = i1 + <i64 0, i64 1, i64 2, i64 3> < %n1
; CHECK-NEXT:         |   %.replicated.elts = shufflevector %.vec,  undef,  <i32 0, i32 0, i32 1, i32 1, i32 2, i32 2, i32 3, i32 3>
; CHECK-NEXT:         |   %.vec2 = (<8 x i64>*)(%larr.bc)[2 * i1], Mask = @{%.replicated.elts};
; CHECK-NEXT:         |   %.replicated = shufflevector %val,  undef,  <i32 0, i32 1, i32 0, i32 1, i32 0, i32 1, i32 0, i32 1>
; CHECK-NEXT:         |   %.replicated.elts3 = shufflevector %.vec,  undef,  <i32 0, i32 0, i32 1, i32 1, i32 2, i32 2, i32 3, i32 3>
; CHECK-NEXT:         |   (<8 x i64>*)(%larr.bc)[2 * i1] = %.vec2 + %.replicated, Mask = @{%.replicated.elts3};
; CHECK-NEXT:         + END LOOP
; CHECK:              ret
; CHECK-NEXT:    END REGION
;
entry:
  %larr.bc = bitcast <2 x i64>* %larr to i64*
  br label %for.ph

for.ph:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:
  %l1.06 = phi i64 [ 0, %for.ph ], [ %inc, %for.inc ]
  %cmp1 = icmp slt i64 %l1.06, %n1
  br i1 %cmp1, label %if.then, label %for.inc

if.then:
  %idx = mul nsw i64 %l1.06, 2
  %arrayidx.tmp = getelementptr inbounds i64,  i64* %larr.bc, i64 %idx
  %arrayidx = bitcast i64* %arrayidx.tmp to <2 x i64>*
  %0 = load <2 x i64>, <2 x i64>* %arrayidx, align 16
  %add = add <2 x i64> %0, %val
  store <2 x i64> %add, <2 x i64>* %arrayidx, align 16
  br label %for.inc

for.inc:
  %inc = add nuw nsw i64 %l1.06, 1
  %exitcond.not = icmp eq i64 %inc, 128
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
