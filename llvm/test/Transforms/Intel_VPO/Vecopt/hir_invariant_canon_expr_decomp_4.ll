; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-vec-dir-insert -hir-vplan-vec -disable-output -vplan-print-after-plain-cfg -vplan-force-invariant-decomposition=0 < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec" -disable-output -vplan-print-after-plain-cfg -vplan-force-invariant-decomposition=0 < %s 2>&1 | FileCheck %s

;
; LIT test to check that invariant canon expressions are not decomposed and
; get treated as external defs as needed. The loop being vectorized is the
; inner loop in the following:
;
;   for (i1 = 0; i1 < 80; i1++) {
;     for (i2 = 0; i2 < 80; i2++) {
;       arr[i1 + 2][i2] = arr2[i1 / 8][i2 + 4] + 1111;
;       arr3[i1 + arr4[i1][i2]][i2] = i1;
;     }
;   }
;
; (i1 + 2) and i1/8 are invariant. The test also checks that we generate one
; external def for i1.
;
; The auto generated checks for external defs are done using CHECK-DAG
; as the order of printing of external defs is non-deterministic. Auto
; generated checks that were unnecessary were also removed.
;

@arr2 = dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16
@arr = dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16
@arr3 = dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16
@arr4 = dso_local local_unnamed_addr global [100 x [100 x i64]] zeroinitializer, align 16

define void @foo() {
; CHECK-LABEL:  VPlan after importing plain CFG
; CHECK-NEXT:  VPlan IR for: foo:HIR
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {@arr}
; CHECK-DAG:     [[VP1:%.*]] = {%i1}
; CHECK-DAG:     [[VP2:%.*]] = {i1 + 2}
; CHECK-DAG:     [[VP3:%.*]] = {@arr4}
; CHECK-DAG:     [[VP4:%.*]] = {@arr3}
; CHECK-DAG:     [[VP5:%.*]] = {@arr2}
; CHECK-DAG:     [[VP6:%.*]] = {(i1)/u8}
; CHECK-NEXT:  External Defs End:
; CHECK:          i64 [[VP7:%.*]] = phi  [ i64 0, {{.*}} ],  [ i64 [[VP8:%.*]], {{.*}} ]
; CHECK-NEXT:     i64 [[VP9:%.*]] = add i64 [[VP7]] i64 4
; CHECK-NEXT:     i64* [[VP10:%.*]] = subscript inbounds [100 x [100 x i64]]* @arr2 i64 0 i64 [[VP6]] i64 [[VP9]]
; CHECK-NEXT:     i64 [[VP11:%.*]] = load i64* [[VP10]]
; CHECK-NEXT:     i64 [[VP12:%.*]] = add i64 [[VP11]] i64 1111
; CHECK-NEXT:     i64* [[VP13:%.*]] = subscript inbounds [100 x [100 x i64]]* @arr i64 0 i64 [[VP2]] i64 [[VP7]]
; CHECK-NEXT:     store i64 [[VP12]] i64* [[VP13]]
; CHECK-NEXT:     i64* [[VP14:%.*]] = subscript inbounds [100 x [100 x i64]]* @arr4 i64 0 i64 [[I10:%.*]] i64 [[VP7]]
; CHECK-NEXT:     i64 [[VP15:%.*]] = load i64* [[VP14]]
; CHECK-NEXT:     i64 [[VP16:%.*]] = add i64 [[VP15]] i64 [[I10]]
; CHECK-NEXT:     i64* [[VP17:%.*]] = subscript inbounds [100 x [100 x i64]]* @arr3 i64 0 i64 [[VP16]] i64 [[VP7]]
; CHECK-NEXT:     store i64 [[I10]] i64* [[VP17]]
;
entry:
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.inc14, %entry
  %i1.030 = phi i64 [ 0, %entry ], [ %inc15, %for.inc14 ]
  %div = lshr i64 %i1.030, 3
  %add6 = add nuw nsw i64 %i1.030, 2
  br label %for.body3

for.body3:                                        ; preds = %for.body3, %for.cond1.preheader
  %i2.029 = phi i64 [ 0, %for.cond1.preheader ], [ %inc, %for.body3 ]
  %add = add nuw nsw i64 %i2.029, 4
  %arrayidx4 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @arr2, i64 0, i64 %div, i64 %add
  %0 = load i64, i64* %arrayidx4, align 8
  %add5 = add nsw i64 %0, 1111
  %arrayidx8 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @arr, i64 0, i64 %add6, i64 %i2.029
  store i64 %add5, i64* %arrayidx8, align 8
  %arrayidx10 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @arr4, i64 0, i64 %i1.030, i64 %i2.029
  %1 = load i64, i64* %arrayidx10, align 8
  %add11 = add nsw i64 %1, %i1.030
  %arrayidx13 = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* @arr3, i64 0, i64 %add11, i64 %i2.029
  store i64 %i1.030, i64* %arrayidx13, align 8
  %inc = add nuw nsw i64 %i2.029, 1
  %exitcond = icmp eq i64 %inc, 80
  br i1 %exitcond, label %for.inc14, label %for.body3

for.inc14:                                        ; preds = %for.body3
  %inc15 = add nuw nsw i64 %i1.030, 1
  %exitcond31 = icmp eq i64 %inc15, 80
  br i1 %exitcond31, label %for.end16, label %for.cond1.preheader

for.end16:                                        ; preds = %for.inc14
  ret void
}
