; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -hir-ssa-deconstruction -hir-framework -hir-vplan-vec -disable-output -enable-vplan-outer-loop-hir -print-after=hir-vplan-vec  -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-vplan-vec,print<hir>" -disable-output -enable-vplan-outer-loop-hir -vplan-force-vf=4 < %s 2>&1 | FileCheck %s
;
; LIT test to demonstrate ZTT for inner loops generated during vectorization.
;
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@arr = external dso_local local_unnamed_addr global [128 x [128 x i64]], align 16

; Function Attrs: nofree norecurse nosync nounwind uwtable writeonly
define dso_local void @foo(i64 %n1, i64 %n2) local_unnamed_addr #0 {
; CHECK:       + DO i1 = 0, 99, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; CHECK-NEXT:  |   %.vec = %n2 > 0;
; CHECK-NEXT:  |   %unifcond = extractelement %.vec,  0;
; CHECK-NEXT:  |   if (%unifcond == 1)
; CHECK-NEXT:  |   {
; CHECK-NEXT:  |      %phi.temp = 0;
; CHECK-NEXT:  |
; CHECK-NEXT:  |      + UNKNOWN LOOP i2
; CHECK-NEXT:  |      |   <i2 = 0>
; CHECK-NEXT:  |      |   [[BB0:BB[0-9]+]].52:
; CHECK-NEXT:  |      |   (<4 x i64>*)(@arr)[0][i1 + <i64 0, i64 1, i64 2, i64 3>][%phi.temp] = i1 + <i64 0, i64 1, i64 2, i64 3> + %phi.temp + 1111;
; CHECK-NEXT:  |      |   %.vec3 = %phi.temp + 1 <= %n2 + -1;
; CHECK-NEXT:  |      |   %phi.temp = %phi.temp + 1;
; CHECK-NEXT:  |      |   %unifcond5 = extractelement %.vec3,  0;
; CHECK-NEXT:  |      |   if (%unifcond5 == 1)
; CHECK-NEXT:  |      |   {
; CHECK-NEXT:  |      |      <i2 = i2 + 1>
; CHECK-NEXT:  |      |      goto [[BB0]].52;
; CHECK-NEXT:  |      |   }
; CHECK-NEXT:  |      + END LOOP
; CHECK-NEXT:  |   }
; CHECK-NEXT:  + END LOOP
;
entry:
  %cmp217 = icmp sgt i64 %n2, 0
  br label %for.cond1.preheader.preheader

for.cond1.preheader.preheader:                    ; preds = %entry
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.cond1.preheader.preheader, %for.inc6
  %l1.020 = phi i64 [ %inc7, %for.inc6 ], [ 0, %for.cond1.preheader.preheader ]
  %add = add nuw i64 %l1.020, 1111
  br i1 %cmp217, label %for.body3.preheader, label %for.inc6

for.body3.preheader:                              ; preds = %for.cond1.preheader
  br label %for.body3

for.body3:                                        ; preds = %for.body3.preheader, %for.body3
  %l2.018 = phi i64 [ %inc, %for.body3 ], [ 0, %for.body3.preheader ]
  %add4 = add i64 %add, %l2.018
  %arrayidx5 = getelementptr inbounds [128 x [128 x i64]], [128 x [128 x i64]]* @arr, i64 0, i64 %l1.020, i64 %l2.018
  store i64 %add4, i64* %arrayidx5, align 8
  %inc = add nuw nsw i64 %l2.018, 1
  %exitcond.not = icmp eq i64 %inc, %n2
  br i1 %exitcond.not, label %for.inc6.loopexit, label %for.body3

for.inc6.loopexit:                                ; preds = %for.body3
  br label %for.inc6

for.inc6:                                         ; preds = %for.inc6.loopexit, %for.cond1.preheader
  %inc7 = add nuw nsw i64 %l1.020, 1
  %exitcond22.not = icmp eq i64 %inc7, 100
  br i1 %exitcond22.not, label %for.end8.loopexit, label %for.cond1.preheader

for.end8.loopexit:                                ; preds = %for.inc6
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %for.end8

for.end8:                                         ; preds = %for.end8.loopexit, %entry
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
