; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test if debug information for PrivDescr class are generated correctly.

; RUN: opt -S -hir-ssa-deconstruction -hir-framework -hir-vplan-vec  -vplan-print-after-plain-cfg -vplan-entities-dump -vplan-print-legality -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s


; Function Attrs: nounwind uwtable
define void @test_hir_debug(i32* nocapture readonly %iarr)  {
; Check legality dumps
; CHECK-LABEL:  HIRLegality Descriptor Lists
; CHECK:       HIRLegality PrivatesList:
; CHECK-NEXT:  Ref: &(([[A20:%.*]])[0])
; CHECK-NEXT:    UpdateInstructions:
; CHECK-NEXT:             ([[A20]])[0] = [[TMP0:%.*]]
; CHECK-NEXT:  PrivDescr: {IsCond: 0, IsLast: 0, Type: i32}
; CHECK:       HIRLegality PrivatesNonPODList:
; CHECK:       HIRLegality LinearList:
; CHECK:       HIRLegality ReductionList:
; Check LoopEntities dump
; CHECK:       VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: test_hir_debug:HIR
; CHECK:       Loop Entities of the loop with header [[BB0:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:  Induction list
; CHECK-NEXT:   IntInduction(+) Start: i64 0 Step: i64 1 StartVal: i64 0 EndVal: i64 99 BinOp: i64 [[VP2:%.*]] = add i64 [[VP3:%.*]] i64 1
; CHECK-NEXT:    Linked values: i64 [[VP3]], i64 [[VP2]],
; CHECK:       Private list
; CHECK-EMPTY:
; CHECK-NEXT:    Private tag: InMemory
; CHECK-NEXT:    Linked values: i32* [[A20]],
; CHECK-NEXT:   Memory: i32* [[A20]]
;
entry:
  %a2 = alloca i32, align 4
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %entry
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.PRIVATE"(i32* %a2) ]
  br label %DIR.QUAL.LIST.END.2

DIR.QUAL.LIST.END.2:                              ; preds = %DIR.OMP.SIMD.1
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.QUAL.LIST.END.2
  %.omp.iv.05 = phi i64 [ 0, %DIR.QUAL.LIST.END.2 ], [ %add1, %omp.inner.for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %iarr, i64 %.omp.iv.05
  %0 = load i32, i32* %arrayidx, align 4
  store i32 %0, i32* %a2, align 4
  %add1 = add nuw nsw i64 %.omp.iv.05, 1
  %exitcond = icmp eq i64 %add1, 100
  br i1 %exitcond, label %omp.loop.exit, label %omp.inner.for.body

omp.loop.exit:                                    ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.QUAL.LIST.END.3

DIR.QUAL.LIST.END.3:                              ; preds = %omp.loop.exit
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry()

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token)
