; Test to check uniformity of new VPInstructions introduced by predicator and their corresponding lowering
; to LLVM-IR generated by VPValue-based CG.

; RUN: opt -VPlanDriver -vplan-print-after-linearization -disable-vplan-subregions=0 -enable-vp-value-codegen -vplan-force-vf=2 %s < %s -S | FileCheck %s --check-prefixes=CHECK-PREDICATOR,CHECK

; CHECK-PREDICATOR-LABEL: After predication and linearization
; CHECK-PREDICATOR-NOT: {{Divergent.* and}}
; CHECK-PREDICATOR-NOT: {{Divergent.* or}}

; Checks for VPValue-based CG

; CHECK-LABEL:  define void @test_uniform_edge_to_uniform_block
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH:%.*]] ], [ [[INDEX_NEXT:%.*]], [[VPLANNEDBB8:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[TMP22:%.*]], [[VPLANNEDBB8]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VECTOR_PH]] ], [ [[TMP21:%.*]], [[VPLANNEDBB8]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr i32, i32* [[A:%.*]], i32 [[UNI_PHI]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[SCALAR_GEP]] to <2 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, <2 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <2 x i32> [[BROADCAST_SPLAT:%.*]], <i32 42, i32 42>
; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <2 x i1> [[TMP1]], i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = or i1 [[TMP2]], true
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT1:%.*]] = insertelement <2 x i1> undef, i1 [[TMP3]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT2:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT1]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP4:%.*]] = add <2 x i32> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    [[TMP5:%.*]] = xor <2 x i1> [[BROADCAST_SPLAT2]], <i1 true, i1 true>
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <2 x i1> [[TMP5]], i32 0
; CHECK-NEXT:    br i1 [[TMP3]], label [[VPLANNEDBB:%.*]], label [[VPLANNEDBB5:%.*]]

; CHECK:       VPlannedBB:
; CHECK-NEXT:    [[TMP7:%.*]] = or i1 [[TMP2]], true
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT3:%.*]] = insertelement <2 x i1> undef, i1 [[TMP7]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT4:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT3]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP8:%.*]] = add <2 x i32> [[WIDE_LOAD]], <i32 1, i32 1>
; CHECK-NEXT:    [[TMP9:%.*]] = xor <2 x i1> [[BROADCAST_SPLAT4]], <i1 true, i1 true>
; CHECK-NEXT:    [[TMP10:%.*]] = extractelement <2 x i1> [[TMP9]], i32 0
; CHECK-NEXT:    [[TMP11:%.*]] = and i1 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT10:%.*]] = insertelement <2 x i1> undef, i1 [[TMP11]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT11:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT10]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP12:%.*]] = and i1 [[TMP3]], [[TMP10]]
; CHECK-NEXT:    [[TMP13:%.*]] = and i1 [[TMP3]], [[TMP7]]
; CHECK-NEXT:    [[TMP14:%.*]] = and i1 [[TMP3]], [[TMP7]]
; CHECK-NEXT:    br i1 [[TMP7]], label [[VPLANNEDBB7:%.*]], label [[VPLANNEDBB5]]

; CHECK:       VPlannedBB5:
; CHECK-NEXT:    [[VEC_PHI6:%.*]] = phi <2 x i1> [ [[BROADCAST_SPLAT11]], [[VPLANNEDBB]] ], [ zeroinitializer, [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[TMP15:%.*]] = extractelement <2 x i1> [[VEC_PHI6]], i32 0
; CHECK-NEXT:    [[TMP16:%.*]] = or i1 [[TMP15]], [[TMP6]]
; CHECK-NEXT:    [[TMP17:%.*]] = or i1 [[TMP15]], [[TMP6]]
; CHECK-NEXT:    [[TMP18:%.*]] = add <2 x i32> [[WIDE_LOAD]], <i32 2, i32 2>
; CHECK-NEXT:    br label [[VPLANNEDBB8]]

define void @test_uniform_edge_to_uniform_block(i32* %a, i32 %b) local_unnamed_addr {
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;         BB0 (U)<--+
;       /     \     |
;     BB1 (U)  |    |
;    /   \    /     |
;   /     \ /       |
;  BB3   BB2        |
;   \    /          |
;    BB4            |
;     |             |
;    Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.uniform = or i1 %uniform, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.uniform, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)
