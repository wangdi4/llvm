; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Test to check uniformity of new VPInstructions introduced by predicator and their corresponding lowering
; to LLVM-IR generated by VPValue-based CG.

; RUN: opt -VPlanDriver -vplan-print-after-linearization -vplan-force-vf=2 %s < %s -S | FileCheck %s --check-prefixes=CHECK-PREDICATOR,CHECK

; CHECK-PREDICATOR-LABEL: After predication and linearization
; CHECK-PREDICATOR-NOT: {{Divergent.* and}}
; CHECK-PREDICATOR-NOT: {{Divergent.* or}}

define void @test_uniform_edge_to_uniform_block(i32* %a, i32 %b) local_unnamed_addr {
; CHECK-LABEL: @test_uniform_edge_to_uniform_block(
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VECTOR_PH:%.*]] ], [ [[TMP16:%.*]], [[VPLANNEDBB8:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI1:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[TMP15:%.*]], [[VPLANNEDBB8]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VECTOR_PH]] ], [ [[TMP14:%.*]], [[VPLANNEDBB8]] ]
; CHECK:         [[SCALAR_GEP:%.*]] = getelementptr i32, i32* [[A:%.*]], i32 [[UNI_PHI1]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[SCALAR_GEP]] to <2 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, <2 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[B:%.*]], 42
; CHECK-NEXT:    [[TMP2:%.*]] = or i1 [[TMP1]], true
; CHECK-NEXT:    [[TMP3:%.*]] = add <2 x i32> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    br i1 [[TMP2]], label [[VPLANNEDBB:%.*]], label [[VPLANNEDBB2:%.*]]
; CHECK:       VPlannedBB:
; CHECK-NEXT:    [[TMP4:%.*]] = or i1 [[TMP1]], true
; CHECK-NEXT:    [[TMP5:%.*]] = add <2 x i32> [[WIDE_LOAD]], <i32 1, i32 1>
; CHECK-NEXT:    br i1 [[TMP4]], label [[VPLANNEDBB3:%.*]], label [[VPLANNEDBB2]]
; CHECK:       VPlannedBB2:
; CHECK-NEXT:    [[TMP6:%.*]] = add <2 x i32> [[WIDE_LOAD]], <i32 2, i32 2>
; CHECK-NEXT:    br label [[VPLANNEDBB4:%.*]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;         BB0 (U)<--+
;       /     \     |
;     BB1 (U)  |    |
;    /   \    /     |
;   /     \ /       |
;  BB3   BB2        |
;   \    /          |
;    BB4            |
;     |             |
;    Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.uniform = or i1 %uniform, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.uniform, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)
