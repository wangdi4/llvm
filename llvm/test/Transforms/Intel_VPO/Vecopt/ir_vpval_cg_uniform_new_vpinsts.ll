; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Test to check uniformity of new VPInstructions introduced by predicator and their corresponding lowering
; to LLVM-IR generated by VPValue-based CG.

; RUN: opt -VPlanDriver -vplan-print-after-linearization -vplan-force-vf=2 %s < %s -S | FileCheck %s --check-prefixes=CHECK-PREDICATOR,CHECK

; CHECK-PREDICATOR-LABEL: After predication and linearization
; CHECK-PREDICATOR-NOT: {{Divergent.* and}}
; CHECK-PREDICATOR-NOT: {{Divergent.* or}}

define void @test_uniform_edge_to_uniform_block(i32* %a, i32 %b) local_unnamed_addr {
; CHECK-LABEL:  define void @test_uniform_edge_to_uniform_block
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ 0, [[VECTOR_PH:%.*]] ], [ [[INDEX_NEXT:%.*]], [[VPLANNEDBB7:%.*]] ]
; CHECK-NEXT:    [[UNI_PHI:%.*]] = phi i32 [ 0, [[VECTOR_PH]] ], [ [[TMP15:%.*]], [[VPLANNEDBB7]] ]
; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <2 x i32> [ <i32 0, i32 1>, [[VECTOR_PH]] ], [ [[TMP14:%.*]], [[VPLANNEDBB7]] ]
; CHECK-NEXT:    [[SCALAR_GEP:%.*]] = getelementptr i32, i32* [[A:%.*]], i32 [[UNI_PHI]]
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32* [[SCALAR_GEP]] to <2 x i32>*
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, <2 x i32>* [[TMP0]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 [[B:%.*]], 42
; CHECK-NEXT:    [[TMP2:%.*]] = or i1 [[TMP1]], true
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <2 x i1> undef, i1 [[TMP2]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP3:%.*]] = add <2 x i32> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    [[TMP4:%.*]] = xor <2 x i1> [[BROADCAST_SPLAT]], <i1 true, i1 true>
; CHECK-NEXT:    [[DOTEXTRACT_0_5:%.*]] = extractelement <2 x i1> [[TMP4]], i32 0
; CHECK-NEXT:    br i1 [[TMP2]], label %[[VPLANNEDBB:.*]], label %[[VPLANNEDBB3:.*]]
; CHECK:       [[VPLANNEDBB]]:
; CHECK-NEXT:    [[TMP5:%.*]] = or i1 [[TMP1]], true
; CHECK-NEXT:    [[BROADCAST_SPLATINSERT1:%.*]] = insertelement <2 x i1> undef, i1 [[TMP5]], i32 0
; CHECK-NEXT:    [[BROADCAST_SPLAT2:%.*]] = shufflevector <2 x i1> [[BROADCAST_SPLATINSERT1]], <2 x i1> undef, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TMP6:%.*]] = add <2 x i32> [[WIDE_LOAD]], <i32 1, i32 1>
; CHECK-NEXT:    [[TMP7:%.*]] = xor <2 x i1> [[BROADCAST_SPLAT2]], <i1 true, i1 true>
; CHECK-NEXT:    [[DOTEXTRACT_0_:%.*]] = extractelement <2 x i1> [[TMP7]], i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = and i1 [[TMP2]], [[DOTEXTRACT_0_]]
; CHECK-NEXT:    [[TMP9:%.*]] = and i1 [[TMP2]], [[TMP5]]
; CHECK-NEXT:    br i1 [[TMP5]], label [[VPLANNEDBB6:%.*]], label %[[VPLANNEDBB3]]
; CHECK:       [[VPLANNEDBB3]]:
; CHECK-NEXT:    [[UNI_PHI4:%.*]] = phi i1 [ [[TMP8]], %[[VPLANNEDBB]] ], [ false, [[VECTOR_BODY:%.*]] ]
; CHECK-NEXT:    [[TMP10:%.*]] = or i1 [[UNI_PHI4]], [[DOTEXTRACT_0_5]]
; CHECK-NEXT:    [[TMP11:%.*]] = add <2 x i32> [[WIDE_LOAD]], <i32 2, i32 2>
; CHECK-NEXT:    br label [[VPLANNEDBB7]]
;
entry:
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body
;         BB0 (U)<--+
;       /     \     |
;     BB1 (U)  |    |
;    /   \    /     |
;   /     \ /       |
;  BB3   BB2        |
;   \    /          |
;    BB4            |
;     |             |
;    Latch----------+
for.body:
  %indvars.iv = phi i32 [ 0, %entry ], [ %indvars.iv.next, %latch ]
  %gep = getelementptr i32, i32 *%a, i32 %indvars.iv
  %ld = load i32, i32* %gep, align 4
  %uniform = icmp eq i32 %b,  42
  br label %bb0

bb0:
  %bb0.uniform = or i1 %uniform, true
  %bb0.add = add i32 %ld, 0
  br i1 %bb0.uniform, label %bb1, label %bb2

bb1:
  %bb1.uniform = or i1 %uniform, true
  %bb1.add = add i32 %ld, 1
  br i1 %bb1.uniform, label %bb3, label %bb2

bb2:
  %bb2.add = add i32 %ld, 2
  br label %bb4

bb3:
  %bb3.add = add i32 %ld, 3
  br label %bb4

bb4:
  %bb4.add = add i32 %ld, 4
  br label %latch

latch:
  %indvars.iv.next = add nuw nsw i32 %indvars.iv, 1
  %exitcond = icmp eq i32 %indvars.iv.next, 300
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"()]
  ret void
}

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)
