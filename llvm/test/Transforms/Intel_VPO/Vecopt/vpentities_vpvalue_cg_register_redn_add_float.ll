; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check VPlan's VPValue-based vector codegen for simple in-register float add reduction.

; Incoming HIR into vectorizer
; <0>     BEGIN REGION { }
; <2>           %0 = @llvm.directive.region.entry(); [ DIR.OMP.SIMD(),  QUAL.OMP.REDUCTION.ADD(&((%s.red)[0])),  QUAL.OMP.NORMALIZED.IV(null),  QUAL.OMP.NORMALIZED.UB(null) ]
; <3>           (%s.red)[0] = 0.000000e+00;
; <6>           %add618 = 0.000000e+00;
; <23>
; <23>          + DO i1 = 0, sext.i32.i64(%n) + -1, 1   <DO_LOOP> <simd>
; <10>          |   %1 = (%ptr)[i1];
; <11>          |   %add618 = %add618  +  %1;
; <23>          + END LOOP
; <23>
; <19>          (%s.red)[0] = %add618;
; <20>          %2 = %add618  +  1.000000e+01;
; <21>          @llvm.directive.region.exit(%0); [ DIR.OMP.END.SIMD() ]
; <0>     END REGION

; Fully VPValue-based HIR codegen
; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vplan-vec -vplan-force-vf=4 -print-after=hir-vplan-vec -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s --check-prefix=CHECK-HIR
; Mixed HIR codegen
; RUN: opt -hir-ssa-deconstruction -hir-temp-cleanup -hir-vplan-vec -vplan-force-vf=4 -print-after=hir-vplan-vec -disable-output < %s 2>&1 -vplan-enable-new-cfg-merge-hir=0 | FileCheck %s --check-prefix=CHECK-HIR

; CHECK-HIR-LABEL: Function: foo_float
; CHECK-HIR: if (0 <u 4 * [[UB:%.*]])
; CHECK-HIR: [[RED_INIT:%.*]] = -0.000000e+00;
; CHECK-HIR: [[PHI_TEMP:%.*]] = [[RED_INIT]];
; CHECK-HIR: DO i1 = 0, 4 * [[UB]] + -1, 4   <DO_LOOP>
; CHECK-HIR: [[VEC_LD:%.*]] = (<4 x float>*)(%ptr)
; CHECK-HIR: [[RED_ADD:%.*]] = [[PHI_TEMP]] + [[VEC_LD]];
; CHECK-HIR: [[PHI_TEMP]] = [[RED_ADD]];
; CHECK-HIR: END LOOP
; CHECK-HIR: [[INIT:%.*]] = @llvm.vector.reduce.fadd.v4f32([[INIT]],  [[RED_ADD]]);


; Fully VPValue-based LLVM-IR codegen
; RUN: opt -vpo-cfg-restructuring -vplan-vec -vplan-force-vf=4 -S < %s 2>&1 | FileCheck %s --check-prefix=CHECK-LLVMIR

; CHECK-LLVMIR-LABEL: @foo_float
; CHECK-LLVMIR-LABEL: vector.body:
; CHECK-LLVMIR: [[RED_PHI:%.*]] = phi <4 x float> [  <float -0.000000e+00, float -0.000000e+00, float -0.000000e+00, float -0.000000e+00>, [[vectorph:%.*]] ], [ [[RED_ADD:%.*]], %vector.body ]
; CHECK-LLVMIR: [[RED_ADD]] = fadd <4 x float> [[RED_PHI]], {{%.*}}
; CHECK-LLVMIR-LABEL: VPlannedBB6:
; CHECK-LLVMIR: [[RED_LVC:%.*]] = call float @llvm.vector.reduce.fadd.v4f32(float 0.000000e+00, <4 x float> [[RED_ADD]])
; CHECK-LLVMIR-LABEL: merge.blk17:
; CHECK-LLVMIR: [[UNI_PHI80:%.*]] = phi float [ [[RED_LVC]], [[MIDDLE_BLOCK0:%.*]] ], [ 0.000000e+00, [[VPLANNEDBB20:%.*]] ]


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local float @foo_float(float* nocapture readonly %ptr, i32 %n) local_unnamed_addr {
entry:
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %DIR.OMP.SIMD.1, label %omp.precond.end

DIR.OMP.SIMD.1:                                   ; preds = %entry
  %s.red = alloca float, align 4
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(float* %s.red), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  store float 0.000000e+00, float* %s.red, align 4
  %wide.trip.count = sext i32 %n to i64
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.1
  %indvars.iv = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %indvars.iv.next, %omp.inner.for.body ]
  %add618 = phi float [ 0.000000e+00, %DIR.OMP.SIMD.1 ], [ %add6, %omp.inner.for.body ]
  %arrayidx = getelementptr inbounds float, float* %ptr, i64 %indvars.iv
  %1 = load float, float* %arrayidx, align 4, !tbaa !2
  %add6 = fadd float %add618, %1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %omp.inner.for.cond.omp.loop.exit_crit_edge.split.split, label %omp.inner.for.body

omp.inner.for.cond.omp.loop.exit_crit_edge.split.split: ; preds = %omp.inner.for.body
  %add6.lcssa = phi float [ %add6, %omp.inner.for.body ]
  store float %add6.lcssa, float* %s.red, align 4, !tbaa !2
  %2 = fadd float %add6.lcssa, 1.000000e+01
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %omp.inner.for.cond.omp.loop.exit_crit_edge.split.split, %entry
  %s.1 = phi float [ %2, %omp.inner.for.cond.omp.loop.exit_crit_edge.split.split ], [ 1.000000e+01, %entry ]
  ret float %s.1
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }

!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C++ TBAA"}
