; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check VPlan transformation and CG for last private array with SOA layout in masked mode loop.
; TODO: Add HIR check lines when SOA is supported.
; RUN: opt -S -passes=vplan-vec -vplan-force-vf=2 -vplan-print-after-create-masked-vplan -vplan-enable-masked-variant -vplan-vec-scenario="n0;v2;m2" < %s | FileCheck %s


target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define void @foo() {
; CHECK-LABEL:  VPlan after emitting masked variant:
; CHECK-NEXT:  VPlan IR for: foo:omp.inner.for.body.i.#{{[0-9]+}}.cloned.masked
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]]
; CHECK-NEXT:     [DA: Div] ptr [[VP0:%.*]] = allocate-priv [12 x i16], OrigAlign = 2
; CHECK-NEXT:     [DA: Div] call i64 24 ptr [[VP0]] ptr @llvm.lifetime.start.p0
; CHECK-NEXT:     [DA: Div] i32 [[VP2:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP3:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_NORM_UB:%.*]] = sub i32 undef i32 live-in0
; CHECK-NEXT:     [DA: Uni] br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], new_latch
; CHECK-NEXT:     [DA: Div] i32 [[VP__OMP_IV_I_LOCAL_03:%.*]] = phi  [ i32 [[VP_ADD5_I:%.*]], new_latch ],  [ i32 [[VP2]], [[BB1]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP_NEW_IND:%.*]] = add i32 [[VP__OMP_IV_I_LOCAL_03]] i32 live-in0
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = icmp ult i32 [[VP__OMP_IV_I_LOCAL_03]] i32 [[VP_NORM_UB]]
; CHECK-NEXT:     [DA: Div] br i1 [[VP4]], [[BB3:BB[0-9]+]], new_latch
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB3]]: # preds: [[BB2]]
; CHECK-NEXT:       [DA: Div] ptr [[VP_ARRAYIDX_I:%.*]] = getelementptr inbounds [12 x i16], ptr [[VP0]] i64 0 i64 1
; CHECK-NEXT:       [DA: Div] store i16 1 ptr [[VP_ARRAYIDX_I]]
; CHECK-NEXT:       [DA: Uni] br [[BB4:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB3]]
; CHECK-NEXT:       [DA: Uni] br new_latch
; CHECK-EMPTY:
; CHECK-NEXT:    new_latch: # preds: [[BB4]], [[BB2]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_ADD5_I]] = add i32 [[VP__OMP_IV_I_LOCAL_03]] i32 [[VP3]]
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = icmp ult i32 [[VP_ADD5_I]] i32 [[VP_NORM_UB]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP6:%.*]] = all-zero-check i1 [[VP5]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP6]], [[BB5:BB[0-9]+]], [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: new_latch
; CHECK-NEXT:     [DA: Uni] i32 [[VP7:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] private-final-array-masked ptr [[VP0]] ptr [[B3_I_LPRIV0:%.*]] i1 [[VP4]]
; CHECK-NEXT:     [DA: Uni] br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB5]]
; CHECK-NEXT:     [DA: Uni] br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i32 [[VP7]]
; CHECK:       VPlannedBB21:
; CHECK-NEXT:    [[TMP21:%.*]] = bitcast <2 x i1> [[TMP13:%.*]] to i2
; CHECK-NEXT:    [[CTLZ0:%.*]] = call i2 @llvm.ctlz.i2(i2 [[TMP21]], i1 true)
; CHECK-NEXT:    [[TMP22:%.*]] = sub i2 1, [[CTLZ0]]
; CHECK-NEXT:    br label %[[ARRAY_LAST_PRIVATE_LOOP220:.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  array.last.private.loop22:
; CHECK-NEXT:    [[TMP23:%.*]] = phi i64 [ 0, [[VPLANNEDBB210:%.*]] ], [ [[TMP27:%.*]], %[[ARRAY_LAST_PRIVATE_LOOP220]] ]
; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr [12 x <2 x i16>], ptr [[DOTSOA_VEC0:%.*]], i64 0, i64 [[TMP23]], i2 [[TMP22]]
; CHECK-NEXT:    [[TMP25:%.*]] = load i16, ptr [[TMP24]], align 2
; CHECK-NEXT:    [[TMP26:%.*]] = getelementptr [12 x i16], ptr [[B3_I_LPRIV0:%.*]], i64 0, i64 [[TMP23]]
; CHECK-NEXT:    store i16 [[TMP25]], ptr [[TMP26]], align 2
; CHECK-NEXT:    [[TMP27]] = add i64 [[TMP23]], 1
; CHECK-NEXT:    [[TMP28:%.*]] = icmp ult i64 [[TMP27]], 12
; CHECK-NEXT:    br i1 [[TMP28]], label %[[ARRAY_LAST_PRIVATE_LOOP220]], label [[ARRAY_LAST_PRIVATE_LOOP_EXIT230:%.*]]

entry:
  %b3.i.lpriv = alloca [12 x i16], align 1
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.LASTPRIVATE:TYPED"(ptr %b3.i.lpriv, i16 0, i32 12) ]
  br label %omp.inner.for.body.i

omp.inner.for.body.i:                             ; preds = %omp.body.continue.i, %DIR.OMP.SIMD.112
  %.omp.iv.i.local.03 = phi i32 [ %add5.i, %omp.body.continue.i ], [ 0, %DIR.OMP.SIMD.1 ]
  %arrayidx.i = getelementptr inbounds [12 x i16], ptr %b3.i.lpriv, i64 0, i64 1
  store i16 1, ptr %arrayidx.i, align 2
  br label %omp.body.continue.i

omp.body.continue.i:                              ; preds = %if.then.i, %omp.inner.for.body.i
  %add5.i = add nuw nsw i32 %.omp.iv.i.local.03, 1
  %exitcond.not = icmp eq i32 %add5.i, undef
  br i1 %exitcond.not, label %omp.inner.for.cond.i.DIR.OMP.END.SIMD.5.i.loopexit_crit_edge, label %omp.inner.for.body.i

omp.inner.for.cond.i.DIR.OMP.END.SIMD.5.i.loopexit_crit_edge: ; preds = %omp.body.continue.i
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
