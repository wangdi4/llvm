; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt -S -passes="vplan-vec" -vplan-print-after-plain-cfg -vplan-print-after-loop-cfu -vplan-print-after-loop-massaging -vplan-print-after-predicator -vplan-print-block-frequencies -disable-output < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Test to see that block frequency information maintains accuracy throughout
; VPlan transformations that add new basic blocks. Note: we may need to do
; some further corrections in places where blocks are split and new control
; flow is introduced (e.g., loop exit massaging) because some blocks are
; split in ways where block frequency information is copied from one block
; which ends up not dominating that block due to extra edges being added.
; However, this may not be critical so leaving it for now.
; See FIXME below

define dso_local void @_ZGVbN32vvvv_foo(<32 x i32*> noalias nocapture noundef readonly %A, <32 x i32*> noalias nocapture noundef readonly %B, <32 x i32*> noalias nocapture noundef writeonly %C, <32 x i32> noundef %N) local_unnamed_addr #1 {
; CHECK-LABEL:  VPlan after importing plain CFG:
; CHECK-NEXT:  VPlan IR for: _ZGVbN32vvvv_foo:simd.loop.header.#{{[0-9]+}}
; CHECK-NEXT:    [[BB0:BB[0-9]+]]: # preds:  {[[FREQ0:freq: 0]]}
; CHECK-NEXT:     br [[BB1:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]] {[[FREQ8:freq: 8]]}
; CHECK-NEXT:     br [[BB2:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3:BB[0-9]+]] {[[FREQ255:freq: 255]]}
; CHECK-NEXT:     i32 [[VP_INDEX:%.*]] = phi  [ i32 0, [[BB1]] ],  [ i32 [[VP_INDVAR:%.*]], [[BB3]] ]
; CHECK-NEXT:     i32* [[VP_VEC_N_CAST_GEP1:%.*]] = getelementptr i32* [[VEC_N_CAST0:%.*]] i32 [[VP_INDEX]]
; CHECK-NEXT:     i32 [[VP_VEC_N_ELEM2:%.*]] = load i32* [[VP_VEC_N_CAST_GEP1]]
; CHECK-NEXT:     i1 [[VP_CMP15:%.*]] = icmp sgt i32 [[VP_VEC_N_ELEM2]] i32 0
; CHECK-NEXT:     br i1 [[VP_CMP15]], [[BB4:BB[0-9]+]], [[BB5:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]] {[[FREQ159:freq: 159]]}
; CHECK-NEXT:       i64 [[VP_WIDE_TRIP_COUNT18:%.*]] = zext i32 [[VP_VEC_N_ELEM2]] to i64
; CHECK-NEXT:       i32** [[VP_VEC_B_CAST_GEP:%.*]] = getelementptr i32** [[VEC_B_CAST0:%.*]] i32 [[VP_INDEX]]
; CHECK-NEXT:       br [[BB6:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]: # preds: [[BB4]], [[BB7:BB[0-9]+]] {[[FREQ2600:freq: 2600]]}
; CHECK-NEXT:       i64 [[VP_INDVARS_IV:%.*]] = phi  [ i64 0, [[BB4]] ],  [ i64 [[VP_INDVARS_IV_NEXT:%.*]], [[BB7]] ]
; CHECK-NEXT:       i32** [[VP_VEC_A_CAST_GEP:%.*]] = getelementptr i32** [[VEC_A_CAST0:%.*]] i32 [[VP_INDEX]]
; CHECK-NEXT:       i32* [[VP_VEC_A_ELEM:%.*]] = load i32** [[VP_VEC_A_CAST_GEP]]
; CHECK-NEXT:       i32* [[VP_ARRAYIDX:%.*]] = getelementptr inbounds i32* [[VP_VEC_A_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:       i32 [[VP0:%.*]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:       i1 [[VP_CMP1:%.*]] = icmp sgt i32 [[VP0]] i32 7
; CHECK-NEXT:       br i1 [[VP_CMP1]], [[BB8:BB[0-9]+]], [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB7]]: # preds: [[BB6]] {[[FREQ2519:freq: 2519]]}
; CHECK-NEXT:         i32* [[VP_VEC_B_ELEM:%.*]] = load i32** [[VP_VEC_B_CAST_GEP]]
; CHECK-NEXT:         i32* [[VP_ARRAYIDX5:%.*]] = getelementptr inbounds i32* [[VP_VEC_B_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:         i32 [[VP1:%.*]] = load i32* [[VP_ARRAYIDX5]]
; CHECK-NEXT:         i32 [[VP_ADD:%.*]] = add i32 [[VP1]] i32 [[VP0]]
; CHECK-NEXT:         i32** [[VP_VEC_C_CAST_GEP:%.*]] = getelementptr i32** [[VEC_C_CAST0:%.*]] i32 [[VP_INDEX]]
; CHECK-NEXT:         i32* [[VP_VEC_C_ELEM:%.*]] = load i32** [[VP_VEC_C_CAST_GEP]]
; CHECK-NEXT:         i32* [[VP_ARRAYIDX7:%.*]] = getelementptr inbounds i32* [[VP_VEC_C_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:         store i32 [[VP_ADD]] i32* [[VP_ARRAYIDX7]]
; CHECK-NEXT:         i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 1
; CHECK-NEXT:         i1 [[VP_EXITCOND_NOT:%.*]] = icmp eq i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_WIDE_TRIP_COUNT18]]
; CHECK-NEXT:         br i1 [[VP_EXITCOND_NOT]], [[BB8]], [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[BB6]], [[BB7]] {[[FREQ159]]}
; CHECK-NEXT:       br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB2]], [[BB8]] {[[FREQ255]]}
; CHECK-NEXT:     br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB5]] {[[FREQ255]]}
; CHECK-NEXT:     i32 [[VP_INDVAR]] = add i32 [[VP_INDEX]] i32 1
; CHECK-NEXT:     i1 [[VP_VL_COND:%.*]] = icmp ult i32 [[VP_INDVAR]] i32 32
; CHECK-NEXT:     br i1 [[VP_VL_COND]], [[BB2]], [[BB9:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB3]] {[[FREQ8]]}
; CHECK-NEXT:     br [[BB10:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]] {[[FREQ0]]}
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  VPlan after loop massaging:
; CHECK-NEXT:  VPlan IR for: _ZGVbN32vvvv_foo:simd.loop.header.#{{[0-9]+}}
; CHECK-NEXT:    [[BB0]]: # preds:  {[[FREQ0]]}
; CHECK-NEXT:     br [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]] {[[FREQ8]]}
; CHECK-NEXT:     i32 [[VP_INDEX_IND_INIT:%.*]] = induction-init{add} i32 live-in0 i32 1
; CHECK-NEXT:     i32 [[VP_INDEX_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     i32 [[VP_VECTOR_TRIP_COUNT:%.*]] = vector-trip-count i32 32, UF = 1
; CHECK-NEXT:     br [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3]] {[[FREQ255]]}
; CHECK-NEXT:     i32 [[VP_INDEX]] = phi  [ i32 [[VP_INDEX_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVAR]], [[BB3]] ]
; CHECK-NEXT:     i32* [[VP_VEC_N_CAST_GEP1]] = getelementptr i32* [[VEC_N_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:     i32 [[VP_VEC_N_ELEM2]] = load i32* [[VP_VEC_N_CAST_GEP1]]
; CHECK-NEXT:     i1 [[VP_CMP15]] = icmp sgt i32 [[VP_VEC_N_ELEM2]] i32 0
; CHECK-NEXT:     br i1 [[VP_CMP15]], [[BB4]], [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]] {[[FREQ159]]}
; CHECK-NEXT:       i64 [[VP_WIDE_TRIP_COUNT18]] = zext i32 [[VP_VEC_N_ELEM2]] to i64
; CHECK-NEXT:       i32** [[VP_VEC_B_CAST_GEP]] = getelementptr i32** [[VEC_B_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:       br [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]: # preds: [[BB4]], [[NEW_LOOP_LATCH0:new.loop.latch[0-9]+]] {[[FREQ2600]]}
; CHECK-NEXT:       i64 [[VP_INDVARS_IV]] = phi  [ i64 0, [[BB4]] ],  [ i64 [[VP_INDVARS_IV_NEXT_SSA_PHI:%.*]], [[NEW_LOOP_LATCH0]] ]
; CHECK-NEXT:       i32** [[VP_VEC_A_CAST_GEP]] = getelementptr i32** [[VEC_A_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:       i32* [[VP_VEC_A_ELEM]] = load i32** [[VP_VEC_A_CAST_GEP]]
; CHECK-NEXT:       i32* [[VP_ARRAYIDX]] = getelementptr inbounds i32* [[VP_VEC_A_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:       i32 [[VP0]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:       i1 [[VP_CMP1]] = icmp sgt i32 [[VP0]] i32 7
; CHECK-NEXT:       br i1 [[VP_CMP1]], [[INTERMEDIATE_BB0:intermediate.bb[0-9]+]], [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB7]]: # preds: [[BB6]] {[[FREQ2519]]}
; CHECK-NEXT:         i32* [[VP_VEC_B_ELEM]] = load i32** [[VP_VEC_B_CAST_GEP]]
; CHECK-NEXT:         i32* [[VP_ARRAYIDX5]] = getelementptr inbounds i32* [[VP_VEC_B_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:         i32 [[VP1]] = load i32* [[VP_ARRAYIDX5]]
; CHECK-NEXT:         i32 [[VP_ADD]] = add i32 [[VP1]] i32 [[VP0]]
; CHECK-NEXT:         i32** [[VP_VEC_C_CAST_GEP]] = getelementptr i32** [[VEC_C_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:         i32* [[VP_VEC_C_ELEM]] = load i32** [[VP_VEC_C_CAST_GEP]]
; CHECK-NEXT:         i32* [[VP_ARRAYIDX7]] = getelementptr inbounds i32* [[VP_VEC_C_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:         store i32 [[VP_ADD]] i32* [[VP_ARRAYIDX7]]
; CHECK-NEXT:         i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 1
; CHECK-NEXT:         i1 [[VP_EXITCOND_NOT]] = icmp eq i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_WIDE_TRIP_COUNT18]]
; CHECK-NEXT:         br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[INTERMEDIATE_BB0]]: # preds: [[BB6]] {[[FREQ159]]}
; CHECK-NEXT:         br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[NEW_LOOP_LATCH0]]: # preds: [[BB7]], [[INTERMEDIATE_BB0]] {[[FREQ2519]]}
; CHECK-NEXT:       i64 [[VP_INDVARS_IV_NEXT_SSA_PHI]] = phi  [ i64 [[VP_INDVARS_IV_NEXT]], [[BB7]] ],  [ i64 undef, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:       i32 [[VP_EXIT_ID_PHI:%.*]] = phi  [ i32 0, [[BB7]] ],  [ i32 1, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:       i1 [[VP_TAKE_BACKEDGE_COND:%.*]] = phi  [ i1 [[VP_EXITCOND_NOT]], [[BB7]] ],  [ i1 true, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:       br i1 [[VP_TAKE_BACKEDGE_COND]], [[BB8]], [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[NEW_LOOP_LATCH0]] {[[FREQ159]]}
; CHECK-NEXT:       br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB2]], [[BB8]] {[[FREQ255]]}
; CHECK-NEXT:     br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB5]] {[[FREQ255]]}
; CHECK-NEXT:     i32 [[VP_INDVAR]] = add i32 [[VP_INDEX]] i32 [[VP_INDEX_IND_INIT_STEP]]
; CHECK-NEXT:     i1 [[VP_VECTOR_LOOP_EXITCOND:%.*]] = icmp ult i32 [[VP_INDVAR]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB2]], [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB3]] {[[FREQ8]]}
; CHECK-NEXT:     i32 [[VP_INDEX_IND_FINAL:%.*]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     br [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]] {[[FREQ0]]}
; CHECK-NEXT:     br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i32 [[VP_INDEX_IND_FINAL]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlan after LoopCFU transformation:
; CHECK-NEXT:  VPlan IR for: _ZGVbN32vvvv_foo:simd.loop.header.#{{[0-9]+}}
; CHECK-NEXT:    [[BB0]]: # preds:  {[[FREQ0]]}
; CHECK-NEXT:     [DA: Uni] br [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]] {[[FREQ8]]}
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDEX_IND_INIT]] = induction-init{add} i32 live-in0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDEX_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT]] = vector-trip-count i32 32, UF = 1
; CHECK-NEXT:     [DA: Uni] br [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3]] {[[FREQ255]]}
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDEX]] = phi  [ i32 [[VP_INDEX_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVAR]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_VEC_N_CAST_GEP1]] = getelementptr i32* [[VEC_N_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC_N_ELEM2]] = load i32* [[VP_VEC_N_CAST_GEP1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_CMP15]] = icmp sgt i32 [[VP_VEC_N_ELEM2]] i32 0
; CHECK-NEXT:     [DA: Div] br i1 [[VP_CMP15]], [[BB4]], [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB4]]: # preds: [[BB2]] {[[FREQ159]]}
; CHECK-NEXT:       [DA: Div] i64 [[VP_WIDE_TRIP_COUNT18]] = zext i32 [[VP_VEC_N_ELEM2]] to i64
; CHECK-NEXT:       [DA: Div] i32** [[VP_VEC_B_CAST_GEP]] = getelementptr i32** [[VEC_B_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:       [DA: Uni] br [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB6]]: # preds: [[BB4]], [[BB11:BB[0-9]+]] {[[FREQ2600]]}
; CHECK-NEXT:       [DA: Uni] i64 [[VP_INDVARS_IV]] = phi  [ i64 0, [[BB4]] ],  [ i64 [[VP_INDVARS_IV_NEXT_SSA_PHI]], [[BB11]] ]
; CHECK-NEXT:       [DA: Div] i1 [[VP_LOOP_MASK:%.*]] = phi  [ i1 [[VP_CMP15]], [[BB4]] ],  [ i1 [[VP_LOOP_MASK_NEXT:%.*]], [[BB11]] ]
; CHECK-NEXT:       [DA: Div] br i1 [[VP_LOOP_MASK]], [[BB12:BB[0-9]+]], [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[BB12]]: # preds: [[BB6]] {[[FREQ2600]]}
; CHECK-NEXT:         [DA: Div] i32** [[VP_VEC_A_CAST_GEP]] = getelementptr i32** [[VEC_A_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:         [DA: Div] i32* [[VP_VEC_A_ELEM]] = load i32** [[VP_VEC_A_CAST_GEP]]
; CHECK-NEXT:         [DA: Div] i32* [[VP_ARRAYIDX]] = getelementptr inbounds i32* [[VP_VEC_A_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:         [DA: Div] i32 [[VP0]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:         [DA: Div] i1 [[VP_CMP1]] = icmp sgt i32 [[VP0]] i32 7
; CHECK-NEXT:         [DA: Div] br i1 [[VP_CMP1]], [[INTERMEDIATE_BB0]], [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:          [[BB7]]: # preds: [[BB12]] {[[FREQ2519]]}
; CHECK-NEXT:           [DA: Div] i32* [[VP_VEC_B_ELEM]] = load i32** [[VP_VEC_B_CAST_GEP]]
; CHECK-NEXT:           [DA: Div] i32* [[VP_ARRAYIDX5]] = getelementptr inbounds i32* [[VP_VEC_B_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:           [DA: Div] i32 [[VP1]] = load i32* [[VP_ARRAYIDX5]]
; CHECK-NEXT:           [DA: Div] i32 [[VP_ADD]] = add i32 [[VP1]] i32 [[VP0]]
; CHECK-NEXT:           [DA: Div] i32** [[VP_VEC_C_CAST_GEP]] = getelementptr i32** [[VEC_C_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:           [DA: Div] i32* [[VP_VEC_C_ELEM]] = load i32** [[VP_VEC_C_CAST_GEP]]
; CHECK-NEXT:           [DA: Div] i32* [[VP_ARRAYIDX7]] = getelementptr inbounds i32* [[VP_VEC_C_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:           [DA: Div] store i32 [[VP_ADD]] i32* [[VP_ARRAYIDX7]]
; CHECK-NEXT:           [DA: Uni] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 1
; CHECK-NEXT:           [DA: Div] i1 [[VP_EXITCOND_NOT]] = icmp eq i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_WIDE_TRIP_COUNT18]]
; CHECK-NEXT:           [DA: Uni] br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:          [[INTERMEDIATE_BB0]]: # preds: [[BB12]] {[[FREQ159]]}
; CHECK-NEXT:           [DA: Uni] br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:        [[NEW_LOOP_LATCH0]]: # preds: [[BB7]], [[INTERMEDIATE_BB0]] {[[FREQ2519]]}
; CHECK-NEXT:         [DA: Uni] i64 [[VP_INDVARS_IV_NEXT_SSA_PHI]] = phi  [ i64 [[VP_INDVARS_IV_NEXT]], [[BB7]] ],  [ i64 undef, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:         [DA: Div] i32 [[VP_EXIT_ID_PHI]] = phi  [ i32 0, [[BB7]] ],  [ i32 1, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:         [DA: Div] i1 [[VP_TAKE_BACKEDGE_COND]] = phi  [ i1 [[VP_EXITCOND_NOT]], [[BB7]] ],  [ i1 true, [[INTERMEDIATE_BB0]] ]
; CHECK-NEXT:         [DA: Uni] br [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB11]]: # preds: [[NEW_LOOP_LATCH0]], [[BB6]] {[[FREQ2519]]}
; CHECK-NEXT:       [DA: Div] i1 [[VP_TAKE_BACKEDGE_COND_NOT:%.*]] = not i1 [[VP_TAKE_BACKEDGE_COND]]
; CHECK-NEXT:       [DA: Div] i1 [[VP_LOOP_MASK_NEXT]] = select i1 [[VP_LOOP_MASK]] i1 [[VP_TAKE_BACKEDGE_COND_NOT]] i1 false
; CHECK-NEXT:       [DA: Uni] i1 [[VP2:%.*]] = all-zero-check i1 [[VP_LOOP_MASK_NEXT]]
; CHECK-NEXT:       [DA: Uni] br i1 [[VP2]], [[BB8]], [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:      [[BB8]]: # preds: [[BB11]] {[[FREQ159]]}
; CHECK-NEXT:       [DA: Uni] br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB2]], [[BB8]] {[[FREQ255]]}
; CHECK-NEXT:     [DA: Uni] br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB5]] {[[FREQ255]]}
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVAR]] = add i32 [[VP_INDEX]] i32 [[VP_INDEX_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND]] = icmp ult i32 [[VP_INDVAR]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB2]], [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB3]] {[[FREQ8]]}
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDEX_IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]] {[[FREQ0]]}
; CHECK-NEXT:     [DA: Uni] br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i32 [[VP_INDEX_IND_FINAL]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlan after predicator:
; CHECK-NEXT:  VPlan IR for: _ZGVbN32vvvv_foo:simd.loop.header.#{{[0-9]+}}
; CHECK-NEXT:    [[BB0]]: # preds:  {[[FREQ0]]}
; CHECK-NEXT:     [DA: Uni] br [[BB1]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB1]]: # preds: [[BB0]] {[[FREQ8]]}
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDEX_IND_INIT]] = induction-init{add} i32 live-in0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDEX_IND_INIT_STEP]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP_VECTOR_TRIP_COUNT]] = vector-trip-count i32 32, UF = 1
; CHECK-NEXT:     [DA: Uni] br [[BB2]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB2]]: # preds: [[BB1]], [[BB3]] {[[FREQ255]]}
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDEX]] = phi  [ i32 [[VP_INDEX_IND_INIT]], [[BB1]] ],  [ i32 [[VP_INDVAR]], [[BB3]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_VEC_N_CAST_GEP1]] = getelementptr i32* [[VEC_N_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_VEC_N_ELEM2]] = load i32* [[VP_VEC_N_CAST_GEP1]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_CMP15]] = icmp sgt i32 [[VP_VEC_N_ELEM2]] i32 0
; CHECK-NEXT:     [DA: Uni] br [[BB4]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB4]]: # preds: [[BB2]] {[[FREQ159]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP3:%.*]] = block-predicate i1 [[VP_CMP15]]
; CHECK-NEXT:     [DA: Div] i64 [[VP_WIDE_TRIP_COUNT18]] = zext i32 [[VP_VEC_N_ELEM2]] to i64
; CHECK-NEXT:     [DA: Div] i32** [[VP_VEC_B_CAST_GEP]] = getelementptr i32** [[VEC_B_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:     [DA: Uni] br [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB6]]: # preds: [[BB4]], [[BB11]] {[[FREQ2600]]}
; CHECK-NEXT:     [DA: Uni] i64 [[VP_INDVARS_IV]] = phi  [ i64 0, [[BB4]] ],  [ i64 [[VP_INDVARS_IV_NEXT]], [[BB11]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK]] = phi  [ i1 [[VP_CMP15]], [[BB4]] ],  [ i1 [[VP_LOOP_MASK_NEXT]], [[BB11]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP4:%.*]] = block-predicate i1 [[VP_CMP15]]
; CHECK-NEXT:     [DA: Uni] br [[BB13:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB13]]: # preds: [[BB6]] {[[FREQ2600]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB5_BR_VP_LOOP_MASK:%.*]] = select i1 [[VP_CMP15]] i1 [[VP_LOOP_MASK]] i1 false
; CHECK-NEXT:     [DA: Uni] br [[BB12]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB12]]: # preds: [[BB13]] {[[FREQ2600]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP5:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Div] i32** [[VP_VEC_A_CAST_GEP]] = getelementptr i32** [[VEC_A_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:     [DA: Div] i32* [[VP_VEC_A_ELEM]] = load i32** [[VP_VEC_A_CAST_GEP]]
; CHECK-NEXT:     [DA: Div] i32* [[VP_ARRAYIDX]] = getelementptr inbounds i32* [[VP_VEC_A_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP0]] = load i32* [[VP_ARRAYIDX]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_CMP1]] = icmp sgt i32 [[VP0]] i32 7
; CHECK-NEXT:     [DA: Div] i1 [[VP_CMP1_NOT:%.*]] = not i1 [[VP_CMP1]]
; CHECK-NEXT:     [DA: Uni] br [[BB14:BB[0-9]+]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB14]]: # preds: [[BB12]] {[[FREQ2600]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB14_BR_VP_CMP1_NOT:%.*]] = select i1 [[VP_BB5_BR_VP_LOOP_MASK]] i1 [[VP_CMP1_NOT]] i1 false
; CHECK-NEXT:     [DA: Div] i1 [[VP_BB14_BR_VP_CMP1:%.*]] = select i1 [[VP_BB5_BR_VP_LOOP_MASK]] i1 [[VP_CMP1]] i1 false
; CHECK-NEXT:     [DA: Uni] br [[BB7]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB7]]: # preds: [[BB14]] {[[FREQ2519]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP6:%.*]] = block-predicate i1 [[VP_BB14_BR_VP_CMP1_NOT]]
; CHECK-NEXT:     [DA: Div] i32* [[VP_VEC_B_ELEM]] = load i32** [[VP_VEC_B_CAST_GEP]]
; CHECK-NEXT:     [DA: Div] i32* [[VP_ARRAYIDX5]] = getelementptr inbounds i32* [[VP_VEC_B_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] i32 [[VP1]] = load i32* [[VP_ARRAYIDX5]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_ADD]] = add i32 [[VP1]] i32 [[VP0]]
; CHECK-NEXT:     [DA: Div] i32** [[VP_VEC_C_CAST_GEP]] = getelementptr i32** [[VEC_C_CAST0]] i32 [[VP_INDEX]]
; CHECK-NEXT:     [DA: Div] i32* [[VP_VEC_C_ELEM]] = load i32** [[VP_VEC_C_CAST_GEP]]
; CHECK-NEXT:     [DA: Div] i32* [[VP_ARRAYIDX7]] = getelementptr inbounds i32* [[VP_VEC_C_ELEM]] i64 [[VP_INDVARS_IV]]
; CHECK-NEXT:     [DA: Div] store i32 [[VP_ADD]] i32* [[VP_ARRAYIDX7]]
; CHECK-NEXT:     [DA: Uni] i64 [[VP_INDVARS_IV_NEXT]] = add i64 [[VP_INDVARS_IV]] i64 1
; CHECK-NEXT:     [DA: Div] i1 [[VP_EXITCOND_NOT]] = icmp eq i64 [[VP_INDVARS_IV_NEXT]] i64 [[VP_WIDE_TRIP_COUNT18]]
; CHECK-NEXT:     [DA: Uni] br [[INTERMEDIATE_BB0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[INTERMEDIATE_BB0]]: # preds: [[BB7]] {[[FREQ159]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP7:%.*]] = block-predicate i1 [[VP_BB14_BR_VP_CMP1]]
; CHECK-NEXT:     [DA: Uni] br [[NEW_LOOP_LATCH0]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[NEW_LOOP_LATCH0]]: # preds: [[INTERMEDIATE_BB0]] {[[FREQ2519]]}
; CHECK-NEXT:     [DA: Div] i32 [[VP_EXIT_ID_PHI_BLEND_INTERMEDIATE_BB13:%.*]] = blend [ i32 0, i1 [[VP_BB14_BR_VP_CMP1_NOT]] ], [ i32 1, i1 [[VP_BB14_BR_VP_CMP1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP_TAKE_BACKEDGE_COND_BLEND_INTERMEDIATE_BB13:%.*]] = blend [ i1 [[VP_EXITCOND_NOT]], i1 [[VP_BB14_BR_VP_CMP1_NOT]] ], [ i1 true, i1 [[VP_BB14_BR_VP_CMP1]] ]
; CHECK-NEXT:     [DA: Div] i1 [[VP8:%.*]] = block-predicate i1 [[VP_BB5_BR_VP_LOOP_MASK]]
; CHECK-NEXT:     [DA: Uni] br [[BB11]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB11]]: # preds: [[NEW_LOOP_LATCH0]] {[[FREQ2519]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP9:%.*]] = block-predicate i1 [[VP_CMP15]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_TAKE_BACKEDGE_COND_NOT]] = not i1 [[VP_TAKE_BACKEDGE_COND_BLEND_INTERMEDIATE_BB13]]
; CHECK-NEXT:     [DA: Div] i1 [[VP_LOOP_MASK_NEXT]] = select i1 [[VP_LOOP_MASK]] i1 [[VP_TAKE_BACKEDGE_COND_NOT]] i1 false
; CHECK-NEXT:     [DA: Uni] i1 [[VP2]] = all-zero-check i1 [[VP_LOOP_MASK_NEXT]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP2]], [[BB8]], [[BB6]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB8]]: # preds: [[BB11]] {[[FREQ159]]}
; CHECK-NEXT:     [DA: Div] i1 [[VP10:%.*]] = block-predicate i1 [[VP_CMP15]]
; CHECK-NEXT:     [DA: Uni] br [[BB5]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB5]]: # preds: [[BB8]] {[[FREQ255]]}
; CHECK-NEXT:     [DA: Uni] br [[BB3]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB3]]: # preds: [[BB5]] {[[FREQ255]]}
; CHECK-NEXT:     [DA: Div] i32 [[VP_INDVAR]] = add i32 [[VP_INDEX]] i32 [[VP_INDEX_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Uni] i1 [[VP_VECTOR_LOOP_EXITCOND]] = icmp ult i32 [[VP_INDVAR]] i32 [[VP_VECTOR_TRIP_COUNT]]
; CHECK-NEXT:     [DA: Uni] br i1 [[VP_VECTOR_LOOP_EXITCOND]], [[BB2]], [[BB9]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB9]]: # preds: [[BB3]] {[[FREQ8]]}
; CHECK-NEXT:     [DA: Uni] i32 [[VP_INDEX_IND_FINAL]] = induction-final{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] br [[BB10]]
; CHECK-EMPTY:
; CHECK-NEXT:    [[BB10]]: # preds: [[BB9]] {[[FREQ0]]}
; CHECK-NEXT:     [DA: Uni] br <External Block>
; CHECK-EMPTY:
; CHECK-NEXT:  External Uses:
; CHECK-NEXT:  Id: 0   no underlying for i32 [[VP_INDEX_IND_FINAL]]
;
; FIXME: loop massaging splits block BB7 to create new loop latch, so frequency is inherited
;        from BB7. However, control flow is changed and frequency should reflect the dominator
;        BB6.
entry:
  %vec.A = alloca <32 x i32*>, align 256
  %vec.B = alloca <32 x i32*>, align 256
  %vec.C = alloca <32 x i32*>, align 256
  %vec.N = alloca <32 x i32>, align 128
  %vec.A.cast = bitcast <32 x i32*>* %vec.A to i32**
  store <32 x i32*> %A, <32 x i32*>* %vec.A, align 256
  %vec.B.cast = bitcast <32 x i32*>* %vec.B to i32**
  store <32 x i32*> %B, <32 x i32*>* %vec.B, align 256
  %vec.C.cast = bitcast <32 x i32*>* %vec.C to i32**
  store <32 x i32*> %C, <32 x i32*>* %vec.C, align 256
  %vec.N.cast = bitcast <32 x i32>* %vec.N to i32*
  store <32 x i32> %N, <32 x i32>* %vec.N, align 128
  br label %simd.begin.region

simd.begin.region:                                ; preds = %entry
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 32) ]
  br label %simd.loop.preheader

simd.loop.preheader:                              ; preds = %simd.begin.region
  br label %simd.loop.header

simd.loop.header:                                 ; preds = %simd.loop.latch, %simd.loop.preheader
  %index = phi i32 [ 0, %simd.loop.preheader ], [ %indvar, %simd.loop.latch ]
  %vec.N.cast.gep1 = getelementptr i32, i32* %vec.N.cast, i32 %index
  %vec.N.elem2 = load i32, i32* %vec.N.cast.gep1, align 4
  %cmp15 = icmp sgt i32 %vec.N.elem2, 0
  br i1 %cmp15, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %simd.loop.header
  %wide.trip.count18 = zext i32 %vec.N.elem2 to i64
  %vec.B.cast.gep = getelementptr i32*, i32** %vec.B.cast, i32 %index
  br label %for.body

for.body:                                         ; preds = %if.end, %for.body.preheader
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %if.end ]
  %vec.A.cast.gep = getelementptr i32*, i32** %vec.A.cast, i32 %index
  %vec.A.elem = load i32*, i32** %vec.A.cast.gep, align 8
  %arrayidx = getelementptr inbounds i32, i32* %vec.A.elem, i64 %indvars.iv
  %0 = load i32, i32* %arrayidx, align 4
  %cmp1 = icmp sgt i32 %0, 7
  br i1 %cmp1, label %cleanup.loopexit, label %if.end

if.end:                                           ; preds = %for.body
  %vec.B.elem = load i32*, i32** %vec.B.cast.gep, align 8
  %arrayidx5 = getelementptr inbounds i32, i32* %vec.B.elem, i64 %indvars.iv
  %1 = load i32, i32* %arrayidx5, align 4
  %add = add nsw i32 %1, %0
  %vec.C.cast.gep = getelementptr i32*, i32** %vec.C.cast, i32 %index
  %vec.C.elem = load i32*, i32** %vec.C.cast.gep, align 8
  %arrayidx7 = getelementptr inbounds i32, i32* %vec.C.elem, i64 %indvars.iv
  store i32 %add, i32* %arrayidx7, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count18
  br i1 %exitcond.not, label %cleanup.loopexit, label %for.body

cleanup.loopexit:                                 ; preds = %if.end, %for.body
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %simd.loop.header
  br label %simd.loop.latch

simd.loop.latch:                                  ; preds = %cleanup
  %indvar = add nuw i32 %index, 1
  %vl.cond = icmp ult i32 %indvar, 32
  br i1 %vl.cond, label %simd.loop.header, label %simd.end.region

simd.end.region:                                  ; preds = %simd.loop.latch
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:                                           ; preds = %simd.end.region
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #2

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #2
