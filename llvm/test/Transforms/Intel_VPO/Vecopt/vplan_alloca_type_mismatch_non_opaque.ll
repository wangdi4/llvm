; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;; Test that we proces correctly if the alloca and reduction type are different.
;; This is only relevant to non-opaque pointers.
;; Once non-opaque pointers are retired, remove this test.

; RUN: opt -passes="vplan-vec" -vplan-force-vf=2 -S < %s 2>&1 | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"
target device_triples = "spir64"

%"struct.std::complex" = type { { float, float } }
%struct.my_udr = type { %"struct.std::complex" }

define void @repro(i32* %tid, i32* %bid, %"struct.std::complex"* %a.map.ptr.tmp.fp110.0.val, %"struct.std::complex"* %b.map.ptr.tmp.fp112.0.val, %"struct.std::complex"* %c.map.ptr.tmp.fp114.0.val, %struct.my_udr* %tmpcast, i64 %.omp.lb.fp.val.zext, i32* %.omp.ub) {
; CHECK-LABEL: define void @repro(

; CHECK:         [[FAST_RED_STRUCT:%.*]] = alloca <2 x float>, align 8
; CHECK:         [[TMPCAST_RED:%.*]] = alloca <2 x float>, align 8
; CHECK:         [[TMPCAST8:%.*]] = bitcast <2 x float>* [[TMPCAST_RED]] to %struct.my_udr*
; CHECK:         [[TMPCAST8_VEC:%.*]] = alloca <4 x float>, align 16
; CHECK-NEXT:    [[TMPCAST8_VEC_BCAST:%.*]] = bitcast <4 x float>* [[TMPCAST8_VEC]] to <2 x float>*
; CHECK-NEXT:    [[TMPCAST8_VEC_BCAST_BASE_ADDR:%.*]] = getelementptr <2 x float>, <2 x float>* [[TMPCAST8_VEC_BCAST]], <2 x i32> <i32 0, i32 1>

; CHECK:       VPlannedBB2:
; CHECK:         [[TMPCAST8_VEC_BCAST_BCAST:%.*]] = bitcast <2 x <2 x float>*> [[TMPCAST8_VEC_BCAST_BASE_ADDR]] to <2 x %struct.my_udr*>
; CHECK:         [[TMPCAST8_VEC_BCAST_BASE_ADDR_EXTRACT_1_:%.*]] = extractelement <2 x %struct.my_udr*> [[TMPCAST8_VEC_BCAST_BCAST]], i32 1
; CHECK:         [[TMPCAST8_VEC_BCAST_BASE_ADDR_EXTRACT_0_:%.*]] = extractelement <2 x %struct.my_udr*> [[TMPCAST8_VEC_BCAST_BCAST]], i32 0
; CHECK:         call void @.omp_initializer.(%struct.my_udr* [[TMPCAST8_VEC_BCAST_BASE_ADDR_EXTRACT_0_]], %struct.my_udr* [[TMPCAST8]])
; CHECK:         call void @.omp_initializer.(%struct.my_udr* [[TMPCAST8_VEC_BCAST_BASE_ADDR_EXTRACT_1_]], %struct.my_udr* [[TMPCAST8]])

; CHECK:       vector.body:

; CHECK:       VPlannedBB6:
; CHECK:         [[MM_VECTORGEP:%.*]] = getelementptr inbounds %struct.my_udr, <2 x %struct.my_udr*> [[TMPCAST8_VEC_BCAST_BCAST]], <2 x i64> zeroinitializer, <2 x i32> zeroinitializer, <2 x i32> zeroinitializer, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[WIDE_MASKED_GATHER:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[MM_VECTORGEP]], i32 4, <2 x i1> <i1 true, i1 true>, <2 x float> poison)
; CHECK-NEXT:    [[MM_VECTORGEP11:%.*]] = getelementptr inbounds %struct.my_udr, <2 x %struct.my_udr*> [[TMPCAST8_VEC_BCAST_BCAST]], <2 x i64> zeroinitializer, <2 x i32> zeroinitializer, <2 x i32> zeroinitializer, <2 x i32> <i32 1, i32 1>
; CHECK-NEXT:    [[WIDE_MASKED_GATHER12:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[MM_VECTORGEP11]], i32 4, <2 x i1> <i1 true, i1 true>, <2 x float> poison)
; CHECK-NEXT:    [[TMP16:%.*]] = fadd fast <2 x float> [[WIDE_MASKED_GATHER]], [[TMP12:%.*]]
; CHECK-NEXT:    [[TMP17:%.*]] = fadd fast <2 x float> [[WIDE_MASKED_GATHER12]], [[TMP13:%.*]]
; CHECK-NEXT:    call void @llvm.masked.scatter.v2f32.v2p0f32(<2 x float> [[TMP16]], <2 x float*> [[MM_VECTORGEP]], i32 4, <2 x i1> <i1 true, i1 true>)
; CHECK-NEXT:    call void @llvm.masked.scatter.v2f32.v2p0f32(<2 x float> [[TMP17]], <2 x float*> [[MM_VECTORGEP11]], i32 4, <2 x i1> <i1 true, i1 true>)
;
DIR.OMP.SIMD.10:
  %i.priv = alloca i32, align 4
  %is.last = alloca i32, align 4
  %lower.bnd = alloca i32, align 4
  %upper.bnd = alloca i32, align 4
  %stride = alloca i32, align 4
  %upperD = alloca i32, align 4
  %fast_red_struct = alloca <2 x float>, align 8
  %tmpcast.red = alloca <2 x float>, align 8
  %tmpcast8 = bitcast <2 x float>* %tmpcast.red to %struct.my_udr*
  store i32 0, i32* %is.last, align 4
  store <2 x float> zeroinitializer, <2 x float>* %tmpcast.red, align 8
  %0 = load i32, i32* %.omp.ub, align 4
  %cmp7.not117 = icmp slt i32 %0, 0
  br i1 %cmp7.not117, label %DIR.OMP.END.SIMD.12.loopexit, label %omp.inner.for.body.lr.ph

omp.inner.for.body.lr.ph:                         ; preds = %DIR.OMP.SIMD.10
  %my.tid = load i32, i32* %tid, align 4
  store i32 0, i32* %lower.bnd, align 4
  store i32 %0, i32* %upper.bnd, align 4
  store i32 1, i32* %stride, align 4
  store i32 %0, i32* %upperD, align 4
  %lb.new = load i32, i32* %lower.bnd, align 4
  %ub.new = load i32, i32* %upper.bnd, align 4
  %omp.ztt.not = icmp ugt i32 %lb.new, %ub.new
  br i1 %omp.ztt.not, label %loop.region.exit, label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %omp.inner.for.body.lr.ph
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.UDR"(%struct.my_udr* %tmpcast8, i8* null, i8* null, void (%struct.my_udr*, %struct.my_udr*)* @.omp_combiner., void (%struct.my_udr*, %struct.my_udr*)* @.omp_initializer.), "QUAL.OMP.LINEAR:IV"(i32* %i.priv, i32 1) ]
  br label %DIR.OMP.SIMD.120

DIR.OMP.SIMD.120:                                 ; preds = %DIR.OMP.SIMD.1
  %2 = bitcast i32* %i.priv to i8*
  %3 = zext i32 %lb.new to i64
  %4 = add nuw nsw i32 %ub.new, 1
  %wide.trip.count = zext i32 %4 to i64
  br label %DIR.VPO.END.GUARD.MEM.MOTION.313

DIR.VPO.END.GUARD.MEM.MOTION.313:                 ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.3, %DIR.OMP.SIMD.120
  %indvars.iv = phi i64 [ %indvars.iv.next, %DIR.VPO.END.GUARD.MEM.MOTION.3 ], [ %3, %DIR.OMP.SIMD.120 ]
  br label %DIR.VPO.GUARD.MEM.MOTION.2.split

DIR.VPO.GUARD.MEM.MOTION.2.split:                 ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.313
  %guard.start = call token @llvm.directive.region.entry() [ "DIR.VPO.GUARD.MEM.MOTION"(), "QUAL.OMP.LIVEIN"(%struct.my_udr* %tmpcast8) ]
  br label %DIR.VPO.GUARD.MEM.MOTION.2

DIR.VPO.GUARD.MEM.MOTION.2:                       ; preds = %DIR.VPO.GUARD.MEM.MOTION.2.split
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %2)
  %arrayidx = getelementptr inbounds %"struct.std::complex", %"struct.std::complex"* %a.map.ptr.tmp.fp110.0.val, i64 %indvars.iv
  %5 = bitcast %"struct.std::complex"* %arrayidx to <2 x float>*
  %6 = load <2 x float>, <2 x float>* %5, align 4
  %_M_value.realp.i.i.i94 = getelementptr inbounds %"struct.std::complex", %"struct.std::complex"* %b.map.ptr.tmp.fp112.0.val, i64 %indvars.iv, i32 0, i32 0
  %_M_value.real.i.i.i = load float, float* %_M_value.realp.i.i.i94, align 4
  %_M_value.imagp.i.i.i95 = getelementptr inbounds %"struct.std::complex", %"struct.std::complex"* %b.map.ptr.tmp.fp112.0.val, i64 %indvars.iv, i32 0, i32 1
  %_M_value.imag.i.i.i = load float, float* %_M_value.imagp.i.i.i95, align 4
  %retval.i92.sroa.0.0.vec.extract = extractelement <2 x float> %6, i64 0
  %retval.i92.sroa.0.4.vec.extract = extractelement <2 x float> %6, i64 1
  %add.r.i.i = fadd fast float %retval.i92.sroa.0.0.vec.extract, %_M_value.real.i.i.i
  %add.i.i.i = fadd fast float %_M_value.imag.i.i.i, %retval.i92.sroa.0.4.vec.extract
  %retval.i92.sroa.0.0.vec.insert = insertelement <2 x float> poison, float %add.r.i.i, i64 0
  %retval.i92.sroa.0.4.vec.insert = insertelement <2 x float> %retval.i92.sroa.0.0.vec.insert, float %add.i.i.i, i64 1
  %arrayidx15 = getelementptr inbounds %"struct.std::complex", %"struct.std::complex"* %c.map.ptr.tmp.fp114.0.val, i64 %indvars.iv
  %7 = bitcast %"struct.std::complex"* %arrayidx15 to <2 x float>*
  store <2 x float> %retval.i92.sroa.0.4.vec.insert, <2 x float>* %7, align 4
  %_M_value.realp.i = getelementptr inbounds %struct.my_udr, %struct.my_udr* %tmpcast8, i64 0, i32 0, i32 0, i32 0
  %_M_value.real.i = load float, float* %_M_value.realp.i, align 4
  %_M_value.imagp.i = getelementptr inbounds %struct.my_udr, %struct.my_udr* %tmpcast8, i64 0, i32 0, i32 0, i32 1
  %_M_value.imag.i = load float, float* %_M_value.imagp.i, align 4
  %add.r.i = fadd fast float %_M_value.real.i, %add.r.i.i
  %add.i.i = fadd fast float %_M_value.imag.i, %add.i.i.i
  store float %add.r.i, float* %_M_value.realp.i, align 4
  store float %add.i.i, float* %_M_value.imagp.i, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %2)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br label %DIR.VPO.END.GUARD.MEM.MOTION.4

DIR.VPO.END.GUARD.MEM.MOTION.4:                   ; preds = %DIR.VPO.GUARD.MEM.MOTION.2
  call void @llvm.directive.region.exit(token %guard.start) [ "DIR.VPO.END.GUARD.MEM.MOTION"() ]
  br label %DIR.VPO.END.GUARD.MEM.MOTION.3

DIR.VPO.END.GUARD.MEM.MOTION.3:                   ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.4
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %DIR.OMP.END.SIMD.4, label %DIR.VPO.END.GUARD.MEM.MOTION.313

DIR.OMP.END.SIMD.4:                               ; preds = %DIR.VPO.END.GUARD.MEM.MOTION.3
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.421

DIR.OMP.END.SIMD.421:                             ; preds = %DIR.OMP.END.SIMD.4
  %.fca.0.0.0.gep.phi.trans.insert = getelementptr inbounds <2 x float>, <2 x float>* %tmpcast.red, i64 0, i64 0
  %.fca.0.0.0.load.pre = load float, float* %.fca.0.0.0.gep.phi.trans.insert, align 8
  %.phi.trans.insert = getelementptr inbounds <2 x float>, <2 x float>* %tmpcast.red, i64 0, i64 1
  %.fca.0.0.1.load.pre = load float, float* %.phi.trans.insert, align 4
  br label %loop.region.exit

loop.region.exit:                                 ; preds = %DIR.OMP.END.SIMD.421, %omp.inner.for.body.lr.ph
  %.fca.0.0.1.load = phi float [ 0.000000e+00, %omp.inner.for.body.lr.ph ], [ %.fca.0.0.1.load.pre, %DIR.OMP.END.SIMD.421 ]
  %.fca.0.0.0.load = phi float [ 0.000000e+00, %omp.inner.for.body.lr.ph ], [ %.fca.0.0.0.load.pre, %DIR.OMP.END.SIMD.421 ]
  %.fca.0.0.1.insert.fca.0.0.0.gep = getelementptr inbounds <2 x float>, <2 x float>* %fast_red_struct, i64 0, i64 0
  store float %.fca.0.0.0.load, float* %.fca.0.0.1.insert.fca.0.0.0.gep, align 8
  %8 = getelementptr inbounds <2 x float>, <2 x float>* %fast_red_struct, i64 0, i64 1
  store float %.fca.0.0.1.load, float* %8, align 4
  %9 = bitcast <2 x float>* %fast_red_struct to i8*
  %my.tid123 = load i32, i32* %tid, align 4
  %to.tree.reduce = icmp eq i32 %my.tid123, 1
  br i1 %to.tree.reduce, label %tree.reduce, label %DIR.OMP.END.SIMD.12.loopexit

tree.reduce:                                      ; preds = %loop.region.exit
  %agg.tmp.sroa.0.0.copyload.i = load <2 x float>, <2 x float>* %fast_red_struct, align 8
  %agg.tmp2.sroa.0.0..sroa_cast.i = bitcast %struct.my_udr* %tmpcast to <2 x float>*
  %agg.tmp2.sroa.0.0.copyload.i = load <2 x float>, <2 x float>* %agg.tmp2.sroa.0.0..sroa_cast.i, align 4
  %b.i.0.vec.extract.i = extractelement <2 x float> %agg.tmp2.sroa.0.0.copyload.i, i64 0
  %b.i.4.vec.extract.i = extractelement <2 x float> %agg.tmp2.sroa.0.0.copyload.i, i64 1
  %retval.i.i.sroa.0.0.vec.extract.i = extractelement <2 x float> %agg.tmp.sroa.0.0.copyload.i, i64 0
  %retval.i.i.sroa.0.4.vec.extract.i = extractelement <2 x float> %agg.tmp.sroa.0.0.copyload.i, i64 1
  %add.r.i.i.i.i = fadd fast float %b.i.0.vec.extract.i, %retval.i.i.sroa.0.0.vec.extract.i
  %add.i.i.i.i.i = fadd fast float %b.i.4.vec.extract.i, %retval.i.i.sroa.0.4.vec.extract.i
  %retval.i.i.sroa.0.0.vec.insert.i = insertelement <2 x float> poison, float %add.r.i.i.i.i, i64 0
  %retval.i.i.sroa.0.4.vec.insert.i = insertelement <2 x float> %retval.i.i.sroa.0.0.vec.insert.i, float %add.i.i.i.i.i, i64 1
  store <2 x float> %retval.i.i.sroa.0.4.vec.insert.i, <2 x float>* %agg.tmp2.sroa.0.0..sroa_cast.i, align 4
  %my.tid124 = load i32, i32* %tid, align 4
  br label %DIR.OMP.END.SIMD.12.loopexit

DIR.OMP.END.SIMD.12.loopexit:                     ; preds = %tree.reduce, %loop.region.exit, %DIR.OMP.SIMD.10
  ret void
}

declare void @.omp_combiner.(%struct.my_udr*, %struct.my_udr*)

declare void @.omp_initializer.(%struct.my_udr*, %struct.my_udr*)

declare token @llvm.directive.region.entry()

declare void @llvm.directive.region.exit(token)

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8*)

declare void @llvm.lifetime.end.p0i8(i64 immarg, i8*)
