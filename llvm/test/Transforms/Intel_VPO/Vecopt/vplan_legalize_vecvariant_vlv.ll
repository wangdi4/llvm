; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2
; RUN: opt -mtriple=x86_64 -mcpu=skylake-avx512 -passes="vplan-vec" -vec-clone-legalize-enabled -S < %s | FileCheck %s
; RUN: opt -mtriple=x86_64 -mcpu=skylake-avx512 -passes="hir-ssa-deconstruction,hir-vec-dir-insert,hir-vplan-vec,print<hir>" -vec-clone-legalize-enabled -disable-output < %s 2>&1 | FileCheck %s --check-prefix=HIR

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #0

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #0

; Check that VPlan correctly legalizes arguments and return value for
; a vector variant _ZGVyN4vlv_foo of "foo".
; Check that first vector argument is legalized while 2dn and 3d arguments
; (linear and vector respectively) do not require legalization.
; The return value does require legalization.

declare i64 @foo(i64, i64, i32) local_unnamed_addr #1

define i32 @caller() local_unnamed_addr #2 {
; CHECK:       vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i64 [ 0, [[VPLANNEDBB10:%.*]] ], [ [[TMP4:%.*]], [[VECTOR_BODY0:%.*]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <4 x i64> [ <i64 0, i64 1, i64 2, i64 3>, [[VPLANNEDBB10]] ], [ [[TMP3:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[SCALAR_GEP0:%.*]] = getelementptr inbounds [256 x i32], ptr [[B0:%.*]], i64 0, i64 [[UNI_PHI0]]
; CHECK-NEXT:    [[WIDE_LOAD0:%.*]] = load <4 x i32>, ptr [[SCALAR_GEP0]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = call x86_regcallcc { <2 x i64>, <2 x i64> } @_ZGVyN4vlv_foo(<2 x i64> <i64 256, i64 256>, <2 x i64> <i64 256, i64 256>, i64 [[UNI_PHI0]], <4 x i32> [[WIDE_LOAD0]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { <2 x i64>, <2 x i64> } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { <2 x i64>, <2 x i64> } [[TMP0]], 1
; CHECK-NEXT:    [[COMBINED0:%.*]] = shufflevector <2 x i64> [[TMP1]], <2 x i64> [[TMP2]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[SCALAR_GEP30:%.*]] = getelementptr inbounds [256 x i64], ptr [[A0:%.*]], i64 0, i64 [[UNI_PHI0]]
; CHECK-NEXT:    store <4 x i64> [[COMBINED0]], ptr [[SCALAR_GEP30]], align 16
; CHECK-NEXT:    [[TMP3]] = add nuw nsw <4 x i64> [[VEC_PHI0]], <i64 4, i64 4, i64 4, i64 4>
; CHECK-NEXT:    [[TMP4]] = add nuw nsw i64 [[UNI_PHI0]], 4
; CHECK-NEXT:    [[TMP5:%.*]] = icmp uge i64 [[TMP4]], 256
; CHECK-NEXT:    br i1 [[TMP5]], label [[VPLANNEDBB40:%.*]], label [[VECTOR_BODY0]], !llvm.loop !0
;
; HIR-LABEL:  Function: caller
; HIR-EMPTY:
; HIR-NEXT:  BEGIN REGION { modified }
; HIR-NEXT:        + DO i1 = 0, 255, 4   <DO_LOOP> <simd-vectorized> <novectorize>
; HIR-NEXT:        |   [[DOTVEC0:%.*]] = (<4 x i32>*)([[B0:%.*]])[0][i1]
; HIR-NEXT:        |   [[DOTEXTRACTED_SUBVEC0:%.*]] = shufflevector 256,  undef,  <i32 0, i32 1>
; HIR-NEXT:        |   [[DOTEXTRACTED_SUBVEC20:%.*]] = shufflevector 256,  undef,  <i32 2, i32 3>
; HIR-NEXT:        |   [[_ZGVYN4VLV_FOO0:%.*]] = @_ZGVyN4vlv_foo([[DOTEXTRACTED_SUBVEC0]],  [[DOTEXTRACTED_SUBVEC20]],  i1,  [[DOTVEC0]])
; HIR-NEXT:        |   [[EXTRACT_RESULT0:%.*]] = extractvalue [[_ZGVYN4VLV_FOO0]], 0
; HIR-NEXT:        |   [[EXTRACT_RESULT30:%.*]] = extractvalue [[_ZGVYN4VLV_FOO0]], 1
; HIR-NEXT:        |   [[COMB_SHUF0:%.*]] = shufflevector [[EXTRACT_RESULT0]],  [[EXTRACT_RESULT30]],  <i32 0, i32 1, i32 2, i32 3>
; HIR-NEXT:        |   (<4 x i64>*)([[A0:%.*]])[0][i1] = [[COMB_SHUF0]]
; HIR-NEXT:        + END LOOP
; HIR-NEXT:  END REGION
;
omp.inner.for.body.lr.ph:
  %a = alloca [256 x i64], align 16
  %b = alloca [256 x i32], align 8
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %omp.inner.for.body.lr.ph
  %tok = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 4) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.1
  %.omp.iv.local = phi i64 [ 0, %DIR.OMP.SIMD.1 ], [ %add2, %omp.inner.for.body ]
  %arrayidx = getelementptr inbounds [256 x i32], ptr %b, i64 0, i64 %.omp.iv.local
  %x = load i32, ptr %arrayidx, align 8
  %call = call i64 @foo(i64 256, i64 %.omp.iv.local, i32 %x)
  %arrayidx1 = getelementptr inbounds [256 x i64], ptr %a, i64 0, i64 %.omp.iv.local
  store i64 %call, ptr %arrayidx1, align 8
  %add2 = add nuw nsw i64 %.omp.iv.local, 1
  %exitcond = icmp eq i64 %add2, 256
  br i1 %exitcond, label %DIR.OMP.END.SIMD.4, label %omp.inner.for.body

DIR.OMP.END.SIMD.4:                               ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %tok) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.2

DIR.OMP.END.SIMD.2:                               ; preds = %DIR.OMP.END.SIMD.4
  ret i32 0
}

attributes #0 = { nounwind }
attributes #1 = { "vector-variants"="_ZGVyN4vlv_foo" }
attributes #2 = { "may-have-openmp-directive"="true" }
