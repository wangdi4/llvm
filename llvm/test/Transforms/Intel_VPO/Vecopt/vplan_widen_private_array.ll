; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; This test verifies that accesses to a array of vectors is handled correctly for individual vector
; as well as all the elements within the vector.

;RUN: opt -S -VPlanDriver -vplan-force-vf=2 -enable-vp-value-codegen=false %s | FileCheck %s --check-prefixes=CHECK-LLVM
;RUN: opt -S -VPlanDriver -vplan-force-vf=2 -enable-vp-value-codegen %s | FileCheck %s --check-prefixes=CHECK-VPVALUE

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture)

; Function Attrs: convergent nounwind readnone
declare i64 @_Z13get_global_idj(i32) local_unnamed_addr

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture)

; Function Attrs: convergent nounwind
define void @_ZGVdN8uuuu_test_fn(<4 x i8> addrspace(1)* %src) {
; CHECK-LLVM-LABEL: @_ZGVdN8uuuu_test_fn(
; CHECK-LLVM:  entry:
; CHECK-LLVM:    [[SPRIVATESTORAGE_VEC:%.*]] = alloca [2 x [2 x <4 x i8>]], align 16
; CHECK-LLVM:  vector.body:
; CHECK-LLVM:    [[PRIVADDR:%.*]] = bitcast [2 x [2 x <4 x i8>]]* [[SPRIVATESTORAGE_VEC]] to [2 x <4 x i8>]*
; CHECK-LLVM:    [[TMP2:%.*]] = getelementptr [2 x <4 x i8>], [2 x <4 x i8>]* [[PRIVADDR]], <2 x i32> <i32 0, i32 1>
; CHECK-LLVM:    [[MM_VECTORGEP:%.*]] = getelementptr inbounds [2 x <4 x i8>], <2 x [2 x <4 x i8>]*> [[TMP2]], <2 x i64> zeroinitializer, <2 x i64> zeroinitializer, <2 x i64> zeroinitializer
; CHECK-LLVM:    [[TMP5:%.*]] = load <4 x i8>, <4 x i8> addrspace(1)* [[SRC:%.*]], align 16
; CHECK-LLVM:    [[REPLICATEDVAL_:%.*]] = shufflevector <4 x i8> [[TMP5]], <4 x i8> undef, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 0, i32 1, i32 2, i32 3>
; CHECK-LLVM:    [[MM_VECTORGEP2:%.*]] = getelementptr inbounds [2 x <4 x i8>], <2 x [2 x <4 x i8>]*> [[TMP2]], <2 x i64> zeroinitializer, <2 x i64> zeroinitializer
; CHECK-LLVM:    [[TMP6:%.*]] = bitcast <2 x <4 x i8>*> [[MM_VECTORGEP2]] to <2 x i8*>
; CHECK-LLVM:    [[VECBASEPTR_:%.*]] = shufflevector <2 x i8*> [[TMP6]], <2 x i8*> undef, <8 x i32> <i32 0, i32 0, i32 0, i32 0, i32 1, i32 1, i32 1, i32 1>
; CHECK-LLVM:    [[ELEMBASEPTR_:%.*]] = getelementptr i8, <8 x i8*> [[VECBASEPTR_]], <8 x i64> <i64 0, i64 1, i64 2, i64 3, i64 0, i64 1, i64 2, i64 3>
; CHECK-LLVM:    call void @llvm.masked.scatter.v8i8.v8p0i8(<8 x i8> [[REPLICATEDVAL_]], <8 x i8*> [[ELEMBASEPTR_]], i32 16, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>)
;
; CHECK-VPVALUE-LABEL: @_ZGVdN8uuuu_test_fn(
; CHECK-VPVALUE:  entry:
; CHECK-VPVALUE:    [[PRIVATE_MEM:%.*]] = alloca [2 x [2 x <4 x i8>]], align 4
; CHECK-VPVALUE:    [[PRIVADDR:%.*]] = bitcast [2 x [2 x <4 x i8>]]* [[PRIVATE_MEM]] to [2 x <4 x i8>]*
; CHECK-VPVALUE:    [[PRIV_BASE_ADDR:%.*]] = getelementptr [2 x <4 x i8>], [2 x <4 x i8>]* [[PRIVADDR]], <2 x i32> <i32 0, i32 1>
; CHECK-VPVALUE:  vector.body:
; CHECK-VPVALUE:    [[MM_VECTORGEP:%.*]] = getelementptr inbounds [2 x <4 x i8>], <2 x [2 x <4 x i8>]*> [[PRIV_BASE_ADDR]], <2 x i64> zeroinitializer, <2 x i64> zeroinitializer, <2 x i64> zeroinitializer
; CHECK-VPVALUE:    [[TMP4:%.*]] = load <4 x i8>, <4 x i8> addrspace(1)* [[SRC:%.*]]
; CHECK-VPVALUE:    [[REPLICATEDVAL_:%.*]] = shufflevector <4 x i8> [[TMP4]], <4 x i8> undef, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 0, i32 1, i32 2, i32 3>
; CHECK-VPVALUE:    [[MM_VECTORGEP2:%.*]] = getelementptr inbounds [2 x <4 x i8>], <2 x [2 x <4 x i8>]*> [[PRIV_BASE_ADDR]], <2 x i64> zeroinitializer, <2 x i64> zeroinitializer
; CHECK-VPVALUE:    [[TMP5:%.*]] = bitcast <2 x <4 x i8>*> [[MM_VECTORGEP2]] to <2 x i8*>
; CHECK-VPVALUE:    [[VECBASEPTR_:%.*]] = shufflevector <2 x i8*> [[TMP5]], <2 x i8*> undef, <8 x i32> <i32 0, i32 0, i32 0, i32 0, i32 1, i32 1, i32 1, i32 1>
; CHECK-VPVALUE:    [[ELEMBASEPTR_:%.*]] = getelementptr i8, <8 x i8*> [[VECBASEPTR_]], <8 x i64> <i64 0, i64 1, i64 2, i64 3, i64 0, i64 1, i64 2, i64 3>
; CHECK-VPVALUE:    call void @llvm.masked.scatter.v8i8.v8p0i8(<8 x i8> [[REPLICATEDVAL_]], <8 x i8*> [[ELEMBASEPTR_]], i32 16, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>)
;
entry:
  %sPrivateStorage = alloca [2 x <4 x i8>], align 16
  %call = tail call i64 @_Z13get_global_idj(i32 0)
  br label %simd.begin.region

simd.begin.region:                                ; preds = %entry
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.UNIFORM"(<4 x i8> addrspace(1)* %src), "QUAL.OMP.PRIVATE"([2 x <4 x i8>]* %sPrivateStorage)]
  br label %simd.loop

simd.loop:                                        ; preds = %simd.loop.exit, %simd.begin.region
  %index = phi i32 [ 0, %simd.begin.region ], [ %indvar, %simd.loop.exit ]
  %0 = sext i32 %index to i64
  %add = add nuw i64 %0, %call
  %1 = getelementptr inbounds [2 x <4 x i8>], [2 x <4 x i8>]* %sPrivateStorage, i64 0, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 256, i8* nonnull %1)
  %2 = load <4 x i8>, <4 x i8> addrspace(1)* %src, align 16
  %arrayidx3 = getelementptr inbounds [2 x <4 x i8>], [2 x <4 x i8>]* %sPrivateStorage, i64 0, i64 0
  store <4 x i8> %2, <4 x i8>* %arrayidx3, align 16
  call void @llvm.lifetime.end.p0i8(i64 256, i8* nonnull %1)
  br label %simd.loop.exit

simd.loop.exit:                                   ; preds = %simd.loop
  %indvar = add nuw i32 %index, 1
  %vl.cond = icmp ult i32 %indvar, 8
  br i1 %vl.cond, label %simd.loop, label %simd.end.region

simd.end.region:                                  ; preds = %simd.loop.exit
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  br label %return

return:                                           ; preds = %simd.end.region
  ret void
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
