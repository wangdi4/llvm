; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: opt %s -passes="vplan-vec" -disable-output -vplan-enable-masked-variant=0 -vplan-dump-da -loopopt=0 -S 2>&1 | FileCheck %s

; Loop iv is inside signed i32 range. Check that trunc retains unit-stride.

define i32 @main() {
;
; CHECK:  Divergent: [Shape: Unit Stride, Stride: i64 1] i32 [[VP_CONV:%.*]] = trunc i64
;
DIR.OMP.SIMD.1:
  %i.linear.iv = alloca i64, align 8
  %b = alloca [2147483647 x i32], align 16
  br label %DIR.OMP.SIMD.117

DIR.OMP.SIMD.117:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.SIMDLEN"(i32 8) ]
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %DIR.OMP.SIMD.117, %omp.inner.for.body
  %.omp.iv.local.013 = phi i64 [ 0, %DIR.OMP.SIMD.117 ], [ %add1, %omp.inner.for.body ]
  %conv = trunc i64 %.omp.iv.local.013 to i32
  %arrayidx = getelementptr inbounds [2147483647 x i32], ptr %b, i64 0, i64 %.omp.iv.local.013
  store i32 %conv, ptr %arrayidx, align 4
  %add1 = add nuw nsw i64 %.omp.iv.local.013, 1
  %exitcond.not = icmp eq i64 %add1, 2147483647
  br i1 %exitcond.not, label %DIR.OMP.END.SIMD.411, label %omp.inner.for.body

DIR.OMP.END.SIMD.411:                             ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %DIR.OMP.END.SIMD.411
  ret i32 0
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
