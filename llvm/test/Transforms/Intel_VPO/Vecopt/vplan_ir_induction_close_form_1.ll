; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; Test to check correctness of closed-form analysis for auto-recognized inductions in LLVM-IR VPlan vectorizer.

; C++ source:
; int foo(int* ptr, int step, int n) {
;     int s = 0; char c = step;
; #pragma omp simd reduction(+:s)
;     for (int i = 0; i < n; i++) {
;         ptr++;
;         c++;
;         s += *ptr * c;
;     }
;     return s;
; }

; Here both "ptr" and "c" are recognized by VPOLegality as induction variables. Since they are both used after their corresponding
; increment instruction, closed-form is needed for their representation in VPlan.

; RUN: opt -VPlanDriver -disable-vplan-codegen -vplan-print-after-vpentity-instrs -disable-output < %s 2>&1 | FileCheck %s
; RUN: opt -passes="vplan-driver" -disable-vplan-codegen -vplan-print-after-vpentity-instrs -disable-output < %s 2>&1 | FileCheck %s
; REQUIRES: asserts

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nounwind uwtable
define dso_local i32 @_Z3fooPiii(i32* nocapture readonly %ptr, i32 %step, i32 %n) local_unnamed_addr {
; Check induction initialization instructions
; CHECK:          [DA: Div] i32 [[VP__OMP_IV_0_IND_INIT:%.*]] = induction-init{add} i32 0 i32 1
; CHECK-NEXT:     [DA: Uni] i32 [[VP__OMP_IV_0_IND_INIT_STEP:%.*]] = induction-init-step{add} i32 1
; CHECK-NEXT:     [DA: Div] i32* [[VP_PTR_ADDR_019_IND_INIT:%.*]] = induction-init{getelementptr} i32* [[PTR0:%.*]] i64 1
; CHECK-NEXT:     [DA: Uni] i64 [[VP_PTR_ADDR_019_IND_INIT_STEP:%.*]] = induction-init-step{getelementptr} i64 1
; CHECK-NEXT:     [DA: Div] i8 [[VP_C_018_IND_INIT:%.*]] = induction-init{add} i8 [[CONV0:%.*]] i8 1
; CHECK-NEXT:     [DA: Uni] i8 [[VP_C_018_IND_INIT_STEP:%.*]] = induction-init-step{add} i8 1
;
; Check induction PHIs
; CHECK:     [DA: Div] i32 [[VP_ADD824:%.*]] = phi  [ i32 [[VP_ADD8:%.*]], [[BB2:BB[0-9]+]] ],  [ i32 [[VP_ADD824_RED_INIT:%.*]], [[BB1:BB[0-9]+]] ]
; CHECK-NEXT:     [DA: Div] i32 [[VP__OMP_IV_0:%.*]] = phi  [ i32 [[VP_ADD9:%.*]], [[BB2]] ],  [ i32 [[VP__OMP_IV_0_IND_INIT]], [[BB1]] ]
; CHECK-NEXT:     [DA: Div] i32* [[VP_PTR_ADDR_019:%.*]] = phi  [ i32* [[VP0:%.*]], [[BB2]] ],  [ i32* [[VP_PTR_ADDR_019_IND_INIT]], [[BB1]] ]
; CHECK-NEXT:     [DA: Div] i8 [[VP_C_018:%.*]] = phi  [ i8 [[VP1:%.*]], [[BB2]] ],  [ i8 [[VP_C_018_IND_INIT]], [[BB1]] ]
;
; Check induction binops
; CHECK:          [DA: Div] i32* [[VP_INCDEC_PTR:%.*]] = getelementptr inbounds i32* [[VP_PTR_ADDR_019]] i64 1
; CHECK-NEXT:     [DA: Div] i8 [[VP_INC:%.*]] = add i8 [[VP_C_018]] i8 1
; CHECK-NEXT:     [DA: Div] i32 [[VP2:%.*]] = load i32* [[VP_INCDEC_PTR]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_CONV6:%.*]] = sext i8 [[VP_INC]] to i32
; CHECK-NEXT:     [DA: Div] i32 [[VP_MUL7:%.*]] = mul i32 [[VP2]] i32 [[VP_CONV6]]
; CHECK-NEXT:     [DA: Div] i32 [[VP_ADD8]] = add i32 [[VP_MUL7]] i32 [[VP_ADD824]]
;
; Check induction close-form instructions
; CHECK:          [DA: Div] i32* [[VP0]] = getelementptr inbounds i32* [[VP_PTR_ADDR_019]] i64 [[VP_PTR_ADDR_019_IND_INIT_STEP]]
; CHECK-NEXT:     [DA: Div] i8 [[VP1]] = add i8 [[VP_C_018]] i8 [[VP_C_018_IND_INIT_STEP]]
entry:
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %DIR.OMP.SIMD.1, label %omp.precond.end

DIR.OMP.SIMD.1:                                   ; preds = %entry
  %conv = trunc i32 %step to i8
  %s.red = alloca i32, align 4
  br label %DIR.OMP.SIMD.126

DIR.OMP.SIMD.126:                                 ; preds = %DIR.OMP.SIMD.1
  %0 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.ADD"(i32* %s.red), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  br label %DIR.OMP.SIMD.2

DIR.OMP.SIMD.2:                                   ; preds = %DIR.OMP.SIMD.126
  store i32 0, i32* %s.red, align 4
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.2
  %add824 = phi i32 [ %add8, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.2 ]
  %.omp.iv.0 = phi i32 [ %add9, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.2 ]
  %ptr.addr.019 = phi i32* [ %incdec.ptr, %omp.inner.for.body ], [ %ptr, %DIR.OMP.SIMD.2 ]
  %c.018 = phi i8 [ %inc, %omp.inner.for.body ], [ %conv, %DIR.OMP.SIMD.2 ]
  %incdec.ptr = getelementptr inbounds i32, i32* %ptr.addr.019, i64 1
  %inc = add i8 %c.018, 1
  %1 = load i32, i32* %incdec.ptr, align 4, !tbaa !2
  %conv6 = sext i8 %inc to i32
  %mul7 = mul nsw i32 %1, %conv6
  %add8 = add nsw i32 %mul7, %add824
  %add9 = add nuw nsw i32 %.omp.iv.0, 1
  %exitcond = icmp eq i32 %add9, %n
  br i1 %exitcond, label %omp.loop.exit, label %omp.inner.for.body

omp.loop.exit:                                    ; preds = %omp.inner.for.body
  %add8.lcssa = phi i32 [ %add8, %omp.inner.for.body ]
  store i32 %add8.lcssa, i32* %s.red, align 4, !tbaa !2
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %omp.loop.exit
  call void @llvm.directive.region.exit(token %0) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.3, %entry
  %s.1 = phi i32 [ %add8.lcssa, %DIR.OMP.END.SIMD.3 ], [ 0, %entry ]
  ret i32 %s.1
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #1 = { nounwind }


!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C++ TBAA"}

