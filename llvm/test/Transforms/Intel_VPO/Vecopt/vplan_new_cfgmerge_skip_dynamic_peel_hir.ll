; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py UTC_ARGS: --version 2

; This test checks that we emit a trip count check to skip the peel loop when
; `-vplan-skip-dynamic-peel-tc` is set to a non-zero value, and the peel kind
; is dynamic. Additionally, check that the outputted HIR is correct, and that
; we don't set the alignment of the peeled memref to the target alignment when
; peeling may be skipped.

; RUN: opt -disable-output < %s -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir-framework>' -hir-details -vplan-enable-peeling=true \
; RUN:     -vplan-vec-scenario='s4;v4;s4' -vplan-print-after-merge-skeleton \
; RUN:     -vplan-skip-dynamic-peel-tc=1200 2>&1 | FileCheck %s
; RUN: opt -disable-output < %s -passes='hir-ssa-deconstruction,hir-vplan-vec,print<hir-framework>' -hir-details -vplan-enable-peeling=true \
; RUN:     -vplan-vec-scenario='m4;v4;m4' -vplan-print-after-merge-skeleton \
; RUN:     -vplan-skip-dynamic-peel-tc=1200 2>&1 | FileCheck %s

target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "x86_64-unknown-linux-gnu"

define void @test(ptr %A, i64 %N) {
; CHECK-LABEL: VPlan after merge skeleton creation:
; CHECK-NEXT:  VPlan IR for: Initial VPlan for VF=4
; CHECK-NEXT:  External Defs Start:
; CHECK-DAG:     [[VP0:%.*]] = {%A}
; CHECK-DAG:     [[VP1:%.*]] = {%N + -1}
; CHECK-NEXT:  External Defs End:
; CHECK-NEXT:    [[PEEL_CHECK_TC0:peel.check.tc[0-9]+]]: # preds:
; CHECK-NEXT:     [DA: Uni] i64 [[VP2:%.*]] = add i64 [[VP1]] i64 1
; CHECK-NEXT:     [DA: Uni] pushvf VF=4 UF=1
; CHECK-NEXT:     [DA: Uni] i1 [[VP3:%.*]] = icmp ult i64 [[VP2]] i64 1200
; CHECK-NEXT:     [DA: Uni] br i1 [[VP3]], [[MERGE_BLK0:merge.blk[0-9]+]], [[PEEL_CHECKZ0:peel.checkz[0-9]+]]
; CHECK-LABEL: Function: test
; CHECK-EMPTY:
; CHECK-NEXT:  BEGIN REGION { modified }
; CHECK:             [[DOTVEC0:%.*]] = %N <u 1200
; CHECK:             [[PHI_TEMP0:%.*]] = 0
; CHECK:             [[EXTRACT_0_0:%.*]] = extractelement [[DOTVEC0]],  0
; CHECK:             if ([[EXTRACT_0_0]] == 1)
; CHECK:             {
; CHECK:                goto [[MERGE_BLK0]].24
; CHECK:             }
; CHECK:             + DO i64 i1 = [[PHI_TEMP0]], {{.*}}, 4   <DO_LOOP> <simd-vectorized> <nounroll> <novectorize>
; CHECK:             |
; CHECK:             |   (<4 x i64>*)([[A0:.*]])[i1] = 0
; CHECK-NEXT:        |   <LVAL-REG> {al:8}(<4 x i64>*)(LINEAR ptr [[A0]])[LINEAR i64 i1] inbounds  !intel.preferred_alignment <{{.*}}> {sb:10}
; CHECK-NEXT:        |      <BLOB> LINEAR ptr [[A0]] {sb:7}
; CHECK-NEXT:        |
; CHECK-NEXT:        + END LOOP
;
entry:
  %entry.region = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"() ]
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %ptr = getelementptr inbounds i64, ptr %A, i64 %indvars.iv
  store i64 0, ptr %ptr, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %N
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.body
  call void @llvm.directive.region.exit(token %entry.region) [ "DIR.OMP.END.SIMD"() ]
  ret void
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #0

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #0

attributes #0 = { nounwind }
