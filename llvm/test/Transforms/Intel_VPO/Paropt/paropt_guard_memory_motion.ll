; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; Test to verify the functionality of VPOParoptGuardMemoryMotion and VPORenameOperands passes.

; Test src:
; struct point {
;   int x;
;   int y;
; };
;
; #pragma omp declare reduction(min : struct point : \
;         omp_out.x = omp_in.x > omp_out.x  ? omp_out.x : omp_in.x, \
;         omp_out.y = omp_in.y > omp_out.y  ? omp_out.y : omp_in.y ) \
;         initializer( omp_priv = { INT_MAX, INT_MAX } )
;
; #pragma omp declare reduction(max : struct point : \
;         omp_out.x = omp_in.x < omp_out.x  ? omp_out.x : omp_in.x,  \
;         omp_out.y = omp_in.y < omp_out.y  ? omp_out.y : omp_in.y ) \
;         initializer( omp_priv = { 0, 0 } )
;
; void find_enclosing_rectangle ( int n, struct point points[] )
; {
;   struct point minp = { INT_MAX, INT_MAX }, maxp = {0,0};
;   int i;
;
; #pragma omp simd reduction(min:minp) reduction(max:maxp)
;   for ( i = 0; i < n; i++ ) {
;     if ( points[i].x < minp.x ) minp.x = points[i].x;
;     if ( points[i].y < minp.y ) minp.y = points[i].y;
;     if ( points[i].x > maxp.x ) maxp.x = points[i].x;
;     if ( points[i].y > maxp.y ) maxp.y = points[i].y;
;   }
; }

; RUN: opt -bugpoint-enable-legacy-pm -vpo-paropt-guard-memory-motion -vpo-cfg-restructuring -vpo-rename-operands -S %s -o %t1.ll && FileCheck --input-file=%t1.ll %s
; RUN: opt -bugpoint-enable-legacy-pm -vpo-restore-operands -S %t1.ll -o %t2.ll && FileCheck --input-file=%t2.ll %s --check-prefix=RESTORE

; RUN: opt -passes='function(vpo-paropt-guard-memory-motion,vpo-cfg-restructuring,vpo-rename-operands)' -S %s -o %t1.ll && FileCheck --input-file=%t1.ll %s
; RUN: opt -passes='function(vpo-restore-operands)' -S %t1.ll -o %t2.ll && FileCheck --input-file=%t2.ll %s --check-prefix=RESTORE

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.point = type { i32, i32 }
%struct.fast_red_t = type <{ %struct.point, %struct.point }>

; Function Attrs: nounwind uwtable
define dso_local void @find_enclosing_rectangle(i32 noundef %n, ptr noundef %points) local_unnamed_addr #0 {
; CHECK:       @find_enclosing_rectangle(
; CHECK:       omp.inner.for.body.lr.ph:
; CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.REDUCTION.UDR:TYPED"(ptr [[MINP_RED:%.*]], %struct.point zeroinitializer, i32 1, ptr null, ptr null, ptr @.omp_combiner., ptr @.omp_initializer.), "QUAL.OMP.REDUCTION.UDR:TYPED"(ptr [[MAXP_RED:%.*]], %struct.point zeroinitializer, i32 1, ptr null, ptr null, ptr @.omp_combiner..1, ptr @.omp_initializer..2), "QUAL.OMP.LINEAR:IV.TYPED"(ptr [[I_LINEAR_IV:%.*]], i32 0, i32 1, i32 1), "QUAL.OMP.NORMALIZED.IV:TYPED"(ptr null, i32 0),  "QUAL.OMP.NORMALIZED.UB:TYPED"(ptr null, i32 0) ]
; CHECK-NEXT:    br label [[OMP_INNER_FOR_BODY:%.*]]
; CHECK:       omp.inner.for.body:
; CHECK-NEXT:    [[DOTOMP_IV_LOCAL_069:%.*]] = phi i32 [ 0, [[OMP_INNER_FOR_BODY_LR_PH:%.*]] ], [ [[ADD43:%.*]], [[DIR_VPO_END_GUARD_MEM_MOTION_4:%.*]] ]
; CHECK-NEXT:    br label [[DIR_VPO_GUARD_MEM_MOTION_1:%.*]]
; CHECK:       DIR.VPO.GUARD.MEM.MOTION.1:
; CHECK-NEXT:    store ptr [[MINP_RED]], ptr [[MINP_RED_ADDR:%.*]], align 8
; CHECK-NEXT:    store ptr [[MAXP_RED]], ptr [[MAXP_RED_ADDR:%.*]], align 8
; CHECK-NEXT:    br label [[DIR_VPO_GUARD_MEM_MOTION_1_SPLIT:%.*]]
; CHECK:       DIR.VPO.GUARD.MEM.MOTION.1.split:
; CHECK-NEXT:    [[GUARD_START:%.*]] = call token @llvm.directive.region.entry() [ "DIR.VPO.GUARD.MEM.MOTION"(), "QUAL.OMP.LIVEIN"(ptr [[MINP_RED]]), "QUAL.OMP.LIVEIN"(ptr [[MAXP_RED]]), "QUAL.OMP.OPERAND.ADDR"(ptr [[MINP_RED]], ptr [[MINP_RED_ADDR]]), "QUAL.OMP.OPERAND.ADDR"(ptr [[MAXP_RED]], ptr [[MAXP_RED_ADDR]]) ]
; CHECK-NEXT:    [[MINP_RED1:%.*]] = load volatile ptr, ptr [[MINP_RED_ADDR]], align 8
; CHECK-NEXT:    [[MAXP_RED2:%.*]] = load volatile ptr, ptr [[MAXP_RED_ADDR]], align 8
; CHECK-NEXT:    br label [[DIR_VPO_GUARD_MEM_MOTION_2:%.*]]
; CHECK:       DIR.VPO.GUARD.MEM.MOTION.2:
; CHECK-NEXT:    store i32 [[DOTOMP_IV_LOCAL_069]], ptr [[I_LINEAR_IV]], align 4
; CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[DOTOMP_IV_LOCAL_069]] to i64
; CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds %struct.point, ptr [[POINTS:%.*]], i64 [[IDXPROM]], i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[X]], align 4
; CHECK-NEXT:    [[X5:%.*]] = getelementptr inbounds %struct.point, ptr [[MINP_RED1]], i64 0, i32 0
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[X5]], align 4
; CHECK-NEXT:    [[CMP6:%.*]] = icmp slt i32 [[TMP2]], [[TMP3]]
; CHECK-NEXT:    br i1 [[CMP6]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    store i32 [[TMP2]], ptr [[X5]], align 4
; CHECK-NEXT:    br label [[IF_END]]
; CHECK:       if.end:
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[I_LINEAR_IV]], align 4
; CHECK-NEXT:    [[IDXPROM11:%.*]] = sext i32 [[TMP4]] to i64
; CHECK-NEXT:    [[Y:%.*]] = getelementptr inbounds %struct.point, ptr [[POINTS]], i64 [[IDXPROM11]], i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[Y]], align 4
; CHECK-NEXT:    [[Y13:%.*]] = getelementptr inbounds %struct.point, ptr [[MINP_RED1]], i64 0, i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[Y13]], align 4
; CHECK-NEXT:    [[CMP14:%.*]] = icmp slt i32 [[TMP5]], [[TMP6]]
; CHECK-NEXT:    br i1 [[CMP14]], label [[IF_THEN15:%.*]], label [[IF_END20:%.*]]
; CHECK:       if.then15:
; CHECK-NEXT:    store i32 [[TMP5]], ptr [[Y13]], align 4
; CHECK-NEXT:    br label [[IF_END20]]
; CHECK:       if.end20:
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[I_LINEAR_IV]], align 4
; CHECK-NEXT:    [[IDXPROM21:%.*]] = sext i32 [[TMP7]] to i64
; CHECK-NEXT:    [[X23:%.*]] = getelementptr inbounds %struct.point, ptr [[POINTS]], i64 [[IDXPROM21]], i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[X23]], align 4
; CHECK-NEXT:    [[X24:%.*]] = getelementptr inbounds %struct.point, ptr [[MAXP_RED2]], i64 0, i32 0
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[X24]], align 4
; CHECK-NEXT:    [[CMP25:%.*]] = icmp sgt i32 [[TMP8]], [[TMP9]]
; CHECK-NEXT:    br i1 [[CMP25]], label [[IF_THEN26:%.*]], label [[IF_END31:%.*]]
; CHECK:       if.then26:
; CHECK-NEXT:    store i32 [[TMP8]], ptr [[X24]], align 4
; CHECK-NEXT:    br label [[IF_END31]]
; CHECK:       if.end31:
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[I_LINEAR_IV]], align 4
; CHECK-NEXT:    [[IDXPROM32:%.*]] = sext i32 [[TMP10]] to i64
; CHECK-NEXT:    [[Y34:%.*]] = getelementptr inbounds %struct.point, ptr [[POINTS]], i64 [[IDXPROM32]], i32 1
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[Y34]], align 4
; CHECK-NEXT:    [[Y35:%.*]] = getelementptr inbounds %struct.point, ptr [[MAXP_RED2]], i64 0, i32 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[Y35]], align 4
; CHECK-NEXT:    [[CMP36:%.*]] = icmp sgt i32 [[TMP11]], [[TMP12]]
; CHECK-NEXT:    br i1 [[CMP36]], label [[IF_THEN37:%.*]], label [[OMP_INNER_FOR_INC:%.*]]
; CHECK:       if.then37:
; CHECK-NEXT:    store i32 [[TMP11]], ptr [[Y35]], align 4
; CHECK-NEXT:    br label [[OMP_INNER_FOR_INC]]
; CHECK:       omp.inner.for.inc:
; CHECK-NEXT:    [[ADD43]] = add nsw i32 [[DOTOMP_IV_LOCAL_069]], 1
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I_LINEAR_IV]], align 4
; CHECK-NEXT:    [[ADD44:%.*]] = add nsw i32 [[TMP13]], 1
; CHECK-NEXT:    store i32 [[ADD44]], ptr [[I_LINEAR_IV]], align 4
; CHECK-NEXT:    [[TMP14:%.*]] = add i32 [[TMP0:%.*]], 1
; CHECK-NEXT:    br label [[DIR_VPO_END_GUARD_MEM_MOTION_3:%.*]]
; CHECK:       DIR.VPO.END.GUARD.MEM.MOTION.3:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[GUARD_START]]) [ "DIR.VPO.END.GUARD.MEM.MOTION"() ]
; CHECK-NEXT:    br label [[DIR_VPO_END_GUARD_MEM_MOTION_4]]
; CHECK:       DIR.VPO.END.GUARD.MEM.MOTION.4:
; CHECK-NEXT:    [[CMP3_NOT:%.*]] = icmp sgt i32 [[TMP14]], [[ADD43]]
; CHECK-NEXT:    br i1 [[CMP3_NOT]], label [[OMP_INNER_FOR_BODY]], label [[OMP_INNER_FOR_COND_DIR_OMP_END_SIMD_3_LOOPEXIT_CRIT_EDGE:%.*]]
; CHECK:       omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge:
; CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.SIMD"() ]
; CHECK-NEXT:    br label [[DIR_OMP_END_SIMD_1:%.*]]
;
; Check that after vpo-restore-operands OMP.OPERAND.ADDR clauses are dropped.
; RESTORE:       @find_enclosing_rectangle(
; RESTORE:         [[GUARD_START:%.*]] = call token @llvm.directive.region.entry() [ "DIR.VPO.GUARD.MEM.MOTION"(), "QUAL.OMP.LIVEIN"(ptr %minp.red), "QUAL.OMP.LIVEIN"(ptr %maxp.red) ]
;
entry:
  %maxp.red = alloca %struct.point, align 8
  %minp.red = alloca %struct.point, align 8
  %fast_red_struct = alloca %struct.fast_red_t, align 8
  %i.linear.iv = alloca i32, align 4
  %minp = alloca %struct.point, align 8
  %maxp = alloca %struct.point, align 8
  %i = alloca i32, align 4
  %.omp.iv = alloca i32, align 4
  %.omp.ub = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %minp) #2
  store i64 9223372034707292159, ptr %minp, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %maxp) #2
  store i64 0, ptr %maxp, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %i) #2
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %DIR.OMP.SIMD.265, label %omp.precond.end

DIR.OMP.SIMD.265:                                 ; preds = %entry
  %sub1 = add nsw i32 %n, -1
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %.omp.iv) #2
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %.omp.ub) #2
  store i32 %sub1, ptr %.omp.ub, align 4
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %DIR.OMP.SIMD.265
  br label %DIR.OMP.SIMD.1.split70

DIR.OMP.SIMD.1.split70:                           ; preds = %DIR.OMP.SIMD.1
  br label %DIR.OMP.SIMD.1.split70.split74

DIR.OMP.SIMD.1.split70.split74:                   ; preds = %DIR.OMP.SIMD.1.split70
  %maxp.fast_red = getelementptr inbounds %struct.fast_red_t, ptr %fast_red_struct, i32 0, i32 1
  br label %DIR.OMP.SIMD.1.split70.split73

DIR.OMP.SIMD.1.split70.split73:                   ; preds = %DIR.OMP.SIMD.1.split70.split74
  call void @.omp_initializer..2(ptr %maxp.red, ptr %maxp)
  br label %DIR.OMP.SIMD.1.split70.split71

DIR.OMP.SIMD.1.split70.split71:                   ; preds = %DIR.OMP.SIMD.1.split70.split73
  %minp.fast_red = getelementptr inbounds %struct.fast_red_t, ptr %fast_red_struct, i32 0, i32 0
  br label %DIR.OMP.SIMD.1.split70.split

DIR.OMP.SIMD.1.split70.split:                     ; preds = %DIR.OMP.SIMD.1.split70.split71
  call void @.omp_initializer.(ptr %minp.red, ptr %minp)
  br label %DIR.OMP.SIMD.1.split

DIR.OMP.SIMD.1.split:                             ; preds = %DIR.OMP.SIMD.1.split70.split
  %0 = load i32, ptr %.omp.ub, align 4
  br label %DIR.OMP.SIMD.266

DIR.OMP.SIMD.266:                                 ; preds = %DIR.OMP.SIMD.1.split
  br label %DIR.OMP.SIMD.2

DIR.OMP.SIMD.2:                                   ; preds = %DIR.OMP.SIMD.266
  %cmp3.not68 = icmp sgt i32 0, %0
  br i1 %cmp3.not68, label %DIR.OMP.END.SIMD.3.loopexit, label %omp.inner.for.body.lr.ph

omp.inner.for.body.lr.ph:                         ; preds = %DIR.OMP.SIMD.2
  %1 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(),
 "QUAL.OMP.REDUCTION.UDR:TYPED"(ptr %minp.red, %struct.point zeroinitializer, i32 1, ptr null, ptr null, ptr @.omp_combiner., ptr @.omp_initializer.),
 "QUAL.OMP.REDUCTION.UDR:TYPED"(ptr %maxp.red, %struct.point zeroinitializer, i32 1, ptr null, ptr null, ptr @.omp_combiner..1, ptr @.omp_initializer..2),
 "QUAL.OMP.LINEAR:IV.TYPED"(ptr %i.linear.iv, i32 0, i32 1, i32 1),
 "QUAL.OMP.NORMALIZED.IV:TYPED"(ptr null, i32 0),
 "QUAL.OMP.NORMALIZED.UB:TYPED"(ptr null, i32 0) ]

  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.inc, %omp.inner.for.body.lr.ph
  %.omp.iv.local.069 = phi i32 [ 0, %omp.inner.for.body.lr.ph ], [ %add43, %omp.inner.for.inc ]
  store i32 %.omp.iv.local.069, ptr %i.linear.iv, align 4
  %idxprom = sext i32 %.omp.iv.local.069 to i64
  %x = getelementptr inbounds %struct.point, ptr %points, i64 %idxprom, i32 0
  %2 = load i32, ptr %x, align 4
  %x5 = getelementptr inbounds %struct.point, ptr %minp.red, i64 0, i32 0
  %3 = load i32, ptr %x5, align 4
  %cmp6 = icmp slt i32 %2, %3
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %omp.inner.for.body
  store i32 %2, ptr %x5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %omp.inner.for.body
  %4 = load i32, ptr %i.linear.iv, align 4
  %idxprom11 = sext i32 %4 to i64
  %y = getelementptr inbounds %struct.point, ptr %points, i64 %idxprom11, i32 1
  %5 = load i32, ptr %y, align 4
  %y13 = getelementptr inbounds %struct.point, ptr %minp.red, i64 0, i32 1
  %6 = load i32, ptr %y13, align 4
  %cmp14 = icmp slt i32 %5, %6
  br i1 %cmp14, label %if.then15, label %if.end20

if.then15:                                        ; preds = %if.end
  store i32 %5, ptr %y13, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %if.end
  %7 = load i32, ptr %i.linear.iv, align 4
  %idxprom21 = sext i32 %7 to i64
  %x23 = getelementptr inbounds %struct.point, ptr %points, i64 %idxprom21, i32 0
  %8 = load i32, ptr %x23, align 4
  %x24 = getelementptr inbounds %struct.point, ptr %maxp.red, i64 0, i32 0
  %9 = load i32, ptr %x24, align 4
  %cmp25 = icmp sgt i32 %8, %9
  br i1 %cmp25, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.end20
  store i32 %8, ptr %x24, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then26, %if.end20
  %10 = load i32, ptr %i.linear.iv, align 4
  %idxprom32 = sext i32 %10 to i64
  %y34 = getelementptr inbounds %struct.point, ptr %points, i64 %idxprom32, i32 1
  %11 = load i32, ptr %y34, align 4
  %y35 = getelementptr inbounds %struct.point, ptr %maxp.red, i64 0, i32 1
  %12 = load i32, ptr %y35, align 4
  %cmp36 = icmp sgt i32 %11, %12
  br i1 %cmp36, label %if.then37, label %omp.inner.for.inc

if.then37:                                        ; preds = %if.end31
  store i32 %11, ptr %y35, align 4
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %if.then37, %if.end31
  %add43 = add nsw i32 %.omp.iv.local.069, 1
  %13 = load i32, ptr %i.linear.iv, align 4
  %add44 = add nsw i32 %13, 1
  store i32 %add44, ptr %i.linear.iv, align 4
  %14 = add i32 %0, 1
  %cmp3.not = icmp sgt i32 %14, %add43
  br i1 %cmp3.not, label %omp.inner.for.body, label %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge

omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge: ; preds = %omp.inner.for.inc
  call void @llvm.directive.region.exit(token %1) [ "DIR.OMP.END.SIMD"() ]
  br label %DIR.OMP.END.SIMD.1

DIR.OMP.END.SIMD.1:                               ; preds = %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge
  %15 = load %struct.point, ptr %minp.red, align 4
  store %struct.point %15, ptr %minp.fast_red, align 4
  br label %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split72

omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split72: ; preds = %DIR.OMP.END.SIMD.1
  %16 = load %struct.point, ptr %maxp.red, align 4
  store %struct.point %16, ptr %maxp.fast_red, align 4
  br label %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split72.split

omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split72.split: ; preds = %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split72
  %17 = load i32, ptr %i.linear.iv, align 4
  store i32 %17, ptr %i, align 4
  br label %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split

omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split: ; preds = %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split72.split
  br label %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split.split

omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split.split: ; preds = %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split
  call void @.omp_combiner.(ptr %minp, ptr %minp.fast_red)
  br label %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split.split.split

omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split.split.split: ; preds = %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split.split
  call void @.omp_combiner..1(ptr %maxp, ptr %maxp.fast_red)
  br label %DIR.OMP.END.SIMD.3.loopexit

DIR.OMP.END.SIMD.3.loopexit:                      ; preds = %omp.inner.for.cond.DIR.OMP.END.SIMD.3.loopexit_crit_edge.split.split.split, %DIR.OMP.SIMD.2
  br label %DIR.OMP.END.SIMD.3

DIR.OMP.END.SIMD.3:                               ; preds = %DIR.OMP.END.SIMD.3.loopexit
  br label %DIR.OMP.END.SIMD.367

DIR.OMP.END.SIMD.367:                             ; preds = %DIR.OMP.END.SIMD.3
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.367, %entry
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %.omp.ub) #2
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %.omp.iv) #2
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %i) #2
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %maxp) #2
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %minp) #2
  ret void
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #2

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #2

; Function Attrs: alwaysinline nounwind uwtable
declare hidden void @.omp_combiner.(ptr noalias noundef, ptr noalias noundef) #3

; Function Attrs: alwaysinline nounwind uwtable
declare hidden void @.omp_initializer.(ptr noalias noundef, ptr noalias) #3

; Function Attrs: alwaysinline nounwind uwtable
declare hidden void @.omp_combiner..1(ptr noalias noundef, ptr noalias noundef) #3

; Function Attrs: alwaysinline nounwind uwtable
declare hidden void @.omp_initializer..2(ptr noalias noundef, ptr noalias) #3

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1
