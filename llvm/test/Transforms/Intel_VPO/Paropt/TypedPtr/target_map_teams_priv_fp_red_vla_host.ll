; REQUIRES: asserts
; RUN: opt -opaque-pointers=0 -bugpoint-enable-legacy-pm -vpo-cfg-restructuring -vpo-paropt -debug-only=WRegionUtils,vpo-paropt-transform -S %s 2>&1 | FileCheck %s
; RUN: opt -opaque-pointers=0 -switch-to-offload -aa-pipeline=basic-aa -passes='function(vpo-cfg-restructuring),vpo-paropt' -debug-only=WRegionUtils,vpo-paropt-transform -S %s 2>&1 | FileCheck %s

; Test src:
;
; #include <stdio.h>
; int main() {
;   long n = 2;
;   int x[n], y[n], z[n];
;
; #pragma omp target map(tofrom:x, y, z)
; #pragma omp teams private(x) firstprivate(y) reduction(+:z)
;     printf("%p %p %p\n", x, y, z);
; }

; The test IR was generated by starting with the above src, removing the error checks
; in clang, and minimizing the IR.


; CHECK: === VPOParopt Transform: TEAMS construct
; CHECK: collectNonPointerValuesToBeUsedInOutlinedRegion: Non-pointer values to be passed into the outlined region: 'i64 %n.v i64 %n.v1 i64 %n.v2 '
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'i64* [[NVV_ADDR:%n.v.addr]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'i64* [[NVV1_ADDR:%n.v1.addr]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'i64* [[NVV2_ADDR:%n.v2.addr]]'

; CHECK: === VPOParopt Transform: TARGET construct
; CHECK: collectNonPointerValuesToBeUsedInOutlinedRegion: Non-pointer values to be passed into the outlined region: 'i64 %n.v1 i64 %n.v2 i64 %n.v '
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'i64* [[NV1_ADDR:%n.v1.addr.*]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'i64* [[NV2_ADDR:%n.v2.addr.*]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'i64* [[NV_ADDR:%n.v.addr.*]]'

; Check that the private copies for the three VLAs are created inside the outlined function for the teams construct.
; CHECK: define internal void @main.{{.*}}TEAMS{{.*}}(i32* %tid, i32* %bid, i64* [[NVV2_ADDR]], i64* [[NVV1_ADDR]], i64* [[NVV_ADDR]], i32* %vla1, i32* %vla2)
; CHECK: [[NVV219:%n.*]] = load i64, i64* [[NVV2_ADDR]], align 8
; CHECK: [[NVV118:%n.*]] = load i64, i64* [[NVV1_ADDR]], align 8
; CHECK: [[NVV117:%n.*]] = load i64, i64* [[NVV_ADDR]], align 8
; CHECK: [[VLA1_FPRIV:%vla.*fpriv]] = alloca i32, i64 [[NVV118]], align 16
; CHECK: [[VLA_PRIV:%vla.priv]] = alloca i32, i64 [[NVV117]], align 16
; CHECK: [[VLA2_RED:%vla.*red]] = alloca i32, i64 [[NVV219]], align 16

; Check that the privatized copies are used in the region
; CHECK: call i32 (i8*, ...) @printf({{.*}}, i32* noundef %vla.priv, i32* noundef %vla1.fpriv, i32* noundef %vla2.red)

; Check the signature of the outlined kernel to make sure it has the same 6 arguments as the device compilation (target_map_teams_priv_fp_red_vla_tgt.ll)
; CHECK: define {{.*}} void @__omp_offloading{{.*}}main{{.*}}(i32* noalias %vla1, i32* noalias %vla2, i32* noalias %vla, i64 [[NV1_ADDR]].val, i64 [[NV2_ADDR]].val, i64 [[NV_ADDR]].val)

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"
target device_triples = "spir64"

@.str = private unnamed_addr constant [10 x i8] c"%p %p %p\0A\00", align 1

define dso_local i32 @main() {
entry:
  %n = alloca i64, align 8
  store i64 2, i64* %n, align 8

  %n.v = load i64, i64* %n, align 8
  %vla = alloca i32, i64 %n.v, align 16

  %n.v1 = load i64, i64* %n, align 8
  %vla1 = alloca i32, i64 %n.v1, align 16

  %n.v2 = load i64, i64* %n, align 8
  %vla2 = alloca i32, i64 %n.v2, align 16

  %map_size1 = mul nuw i64 %n.v1, 4
  %arrayidx = getelementptr inbounds i32, i32* %vla1, i64 0
  %map_size2 = mul nuw i64 %n.v2, 4
  %arrayidx5 = getelementptr inbounds i32, i32* %vla2, i64 0
  %map_size3 = mul nuw i64 %n.v, 4
  %arrayidx6 = getelementptr inbounds i32, i32* %vla, i64 0

  %dir1 = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(),
    "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 0),
    "QUAL.OMP.MAP.TOFROM"(i32* %vla1, i32* %arrayidx, i64 %map_size1, i64 35, i8* null, i8* null),
    "QUAL.OMP.MAP.TOFROM"(i32* %vla2, i32* %arrayidx5, i64 %map_size2, i64 35, i8* null, i8* null),
    "QUAL.OMP.MAP.TOFROM"(i32* %vla, i32* %arrayidx6, i64 %map_size3, i64 3, i8* null, i8* null) ]

  %dir2 = call token @llvm.directive.region.entry() [ "DIR.OMP.TEAMS"(),
    "QUAL.OMP.PRIVATE"(i32* %vla),
    "QUAL.OMP.FIRSTPRIVATE"(i32* %vla1),
    "QUAL.OMP.REDUCTION.ADD"(i32* %vla2) ]

  %call = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str, i64 0, i64 0), i32* noundef %vla, i32* noundef %vla1, i32* noundef %vla2)

  call void @llvm.directive.region.exit(token %dir2) [ "DIR.OMP.END.TEAMS"() ]
  call void @llvm.directive.region.exit(token %dir1) [ "DIR.OMP.END.TARGET"() ]

  ret i32 0
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
declare dso_local i32 @printf(i8* noundef, ...)

!omp_offload.info = !{!0}
!0 = !{i32 0, i32 66313, i32 135942823, !"_Z4main", i32 6, i32 0, i32 0}
