; REQUIRES: asserts
; RUN: opt -bugpoint-enable-legacy-pm -vpo-cfg-restructuring -vpo-paropt -debug-only=WRegionUtils,vpo-paropt-transform -S %s 2>&1 | FileCheck %s
; RUN: opt -aa-pipeline=basic-aa -passes='function(vpo-cfg-restructuring),vpo-paropt' -debug-only=WRegionUtils,vpo-paropt-transform -S %s 2>&1 | FileCheck %s

; Test src:
;
; #include <stdio.h>
; int main() {
;   long n = 2;
;   int x[n], y[n], z[n];
;
; #pragma omp target map(tofrom:x, y, z)
; #pragma omp teams private(x) firstprivate(y) reduction(+:z)
;     printf("%p %p %p\n", x, y, z);
; }

; The test IR was generated by starting with the above src, removing the error checks
; in clang, and minimizing the IR.

; CHECK: === VPOParopt Transform: TEAMS construct
; CHECK: collectNonPointerValuesToBeUsedInOutlinedRegion: Non-pointer values to be passed into the outlined region: 'i64 %n.vv i64 %n.vv1 i64 %n.vv2 '
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'ptr [[NVV_ADDR:%n.vv.addr]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'ptr [[NVV1_ADDR:%n.vv1.addr]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'ptr [[NVV2_ADDR:%n.vv2.addr]]'

; CHECK: === VPOParopt Transform: TARGET construct
; CHECK: collectNonPointerValuesToBeUsedInOutlinedRegion: Non-pointer values to be passed into the outlined region: 'i64 %n.v1 i64 %n.v2 i64 %n.v '
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'ptr [[NV1_ADDR:%n.v1.addr.*]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'ptr [[NV2_ADDR:%n.v2.addr.*]]'
; CHECK: captureAndAddCollectedNonPointerValuesToSharedClause: Added implicit shared/map(to)/firstprivate clause for: 'ptr [[NV_ADDR:%n.v.addr.*]]'

; Check that the private copies for the three VLAs are created inside the outlined function for the teams construct.
; CHECK: define internal void @main.{{.*}}TEAMS{{.*}}(ptr %tid, ptr %bid, ptr [[NVV2_ADDR]], ptr [[NVV1_ADDR]], ptr [[NVV_ADDR]], ptr %vla1, ptr %vla2)
; CHECK: [[NVV219:%n.*]] = load i64, ptr [[NVV2_ADDR]], align 8
; CHECK: [[NVV118:%n.*]] = load i64, ptr [[NVV1_ADDR]], align 8
; CHECK: [[NVV117:%n.*]] = load i64, ptr [[NVV_ADDR]], align 8
; CHECK: [[VLA1_FPRIV:%vla.*fpriv]] = alloca i32, i64 [[NVV118]], align 16
; CHECK: [[VLA_PRIV:%vla.priv]] = alloca i32, i64 [[NVV117]], align 16
; CHECK: [[VLA2_RED:%vla.*red]] = alloca i32, i64 [[NVV219]], align 16

; Check that the privatized copies are used in the region
; CHECK: call i32 (ptr, ...) @printf({{.*}}, ptr noundef %vla.priv, ptr noundef %vla1.fpriv, ptr noundef %vla2.red)

; Check the signature of the outlined kernel to make sure it has the same 9 arguments as the device compilation (target_map_teams_priv_fp_red_vla_tgt.ll): 3 for maps, 3 for implicit capture of VLA sizes, and 3 for firstprivate operands.
; CHECK: define internal void @__omp_offloading{{.*}}main{{.*}}(ptr noalias %vla1, ptr noalias %vla2, ptr noalias %vla, i64 %n.v.addr.val, i64 %n.v1.addr.val, i64 %n.v2.addr.val, i64 [[NV1_ADDR]].val, i64 [[NV2_ADDR]].val, i64 [[NV_ADDR]].val)

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"
target device_triples = "spir64"

@.str = private unnamed_addr constant [10 x i8] c"%p %p %p\0A\00", align 1

define dso_local i32 @main() {
entry:
  %n = alloca i64, align 8
  %n.v.addr = alloca i64, align 8
  %n.v1.addr = alloca i64, align 8
  %n.v2.addr = alloca i64, align 8


  store i64 2, ptr %n, align 8

  %n.v = load i64, ptr %n, align 8
  %vla = alloca i32, i64 %n.v, align 16

  %n.v1 = load i64, ptr %n, align 8
  %vla1 = alloca i32, i64 %n.v1, align 16

  %n.v2 = load i64, ptr %n, align 8
  %vla2 = alloca i32, i64 %n.v2, align 16

  %map_size1 = mul nuw i64 %n.v1, 4
  %arrayidx = getelementptr inbounds i32, ptr %vla1, i64 0
  %map_size2 = mul nuw i64 %n.v2, 4
  %arrayidx5 = getelementptr inbounds i32, ptr %vla2, i64 0
  %map_size3 = mul nuw i64 %n.v, 4
  %arrayidx6 = getelementptr inbounds i32, ptr %vla, i64 0

  store i64 %n.v, i64* %n.v.addr, align 8
  store i64 %n.v1, i64* %n.v1.addr, align 8
  store i64 %n.v2, i64* %n.v2.addr, align 8

  %dir1 = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(),
    "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 0),
    "QUAL.OMP.MAP.TOFROM"(ptr %vla1, ptr %arrayidx, i64 %map_size1, i64 35, ptr null, ptr null),
    "QUAL.OMP.MAP.TOFROM"(ptr %vla2, ptr %arrayidx5, i64 %map_size2, i64 35, ptr null, ptr null),
    "QUAL.OMP.MAP.TOFROM"(ptr %vla, ptr %arrayidx6, i64 %map_size3, i64 3, ptr null, ptr null),
    "QUAL.OMP.FIRSTPRIVATE:TYPED"(ptr %n.v.addr, i64 0, i32 1),
    "QUAL.OMP.FIRSTPRIVATE:TYPED"(ptr %n.v1.addr, i64 0, i32 1),
    "QUAL.OMP.FIRSTPRIVATE:TYPED"(ptr %n.v2.addr, i64 0, i32 1) ]

  %n.vv = load i64, ptr %n.v.addr
  %n.vv1 = load i64, ptr %n.v1.addr
  %n.vv2 = load i64, ptr %n.v2.addr

  %dir2 = call token @llvm.directive.region.entry() [ "DIR.OMP.TEAMS"(),
  "QUAL.OMP.PRIVATE:TYPED"(ptr %vla, i32 0, i64 %n.vv),
  "QUAL.OMP.FIRSTPRIVATE:TYPED"(ptr %vla1, i32 0, i64 %n.vv1),
  "QUAL.OMP.REDUCTION.ADD:TYPED"(ptr %vla2, i32 0, i64 %n.vv2) ]

  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, ptr noundef %vla, ptr noundef %vla1, ptr noundef %vla2)

  call void @llvm.directive.region.exit(token %dir2) [ "DIR.OMP.END.TEAMS"() ]
  call void @llvm.directive.region.exit(token %dir1) [ "DIR.OMP.END.TARGET"() ]

  ret i32 0
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
declare dso_local i32 @printf(ptr noundef, ...)

!omp_offload.info = !{!0}
!0 = !{i32 0, i32 66313, i32 135942823, !"_Z4main", i32 6, i32 0, i32 0}
