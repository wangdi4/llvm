; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;; Test loops created with LoopCreator in presence of scalar kernel only.

; RUN: opt -dpcpp-kernel-wgloop-creator %s -S -o - | FileCheck %s
; RUN: opt -passes=dpcpp-kernel-wgloop-creator %s -S -o - | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @_Z30ParallelForNDRangeImplKernel1DPiS_S_mmm(i32* %out, i32* %dummy) #0 !no_barrier_path !{i1 1} {
; CHECK-LABEL: @_Z30ParallelForNDRangeImplKernel1DPiS_S_mmm(
; CHECK-NEXT:    [[OUT_ADDR:%.*]] = alloca i32*, align 8
; CHECK-NEXT:    [[DUMMY_ADDR:%.*]] = alloca i32*, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @get_base_global_id.(i32 0)
; CHECK-NEXT:    [[TMP2:%.*]] = call i64 @_Z14get_local_sizej(i32 0)
; CHECK-NEXT:    [[TMP3:%.*]] = call i64 @get_base_global_id.(i32 1)
; CHECK-NEXT:    [[TMP4:%.*]] = call i64 @_Z14get_local_sizej(i32 1)
; CHECK-NEXT:    [[TMP5:%.*]] = call i64 @get_base_global_id.(i32 2)
; CHECK-NEXT:    [[TMP6:%.*]] = call i64 @_Z14get_local_sizej(i32 2)
; CHECK-NEXT:    br label [[DIM_2_PRE_HEAD:%.*]]
; CHECK:       dim_2_pre_head:
; CHECK-NEXT:    br label [[DIM_1_PRE_HEAD:%.*]]
; CHECK:       dim_1_pre_head:
; CHECK-NEXT:    [[DIM_2_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_2_PRE_HEAD]] ], [ [[DIM_2_INC_IND_VAR:%.*]], [[DIM_1_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[DIM_0_PRE_HEAD:%.*]]
; CHECK:       dim_0_pre_head:
; CHECK-NEXT:    [[DIM_1_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_1_PRE_HEAD]] ], [ [[DIM_1_INC_IND_VAR:%.*]], [[DIM_0_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[SCALAR_KERNEL_ENTRY:%.*]]
; CHECK:       scalar_kernel_entry:
; CHECK-NEXT:    [[DIM_0_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_0_PRE_HEAD]] ], [ [[DIM_0_INC_IND_VAR:%.*]], [[SCALAR_KERNEL_ENTRY]] ]
; CHECK-NEXT:    [[DIM0__TID:%.*]] = phi i64 [ [[TMP1]], [[DIM_0_PRE_HEAD]] ], [ [[DIM0_INC_TID:%.*]], [[SCALAR_KERNEL_ENTRY]] ]
; CHECK-NEXT:    store i32* [[OUT:%.*]], i32** [[OUT_ADDR]], align 8
; CHECK-NEXT:    store i32* [[DUMMY:%.*]], i32** [[DUMMY_ADDR]], align 8
; CHECK-NEXT:    [[TMP7:%.*]] = load i32*, i32** [[OUT_ADDR]], align 8
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32* [[TMP7]], i64 [[DIM0__TID]]
; CHECK-NEXT:    store i32 12345, i32* [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[DIM_0_INC_IND_VAR]] = add nuw nsw i64 [[DIM_0_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_0_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_0_INC_IND_VAR]], [[TMP2]]
; CHECK-NEXT:    [[DIM0_INC_TID]] = add nuw nsw i64 [[DIM0__TID]], 1
; CHECK-NEXT:    br i1 [[DIM_0_CMP_TO_MAX]], label [[DIM_0_EXIT]], label [[SCALAR_KERNEL_ENTRY]]
; CHECK:       dim_0_exit:
; CHECK-NEXT:    [[DIM_1_INC_IND_VAR]] = add nuw nsw i64 [[DIM_1_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_1_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_1_INC_IND_VAR]], [[TMP4]]
; CHECK-NEXT:    br i1 [[DIM_1_CMP_TO_MAX]], label [[DIM_1_EXIT]], label [[DIM_0_PRE_HEAD]]
; CHECK:       dim_1_exit:
; CHECK-NEXT:    [[DIM_2_INC_IND_VAR]] = add nuw nsw i64 [[DIM_2_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_2_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_2_INC_IND_VAR]], [[TMP6]]
; CHECK-NEXT:    br i1 [[DIM_2_CMP_TO_MAX]], label [[DIM_2_EXIT:%.*]], label [[DIM_1_PRE_HEAD]]
; CHECK:       dim_2_exit:
; CHECK-NEXT:    br label [[TMP8:%.*]]
; CHECK:       8:
; CHECK-NEXT:    ret void
;
entry:
  %out.addr = alloca i32*, align 8
  %dummy.addr = alloca i32*, align 8
  store i32* %out, i32** %out.addr, align 8
  store i32* %dummy, i32** %dummy.addr, align 8
  %0 = load i32*, i32** %out.addr, align 8
  %call = call i64 @_Z13get_global_idj(i64 0)
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %call
  store i32 12345, i32* %arrayidx, align 4
  ret void
}

declare dso_local i64 @_Z13get_global_idj(i64 %0)

attributes #0 = { noinline optnone "no-barrier-path"="true" "sycl-kernel" }

!sycl.kernels = !{!0}
!0 = !{void (i32*, i32*)* @_Z30ParallelForNDRangeImplKernel1DPiS_S_mmm}
