; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -dpcpp-kernel-wgloop-creator %s -S | FileCheck %s
; RUN: opt -dpcpp-kernel-wgloop-creator %s -S -enable-debugify -disable-output 2>&1 | FileCheck -check-prefix=DEBUGIFY %s
; RUN: opt -passes=dpcpp-kernel-wgloop-creator %s -S | FileCheck %s
; RUN: opt -passes=dpcpp-kernel-wgloop-creator %s -S -enable-debugify -disable-output 2>&1 | FileCheck -check-prefix=DEBUGIFY %s

; Check that peeling loop is generated for masked kernel.

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux"

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn writeonly
define dso_local void @test(i32 addrspace(1)* nocapture noundef writeonly %dst) local_unnamed_addr #0 !kernel_arg_addr_space !2 !kernel_arg_access_qual !3 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !5 !kernel_arg_name !6 !kernel_arg_host_accessible !7 !kernel_arg_pipe_depth !8 !kernel_arg_pipe_io !5 !kernel_arg_buffer_location !5 !no_barrier_path !9 !kernel_has_sub_groups !9 !vectorized_kernel !10 !vectorized_masked_kernel !11 !vectorized_width !2 {
; CHECK-LABEL: @test(
; CHECK-NEXT:    [[EARLY_EXIT_CALL:%.*]] = call [7 x i64] @WG.boundaries.test(i32 addrspace(1)* [[DST:%.*]])
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = trunc i64 [[TMP1]] to i1
; CHECK-NEXT:    br i1 [[TMP2]], label [[WGLOOPSENTRY:%.*]], label [[EXIT:%.*]]
; CHECK:       WGLoopsEntry:
; CHECK-NEXT:    [[INIT_GID_DIM0:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 1
; CHECK-NEXT:    [[LOOP_SIZE_DIM0:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 2
; CHECK-NEXT:    [[MAX_GID_DIM0:%.*]] = add i64 [[INIT_GID_DIM0]], [[LOOP_SIZE_DIM0]]
; CHECK-NEXT:    [[INIT_GID_DIM1:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 3
; CHECK-NEXT:    [[LOOP_SIZE_DIM1:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 4
; CHECK-NEXT:    [[MAX_GID_DIM1:%.*]] = add i64 [[INIT_GID_DIM1]], [[LOOP_SIZE_DIM1]]
; CHECK-NEXT:    [[INIT_GID_DIM2:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 5
; CHECK-NEXT:    [[LOOP_SIZE_DIM2:%.*]] = extractvalue [7 x i64] [[EARLY_EXIT_CALL]], 6
; CHECK-NEXT:    [[MAX_GID_DIM2:%.*]] = add i64 [[INIT_GID_DIM2]], [[LOOP_SIZE_DIM2]]
; CHECK-NEXT:    [[VECTOR_SIZE:%.*]] = ashr i64 [[LOOP_SIZE_DIM0]], 4
; CHECK-NEXT:    [[NUM_VECTOR_WI:%.*]] = shl i64 [[VECTOR_SIZE]], 4
; CHECK-NEXT:    [[MAX_VECTOR_GID:%.*]] = add i64 [[NUM_VECTOR_WI]], [[INIT_GID_DIM0]]
; CHECK-NEXT:    [[SCALAR_SIZE:%.*]] = sub i64 [[LOOP_SIZE_DIM0]], [[NUM_VECTOR_WI]]
; CHECK-NEXT:    br label [[VECT_IF:%.*]]
; CHECK:       vect_if:
; CHECK-NEXT:    [[TMP3:%.*]] = icmp ne i64 [[VECTOR_SIZE]], 0
; CHECK-NEXT:    br i1 [[TMP3]], label [[DIM_2_VECTOR_PRE_HEAD:%.*]], label [[MASKED_VECT_IF:%.*]]
; CHECK:       dim_2_vector_pre_head:
; CHECK-NEXT:    br label [[DIM_1_VECTOR_PRE_HEAD:%.*]]
; CHECK:       dim_1_vector_pre_head:
; CHECK-NEXT:    [[DIM_2_VECTOR_IND_VAR:%.*]] = phi i64 [ [[INIT_GID_DIM2]], [[DIM_2_VECTOR_PRE_HEAD]] ], [ [[DIM_2_VECTOR_INC_IND_VAR:%.*]], [[DIM_1_VECTOR_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[DIM_0_VECTOR_PRE_HEAD:%.*]]
; CHECK:       dim_0_vector_pre_head:
; CHECK-NEXT:    [[DIM_1_VECTOR_IND_VAR:%.*]] = phi i64 [ [[INIT_GID_DIM1]], [[DIM_1_VECTOR_PRE_HEAD]] ], [ [[DIM_1_VECTOR_INC_IND_VAR:%.*]], [[DIM_0_VECTOR_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[ENTRYVECTOR_FUNC:%.*]]
; CHECK:       entryvector_func:
; CHECK-NEXT:    [[DIM_0_VECTOR_IND_VAR:%.*]] = phi i64 [ [[INIT_GID_DIM0]], [[DIM_0_VECTOR_PRE_HEAD]] ], [ [[DIM_0_VECTOR_INC_IND_VAR:%.*]], [[ENTRYVECTOR_FUNC]] ]
; CHECK-NEXT:    [[SEXTVECTOR_FUNC:%.*]] = shl i64 [[DIM_0_VECTOR_IND_VAR]], 32
; CHECK-NEXT:    [[DOTEXTRACT_0_VECTOR_FUNC:%.*]] = ashr exact i64 [[SEXTVECTOR_FUNC]], 32
; CHECK-NEXT:    [[SCALAR_GEPVECTOR_FUNC:%.*]] = getelementptr inbounds i32, i32 addrspace(1)* [[DST]], i64 [[DOTEXTRACT_0_VECTOR_FUNC]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i32 addrspace(1)* [[SCALAR_GEPVECTOR_FUNC]] to <16 x i32> addrspace(1)*
; CHECK-NEXT:    store <16 x i32> zeroinitializer, <16 x i32> addrspace(1)* [[TMP4]], align 4
; CHECK-NEXT:    [[DIM_0_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_0_VECTOR_IND_VAR]], 16
; CHECK-NEXT:    [[DIM_0_VECTOR_CMP_TO_MAX:%.*]] = icmp sge i64 [[DIM_0_VECTOR_INC_IND_VAR]], [[MAX_VECTOR_GID]]
; CHECK-NEXT:    br i1 [[DIM_0_VECTOR_CMP_TO_MAX]], label [[DIM_0_VECTOR_EXIT]], label [[ENTRYVECTOR_FUNC]]
; CHECK:       dim_0_vector_exit:
; CHECK-NEXT:    [[DIM_1_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_1_VECTOR_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_1_VECTOR_CMP_TO_MAX:%.*]] = icmp sge i64 [[DIM_1_VECTOR_INC_IND_VAR]], [[MAX_GID_DIM1]]
; CHECK-NEXT:    br i1 [[DIM_1_VECTOR_CMP_TO_MAX]], label [[DIM_1_VECTOR_EXIT]], label [[DIM_0_VECTOR_PRE_HEAD]]
; CHECK:       dim_1_vector_exit:
; CHECK-NEXT:    [[DIM_2_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_2_VECTOR_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_2_VECTOR_CMP_TO_MAX:%.*]] = icmp sge i64 [[DIM_2_VECTOR_INC_IND_VAR]], [[MAX_GID_DIM2]]
; CHECK-NEXT:    br i1 [[DIM_2_VECTOR_CMP_TO_MAX]], label [[DIM_2_VECTOR_EXIT:%.*]], label [[DIM_1_VECTOR_PRE_HEAD]]
; CHECK:       dim_2_vector_exit:
; CHECK-NEXT:    br label [[MASKED_VECT_IF]]
; CHECK:       masked_vect_if:
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i64 [[SCALAR_SIZE]], 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[MASK_GENERATE:%.*]], label [[RET:%.*]]
; CHECK:       mask_generate:
; CHECK-NEXT:    [[DOTSPLATINSERT:%.*]] = insertelement <16 x i64> poison, i64 [[SCALAR_SIZE]], i32 0
; CHECK-NEXT:    [[DOTSPLAT:%.*]] = shufflevector <16 x i64> [[DOTSPLATINSERT]], <16 x i64> poison, <16 x i32> zeroinitializer
; CHECK-NEXT:    [[MASK_I1:%.*]] = icmp ult <16 x i64> <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, [[DOTSPLAT]]
; CHECK-NEXT:    [[MASK_I32:%.*]] = sext <16 x i1> [[MASK_I1]] to <16 x i32>
; CHECK-NEXT:    br label [[DIM_2_VECTOR_PRE_HEAD11:%.*]]
; CHECK:       dim_2_vector_pre_head11:
; CHECK-NEXT:    br label [[DIM_1_VECTOR_PRE_HEAD6:%.*]]
; CHECK:       dim_1_vector_pre_head6:
; CHECK-NEXT:    [[DIM_2_VECTOR_IND_VAR13:%.*]] = phi i64 [ [[INIT_GID_DIM2]], [[DIM_2_VECTOR_PRE_HEAD11]] ], [ [[DIM_2_VECTOR_INC_IND_VAR14:%.*]], [[DIM_1_VECTOR_EXIT7:%.*]] ]
; CHECK-NEXT:    br label [[DIM_0_VECTOR_PRE_HEAD1:%.*]]
; CHECK:       dim_0_vector_pre_head1:
; CHECK-NEXT:    [[DIM_1_VECTOR_IND_VAR8:%.*]] = phi i64 [ [[INIT_GID_DIM1]], [[DIM_1_VECTOR_PRE_HEAD6]] ], [ [[DIM_1_VECTOR_INC_IND_VAR9:%.*]], [[DIM_0_VECTOR_EXIT2:%.*]] ]
; CHECK-NEXT:    br label [[MASKED_KERNEL_ENTRY:%.*]]
; CHECK:       masked_kernel_entry:
; CHECK-NEXT:    [[DIM_0_VECTOR_IND_VAR3:%.*]] = phi i64 [ [[MAX_VECTOR_GID]], [[DIM_0_VECTOR_PRE_HEAD1]] ], [ [[DIM_0_VECTOR_INC_IND_VAR4:%.*]], [[MASKED_KERNEL_ENTRY]] ]
; CHECK-NEXT:    [[SEXT:%.*]] = shl i64 [[DIM_0_VECTOR_IND_VAR3]], 32
; CHECK-NEXT:    [[DOTEXTRACT_0_:%.*]] = ashr exact i64 [[SEXT]], 32
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne <16 x i32> [[MASK_I32]], zeroinitializer
; CHECK-NEXT:    [[SCALAR_GEP5:%.*]] = getelementptr inbounds i32, i32 addrspace(1)* [[DST]], i64 [[DOTEXTRACT_0_]]
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i32 addrspace(1)* [[SCALAR_GEP5]] to <16 x i32> addrspace(1)*
; CHECK-NEXT:    call void @llvm.masked.store.v16i32.p1v16i32(<16 x i32> zeroinitializer, <16 x i32> addrspace(1)* [[TMP7]], i32 4, <16 x i1> [[TMP6]])
; CHECK-NEXT:    [[DIM_0_VECTOR_INC_IND_VAR4]] = add nuw nsw i64 [[DIM_0_VECTOR_IND_VAR3]], 16
; CHECK-NEXT:    [[DIM_0_VECTOR_CMP_TO_MAX5:%.*]] = icmp sge i64 [[DIM_0_VECTOR_INC_IND_VAR4]], [[MAX_GID_DIM0]]
; CHECK-NEXT:    br i1 [[DIM_0_VECTOR_CMP_TO_MAX5]], label [[DIM_0_VECTOR_EXIT2]], label [[MASKED_KERNEL_ENTRY]]
; CHECK:       dim_0_vector_exit2:
; CHECK-NEXT:    [[DIM_1_VECTOR_INC_IND_VAR9]] = add nuw nsw i64 [[DIM_1_VECTOR_IND_VAR8]], 1
; CHECK-NEXT:    [[DIM_1_VECTOR_CMP_TO_MAX10:%.*]] = icmp sge i64 [[DIM_1_VECTOR_INC_IND_VAR9]], [[MAX_GID_DIM1]]
; CHECK-NEXT:    br i1 [[DIM_1_VECTOR_CMP_TO_MAX10]], label [[DIM_1_VECTOR_EXIT7]], label [[DIM_0_VECTOR_PRE_HEAD1]]
; CHECK:       dim_1_vector_exit7:
; CHECK-NEXT:    [[DIM_2_VECTOR_INC_IND_VAR14]] = add nuw nsw i64 [[DIM_2_VECTOR_IND_VAR13]], 1
; CHECK-NEXT:    [[DIM_2_VECTOR_CMP_TO_MAX15:%.*]] = icmp sge i64 [[DIM_2_VECTOR_INC_IND_VAR14]], [[MAX_GID_DIM2]]
; CHECK-NEXT:    br i1 [[DIM_2_VECTOR_CMP_TO_MAX15]], label [[DIM_2_VECTOR_EXIT12:%.*]], label [[DIM_1_VECTOR_PRE_HEAD6]]
; CHECK:       dim_2_vector_exit12:
; CHECK-NEXT:    br label [[RET]]
; CHECK:       ret:
; CHECK-NEXT:    br label [[EXIT]]
; CHECK:       exit:
; CHECK-NEXT:    ret void
;
entry:
  %call = tail call i64 @_Z13get_global_idj(i32 noundef 0) #3
  %arrayidx = getelementptr inbounds i32, i32 addrspace(1)* %dst, i64 %call
  store i32 0, i32 addrspace(1)* %arrayidx, align 4, !tbaa !12
  ret void
}

; Function Attrs: convergent mustprogress nofree nounwind readnone willreturn
declare i64 @_Z13get_global_idj(i32 noundef) local_unnamed_addr #1

define [7 x i64] @WG.boundaries.test(i32 addrspace(1)* %0) {
entry:
  %1 = call i64 @_Z14get_local_sizej(i32 0)
  %2 = call i64 @get_base_global_id.(i32 0)
  %3 = call i64 @_Z14get_local_sizej(i32 1)
  %4 = call i64 @get_base_global_id.(i32 1)
  %5 = call i64 @_Z14get_local_sizej(i32 2)
  %6 = call i64 @get_base_global_id.(i32 2)
  %7 = insertvalue [7 x i64] undef, i64 %1, 2
  %8 = insertvalue [7 x i64] %7, i64 %2, 1
  %9 = insertvalue [7 x i64] %8, i64 %3, 4
  %10 = insertvalue [7 x i64] %9, i64 %4, 3
  %11 = insertvalue [7 x i64] %10, i64 %5, 6
  %12 = insertvalue [7 x i64] %11, i64 %6, 5
  %13 = insertvalue [7 x i64] %12, i64 1, 0
  ret [7 x i64] %13
}

declare i64 @_Z14get_local_sizej(i32)

declare i64 @get_base_global_id.(i32)

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn writeonly
define dso_local void @_ZGVeN16u_test(i32 addrspace(1)* nocapture noundef writeonly %dst) local_unnamed_addr #0 !kernel_arg_addr_space !2 !kernel_arg_access_qual !3 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !5 !kernel_arg_name !6 !kernel_arg_host_accessible !7 !kernel_arg_pipe_depth !8 !kernel_arg_pipe_io !5 !kernel_arg_buffer_location !5 !no_barrier_path !9 !kernel_has_sub_groups !7 !vectorized_width !16 !vectorization_dimension !8 !can_unite_workgroups !7 !scalar_kernel !1 {
entry:
  %call = tail call i64 @_Z13get_global_idj(i32 noundef 0) #3
  %sext = shl i64 %call, 32
  %.extract.0. = ashr exact i64 %sext, 32
  %scalar.gep = getelementptr inbounds i32, i32 addrspace(1)* %dst, i64 %.extract.0.
  %0 = bitcast i32 addrspace(1)* %scalar.gep to <16 x i32> addrspace(1)*
  store <16 x i32> zeroinitializer, <16 x i32> addrspace(1)* %0, align 4
  ret void
}

; Function Attrs: convergent mustprogress nofree norecurse nounwind willreturn writeonly
define dso_local void @_ZGVeM16u_test(i32 addrspace(1)* nocapture noundef writeonly %dst, <16 x i32> %mask) local_unnamed_addr #0 !kernel_arg_addr_space !2 !kernel_arg_access_qual !3 !kernel_arg_type !4 !kernel_arg_base_type !4 !kernel_arg_type_qual !5 !kernel_arg_name !6 !kernel_arg_host_accessible !7 !kernel_arg_pipe_depth !8 !kernel_arg_pipe_io !5 !kernel_arg_buffer_location !5 !no_barrier_path !9 !kernel_has_sub_groups !7 !vectorized_kernel !10 !vectorized_width !16 !vectorization_dimension !8 !can_unite_workgroups !7 !scalar_kernel !1 {
entry:
  %call = tail call i64 @_Z13get_global_idj(i32 noundef 0) #3
  %sext = shl i64 %call, 32
  %.extract.0. = ashr exact i64 %sext, 32
  %0 = icmp ne <16 x i32> %mask, zeroinitializer
  %scalar.gep5 = getelementptr inbounds i32, i32 addrspace(1)* %dst, i64 %.extract.0.
  %1 = bitcast i32 addrspace(1)* %scalar.gep5 to <16 x i32> addrspace(1)*
  call void @llvm.masked.store.v16i32.p1v16i32(<16 x i32> zeroinitializer, <16 x i32> addrspace(1)* %1, i32 4, <16 x i1> %0)
  ret void
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn writeonly
declare void @llvm.masked.store.v16i32.p1v16i32(<16 x i32>, <16 x i32> addrspace(1)*, i32 immarg, <16 x i1>) #2

attributes #0 = { convergent mustprogress nofree norecurse nounwind willreturn writeonly "vector-variants"="_ZGVeN16u_test,_ZGVeM16u_test" }
attributes #1 = { convergent mustprogress nofree nounwind readnone willreturn }
attributes #2 = { argmemonly nofree nosync nounwind willreturn writeonly }
attributes #3 = { convergent nounwind readnone willreturn }

!opencl.ocl.version = !{!0}
!opencl.spir.version = !{!0}
!sycl.kernels = !{!1}

!0 = !{i32 1, i32 2}
!1 = !{void (i32 addrspace(1)*)* @test}
!2 = !{i32 1}
!3 = !{!"none"}
!4 = !{!"int*"}
!5 = !{!""}
!6 = !{!"dst"}
!7 = !{i1 false}
!8 = !{i32 0}
!9 = !{i1 true}
!10 = !{void (i32 addrspace(1)*)* @_ZGVeN16u_test}
!11 = !{void (i32 addrspace(1)*, <16 x i32>)* @_ZGVeM16u_test}
!12 = !{!13, !13, i64 0}
!13 = !{!"int", !14, i64 0}
!14 = !{!"omnipotent char", !15, i64 0}
!15 = !{!"Simple C/C++ TBAA"}
!16 = !{i32 16}

; DEBUGIFY-COUNT-53: WARNING: Instruction with empty DebugLoc in function test
; DEBUGIFY: WARNING: Missing line 1
; DEBUGIFY: WARNING: Missing line 2
; DEBUGIFY: WARNING: Missing line 3
; DEBUGIFY: WARNING: Missing line 4
; DEBUGIFY: WARNING: Missing line 19
; DEBUGIFY: WARNING: Missing line 25
; DEBUGIFY: WARNING: Missing line 26
; DEBUGIFY: WARNING: Missing variable 1
; DEBUGIFY: WARNING: Missing variable 2
; DEBUGIFY-NOT: WARNING
