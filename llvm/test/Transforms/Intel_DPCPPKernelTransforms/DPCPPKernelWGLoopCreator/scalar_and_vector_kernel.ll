; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;; Test loops created with LoopCreator in
;; presence of both scalar and vector kernels.

; RUN: opt -dpcpp-kernel-wgloop-creator < %s -S -o - | FileCheck %s
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

define dso_local void @_Z30ParallelForNDRangeImplKernel1DPiS_S_mmm(i32* nocapture %out, i32* nocapture readnone %dummy1, i32* nocapture readnone %dummy2, i64 %LocalRange0, i64 %LocalRange1, i64 %LocalRange2) #0 {
; CHECK-LABEL: @_Z30ParallelForNDRangeImplKernel1DPiS_S_mmm(
; CHECK-NEXT:    [[VECTOR_SIZE:%.*]] = ashr i64 %LocalRange0, 4
; CHECK-NEXT:    [[NUM_VECTOR_WI:%.*]] = shl i64 [[VECTOR_SIZE]], 4
; CHECK-NEXT:    [[MAX_VECTOR_GID:%.*]] = add i64 [[NUM_VECTOR_WI]], 0
; CHECK-NEXT:    [[SCALAR_SIZE:%.*]] = sub i64 %LocalRange0, [[NUM_VECTOR_WI]]
; CHECK-NEXT:    br label %vect_if
; CHECK:       vect_if:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i64 [[VECTOR_SIZE]], 0
; CHECK-NEXT:    br i1 [[TMP1]], label [[DIM_2_VECTOR_PRE_HEAD:%.*]], label [[SCALARIF:%.*]]
; CHECK:       dim_2_vector_pre_head:
; CHECK-NEXT:    br label [[DIM_1_VECTOR_PRE_HEAD:%.*]]
; CHECK:       dim_1_vector_pre_head:
; CHECK-NEXT:    [[DIM_2_VECTOR_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_2_VECTOR_PRE_HEAD]] ], [ [[DIM_2_VECTOR_INC_IND_VAR:%.*]], [[DIM_1_VECTOR_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[DIM_0_VECTOR_PRE_HEAD:%.*]]
; CHECK:       dim_0_vector_pre_head:
; CHECK-NEXT:    [[DIM_1_VECTOR_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_1_VECTOR_PRE_HEAD]] ], [ [[DIM_1_VECTOR_INC_IND_VAR:%.*]], [[DIM_0_VECTOR_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[ENTRYVECTOR_FUNC:%.*]]
; CHECK:       entryvector_func:
; CHECK-NEXT:    [[DIM_0_VECTOR_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_0_VECTOR_PRE_HEAD]] ], [ [[DIM_0_VECTOR_INC_IND_VAR:%.*]], [[ENTRYVECTOR_FUNC]] ]
; CHECK-NEXT:    [[DIM0__TID:%.*]] = phi i64 [ 0, [[DIM_0_VECTOR_PRE_HEAD]] ], [ [[DIM0_INC_TID:%.*]], [[ENTRYVECTOR_FUNC]] ]
;; Check that trunc has been replaced correctly.
; CHECK-NEXT:    [[TRUNC_DIM0:%.*]] = trunc i64 [[DIM0__TID]] to i32
;; snip snip
; CHECK:         [[DIM_0_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_0_VECTOR_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_0_VECTOR_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_0_VECTOR_INC_IND_VAR]], [[VECTOR_SIZE]]
; CHECK-NEXT:    [[DIM0_INC_TID]] = add nuw nsw i64 [[DIM0__TID]], 16
; CHECK-NEXT:    br i1 [[DIM_0_VECTOR_CMP_TO_MAX]], label [[DIM_0_VECTOR_EXIT]], label [[ENTRYVECTOR_FUNC]]
; CHECK:       dim_0_vector_exit:
; CHECK-NEXT:    [[DIM_1_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_1_VECTOR_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_1_VECTOR_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_1_VECTOR_INC_IND_VAR]], %LocalRange1
; CHECK-NEXT:    br i1 [[DIM_1_VECTOR_CMP_TO_MAX]], label [[DIM_1_VECTOR_EXIT]], label [[DIM_0_VECTOR_PRE_HEAD]]
; CHECK:       dim_1_vector_exit:
; CHECK-NEXT:    [[DIM_2_VECTOR_INC_IND_VAR]] = add nuw nsw i64 [[DIM_2_VECTOR_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_2_VECTOR_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_2_VECTOR_INC_IND_VAR]], %LocalRange2
; CHECK-NEXT:    br i1 [[DIM_2_VECTOR_CMP_TO_MAX]], label [[DIM_2_VECTOR_EXIT:%.*]], label [[DIM_1_VECTOR_PRE_HEAD]]
; CHECK:       dim_2_vector_exit:
; CHECK-NEXT:    br label [[SCALARIF]]
; CHECK:       scalarIf:
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i64 [[SCALAR_SIZE]], 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[DIM_2_PRE_HEAD:%.*]], label [[RET:%.*]]
; CHECK:       dim_2_pre_head:
; CHECK-NEXT:    br label [[DIM_1_PRE_HEAD:%.*]]
; CHECK:       dim_1_pre_head:
; CHECK-NEXT:    [[DIM_2_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_2_PRE_HEAD]] ], [ [[DIM_2_INC_IND_VAR:%.*]], [[DIM_1_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[DIM_0_PRE_HEAD:%.*]]
; CHECK:       dim_0_pre_head:
; CHECK-NEXT:    [[DIM_1_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_1_PRE_HEAD]] ], [ [[DIM_1_INC_IND_VAR:%.*]], [[DIM_0_EXIT:%.*]] ]
; CHECK-NEXT:    br label [[SCALAR_KERNEL_ENTRY:%.*]]
; CHECK:       scalar_kernel_entry:
; CHECK-NEXT:    [[DIM_0_IND_VAR:%.*]] = phi i64 [ 0, [[DIM_0_PRE_HEAD]] ], [ [[DIM_0_INC_IND_VAR:%.*]], [[SCALAR_KERNEL_ENTRY]] ]
; CHECK-NEXT:    [[DIM0__TID1:%.*]] = phi i64 [ [[MAX_VECTOR_GID]], [[DIM_0_PRE_HEAD]] ], [ [[DIM0_INC_TID2:%.*]], [[SCALAR_KERNEL_ENTRY]] ]
;; snip snip
; CHECK:         [[DIM_0_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_0_INC_IND_VAR]], [[SCALAR_SIZE]]
; CHECK-NEXT:    [[DIM0_INC_TID2]] = add nuw nsw i64 [[DIM0__TID1]], 1
; CHECK-NEXT:    br i1 [[DIM_0_CMP_TO_MAX]], label [[DIM_0_EXIT]], label [[SCALAR_KERNEL_ENTRY]]
; CHECK:       dim_0_exit:
; CHECK-NEXT:    [[DIM_1_INC_IND_VAR]] = add nuw nsw i64 [[DIM_1_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_1_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_1_INC_IND_VAR]], %LocalRange1
; CHECK-NEXT:    br i1 [[DIM_1_CMP_TO_MAX]], label [[DIM_1_EXIT]], label [[DIM_0_PRE_HEAD]]
; CHECK:       dim_1_exit:
; CHECK-NEXT:    [[DIM_2_INC_IND_VAR]] = add nuw nsw i64 [[DIM_2_IND_VAR]], 1
; CHECK-NEXT:    [[DIM_2_CMP_TO_MAX:%.*]] = icmp eq i64 [[DIM_2_INC_IND_VAR]], %LocalRange2
; CHECK-NEXT:    br i1 [[DIM_2_CMP_TO_MAX]], label [[DIM_2_EXIT:%.*]], label [[DIM_1_PRE_HEAD]]
; CHECK:       dim_2_exit:
; CHECK-NEXT:    br label [[RET]]
; CHECK:       ret:
; CHECK-NEXT:    br label [[TMP6:%.*]]
; CHECK:       6:
; CHECK-NEXT:    ret void

;; If we don't have optnone noinline should be removed
; CHECK-NOT: noinline

entry:
  %call = tail call i64 @__builtin_get_local_id(i64 0)
  %arrayidx = getelementptr inbounds i32, i32* %out, i64 %call
  store i32 12345, i32* %arrayidx, align 4
  ret void
}

declare dso_local i64 @__builtin_get_local_id(i64 %0) local_unnamed_addr 

define dso_local void @_ZGVbN16uuuuuu_30ParallelForNDRangeImplKernel1DPiS_S_mmm(i32* nocapture %out, i32* nocapture readnone %dummy1, i32* nocapture readnone %dummy2, i64 %LocalRange0, i64 %LocalRange1, i64 %LocalRange2) #1 {
entry:
  %call = tail call i64 @__builtin_get_local_id(i64 0)
  %0 = trunc i64 %call to i32
  %1 = add i32 0, %0
  %.extract.0. = sext i32 %1 to i64
  %scalar.gep = getelementptr inbounds i32, i32* %out, i64 %.extract.0.
  %2 = bitcast i32* %scalar.gep to <16 x i32>*
  store <16 x i32> <i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345, i32 12345>, <16 x i32>* %2, align 4
  ret void
}

attributes #0 = { noinline "dpcpp-no-barrier-path"="true" "scalar_kernel" "sycl_kernel" "vectorized_kernel"="_ZGVbN16uuuuuu_30ParallelForNDRangeImplKernel1DPiS_S_mmm" "vectorized_width"="1" }
attributes #1 = { noinline "scalar_kernel"="_Z30ParallelForNDRangeImplKernel1DPiS_S_mmm" "vectorized_kernel" "vectorized_width"="16" }

