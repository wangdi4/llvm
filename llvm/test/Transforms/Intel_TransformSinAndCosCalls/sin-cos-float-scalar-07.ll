; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;
; Test case:
; . float sinf/cosf (add and mul constants)
; . scalar (sinf/cosf will not be vectorized by compiler)
; . precision: low
; . fast-math: yes
;
; Compilation options:
; icpx -O2 -ffast-math -fimf-precision=low
;
; #include <math.h>
;
; #define FP_NUM 7.38906f
; #define PI     3.14159265358979f
;
; float Compute(float fArg)
; {
;   float f1, f2, f3, f4;
;
;   float arg_mul   = (FP_NUM + fArg) * PI;
;   float arg_mul_2 = ((FP_NUM + (2.0 * fArg))) * PI;
;   f1 = sinf(arg_mul);
;   f2 = cosf(arg_mul + 1);
;
;   f3 = sinf(arg_mul_2);
;   f4 = cosf(arg_mul_2 + 1);
;
;   return (f1 + f2 + f3 + f4);
; }
;
; RUN: opt < %s -transform-sin-cos-calls -S 2>&1 | FileCheck %s
; RUN: opt -passes="transform-sin-cos-calls" -S 2>&1 < %s | FileCheck %s
;
; CHECK-LABEL: @_Z7Computef(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = fmul fast float [[FARG:%.*]], 0x400921FB60000000
; CHECK-NEXT:    [[MUL:%.*]] = fadd fast float [[TMP0]], 0x403736A280000000
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[FARG]] to double
; CHECK-NEXT:    [[TMP1:%.*]] = fmul fast double [[CONV]], 0x401921FB60000000
; CHECK-NEXT:    [[MUL3:%.*]] = fadd fast double [[TMP1]], 0x403736A284874B40
; CHECK-NEXT:    [[CONV4:%.*]] = fptrunc double [[MUL3]] to float
; CHECK-NEXT:    [[DOTOVERPI:%.*]] = fmul fast float [[FARG]], 1.000000e+00
; CHECK-NEXT:    [[MUL_OVERPI:%.*]] = fadd fast float [[DOTOVERPI]], 0x401D8E65C0000000
; CHECK-NEXT:    [[TMP2:%.*]] = tail call fast float @sinpif(float [[MUL_OVERPI]]) [[ATTR0:#.*]]
; CHECK-NEXT:    [[ADD5:%.*]] = fadd fast float [[TMP0]], 0x403836A280000000
; CHECK-NEXT:    [[DOTOVERPI1:%.*]] = fmul fast float [[FARG]], 1.000000e+00
; CHECK-NEXT:    [[ADD5_OVERPI:%.*]] = fadd fast float [[DOTOVERPI1]], 0x401ED458C0000000
; CHECK-NEXT:    [[TMP3:%.*]] = tail call fast float @cospif(float [[ADD5_OVERPI]]) [[ATTR0]]
; CHECK-NEXT:    [[TMP4:%.*]] = tail call fast float @llvm.sin.f32(float [[CONV4]]) [[ATTR0]]
; CHECK-NEXT:    [[ADD6:%.*]] = fadd fast float [[CONV4]], 1.000000e+00
; CHECK-NEXT:    [[TMP5:%.*]] = tail call fast float @llvm.cos.f32(float [[ADD6]]) [[ATTR0]]
; CHECK-NEXT:    [[ADD7:%.*]] = fadd fast float [[TMP2]], [[TMP3]]
; CHECK-NEXT:    [[ADD8:%.*]] = fadd fast float [[ADD7]], [[TMP4]]
; CHECK-NEXT:    [[ADD9:%.*]] = fadd fast float [[ADD8]], [[TMP5]]
; CHECK-NEXT:    ret float [[ADD9]]
;
; Function Attrs: nounwind readnone uwtable willreturn mustprogress
define dso_local float @_Z7Computef(float %fArg) local_unnamed_addr #0 {
entry:
  %0 = fmul fast float %fArg, 0x400921FB60000000
  %mul = fadd fast float %0, 0x403736A280000000
  %conv = fpext float %fArg to double
  %1 = fmul fast double %conv, 0x401921FB60000000
  %mul3 = fadd fast double %1, 0x403736A284874B40
  %conv4 = fptrunc double %mul3 to float
  %2 = tail call fast float @llvm.sin.f32(float %mul) #2
  %add5 = fadd fast float %0, 0x403836A280000000
  %3 = tail call fast float @llvm.cos.f32(float %add5) #2
  %4 = tail call fast float @llvm.sin.f32(float %conv4) #2
  %add6 = fadd fast float %conv4, 1.000000e+00
  %5 = tail call fast float @llvm.cos.f32(float %add6) #2
  %add7 = fadd fast float %2, %3
  %add8 = fadd fast float %add7, %4
  %add9 = fadd fast float %add8, %5
  ret float %add9
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.sin.f32(float) #1

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.cos.f32(float) #1

attributes #0 = { "imf-precision"="low" }
attributes #1 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { "imf-precision"="low" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"Intel(R) oneAPI DPC++ Compiler 2021.2.0 (2021.2.0.YYYYMMDD)"}
