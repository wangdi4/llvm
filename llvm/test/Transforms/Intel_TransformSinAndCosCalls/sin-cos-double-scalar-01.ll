; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
;
; Test case:
; . double sin/cos (various patterns)
; . scalar (sin/cos will not be vectorized by compiler)
; . precision: low
; . fast-math: yes
; . enable transformation of double sin/cos to sinpi/cospi (float enabled by default)
;
; Compilation options:
; icpx -O2 -ffast-math -fimf-precision=low -mllvm -enable-transform-sin-cos-double
;
; #include <math.h>
;
; #define NUM 7.38906
; #define PI  3.14159265358979
;
; double Compute(double fArg)
; {
;   double f1, f2, f3, f4, f5, f6, f7, f8;
;
;   f1 = sin(8.0 * fArg);
;   f2 = cos(8.0 * fArg);
;
;   f3 = sin(fArg * (10.0 + NUM));
;   f4 = cos(fArg * 10.25);
;
;   f5 = sin(fArg - 20.0);
;   f6 = cos(fArg * fArg);
;
;   double arg_mul = (NUM + fArg)*PI;
;   f7 = sin(arg_mul);
;   f8 = cos(arg_mul);
;
;   return (f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8);
; }
;
; RUN: opt -passes="transform-sin-cos-calls" -enable-transform-sin-cos-double -S 2>&1 < %s | FileCheck %s
;
; CHECK-LABEL: @_Z7Computed(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[MUL:%.*]] = fmul fast double [[FARG:%.*]], 8.000000e+00
; CHECK-NEXT:    [[TMP0:%.*]] = tail call fast double @llvm.sin.f64(double [[MUL]]) [[ATTR1:#.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = tail call fast double @llvm.cos.f64(double [[MUL]]) [[ATTR1]]
; CHECK-NEXT:    [[MUL2:%.*]] = fmul fast double [[FARG]], 0x403163996FA82E88
; CHECK-NEXT:    [[MUL2_OVERPI:%.*]] = fmul fast double [[FARG]], 0x401623F3CCB75222
; CHECK-NEXT:    [[TMP2:%.*]] = tail call fast double @sinpi(double [[MUL2_OVERPI]]) [[ATTR1]]
; CHECK-NEXT:    [[MUL3:%.*]] = fmul fast double [[FARG]], 1.025000e+01
; CHECK-NEXT:    [[MUL3_OVERPI:%.*]] = fmul fast double [[FARG]], 0x400A19F60CAA88E7
; CHECK-NEXT:    [[TMP3:%.*]] = tail call fast double @cospi(double [[MUL3_OVERPI]]) [[ATTR1]]
; CHECK-NEXT:    [[SUB:%.*]] = fadd fast double [[FARG]], -2.000000e+01
; CHECK-NEXT:    [[TMP4:%.*]] = tail call fast double @llvm.sin.f64(double [[SUB]]) [[ATTR1]]
; CHECK-NEXT:    [[MUL4:%.*]] = fmul fast double [[FARG]], [[FARG]]
; CHECK-NEXT:    [[TMP5:%.*]] = tail call fast double @llvm.cos.f64(double [[MUL4]]) [[ATTR1]]
; CHECK-NEXT:    [[TMP6:%.*]] = fmul fast double [[FARG]], 0x400921FB54442D11
; CHECK-NEXT:    [[MUL5:%.*]] = fadd fast double [[TMP6]], 0x403736A2789CF9B1
; CHECK-NEXT:    [[TMP7:%.*]] = tail call fast double @llvm.sin.f64(double [[MUL5]]) [[ATTR1]]
; CHECK-NEXT:    [[TMP8:%.*]] = tail call fast double @llvm.cos.f64(double [[MUL5]]) [[ATTR1]]
; CHECK-NEXT:    [[ADD6:%.*]] = fadd fast double [[TMP0]], [[TMP1]]
; CHECK-NEXT:    [[ADD7:%.*]] = fadd fast double [[ADD6]], [[TMP2]]
; CHECK-NEXT:    [[ADD8:%.*]] = fadd fast double [[ADD7]], [[TMP3]]
; CHECK-NEXT:    [[ADD9:%.*]] = fadd fast double [[ADD8]], [[TMP4]]
; CHECK-NEXT:    [[ADD10:%.*]] = fadd fast double [[ADD9]], [[TMP5]]
; CHECK-NEXT:    [[ADD11:%.*]] = fadd fast double [[ADD10]], [[TMP7]]
; CHECK-NEXT:    [[ADD12:%.*]] = fadd fast double [[ADD11]], [[TMP8]]
; CHECK-NEXT:    ret double [[ADD12]]
;
; Function Attrs: nounwind readnone uwtable willreturn mustprogress
define dso_local double @_Z7Computed(double %fArg) local_unnamed_addr #0 {
entry:
  %mul = fmul fast double %fArg, 8.000000e+00
  %0 = tail call fast double @llvm.sin.f64(double %mul) #2
  %1 = tail call fast double @llvm.cos.f64(double %mul) #2
  %mul2 = fmul fast double %fArg, 0x403163996FA82E88
  %2 = tail call fast double @llvm.sin.f64(double %mul2) #2
  %mul3 = fmul fast double %fArg, 1.025000e+01
  %3 = tail call fast double @llvm.cos.f64(double %mul3) #2
  %sub = fadd fast double %fArg, -2.000000e+01
  %4 = tail call fast double @llvm.sin.f64(double %sub) #2
  %mul4 = fmul fast double %fArg, %fArg
  %5 = tail call fast double @llvm.cos.f64(double %mul4) #2
  %6 = fmul fast double %fArg, 0x400921FB54442D11
  %mul5 = fadd fast double %6, 0x403736A2789CF9B1
  %7 = tail call fast double @llvm.sin.f64(double %mul5) #2
  %8 = tail call fast double @llvm.cos.f64(double %mul5) #2
  %add6 = fadd fast double %0, %1
  %add7 = fadd fast double %add6, %2
  %add8 = fadd fast double %add7, %3
  %add9 = fadd fast double %add8, %4
  %add10 = fadd fast double %add9, %5
  %add11 = fadd fast double %add10, %7
  %add12 = fadd fast double %add11, %8
  ret double %add12
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare double @llvm.sin.f64(double) #1

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare double @llvm.cos.f64(double) #1

attributes #0 = { "imf-precision"="low" }
attributes #1 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { "imf-precision"="low" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"Intel(R) oneAPI DPC++ Compiler 2021.2.0 (2021.2.0.YYYYMMDD)"}
