; RUN: opt -passes=auto-cpu-clone -acd-enable-all < %s -S | FileCheck %s

; This test checks that functions are multi-versioned correctly, when there are global variables
; present in IR with names matching those of clones, generated by ACD, as in foo.a and foo.A
; in the input IR below.


; CHECK:      @foo.ptr = internal global ptr @foo.A.3, !llvm.acd.dispatcher !0
; CHECK:      @llvm.global_ctors = appending global [2 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 500, ptr @__intel.acd.resolver, ptr null }, { i32, ptr, ptr } { i32 0, ptr @__intel_cpu_features_init_x, ptr null }]
; CHECK:      define dso_local i32 @foo.A.3(i32 noundef %i) local_unnamed_addr #0 !llvm.acd.clone !0 {
; CHECK:      define dso_local i32 @foo.a.2(i32 noundef %i) local_unnamed_addr #1 !llvm.acd.clone !0 {

; CHECK:      define internal void @__intel.acd.resolver() #2 {
; CHECK-NEXT:   resolver_entry:
; CHECK-NEXT:   %cpu_feature_indicator = load i64, ptr @__intel_cpu_feature_indicator_x, align 8
; CHECK-NEXT:   %cpu_feature_join = and i64 %cpu_feature_indicator, 429926490094
; CHECK-NEXT:   %cpu_feature_check = icmp eq i64 %cpu_feature_join, 429926490094
; CHECK-NEXT:   br i1 %cpu_feature_check, label %resolver_return, label %resolver_else
; CHECK-EMPTY:
; CHECK-NEXT: resolver_return:                                  ; preds = %resolver_entry
; CHECK-NEXT:   store ptr @foo.a.2, ptr @foo.ptr, align 8
; CHECK-NEXT:   br label %resolver_exit
; CHECK-EMPTY:
; CHECK-NEXT: resolver_else:                                    ; preds = %resolver_entry
; CHECK-NEXT:   store ptr @foo.A.3, ptr @foo.ptr, align 8
; CHECK-NEXT:   br label %resolver_exit
; CHECK-EMPTY:
; CHECK-NEXT: resolver_exit:                                    ; preds = %resolver_else, %resolver_return
; CHECK-NEXT:   ret void
; CHECK-NEXT: }

; CHECK:      define dso_local i32 @foo(i32 noundef %i) local_unnamed_addr #0 !llvm.acd.dispatcher !0 {
; CHECK-NEXT:   %1 = load ptr, ptr @foo.ptr, align 8
; CHECK-NEXT:   %2 = call i32 %1(i32 noundef %i)
; CHECK-NEXT:   ret i32 %2
; CHECK-NEXT: }


target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-windows-msvc19.29.30133"

@foo.a = internal unnamed_addr constant [6 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5], align 16
@foo.A = internal unnamed_addr constant [6 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5], align 16

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local i32 @foo(i32 noundef %i) local_unnamed_addr #0 !llvm.auto.arch !3 {
entry:
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds [6 x i32], ptr @foo.A, i64 0, i64 %idxprom
  %0 = load i32, ptr %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds [6 x i32], ptr @foo.a, i64 0, i64 %idxprom
  %1 = load i32, ptr %arrayidx2, align 4
  %add = add nsw i32 %1, %0
  ret i32 %add
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable "approx-func-fp-math"="true" "denormal-fp-math"="preserve-sign,preserve-sign" "loopopt-pipeline"="light" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "pre_loopopt" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" "unsafe-fp-math"="true" }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"uwtable", i32 2}
!3 = !{!"skylake-avx512"}
