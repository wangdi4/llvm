; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes="instsimplify" -enable-intel-advanced-opts=true -mtriple=x86_64-unknown -mattr=+avx512f -mcpu=skylake-avx512 -S | FileCheck %s
; RUN: opt < %s -instsimplify -enable-intel-advanced-opts -mtriple=x86_64-unknown -mcpu=skylake-avx512 -S | FileCheck %s

; Basic test
; Because icmp is over two selects which have the same condition,
; We try to simplify by trying two cases:
;  - TCmp: icmp sle i32 %arg, %arg (true)
;  - FCmp: icmp sle i32 1, 8       (true)
; Later in the test we use abbreviations:
;  - TCmp - icmp with operands from true branches of the select
;  - FCmp - icmp with operands from false branches of the select
define i1 @foldKnownIcmp(i32 %arg) {
; CHECK-LABEL: @foldKnownIcmp(
; CHECK-NEXT:    ret i1 true
;
  %cmp = icmp ne i32 %arg, 0
  %tmp = select i1 %cmp, i32 %arg, i32 1
  %tmp1 = select i1 %cmp, i32 %arg, i32 8
  %cmp1 = icmp sle i32 %tmp, %tmp1
  ret i1 %cmp1
}

; No folding, because TCmp is not simplifiable
define i1 @noFoldingTcmp(i32 %arg1, i32 %arg2) {
; CHECK-LABEL: @noFoldingTcmp(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[ARG1:%.*]], 0
; CHECK-NEXT:    [[TMP:%.*]] = select i1 [[CMP]], i32 [[ARG1]], i32 1
; CHECK-NEXT:    [[TMP1:%.*]] = select i1 [[CMP]], i32 [[ARG2:%.*]], i32 8
; CHECK-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[CMP1]]
;
  %cmp = icmp ne i32 %arg1, 0
  %tmp = select i1 %cmp, i32 %arg1, i32 1
  %tmp1 = select i1 %cmp, i32 %arg2, i32 8
  %cmp1 = icmp sle i32 %tmp, %tmp1
  ret i1 %cmp1
}

; No folding, because FCmp is not simplifiable
define i1 @noFoldingFcmp(i32 %arg1, i32 %arg2) {
; CHECK-LABEL: @noFoldingFcmp(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i32 [[ARG1:%.*]], 0
; CHECK-NEXT:    [[TMP:%.*]] = select i1 [[CMP]], i32 1, i32 [[ARG1]]
; CHECK-NEXT:    [[TMP1:%.*]] = select i1 [[CMP]], i32 8, i32 [[ARG2:%.*]]
; CHECK-NEXT:    [[CMP1:%.*]] = icmp sle i32 [[TMP]], [[TMP1]]
; CHECK-NEXT:    ret i1 [[CMP1]]
;
  %cmp = icmp ne i32 %arg1, 0
  %tmp = select i1 %cmp, i32 1, i32 %arg1
  %tmp1 = select i1 %cmp, i32 8, i32 %arg2
  %cmp1 = icmp sle i32 %tmp, %tmp1
  ret i1 %cmp1
}

; TCmp simplified to the select condition (%X)
; FCmp simplified to false
; Comparison is simplified to: (%X || false) => %X
define i1 @foldTcmpToSelectCondition(i1 %X) {
; CHECK-LABEL: @foldTcmpToSelectCondition(
; CHECK-NEXT:    ret i1 [[X:%.*]]
;
  %E = zext i1 %X to i32
  %V = select i1 %X, i32 %E, i32 0
  %W = select i1 %X, i32 0, i32 0
  %R = icmp ne i32 %V, %W
  ret i1 %R
}

; TCmp simplified to true
; FCmp simplified to the select condition (%X)
; Comparison is simplified to: (%X && true) => %X
define i1 @foldFcmpToSelectCondition(i1 %X) {
; CHECK-LABEL: @foldFcmpToSelectCondition(
; CHECK-NEXT:    ret i1 [[X:%.*]]
;
  %E = zext i1 %X to i32
  %V = select i1 %X, i32 0, i32 %E
  %W = select i1 %X, i32 1, i32 0
  %R = icmp ne i32 %V, %W
  ret i1 %R
}

; TCmp simplified to the same comparison as %C (true)
; FCmp is also simplified to true
; Comparison is simplified to: true
define i1 @foldTCmpSameCompAsSelect(i32 %X) {
; CHECK-LABEL: @foldTCmpSameCompAsSelect(
; CHECK-NEXT:    ret i1 true
;
  %C = icmp slt i32 %X, 7
  %V = select i1 %C, i32 %X, i32 0
  %W = select i1 %C, i32 7, i32 1
  %R = icmp slt i32 %V, %W
  ret i1 %R
}

; TCmp is also simplified to false
; FCmp simplified to the same comparison as %C (false)
; Comparison is simplified to: false
define i1 @foldFCmpSameCompAsSelect(i32 %X) {
; CHECK-LABEL: @foldFCmpSameCompAsSelect(
; CHECK-NEXT:    ret i1 false
;
  %C = icmp slt i32 %X, 7
  %V = select i1 %C, i32 1, i32 %X
  %W = select i1 %C, i32 0, i32 7
  %R = icmp slt i32 %V, %W
  ret i1 %R
}

; Test case doesn't work right now!
; FCmp is simplified to true
; TCmp is simplified to false
; Comparison can be simplified to: ~%X
define i1 @foldFcmpToTrueTCmpToFalse(i1 %X) {
; CHECK-LABEL: @foldFcmpToTrueTCmpToFalse(
; CHECK-NEXT:    [[V:%.*]] = select i1 [[X:%.*]], i32 0, i32 1
; CHECK-NEXT:    [[W:%.*]] = select i1 [[X]], i32 0, i32 2
; CHECK-NEXT:    [[R:%.*]] = icmp ne i32 [[V]], [[W]]
; CHECK-NEXT:    ret i1 [[R]]
;
  %E = zext i1 %X to i32
  %V = select i1 %X, i32 0, i32 1
  %W = select i1 %X, i32 0, i32 2
  %R = icmp ne i32 %V, %W
  ret i1 %R
}

; It also works for floats (fcmp)
define i1 @foldKnownIcmpFloats(float %arg) {
; CHECK-LABEL: @foldKnownIcmpFloats(
; CHECK-NEXT:    ret i1 true
;
  %cmp = fcmp one float %arg, 0.0
  %tmp = select i1 %cmp, float %arg, float 1.0
  %tmp1 = select i1 %cmp, float %arg, float 8.0
  %cmp1 = fcmp ule float %tmp, %tmp1
  ret i1 %cmp1
}

; It also works for vectors
define <2 x i1> @foldKnownIcmpVectors(<2 x float> %arg) {
; CHECK-LABEL: @foldKnownIcmpVectors(
; CHECK-NEXT:    ret <2 x i1> <i1 true, i1 true>
;
  %cmp = fcmp one <2 x float> %arg, < float 0.0, float 0.0 >
  %tmp = select <2 x i1> %cmp, <2 x float> %arg, <2 x float> < float 1.0, float 1.0 >
  %tmp1 = select <2 x i1> %cmp, <2 x float> %arg, <2 x float> < float 8.0, float 8.0 >
  %cmp1 = fcmp ule <2 x float> %tmp, %tmp1
  ret <2 x i1> %cmp1
}
