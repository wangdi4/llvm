; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py

; Check that byval arguments are not re-allocated by VecClone pass, meaning we
; end up having only one alloca with [4 x %struct.pair].

; RUN: opt -vec-clone -S < %s | FileCheck %s
; RUN: opt -passes="vec-clone" -S < %s | FileCheck %s

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.pair = type { i32, i32 }

define i32 @foo(%struct.pair* byval(%struct.pair) %x) #0 {
; CHECK:  define <4 x i32> @_ZGVbN4v_foo([4 x %struct.pair]* byval([4 x %struct.pair]) [[X0:%.*]]) #0 {
; CHECK-NEXT:    [[VEC_X0:%.*]] = alloca [4 x %struct.pair], align 8
; CHECK:         [[VEC_X_CAST0:%.*]] = bitcast [4 x %struct.pair]* [[VEC_X0]] to %struct.pair*
; CHECK-NEXT:    [[VEC_X_BYVAL_LOAD0:%.*]] = load [4 x %struct.pair], [4 x %struct.pair]* [[X0]], align 4
; CHECK-NEXT:    store [4 x %struct.pair] [[VEC_X_BYVAL_LOAD0]], [4 x %struct.pair]* [[VEC_X0]], align 4
; CHECK:         br label [[SIMD_BEGIN_REGION0:%.*]]
;
  %fst.p = getelementptr inbounds %struct.pair, %struct.pair* %x, i32 0, i32 0
  %snd.p = getelementptr inbounds %struct.pair, %struct.pair* %x, i32 0, i32 1
  %fst = load i32, i32* %fst.p, align 4
  %snd = load i32, i32* %snd.p, align 4
  %sum = add i32 %fst, %snd
  ret i32 %sum
}

attributes #0 = { nounwind uwtable "vector-variants"="_ZGVbN4v_" }

