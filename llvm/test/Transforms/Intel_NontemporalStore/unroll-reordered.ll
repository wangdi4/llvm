; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -enable-intel-advanced-opts -intel-libirc-allowed -S -passes 'unaligned-nontemporal,verify' < %s | FileCheck %s
target triple = "x86_64-unknown-linux-gnu"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"

; This test checks that multi-store blocks are handled correctly when the stores
; are not processed in execution or address order.

define void @example(ptr %dest) #0 {
; CHECK-LABEL: @example(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[DEST1:%.*]] = ptrtoint ptr [[DEST:%.*]] to i64
; CHECK-NEXT:    [[ADDR_NT_STORE_ALLOCA:%.*]] = alloca i8, i64 4184, align 64
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [[__NONTEMPORAL_BUFFER_DATA:%.*]], ptr [[ADDR_NT_STORE_ALLOCA]], i32 0, i32 4
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr [[__NONTEMPORAL_BUFFER_DATA]], ptr [[ADDR_NT_STORE_ALLOCA]], i32 0, i32 1
; CHECK-NEXT:    store i64 [[DEST1]], ptr [[TMP1]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = and i64 [[DEST1]], 63
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [[__NONTEMPORAL_BUFFER_DATA]], ptr [[ADDR_NT_STORE_ALLOCA]], i32 0, i32 2
; CHECK-NEXT:    store i64 [[TMP2]], ptr [[TMP3]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr [[__NONTEMPORAL_BUFFER_DATA]], ptr [[ADDR_NT_STORE_ALLOCA]], i32 0, i32 3
; CHECK-NEXT:    store i64 0, ptr [[TMP4]], align 8
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop.split:
; CHECK-NEXT:    [[INDEX_3:%.*]] = add nuw nsw i64 [[INDEX:%.*]], 3
; CHECK-NEXT:    [[SPLAT_3:%.*]] = insertelement <8 x i64> zeroinitializer, i64 [[INDEX_3]], i32 0
; CHECK-NEXT:    [[ADDR_3:%.*]] = getelementptr inbounds <8 x i64>, ptr [[DEST]], i64 [[INDEX_3]]
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [4 x <8 x i64>], ptr [[TMP0]], i64 [[ADDR_NT_BUF_IDX:%.*]], i64 3
; CHECK-NEXT:    store <8 x i64> [[SPLAT_3]], ptr [[TMP5]], align 8
; CHECK-NEXT:    [[SPLAT:%.*]] = insertelement <8 x i64> zeroinitializer, i64 [[INDEX]], i32 0
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds <8 x i64>, ptr [[DEST]], i64 [[INDEX]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr [4 x <8 x i64>], ptr [[TMP0]], i64 [[ADDR_NT_BUF_IDX]], i64 0
; CHECK-NEXT:    store <8 x i64> [[SPLAT]], ptr [[TMP6]], align 8
; CHECK-NEXT:    [[ADDR_NT_BUF_IDX2:%.*]] = add nuw nsw i64 [[ADDR_NT_BUF_IDX]], 1
; CHECK-NEXT:    [[TMP7:%.*]] = icmp eq i64 16, [[ADDR_NT_BUF_IDX2]]
; CHECK-NEXT:    br i1 [[TMP7]], label [[ADDR_NT_BUF_DRAIN:%.*]], label [[LOOP_SPLIT_SPLIT:%.*]]
; CHECK:       addr.nt_buf_drain:
; CHECK-NEXT:    call void @__libirc_nontemporal_store(ptr [[ADDR_NT_STORE_ALLOCA]], i64 4096, i32 0)
; CHECK-NEXT:    br label [[LOOP_SPLIT_SPLIT]]
; CHECK:       loop.split.split:
; CHECK-NEXT:    [[ADDR_NT_BUF_POST_PHI:%.*]] = phi i64 [ [[ADDR_NT_BUF_IDX2]], [[LOOP_SPLIT:%.*]] ], [ 0, [[ADDR_NT_BUF_DRAIN]] ]
; CHECK-NEXT:    [[INDEX_4:%.*]] = add nuw nsw i64 [[INDEX]], 4
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[INDEX_4]], 10000
; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]], !llvm.loop [[LOOP0:![0-9]+]]
; CHECK:       loop:
; CHECK-NEXT:    [[INDEX]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INDEX_4]], [[LOOP_SPLIT_SPLIT]] ]
; CHECK-NEXT:    [[ADDR_NT_BUF_IDX]] = phi i64 [ 0, [[ENTRY]] ], [ [[ADDR_NT_BUF_POST_PHI]], [[LOOP_SPLIT_SPLIT]] ]
; CHECK-NEXT:    [[INDEX_2:%.*]] = add nuw nsw i64 [[INDEX]], 2
; CHECK-NEXT:    [[SPLAT_2:%.*]] = insertelement <8 x i64> zeroinitializer, i64 [[INDEX_2]], i32 0
; CHECK-NEXT:    [[ADDR_2:%.*]] = getelementptr inbounds <8 x i64>, ptr [[DEST]], i64 [[INDEX_2]]
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr [4 x <8 x i64>], ptr [[TMP0]], i64 [[ADDR_NT_BUF_IDX]], i64 2
; CHECK-NEXT:    store <8 x i64> [[SPLAT_2]], ptr [[TMP8]], align 8
; CHECK-NEXT:    [[INDEX_1:%.*]] = add nuw nsw i64 [[INDEX]], 1
; CHECK-NEXT:    [[SPLAT_1:%.*]] = insertelement <8 x i64> zeroinitializer, i64 [[INDEX_1]], i32 0
; CHECK-NEXT:    [[ADDR_1:%.*]] = getelementptr inbounds <8 x i64>, ptr [[DEST]], i64 [[INDEX_1]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr [4 x <8 x i64>], ptr [[TMP0]], i64 [[ADDR_NT_BUF_IDX]], i64 1
; CHECK-NEXT:    store <8 x i64> [[SPLAT_1]], ptr [[TMP9]], align 8
; CHECK-NEXT:    br label [[LOOP_SPLIT]]
; CHECK:       exit:
; CHECK-NEXT:    [[TMP10:%.*]] = mul i64 [[ADDR_NT_BUF_POST_PHI]], 256
; CHECK-NEXT:    call void @__libirc_nontemporal_store(ptr [[ADDR_NT_STORE_ALLOCA]], i64 [[TMP10]], i32 1)
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop.split:                                       ; preds = %loop
  %index.3 = add nuw nsw i64 %index, 3
  %splat.3 = insertelement <8 x i64> zeroinitializer, i64 %index.3, i32 0
  %addr.3 = getelementptr inbounds <8 x i64>, ptr %dest, i64 %index.3
  store <8 x i64> %splat.3, ptr %addr.3, align 16, !nontemporal !0
  %splat = insertelement <8 x i64> zeroinitializer, i64 %index, i32 0
  %addr = getelementptr inbounds <8 x i64>, ptr %dest, i64 %index
  store <8 x i64> %splat, ptr %addr, align 16, !nontemporal !0
  %index.4 = add nuw nsw i64 %index, 4
  %cond = icmp eq i64 %index.4, 10000
  br i1 %cond, label %exit, label %loop, !llvm.loop !1

loop:                                             ; preds = %loop.split, %entry
  %index = phi i64 [ 0, %entry ], [ %index.4, %loop.split ]
  %index.2 = add nuw nsw i64 %index, 2
  %splat.2 = insertelement <8 x i64> zeroinitializer, i64 %index.2, i32 0
  %addr.2 = getelementptr inbounds <8 x i64>, ptr %dest, i64 %index.2
  store <8 x i64> %splat.2, ptr %addr.2, align 16, !nontemporal !0
  %index.1 = add nuw nsw i64 %index, 1
  %splat.1 = insertelement <8 x i64> zeroinitializer, i64 %index.1, i32 0
  %addr.1 = getelementptr inbounds <8 x i64>, ptr %dest, i64 %index.1
  store <8 x i64> %splat.1, ptr %addr.1, align 16, !nontemporal !0
  br label %loop.split

exit:                                             ; preds = %loop.split
  ret void
}

attributes #0 = { "target-features"="+avx512f" }

!0 = !{i32 1}
!1 = distinct !{!1, !2}
!2 = !{!"llvm.loop.unroll.disable"}
