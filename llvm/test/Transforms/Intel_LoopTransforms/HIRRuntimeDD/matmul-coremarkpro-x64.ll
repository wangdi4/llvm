; The test checks if the loop from coremark-pro/loops is multiversioned.
; Additionally it checks the ability of converting UB to a standalone blob.
;
; Original Source:
;
; float matmul(float * px, float * vy, float * cx, int n, int loop) {
;   int i,j,k,l;
;   float ret;
;   for ( l=1 ; l<=loop ; l++ ) {
;     for ( k=0 ; k<25 ; k++ ) {
;       for ( i=0 ; i<25 ; i++ ) {
;         for ( j=0 ; j<n ; j++ ) {
;           px[j*25+i] += vy[k*n+i] * cx[j*25+k+l];
;         }
;       }
;     }
;   }
;   return px[0];
; }
;
; The LLVM IR is generated by running "opt source.c -O2" in 64-bit mode.
;
; This particulat IR has an i32 outermost IV, along with other i64 IVs.
; Because of this the CanonExpr inside <26> has an i32 src type that makes it non-mergeable with i64 UBs.
; i4 UB: [i64 zext.i32.i64(-1 + %4)] should be truncated to i32 to multiversion this loopnest.
;
;           BEGIN REGION { }
; <63>         + DO i32 i1 = 0, %5 + -1, 1   <DO_LOOP>
; <64>         |   + DO i64 i2 = 0, 24, 1   <DO_LOOP>
; <65>         |   |   + DO i64 i3 = 0, 24, 1   <DO_LOOP>
; <66>         |   |   |   + DO i64 i4 = 0, i64 sext.i32.i64((-1 + %4)), 1   <DO_LOOP>
; <20>         |   |   |   |   %10 = (%2)[i64 sext.i32.i64(%4) * i2 + i3];
; <26>         |   |   |   |   %14 = (%3)[sext.i32.i64 i1 + i2 + 25 * i4 + 1];
; <27>         |   |   |   |   %mul24 = %10  *  %14;
; <30>         |   |   |   |   %16 = (%1)[i64 i3 + 25 * i4];
; <31>         |   |   |   |   %add28 = %16  +  %mul24;
; <32>         |   |   |   |   (%1)[i64 i3 + 25 * i4] = %add28;
; <66>         |   |   |   + END LOOP
; <65>         |   |   + END LOOP
; <64>         |   + END LOOP
; <63>         + END LOOP
;           END REGION

; RUN: opt -hir-ssa-deconstruction -hir-runtime-dd -hir-details -print-after=hir-runtime-dd -S < %s 2>&1 | FileCheck %s
; RUN: opt -passes="hir-ssa-deconstruction,hir-runtime-dd,print<hir>" -aa-pipeline="basic-aa" -hir-details -S < %s 2>&1 | FileCheck %s

; CHECK: Function
; CHECK-DAG: &((%2)[24 * sext.i32.i64(%4) + 24]) >=u &((%1)[0]);
; CHECK-DAG: &((%1)[25 * sext.i32.i64((-1 + %4)) + 24]) >=u &((%2)[0]);
; CHECK: %mv.and =
; CHECK-DAG: &((%3)[%5 + 25 * (-1 + %4) + 24]) >=u &((%1)[0]);
; CHECK-DAG: &((%1)[25 * sext.i32.i64((-1 + %4)) + 24]) >=u &((%3)[1]);
; CHECK: %mv.and7 =
; CHECK: if (%mv.and == 0 && %mv.and7 == 0)

target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.loops_params_s = type { i32, i32, i32, i32, i32, i32, i32, [32 x i32], [32 x i32], i32, i32, i32, i32, i32, i8*, i32, i32, float**, i32**, float*, float**, float**, float*, i32*, i8*, %struct.intparts_s*, float, float*, float*, i32, float* }
%struct.intparts_s = type { i8, i16, i32, i32 }

@presets_loops = common global [8 x %struct.loops_params_s] zeroinitializer, align 4
@pgo_training_run = external global i32, align 4

declare float* @reinit_vec_limited(%struct.loops_params_s*, float*, i32) #0

; Function Attrs: nounwind
declare float @get_array_feedback(float*, i32) #1

declare void @zero_vec(float*, i32) #0

; Function Attrs: nounwind
define float @matmul(%struct.loops_params_s* %p) #1 {
entry:
  %m2 = getelementptr inbounds %struct.loops_params_s, %struct.loops_params_s* %p, i64 0, i32 20
  %0 = load float**, float*** %m2, align 4
  %1 = load float*, float** %0, align 4
  %arrayidx2 = getelementptr inbounds float*, float** %0, i64 1
  %2 = load float*, float** %arrayidx2, align 4
  %arrayidx4 = getelementptr inbounds float*, float** %0, i64 2
  %3 = load float*, float** %arrayidx4, align 4
  %N = getelementptr inbounds %struct.loops_params_s, %struct.loops_params_s* %p, i64 0, i32 5
  %4 = load i32, i32* %N, align 4
  %Loop = getelementptr inbounds %struct.loops_params_s, %struct.loops_params_s* %p, i64 0, i32 9
  %5 = load i32, i32* %Loop, align 4
  %mul = mul nsw i32 %4, 25
  tail call void @zero_vec(float* %1, i32 %mul) #2
  %call = tail call float* @reinit_vec_limited(%struct.loops_params_s* %p, float* %2, i32 %mul) #2
  %add = add nsw i32 %mul, %5
  %call7 = tail call float* @reinit_vec_limited(%struct.loops_params_s* %p, float* %3, i32 %add) #2
  %cmp33 = icmp slt i32 %5, 1
  br i1 %cmp33, label %for.end37, label %for.cond8.preheader.lr.ph

for.cond8.preheader.lr.ph:                        ; preds = %entry
  %cmp1528 = icmp sgt i32 %4, 0
  %6 = sext i32 %4 to i64
  br label %for.cond8.preheader

for.cond8.preheader:                              ; preds = %for.inc35, %for.cond8.preheader.lr.ph
  %l.034 = phi i32 [ 1, %for.cond8.preheader.lr.ph ], [ %inc36, %for.inc35 ]
  br label %for.cond11.preheader

for.cond11.preheader:                             ; preds = %for.inc32, %for.cond8.preheader
  %indvars.iv41 = phi i64 [ 0, %for.cond8.preheader ], [ %indvars.iv.next42, %for.inc32 ]
  %7 = mul nsw i64 %indvars.iv41, %6
  %8 = trunc i64 %indvars.iv41 to i32
  %add21 = add nuw i32 %8, %l.034
  br label %for.cond14.preheader

for.cond14.preheader:                             ; preds = %for.inc29, %for.cond11.preheader
  %indvars.iv37 = phi i64 [ 0, %for.cond11.preheader ], [ %indvars.iv.next38, %for.inc29 ]
  br i1 %cmp1528, label %for.body16.lr.ph, label %for.inc29

for.body16.lr.ph:                                 ; preds = %for.cond14.preheader
  %9 = add nsw i64 %indvars.iv37, %7
  %arrayidx19 = getelementptr inbounds float, float* %2, i64 %9
  br label %for.body16

for.body16:                                       ; preds = %for.body16, %for.body16.lr.ph
  %indvars.iv = phi i64 [ 0, %for.body16.lr.ph ], [ %indvars.iv.next, %for.body16 ]
  %10 = load float, float* %arrayidx19, align 4
  %11 = mul nuw nsw i64 %indvars.iv, 25
  %12 = trunc i64 %11 to i32
  %add22 = add i32 %add21, %12
  %13 = sext i32 %add22 to i64
  %arrayidx23 = getelementptr inbounds float, float* %3, i64 %13
  %14 = load float, float* %arrayidx23, align 4
  %mul24 = fmul float %10, %14
  %15 = add nuw nsw i64 %11, %indvars.iv37
  %arrayidx27 = getelementptr inbounds float, float* %1, i64 %15
  %16 = load float, float* %arrayidx27, align 4
  %add28 = fadd float %16, %mul24
  store float %add28, float* %arrayidx27, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %4
  br i1 %exitcond, label %for.inc29.loopexit, label %for.body16

for.inc29.loopexit:                               ; preds = %for.body16
  br label %for.inc29

for.inc29:                                        ; preds = %for.inc29.loopexit, %for.cond14.preheader
  %indvars.iv.next38 = add nuw nsw i64 %indvars.iv37, 1
  %exitcond40 = icmp eq i64 %indvars.iv.next38, 25
  br i1 %exitcond40, label %for.inc32, label %for.cond14.preheader

for.inc32:                                        ; preds = %for.inc29
  %indvars.iv.next42 = add nuw nsw i64 %indvars.iv41, 1
  %exitcond44 = icmp eq i64 %indvars.iv.next42, 25
  br i1 %exitcond44, label %for.inc35, label %for.cond11.preheader

for.inc35:                                        ; preds = %for.inc32
  %inc36 = add nuw nsw i32 %l.034, 1
  %exitcond45 = icmp eq i32 %l.034, %5
  br i1 %exitcond45, label %for.end37.loopexit, label %for.cond8.preheader

for.end37.loopexit:                               ; preds = %for.inc35
  br label %for.end37

for.end37:                                        ; preds = %for.end37.loopexit, %entry
  %call39 = tail call float @get_array_feedback(float* %1, i32 %mul)
  ret float %call39
}

