; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-- -mattr=+avx512f | FileCheck %s
; This is related to intel-avx512-cmp-broadcast.ll, but to test the non-vxi1 type.

@a = external dso_local local_unnamed_addr global i16, align 2
@c = external dso_local local_unnamed_addr global i8, align 1

define dso_local void @main() local_unnamed_addr {
; CHECK-LABEL: main:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw $0, a(%rip)
; CHECK-NEXT:    sete %al
; CHECK-NEXT:    vmovd %eax, %xmm0
; CHECK-NEXT:    vpbroadcastb %xmm0, %xmm0
; CHECK-NEXT:    vpbroadcastb {{.*#+}} xmm1 = [255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255]
; CHECK-NEXT:    vpinsrb $0, c(%rip), %xmm1, %xmm1
; CHECK-NEXT:    vpand %xmm1, %xmm0, %xmm0
; CHECK-NEXT:    vpshufb {{.*#+}} xmm1 = xmm0[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]
; CHECK-NEXT:    vpand %xmm1, %xmm0, %xmm0
; CHECK-NEXT:    vpunpcklbw {{.*#+}} xmm1 = xmm0[0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]
; CHECK-NEXT:    vpshufd {{.*#+}} xmm1 = xmm1[1,1,1,1]
; CHECK-NEXT:    vpand %xmm1, %xmm0, %xmm0
; CHECK-NEXT:    vpsrlw $8, %xmm0, %xmm1
; CHECK-NEXT:    vpand %xmm1, %xmm0, %xmm0
; CHECK-NEXT:    vmovd %xmm0, %ecx
; CHECK-NEXT:    andb %al, %cl
; CHECK-NEXT:    movb %cl, c(%rip)
; CHECK-NEXT:    retq
entry:
  %0 = load i16, i16* @a, align 2
  %tobool.not = icmp eq i16 %0, 0
  %conv = zext i1 %tobool.not to i8
  %.splatinsert.4 = insertelement <8 x i8> poison, i8 %conv, i32 0
  %.splatinsert.3 = insertelement <8 x i8> poison, i8 %conv, i32 0
  %.splatinsert.2 = insertelement <8 x i8> poison, i8 %conv, i32 0
  %.splatinsert.1 = insertelement <8 x i8> poison, i8 %conv, i32 0
  %.splatinsert = insertelement <8 x i8> poison, i8 %conv, i32 0
  %1 = and <8 x i8> %.splatinsert.1, %.splatinsert
  %2 = and <8 x i8> %.splatinsert.2, %1
  %3 = and <8 x i8> %.splatinsert.3, %2
  %4 = and <8 x i8> %.splatinsert.4, %3
  %5 = shufflevector <8 x i8> %4, <8 x i8> poison, <8 x i32> zeroinitializer
  %c.promoted = load i8, i8* @c, align 1
  %red.init.insert6 = insertelement <8 x i8> <i8 poison, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>, i8 %c.promoted, i64 0
  %6 = and <8 x i8> %5, %red.init.insert6
  %rdx.shuf = shufflevector <8 x i8> %6, <8 x i8> poison, <8 x i32> <i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef>
  %bin.rdx = and <8 x i8> %6, %rdx.shuf
  %rdx.shuf18 = shufflevector <8 x i8> %bin.rdx, <8 x i8> poison, <8 x i32> <i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %bin.rdx19 = and <8 x i8> %bin.rdx, %rdx.shuf18
  %rdx.shuf20 = shufflevector <8 x i8> %bin.rdx19, <8 x i8> poison, <8 x i32> <i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %bin.rdx21 = and <8 x i8> %bin.rdx19, %rdx.shuf20
  %7 = extractelement <8 x i8> %bin.rdx21, i32 0
  %8 = and i8 %7, %conv
  store i8 %8, i8* @c, align 1
  ret void
}
