; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx256p
; RUN: llc < %s -mtriple=i686-unknown-unknown -mattr=+avx256p -O3 | FileCheck %s --check-prefix=AVX256P-X86
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx256p -O3 | FileCheck %s --check-prefix=AVX256P-X64

define i32 @test_f32_oeq_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_oeq_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_oeq_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"oeq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ogt_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ogt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ogt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"ogt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_oge_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_oge_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_oge_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"oge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_olt_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_olt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_olt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"olt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ole_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ole_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ole_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"ole",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_one_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_one_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_one_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"one",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ord_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ord_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ord_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"ord",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ueq_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ueq_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ueq_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"ueq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ugt_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ugt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ugt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"ugt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_uge_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_uge_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_uge_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"uge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ult_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ult_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ult_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"ult",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ule_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ule_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ule_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"ule",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_une_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_une_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_une_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %esi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %edi, %eax
; AVX256P-X64-NEXT:    cmovpl %edi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"une",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_uno_q(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_uno_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_uno_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f32(
                                               float %f1, float %f2, metadata !"uno",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_oeq_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_oeq_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_oeq_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"oeq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ogt_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ogt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ogt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"ogt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_oge_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_oge_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_oge_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"oge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_olt_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_olt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_olt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"olt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ole_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ole_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ole_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"ole",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_one_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_one_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_one_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"one",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ord_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ord_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ord_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"ord",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ueq_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ueq_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ueq_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"ueq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ugt_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ugt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ugt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"ugt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_uge_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_uge_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_uge_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"uge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ult_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ult_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ult_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"ult",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ule_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ule_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ule_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"ule",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_une_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_une_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_une_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %esi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %edi, %eax
; AVX256P-X64-NEXT:    cmovpl %edi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"une",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_uno_q(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_uno_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vucomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_uno_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f64(
                                               double %f1, double %f2, metadata !"uno",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_oeq_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_oeq_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_oeq_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"oeq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ogt_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ogt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ogt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"ogt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_oge_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_oge_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_oge_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"oge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_olt_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_olt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_olt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"olt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ole_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ole_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ole_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"ole",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_one_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_one_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_one_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"one",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ord_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ord_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ord_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"ord",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ueq_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ueq_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ueq_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"ueq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ugt_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ugt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ugt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"ugt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_uge_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_uge_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_uge_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"uge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ult_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ult_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ult_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"ult",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_ule_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_ule_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_ule_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"ule",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_une_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_une_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_une_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %esi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %edi, %eax
; AVX256P-X64-NEXT:    cmovpl %edi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"une",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f32_uno_s(i32 %a, i32 %b, float %f1, float %f2) #0 {
; AVX256P-X86-LABEL: test_f32_uno_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vcomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f32_uno_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f32(
                                               float %f1, float %f2, metadata !"uno",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_oeq_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_oeq_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_oeq_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"oeq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ogt_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ogt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ogt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"ogt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_oge_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_oge_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_oge_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"oge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_olt_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_olt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_olt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"olt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ole_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ole_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ole_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"ole",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_one_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_one_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_one_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"one",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ord_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ord_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ord_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"ord",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ueq_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ueq_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ueq_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"ueq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ugt_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ugt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ugt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"ugt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_uge_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_uge_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_uge_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"uge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ult_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ult_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ult_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"ult",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_ule_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_ule_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_ule_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"ule",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_une_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_une_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_une_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %esi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %edi, %eax
; AVX256P-X64-NEXT:    cmovpl %edi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"une",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f64_uno_s(i32 %a, i32 %b, double %f1, double %f2) #0 {
; AVX256P-X86-LABEL: test_f64_uno_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; AVX256P-X86-NEXT:    vcomisd {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f64_uno_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomisd %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f64(
                                               double %f1, double %f2, metadata !"uno",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define void @foo(float %0, float %1) #0 {
; AVX256P-X86-LABEL: foo:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; AVX256P-X86-NEXT:    vucomiss {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    ja bar # TAILCALL
; AVX256P-X86-NEXT:  # %bb.1:
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: foo:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    vucomiss %xmm1, %xmm0
; AVX256P-X64-NEXT:    ja bar # TAILCALL
; AVX256P-X64-NEXT:  # %bb.1:
; AVX256P-X64-NEXT:    retq
  %3 = call i1 @llvm.experimental.constrained.fcmp.f32( float %0, float %1, metadata !"ogt", metadata !"fpexcept.strict") #0
  br i1 %3, label %4, label %5

4:                                                ; preds = %2
  tail call void @bar() #0
  br label %5

5:                                                ; preds = %4, %2
  ret void
}
declare dso_local void @bar()

attributes #0 = { strictfp }

declare i1 @llvm.experimental.constrained.fcmp.f32(float, float, metadata, metadata)
declare i1 @llvm.experimental.constrained.fcmp.f64(double, double, metadata, metadata)
declare i1 @llvm.experimental.constrained.fcmps.f32(float, float, metadata, metadata)
declare i1 @llvm.experimental.constrained.fcmps.f64(double, double, metadata, metadata)
