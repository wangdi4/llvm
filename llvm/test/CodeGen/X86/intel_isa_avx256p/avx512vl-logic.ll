; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx256p
; RUN: llc < %s -mtriple=x86_64-apple-darwin -mattr=+avx256p -show-mc-encoding | FileCheck %s --check-prefix=CHECK --check-prefix=KNL

; 256-bit

define <8 x i32> @vpandd256(<8 x i32> %a, <8 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandd256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to8}, %ymm0, %ymm0 ## encoding: [0x62,0xf1,0x7d,0x38,0xfe,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpand %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xdb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <8 x i32> %a, <i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2, i32 2>
  %x = and <8 x i32> %a2, %b
  ret <8 x i32> %x
}

define <8 x i32> @vpandnd256(<8 x i32> %a, <8 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandnd256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to8}, %ymm0, %ymm1 ## encoding: [0x62,0xf1,0x7d,0x38,0xfe,0x0d,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpandn %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xdf,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <8 x i32> %a, <i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3, i32 3>
  %b2 = xor <8 x i32> %a, <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>
  %x = and <8 x i32> %a2, %b2
  ret <8 x i32> %x
}

define <8 x i32> @vpord256(<8 x i32> %a, <8 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpord256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to8}, %ymm0, %ymm0 ## encoding: [0x62,0xf1,0x7d,0x38,0xfe,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpor %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xeb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <8 x i32> %a, <i32 4, i32 4, i32 4, i32 4, i32 4, i32 4, i32 4, i32 4>
  %x = or <8 x i32> %a2, %b
  ret <8 x i32> %x
}

define <8 x i32> @vpxord256(<8 x i32> %a, <8 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpxord256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to8}, %ymm0, %ymm0 ## encoding: [0x62,0xf1,0x7d,0x38,0xfe,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpxor %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xef,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <8 x i32> %a, <i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5, i32 5>
  %x = xor <8 x i32> %a2, %b
  ret <8 x i32> %x
}

define <4 x i64> @vpandq256(<4 x i64> %a, <4 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandq256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %ymm0, %ymm0 ## encoding: [0x62,0xf1,0xfd,0x38,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpand %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xdb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i64> %a, <i64 6, i64 6, i64 6, i64 6>
  %x = and <4 x i64> %a2, %b
  ret <4 x i64> %x
}

define <4 x i64> @vpandnq256(<4 x i64> %a, <4 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandnq256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %ymm0, %ymm0 ## encoding: [0x62,0xf1,0xfd,0x38,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpandn %ymm0, %ymm1, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf5,0xdf,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i64> %a, <i64 7, i64 7, i64 7, i64 7>
  %b2 = xor <4 x i64> %b, <i64 -1, i64 -1, i64 -1, i64 -1>
  %x = and <4 x i64> %a2, %b2
  ret <4 x i64> %x
}

define <4 x i64> @vporq256(<4 x i64> %a, <4 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vporq256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %ymm0, %ymm0 ## encoding: [0x62,0xf1,0xfd,0x38,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpor %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xeb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i64> %a, <i64 21, i64 21, i64 21, i64 21>
  %x = or <4 x i64> %a2, %b
  ret <4 x i64> %x
}

define <4 x i64> @vpxorq256(<4 x i64> %a, <4 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpxorq256:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %ymm0, %ymm0 ## encoding: [0x62,0xf1,0xfd,0x38,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpxor %ymm1, %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xef,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i64> %a, <i64 22, i64 22, i64 22, i64 22>
  %x = xor <4 x i64> %a2, %b
  ret <4 x i64> %x
}

; 128-bit

define <4 x i32> @vpandd128(<4 x i32> %a, <4 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandd128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0x7d,0x18,0xfe,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpand %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xdb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i32> %a, <i32 8, i32 8, i32 8, i32 8>
  %x = and <4 x i32> %a2, %b
  ret <4 x i32> %x
}

define <4 x i32> @vpandnd128(<4 x i32> %a, <4 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandnd128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0x7d,0x18,0xfe,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpandn %xmm0, %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf1,0xdf,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i32> %a, <i32 9, i32 9, i32 9, i32 9>
  %b2 = xor <4 x i32> %b, <i32 -1, i32 -1, i32 -1, i32 -1>
  %x = and <4 x i32> %a2, %b2
  ret <4 x i32> %x
}

define <4 x i32> @vpord128(<4 x i32> %a, <4 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpord128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0x7d,0x18,0xfe,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpor %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xeb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i32> %a, <i32 10, i32 10, i32 10, i32 10>
  %x = or <4 x i32> %a2, %b
  ret <4 x i32> %x
}

define <4 x i32> @vpxord128(<4 x i32> %a, <4 x i32> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpxord128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddd {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to4}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0x7d,0x18,0xfe,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpxor %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xef,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <4 x i32> %a, <i32 11, i32 11, i32 11, i32 11>
  %x = xor <4 x i32> %a2, %b
  ret <4 x i32> %x
}

define <2 x i64> @vpandq128(<2 x i64> %a, <2 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandq128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to2}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0xfd,0x18,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpand %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xdb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <2 x i64> %a, <i64 12, i64 12>
  %x = and <2 x i64> %a2, %b
  ret <2 x i64> %x
}

define <2 x i64> @vpandnq128(<2 x i64> %a, <2 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpandnq128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to2}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0xfd,0x18,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpandn %xmm0, %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf1,0xdf,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <2 x i64> %a, <i64 13, i64 13>
  %b2 = xor <2 x i64> %b, <i64 -1, i64 -1>
  %x = and <2 x i64> %a2, %b2
  ret <2 x i64> %x
}

define <2 x i64> @vporq128(<2 x i64> %a, <2 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vporq128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to2}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0xfd,0x18,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpor %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xeb,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <2 x i64> %a, <i64 14, i64 14>
  %x = or <2 x i64> %a2, %b
  ret <2 x i64> %x
}

define <2 x i64> @vpxorq128(<2 x i64> %a, <2 x i64> %b) nounwind uwtable readnone ssp {
; CHECK-LABEL: vpxorq128:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip){1to2}, %xmm0, %xmm0 ## encoding: [0x62,0xf1,0xfd,0x18,0xd4,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpxor %xmm1, %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xef,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
entry:
  ; Force the execution domain with an add.
  %a2 = add <2 x i64> %a, <i64 15, i64 15>
  %x = xor <2 x i64> %a2, %b
  ret <2 x i64> %x
}


define <4 x double> @test_mm256_mask_andnot_pd(<4 x double> %__W, i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_mask_andnot_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnpd %ymm2, %ymm1, %ymm0 {%k1} ## encoding: [0x62,0xf1,0xf5,0x29,0x55,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_andnot_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnpd %ymm2, %ymm1, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %neg.i.i = xor <4 x i64> %0, <i64 -1, i64 -1, i64 -1, i64 -1>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %and.i.i = and <4 x i64> %1, %neg.i.i
  %2 = bitcast <4 x i64> %and.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> %__W
  ret <4 x double> %4
}

define <4 x double> @test_mm256_maskz_andnot_pd(i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_maskz_andnot_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnpd %ymm1, %ymm0, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0xfd,0xa9,0x55,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_andnot_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnpd %ymm1, %ymm0, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %neg.i.i = xor <4 x i64> %0, <i64 -1, i64 -1, i64 -1, i64 -1>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %and.i.i = and <4 x i64> %1, %neg.i.i
  %2 = bitcast <4 x i64> %and.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> zeroinitializer
  ret <4 x double> %4
}

define <2 x double> @test_mm_mask_andnot_pd(<2 x double> %__W, i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_mask_andnot_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnpd %xmm2, %xmm1, %xmm0 {%k1} ## encoding: [0x62,0xf1,0xf5,0x09,0x55,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_andnot_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnpd %xmm2, %xmm1, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %neg.i.i = xor <2 x i64> %0, <i64 -1, i64 -1>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %and.i.i = and <2 x i64> %1, %neg.i.i
  %2 = bitcast <2 x i64> %and.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> %__W
  ret <2 x double> %4
}

define <2 x double> @test_mm_maskz_andnot_pd(i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_maskz_andnot_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnpd %xmm1, %xmm0, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0xfd,0x89,0x55,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_andnot_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnpd %xmm1, %xmm0, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %neg.i.i = xor <2 x i64> %0, <i64 -1, i64 -1>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %and.i.i = and <2 x i64> %1, %neg.i.i
  %2 = bitcast <2 x i64> %and.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> zeroinitializer
  ret <2 x double> %4
}

define <8 x float> @test_mm256_mask_andnot_ps(<8 x float> %__W, i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_mask_andnot_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnps %ymm2, %ymm1, %ymm0 {%k1} ## encoding: [0x62,0xf1,0x74,0x29,0x55,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_andnot_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnps %ymm2, %ymm1, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %neg.i.i = xor <8 x i32> %0, <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %and.i.i = and <8 x i32> %1, %neg.i.i
  %2 = bitcast <8 x i32> %and.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> %__W
  ret <8 x float> %4
}

define <8 x float> @test_mm256_maskz_andnot_ps(i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_maskz_andnot_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnps %ymm1, %ymm0, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0x7c,0xa9,0x55,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_andnot_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnps %ymm1, %ymm0, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %neg.i.i = xor <8 x i32> %0, <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %and.i.i = and <8 x i32> %1, %neg.i.i
  %2 = bitcast <8 x i32> %and.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> zeroinitializer
  ret <8 x float> %4
}

define <4 x float> @test_mm_mask_andnot_ps(<4 x float> %__W, i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_mask_andnot_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnps %xmm2, %xmm1, %xmm0 {%k1} ## encoding: [0x62,0xf1,0x74,0x09,0x55,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_andnot_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnps %xmm2, %xmm1, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %neg.i.i = xor <4 x i32> %0, <i32 -1, i32 -1, i32 -1, i32 -1>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %and.i.i = and <4 x i32> %1, %neg.i.i
  %2 = bitcast <4 x i32> %and.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> %__W
  ret <4 x float> %4
}

define <4 x float> @test_mm_maskz_andnot_ps(i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_maskz_andnot_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandnps %xmm1, %xmm0, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0x7c,0x89,0x55,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_andnot_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandnps %xmm1, %xmm0, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %neg.i.i = xor <4 x i32> %0, <i32 -1, i32 -1, i32 -1, i32 -1>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %and.i.i = and <4 x i32> %1, %neg.i.i
  %2 = bitcast <4 x i32> %and.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> zeroinitializer
  ret <4 x float> %4
}

define <4 x double> @test_mm256_mask_and_pd(<4 x double> %__W, i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_mask_and_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandpd %ymm1, %ymm2, %ymm0 {%k1} ## encoding: [0x62,0xf1,0xed,0x29,0x54,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_and_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandpd %ymm1, %ymm2, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %and.i.i = and <4 x i64> %1, %0
  %2 = bitcast <4 x i64> %and.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> %__W
  ret <4 x double> %4
}

define <4 x double> @test_mm256_maskz_and_pd(i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_maskz_and_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandpd %ymm0, %ymm1, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0xf5,0xa9,0x54,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_and_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandpd %ymm0, %ymm1, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %and.i.i = and <4 x i64> %1, %0
  %2 = bitcast <4 x i64> %and.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> zeroinitializer
  ret <4 x double> %4
}

define <2 x double> @test_mm_mask_and_pd(<2 x double> %__W, i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_mask_and_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandpd %xmm1, %xmm2, %xmm0 {%k1} ## encoding: [0x62,0xf1,0xed,0x09,0x54,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_and_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandpd %xmm1, %xmm2, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %and.i.i = and <2 x i64> %1, %0
  %2 = bitcast <2 x i64> %and.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> %__W
  ret <2 x double> %4
}

define <2 x double> @test_mm_maskz_and_pd(i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_maskz_and_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandpd %xmm0, %xmm1, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0xf5,0x89,0x54,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_and_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandpd %xmm0, %xmm1, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %and.i.i = and <2 x i64> %1, %0
  %2 = bitcast <2 x i64> %and.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> zeroinitializer
  ret <2 x double> %4
}

define <8 x float> @test_mm256_mask_and_ps(<8 x float> %__W, i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_mask_and_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandps %ymm1, %ymm2, %ymm0 {%k1} ## encoding: [0x62,0xf1,0x6c,0x29,0x54,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_and_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandps %ymm1, %ymm2, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %and.i.i = and <8 x i32> %1, %0
  %2 = bitcast <8 x i32> %and.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> %__W
  ret <8 x float> %4
}

define <8 x float> @test_mm256_maskz_and_ps(i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_maskz_and_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandps %ymm0, %ymm1, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0x74,0xa9,0x54,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_and_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandps %ymm0, %ymm1, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %and.i.i = and <8 x i32> %1, %0
  %2 = bitcast <8 x i32> %and.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> zeroinitializer
  ret <8 x float> %4
}

define <4 x float> @test_mm_mask_and_ps(<4 x float> %__W, i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_mask_and_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandps %xmm1, %xmm2, %xmm0 {%k1} ## encoding: [0x62,0xf1,0x6c,0x09,0x54,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_and_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandps %xmm1, %xmm2, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %and.i.i = and <4 x i32> %1, %0
  %2 = bitcast <4 x i32> %and.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> %__W
  ret <4 x float> %4
}

define <4 x float> @test_mm_maskz_and_ps(i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_maskz_and_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vandps %xmm0, %xmm1, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0x74,0x89,0x54,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_and_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vandps %xmm0, %xmm1, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %and.i.i = and <4 x i32> %1, %0
  %2 = bitcast <4 x i32> %and.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> zeroinitializer
  ret <4 x float> %4
}

define <4 x double> @test_mm256_mask_xor_pd(<4 x double> %__W, i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_mask_xor_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorpd %ymm2, %ymm1, %ymm0 {%k1} ## encoding: [0x62,0xf1,0xf5,0x29,0x57,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_xor_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorpd %ymm2, %ymm1, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %xor.i.i = xor <4 x i64> %0, %1
  %2 = bitcast <4 x i64> %xor.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> %__W
  ret <4 x double> %4
}

define <4 x double> @test_mm256_maskz_xor_pd(i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_maskz_xor_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorpd %ymm1, %ymm0, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0xfd,0xa9,0x57,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_xor_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorpd %ymm1, %ymm0, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %xor.i.i = xor <4 x i64> %0, %1
  %2 = bitcast <4 x i64> %xor.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> zeroinitializer
  ret <4 x double> %4
}

define <2 x double> @test_mm_mask_xor_pd(<2 x double> %__W, i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_mask_xor_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorpd %xmm2, %xmm1, %xmm0 {%k1} ## encoding: [0x62,0xf1,0xf5,0x09,0x57,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_xor_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorpd %xmm2, %xmm1, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %xor.i.i = xor <2 x i64> %0, %1
  %2 = bitcast <2 x i64> %xor.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> %__W
  ret <2 x double> %4
}

define <2 x double> @test_mm_maskz_xor_pd(i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_maskz_xor_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorpd %xmm1, %xmm0, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0xfd,0x89,0x57,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_xor_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorpd %xmm1, %xmm0, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %xor.i.i = xor <2 x i64> %0, %1
  %2 = bitcast <2 x i64> %xor.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> zeroinitializer
  ret <2 x double> %4
}

define <8 x float> @test_mm256_mask_xor_ps(<8 x float> %__W, i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_mask_xor_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorps %ymm2, %ymm1, %ymm0 {%k1} ## encoding: [0x62,0xf1,0x74,0x29,0x57,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_xor_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorps %ymm2, %ymm1, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %xor.i.i = xor <8 x i32> %0, %1
  %2 = bitcast <8 x i32> %xor.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> %__W
  ret <8 x float> %4
}

define <8 x float> @test_mm256_maskz_xor_ps(i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_maskz_xor_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorps %ymm1, %ymm0, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0x7c,0xa9,0x57,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_xor_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorps %ymm1, %ymm0, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %xor.i.i = xor <8 x i32> %0, %1
  %2 = bitcast <8 x i32> %xor.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> zeroinitializer
  ret <8 x float> %4
}

define <4 x float> @test_mm_mask_xor_ps(<4 x float> %__W, i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_mask_xor_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorps %xmm2, %xmm1, %xmm0 {%k1} ## encoding: [0x62,0xf1,0x74,0x09,0x57,0xc2]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_xor_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorps %xmm2, %xmm1, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %xor.i.i = xor <4 x i32> %0, %1
  %2 = bitcast <4 x i32> %xor.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> %__W
  ret <4 x float> %4
}

define <4 x float> @test_mm_maskz_xor_ps(i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_maskz_xor_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vxorps %xmm1, %xmm0, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0x7c,0x89,0x57,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_xor_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vxorps %xmm1, %xmm0, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %xor.i.i = xor <4 x i32> %0, %1
  %2 = bitcast <4 x i32> %xor.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> zeroinitializer
  ret <4 x float> %4
}

define <4 x double> @test_mm256_mask_or_pd(<4 x double> %__W, i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_mask_or_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorpd %ymm1, %ymm2, %ymm0 {%k1} ## encoding: [0x62,0xf1,0xed,0x29,0x56,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_or_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorpd %ymm1, %ymm2, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %or.i.i = or <4 x i64> %1, %0
  %2 = bitcast <4 x i64> %or.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> %__W
  ret <4 x double> %4
}

define <4 x double> @test_mm256_maskz_or_pd(i8 zeroext %__U, <4 x double> %__A, <4 x double> %__B) {
; CHECK-LABEL: test_mm256_maskz_or_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorpd %ymm0, %ymm1, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0xf5,0xa9,0x56,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_or_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorpd %ymm0, %ymm1, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x double> %__A to <4 x i64>
  %1 = bitcast <4 x double> %__B to <4 x i64>
  %or.i.i = or <4 x i64> %1, %0
  %2 = bitcast <4 x i64> %or.i.i to <4 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x double> %2, <4 x double> zeroinitializer
  ret <4 x double> %4
}

define <2 x double> @test_mm_mask_or_pd(<2 x double> %__W, i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_mask_or_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorpd %xmm1, %xmm2, %xmm0 {%k1} ## encoding: [0x62,0xf1,0xed,0x09,0x56,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_or_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorpd %xmm1, %xmm2, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %or.i.i = or <2 x i64> %1, %0
  %2 = bitcast <2 x i64> %or.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> %__W
  ret <2 x double> %4
}

define <2 x double> @test_mm_maskz_or_pd(i8 zeroext %__U, <2 x double> %__A, <2 x double> %__B) {
; CHECK-LABEL: test_mm_maskz_or_pd:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorpd %xmm0, %xmm1, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0xf5,0x89,0x56,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_or_pd:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorpd %xmm0, %xmm1, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <2 x double> %__A to <2 x i64>
  %1 = bitcast <2 x double> %__B to <2 x i64>
  %or.i.i = or <2 x i64> %1, %0
  %2 = bitcast <2 x i64> %or.i.i to <2 x double>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <2 x i32> <i32 0, i32 1>
  %4 = select <2 x i1> %extract.i, <2 x double> %2, <2 x double> zeroinitializer
  ret <2 x double> %4
}

define <8 x float> @test_mm256_mask_or_ps(<8 x float> %__W, i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_mask_or_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorps %ymm1, %ymm2, %ymm0 {%k1} ## encoding: [0x62,0xf1,0x6c,0x29,0x56,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_mask_or_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorps %ymm1, %ymm2, %ymm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %or.i.i = or <8 x i32> %1, %0
  %2 = bitcast <8 x i32> %or.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> %__W
  ret <8 x float> %4
}

define <8 x float> @test_mm256_maskz_or_ps(i8 zeroext %__U, <8 x float> %__A, <8 x float> %__B) {
; CHECK-LABEL: test_mm256_maskz_or_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorps %ymm0, %ymm1, %ymm0 {%k1} {z} ## encoding: [0x62,0xf1,0x74,0xa9,0x56,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm256_maskz_or_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorps %ymm0, %ymm1, %ymm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <8 x float> %__A to <8 x i32>
  %1 = bitcast <8 x float> %__B to <8 x i32>
  %or.i.i = or <8 x i32> %1, %0
  %2 = bitcast <8 x i32> %or.i.i to <8 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %4 = select <8 x i1> %3, <8 x float> %2, <8 x float> zeroinitializer
  ret <8 x float> %4
}

define <4 x float> @test_mm_mask_or_ps(<4 x float> %__W, i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_mask_or_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorps %xmm1, %xmm2, %xmm0 {%k1} ## encoding: [0x62,0xf1,0x6c,0x09,0x56,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_mask_or_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorps %xmm1, %xmm2, %xmm0 {%k1}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %or.i.i = or <4 x i32> %1, %0
  %2 = bitcast <4 x i32> %or.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> %__W
  ret <4 x float> %4
}

define <4 x float> @test_mm_maskz_or_ps(i8 zeroext %__U, <4 x float> %__A, <4 x float> %__B) {
; CHECK-LABEL: test_mm_maskz_or_ps:
; CHECK:       ## %bb.0: ## %entry
; CHECK-NEXT:    kmovd %edi, %k1 ## encoding: [0xc5,0xfb,0x92,0xcf]
; CHECK-NEXT:    vorps %xmm0, %xmm1, %xmm0 {%k1} {z} ## encoding: [0x62,0xf1,0x74,0x89,0x56,0xc0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: test_mm_maskz_or_ps:
; SKX:       ## %bb.0: ## %entry
; SKX-NEXT:    kmovd %edi, %k1
; SKX-NEXT:    vorps %xmm0, %xmm1, %xmm0 {%k1} {z}
; SKX-NEXT:    retq
entry:
  %0 = bitcast <4 x float> %__A to <4 x i32>
  %1 = bitcast <4 x float> %__B to <4 x i32>
  %or.i.i = or <4 x i32> %1, %0
  %2 = bitcast <4 x i32> %or.i.i to <4 x float>
  %3 = bitcast i8 %__U to <8 x i1>
  %extract.i = shufflevector <8 x i1> %3, <8 x i1> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = select <4 x i1> %extract.i, <4 x float> %2, <4 x float> zeroinitializer
  ret <4 x float> %4
}

define <4 x i32> @ternlog_and_andn(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_and_andn:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $8, %xmm1, %xmm2, %xmm0 ## encoding: [0x62,0xf3,0x6d,0x08,0x25,0xc1,0x08]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = and <4 x i32> %y, %a
  %c = and <4 x i32> %b, %z
  ret <4 x i32> %c
}

define <4 x i32> @ternlog_or_andn(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_or_andn:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $206, %xmm1, %xmm2, %xmm0 ## encoding: [0x62,0xf3,0x6d,0x08,0x25,0xc1,0xce]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = and <4 x i32> %y, %a
  %c = or <4 x i32> %b, %z
  ret <4 x i32> %c
}

define <4 x i32> @ternlog_and_orn(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_and_orn:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $176, %xmm1, %xmm2, %xmm0 ## encoding: [0x62,0xf3,0x6d,0x08,0x25,0xc1,0xb0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %z, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = or <4 x i32> %a, %y
  %c = and <4 x i32> %b, %x
  ret <4 x i32> %c
}

define <4 x i32> @ternlog_and_orn_2(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_and_orn_2:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $208, %xmm2, %xmm1, %xmm0 ## encoding: [0x62,0xf3,0x75,0x08,0x25,0xc2,0xd0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %z, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = or <4 x i32> %y, %a
  %c = and <4 x i32> %b, %x
  ret <4 x i32> %c
}

; FIXME: This should be a single vpternlog, but we accidentally match the xor -1
; as the second binary op instead of the and.
define <4 x i32> @ternlog_orn_and(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_orn_and:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpcmpeqd %xmm3, %xmm3, %xmm3 ## encoding: [0xc5,0xe1,0x76,0xdb]
; CHECK-NEXT:    vpand %xmm2, %xmm1, %xmm1 ## EVEX TO VEX Compression encoding: [0xc5,0xf1,0xdb,0xca]
; CHECK-NEXT:    vpternlogd $222, %xmm3, %xmm1, %xmm0 ## encoding: [0x62,0xf3,0x75,0x08,0x25,0xc3,0xde]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = and <4 x i32> %y, %z
  %c = or <4 x i32> %b, %a
  ret <4 x i32> %c
}

define <4 x i32> @ternlog_orn_and_2(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_orn_and_2:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $143, %xmm2, %xmm1, %xmm0 ## encoding: [0x62,0xf3,0x75,0x08,0x25,0xc2,0x8f]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = and <4 x i32> %y, %z
  %c = or <4 x i32> %a, %b
  ret <4 x i32> %c
}

define <4 x i32> @ternlog_xor_andn(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_xor_andn:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $198, %xmm1, %xmm2, %xmm0 ## encoding: [0x62,0xf3,0x6d,0x08,0x25,0xc1,0xc6]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = and <4 x i32> %y, %a
  %c = xor <4 x i32> %b, %z
  ret <4 x i32> %c
}

define <4 x i32> @ternlog_or_and_mask(<4 x i32> %x, <4 x i32> %y) {
; CHECK-LABEL: ternlog_or_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $236, {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1, %xmm0 ## encoding: [0x62,0xf3,0x75,0x08,0x25,0x05,A,A,A,A,0xec]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-5, kind: reloc_riprel_4byte
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = and <4 x i32> %x, <i32 255, i32 255, i32 255, i32 255>
  %b = or <4 x i32> %a, %y
  ret <4 x i32> %b
}

define <8 x i32> @ternlog_or_and_mask_ymm(<8 x i32> %x, <8 x i32> %y) {
; CHECK-LABEL: ternlog_or_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $236, {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm1, %ymm0 ## encoding: [0x62,0xf3,0x75,0x28,0x25,0x05,A,A,A,A,0xec]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-5, kind: reloc_riprel_4byte
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = and <8 x i32> %x, <i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216>
  %b = or <8 x i32> %a, %y
  ret <8 x i32> %b
}

define <2 x i64> @ternlog_xor_and_mask(<2 x i64> %x, <2 x i64> %y) {
; CHECK-LABEL: ternlog_xor_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogq $108, {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1, %xmm0 ## encoding: [0x62,0xf3,0xf5,0x08,0x25,0x05,A,A,A,A,0x6c]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-5, kind: reloc_riprel_4byte
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = and <2 x i64> %x, <i64 1099511627775, i64 1099511627775>
  %b = xor <2 x i64> %a, %y
  ret <2 x i64> %b
}

define <4 x i64> @ternlog_xor_and_mask_ymm(<4 x i64> %x, <4 x i64> %y) {
; CHECK-LABEL: ternlog_xor_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogq $108, {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm1, %ymm0 ## encoding: [0x62,0xf3,0xf5,0x28,0x25,0x05,A,A,A,A,0x6c]
; CHECK-NEXT:    ## fixup A - offset: 6, value: {{\.?LCPI[0-9]+_[0-9]+}}-5, kind: reloc_riprel_4byte
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = and <4 x i64> %x, <i64 72057594037927935, i64 72057594037927935, i64 72057594037927935, i64 72057594037927935>
  %b = xor <4 x i64> %a, %y
  ret <4 x i64> %b
}

define <4 x i32> @ternlog_maskz_or_and_mask(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %mask) {
; CHECK-LABEL: ternlog_maskz_or_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm2 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xdb,0x15,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpsrad $31, %xmm3, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x72,0xe3,0x1f]
; CHECK-NEXT:    vpternlogd $224, %xmm1, %xmm2, %xmm0 ## encoding: [0x62,0xf3,0x6d,0x08,0x25,0xc1,0xe0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %m = icmp slt <4 x i32> %mask, zeroinitializer
  %a = and <4 x i32> %x, <i32 255, i32 255, i32 255, i32 255>
  %b = or <4 x i32> %a, %y
  %c = select <4 x i1> %m, <4 x i32> %b, <4 x i32> zeroinitializer
  ret <4 x i32> %c
}

define <8 x i32> @ternlog_maskz_or_and_mask_ymm(<8 x i32> %x, <8 x i32> %y, <8 x i32> %mask) {
; CHECK-LABEL: ternlog_maskz_or_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm3 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xdb,0x1d,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpsrad $31, %ymm2, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x72,0xe2,0x1f]
; CHECK-NEXT:    vpternlogd $224, %ymm1, %ymm3, %ymm0 ## encoding: [0x62,0xf3,0x65,0x28,0x25,0xc1,0xe0]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %m = icmp slt <8 x i32> %mask, zeroinitializer
  %a = and <8 x i32> %x, <i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216>
  %b = or <8 x i32> %a, %y
  %c = select <8 x i1> %m, <8 x i32> %b, <8 x i32> zeroinitializer
  ret <8 x i32> %c
}

define <2 x i64> @ternlog_maskz_xor_and_mask(<2 x i64> %x, <2 x i64> %y, <2 x i64> %mask) {
; CHECK-LABEL: ternlog_maskz_xor_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm3 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0xdb,0x1d,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpsraq $63, %xmm2, %xmm0 ## encoding: [0x62,0xf1,0xfd,0x08,0x72,0xe2,0x3f]
; CHECK-NEXT:    vpternlogq $96, %xmm1, %xmm3, %xmm0 ## encoding: [0x62,0xf3,0xe5,0x08,0x25,0xc1,0x60]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %m = icmp slt <2 x i64> %mask, zeroinitializer
  %a = and <2 x i64> %x, <i64 1099511627775, i64 1099511627775>
  %b = xor <2 x i64> %a, %y
  %c = select <2 x i1> %m, <2 x i64> %b, <2 x i64> zeroinitializer
  ret <2 x i64> %c
}

define <4 x i64> @ternlog_maskz_xor_and_mask_ymm(<4 x i64> %x, <4 x i64> %y, <4 x i64> %mask) {
; CHECK-LABEL: ternlog_maskz_xor_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpand {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm3 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0xdb,0x1d,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vpsraq $63, %ymm2, %ymm0 ## encoding: [0x62,0xf1,0xfd,0x28,0x72,0xe2,0x3f]
; CHECK-NEXT:    vpternlogq $96, %ymm1, %ymm3, %ymm0 ## encoding: [0x62,0xf3,0xe5,0x28,0x25,0xc1,0x60]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %m = icmp slt <4 x i64> %mask, zeroinitializer
  %a = and <4 x i64> %x, <i64 72057594037927935, i64 72057594037927935, i64 72057594037927935, i64 72057594037927935>
  %b = xor <4 x i64> %a, %y
  %c = select <4 x i1> %m, <4 x i64> %b, <4 x i64> zeroinitializer
  ret <4 x i64> %c
}

define <4 x i32> @ternlog_maskx_or_and_mask(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %mask) {
; CHECK-LABEL: ternlog_maskx_or_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovd2m %xmm3, %k1 ## encoding: [0x62,0xf2,0x7e,0x08,0x39,0xcb]
; CHECK-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm2 ## EVEX TO VEX Compression encoding: [0xc5,0xf8,0x54,0x15,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vorps %xmm1, %xmm2, %xmm0 {%k1} ## encoding: [0x62,0xf1,0x6c,0x09,0x56,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_maskx_or_and_mask:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovd2m %xmm3, %k1
; SKX-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm2
; SKX-NEXT:    vorps %xmm1, %xmm2, %xmm0 {%k1}
; SKX-NEXT:    retq
  %m = icmp slt <4 x i32> %mask, zeroinitializer
  %a = and <4 x i32> %x, <i32 255, i32 255, i32 255, i32 255>
  %b = or <4 x i32> %a, %y
  %c = select <4 x i1> %m, <4 x i32> %b, <4 x i32> %x
  ret <4 x i32> %c
}

define <8 x i32> @ternlog_maskx_or_and_mask_ymm(<8 x i32> %x, <8 x i32> %y, <8 x i32> %mask) {
; CHECK-LABEL: ternlog_maskx_or_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovd2m %ymm2, %k1 ## encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; CHECK-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm2 ## EVEX TO VEX Compression encoding: [0xc5,0xfc,0x54,0x15,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vorps %ymm1, %ymm2, %ymm0 {%k1} ## encoding: [0x62,0xf1,0x6c,0x29,0x56,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_maskx_or_and_mask_ymm:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovd2m %ymm2, %k1
; SKX-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm2
; SKX-NEXT:    vorps %ymm1, %ymm2, %ymm0 {%k1}
; SKX-NEXT:    retq
  %m = icmp slt <8 x i32> %mask, zeroinitializer
  %a = and <8 x i32> %x, <i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216>
  %b = or <8 x i32> %a, %y
  %c = select <8 x i1> %m, <8 x i32> %b, <8 x i32> %x
  ret <8 x i32> %c
}

define <2 x i64> @ternlog_maskx_xor_and_mask(<2 x i64> %x, <2 x i64> %y, <2 x i64> %mask) {
; CHECK-LABEL: ternlog_maskx_xor_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovq2m %xmm2, %k1 ## encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; CHECK-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm2 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x54,0x15,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vxorpd %xmm1, %xmm2, %xmm0 {%k1} ## encoding: [0x62,0xf1,0xed,0x09,0x57,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_maskx_xor_and_mask:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovq2m %xmm2, %k1
; SKX-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm2
; SKX-NEXT:    vxorpd %xmm1, %xmm2, %xmm0 {%k1}
; SKX-NEXT:    retq
  %m = icmp slt <2 x i64> %mask, zeroinitializer
  %a = and <2 x i64> %x, <i64 1099511627775, i64 1099511627775>
  %b = xor <2 x i64> %a, %y
  %c = select <2 x i1> %m, <2 x i64> %b, <2 x i64> %x
  ret <2 x i64> %c
}

define <4 x i64> @ternlog_maskx_xor_and_mask_ymm(<4 x i64> %x, <4 x i64> %y, <4 x i64> %mask) {
; CHECK-LABEL: ternlog_maskx_xor_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovq2m %ymm2, %k1 ## encoding: [0x62,0xf2,0xfe,0x28,0x39,0xca]
; CHECK-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm2 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x54,0x15,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vxorpd %ymm1, %ymm2, %ymm0 {%k1} ## encoding: [0x62,0xf1,0xed,0x29,0x57,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_maskx_xor_and_mask_ymm:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovq2m %ymm2, %k1
; SKX-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm2
; SKX-NEXT:    vxorpd %ymm1, %ymm2, %ymm0 {%k1}
; SKX-NEXT:    retq
  %m = icmp slt <4 x i64> %mask, zeroinitializer
  %a = and <4 x i64> %x, <i64 72057594037927935, i64 72057594037927935, i64 72057594037927935, i64 72057594037927935>
  %b = xor <4 x i64> %a, %y
  %c = select <4 x i1> %m, <4 x i64> %b, <4 x i64> %x
  ret <4 x i64> %c
}

define <4 x i32> @ternlog_masky_or_and_mask(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z, <4 x i32> %mask) {
; CHECK-LABEL: ternlog_masky_or_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovd2m %xmm3, %k1 ## encoding: [0x62,0xf2,0x7e,0x08,0x39,0xcb]
; CHECK-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf8,0x54,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vorps %xmm1, %xmm0, %xmm1 {%k1} ## encoding: [0x62,0xf1,0x7c,0x09,0x56,0xc9]
; CHECK-NEXT:    vmovaps %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_masky_or_and_mask:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovd2m %xmm3, %k1
; SKX-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
; SKX-NEXT:    vorps %xmm1, %xmm0, %xmm1 {%k1}
; SKX-NEXT:    vmovaps %xmm1, %xmm0
; SKX-NEXT:    retq
  %m = icmp slt <4 x i32> %mask, zeroinitializer
  %a = and <4 x i32> %x, <i32 255, i32 255, i32 255, i32 255>
  %b = or <4 x i32> %a, %y
  %c = select <4 x i1> %m, <4 x i32> %b, <4 x i32> %y
  ret <4 x i32> %c
}

define <8 x i32> @ternlog_masky_or_and_mask_ymm(<8 x i32> %x, <8 x i32> %y, <8 x i32> %mask) {
; CHECK-LABEL: ternlog_masky_or_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovd2m %ymm2, %k1 ## encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; CHECK-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm2 ## EVEX TO VEX Compression encoding: [0xc5,0xfc,0x54,0x15,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vorps %ymm1, %ymm2, %ymm0 {%k1} ## encoding: [0x62,0xf1,0x6c,0x29,0x56,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_masky_or_and_mask_ymm:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovd2m %ymm2, %k1
; SKX-NEXT:    vandps {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm2
; SKX-NEXT:    vorps %ymm1, %ymm2, %ymm0 {%k1}
; SKX-NEXT:    retq
  %m = icmp slt <8 x i32> %mask, zeroinitializer
  %a = and <8 x i32> %x, <i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216>
  %b = or <8 x i32> %a, %y
  %c = select <8 x i1> %m, <8 x i32> %b, <8 x i32> %x
  ret <8 x i32> %c
}

define <2 x i64> @ternlog_masky_xor_and_mask(<2 x i64> %x, <2 x i64> %y, <2 x i64> %mask) {
; CHECK-LABEL: ternlog_masky_xor_and_mask:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovq2m %xmm2, %k1 ## encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; CHECK-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x54,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vxorpd %xmm1, %xmm0, %xmm1 {%k1} ## encoding: [0x62,0xf1,0xfd,0x09,0x57,0xc9]
; CHECK-NEXT:    vmovapd %xmm1, %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_masky_xor_and_mask:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovq2m %xmm2, %k1
; SKX-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0, %xmm0
; SKX-NEXT:    vxorpd %xmm1, %xmm0, %xmm1 {%k1}
; SKX-NEXT:    vmovapd %xmm1, %xmm0
; SKX-NEXT:    retq
  %m = icmp slt <2 x i64> %mask, zeroinitializer
  %a = and <2 x i64> %x, <i64 1099511627775, i64 1099511627775>
  %b = xor <2 x i64> %a, %y
  %c = select <2 x i1> %m, <2 x i64> %b, <2 x i64> %y
  ret <2 x i64> %c
}

define <4 x i64> @ternlog_masky_xor_and_mask_ymm(<4 x i64> %x, <4 x i64> %y, <4 x i64> %mask) {
; CHECK-LABEL: ternlog_masky_xor_and_mask_ymm:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpmovq2m %ymm2, %k1 ## encoding: [0x62,0xf2,0xfe,0x28,0x39,0xca]
; CHECK-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x54,0x05,A,A,A,A]
; CHECK-NEXT:    ## fixup A - offset: 4, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    vxorpd %ymm1, %ymm0, %ymm1 {%k1} ## encoding: [0x62,0xf1,0xfd,0x29,0x57,0xc9]
; CHECK-NEXT:    vmovapd %ymm1, %ymm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfd,0x28,0xc1]
; CHECK-NEXT:    retq ## encoding: [0xc3]
; SKX-LABEL: ternlog_masky_xor_and_mask_ymm:
; SKX:       ## %bb.0:
; SKX-NEXT:    vpmovq2m %ymm2, %k1
; SKX-NEXT:    vandpd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm0, %ymm0
; SKX-NEXT:    vxorpd %ymm1, %ymm0, %ymm1 {%k1}
; SKX-NEXT:    vmovapd %ymm1, %ymm0
; SKX-NEXT:    retq
  %m = icmp slt <4 x i64> %mask, zeroinitializer
  %a = and <4 x i64> %x, <i64 72057594037927935, i64 72057594037927935, i64 72057594037927935, i64 72057594037927935>
  %b = xor <4 x i64> %a, %y
  %c = select <4 x i1> %m, <4 x i64> %b, <4 x i64> %y
  ret <4 x i64> %c
}

define <4 x i32> @ternlog_andn_or(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_andn_or:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $14, %xmm2, %xmm1, %xmm0 ## encoding: [0x62,0xf3,0x75,0x08,0x25,0xc2,0x0e]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = xor <4 x i32> %x, <i32 -1, i32 -1, i32 -1, i32 -1>
  %b = or <4 x i32> %y, %z
  %c = and <4 x i32> %a, %b
  ret <4 x i32> %c
}

define <4 x i32> @ternlog_andn_or_2(<4 x i32> %x, <4 x i32> %y, <4 x i32> %z) {
; CHECK-LABEL: ternlog_andn_or_2:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpternlogd $16, %xmm2, %xmm1, %xmm0 ## encoding: [0x62,0xf3,0x75,0x08,0x25,0xc2,0x10]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = or <4 x i32> %y, %z
  %b = xor <4 x i32> %a, <i32 -1, i32 -1, i32 -1, i32 -1>
  %c = and <4 x i32> %x, %b
  ret <4 x i32> %c
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; KNL: {{.*}}
