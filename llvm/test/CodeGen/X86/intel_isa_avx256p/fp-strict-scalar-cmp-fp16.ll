; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx256p
; RUN: llc < %s -mtriple=i686-unknown-unknown -mattr=+avx256p -O3 | FileCheck %s --check-prefixes=AVX256P-X86
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx256p -O3 | FileCheck %s --check-prefixes=AVX256P-X64

define i32 @test_f16_oeq_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_oeq_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_oeq_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"oeq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ogt_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ogt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ogt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"ogt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_oge_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_oge_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_oge_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"oge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_olt_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_olt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_olt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"olt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ole_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ole_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ole_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"ole",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_one_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_one_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_one_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"one",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ord_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ord_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ord_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"ord",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ueq_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ueq_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ueq_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"ueq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ugt_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ugt_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ugt_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"ugt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_uge_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_uge_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_uge_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"uge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ult_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ult_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ult_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"ult",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ule_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ule_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ule_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"ule",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_une_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_une_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_une_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %esi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %edi, %eax
; AVX256P-X64-NEXT:    cmovpl %edi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"une",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_uno_q(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_uno_q:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_uno_q:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmp.f16(
                                               half %f1, half %f2, metadata !"uno",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_oeq_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_oeq_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_oeq_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"oeq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ogt_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ogt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ogt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"ogt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_oge_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_oge_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_oge_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"oge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_olt_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_olt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmoval %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_olt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"olt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ole_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ole_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovael %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ole_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovbl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"ole",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_one_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_one_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_one_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"one",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ord_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ord_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ord_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"ord",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ueq_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ueq_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ueq_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"ueq",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ugt_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ugt_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ugt_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"ugt",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_uge_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_uge_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_uge_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm0, %xmm1
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"uge",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ult_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ult_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ult_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovael %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"ult",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_ule_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_ule_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovbel %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_ule_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmoval %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"ule",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_une_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_une_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovnel %eax, %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_une_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %esi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnel %edi, %eax
; AVX256P-X64-NEXT:    cmovpl %edi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"une",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define i32 @test_f16_uno_s(i32 %a, i32 %b, half %f1, half %f2) #0 {
; AVX256P-X86-LABEL: test_f16_uno_s:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vcomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; AVX256P-X86-NEXT:    leal {{[0-9]+}}(%esp), %ecx
; AVX256P-X86-NEXT:    cmovpl %eax, %ecx
; AVX256P-X86-NEXT:    movl (%ecx), %eax
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: test_f16_uno_s:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    movl %edi, %eax
; AVX256P-X64-NEXT:    vcomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    cmovnpl %esi, %eax
; AVX256P-X64-NEXT:    retq
  %cond = call i1 @llvm.experimental.constrained.fcmps.f16(
                                               half %f1, half %f2, metadata !"uno",
                                               metadata !"fpexcept.strict") #0
  %res = select i1 %cond, i32 %a, i32 %b
  ret i32 %res
}

define void @foo(half %0, half %1) #0 {
; AVX256P-X86-LABEL: foo:
; AVX256P-X86:       # %bb.0:
; AVX256P-X86-NEXT:    vmovsh {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    vucomish {{[0-9]+}}(%esp), %xmm0
; AVX256P-X86-NEXT:    jbe .LBB28_1
; AVX256P-X86-NEXT:  # %bb.2:
; AVX256P-X86-NEXT:    jmp bar@PLT # TAILCALL
; AVX256P-X86-NEXT:  .LBB28_1:
; AVX256P-X86-NEXT:    retl
;
; AVX256P-X64-LABEL: foo:
; AVX256P-X64:       # %bb.0:
; AVX256P-X64-NEXT:    vucomish %xmm1, %xmm0
; AVX256P-X64-NEXT:    jbe .LBB28_1
; AVX256P-X64-NEXT:  # %bb.2:
; AVX256P-X64-NEXT:    jmp bar@PLT # TAILCALL
; AVX256P-X64-NEXT:  .LBB28_1:
; AVX256P-X64-NEXT:    retq
  %3 = call i1 @llvm.experimental.constrained.fcmp.f16( half %0, half %1, metadata !"ogt", metadata !"fpexcept.strict") #0
  br i1 %3, label %4, label %5

4:                                                  tail call void @bar() #0
  br label %5

5:                                                  ret void
}
declare void @bar()

attributes #0 = { strictfp nounwind }

declare i1 @llvm.experimental.constrained.fcmp.f16(half, half, metadata, metadata)
declare i1 @llvm.experimental.constrained.fcmps.f16(half, half, metadata, metadata)
