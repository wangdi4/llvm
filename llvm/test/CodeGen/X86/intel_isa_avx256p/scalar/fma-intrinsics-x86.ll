; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx256p
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx256p -show-mc-encoding | FileCheck %s --check-prefix=AVX256P
; RUN: llc < %s -mtriple=x86_64-pc-windows -mattr=+avx256p -show-mc-encoding | FileCheck %s --check-prefix=AVX256P-WIN

define <4 x float> @test_x86_fma_vfmadd_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmadd_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmadd213ss %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0xa9,0xc2]
; AVX256P-NEXT:    # xmm0 = (xmm1 * xmm0) + xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmadd_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfmadd132ss (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x99,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a0, i64 0
  %2 = extractelement <4 x float> %a1, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = call float @llvm.fma.f32(float %1, float %2, float %3)
  %5 = insertelement <4 x float> %a0, float %4, i64 0
  ret <4 x float> %5
}

define <4 x float> @test_x86_fma_vfmadd_bac_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmadd_bac_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmadd213ss %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0xa9,0xca]
; AVX256P-NEXT:    # xmm1 = (xmm0 * xmm1) + xmm2
; AVX256P-NEXT:    vmovaps %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmadd_bac_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfmadd132ss (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x99,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a1, i64 0
  %2 = extractelement <4 x float> %a0, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = call float @llvm.fma.f32(float %1, float %2, float %3)
  %5 = insertelement <4 x float> %a1, float %4, i64 0
  ret <4 x float> %5
}

define <4 x float> @test_x86_fma_vfmadd_ss_231(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmadd_ss_231:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmadd231ss %xmm1, %xmm0, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0xb9,0xd1]
; AVX256P-NEXT:    # xmm2 = (xmm0 * xmm1) + xmm2
; AVX256P-NEXT:    vmovaps %xmm2, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0xc2]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmadd_ss_231:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%r8), %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x78,0x28,0x00]
; AVX256P-WIN-NEXT:    vmovss (%rcx), %xmm1 # EVEX TO VEX Compression encoding: [0xc5,0xfa,0x10,0x09]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfmadd231ss (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0xb9,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm1 * mem) + xmm0
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a0, i64 0
  %2 = extractelement <4 x float> %a1, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = call float @llvm.fma.f32(float %1, float %2, float %3)
  %5 = insertelement <4 x float> %a2, float %4, i64 0
  ret <4 x float> %5
}

define <2 x double> @test_x86_fma_vfmadd_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmadd_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmadd213sd %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0xa9,0xc2]
; AVX256P-NEXT:    # xmm0 = (xmm1 * xmm0) + xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmadd_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfmadd132sd (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x99,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a0, i64 0
  %2 = extractelement <2 x double> %a1, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = call double @llvm.fma.f64(double %1, double %2, double %3)
  %5 = insertelement <2 x double> %a0, double %4, i64 0
  ret <2 x double> %5
}

define <2 x double> @test_x86_fma_vfmadd_bac_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmadd_bac_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmadd213sd %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf9,0xa9,0xca]
; AVX256P-NEXT:    # xmm1 = (xmm0 * xmm1) + xmm2
; AVX256P-NEXT:    vmovapd %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmadd_bac_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfmadd132sd (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x99,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a1, i64 0
  %2 = extractelement <2 x double> %a0, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = call double @llvm.fma.f64(double %1, double %2, double %3)
  %5 = insertelement <2 x double> %a1, double %4, i64 0
  ret <2 x double> %5
}

define <4 x float> @test_x86_fma_vfmsub_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmsub_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmsub213ss %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0xab,0xc2]
; AVX256P-NEXT:    # xmm0 = (xmm1 * xmm0) - xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmsub_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfmsub132ss (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x9b,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a0, i64 0
  %2 = extractelement <4 x float> %a1, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = fsub float -0.000000e+00, %3
  %5 = call float @llvm.fma.f32(float %1, float %2, float %4)
  %6 = insertelement <4 x float> %a0, float %5, i64 0
  ret <4 x float> %6
}

define <4 x float> @test_x86_fma_vfmsub_bac_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmsub_bac_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmsub213ss %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0xab,0xca]
; AVX256P-NEXT:    # xmm1 = (xmm0 * xmm1) - xmm2
; AVX256P-NEXT:    vmovaps %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmsub_bac_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfmsub132ss (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x9b,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a1, i64 0
  %2 = extractelement <4 x float> %a0, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = fsub float -0.000000e+00, %3
  %5 = call float @llvm.fma.f32(float %1, float %2, float %4)
  %6 = insertelement <4 x float> %a1, float %5, i64 0
  ret <4 x float> %6
}

define <2 x double> @test_x86_fma_vfmsub_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmsub_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmsub213sd %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0xab,0xc2]
; AVX256P-NEXT:    # xmm0 = (xmm1 * xmm0) - xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmsub_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfmsub132sd (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x9b,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a0, i64 0
  %2 = extractelement <2 x double> %a1, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = fsub double -0.000000e+00, %3
  %5 = call double @llvm.fma.f64(double %1, double %2, double %4)
  %6 = insertelement <2 x double> %a0, double %5, i64 0
  ret <2 x double> %6
}

define <2 x double> @test_x86_fma_vfmsub_bac_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfmsub_bac_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfmsub213sd %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf9,0xab,0xca]
; AVX256P-NEXT:    # xmm1 = (xmm0 * xmm1) - xmm2
; AVX256P-NEXT:    vmovapd %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfmsub_bac_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfmsub132sd (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x9b,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = (xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a1, i64 0
  %2 = extractelement <2 x double> %a0, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = fsub double -0.000000e+00, %3
  %5 = call double @llvm.fma.f64(double %1, double %2, double %4)
  %6 = insertelement <2 x double> %a1, double %5, i64 0
  ret <2 x double> %6
}

define <4 x float> @test_x86_fma_vfnmadd_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmadd_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmadd213ss %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0xad,0xc2]
; AVX256P-NEXT:    # xmm0 = -(xmm1 * xmm0) + xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmadd_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfnmadd132ss (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x9d,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a0, i64 0
  %2 = extractelement <4 x float> %a1, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = fsub float -0.000000e+00, %2
  %5 = call float @llvm.fma.f32(float %1, float %4, float %3)
  %6 = insertelement <4 x float> %a0, float %5, i64 0
  ret <4 x float> %6
}

define <4 x float> @test_x86_fma_vfnmadd_bac_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmadd_bac_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmadd213ss %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0xad,0xca]
; AVX256P-NEXT:    # xmm1 = -(xmm0 * xmm1) + xmm2
; AVX256P-NEXT:    vmovaps %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmadd_bac_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfnmadd132ss (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x9d,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a1, i64 0
  %2 = extractelement <4 x float> %a0, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = fsub float -0.000000e+00, %2
  %5 = call float @llvm.fma.f32(float %1, float %4, float %3)
  %6 = insertelement <4 x float> %a1, float %5, i64 0
  ret <4 x float> %6
}

define <2 x double> @test_x86_fma_vfnmadd_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmadd_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmadd213sd %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0xad,0xc2]
; AVX256P-NEXT:    # xmm0 = -(xmm1 * xmm0) + xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmadd_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfnmadd132sd (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x9d,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a0, i64 0
  %2 = extractelement <2 x double> %a1, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = fsub double -0.000000e+00, %2
  %5 = call double @llvm.fma.f64(double %1, double %4, double %3)
  %6 = insertelement <2 x double> %a0, double %5, i64 0
  ret <2 x double> %6
}

define <2 x double> @test_x86_fma_vfnmadd_bac_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmadd_bac_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmadd213sd %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf9,0xad,0xca]
; AVX256P-NEXT:    # xmm1 = -(xmm0 * xmm1) + xmm2
; AVX256P-NEXT:    vmovapd %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmadd_bac_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfnmadd132sd (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x9d,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) + xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a1, i64 0
  %2 = extractelement <2 x double> %a0, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = fsub double -0.000000e+00, %2
  %5 = call double @llvm.fma.f64(double %1, double %4, double %3)
  %6 = insertelement <2 x double> %a1, double %5, i64 0
  ret <2 x double> %6
}

define <4 x float> @test_x86_fma_vfnmsub_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmsub_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmsub213ss %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0xaf,0xc2]
; AVX256P-NEXT:    # xmm0 = -(xmm1 * xmm0) - xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmsub_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfnmsub132ss (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x9f,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a0, i64 0
  %2 = extractelement <4 x float> %a1, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = fsub float -0.000000e+00, %2
  %5 = fsub float -0.000000e+00, %3
  %6 = call float @llvm.fma.f32(float %1, float %4, float %5)
  %7 = insertelement <4 x float> %a0, float %6, i64 0
  ret <4 x float> %7
}

define <4 x float> @test_x86_fma_vfnmsub_bac_ss(<4 x float> %a0, <4 x float> %a1, <4 x float> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmsub_bac_ss:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmsub213ss %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0xaf,0xca]
; AVX256P-NEXT:    # xmm1 = -(xmm0 * xmm1) - xmm2
; AVX256P-NEXT:    vmovaps %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmsub_bac_ss:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovaps (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovss (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7a,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero,zero,zero
; AVX256P-WIN-NEXT:    vfnmsub132ss (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x71,0x9f,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <4 x float> %a1, i64 0
  %2 = extractelement <4 x float> %a0, i64 0
  %3 = extractelement <4 x float> %a2, i64 0
  %4 = fsub float -0.000000e+00, %2
  %5 = fsub float -0.000000e+00, %3
  %6 = call float @llvm.fma.f32(float %1, float %4, float %5)
  %7 = insertelement <4 x float> %a1, float %6, i64 0
  ret <4 x float> %7
}

define <2 x double> @test_x86_fma_vfnmsub_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmsub_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmsub213sd %xmm2, %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0xaf,0xc2]
; AVX256P-NEXT:    # xmm0 = -(xmm1 * xmm0) - xmm2
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmsub_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rcx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x01]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfnmsub132sd (%rdx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x9f,0x02]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a0, i64 0
  %2 = extractelement <2 x double> %a1, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = fsub double -0.000000e+00, %2
  %5 = fsub double -0.000000e+00, %3
  %6 = call double @llvm.fma.f64(double %1, double %4, double %5)
  %7 = insertelement <2 x double> %a0, double %6, i64 0
  ret <2 x double> %7
}

define <2 x double> @test_x86_fma_vfnmsub_bac_sd(<2 x double> %a0, <2 x double> %a1, <2 x double> %a2) #0 {
; AVX256P-LABEL: test_x86_fma_vfnmsub_bac_sd:
; AVX256P:       # %bb.0:
; AVX256P-NEXT:    vfnmsub213sd %xmm2, %xmm0, %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf9,0xaf,0xca]
; AVX256P-NEXT:    # xmm1 = -(xmm0 * xmm1) - xmm2
; AVX256P-NEXT:    vmovapd %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0xc1]
; AVX256P-NEXT:    retq # encoding: [0xc3]
;
; AVX256P-WIN-LABEL: test_x86_fma_vfnmsub_bac_sd:
; AVX256P-WIN:       # %bb.0:
; AVX256P-WIN-NEXT:    vmovapd (%rdx), %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x28,0x02]
; AVX256P-WIN-NEXT:    vmovsd (%r8), %xmm1 # EVEX TO VEX Compression encoding: [0xc4,0xc1,0x7b,0x10,0x08]
; AVX256P-WIN-NEXT:    # xmm1 = mem[0],zero
; AVX256P-WIN-NEXT:    vfnmsub132sd (%rcx), %xmm1, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0xf1,0x9f,0x01]
; AVX256P-WIN-NEXT:    # xmm0 = -(xmm0 * mem) - xmm1
; AVX256P-WIN-NEXT:    retq # encoding: [0xc3]
  %1 = extractelement <2 x double> %a1, i64 0
  %2 = extractelement <2 x double> %a0, i64 0
  %3 = extractelement <2 x double> %a2, i64 0
  %4 = fsub double -0.000000e+00, %2
  %5 = fsub double -0.000000e+00, %3
  %6 = call double @llvm.fma.f64(double %1, double %4, double %5)
  %7 = insertelement <2 x double> %a1, double %6, i64 0
  ret <2 x double> %7
}
declare float @llvm.fma.f32(float, float, float)
declare double @llvm.fma.f64(double, double, double)
