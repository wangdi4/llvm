; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx256p
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx256p,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle -O2 --show-mc-encoding | FileCheck %s --check-prefixes=AVX512,AVX512-FAST
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avx256p,+fast-variable-perlane-shuffle -O2 --show-mc-encoding | FileCheck %s --check-prefixes=AVX512,AVX512-FAST-PERLANE

define void @load_v8i1_broadcast_4_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v8i1_broadcast_4_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $4, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x04]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastq %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xd2]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <8 x i1>, ptr %a0
    %d1 = shufflevector <8 x i1> %d0,<8 x i1> undef,<2 x i32><i32 4,i32 4>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v8i1_broadcast_7_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v8i1_broadcast_7_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $6, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x06]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpshufd $238, %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xd2,0xee]
; AVX512-NEXT:    # xmm2 = xmm2[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <8 x i1>, ptr %a0
    %d1 = shufflevector <8 x i1> %d0,<8 x i1> undef,<2 x i32><i32 7,i32 7>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v16i1_broadcast_8_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v16i1_broadcast_8_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $8, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x08]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastq %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xd2]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<2 x i32><i32 8,i32 8>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v16i1_broadcast_8_v4i1(ptr %a0,<4 x float> %a1,<4 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v16i1_broadcast_8_v4i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $8, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x08]
; AVX512-NEXT:    vpmovm2d %k0, %xmm2 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastd %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x58,0xd2]
; AVX512-NEXT:    vpmovd2m %xmm2, %k1 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xca]
; AVX512-NEXT:    vmovaps %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovaps %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<4 x i32><i32 8,i32 8,i32 8,i32 8>
    %d2 = select <4 x i1> %d1, <4 x float> %a1, <4 x float> %a2
    store <4 x float> %d2, ptr %a3
    ret void
}

define void @load_v16i1_broadcast_15_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v16i1_broadcast_15_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $14, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x0e]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpshufd $238, %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xd2,0xee]
; AVX512-NEXT:    # xmm2 = xmm2[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<2 x i32><i32 15,i32 15>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v16i1_broadcast_15_v4i1(ptr %a0,<4 x float> %a1,<4 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v16i1_broadcast_15_v4i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $12, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x0c]
; AVX512-NEXT:    vpmovm2d %k0, %xmm2 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xd0]
; AVX512-NEXT:    vpshufd $255, %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xd2,0xff]
; AVX512-NEXT:    # xmm2 = xmm2[3,3,3,3]
; AVX512-NEXT:    vpmovd2m %xmm2, %k1 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xca]
; AVX512-NEXT:    vmovaps %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovaps %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<4 x i32><i32 15,i32 15,i32 15,i32 15>
    %d2 = select <4 x i1> %d1, <4 x float> %a1, <4 x float> %a2
    store <4 x float> %d2, ptr %a3
    ret void
}

define void @load_v32i1_broadcast_16_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v32i1_broadcast_16_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $16, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x10]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastq %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xd2]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<2 x i32><i32 16,i32 16>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v32i1_broadcast_16_v4i1(ptr %a0,<4 x float> %a1,<4 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v32i1_broadcast_16_v4i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $16, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x10]
; AVX512-NEXT:    vpmovm2d %k0, %xmm2 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastd %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x58,0xd2]
; AVX512-NEXT:    vpmovd2m %xmm2, %k1 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xca]
; AVX512-NEXT:    vmovaps %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovaps %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<4 x i32><i32 16,i32 16,i32 16,i32 16>
    %d2 = select <4 x i1> %d1, <4 x float> %a1, <4 x float> %a2
    store <4 x float> %d2, ptr %a3
    ret void
}

define void @load_v32i1_broadcast_16_v8i1(ptr %a0,<8 x float> %a1,<8 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v32i1_broadcast_16_v8i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb 2(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x02]
; AVX512-NEXT:    vpmovm2d %k0, %ymm2 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastd %xmm2, %ymm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x7d,0x58,0xd2]
; AVX512-NEXT:    vpmovd2m %ymm2, %k1 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; AVX512-NEXT:    vmovaps %ymm0, %ymm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x29,0x28,0xc8]
; AVX512-NEXT:    vmovaps %ymm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xfc,0x29,0x0e]
; AVX512-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<8 x i32><i32 16,i32 16,i32 16,i32 16,i32 16,i32 16,i32 16,i32 16>
    %d2 = select <8 x i1> %d1, <8 x float> %a1, <8 x float> %a2
    store <8 x float> %d2, ptr %a3
    ret void
}

define void @load_v32i1_broadcast_31_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v32i1_broadcast_31_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $30, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1e]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpshufd $238, %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xd2,0xee]
; AVX512-NEXT:    # xmm2 = xmm2[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<2 x i32><i32 31,i32 31>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v32i1_broadcast_31_v4i1(ptr %a0,<4 x float> %a1,<4 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v32i1_broadcast_31_v4i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $28, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1c]
; AVX512-NEXT:    vpmovm2d %k0, %xmm2 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xd0]
; AVX512-NEXT:    vpshufd $255, %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xd2,0xff]
; AVX512-NEXT:    # xmm2 = xmm2[3,3,3,3]
; AVX512-NEXT:    vpmovd2m %xmm2, %k1 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xca]
; AVX512-NEXT:    vmovaps %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovaps %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<4 x i32><i32 31,i32 31,i32 31,i32 31>
    %d2 = select <4 x i1> %d1, <4 x float> %a1, <4 x float> %a2
    store <4 x float> %d2, ptr %a3
    ret void
}

define void @load_v32i1_broadcast_31_v8i1(ptr %a0,<8 x float> %a1,<8 x float> %a2,ptr %a3) {
; AVX512-FAST-LABEL: load_v32i1_broadcast_31_v8i1:
; AVX512-FAST:       # %bb.0:
; AVX512-FAST-NEXT:    kmovb 3(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x03]
; AVX512-FAST-NEXT:    vpmovm2d %k0, %ymm2 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xd0]
; AVX512-FAST-NEXT:    vpbroadcastd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3 # EVEX TO VEX Compression ymm3 = [7,7,7,7,7,7,7,7]
; AVX512-FAST-NEXT:    # encoding: [0xc4,0xe2,0x7d,0x58,0x1d,A,A,A,A]
; AVX512-FAST-NEXT:    # fixup A - offset: 5, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; AVX512-FAST-NEXT:    vpermd %ymm2, %ymm3, %ymm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x65,0x36,0xd2]
; AVX512-FAST-NEXT:    vpmovd2m %ymm2, %k1 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; AVX512-FAST-NEXT:    vmovaps %ymm0, %ymm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x29,0x28,0xc8]
; AVX512-FAST-NEXT:    vmovaps %ymm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xfc,0x29,0x0e]
; AVX512-FAST-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-NEXT:    retq # encoding: [0xc3]
;
; AVX512-FAST-PERLANE-LABEL: load_v32i1_broadcast_31_v8i1:
; AVX512-FAST-PERLANE:       # %bb.0:
; AVX512-FAST-PERLANE-NEXT:    kmovb 3(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x03]
; AVX512-FAST-PERLANE-NEXT:    vpmovm2d %k0, %ymm2 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xd0]
; AVX512-FAST-PERLANE-NEXT:    vpshufd $255, %ymm2, %ymm2 # EVEX TO VEX Compression encoding: [0xc5,0xfd,0x70,0xd2,0xff]
; AVX512-FAST-PERLANE-NEXT:    # ymm2 = ymm2[3,3,3,3,7,7,7,7]
; AVX512-FAST-PERLANE-NEXT:    vpermq $170, %ymm2, %ymm2 # EVEX TO VEX Compression encoding: [0xc4,0xe3,0xfd,0x00,0xd2,0xaa]
; AVX512-FAST-PERLANE-NEXT:    # ymm2 = ymm2[2,2,2,2]
; AVX512-FAST-PERLANE-NEXT:    vpmovd2m %ymm2, %k1 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; AVX512-FAST-PERLANE-NEXT:    vmovaps %ymm0, %ymm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x29,0x28,0xc8]
; AVX512-FAST-PERLANE-NEXT:    vmovaps %ymm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xfc,0x29,0x0e]
; AVX512-FAST-PERLANE-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-PERLANE-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<8 x i32><i32 31,i32 31,i32 31,i32 31,i32 31,i32 31,i32 31,i32 31>
    %d2 = select <8 x i1> %d1, <8 x float> %a1, <8 x float> %a2
    store <8 x float> %d2, ptr %a3
    ret void
}

define void @load_v64i1_broadcast_32_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v64i1_broadcast_32_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastq %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xd2]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<2 x i32><i32 32,i32 32>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v64i1_broadcast_32_v4i1(ptr %a0,<4 x float> %a1,<4 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v64i1_broadcast_32_v4i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    vpmovm2d %k0, %xmm2 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastd %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x58,0xd2]
; AVX512-NEXT:    vpmovd2m %xmm2, %k1 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xca]
; AVX512-NEXT:    vmovaps %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovaps %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<4 x i32><i32 32,i32 32,i32 32,i32 32>
    %d2 = select <4 x i1> %d1, <4 x float> %a1, <4 x float> %a2
    store <4 x float> %d2, ptr %a3
    ret void
}

define void @load_v64i1_broadcast_32_v8i1(ptr %a0,<8 x float> %a1,<8 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v64i1_broadcast_32_v8i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb 4(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    vpmovm2d %k0, %ymm2 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xd0]
; AVX512-NEXT:    vpbroadcastd %xmm2, %ymm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x7d,0x58,0xd2]
; AVX512-NEXT:    vpmovd2m %ymm2, %k1 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; AVX512-NEXT:    vmovaps %ymm0, %ymm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x29,0x28,0xc8]
; AVX512-NEXT:    vmovaps %ymm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xfc,0x29,0x0e]
; AVX512-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<8 x i32><i32 32,i32 32,i32 32,i32 32,i32 32,i32 32,i32 32,i32 32>
    %d2 = select <8 x i1> %d1, <8 x float> %a1, <8 x float> %a2
    store <8 x float> %d2, ptr %a3
    ret void
}

define void @load_v64i1_broadcast_63_v2i1(ptr %a0,<2 x double> %a1,<2 x double> %a2,ptr %a3) {
; AVX512-LABEL: load_v64i1_broadcast_63_v2i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    kshiftrd $30, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1e]
; AVX512-NEXT:    vpmovm2q %k0, %xmm2 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xd0]
; AVX512-NEXT:    vpshufd $238, %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xd2,0xee]
; AVX512-NEXT:    # xmm2 = xmm2[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm2, %k1 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xca]
; AVX512-NEXT:    vmovapd %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0xfd,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovapd %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<2 x i32><i32 63,i32 63>
    %d2 = select <2 x i1> %d1, <2 x double> %a1, <2 x double> %a2
    store <2 x double> %d2, ptr %a3
    ret void
}

define void @load_v64i1_broadcast_63_v4i1(ptr %a0,<4 x float> %a1,<4 x float> %a2,ptr %a3) {
; AVX512-LABEL: load_v64i1_broadcast_63_v4i1:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    kshiftrd $28, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1c]
; AVX512-NEXT:    vpmovm2d %k0, %xmm2 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xd0]
; AVX512-NEXT:    vpshufd $255, %xmm2, %xmm2 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xd2,0xff]
; AVX512-NEXT:    # xmm2 = xmm2[3,3,3,3]
; AVX512-NEXT:    vpmovd2m %xmm2, %k1 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xca]
; AVX512-NEXT:    vmovaps %xmm0, %xmm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x09,0x28,0xc8]
; AVX512-NEXT:    vmovaps %xmm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xf8,0x29,0x0e]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<4 x i32><i32 63,i32 63,i32 63,i32 63>
    %d2 = select <4 x i1> %d1, <4 x float> %a1, <4 x float> %a2
    store <4 x float> %d2, ptr %a3
    ret void
}

define void @load_v64i1_broadcast_63_v8i1(ptr %a0,<8 x float> %a1,<8 x float> %a2,ptr %a3) {
; AVX512-FAST-LABEL: load_v64i1_broadcast_63_v8i1:
; AVX512-FAST:       # %bb.0:
; AVX512-FAST-NEXT:    kmovb 7(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x07]
; AVX512-FAST-NEXT:    vpmovm2d %k0, %ymm2 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xd0]
; AVX512-FAST-NEXT:    vpbroadcastd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3 # EVEX TO VEX Compression ymm3 = [7,7,7,7,7,7,7,7]
; AVX512-FAST-NEXT:    # encoding: [0xc4,0xe2,0x7d,0x58,0x1d,A,A,A,A]
; AVX512-FAST-NEXT:    # fixup A - offset: 5, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; AVX512-FAST-NEXT:    vpermd %ymm2, %ymm3, %ymm2 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x65,0x36,0xd2]
; AVX512-FAST-NEXT:    vpmovd2m %ymm2, %k1 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; AVX512-FAST-NEXT:    vmovaps %ymm0, %ymm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x29,0x28,0xc8]
; AVX512-FAST-NEXT:    vmovaps %ymm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xfc,0x29,0x0e]
; AVX512-FAST-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-NEXT:    retq # encoding: [0xc3]
;
; AVX512-FAST-PERLANE-LABEL: load_v64i1_broadcast_63_v8i1:
; AVX512-FAST-PERLANE:       # %bb.0:
; AVX512-FAST-PERLANE-NEXT:    kmovb 7(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x07]
; AVX512-FAST-PERLANE-NEXT:    vpmovm2d %k0, %ymm2 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xd0]
; AVX512-FAST-PERLANE-NEXT:    vpshufd $255, %ymm2, %ymm2 # EVEX TO VEX Compression encoding: [0xc5,0xfd,0x70,0xd2,0xff]
; AVX512-FAST-PERLANE-NEXT:    # ymm2 = ymm2[3,3,3,3,7,7,7,7]
; AVX512-FAST-PERLANE-NEXT:    vpermq $170, %ymm2, %ymm2 # EVEX TO VEX Compression encoding: [0xc4,0xe3,0xfd,0x00,0xd2,0xaa]
; AVX512-FAST-PERLANE-NEXT:    # ymm2 = ymm2[2,2,2,2]
; AVX512-FAST-PERLANE-NEXT:    vpmovd2m %ymm2, %k1 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xca]
; AVX512-FAST-PERLANE-NEXT:    vmovaps %ymm0, %ymm1 {%k1} # encoding: [0x62,0xf1,0x7c,0x29,0x28,0xc8]
; AVX512-FAST-PERLANE-NEXT:    vmovaps %ymm1, (%rsi) # EVEX TO VEX Compression encoding: [0xc5,0xfc,0x29,0x0e]
; AVX512-FAST-PERLANE-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-PERLANE-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<8 x i32><i32 63,i32 63,i32 63,i32 63,i32 63,i32 63,i32 63,i32 63>
    %d2 = select <8 x i1> %d1, <8 x float> %a1, <8 x float> %a2
    store <8 x float> %d2, ptr %a3
    ret void
}

define void @load_v2i1_broadcast_1_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v2i1_broadcast_1_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $1, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x01]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <2 x i1>, ptr %a0
    %d1 = shufflevector <2 x i1> %d0,<2 x i1> undef,<1 x i32><i32 1>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v3i1_broadcast_1_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v3i1_broadcast_1_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    movzbl (%rdi), %eax # encoding: [0x0f,0xb6,0x07]
; AVX512-NEXT:    shrb %al # encoding: [0xd0,0xe8]
; AVX512-NEXT:    xorl %ecx, %ecx # encoding: [0x31,0xc9]
; AVX512-NEXT:    testb $1, %al # encoding: [0xa8,0x01]
; AVX512-NEXT:    movl $255, %eax # encoding: [0xb8,0xff,0x00,0x00,0x00]
; AVX512-NEXT:    cmovel %ecx, %eax # encoding: [0x0f,0x44,0xc1]
; AVX512-NEXT:    kmovd %eax, %k0 # encoding: [0xc5,0xfb,0x92,0xc0]
; AVX512-NEXT:    kshiftrb $1, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x01]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <3 x i1>, ptr %a0
    %d1 = shufflevector <3 x i1> %d0,<3 x i1> undef,<1 x i32><i32 1>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v3i1_broadcast_2_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v3i1_broadcast_2_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; AVX512-NEXT:    testb $4, (%rdi) # encoding: [0xf6,0x07,0x04]
; AVX512-NEXT:    movl $255, %ecx # encoding: [0xb9,0xff,0x00,0x00,0x00]
; AVX512-NEXT:    cmovel %eax, %ecx # encoding: [0x0f,0x44,0xc8]
; AVX512-NEXT:    kmovd %ecx, %k0 # encoding: [0xc5,0xfb,0x92,0xc1]
; AVX512-NEXT:    kshiftrb $2, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x02]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <3 x i1>, ptr %a0
    %d1 = shufflevector <3 x i1> %d0,<3 x i1> undef,<1 x i32><i32 2>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v4i1_broadcast_2_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v4i1_broadcast_2_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $2, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x02]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <4 x i1>, ptr %a0
    %d1 = shufflevector <4 x i1> %d0,<4 x i1> undef,<1 x i32><i32 2>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v4i1_broadcast_3_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v4i1_broadcast_3_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $3, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x03]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <4 x i1>, ptr %a0
    %d1 = shufflevector <4 x i1> %d0,<4 x i1> undef,<1 x i32><i32 3>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v8i1_broadcast_4_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v8i1_broadcast_4_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $4, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x04]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <8 x i1>, ptr %a0
    %d1 = shufflevector <8 x i1> %d0,<8 x i1> undef,<1 x i32><i32 4>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v8i1_broadcast_4_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v8i1_broadcast_4_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $4, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x04]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastq %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xc0]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <8 x i1>, ptr %a0
    %d1 = shufflevector <8 x i1> %d0,<8 x i1> undef,<2 x i32><i32 4,i32 4>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v8i1_broadcast_7_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v8i1_broadcast_7_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <8 x i1>, ptr %a0
    %d1 = shufflevector <8 x i1> %d0,<8 x i1> undef,<1 x i32><i32 7>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v8i1_broadcast_7_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v8i1_broadcast_7_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb (%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrb $6, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x06]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpshufd $238, %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xc0,0xee]
; AVX512-NEXT:    # xmm0 = xmm0[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <8 x i1>, ptr %a0
    %d1 = shufflevector <8 x i1> %d0,<8 x i1> undef,<2 x i32><i32 7,i32 7>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v16i1_broadcast_8_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v16i1_broadcast_8_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $8, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x08]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<1 x i32><i32 8>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v16i1_broadcast_8_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v16i1_broadcast_8_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $8, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x08]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastq %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xc0]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<2 x i32><i32 8,i32 8>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v16i1_broadcast_8_v4i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v16i1_broadcast_8_v4i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $8, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x08]
; AVX512-NEXT:    vpmovm2d %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastd %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x58,0xc0]
; AVX512-NEXT:    vpmovd2m %xmm0, %k0 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<4 x i32><i32 8,i32 8,i32 8,i32 8>
    store <4 x i1> %d1, ptr %a1
    ret void
}

define void @load_v16i1_broadcast_15_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v16i1_broadcast_15_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $15, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x0f]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<1 x i32><i32 15>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v16i1_broadcast_15_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v16i1_broadcast_15_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $14, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x0e]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpshufd $238, %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xc0,0xee]
; AVX512-NEXT:    # xmm0 = xmm0[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<2 x i32><i32 15,i32 15>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v16i1_broadcast_15_v4i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v16i1_broadcast_15_v4i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovw (%rdi), %k0 # encoding: [0xc5,0xf8,0x90,0x07]
; AVX512-NEXT:    kshiftrw $12, %k0, %k0 # encoding: [0xc4,0xe3,0xf9,0x30,0xc0,0x0c]
; AVX512-NEXT:    vpmovm2d %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xc0]
; AVX512-NEXT:    vpshufd $255, %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xc0,0xff]
; AVX512-NEXT:    # xmm0 = xmm0[3,3,3,3]
; AVX512-NEXT:    vpmovd2m %xmm0, %k0 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <16 x i1>, ptr %a0
    %d1 = shufflevector <16 x i1> %d0,<16 x i1> undef,<4 x i32><i32 15,i32 15,i32 15,i32 15>
    store <4 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_16_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v32i1_broadcast_16_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $16, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x10]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<1 x i32><i32 16>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_16_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v32i1_broadcast_16_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $16, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x10]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastq %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xc0]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<2 x i32><i32 16,i32 16>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_16_v4i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v32i1_broadcast_16_v4i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $16, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x10]
; AVX512-NEXT:    vpmovm2d %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastd %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x58,0xc0]
; AVX512-NEXT:    vpmovd2m %xmm0, %k0 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<4 x i32><i32 16,i32 16,i32 16,i32 16>
    store <4 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_16_v8i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v32i1_broadcast_16_v8i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb 2(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x02]
; AVX512-NEXT:    vpmovm2d %k0, %ymm0 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastd %xmm0, %ymm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x7d,0x58,0xc0]
; AVX512-NEXT:    vpmovd2m %ymm0, %k0 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<8 x i32><i32 16,i32 16,i32 16,i32 16,i32 16,i32 16,i32 16,i32 16>
    store <8 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_31_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v32i1_broadcast_31_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $31, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1f]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<1 x i32><i32 31>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_31_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v32i1_broadcast_31_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $30, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1e]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpshufd $238, %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xc0,0xee]
; AVX512-NEXT:    # xmm0 = xmm0[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<2 x i32><i32 31,i32 31>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_31_v4i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v32i1_broadcast_31_v4i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd (%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x07]
; AVX512-NEXT:    kshiftrd $28, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1c]
; AVX512-NEXT:    vpmovm2d %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xc0]
; AVX512-NEXT:    vpshufd $255, %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xc0,0xff]
; AVX512-NEXT:    # xmm0 = xmm0[3,3,3,3]
; AVX512-NEXT:    vpmovd2m %xmm0, %k0 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<4 x i32><i32 31,i32 31,i32 31,i32 31>
    store <4 x i1> %d1, ptr %a1
    ret void
}

define void @load_v32i1_broadcast_31_v8i1_store(ptr %a0,ptr %a1) {
; AVX512-FAST-LABEL: load_v32i1_broadcast_31_v8i1_store:
; AVX512-FAST:       # %bb.0:
; AVX512-FAST-NEXT:    kmovb 3(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x03]
; AVX512-FAST-NEXT:    vpmovm2d %k0, %ymm0 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xc0]
; AVX512-FAST-NEXT:    vpbroadcastd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm1 # EVEX TO VEX Compression ymm1 = [7,7,7,7,7,7,7,7]
; AVX512-FAST-NEXT:    # encoding: [0xc4,0xe2,0x7d,0x58,0x0d,A,A,A,A]
; AVX512-FAST-NEXT:    # fixup A - offset: 5, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; AVX512-FAST-NEXT:    vpermd %ymm0, %ymm1, %ymm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x75,0x36,0xc0]
; AVX512-FAST-NEXT:    vpmovd2m %ymm0, %k0 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xc0]
; AVX512-FAST-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-FAST-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-NEXT:    retq # encoding: [0xc3]
;
; AVX512-FAST-PERLANE-LABEL: load_v32i1_broadcast_31_v8i1_store:
; AVX512-FAST-PERLANE:       # %bb.0:
; AVX512-FAST-PERLANE-NEXT:    kmovb 3(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x03]
; AVX512-FAST-PERLANE-NEXT:    vpmovm2d %k0, %ymm0 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xc0]
; AVX512-FAST-PERLANE-NEXT:    vpshufd $255, %ymm0, %ymm0 # EVEX TO VEX Compression encoding: [0xc5,0xfd,0x70,0xc0,0xff]
; AVX512-FAST-PERLANE-NEXT:    # ymm0 = ymm0[3,3,3,3,7,7,7,7]
; AVX512-FAST-PERLANE-NEXT:    vpermq $170, %ymm0, %ymm0 # EVEX TO VEX Compression encoding: [0xc4,0xe3,0xfd,0x00,0xc0,0xaa]
; AVX512-FAST-PERLANE-NEXT:    # ymm0 = ymm0[2,2,2,2]
; AVX512-FAST-PERLANE-NEXT:    vpmovd2m %ymm0, %k0 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xc0]
; AVX512-FAST-PERLANE-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-FAST-PERLANE-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-PERLANE-NEXT:    retq # encoding: [0xc3]
    %d0 = load <32 x i1>, ptr %a0
    %d1 = shufflevector <32 x i1> %d0,<32 x i1> undef,<8 x i32><i32 31,i32 31,i32 31,i32 31,i32 31,i32 31,i32 31,i32 31>
    store <8 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_32_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v64i1_broadcast_32_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<1 x i32><i32 32>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_32_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v64i1_broadcast_32_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastq %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x59,0xc0]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<2 x i32><i32 32,i32 32>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_32_v4i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v64i1_broadcast_32_v4i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    vpmovm2d %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastd %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x79,0x58,0xc0]
; AVX512-NEXT:    vpmovd2m %xmm0, %k0 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<4 x i32><i32 32,i32 32,i32 32,i32 32>
    store <4 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_32_v8i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v64i1_broadcast_32_v8i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovb 4(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    vpmovm2d %k0, %ymm0 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xc0]
; AVX512-NEXT:    vpbroadcastd %xmm0, %ymm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x7d,0x58,0xc0]
; AVX512-NEXT:    vpmovd2m %ymm0, %k0 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<8 x i32><i32 32,i32 32,i32 32,i32 32,i32 32,i32 32,i32 32,i32 32>
    store <8 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_63_v1i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v64i1_broadcast_63_v1i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    kshiftrd $31, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1f]
; AVX512-NEXT:    kshiftlb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x32,0xc0,0x07]
; AVX512-NEXT:    kshiftrb $7, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x30,0xc0,0x07]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<1 x i32><i32 63>
    store <1 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_63_v2i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v64i1_broadcast_63_v2i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    kshiftrd $30, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1e]
; AVX512-NEXT:    vpmovm2q %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x38,0xc0]
; AVX512-NEXT:    vpshufd $238, %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xc0,0xee]
; AVX512-NEXT:    # xmm0 = xmm0[2,3,2,3]
; AVX512-NEXT:    vpmovq2m %xmm0, %k0 # encoding: [0x62,0xf2,0xfe,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<2 x i32><i32 63,i32 63>
    store <2 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_63_v4i1_store(ptr %a0,ptr %a1) {
; AVX512-LABEL: load_v64i1_broadcast_63_v4i1_store:
; AVX512:       # %bb.0:
; AVX512-NEXT:    kmovd 4(%rdi), %k0 # encoding: [0xc4,0xe1,0xf9,0x90,0x47,0x04]
; AVX512-NEXT:    kshiftrd $28, %k0, %k0 # encoding: [0xc4,0xe3,0x79,0x31,0xc0,0x1c]
; AVX512-NEXT:    vpmovm2d %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x38,0xc0]
; AVX512-NEXT:    vpshufd $255, %xmm0, %xmm0 # EVEX TO VEX Compression encoding: [0xc5,0xf9,0x70,0xc0,0xff]
; AVX512-NEXT:    # xmm0 = xmm0[3,3,3,3]
; AVX512-NEXT:    vpmovd2m %xmm0, %k0 # encoding: [0x62,0xf2,0x7e,0x08,0x39,0xc0]
; AVX512-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<4 x i32><i32 63,i32 63,i32 63,i32 63>
    store <4 x i1> %d1, ptr %a1
    ret void
}

define void @load_v64i1_broadcast_63_v8i1_store(ptr %a0,ptr %a1) {
; AVX512-FAST-LABEL: load_v64i1_broadcast_63_v8i1_store:
; AVX512-FAST:       # %bb.0:
; AVX512-FAST-NEXT:    kmovb 7(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x07]
; AVX512-FAST-NEXT:    vpmovm2d %k0, %ymm0 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xc0]
; AVX512-FAST-NEXT:    vpbroadcastd {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm1 # EVEX TO VEX Compression ymm1 = [7,7,7,7,7,7,7,7]
; AVX512-FAST-NEXT:    # encoding: [0xc4,0xe2,0x7d,0x58,0x0d,A,A,A,A]
; AVX512-FAST-NEXT:    # fixup A - offset: 5, value: {{\.?LCPI[0-9]+_[0-9]+}}-4, kind: reloc_riprel_4byte
; AVX512-FAST-NEXT:    vpermd %ymm0, %ymm1, %ymm0 # EVEX TO VEX Compression encoding: [0xc4,0xe2,0x75,0x36,0xc0]
; AVX512-FAST-NEXT:    vpmovd2m %ymm0, %k0 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xc0]
; AVX512-FAST-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-FAST-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-NEXT:    retq # encoding: [0xc3]
;
; AVX512-FAST-PERLANE-LABEL: load_v64i1_broadcast_63_v8i1_store:
; AVX512-FAST-PERLANE:       # %bb.0:
; AVX512-FAST-PERLANE-NEXT:    kmovb 7(%rdi), %k0 # encoding: [0xc5,0xf9,0x90,0x47,0x07]
; AVX512-FAST-PERLANE-NEXT:    vpmovm2d %k0, %ymm0 # encoding: [0x62,0xf2,0x7e,0x28,0x38,0xc0]
; AVX512-FAST-PERLANE-NEXT:    vpshufd $255, %ymm0, %ymm0 # EVEX TO VEX Compression encoding: [0xc5,0xfd,0x70,0xc0,0xff]
; AVX512-FAST-PERLANE-NEXT:    # ymm0 = ymm0[3,3,3,3,7,7,7,7]
; AVX512-FAST-PERLANE-NEXT:    vpermq $170, %ymm0, %ymm0 # EVEX TO VEX Compression encoding: [0xc4,0xe3,0xfd,0x00,0xc0,0xaa]
; AVX512-FAST-PERLANE-NEXT:    # ymm0 = ymm0[2,2,2,2]
; AVX512-FAST-PERLANE-NEXT:    vpmovd2m %ymm0, %k0 # encoding: [0x62,0xf2,0x7e,0x28,0x39,0xc0]
; AVX512-FAST-PERLANE-NEXT:    kmovb %k0, (%rsi) # encoding: [0xc5,0xf9,0x91,0x06]
; AVX512-FAST-PERLANE-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; AVX512-FAST-PERLANE-NEXT:    retq # encoding: [0xc3]
    %d0 = load <64 x i1>, ptr %a0
    %d1 = shufflevector <64 x i1> %d0,<64 x i1> undef,<8 x i32><i32 63,i32 63,i32 63,i32 63,i32 63,i32 63,i32 63,i32 63>
    store <8 x i1> %d1, ptr %a1
    ret void
}
