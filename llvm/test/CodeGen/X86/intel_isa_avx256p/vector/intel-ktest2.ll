; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx256p
; RUN: llc < %s -O0 -mtriple=x86_64-unknown-unknown -mattr=+avx256p -enable-intel-advanced-opts --show-mc-encoding | FileCheck %s --check-prefixes=X64
; RUN: llc < %s -O0 -mtriple=i686-unknown-unknown -mattr=+avx256p -enable-intel-advanced-opts --show-mc-encoding | FileCheck %s --check-prefixes=X86

define <8 x i1> @test_pseudo_kmovb_spill() nounwind {
; X64-LABEL: test_pseudo_kmovb_spill:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rbx # encoding: [0x53]
; X64-NEXT:    #APP
; X64-NEXT:    #NO_APP
; X64-NEXT:    movb $3, %dil # encoding: [0x40,0xb7,0x03]
; X64-NEXT:    # implicit-def: $esi
; X64-NEXT:    movb %dil, %sil # encoding: [0x40,0x88,0xfe]
; X64-NEXT:    kmovb %esi, %k0 # encoding: [0xc5,0xf9,0x92,0xc6]
; X64-NEXT:    #APP
; X64-NEXT:    #NO_APP
; X64-NEXT:    vpmovm2w %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x28,0xc0]
; X64-NEXT:    popq %rbx # encoding: [0x5b]
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_pseudo_kmovb_spill:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx # encoding: [0x53]
; X86-NEXT:    subl $8, %esp # encoding: [0x83,0xec,0x08]
; X86-NEXT:    #APP
; X86-NEXT:    #NO_APP
; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; X86-NEXT:    # encoding: [0x89,0x44,0x24,0x04]
; X86-NEXT:    movl %ecx, (%esp) # 4-byte Spill
; X86-NEXT:    # encoding: [0x89,0x0c,0x24]
; X86-NEXT:    movb $3, %cl # encoding: [0xb1,0x03]
; X86-NEXT:    # implicit-def: $eax
; X86-NEXT:    movb %cl, %al # encoding: [0x88,0xc8]
; X86-NEXT:    movl (%esp), %ecx # 4-byte Reload
; X86-NEXT:    # encoding: [0x8b,0x0c,0x24]
; X86-NEXT:    kmovb %eax, %k0 # encoding: [0xc5,0xf9,0x92,0xc0]
; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Reload
; X86-NEXT:    # encoding: [0x8b,0x44,0x24,0x04]
; X86-NEXT:    #APP
; X86-NEXT:    #NO_APP
; X86-NEXT:    vpmovm2w %k0, %xmm0 # encoding: [0x62,0xf2,0xfe,0x08,0x28,0xc0]
; X86-NEXT:    addl $8, %esp # encoding: [0x83,0xc4,0x08]
; X86-NEXT:    popl %ebx # encoding: [0x5b]
; X86-NEXT:    retl # encoding: [0xc3]
  %1 = call { i32, i32, i32, i32 } asm sideeffect "", "={ax},={bx},={cx},={dx},~{dirflag},~{fpsr},~{flags}"()
  %2 = bitcast i8 3 to <8 x i1>
  %a = extractvalue { i32, i32, i32, i32 } %1, 0
  %b = extractvalue { i32, i32, i32, i32 } %1, 1
  %c = extractvalue { i32, i32, i32, i32 } %1, 2
  %d = extractvalue { i32, i32, i32, i32 } %1, 3
  call void asm sideeffect "", "{ax},{bx},{cx},{dx},~{dirflag},~{fpsr},~{flags}"(i32 %a, i32 %b, i32 %c, i32 %d)
  ret <8 x i1> %2
}

define <16 x i1> @test_pseudo_kmovw_spill() nounwind {
; X64-LABEL: test_pseudo_kmovw_spill:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rbx # encoding: [0x53]
; X64-NEXT:    #APP
; X64-NEXT:    #NO_APP
; X64-NEXT:    movw $3, %di # encoding: [0x66,0xbf,0x03,0x00]
; X64-NEXT:    # implicit-def: $esi
; X64-NEXT:    movw %di, %si # encoding: [0x66,0x89,0xfe]
; X64-NEXT:    kmovw %esi, %k0 # encoding: [0xc5,0xf8,0x92,0xc6]
; X64-NEXT:    #APP
; X64-NEXT:    #NO_APP
; X64-NEXT:    vpmovm2b %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x28,0xc0]
; X64-NEXT:    popq %rbx # encoding: [0x5b]
; X64-NEXT:    retq # encoding: [0xc3]
;
; X86-LABEL: test_pseudo_kmovw_spill:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx # encoding: [0x53]
; X86-NEXT:    pushl %edi # encoding: [0x57]
; X86-NEXT:    pushl %esi # encoding: [0x56]
; X86-NEXT:    #APP
; X86-NEXT:    #NO_APP
; X86-NEXT:    movw $3, %di # encoding: [0x66,0xbf,0x03,0x00]
; X86-NEXT:    # implicit-def: $esi
; X86-NEXT:    movw %di, %si # encoding: [0x66,0x89,0xfe]
; X86-NEXT:    kmovw %esi, %k0 # encoding: [0xc5,0xf8,0x92,0xc6]
; X86-NEXT:    #APP
; X86-NEXT:    #NO_APP
; X86-NEXT:    vpmovm2b %k0, %xmm0 # encoding: [0x62,0xf2,0x7e,0x08,0x28,0xc0]
; X86-NEXT:    popl %esi # encoding: [0x5e]
; X86-NEXT:    popl %edi # encoding: [0x5f]
; X86-NEXT:    popl %ebx # encoding: [0x5b]
; X86-NEXT:    retl # encoding: [0xc3]
  %1 = call { i32, i32, i32, i32 } asm sideeffect "", "={ax},={bx},={cx},={dx},~{dirflag},~{fpsr},~{flags}"()
  %2 = bitcast i16 3 to <16 x i1>
  %a = extractvalue { i32, i32, i32, i32 } %1, 0
  %b = extractvalue { i32, i32, i32, i32 } %1, 1
  %c = extractvalue { i32, i32, i32, i32 } %1, 2
  %d = extractvalue { i32, i32, i32, i32 } %1, 3
  call void asm sideeffect "", "{ax},{bx},{cx},{dx},~{dirflag},~{fpsr},~{flags}"(i32 %a, i32 %b, i32 %c, i32 %d)
  ret <16 x i1> %2
}
