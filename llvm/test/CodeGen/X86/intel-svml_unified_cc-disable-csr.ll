; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; Ensure that registers used for argument passing (RDI) is not a callee saved register.
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=avx512f | FileCheck %s

@v1 = global <16 x float> zeroinitializer, align 64
@v2 = global <16 x float> zeroinitializer, align 64

define svml_unified_cc_512 <16 x float> @__ocl_svml_z0_sincosf16_native(<16 x float> %a, <16 x float>* nocapture readnone %c) {
; CHECK-LABEL: __ocl_svml_z0_sincosf16_native:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vaddps (%rdi), %zmm0, %zmm0
; CHECK-NEXT:    movq v1@GOTPCREL(%rip), %rax
; CHECK-NEXT:    vmovaps %zmm0, (%rax)
; CHECK-NEXT:    #APP
; CHECK-EMPTY:
; CHECK-NEXT:    movq $255, %rdi
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    movq v2@GOTPCREL(%rip), %rax
; CHECK-NEXT:    vmovaps (%rax), %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = load <16 x float>, <16 x float>* %c, align 64
  %add = fadd fast <16 x float> %0, %a
  store <16 x float> %add, <16 x float>* @v1, align 64
  tail call void asm sideeffect inteldialect "mov rdi, $$255", "~{rdi},~{dirflag},~{fpsr},~{flags}"()
  %1 = load <16 x float>, <16 x float>* @v2, align 64
  ret <16 x float> %1
}

define void @caller_nopreserve_rdi(i8* %p, <16 x float> %v) {
; CHECK-LABEL: caller_nopreserve_rdi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    movq %rdi, %rsi
; CHECK-NEXT:    callq *__ocl_svml_z0_sincosf16_native@GOTPCREL(%rip)
; CHECK-NEXT:    movq %rsi, %rdi
; CHECK-NEXT:    movl $1, %esi
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jmp foo@PLT # TAILCALL
entry:
  %0 = bitcast i8* %p to <16 x float>*
  %call = tail call svml_unified_cc_512 <16 x float> @__ocl_svml_z0_sincosf16_native(<16 x float> %v, <16 x float>* %0)
  tail call void @foo(i8* %p, i32 1)
  ret void
}

define svml_unified_cc_512 <16 x float> @__ocl_svml_z0_sqrtf16_native(<16 x float> %a) {
; CHECK-LABEL: __ocl_svml_z0_sqrtf16_native:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rdi
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset %rdi, -16
; CHECK-NEXT:    movq v1@GOTPCREL(%rip), %rax
; CHECK-NEXT:    vmovaps (%rax), %zmm0
; CHECK-NEXT:    #APP
; CHECK-EMPTY:
; CHECK-NEXT:    movq $255, %rdi
; CHECK-EMPTY:
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    popq %rdi
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
entry:
  %0 = load <16 x float>, <16 x float>* @v1, align 64
  tail call void asm sideeffect inteldialect "mov rdi, $$255", "~{rdi},~{dirflag},~{fpsr},~{flags}"()
  ret <16 x float> %0
}

define void @caller_preserve_rdi(i8* %p) {
; CHECK-LABEL: caller_preserve_rdi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    vmovaps (%rdi), %zmm0
; CHECK-NEXT:    callq *__ocl_svml_z0_sqrtf16_native@GOTPCREL(%rip)
; CHECK-NEXT:    movl $1, %esi
; CHECK-NEXT:    popq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    jmp foo@PLT # TAILCALL
entry:
  %0 = bitcast i8* %p to <16 x float>*
  %1 = load <16 x float>, <16 x float>* %0, align 64
  %call = tail call svml_unified_cc_512 <16 x float> @__ocl_svml_z0_sqrtf16_native(<16 x float> %1)
  tail call void @foo(i8* %p, i32 1)
  ret void
}

declare void @foo(i8*, i32)
