; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_fp16
; RUN: llc < %s -mtriple=i386-linux-gnu -mattr=+avx512fp16 | FileCheck %s --check-prefixes=X86
; RUN: llc < %s -mtriple=x86_64-linux-gnu -mattr=+avx512fp16 | FileCheck %s --check-prefixes=X64

; Check soft floating point conversion function calls.

@vf16 = common global half 0.000000e+00, align 2
@vf128 = common global fp128 0xL00000000000000000000000000000000, align 16

define void @TestFPExtF16_F128() nounwind strictfp {
; X86-LABEL: TestFPExtF16_F128:
; X86:       # %bb.0: # %entry
; X86-NEXT:    subl $28, %esp
; X86-NEXT:    vmovsh vf16, %xmm0
; X86-NEXT:    vcvtsh2ss %xmm0, %xmm0, %xmm0
; X86-NEXT:    vmovss %xmm0, {{[0-9]+}}(%esp)
; X86-NEXT:    leal {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl %eax, (%esp)
; X86-NEXT:    calll __extendsftf2
; X86-NEXT:    subl $4, %esp
; X86-NEXT:    vmovups {{[0-9]+}}(%esp), %xmm0
; X86-NEXT:    vmovaps %xmm0, vf128
; X86-NEXT:    addl $28, %esp
; X86-NEXT:    retl
;
; X64-LABEL: TestFPExtF16_F128:
; X64:       # %bb.0: # %entry
; X64-NEXT:    pushq %rax
; X64-NEXT:    movq vf16@{{.*}}(%rip), %rax
; X64-NEXT:    vmovsh (%rax), %xmm0
; X64-NEXT:    callq __extendhftf2@PLT
; X64-NEXT:    movq vf128@{{.*}}(%rip), %rax
; X64-NEXT:    vmovaps %xmm0, (%rax)
; X64-NEXT:    popq %rax
; X64-NEXT:    retq
entry:
  %0 = load half, half* @vf16, align 2
  %conv = call fp128 @llvm.experimental.constrained.fpext.f128.f16(half %0, metadata !"fpexcept.strict") #0
  store fp128 %conv, fp128* @vf128, align 16
  ret void
}

define void @TestFPTruncF128_F16() nounwind strictfp {
; X86-LABEL: TestFPTruncF128_F16:
; X86:       # %bb.0: # %entry
; X86-NEXT:    subl $28, %esp
; X86-NEXT:    vmovaps vf128, %xmm0
; X86-NEXT:    vmovups %xmm0, (%esp)
; X86-NEXT:    calll __trunctfhf2
; X86-NEXT:    vmovsh %xmm0, vf16
; X86-NEXT:    addl $28, %esp
; X86-NEXT:    retl
;
; X64-LABEL: TestFPTruncF128_F16:
; X64:       # %bb.0: # %entry
; X64-NEXT:    pushq %rax
; X64-NEXT:    movq vf128@{{.*}}(%rip), %rax
; X64-NEXT:    vmovaps (%rax), %xmm0
; X64-NEXT:    callq __trunctfhf2@PLT
; X64-NEXT:    movq vf16@{{.*}}(%rip), %rax
; X64-NEXT:    vmovsh %xmm0, (%rax)
; X64-NEXT:    popq %rax
; X64-NEXT:    retq
entry:
  %0 = load fp128, fp128* @vf128, align 16
  %conv = call half @llvm.experimental.constrained.fptrunc.f16.f128(fp128 %0, metadata !"round.dynamic", metadata !"fpexcept.strict") #0
  store half %conv, half* @vf16, align 2
  ret void
}

declare half @llvm.experimental.constrained.fptrunc.f16.f128(fp128, metadata, metadata)
declare fp128 @llvm.experimental.constrained.fpext.f128.f16(half, metadata)
