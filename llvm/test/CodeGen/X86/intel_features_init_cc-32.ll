; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=sse2 | FileCheck %s
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=avx2 | FileCheck %s
; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=avx512f | FileCheck %s

%struct.FeatureDefType = type { i8*, i32, i8* }

@proc_info_features = internal unnamed_addr global [63 x %struct.FeatureDefType] zeroinitializer, align 4
@.str.1 = private unnamed_addr constant [13 x i8] c"GENERIC_IA32\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"X87\00", align 1
@__libirc_isa_info_initialized = internal unnamed_addr global i1 false, align 4

define intel_features_init_cc i32 @__intel_cpu_features_init_x() #0 {
; CHECK-LABEL: __intel_cpu_features_init_x:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    subl $12, %esp
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    calll __intel_cpu_features_init_body@PLT
; CHECK-NEXT:    addl $12, %esp
; CHECK-NEXT:    retl
entry:
  %call = tail call intel_features_init_cc i32 @__intel_cpu_features_init_body(i32 0) #0
  ret i32 %call
}

define intel_features_init_cc i32 @__intel_cpu_features_init() #0 {
; CHECK-LABEL: __intel_cpu_features_init:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    subl $12, %esp
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    calll __intel_cpu_features_init_body@PLT
; CHECK-NEXT:    addl $12, %esp
; CHECK-NEXT:    retl
entry:
  %call = tail call intel_features_init_cc i32 @__intel_cpu_features_init_body(i32 1)
  ret i32 %call
}

define intel_features_init_cc i32 @__libirc_get_feature_bitpos(i32 %feature_id) #0 {
; CHECK-LABEL: __libirc_get_feature_bitpos:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushl %ecx
; CHECK-NEXT:    subl $8, %esp
; CHECK-NEXT:    movl %eax, %ecx
; CHECK-NEXT:    cmpb $0, __libirc_isa_info_initialized
; CHECK-NEXT:    jne .LBB2_2
; CHECK-NEXT:  # %bb.1: # %land.lhs.true
; CHECK-NEXT:    calll __libirc_isa_init_once@PLT
; CHECK-NEXT:  .LBB2_2: # %if.end
; CHECK-NEXT:    leal (%ecx,%ecx,2), %eax
; CHECK-NEXT:    movl proc_info_features+4(,%eax,4), %ecx
; CHECK-NEXT:    leal -128(%ecx), %eax
; CHECK-NEXT:    cmpl $-129, %eax
; CHECK-NEXT:    movl $-3, %eax
; CHECK-NEXT:    cmovael %ecx, %eax
; CHECK-NEXT:    addl $8, %esp
; CHECK-NEXT:    popl %ecx
; CHECK-NEXT:    retl
entry:
  %.b = load i1, i1* @__libirc_isa_info_initialized, align 4
  br i1 %.b, label %if.end, label %land.lhs.true

land.lhs.true:
  tail call intel_features_init_cc void @__libirc_isa_init_once()
  br label %if.end

if.end:
  %bitpos2 = getelementptr inbounds [63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i32 0, i32 %feature_id, i32 1
  %0 = load i32, i32* %bitpos2, align 4
  %1 = add i32 %0, -128
  %2 = icmp ult i32 %1, -129
  %spec.select = select i1 %2, i32 -3, i32 %0
  ret i32 %spec.select
}

declare intel_features_init_cc i32 @__intel_cpu_features_init_body(i32 %vendor_check) #0

define intel_features_init_cc i32 @__libirc_set_cpu_feature(i64* noalias nocapture %features_ptr, i32 %feature) #0 {
; CHECK-LABEL: __libirc_set_cpu_feature:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushl %edx
; CHECK-NEXT:    pushl %edi
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    movl %eax, %edx
; CHECK-NEXT:    cmpb $0, __libirc_isa_info_initialized
; CHECK-NEXT:    jne .LBB3_2
; CHECK-NEXT:  # %bb.1: # %land.lhs.true.i
; CHECK-NEXT:    calll __libirc_isa_init_once@PLT
; CHECK-NEXT:  .LBB3_2: # %__libirc_get_feature_bitpos.exit
; CHECK-NEXT:    leal (%ecx,%ecx,2), %eax
; CHECK-NEXT:    movl proc_info_features+4(,%eax,4), %eax
; CHECK-NEXT:    leal -128(%eax), %ecx
; CHECK-NEXT:    cmpl $-129, %ecx
; CHECK-NEXT:    movl $-3, %ecx
; CHECK-NEXT:    cmovael %eax, %ecx
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    js .LBB3_4
; CHECK-NEXT:  # %bb.3: # %if.end
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:    xorl %edi, %edi
; CHECK-NEXT:    shldl %cl, %eax, %edi
; CHECK-NEXT:    shll %cl, %eax
; CHECK-NEXT:    testb $32, %cl
; CHECK-NEXT:    cmovnel %eax, %edi
; CHECK-NEXT:    cmovnel %esi, %eax
; CHECK-NEXT:    shrl $6, %ecx
; CHECK-NEXT:    orl %eax, (%edx,%ecx,8)
; CHECK-NEXT:    orl %edi, 4(%edx,%ecx,8)
; CHECK-NEXT:    xorl %ecx, %ecx
; CHECK-NEXT:  .LBB3_4: # %cleanup
; CHECK-NEXT:    movl %ecx, %eax
; CHECK-NEXT:    popl %esi
; CHECK-NEXT:    popl %edi
; CHECK-NEXT:    popl %edx
; CHECK-NEXT:    retl
entry:
  %.b.i = load i1, i1* @__libirc_isa_info_initialized, align 4
  br i1 %.b.i, label %__libirc_get_feature_bitpos.exit, label %land.lhs.true.i

land.lhs.true.i:
  tail call intel_features_init_cc void @__libirc_isa_init_once()
  br label %__libirc_get_feature_bitpos.exit

__libirc_get_feature_bitpos.exit:
  %bitpos2.i = getelementptr inbounds [63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i32 0, i32 %feature, i32 1
  %0 = load i32, i32* %bitpos2.i, align 4
  %1 = add i32 %0, -128
  %2 = icmp ult i32 %1, -129
  %spec.select.i = select i1 %2, i32 -3, i32 %0
  %cmp = icmp slt i32 %spec.select.i, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:
  %div = lshr i32 %spec.select.i, 6
  %sub = and i32 %spec.select.i, 63
  %sh_prom = zext i32 %sub to i64
  %shl = shl nuw i64 1, %sh_prom
  %arrayidx = getelementptr inbounds i64, i64* %features_ptr, i32 %div
  %3 = load i64, i64* %arrayidx, align 4
  %or = or i64 %3, %shl
  store i64 %or, i64* %arrayidx, align 4
  br label %cleanup

cleanup:
  %retval.0 = phi i32 [ 0, %if.end ], [ %spec.select.i, %__libirc_get_feature_bitpos.exit ]
  ret i32 %retval.0
}

define intel_features_init_cc void @__libirc_isa_init_once() #0 {
; CHECK-LABEL: __libirc_isa_init_once:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb $0, __libirc_isa_info_initialized
; CHECK-NEXT:    jne .LBB4_4
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    movl $-744, %eax # imm = 0xFD18
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB4_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl $-1, proc_info_features+760(%eax)
; CHECK-NEXT:    addl $12, %eax
; CHECK-NEXT:    jne .LBB4_2
; CHECK-NEXT:  # %bb.3: # %for.end
; CHECK-NEXT:    movl $.L.str.1, proc_info_features+12
; CHECK-NEXT:    movl $0, proc_info_features+16
; CHECK-NEXT:    movl $.L.str.2, proc_info_features+24
; CHECK-NEXT:    movl $1, proc_info_features+28
; CHECK-NEXT:    movb $1, __libirc_isa_info_initialized
; CHECK-NEXT:  .LBB4_4: # %cleanup
; CHECK-NEXT:    retl
entry:
  %.b = load i1, i1* @__libirc_isa_info_initialized, align 4
  br i1 %.b, label %cleanup, label %for.body

for.body:
  %i.01 = phi i32 [ %inc, %for.body ], [ 1, %entry ]
  %bitpos = getelementptr inbounds [63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i32 0, i32 %i.01, i32 1
  store i32 -1, i32* %bitpos, align 4
  %inc = add nuw nsw i32 %i.01, 1
  %exitcond.not = icmp eq i32 %inc, 63
  br i1 %exitcond.not, label %for.end, label %for.body

for.end:
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1, i32 0, i32 0), i8** getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i32 0, i32 1, i32 0), align 4
  store i32 0, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i32 0, i32 1, i32 1), align 4
  store i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i8** getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i32 0, i32 2, i32 0), align 4
  store i32 1, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i32 0, i32 2, i32 1), align 4
  store i1 true, i1* @__libirc_isa_info_initialized, align 4
  br label %cleanup

cleanup:
  ret void
}

attributes #0 = { nounwind }
