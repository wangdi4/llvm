; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O3 -disable-peephole -enable-intel-advanced-opts -verify-machineinstrs -mtriple=x86_64-unknown-unknown -mattr=+avx2 < %s | FileCheck %s

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@a = external dso_local local_unnamed_addr global [10240 x [10240 x i32]], align 16

; Function Attrs: mustprogress norecurse uwtable
define dso_local <2 x i32> @test_gather(i64 %offset) local_unnamed_addr {
; CHECK-LABEL: test_gather:
; CHECK:       # %bb.0: # %header
; CHECK-NEXT:    shlq $13, %rdi
; CHECK-NEXT:    vmovd {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vpinsrd $1, a+40960(%rdi,%rdi,4), %xmm0, %xmm0
; CHECK-NEXT:    retq
header:
  %.splatinsert55 = insertelement <2 x i64> poison, i64 0, i32 0
  %.splat56 = shufflevector <2 x i64> %.splatinsert55, <2 x i64> poison, <2 x i32> zeroinitializer
  %.splatinsert53 = insertelement <2 x i64> poison, i64 %offset, i32 0
  %.splat54 = shufflevector <2 x i64> %.splatinsert53, <2 x i64> poison, <2 x i32> zeroinitializer
  %0 = add <2 x i64> %.splat54, <i64 0, i64 1>
  %1 = getelementptr inbounds [10240 x [10240 x i32]], [10240 x [10240 x i32]]* @a, i64 0, <2 x i64> %0, <2 x i64> %.splat56
  %2 = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> %1, i32 4, <2 x i1> <i1 true, i1 true>, <2 x i32> undef)
  ret <2 x i32> %2
}

define dso_local void @test_scatter(i64 %offset, <2 x i32> %data) local_unnamed_addr {
; CHECK-LABEL: test_scatter:
; CHECK:       # %bb.0: # %header
; CHECK-NEXT:    shlq $13, %rdi
; CHECK-NEXT:    vmovss %xmm0, a(%rdi,%rdi,4)
; CHECK-NEXT:    vextractps $1, %xmm0, a-40960(%rdi,%rdi,4)
; CHECK-NEXT:    retq
header:
  %.splatinsert55 = insertelement <2 x i64> poison, i64 0, i32 0
  %.splat56 = shufflevector <2 x i64> %.splatinsert55, <2 x i64> poison, <2 x i32> zeroinitializer
  %.splatinsert53 = insertelement <2 x i64> poison, i64 %offset, i32 0
  %.splat54 = shufflevector <2 x i64> %.splatinsert53, <2 x i64> poison, <2 x i32> zeroinitializer
  %0 = sub <2 x i64> %.splat54, <i64 0, i64 1>
  %1 = getelementptr inbounds [10240 x [10240 x i32]], [10240 x [10240 x i32]]* @a, i64 0, <2 x i64> %0, <2 x i64> %.splat56
  call void @llvm.masked.scatter.v2i32.v2p0i32(<2 x i32> %data, <2 x i32*> %1, i32 4, <2 x i1> <i1 true, i1 true>)
  ret void
}

define double @test_gather_load(double* %src, <4 x i64>* %p) {
; CHECK-LABEL: test_gather_load:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq 16(%rsi), %rax
; CHECK-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %gepload
  %t10 = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
  %t38 = extractelement <4 x double> %t10, i64 2
  ret double %t38
}

define double @test_gather_sext(double* %src, <4 x i32>* %p) {
; CHECK-LABEL: test_gather_sext:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movslq 8(%rsi), %rax
; CHECK-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    retq
  %gepload = load <4 x i32>, <4 x i32>* %p, align 4
  %idx = sext <4 x i32> %gepload to <4 x i64>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %idx
  %t10 = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
  %t38 = extractelement <4 x double> %t10, i64 2
  ret double %t38
}

define double @test_gather_zext(double* %src, <4 x i32>* %p) {
; CHECK-LABEL: test_gather_zext:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl 8(%rsi), %eax
; CHECK-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    retq
  %gepload = load <4 x i32>, <4 x i32>* %p, align 4
  %idx = zext <4 x i32> %gepload to <4 x i64>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %idx
  %t10 = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
  %t38 = extractelement <4 x double> %t10, i64 2
  ret double %t38
}

define double @test_gather_shuffle(double* %src, <4 x i64>* %p) {
; CHECK-LABEL: test_gather_shuffle:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rsi), %rax
; CHECK-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %shuf = shufflevector <4 x i64> %gepload, <4 x i64> poison, <4 x i32> <i32 2, i32 0, i32 0, i32 1>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %shuf
  %t10 = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
  %t38 = extractelement <4 x double> %t10, i64 2
  ret double %t38
}

define double @test_gather_undef_shuffle(double* %src, <4 x i64>* %p) {
; CHECK-LABEL: test_gather_undef_shuffle:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rsi), %rax
; CHECK-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %shuf = shufflevector <4 x i64> %gepload, <4 x i64> poison, <4 x i32> <i32 2, i32 undef, i32 0, i32 1>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %shuf
  %t10 = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
  %t38 = extractelement <4 x double> %t10, i64 2
  ret double %t38
}

define double @test_gather_bc(float* %src, <4 x i64>* %p, <4 x double> %data) {
; CHECK-LABEL: test_gather_bc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq 16(%rsi), %rax
; CHECK-NEXT:    vmovsd {{.*#+}} xmm0 = mem[0],zero
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %flt_ptr = getelementptr inbounds float, float* %src, <4 x i64> %gepload
  %ptr = bitcast <4 x float*> %flt_ptr to <4 x double*>
  %t10 = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)
  %t38 = extractelement <4 x double> %t10, i64 2
  ret double %t38
}

define void @test_scatter_load(double* %src, <4 x i64>* %p, <4 x double> %data) {
; CHECK-LABEL: test_scatter_load:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rsi), %rax
; CHECK-NEXT:    movq 8(%rsi), %rcx
; CHECK-NEXT:    movq 16(%rsi), %rdx
; CHECK-NEXT:    movq 24(%rsi), %rsi
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rax,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rcx,8)
; CHECK-NEXT:    vextractf128 $1, %ymm0, %xmm0
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rdx,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rsi,8)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %gepload
  call void @llvm.masked.scatter.v4f64.v4p0f64(<4 x double> %data, <4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
  ret void
}

define void @test_scatter_sext(double* %src, <4 x i32>* %p, <4 x double> %data) {
; CHECK-LABEL: test_scatter_sext:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movslq (%rsi), %rax
; CHECK-NEXT:    movslq 4(%rsi), %rcx
; CHECK-NEXT:    movslq 8(%rsi), %rdx
; CHECK-NEXT:    movslq 12(%rsi), %rsi
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rax,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rcx,8)
; CHECK-NEXT:    vextractf128 $1, %ymm0, %xmm0
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rdx,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rsi,8)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %gepload = load <4 x i32>, <4 x i32>* %p, align 4
  %idx = sext <4 x i32> %gepload to <4 x i64>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %idx
  call void @llvm.masked.scatter.v4f64.v4p0f64(<4 x double> %data, <4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
  ret void
}

define void @test_scatter_zext(double* %src, <4 x i32>* %p, <4 x double> %data) {
; CHECK-LABEL: test_scatter_zext:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movl (%rsi), %eax
; CHECK-NEXT:    movl 4(%rsi), %ecx
; CHECK-NEXT:    movl 8(%rsi), %edx
; CHECK-NEXT:    movl 12(%rsi), %esi
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rax,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rcx,8)
; CHECK-NEXT:    vextractf128 $1, %ymm0, %xmm0
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rdx,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rsi,8)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %gepload = load <4 x i32>, <4 x i32>* %p, align 4
  %idx = zext <4 x i32> %gepload to <4 x i64>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %idx
  call void @llvm.masked.scatter.v4f64.v4p0f64(<4 x double> %data, <4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
  ret void
}

define void @test_scatter_shuffle(double* %src, <4 x i64>* %p, <4 x double> %data) {
; CHECK-LABEL: test_scatter_shuffle:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq 16(%rsi), %rax
; CHECK-NEXT:    movq (%rsi), %rcx
; CHECK-NEXT:    movq 8(%rsi), %rdx
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rax,8)
; CHECK-NEXT:    vextractf128 $1, %ymm0, %xmm0
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rcx,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rdx,8)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %shuf = shufflevector <4 x i64> %gepload, <4 x i64> poison, <4 x i32> <i32 2, i32 0, i32 0, i32 1>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %shuf
  call void @llvm.masked.scatter.v4f64.v4p0f64(<4 x double> %data, <4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
  ret void
}

define void @test_scatter_undef_shuffle(double* %src, <4 x i64>* %p, <4 x double> %data) {
; CHECK-LABEL: test_scatter_undef_shuffle:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rsi), %rax
; CHECK-NEXT:    movq 8(%rsi), %rcx
; CHECK-NEXT:    vmovlps %xmm0, (%rdi)
; CHECK-NEXT:    vextractf128 $1, %ymm0, %xmm0
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rax,8)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rcx,8)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %shuf = shufflevector <4 x i64> %gepload, <4 x i64> poison, <4 x i32> <i32 undef, i32 0, i32 0, i32 1>
  %ptr = getelementptr inbounds double, double* %src, <4 x i64> %shuf
  call void @llvm.masked.scatter.v4f64.v4p0f64(<4 x double> %data, <4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
  ret void
}

define void @test_scatter_bc(float* %src, <4 x i64>* %p, <4 x double> %data) {
; CHECK-LABEL: test_scatter_bc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movq (%rsi), %rax
; CHECK-NEXT:    movq 8(%rsi), %rcx
; CHECK-NEXT:    movq 16(%rsi), %rdx
; CHECK-NEXT:    movq 24(%rsi), %rsi
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rax,4)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rcx,4)
; CHECK-NEXT:    vextractf128 $1, %ymm0, %xmm0
; CHECK-NEXT:    vmovlps %xmm0, (%rdi,%rdx,4)
; CHECK-NEXT:    vmovhps %xmm0, (%rdi,%rsi,4)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %gepload = load <4 x i64>, <4 x i64>* %p, align 4
  %flt_ptr = getelementptr inbounds float, float* %src, <4 x i64> %gepload
  %ptr = bitcast <4 x float*> %flt_ptr to <4 x double*>
  call void @llvm.masked.scatter.v4f64.v4p0f64(<4 x double> %data, <4 x double*> %ptr, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>)
  ret void
}

; Function Attrs: nofree nosync nounwind readonly willreturn
declare <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*>, i32, <4 x i1>, <4 x double>)

declare void @llvm.masked.scatter.v4f64.v4p0f64(<4 x double>, <4 x double*>, i32, <4 x i1>)

; Function Attrs: nofree nosync nounwind readonly willreturn
declare <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*>, i32, <2 x i1>, <2 x i32>)

declare void @llvm.masked.scatter.v2i32.v2p0i32(<2 x i32>, <2 x i32*>, i32, <2 x i1>)

