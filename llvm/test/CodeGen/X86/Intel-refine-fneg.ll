; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=+avx2,fma | FileCheck %s

define dso_local void @compute(float* nocapture readonly %in, float* nocapture %out) local_unnamed_addr {
; CHECK-LABEL: compute:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovups (%rdi), %ymm0
; CHECK-NEXT:    vmovups 64(%rdi), %ymm1
; CHECK-NEXT:    vmovaps {{.*#+}} ymm2 = [1.0E+0,2.0E+0,3.0E+0,4.0E+0,3.0E+0,2.0E+0,1.0E+0,0.0E+0]
; CHECK-NEXT:    vmovaps %ymm2, %ymm3
; CHECK-NEXT:    vfmadd213ps {{.*#+}} ymm3 = (ymm0 * ymm3) + ymm1
; CHECK-NEXT:    vfnmadd213ps {{.*#+}} ymm0 = -(ymm2 * ymm0) + ymm1
; CHECK-NEXT:    vmovups %ymm3, (%rsi)
; CHECK-NEXT:    vmovups %ymm0, 64(%rsi)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %__v.i19 = bitcast float* %in to <8 x float>*
  %0 = load <8 x float>, <8 x float>* %__v.i19, align 1
  %add.ptr = getelementptr inbounds float, float* %in, i64 16
  %__v.i18 = bitcast float* %add.ptr to <8 x float>*
  %1 = load <8 x float>, <8 x float>* %__v.i18, align 1
  %2 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %0, <8 x float> <float 1.000000e+00, float 2.000000e+00, float 3.000000e+00, float 4.000000e+00, float 3.000000e+00, float 2.000000e+00, float 1.000000e+00, float 0.000000e+00>, <8 x float> %1)
  %fneg.i = fneg <8 x float> <float 1.000000e+00, float 2.000000e+00, float 3.000000e+00, float 4.000000e+00, float 3.000000e+00, float 2.000000e+00, float 1.000000e+00, float 0.000000e+00>
  %3 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %fneg.i, <8 x float> %0, <8 x float> %1)
  %__v.i17 = bitcast float* %out to <8 x float>*
  store <8 x float> %2, <8 x float>* %__v.i17, align 1
  %add.ptr5 = getelementptr inbounds float, float* %out, i64 16
  %__v.i16 = bitcast float* %add.ptr5 to <8 x float>*
  store <8 x float> %3, <8 x float>* %__v.i16, align 1
  ret void
}

declare <8 x float> @llvm.fma.v8f32(<8 x float>, <8 x float>, <8 x float>)
