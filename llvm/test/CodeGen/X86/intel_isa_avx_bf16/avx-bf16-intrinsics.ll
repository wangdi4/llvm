; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx_bf16
; RUN: llc < %s -mtriple=i686-unknown-unknown -mattr=+avxbf16 --show-mc-encoding | FileCheck %s --check-prefixes=CHECK,X86
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avxbf16 --show-mc-encoding | FileCheck %s --check-prefixes=CHECK,X64

declare <8 x i16> @llvm.x86.avx2bf16.cvtne2ps2bf16.128(<4 x float>, <4 x float>)

define <2 x i64> @test_mm_cvtne2ps2bf16_128(<4 x float> %A, <4 x float> %B) {
; CHECK-LABEL: test_mm_cvtne2ps2bf16_128:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    {vex} vcvtne2ps2bf16 %xmm1, %xmm0, %xmm0 # encoding: [0xc4,0xe2,0x7b,0x72,0xc1]
; CHECK-NEXT:    ret{{[l|q]}} # encoding: [0xc3]
entry:
  %0 = tail call <8 x i16> @llvm.x86.avx2bf16.cvtne2ps2bf16.128(<4 x float> %A, <4 x float> %B)
  %1 = bitcast <8 x i16> %0 to <2 x i64>
  ret <2 x i64> %1
}

declare <16 x i16> @llvm.x86.avx2bf16.cvtne2ps2bf16.256(<8 x float>, <8 x float>)

define <4 x i64> @test_mm256_cvtne2ps2bf16_256(<8 x float> %A, <8 x float> %B) {
; CHECK-LABEL: test_mm256_cvtne2ps2bf16_256:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    {vex} vcvtne2ps2bf16 %ymm1, %ymm0, %ymm0 # encoding: [0xc4,0xe2,0x7f,0x72,0xc1]
; CHECK-NEXT:    ret{{[l|q]}} # encoding: [0xc3]
entry:
  %0 = tail call <16 x i16> @llvm.x86.avx2bf16.cvtne2ps2bf16.256(<8 x float> %A, <8 x float> %B)
  %1 = bitcast <16 x i16> %0 to <4 x i64>
  ret <4 x i64> %1
}

declare <8 x i16> @llvm.x86.avx2bf16.cvtneps2bf16.128(<4 x float>)

define <2 x i64> @test_mm_cvtneps2bf16_128(<4 x float> %A) {
; CHECK-LABEL: test_mm_cvtneps2bf16_128:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    {vex} vcvtneps2bf16 %xmm0, %xmm0 # encoding: [0xc4,0xe2,0x7a,0x72,0xc0]
; CHECK-NEXT:    ret{{[l|q]}} # encoding: [0xc3]
entry:
  %0 = tail call <8 x i16> @llvm.x86.avx2bf16.cvtneps2bf16.128(<4 x float> %A)
  %1 = bitcast <8 x i16> %0 to <2 x i64>
  ret <2 x i64> %1
}

declare <8 x i16> @llvm.x86.avx2bf16.cvtneps2bf16.256(<8 x float>)

define <2 x i64> @test_mm256_cvtneps2bf16_256(<8 x float> %A) {
; CHECK-LABEL: test_mm256_cvtneps2bf16_256:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    {vex} vcvtneps2bf16 %ymm0, %xmm0 # encoding: [0xc4,0xe2,0x7e,0x72,0xc0]
; CHECK-NEXT:    vzeroupper # encoding: [0xc5,0xf8,0x77]
; CHECK-NEXT:    ret{{[l|q]}} # encoding: [0xc3]
entry:
  %0 = tail call <8 x i16> @llvm.x86.avx2bf16.cvtneps2bf16.256(<8 x float> %A)
  %1 = bitcast <8 x i16> %0 to <2 x i64>
  ret <2 x i64> %1
}

declare <4 x float> @llvm.x86.avx2bf16.dpbf16ps.128(<4 x float>, <4 x i32>, <4 x i32>)

define <4 x float> @test_mm_dpbf16ps_128(<4 x float> %E, <4 x i32> %A, <4 x i32> %B) {
; CHECK-LABEL: test_mm_dpbf16ps_128:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    {vex} vdpbf16ps %xmm2, %xmm1, %xmm0 # encoding: [0xc4,0xe2,0x72,0x52,0xc2]
; CHECK-NEXT:    ret{{[l|q]}} # encoding: [0xc3]
entry:
  %0 = tail call <4 x float> @llvm.x86.avx2bf16.dpbf16ps.128(<4 x float> %E, <4 x i32> %A, <4x i32> %B)
  ret <4 x float> %0
}

declare <8 x float> @llvm.x86.avx2bf16.dpbf16ps.256(<8 x float>, <8 x i32>, <8 x i32>)

define <8 x float> @test_mm256_dpbf16ps_256(<8 x float> %E, <8 x i32> %A, <8 x i32> %B) {
; CHECK-LABEL: test_mm256_dpbf16ps_256:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    {vex} vdpbf16ps %ymm2, %ymm1, %ymm0 # encoding: [0xc4,0xe2,0x76,0x52,0xc2]
; CHECK-NEXT:    ret{{[l|q]}} # encoding: [0xc3]
entry:
  %0 = tail call <8 x float> @llvm.x86.avx2bf16.dpbf16ps.256(<8 x float> %E, <8 x i32> %A, <8 x i32> %B)
  ret <8 x float> %0
}
