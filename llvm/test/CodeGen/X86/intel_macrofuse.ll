; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -lsr-loop-depth-limit=0 -cgp-icmp-CmpLeaJcc2IncCmpJcc=false -mcpu=skylake -O3 | FileCheck %s --check-prefix=X64-NO
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -lsr-loop-depth-limit=0 -mcpu=skylake -O3 | FileCheck %s --check-prefix=X64

; comlex0_inc_eq could do transformation.
define dso_local noundef i64 @comlex0_inc_eq(i1 %cmp, i32 %lddata) local_unnamed_addr{
; X64-NO-LABEL: comlex0_inc_eq:
; X64-NO:       # %bb.0: # %entry
; X64-NO-NEXT:    testb $1, %dil
; X64-NO-NEXT:    movl $1, %eax
; X64-NO-NEXT:    cmovel %esi, %eax
; X64-NO-NEXT:    movl $9, %edx
; X64-NO-NEXT:    cmovel %esi, %edx
; X64-NO-NEXT:    movslq %eax, %rcx
; X64-NO-NEXT:    movslq %edx, %rax
; X64-NO-NEXT:    .p2align 4, 0x90
; X64-NO-NEXT:  .LBB0_1: # %loop2
; X64-NO-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NO-NEXT:    leaq 1(%rcx), %rdx
; X64-NO-NEXT:    cmpq %rax, %rcx
; X64-NO-NEXT:    movq %rdx, %rcx
; X64-NO-NEXT:    jne .LBB0_1
; X64-NO-NEXT:  # %bb.2: # %exit
; X64-NO-NEXT:    xorl %eax, %eax
; X64-NO-NEXT:    retq
;
; X64-LABEL: comlex0_inc_eq:
; X64:       # %bb.0: # %entry
; X64-NEXT:    testb $1, %dil
; X64-NEXT:    movl $1, %eax
; X64-NEXT:    cmovel %esi, %eax
; X64-NEXT:    movl $9, %ecx
; X64-NEXT:    cmovel %esi, %ecx
; X64-NEXT:    cltq
; X64-NEXT:    movslq %ecx, %rcx
; X64-NEXT:    .p2align 4, 0x90
; X64-NEXT:  .LBB0_1: # %loop1
; X64-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NEXT:    incq %rax
; X64-NEXT:    cmpq %rcx, %rax
; X64-NEXT:    jle .LBB0_1
; X64-NEXT:  # %bb.2: # %exit
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
entry:
  %sel1 = select i1 %cmp, i32 1, i32 %lddata
  %sel9 = select i1 %cmp, i32 9, i32 %lddata
  %sel1.ext = sext i32 %sel1 to i64
  %sel9.ext = sext i32 %sel9 to i64
  br label %loop1
loop1:
  %phi1 = phi i64 [ %sel1.ext, %entry ], [ %inc, %loop2 ]
  br label %loop2
loop2:
  %inc = add nsw i64 %phi1, 1
  %icmp = icmp eq i64 %phi1, %sel9.ext
  br i1 %icmp, label %exit, label %loop1
exit:
  ret i64 0
}

; Compare with comlex0_inc_eq, comlex0_inc_noeq_var's two variables are not equal, so transformation could not do.
define dso_local noundef i64 @comlex0_inc_noeq_var(i1 %cmp, i32 %lddata0, i32 %lddata1) local_unnamed_addr{
; X64-NO-LABEL: comlex0_inc_noeq_var:
; X64-NO:       # %bb.0: # %entry
; X64-NO-NEXT:    testb $1, %dil
; X64-NO-NEXT:    movl $1, %eax
; X64-NO-NEXT:    cmovel %esi, %eax
; X64-NO-NEXT:    movl $9, %esi
; X64-NO-NEXT:    cmovel %edx, %esi
; X64-NO-NEXT:    movslq %eax, %rcx
; X64-NO-NEXT:    movslq %esi, %rax
; X64-NO-NEXT:    .p2align 4, 0x90
; X64-NO-NEXT:  .LBB1_1: # %loop2
; X64-NO-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NO-NEXT:    leaq 1(%rcx), %rdx
; X64-NO-NEXT:    cmpq %rax, %rcx
; X64-NO-NEXT:    movq %rdx, %rcx
; X64-NO-NEXT:    jne .LBB1_1
; X64-NO-NEXT:  # %bb.2: # %exit
; X64-NO-NEXT:    xorl %eax, %eax
; X64-NO-NEXT:    retq
;
; X64-LABEL: comlex0_inc_noeq_var:
; X64:       # %bb.0: # %entry
; X64-NEXT:    testb $1, %dil
; X64-NEXT:    movl $1, %eax
; X64-NEXT:    cmovel %esi, %eax
; X64-NEXT:    movl $9, %esi
; X64-NEXT:    cmovel %edx, %esi
; X64-NEXT:    movslq %eax, %rcx
; X64-NEXT:    movslq %esi, %rax
; X64-NEXT:    .p2align 4, 0x90
; X64-NEXT:  .LBB1_1: # %loop2
; X64-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NEXT:    leaq 1(%rcx), %rdx
; X64-NEXT:    cmpq %rax, %rcx
; X64-NEXT:    movq %rdx, %rcx
; X64-NEXT:    jne .LBB1_1
; X64-NEXT:  # %bb.2: # %exit
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
entry:
  %sel1 = select i1 %cmp, i32 1, i32 %lddata0
  %sel9 = select i1 %cmp, i32 9, i32 %lddata1
  %sel1.ext = sext i32 %sel1 to i64
  %sel9.ext = sext i32 %sel9 to i64
  br label %loop1
loop1:
  %phi1 = phi i64 [ %sel1.ext, %entry ], [ %inc, %loop2 ]
  br label %loop2
loop2:
  %inc = add nsw i64 %phi1, 1
  %icmp = icmp eq i64 %phi1, %sel9.ext
  br i1 %icmp, label %exit, label %loop1
exit:
  ret i64 0
}

; comlex1_inc_eq could work.
define dso_local noundef i64 @comlex1_inc_eq(<64 x i32> %lddata) local_unnamed_addr{
; X64-NO-LABEL: comlex1_inc_eq:
; X64-NO:       # %bb.0: # %entry
; X64-NO-NEXT:    vextracti128 $1, %ymm7, %xmm0
; X64-NO-NEXT:    vpextrd $3, %xmm0, %eax
; X64-NO-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; X64-NO-NEXT:    vpcmpeqd %xmm1, %xmm0, %xmm0
; X64-NO-NEXT:    vpcmpeqd %xmm1, %xmm1, %xmm1
; X64-NO-NEXT:    vpxor %xmm1, %xmm0, %xmm0
; X64-NO-NEXT:    vpextrb $15, %xmm0, %ecx
; X64-NO-NEXT:    movslq %eax, %rdx
; X64-NO-NEXT:    testb $1, %cl
; X64-NO-NEXT:    movl $1, %eax
; X64-NO-NEXT:    cmovneq %rdx, %rax
; X64-NO-NEXT:    movl $9, %ecx
; X64-NO-NEXT:    cmovneq %rdx, %rcx
; X64-NO-NEXT:    .p2align 4, 0x90
; X64-NO-NEXT:  .LBB2_1: # %for.loop
; X64-NO-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NO-NEXT:    movq %rax, %rdx
; X64-NO-NEXT:    incq %rax
; X64-NO-NEXT:    cmpq %rcx, %rdx
; X64-NO-NEXT:    jne .LBB2_1
; X64-NO-NEXT:  # %bb.2: # %for.ret
; X64-NO-NEXT:    vzeroupper
; X64-NO-NEXT:    retq
;
; X64-LABEL: comlex1_inc_eq:
; X64:       # %bb.0: # %entry
; X64-NEXT:    vextracti128 $1, %ymm7, %xmm0
; X64-NEXT:    vpextrd $3, %xmm0, %eax
; X64-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; X64-NEXT:    vpcmpeqd %xmm1, %xmm0, %xmm0
; X64-NEXT:    vpcmpeqd %xmm1, %xmm1, %xmm1
; X64-NEXT:    vpxor %xmm1, %xmm0, %xmm0
; X64-NEXT:    vpextrb $15, %xmm0, %ecx
; X64-NEXT:    movslq %eax, %rdx
; X64-NEXT:    testb $1, %cl
; X64-NEXT:    movl $1, %eax
; X64-NEXT:    cmovneq %rdx, %rax
; X64-NEXT:    movl $9, %ecx
; X64-NEXT:    cmovneq %rdx, %rcx
; X64-NEXT:    .p2align 4, 0x90
; X64-NEXT:  .LBB2_1: # %for.loop
; X64-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NEXT:    incq %rax
; X64-NEXT:    cmpq %rcx, %rax
; X64-NEXT:    jle .LBB2_1
; X64-NEXT:  # %bb.2: # %for.ret
; X64-NEXT:    vzeroupper
; X64-NEXT:    retq
entry:
  %cmp_ne = icmp ne <64 x i32> %lddata, zeroinitializer
  %lddata_63 = extractelement <64 x i32> %lddata, i64 63
  %lddata_63_i64_0 = sext i32 %lddata_63 to i64
  %lddata_63_i64_1 = sext i32 %lddata_63 to i64
  %cmp_ne_63 = extractelement <64 x i1> %cmp_ne, i64 63
  %lddata_63_i64_or_1 = select i1 %cmp_ne_63, i64 %lddata_63_i64_0, i64 1
  %lddata_63_i64_or_9 = select i1 %cmp_ne_63, i64 %lddata_63_i64_1, i64 9
  br label %for.loop

for.loop:
  %lddata_63_i64_or_1_phy = phi i64 [ %lddata_63_i64_or_1, %entry ], [ %inc, %for.loop ]
  %inc = add nsw i64 %lddata_63_i64_or_1_phy, 1
  %cmp_eq = icmp eq i64 %lddata_63_i64_or_1_phy, %lddata_63_i64_or_9
  br i1 %cmp_eq, label %for.ret, label %for.loop

for.ret:
  ret i64 %inc
}

; Compare with comlex1_inc_eq, comlex1_inc_noeq_const's two const variables are not large or equal, so transformation could not do.
define dso_local noundef i64 @comlex1_inc_noeq_const(<64 x i32> %lddata) local_unnamed_addr{
; X64-NO-LABEL: comlex1_inc_noeq_const:
; X64-NO:       # %bb.0: # %entry
; X64-NO-NEXT:    vextracti128 $1, %ymm7, %xmm0
; X64-NO-NEXT:    vpextrd $3, %xmm0, %eax
; X64-NO-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; X64-NO-NEXT:    vpcmpeqd %xmm1, %xmm0, %xmm0
; X64-NO-NEXT:    vpcmpeqd %xmm1, %xmm1, %xmm1
; X64-NO-NEXT:    vpxor %xmm1, %xmm0, %xmm0
; X64-NO-NEXT:    vpextrb $15, %xmm0, %ecx
; X64-NO-NEXT:    movslq %eax, %rdx
; X64-NO-NEXT:    testb $1, %cl
; X64-NO-NEXT:    movl $10, %eax
; X64-NO-NEXT:    cmovneq %rdx, %rax
; X64-NO-NEXT:    movl $9, %ecx
; X64-NO-NEXT:    cmovneq %rdx, %rcx
; X64-NO-NEXT:    .p2align 4, 0x90
; X64-NO-NEXT:  .LBB3_1: # %for.loop
; X64-NO-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NO-NEXT:    movq %rax, %rdx
; X64-NO-NEXT:    incq %rax
; X64-NO-NEXT:    cmpq %rcx, %rdx
; X64-NO-NEXT:    jne .LBB3_1
; X64-NO-NEXT:  # %bb.2: # %for.ret
; X64-NO-NEXT:    vzeroupper
; X64-NO-NEXT:    retq
;
; X64-LABEL: comlex1_inc_noeq_const:
; X64:       # %bb.0: # %entry
; X64-NEXT:    vextracti128 $1, %ymm7, %xmm0
; X64-NEXT:    vpextrd $3, %xmm0, %eax
; X64-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; X64-NEXT:    vpcmpeqd %xmm1, %xmm0, %xmm0
; X64-NEXT:    vpcmpeqd %xmm1, %xmm1, %xmm1
; X64-NEXT:    vpxor %xmm1, %xmm0, %xmm0
; X64-NEXT:    vpextrb $15, %xmm0, %ecx
; X64-NEXT:    movslq %eax, %rdx
; X64-NEXT:    testb $1, %cl
; X64-NEXT:    movl $10, %eax
; X64-NEXT:    cmovneq %rdx, %rax
; X64-NEXT:    movl $9, %ecx
; X64-NEXT:    cmovneq %rdx, %rcx
; X64-NEXT:    .p2align 4, 0x90
; X64-NEXT:  .LBB3_1: # %for.loop
; X64-NEXT:    # =>This Inner Loop Header: Depth=1
; X64-NEXT:    movq %rax, %rdx
; X64-NEXT:    incq %rax
; X64-NEXT:    cmpq %rcx, %rdx
; X64-NEXT:    jne .LBB3_1
; X64-NEXT:  # %bb.2: # %for.ret
; X64-NEXT:    vzeroupper
; X64-NEXT:    retq
entry:
  %cmp_ne = icmp ne <64 x i32> %lddata, zeroinitializer
  %lddata_63 = extractelement <64 x i32> %lddata, i64 63
  %lddata_63_i64_0 = sext i32 %lddata_63 to i64
  %lddata_63_i64_1 = sext i32 %lddata_63 to i64
  %cmp_ne_63 = extractelement <64 x i1> %cmp_ne, i64 63
  %lddata_63_i64_or_1 = select i1 %cmp_ne_63, i64 %lddata_63_i64_0, i64 10
  %lddata_63_i64_or_9 = select i1 %cmp_ne_63, i64 %lddata_63_i64_1, i64 9
  br label %for.loop

for.loop:
  %lddata_63_i64_or_1_phy = phi i64 [ %lddata_63_i64_or_1, %entry ], [ %inc, %for.loop ]
  %inc = add nsw i64 %lddata_63_i64_or_1_phy, 1
  %cmp_eq = icmp eq i64 %lddata_63_i64_or_1_phy, %lddata_63_i64_or_9
  br i1 %cmp_eq, label %for.ret, label %for.loop

for.ret:
  ret i64 %inc
}

; comlex2_inc_eq could do the transformation.
define dso_local noundef i64 @comlex2_inc_eq(i32 %lddata, i64 %alloca0, ptr %addr) local_unnamed_addr{
; X64-NO-LABEL: comlex2_inc_eq:
; X64-NO:       # %bb.0: # %entry
; X64-NO-NEXT:    movl $1, %ecx
; X64-NO-NEXT:    testl %edi, %edi
; X64-NO-NEXT:    cmovnel %edi, %ecx
; X64-NO-NEXT:    movl $9, %eax
; X64-NO-NEXT:    cmovnel %edi, %eax
; X64-NO-NEXT:    cltq
; X64-NO-NEXT:    jne .LBB4_3
; X64-NO-NEXT:  # %bb.1:
; X64-NO-NEXT:    movslq %ecx, %rsi
; X64-NO-NEXT:  .LBB4_2: # %for.loop1
; X64-NO-NEXT:    cmpl $0, 212(%rdx,%rsi,4)
; X64-NO-NEXT:    jg .LBB4_4
; X64-NO-NEXT:  .LBB4_3: # %for.loop2
; X64-NO-NEXT:    leaq 1(%rsi), %rcx
; X64-NO-NEXT:    cmpq %rax, %rsi
; X64-NO-NEXT:    movq %rcx, %rsi
; X64-NO-NEXT:    jne .LBB4_2
; X64-NO-NEXT:  .LBB4_4: # %exit
; X64-NO-NEXT:    xorl %eax, %eax
; X64-NO-NEXT:    retq
;
; X64-LABEL: comlex2_inc_eq:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movl $1, %ecx
; X64-NEXT:    testl %edi, %edi
; X64-NEXT:    cmovnel %edi, %ecx
; X64-NEXT:    movl $9, %eax
; X64-NEXT:    cmovnel %edi, %eax
; X64-NEXT:    cltq
; X64-NEXT:    jne .LBB4_3
; X64-NEXT:  # %bb.1:
; X64-NEXT:    movslq %ecx, %rsi
; X64-NEXT:  .LBB4_2: # %for.loop1
; X64-NEXT:    cmpl $0, 212(%rdx,%rsi,4)
; X64-NEXT:    jg .LBB4_4
; X64-NEXT:  .LBB4_3: # %for.loop2
; X64-NEXT:    incq %rsi
; X64-NEXT:    cmpq %rax, %rsi
; X64-NEXT:    jle .LBB4_2
; X64-NEXT:  .LBB4_4: # %exit
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
entry:
  %cmp.eq0 = icmp eq i32 %lddata, 0
  %lddata.sel1 = select i1 %cmp.eq0, i32 1, i32 %lddata
  %lddata.sel9 = select i1 %cmp.eq0, i32 9, i32 %lddata
  %lddata.sel1.xt = sext i32 %lddata.sel1 to i64
  %lddata.sel9.xt = sext i32 %lddata.sel9 to i64
  br i1 %cmp.eq0, label %for.loop1, label %for.loop2

for.loop1:                                             ; preds = %4641, %6181
  %phi.1 = phi i64 [ %lddata.sel1.xt, %entry ], [ %inc, %for.loop2 ]
  %dec = add nsw i64 %phi.1, -1
  %addr.dec = getelementptr inbounds i32, ptr %addr, i64 %dec
  %addr.dec.54 = getelementptr inbounds i32, ptr %addr.dec, i64 54
  %ld = load i32, ptr %addr.dec.54, align 4
  %ld.cmp.1 = icmp slt i32 %ld, 1
  br i1 %ld.cmp.1, label %for.loop2, label %exit
for.loop2:                                            ; preds = %11139, %1474
  %phi.2 = phi i64 [ %alloca0, %entry ], [ %phi.1, %for.loop1 ]
  %inc = add nsw i64 %phi.2, 1
  %phi2.cmp = icmp eq i64 %phi.2, %lddata.sel9.xt
  br i1 %phi2.cmp, label %exit, label %for.loop1
exit:
  ret i64 0
}

; Compare with comlex2_inc_eq, comlex2_noinc_eq is not Inc, so transformation could not do.
define dso_local noundef i64 @comlex2_noinc_eq(i32 %lddata, i64 %alloca0, ptr %addr) local_unnamed_addr{
; X64-NO-LABEL: comlex2_noinc_eq:
; X64-NO:       # %bb.0: # %entry
; X64-NO-NEXT:    movl $1, %ecx
; X64-NO-NEXT:    testl %edi, %edi
; X64-NO-NEXT:    cmovnel %edi, %ecx
; X64-NO-NEXT:    movl $9, %eax
; X64-NO-NEXT:    cmovnel %edi, %eax
; X64-NO-NEXT:    cltq
; X64-NO-NEXT:    jne .LBB5_3
; X64-NO-NEXT:  # %bb.1:
; X64-NO-NEXT:    movslq %ecx, %rsi
; X64-NO-NEXT:  .LBB5_2: # %for.loop1
; X64-NO-NEXT:    cmpl $0, 212(%rdx,%rsi,4)
; X64-NO-NEXT:    jg .LBB5_4
; X64-NO-NEXT:  .LBB5_3: # %for.loop2
; X64-NO-NEXT:    leaq 2(%rsi), %rcx
; X64-NO-NEXT:    cmpq %rax, %rsi
; X64-NO-NEXT:    movq %rcx, %rsi
; X64-NO-NEXT:    jne .LBB5_2
; X64-NO-NEXT:  .LBB5_4: # %exit
; X64-NO-NEXT:    xorl %eax, %eax
; X64-NO-NEXT:    retq
;
; X64-LABEL: comlex2_noinc_eq:
; X64:       # %bb.0: # %entry
; X64-NEXT:    movl $1, %ecx
; X64-NEXT:    testl %edi, %edi
; X64-NEXT:    cmovnel %edi, %ecx
; X64-NEXT:    movl $9, %eax
; X64-NEXT:    cmovnel %edi, %eax
; X64-NEXT:    cltq
; X64-NEXT:    jne .LBB5_3
; X64-NEXT:  # %bb.1:
; X64-NEXT:    movslq %ecx, %rsi
; X64-NEXT:  .LBB5_2: # %for.loop1
; X64-NEXT:    cmpl $0, 212(%rdx,%rsi,4)
; X64-NEXT:    jg .LBB5_4
; X64-NEXT:  .LBB5_3: # %for.loop2
; X64-NEXT:    leaq 2(%rsi), %rcx
; X64-NEXT:    cmpq %rax, %rsi
; X64-NEXT:    movq %rcx, %rsi
; X64-NEXT:    jne .LBB5_2
; X64-NEXT:  .LBB5_4: # %exit
; X64-NEXT:    xorl %eax, %eax
; X64-NEXT:    retq
entry:
  %cmp.eq0 = icmp eq i32 %lddata, 0
  %lddata.sel1 = select i1 %cmp.eq0, i32 1, i32 %lddata
  %lddata.sel9 = select i1 %cmp.eq0, i32 9, i32 %lddata
  %lddata.sel1.xt = sext i32 %lddata.sel1 to i64
  %lddata.sel9.xt = sext i32 %lddata.sel9 to i64
  br i1 %cmp.eq0, label %for.loop1, label %for.loop2

for.loop1:                                             ; preds = %4641, %6181
  %phi.1 = phi i64 [ %lddata.sel1.xt, %entry ], [ %inc, %for.loop2 ]
  %dec = add nsw i64 %phi.1, -1
  %addr.dec = getelementptr inbounds i32, ptr %addr, i64 %dec
  %addr.dec.54 = getelementptr inbounds i32, ptr %addr.dec, i64 54
  %ld = load i32, ptr %addr.dec.54, align 4
  %ld.cmp.1 = icmp slt i32 %ld, 1
  br i1 %ld.cmp.1, label %for.loop2, label %exit
for.loop2:                                            ; preds = %11139, %1474
  %phi.2 = phi i64 [ %alloca0, %entry ], [ %phi.1, %for.loop1 ]
  %inc = add nsw i64 %phi.2, 2
  %phi2.cmp = icmp eq i64 %phi.2, %lddata.sel9.xt
  br i1 %phi2.cmp, label %exit, label %for.loop1
exit:
  ret i64 0
}
