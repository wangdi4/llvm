; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx_compress
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avxcompress -verify-machineinstrs --show-mc-encoding | FileCheck %s --check-prefixes=CHECK

define <2 x i64> @testv2i64(<2 x i64> %in) nounwind {
; CHECK-LABEL: testv2i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntq %xmm0, %xmm0 # encoding: [0xc4,0xe2,0xf9,0x55,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <2 x i64> @llvm.ctpop.v2i64(<2 x i64> %in)
  ret <2 x i64> %out
}

define <4 x i32> @testv4i32(<4 x i32> %in) nounwind {
; CHECK-LABEL: testv4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntd %xmm0, %xmm0 # encoding: [0xc4,0xe2,0x79,0x55,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <4 x i32> @llvm.ctpop.v4i32(<4 x i32> %in)
  ret <4 x i32> %out
}

define <8 x i16> @testv8i16(<8 x i16> %in) nounwind {
; CHECK-LABEL: testv8i16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntw %xmm0, %xmm0 # encoding: [0xc4,0xe2,0xf9,0x54,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <8 x i16> @llvm.ctpop.v8i16(<8 x i16> %in)
  ret <8 x i16> %out
}

define <16 x i8> @testv16i8(<16 x i8> %in) nounwind {
; CHECK-LABEL: testv16i8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntb %xmm0, %xmm0 # encoding: [0xc4,0xe2,0x79,0x54,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <16 x i8> @llvm.ctpop.v16i8(<16 x i8> %in)
  ret <16 x i8> %out
}

define <4 x i64> @testv4i64(<4 x i64> %in) nounwind {
; CHECK-LABEL: testv4i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntq %ymm0, %ymm0 # encoding: [0xc4,0xe2,0xfd,0x55,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <4 x i64> @llvm.ctpop.v4i64(<4 x i64> %in)
  ret <4 x i64> %out
}

define <8 x i32> @testv8i32(<8 x i32> %in) nounwind {
; CHECK-LABEL: testv8i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntd %ymm0, %ymm0 # encoding: [0xc4,0xe2,0x7d,0x55,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <8 x i32> @llvm.ctpop.v8i32(<8 x i32> %in)
  ret <8 x i32> %out
}

define <16 x i16> @testv16i16(<16 x i16> %in) nounwind {
; CHECK-LABEL: testv16i16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntw %ymm0, %ymm0 # encoding: [0xc4,0xe2,0xfd,0x54,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <16 x i16> @llvm.ctpop.v16i16(<16 x i16> %in)
  ret <16 x i16> %out
}

define <32 x i8> @testv32i8(<32 x i8> %in) nounwind {
; CHECK-LABEL: testv32i8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpopcntb %ymm0, %ymm0 # encoding: [0xc4,0xe2,0x7d,0x54,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %out = call <32 x i8> @llvm.ctpop.v32i8(<32 x i8> %in)
  ret <32 x i8> %out
}

declare <2 x i64> @llvm.ctpop.v2i64(<2 x i64>)
declare <4 x i32> @llvm.ctpop.v4i32(<4 x i32>)
declare <8 x i16> @llvm.ctpop.v8i16(<8 x i16>)
declare <16 x i8> @llvm.ctpop.v16i8(<16 x i8>)
declare <4 x i64> @llvm.ctpop.v4i64(<4 x i64>)
declare <8 x i32> @llvm.ctpop.v8i32(<8 x i32>)
declare <16 x i16> @llvm.ctpop.v16i16(<16 x i16>)
declare <32 x i8> @llvm.ctpop.v32i8(<32 x i8>)
