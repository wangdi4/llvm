; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_avx_compress
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+avxcompress -verify-machineinstrs --show-mc-encoding | FileCheck %s --check-prefixes=CHECK

declare <2 x i64> @llvm.fshl.v2i64(<2 x i64>, <2 x i64>, <2 x i64>)
declare <4 x i32> @llvm.fshl.v4i32(<4 x i32>, <4 x i32>, <4 x i32>)


define <2 x i64> @var_funnnel_v2i64(<2 x i64> %x, <2 x i64> %amt) nounwind {
; CHECK-LABEL: var_funnnel_v2i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    {vex} vprolvq %xmm1, %xmm0, %xmm0 # encoding: [0xc4,0xe2,0xf9,0x15,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %res = call <2 x i64> @llvm.fshl.v2i64(<2 x i64> %x, <2 x i64> %x, <2 x i64> %amt)
  ret <2 x i64> %res
}

define <4 x i32> @var_funnnel_v4i32(<4 x i32> %x, <4 x i32> %amt) nounwind {
; CHECK-LABEL: var_funnnel_v4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    {vex} vprolvd %xmm1, %xmm0, %xmm0 # encoding: [0xc4,0xe2,0x79,0x15,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %res = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %x, <4 x i32> %x, <4 x i32> %amt)
  ret <4 x i32> %res
}

define <2 x i64> @splatvar_funnnel_v2i64(<2 x i64> %x, <2 x i64> %amt) nounwind {
; CHECK-LABEL: splatvar_funnnel_v2i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpbroadcastq %xmm1, %xmm1 # encoding: [0xc4,0xe2,0x79,0x59,0xc9]
; CHECK-NEXT:    {vex} vprolvq %xmm1, %xmm0, %xmm0 # encoding: [0xc4,0xe2,0xf9,0x15,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %splat = shufflevector <2 x i64> %amt, <2 x i64> undef, <2 x i32> zeroinitializer
  %res = call <2 x i64> @llvm.fshl.v2i64(<2 x i64> %x, <2 x i64> %x, <2 x i64> %splat)
  ret <2 x i64> %res
}

define <4 x i32> @splatvar_funnnel_v4i32(<4 x i32> %x, <4 x i32> %amt) nounwind {
; CHECK-LABEL: splatvar_funnnel_v4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vpbroadcastd %xmm1, %xmm1 # encoding: [0xc4,0xe2,0x79,0x58,0xc9]
; CHECK-NEXT:    {vex} vprolvd %xmm1, %xmm0, %xmm0 # encoding: [0xc4,0xe2,0x79,0x15,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %splat = shufflevector <4 x i32> %amt, <4 x i32> undef, <4 x i32> zeroinitializer
  %res = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %x, <4 x i32> %x, <4 x i32> %splat)
  ret <4 x i32> %res
}

define <2 x i64> @constant_funnnel_v2i64(<2 x i64> %x) nounwind {
; CHECK-LABEL: constant_funnnel_v2i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    {vex} vprolvq {{.*}}(%rip), %xmm0, %xmm0 # encoding: [0xc4,0xe2,0xf9,0x15,0x05,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 5, value: {{\.LCPI.*}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]
  %res = call <2 x i64> @llvm.fshl.v2i64(<2 x i64> %x, <2 x i64> %x, <2 x i64> <i64 4, i64 14>)
  ret <2 x i64> %res
}

define <4 x i32> @constant_funnnel_v4i32(<4 x i32> %x) nounwind {
; CHECK-LABEL: constant_funnnel_v4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    {vex} vprolvd {{.*}}(%rip), %xmm0, %xmm0 # encoding: [0xc4,0xe2,0x79,0x15,0x05,A,A,A,A]
; CHECK-NEXT:    # fixup A - offset: 5, value: {{\.LCPI.*}}-4, kind: reloc_riprel_4byte
; CHECK-NEXT:    retq # encoding: [0xc3]
  %res = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %x, <4 x i32> %x, <4 x i32> <i32 4, i32 5, i32 6, i32 7>)
  ret <4 x i32> %res
}

define <2 x i64> @splatconstant_funnnel_v2i64(<2 x i64> %x) nounwind {
; CHECK-LABEL: splatconstant_funnnel_v2i64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    {vex} vprolq $14, %xmm0, %xmm0 # encoding: [0xc4,0xe1,0xf9,0x72,0xc8,0x0e]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %res = call <2 x i64> @llvm.fshl.v2i64(<2 x i64> %x, <2 x i64> %x, <2 x i64> <i64 14, i64 14>)
  ret <2 x i64> %res
}

define <4 x i32> @splatconstant_funnnel_v4i32(<4 x i32> %x) nounwind {
; CHECK-LABEL: splatconstant_funnnel_v4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    {vex} vprold $4, %xmm0, %xmm0 # encoding: [0xc5,0xf9,0x72,0xc8,0x04]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %res = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %x, <4 x i32> %x, <4 x i32> <i32 4, i32 4, i32 4, i32 4>)
  ret <4 x i32> %res
}
