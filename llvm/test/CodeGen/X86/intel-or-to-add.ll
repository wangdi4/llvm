; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 3
; RUN: llc -disable-peephole -O3 -mcpu=skylake -mtriple=x86_64-unknown-linux-gnu < %s | FileCheck %s

define dso_local i32 @test_0(i32 %i) {
; CHECK-LABEL: test_0:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $edi killed $edi def $rdi
; CHECK-NEXT:    leal 7(%rdi), %eax
; CHECK-NEXT:    retq
  %zero = icmp eq i32 %i, 0
  call void @llvm.assume(i1 %zero)
  %or = or i32 %i, 7
  ret i32 %or
}

define dso_local <2 x i64> @test_1(<2 x i64> %in) {
; CHECK-LABEL: test_1:
; CHECK:       # %bb.0: # %header
; CHECK-NEXT:    movq $-2, %rax
; CHECK-NEXT:    vmovdqa {{.*#+}} xmm2 = [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
; CHECK-NEXT:    vpsrlq $32, %xmm0, %xmm1
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB1_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    addq $2, %rax
; CHECK-NEXT:    movq %rax, %rcx
; CHECK-NEXT:    subq $10238, %rcx # imm = 0x27FE
; CHECK-NEXT:    jb .LBB1_1
; CHECK-NEXT:  # %bb.2: # %end
; CHECK-NEXT:    vmovq %rax, %xmm3
; CHECK-NEXT:    vpbroadcastq %xmm3, %xmm3
; CHECK-NEXT:    vpaddq %xmm2, %xmm3, %xmm2
; CHECK-NEXT:    vpmuludq %xmm1, %xmm2, %xmm1
; CHECK-NEXT:    vpsrlq $32, %xmm2, %xmm3
; CHECK-NEXT:    vpmuludq %xmm0, %xmm3, %xmm3
; CHECK-NEXT:    vpaddq %xmm3, %xmm1, %xmm1
; CHECK-NEXT:    vpsllq $32, %xmm1, %xmm1
; CHECK-NEXT:    vpmuludq %xmm0, %xmm2, %xmm0
; CHECK-NEXT:    vpaddq %xmm1, %xmm0, %xmm0
; CHECK-NEXT:    retq
header:
  br label %loop

loop:                                          ; preds = %loop, %header
  %iv = phi i64 [ 0, %header ], [ %nextiv, %loop ]
  %veciv = insertelement <2 x i64> poison, i64 %iv, i32 0
  %splativ = shufflevector <2 x i64> %veciv, <2 x i64> poison, <2 x i32> zeroinitializer
  %ToAdd = or <2 x i64> %splativ, <i64 0, i64 1>
  %res = mul <2 x i64> %ToAdd, %in
  %nextiv = add nuw nsw i64 %iv, 2
  %cond = icmp ult i64 %iv, 10238
  br i1 %cond, label %loop, label %end

end:                                           ; preds = %loop
  ret <2 x i64> %res
}

define dso_local <2 x i64> @test_not_profitable(<2 x i64> %in) {
; CHECK-LABEL: test_not_profitable:
; CHECK:       # %bb.0: # %header
; CHECK-NEXT:    movq $-2, %rax
; CHECK-NEXT:    vmovdqa {{.*#+}} xmm1 = [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB2_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    addq $2, %rax
; CHECK-NEXT:    movq %rax, %rcx
; CHECK-NEXT:    subq $10238, %rcx # imm = 0x27FE
; CHECK-NEXT:    jb .LBB2_1
; CHECK-NEXT:  # %bb.2: # %end
; CHECK-NEXT:    vmovq %rax, %xmm2
; CHECK-NEXT:    vpbroadcastq %xmm2, %xmm2
; CHECK-NEXT:    vpaddq %xmm1, %xmm2, %xmm1
; CHECK-NEXT:    vpxor %xmm0, %xmm1, %xmm0
; CHECK-NEXT:    retq
header:
  br label %loop

loop:                                          ; preds = %loop, %header
  %iv = phi i64 [ 0, %header ], [ %nextiv, %loop ]
  %veciv = insertelement <2 x i64> poison, i64 %iv, i32 0
  %splativ = shufflevector <2 x i64> %veciv, <2 x i64> poison, <2 x i32> zeroinitializer
  %NotToAdd = or <2 x i64> %splativ, <i64 0, i64 1>
  %res = xor <2 x i64> %NotToAdd, %in
  %nextiv = add nuw nsw i64 %iv, 2
  %cond = icmp ult i64 %iv, 10238
  br i1 %cond, label %loop, label %end

end:                                           ; preds = %loop
  ret <2 x i64> %res
}

declare void @llvm.assume(i1)
