; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -x86-inst-combine -mtriple=x86_64-unknown-linux-gnu -mattr=avx512f -S < %s | FileCheck %s
define dso_local i32 @test_0(i32 %i) {
; CHECK-LABEL: @test_0(
; CHECK-NEXT:    [[ZERO:%.*]] = icmp eq i32 [[I:%.*]], 0
; CHECK-NEXT:    call void @llvm.assume(i1 [[ZERO]])
; CHECK-NEXT:    [[OR:%.*]] = add i32 [[I]], 7
; CHECK-NEXT:    ret i32 [[OR]]
;
  %zero = icmp eq i32 %i, 0
  call void @llvm.assume(i1 %zero)
  %or = or i32 %i, 7
  ret i32 %or
}

define dso_local <2 x i64> @test_1(<2 x i64> %in) {
; CHECK-LABEL: @test_1(
; CHECK-NEXT:  header:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[HEADER:%.*]] ], [ [[NEXTIV:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[VECIV:%.*]] = insertelement <2 x i64> poison, i64 [[IV]], i32 0
; CHECK-NEXT:    [[SPLATIV:%.*]] = shufflevector <2 x i64> [[VECIV]], <2 x i64> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[TOADD:%.*]] = add <2 x i64> [[SPLATIV]], <i64 0, i64 1>
; CHECK-NEXT:    [[RES:%.*]] = mul <2 x i64> [[TOADD]], [[IN:%.*]]
; CHECK-NEXT:    [[NEXTIV]] = add nuw nsw i64 [[IV]], 2
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i64 [[IV]], 10238
; CHECK-NEXT:    br i1 [[COND]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret <2 x i64> [[RES]]
;
header:
  br label %loop

loop:                                          ; preds = %loop, %header
  %iv = phi i64 [ 0, %header ], [ %nextiv, %loop ]
  %veciv = insertelement <2 x i64> poison, i64 %iv, i32 0
  %splativ = shufflevector <2 x i64> %veciv, <2 x i64> poison, <2 x i32> zeroinitializer
  %ToAdd = or <2 x i64> %splativ, <i64 0, i64 1>
  %res = mul <2 x i64> %ToAdd, %in
  %nextiv = add nuw nsw i64 %iv, 2
  %cond = icmp ult i64 %iv, 10238
  br i1 %cond, label %loop, label %end

end:                                           ; preds = %loop
  ret <2 x i64> %res
}

define dso_local <2 x i64> @test_not_profitable(<2 x i64> %in) {
; CHECK-LABEL: @test_not_profitable(
; CHECK-NEXT:  header:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[HEADER:%.*]] ], [ [[NEXTIV:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[VECIV:%.*]] = insertelement <2 x i64> poison, i64 [[IV]], i32 0
; CHECK-NEXT:    [[SPLATIV:%.*]] = shufflevector <2 x i64> [[VECIV]], <2 x i64> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[NOTTOADD:%.*]] = or <2 x i64> [[SPLATIV]], <i64 0, i64 1>
; CHECK-NEXT:    [[RES:%.*]] = xor <2 x i64> [[NOTTOADD]], [[IN:%.*]]
; CHECK-NEXT:    [[NEXTIV]] = add nuw nsw i64 [[IV]], 2
; CHECK-NEXT:    [[COND:%.*]] = icmp ult i64 [[IV]], 10238
; CHECK-NEXT:    br i1 [[COND]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret <2 x i64> [[RES]]
;
header:
  br label %loop

loop:                                          ; preds = %loop, %header
  %iv = phi i64 [ 0, %header ], [ %nextiv, %loop ]
  %veciv = insertelement <2 x i64> poison, i64 %iv, i32 0
  %splativ = shufflevector <2 x i64> %veciv, <2 x i64> poison, <2 x i32> zeroinitializer
  %NotToAdd = or <2 x i64> %splativ, <i64 0, i64 1>
  %res = xor <2 x i64> %NotToAdd, %in
  %nextiv = add nuw nsw i64 %iv, 2
  %cond = icmp ult i64 %iv, 10238
  br i1 %cond, label %loop, label %end

end:                                           ; preds = %loop
  ret <2 x i64> %res
}

declare void @llvm.assume(i1)
