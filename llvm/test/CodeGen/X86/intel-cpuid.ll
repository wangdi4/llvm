; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i386-unknown-linux | FileCheck %s --check-prefix=X86
; RUN: llc < %s -mtriple=x86_64-unknown-linux | FileCheck %s --check-prefix=X64

define i32 @test_cpuid(i32 %eax, i32 %ecx) nounwind {
; X86-LABEL: test_cpuid:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebx
; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; X86-NEXT:    cpuid
; X86-NEXT:    movl %ebx, %eax
; X86-NEXT:    subl %edx, %eax
; X86-NEXT:    popl %ebx
; X86-NEXT:    retl
;
; X64-LABEL: test_cpuid:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rbx
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    cpuid
; X64-NEXT:    movl %ebx, %eax
; X64-NEXT:    subl %edx, %eax
; X64-NEXT:    popq %rbx
; X64-NEXT:    retq
  %id = call {i32, i32, i32, i32} @llvm.x86.cpuid(i32 %eax, i32 %ecx)
  %id.ebx = extractvalue {i32, i32, i32, i32} %id, 1
  %id.edx = extractvalue {i32, i32, i32, i32} %id, 3
  %res = sub i32 %id.ebx, %id.edx
  ret i32 %res
}

define void  @test_rbx_preserved_cpuid(i32 %eax, i32 %ecx, i32 %n) nounwind {
; X86-LABEL: test_rbx_preserved_cpuid:
; X86:       # %bb.0:
; X86-NEXT:    pushl %ebp
; X86-NEXT:    movl %esp, %ebp
; X86-NEXT:    pushl %ebx
; X86-NEXT:    pushl %edi
; X86-NEXT:    pushl %esi
; X86-NEXT:    andl $-32, %esp
; X86-NEXT:    subl $32, %esp
; X86-NEXT:    movl %esp, %esi
; X86-NEXT:    movl 8(%ebp), %eax
; X86-NEXT:    movl 12(%ebp), %ecx
; X86-NEXT:    movl 16(%ebp), %edx
; X86-NEXT:    movl %esp, %edi
; X86-NEXT:    leal 15(,%edx,4), %edx
; X86-NEXT:    andl $-16, %edx
; X86-NEXT:    subl %edx, %edi
; X86-NEXT:    andl $-32, %edi
; X86-NEXT:    movl %edi, %esp
; X86-NEXT:    cpuid
; X86-NEXT:    movl %eax, (%edi)
; X86-NEXT:    movl %ebx, 4(%edi)
; X86-NEXT:    movl %ecx, 8(%edi)
; X86-NEXT:    movl %edx, 12(%edi)
; X86-NEXT:    subl $8, %esp
; X86-NEXT:    pushl 16(%ebp)
; X86-NEXT:    pushl %edi
; X86-NEXT:    calll foo@PLT
; X86-NEXT:    leal -12(%ebp), %esp
; X86-NEXT:    popl %esi
; X86-NEXT:    popl %edi
; X86-NEXT:    popl %ebx
; X86-NEXT:    popl %ebp
; X86-NEXT:    retl
;
; X64-LABEL: test_rbx_preserved_cpuid:
; X64:       # %bb.0:
; X64-NEXT:    pushq %rbp
; X64-NEXT:    movq %rsp, %rbp
; X64-NEXT:    pushq %rbx
; X64-NEXT:    andq $-32, %rsp
; X64-NEXT:    subq $32, %rsp
; X64-NEXT:    movq %rsp, %rbx
; X64-NEXT:    movl %edx, %r8d
; X64-NEXT:    movl %esi, %ecx
; X64-NEXT:    movl %edi, %eax
; X64-NEXT:    movq %rsp, %rdi
; X64-NEXT:    movl %edx, %edx
; X64-NEXT:    leaq 15(,%rdx,4), %rdx
; X64-NEXT:    andq $-16, %rdx
; X64-NEXT:    subq %rdx, %rdi
; X64-NEXT:    andq $-32, %rdi
; X64-NEXT:    movq %rdi, %rsp
; X64-NEXT:    movq %rbx, %rsi
; X64-NEXT:    cpuid
; X64-NEXT:    xchgq %rsi, %rbx
; X64-NEXT:    movl %eax, (%rdi)
; X64-NEXT:    movl %esi, 4(%rdi)
; X64-NEXT:    movl %ecx, 8(%rdi)
; X64-NEXT:    movl %edx, 12(%rdi)
; X64-NEXT:    movl %r8d, %esi
; X64-NEXT:    callq foo@PLT
; X64-NEXT:    leaq -8(%rbp), %rsp
; X64-NEXT:    popq %rbx
; X64-NEXT:    popq %rbp
; X64-NEXT:    retq
  %mem = alloca i32, i32 %n, align 32  ; Force rbx to be used as a base pointer.
  %id = call {i32, i32, i32, i32} @llvm.x86.cpuid(i32 %eax, i32 %ecx)
  %id.eax = extractvalue {i32, i32, i32, i32} %id, 0
  %id.ebx = extractvalue {i32, i32, i32, i32} %id, 1
  %id.ecx = extractvalue {i32, i32, i32, i32} %id, 2
  %id.edx = extractvalue {i32, i32, i32, i32} %id, 3
  %arrayidx0 = getelementptr inbounds i32, i32* %mem, i32 0
  store i32 %id.eax, i32* %arrayidx0, align 4
  %arrayidx1 = getelementptr inbounds i32, i32* %mem, i32 1
  store i32 %id.ebx, i32* %arrayidx1, align 4
  %arrayidx2 = getelementptr inbounds i32, i32* %mem, i32 2
  store i32 %id.ecx, i32* %arrayidx2, align 4
  %arrayidx3 = getelementptr inbounds i32, i32* %mem, i32 3
  store i32 %id.edx, i32* %arrayidx3, align 4
  call void @foo(i32* %mem, i32 %n)
  ret void
}

declare {i32, i32, i32, i32} @llvm.x86.cpuid(i32, i32)
declare void @foo(i32*, i32)
