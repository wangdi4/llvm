; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -mattr=+prefer-no-gather -x86-inst-combine -mcpu=skylake -S -mtriple=x86_64-unknown-linux-gnu -mattr=avx2 < %s | FileCheck %s

@int_base = external dso_local global [0 x i32], align 4

define dso_local noundef <2 x i64> @_Z10s1p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i32v4Dv2_x(
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32>, ptr, <4 x i32>, <4 x i32>, i8 immarg) #0

define dso_local noundef <2 x i64> @_Z12s1p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, ptr @int_base, <4 x i32> %b, <4 x i32> %c, i8 1)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

define dso_local noundef <4 x i64> @_Z10s1p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32>, ptr, <8 x i32>, <8 x i32>, i8 immarg) #0

define dso_local noundef <4 x i64> @_Z12s1p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <8 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP2]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, ptr @int_base, <8 x i32> %b, <8 x i32> %c, i8 1)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

define dso_local noundef <2 x i64> @_Z10s1p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 1)
  ret <2 x i64> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64>, ptr, <4 x i32>, <2 x i64>, i8 immarg) #0

define dso_local noundef <2 x i64> @_Z12s1p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, ptr @int_base, <4 x i32> %a, <2 x i64> %mask, i8 1)
  ret <2 x i64> %b
}

define dso_local noundef <4 x i64> @_Z10s1p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 1)
  ret <4 x i64> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64>, ptr, <4 x i32>, <4 x i64>, i8 immarg) #0

define dso_local noundef <4 x i64> @_Z12s1p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, ptr @int_base, <4 x i32> %a, <4 x i64> %mask, i8 1)
  ret <4 x i64> %b
}

define dso_local noundef <2 x i64> @_Z10s1p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP1]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32>, ptr, <2 x i64>, <4 x i32>, i8 immarg) #0

define dso_local noundef <2 x i64> @_Z12s1p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP4]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP5]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, ptr @int_base, <2 x i64> %index, <4 x i32> %b, i8 1)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s1p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32>, ptr, <4 x i64>, <4 x i32>, i8 immarg) #0

define dso_local noundef <2 x i64> @_Z12s1p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, ptr @int_base, <4 x i64> %index, <4 x i32> %b, i8 1)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s1p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 1)
  ret <2 x i64> %a
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64>, ptr, <2 x i64>, <2 x i64>, i8 immarg) #0

define dso_local noundef <2 x i64> @_Z12s1p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, ptr @int_base, <2 x i64> %index, <2 x i64> %mask, i8 1)
  ret <2 x i64> %a
}

define dso_local noundef <4 x i64> @_Z10s1p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 1)
  ret <4 x i64> %a
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64>, ptr, <4 x i64>, <4 x i64>, i8 immarg) #0

define dso_local noundef <4 x i64> @_Z12s1p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, ptr @int_base, <4 x i64> %index, <4 x i64> %mask, i8 1)
  ret <4 x i64> %a
}

define dso_local noundef <4 x float> @_Z10s1p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <4 x float> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float>, ptr, <4 x i32>, <4 x float>, i8 immarg) #0

define dso_local noundef <4 x float> @_Z12s1p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, ptr @int_base, <4 x i32> %a, <4 x float> %b, i8 1)
  ret <4 x float> %c
}

define dso_local noundef <8 x float> @_Z10s1p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <8 x float> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float>, ptr, <8 x i32>, <8 x float>, i8 immarg) #0

define dso_local noundef <8 x float> @_Z12s1p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, ptr @int_base, <8 x i32> %a, <8 x float> %b, i8 1)
  ret <8 x float> %c
}

define dso_local noundef <2 x double> @_Z10s1p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <2 x double> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double>, ptr, <4 x i32>, <2 x double>, i8 immarg) #0

define dso_local noundef <2 x double> @_Z12s1p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, ptr @int_base, <4 x i32> %a, <2 x double> %b, i8 1)
  ret <2 x double> %c
}

define dso_local noundef <4 x double> @_Z10s1p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <4 x double> %b
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double>, ptr, <4 x i32>, <4 x double>, i8 immarg) #0

define dso_local noundef <4 x double> @_Z12s1p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, ptr @int_base, <4 x i32> %a, <4 x double> %b, i8 1)
  ret <4 x double> %c
}

define dso_local noundef <4 x float> @_Z10s1p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP1]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <4 x float> %a
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float>, ptr, <2 x i64>, <4 x float>, i8 immarg) #0

define dso_local noundef <4 x float> @_Z12s1p64f32v2m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f32v2m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i1> [[TMP2]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[SRC:%.*]], <4 x float> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP5]], i32 1, <2 x i1> [[TMP3]], <2 x float> [[TMP4]])
; CHECK-NEXT:    [[B:%.*]] = shufflevector <2 x float> [[TMP6]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> %src, ptr @int_base, <2 x i64> %index, <4 x float> %a, i8 1)
  ret <4 x float> %b
}

define dso_local noundef <4 x float> @_Z10s1p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <4 x float> %a
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float>, ptr, <4 x i64>, <4 x float>, i8 immarg) #0

define dso_local noundef <4 x float> @_Z12s1p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, ptr @int_base, <4 x i64> %index, <4 x float> %a, i8 1)
  ret <4 x float> %b
}

define dso_local noundef <2 x double> @_Z10s1p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <2 x double> %a
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double>, ptr, <2 x i64>, <2 x double>, i8 immarg) #0

define dso_local noundef <2 x double> @_Z12s1p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, ptr @int_base, <2 x i64> %index, <2 x double> %a, i8 1)
  ret <2 x double> %b
}

define dso_local noundef <4 x double> @_Z10s1p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <4 x double> %a
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(read)
declare <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double>, ptr, <4 x i64>, <4 x double>, i8 immarg) #0

define dso_local noundef <4 x double> @_Z12s1p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, ptr @int_base, <4 x i64> %index, <4 x double> %a, i8 1)
  ret <4 x double> %b
}

define dso_local noundef <2 x i64> @_Z10s2p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

define dso_local noundef <2 x i64> @_Z12s2p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, ptr @int_base, <4 x i32> %b, <4 x i32> %c, i8 2)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

define dso_local noundef <4 x i64> @_Z10s2p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

define dso_local noundef <4 x i64> @_Z12s2p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <8 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP2]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, ptr @int_base, <8 x i32> %b, <8 x i32> %c, i8 2)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

define dso_local noundef <2 x i64> @_Z10s2p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 2)
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s2p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, ptr @int_base, <4 x i32> %a, <2 x i64> %mask, i8 2)
  ret <2 x i64> %b
}

define dso_local noundef <4 x i64> @_Z10s2p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 2)
  ret <4 x i64> %b
}

define dso_local noundef <4 x i64> @_Z12s2p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, ptr @int_base, <4 x i32> %a, <4 x i64> %mask, i8 2)
  ret <4 x i64> %b
}

define dso_local noundef <2 x i64> @_Z10s2p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP1]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s2p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP4]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP5]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, ptr @int_base, <2 x i64> %index, <4 x i32> %b, i8 2)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s2p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s2p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, ptr @int_base, <4 x i64> %index, <4 x i32> %b, i8 2)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s2p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 2)
  ret <2 x i64> %a
}

define dso_local noundef <2 x i64> @_Z12s2p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, ptr @int_base, <2 x i64> %index, <2 x i64> %mask, i8 2)
  ret <2 x i64> %a
}

define dso_local noundef <4 x i64> @_Z10s2p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 2)
  ret <4 x i64> %a
}

define dso_local noundef <4 x i64> @_Z12s2p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, ptr @int_base, <4 x i64> %index, <4 x i64> %mask, i8 2)
  ret <4 x i64> %a
}

define dso_local noundef <4 x float> @_Z10s2p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <4 x float> %b
}

define dso_local noundef <4 x float> @_Z12s2p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, ptr @int_base, <4 x i32> %a, <4 x float> %b, i8 2)
  ret <4 x float> %c
}

define dso_local noundef <8 x float> @_Z10s2p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <8 x float> %b
}

define dso_local noundef <8 x float> @_Z12s2p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, ptr @int_base, <8 x i32> %a, <8 x float> %b, i8 2)
  ret <8 x float> %c
}

define dso_local noundef <2 x double> @_Z10s2p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <2 x double> %b
}

define dso_local noundef <2 x double> @_Z12s2p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, ptr @int_base, <4 x i32> %a, <2 x double> %b, i8 2)
  ret <2 x double> %c
}

define dso_local noundef <4 x double> @_Z10s2p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <4 x double> %b
}

define dso_local noundef <4 x double> @_Z12s2p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, ptr @int_base, <4 x i32> %a, <4 x double> %b, i8 2)
  ret <4 x double> %c
}

define dso_local noundef <4 x float> @_Z10s2p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP1]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <4 x float> %a
}

define dso_local noundef <4 x float> @_Z12s2p64f32v2m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f32v2m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i1> [[TMP2]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[SRC:%.*]], <4 x float> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP5]], i32 1, <2 x i1> [[TMP3]], <2 x float> [[TMP4]])
; CHECK-NEXT:    [[B:%.*]] = shufflevector <2 x float> [[TMP6]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> %src, ptr @int_base, <2 x i64> %index, <4 x float> %a, i8 2)
  ret <4 x float> %b
}

define dso_local noundef <4 x float> @_Z10s2p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <4 x float> %a
}

define dso_local noundef <4 x float> @_Z12s2p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, ptr @int_base, <4 x i64> %index, <4 x float> %a, i8 2)
  ret <4 x float> %b
}

define dso_local noundef <2 x double> @_Z10s2p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <2 x double> %a
}

define dso_local noundef <2 x double> @_Z12s2p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, ptr @int_base, <2 x i64> %index, <2 x double> %a, i8 2)
  ret <2 x double> %b
}

define dso_local noundef <4 x double> @_Z10s2p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <4 x double> %a
}

define dso_local noundef <4 x double> @_Z12s2p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, ptr @int_base, <4 x i64> %index, <4 x double> %a, i8 2)
  ret <4 x double> %b
}

define dso_local noundef <2 x i64> @_Z10s4p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

define dso_local noundef <2 x i64> @_Z12s4p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, ptr @int_base, <4 x i32> %b, <4 x i32> %c, i8 4)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

define dso_local noundef <4 x i64> @_Z10s4p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

define dso_local noundef <4 x i64> @_Z12s4p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <8 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP2]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, ptr @int_base, <8 x i32> %b, <8 x i32> %c, i8 4)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

define dso_local noundef <2 x i64> @_Z10s4p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 4)
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s4p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, ptr @int_base, <4 x i32> %a, <2 x i64> %mask, i8 4)
  ret <2 x i64> %b
}

define dso_local noundef <4 x i64> @_Z10s4p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 4)
  ret <4 x i64> %b
}

define dso_local noundef <4 x i64> @_Z12s4p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, ptr @int_base, <4 x i32> %a, <4 x i64> %mask, i8 4)
  ret <4 x i64> %b
}

define dso_local noundef <2 x i64> @_Z10s4p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP1]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s4p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP4]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP5]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, ptr @int_base, <2 x i64> %index, <4 x i32> %b, i8 4)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s4p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s4p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, ptr @int_base, <4 x i64> %index, <4 x i32> %b, i8 4)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s4p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 4)
  ret <2 x i64> %a
}

define dso_local noundef <2 x i64> @_Z12s4p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, ptr @int_base, <2 x i64> %index, <2 x i64> %mask, i8 4)
  ret <2 x i64> %a
}

define dso_local noundef <4 x i64> @_Z10s4p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 4)
  ret <4 x i64> %a
}

define dso_local noundef <4 x i64> @_Z12s4p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, ptr @int_base, <4 x i64> %index, <4 x i64> %mask, i8 4)
  ret <4 x i64> %a
}

define dso_local noundef <4 x float> @_Z10s4p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <4 x float> %b
}

define dso_local noundef <4 x float> @_Z12s4p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, ptr @int_base, <4 x i32> %a, <4 x float> %b, i8 4)
  ret <4 x float> %c
}

define dso_local noundef <8 x float> @_Z10s4p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <8 x float> %b
}

define dso_local noundef <8 x float> @_Z12s4p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, ptr @int_base, <8 x i32> %a, <8 x float> %b, i8 4)
  ret <8 x float> %c
}

define dso_local noundef <2 x double> @_Z10s4p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <2 x double> %b
}

define dso_local noundef <2 x double> @_Z12s4p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, ptr @int_base, <4 x i32> %a, <2 x double> %b, i8 4)
  ret <2 x double> %c
}

define dso_local noundef <4 x double> @_Z10s4p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <4 x double> %b
}

define dso_local noundef <4 x double> @_Z12s4p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, ptr @int_base, <4 x i32> %a, <4 x double> %b, i8 4)
  ret <4 x double> %c
}

define dso_local noundef <4 x float> @_Z10s4p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP1]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <4 x float> %a
}

define dso_local noundef <4 x float> @_Z12s4p64f32v2m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f32v2m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i1> [[TMP2]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[SRC:%.*]], <4 x float> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP5]], i32 1, <2 x i1> [[TMP3]], <2 x float> [[TMP4]])
; CHECK-NEXT:    [[B:%.*]] = shufflevector <2 x float> [[TMP6]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> %src, ptr @int_base, <2 x i64> %index, <4 x float> %a, i8 4)
  ret <4 x float> %b
}

define dso_local noundef <4 x float> @_Z10s4p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <4 x float> %a
}

define dso_local noundef <4 x float> @_Z12s4p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, ptr @int_base, <4 x i64> %index, <4 x float> %a, i8 4)
  ret <4 x float> %b
}

define dso_local noundef <2 x double> @_Z10s4p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <2 x double> %a
}

define dso_local noundef <2 x double> @_Z12s4p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, ptr @int_base, <2 x i64> %index, <2 x double> %a, i8 4)
  ret <2 x double> %b
}

define dso_local noundef <4 x double> @_Z10s4p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <4 x double> %a
}

define dso_local noundef <4 x double> @_Z12s4p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, ptr @int_base, <4 x i64> %index, <4 x double> %a, i8 4)
  ret <4 x double> %b
}

define dso_local noundef <2 x i64> @_Z10s8p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

define dso_local noundef <2 x i64> @_Z12s8p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, ptr @int_base, <4 x i32> %b, <4 x i32> %c, i8 8)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

define dso_local noundef <4 x i64> @_Z10s8p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

define dso_local noundef <4 x i64> @_Z12s8p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <8 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP2]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, ptr @int_base, <8 x i32> %b, <8 x i32> %c, i8 8)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

define dso_local noundef <2 x i64> @_Z10s8p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 8)
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s8p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, ptr @int_base, <4 x i32> %a, <2 x i64> %mask, i8 8)
  ret <2 x i64> %b
}

define dso_local noundef <4 x i64> @_Z10s8p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 8)
  ret <4 x i64> %b
}

define dso_local noundef <4 x i64> @_Z12s8p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, ptr @int_base, <4 x i32> %a, <4 x i64> %mask, i8 8)
  ret <4 x i64> %b
}

define dso_local noundef <2 x i64> @_Z10s8p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP1]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s8p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP4]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP5]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, ptr @int_base, <2 x i64> %index, <4 x i32> %b, i8 8)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s8p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

define dso_local noundef <2 x i64> @_Z12s8p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, ptr @int_base, <4 x i64> %index, <4 x i32> %b, i8 8)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

define dso_local noundef <2 x i64> @_Z10s8p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 8)
  ret <2 x i64> %a
}

define dso_local noundef <2 x i64> @_Z12s8p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, ptr @int_base, <2 x i64> %index, <2 x i64> %mask, i8 8)
  ret <2 x i64> %a
}

define dso_local noundef <4 x i64> @_Z10s8p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 8)
  ret <4 x i64> %a
}

define dso_local noundef <4 x i64> @_Z12s8p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, ptr @int_base, <4 x i64> %index, <4 x i64> %mask, i8 8)
  ret <4 x i64> %a
}

define dso_local noundef <4 x float> @_Z10s8p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <4 x float> %b
}

define dso_local noundef <4 x float> @_Z12s8p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, ptr @int_base, <4 x i32> %a, <4 x float> %b, i8 8)
  ret <4 x float> %c
}

define dso_local noundef <8 x float> @_Z10s8p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, ptr @int_base, <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <8 x float> %b
}

define dso_local noundef <8 x float> @_Z12s8p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr @int_base, <8 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, ptr @int_base, <8 x i32> %a, <8 x float> %b, i8 8)
  ret <8 x float> %c
}

define dso_local noundef <2 x double> @_Z10s8p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <2 x double> %b
}

define dso_local noundef <2 x double> @_Z12s8p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, ptr @int_base, <4 x i32> %a, <2 x double> %b, i8 8)
  ret <2 x double> %c
}

define dso_local noundef <4 x double> @_Z10s8p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <4 x double> %b
}

define dso_local noundef <4 x double> @_Z12s8p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i32> [[A]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, ptr @int_base, <4 x i32> %a, <4 x double> %b, i8 8)
  ret <4 x double> %c
}

define dso_local noundef <4 x float> @_Z10s8p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP1]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, ptr @int_base, <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <4 x float> %a
}

define dso_local noundef <4 x float> @_Z10s8p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <4 x float> %a
}

define dso_local noundef <4 x float> @_Z12s8p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, ptr @int_base, <4 x i64> %index, <4 x float> %a, i8 8)
  ret <4 x float> %b
}

define dso_local noundef <2 x double> @_Z10s8p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, ptr @int_base, <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <2 x double> %a
}

define dso_local noundef <2 x double> @_Z12s8p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, ptr @int_base, <2 x i64> %index, <2 x double> %a, i8 8)
  ret <2 x double> %b
}

define dso_local noundef <4 x double> @_Z10s8p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, ptr @int_base, <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <4 x double> %a
}

define dso_local noundef <4 x double> @_Z12s8p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, ptr @int_base, <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, ptr @int_base, <4 x i64> %index, <4 x double> %a, i8 8)
  ret <4 x double> %b
}

@base = dso_local local_unnamed_addr global i8* null, align 8

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @m1s4p32i32v4(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p32i32v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <4 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP4]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <4 x i32> [[TMP5]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[TMP6]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <2 x i64> %0 to <4 x i32>
  %4 = tail call <4 x i32> @llvm.x86.avx512.mask.gather3siv4.si(<4 x i32> zeroinitializer, i8* %2, <4 x i32> %3, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 4)
  %5 = bitcast <4 x i32> %4 to <2 x i64>
  ret <2 x i64> %5
}

; Function Attrs: nofree nounwind readonly
declare <4 x i32> @llvm.x86.avx512.mask.gather3siv4.si(<4 x i32>, i8*, <4 x i32>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @mvs4p32i32v4(<2 x i64> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p32i32v4(
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <2 x i64> [[TMP2:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <8 x i1> [[TMP7]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], <4 x i32> [[TMP6]]
; CHECK-NEXT:    [[TMP10:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP9]], i32 1, <4 x i1> [[TMP8]], <4 x i32> [[TMP4]])
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast <4 x i32> [[TMP10]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[TMP11]]
;
  %4 = bitcast <2 x i64> %0 to <4 x i32>
  %5 = load i8*, i8** @base, align 8
  %6 = bitcast <2 x i64> %2 to <4 x i32>
  %7 = bitcast i8 %1 to <8 x i1>
  %8 = shufflevector <8 x i1> %7, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %9 = tail call <4 x i32> @llvm.x86.avx512.mask.gather3siv4.si(<4 x i32> %4, i8* %5, <4 x i32> %6, <4 x i1> %8, i32 4)
  %10 = bitcast <4 x i32> %9 to <2 x i64>
  ret <2 x i64> %10
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @m1s4p32i32v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p32i32v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <8 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP4]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <8 x i32> [[TMP5]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[TMP6]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <4 x i64> %0 to <8 x i32>
  %4 = tail call <8 x i32> @llvm.x86.avx512.mask.gather3siv8.si(<8 x i32> zeroinitializer, i8* %2, <8 x i32> %3, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  %5 = bitcast <8 x i32> %4 to <4 x i64>
  ret <4 x i64> %5
}

; Function Attrs: nofree nounwind readonly
declare <8 x i32> @llvm.x86.avx512.mask.gather3siv8.si(<8 x i32>, i8*, <8 x i32>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @mvs4p32i32v8(<4 x i64> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p32i32v8(
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <4 x i64> [[TMP2:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], <8 x i32> [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP8]], i32 1, <8 x i1> [[TMP7]], <8 x i32> [[TMP4]])
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast <8 x i32> [[TMP9]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[TMP10]]
;
  %4 = bitcast <4 x i64> %0 to <8 x i32>
  %5 = load i8*, i8** @base, align 8
  %6 = bitcast <4 x i64> %2 to <8 x i32>
  %7 = bitcast i8 %1 to <8 x i1>
  %8 = tail call <8 x i32> @llvm.x86.avx512.mask.gather3siv8.si(<8 x i32> %4, i8* %5, <8 x i32> %6, <8 x i1> %7, i32 4)
  %9 = bitcast <8 x i32> %8 to <4 x i64>
  ret <4 x i64> %9
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @m0s4p32i32v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m0s4p32i32v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x i64> [[TMP0:%.*]] to <16 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <16 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <16 x i32> @llvm.masked.gather.v16i32.v16p0(<16 x ptr> [[TMP4]], i32 1, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <16 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i32> [[TMP5]] to <8 x i64>
; CHECK-NEXT:    ret <8 x i64> [[TMP6]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <8 x i64> %0 to <16 x i32>
  %4 = tail call <16 x i32> @llvm.x86.avx512.mask.gather.dpi.512(<16 x i32> zeroinitializer, i8* %2, <16 x i32> %3, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  %5 = bitcast <16 x i32> %4 to <8 x i64>
  ret <8 x i64> %5
}

; Function Attrs: nofree nounwind readonly
declare <16 x i32> @llvm.x86.avx512.mask.gather.dpi.512(<16 x i32>, i8*, <16 x i32>, <16 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @m1s4p32i32v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p32i32v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x i64> [[TMP0:%.*]] to <16 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <16 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <16 x i32> @llvm.masked.gather.v16i32.v16p0(<16 x ptr> [[TMP4]], i32 1, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <16 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <16 x i32> [[TMP5]] to <8 x i64>
; CHECK-NEXT:    ret <8 x i64> [[TMP6]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <8 x i64> %0 to <16 x i32>
  %4 = tail call <16 x i32> @llvm.x86.avx512.mask.gather.dpi.512(<16 x i32> zeroinitializer, i8* %2, <16 x i32> %3, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  %5 = bitcast <16 x i32> %4 to <8 x i64>
  ret <8 x i64> %5
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @mvs4p32i32v16(<8 x i64> noundef %0, i16 noundef zeroext %1, <8 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p32i32v16(
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <8 x i64> [[TMP0:%.*]] to <16 x i32>
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <8 x i64> [[TMP2:%.*]] to <16 x i32>
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i16 [[TMP1:%.*]] to <16 x i1>
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], <16 x i32> [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = call <16 x i32> @llvm.masked.gather.v16i32.v16p0(<16 x ptr> [[TMP8]], i32 1, <16 x i1> [[TMP7]], <16 x i32> [[TMP4]])
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast <16 x i32> [[TMP9]] to <8 x i64>
; CHECK-NEXT:    ret <8 x i64> [[TMP10]]
;
  %4 = bitcast <8 x i64> %0 to <16 x i32>
  %5 = load i8*, i8** @base, align 8
  %6 = bitcast <8 x i64> %2 to <16 x i32>
  %7 = bitcast i16 %1 to <16 x i1>
  %8 = tail call <16 x i32> @llvm.x86.avx512.mask.gather.dpi.512(<16 x i32> %4, i8* %5, <16 x i32> %6, <16 x i1> %7, i32 4)
  %9 = bitcast <16 x i32> %8 to <8 x i64>
  ret <8 x i64> %9
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x float> @m1s4p32f32v4(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p32f32v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <4 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP4]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <2 x i64> %0 to <4 x i32>
  %4 = tail call <4 x float> @llvm.x86.avx512.mask.gather3siv4.sf(<4 x float> zeroinitializer, i8* %2, <4 x i32> %3, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 4)
  ret <4 x float> %4
}

; Function Attrs: nofree nounwind readonly
declare <4 x float> @llvm.x86.avx512.mask.gather3siv4.sf(<4 x float>, i8*, <4 x i32>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x float> @mvs4p32f32v4(<4 x float> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p32f32v4(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i64> [[TMP2:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i1> [[TMP6]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], <4 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP9:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP8]], i32 1, <4 x i1> [[TMP7]], <4 x float> [[TMP0:%.*]])
; CHECK-NEXT:    ret <4 x float> [[TMP9]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <2 x i64> %2 to <4 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = shufflevector <8 x i1> %6, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %8 = tail call <4 x float> @llvm.x86.avx512.mask.gather3siv4.sf(<4 x float> %0, i8* %4, <4 x i32> %5, <4 x i1> %7, i32 4)
  ret <4 x float> %8
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x float> @m1s4p32f32v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p32f32v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <8 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP4]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <4 x i64> %0 to <8 x i32>
  %4 = tail call <8 x float> @llvm.x86.avx512.mask.gather3siv8.sf(<8 x float> zeroinitializer, i8* %2, <8 x i32> %3, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  ret <8 x float> %4
}

; Function Attrs: nofree nounwind readonly
declare <8 x float> @llvm.x86.avx512.mask.gather3siv8.sf(<8 x float>, i8*, <8 x i32>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x float> @mvs4p32f32v8(<8 x float> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p32f32v8(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <4 x i64> [[TMP2:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], <8 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP7]], i32 1, <8 x i1> [[TMP6]], <8 x float> [[TMP0:%.*]])
; CHECK-NEXT:    ret <8 x float> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <4 x i64> %2 to <8 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = tail call <8 x float> @llvm.x86.avx512.mask.gather3siv8.sf(<8 x float> %0, i8* %4, <8 x i32> %5, <8 x i1> %6, i32 4)
  ret <8 x float> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <16 x float> @m0s4p32f32v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m0s4p32f32v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x i64> [[TMP0:%.*]] to <16 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <16 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> [[TMP4]], i32 1, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <16 x float> zeroinitializer)
; CHECK-NEXT:    ret <16 x float> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <8 x i64> %0 to <16 x i32>
  %4 = tail call <16 x float> @llvm.x86.avx512.mask.gather.dps.512(<16 x float> zeroinitializer, i8* %2, <16 x i32> %3, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  ret <16 x float> %4
}

; Function Attrs: nofree nounwind readonly
declare <16 x float> @llvm.x86.avx512.mask.gather.dps.512(<16 x float>, i8*, <16 x i32>, <16 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <16 x float> @m1s4p32f32v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p32f32v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x i64> [[TMP0:%.*]] to <16 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <16 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> [[TMP4]], i32 1, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <16 x float> zeroinitializer)
; CHECK-NEXT:    ret <16 x float> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <8 x i64> %0 to <16 x i32>
  %4 = tail call <16 x float> @llvm.x86.avx512.mask.gather.dps.512(<16 x float> zeroinitializer, i8* %2, <16 x i32> %3, <16 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  ret <16 x float> %4
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <16 x float> @mvs4p32f32v16(<16 x float> noundef %0, i16 noundef zeroext %1, <8 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p32f32v16(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <8 x i64> [[TMP2:%.*]] to <16 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i16 [[TMP1:%.*]] to <16 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], <16 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> [[TMP7]], i32 1, <16 x i1> [[TMP6]], <16 x float> [[TMP0:%.*]])
; CHECK-NEXT:    ret <16 x float> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <8 x i64> %2 to <16 x i32>
  %6 = bitcast i16 %1 to <16 x i1>
  %7 = tail call <16 x float> @llvm.x86.avx512.mask.gather.dps.512(<16 x float> %0, i8* %4, <16 x i32> %5, <16 x i1> %6, i32 4)
  ret <16 x float> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @m1s8p32i64v2(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s8p32i64v2(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x i32> [[TMP3]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <2 x i32> [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP5]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[TMP6]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <2 x i64> %0 to <4 x i32>
  %4 = tail call <2 x i64> @llvm.x86.avx512.mask.gather3siv2.di(<2 x i64> zeroinitializer, i8* %2, <4 x i32> %3, <2 x i1> <i1 true, i1 true>, i32 8)
  ret <2 x i64> %4
}

; Function Attrs: nofree nounwind readonly
declare <2 x i64> @llvm.x86.avx512.mask.gather3siv2.di(<2 x i64>, i8*, <4 x i32>, <2 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @mvs8p32i64v2(<2 x i64> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs8p32i64v2(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i64> [[TMP2:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i1> [[TMP6]], <8 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i32> [[TMP5]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <2 x i32> [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP9]], i32 1, <2 x i1> [[TMP7]], <2 x i64> [[TMP0:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[TMP10]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <2 x i64> %2 to <4 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = shufflevector <8 x i1> %6, <8 x i1> poison, <2 x i32> <i32 0, i32 1>
  %8 = tail call <2 x i64> @llvm.x86.avx512.mask.gather3siv2.di(<2 x i64> %0, i8* %4, <4 x i32> %5, <2 x i1> %7, i32 8)
  ret <2 x i64> %8
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @m1s8p32i64v4(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s8p32i64v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <4 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP4]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <2 x i64> %0 to <4 x i32>
  %4 = tail call <4 x i64> @llvm.x86.avx512.mask.gather3siv4.di(<4 x i64> zeroinitializer, i8* %2, <4 x i32> %3, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <4 x i64> %4
}

; Function Attrs: nofree nounwind readonly
declare <4 x i64> @llvm.x86.avx512.mask.gather3siv4.di(<4 x i64>, i8*, <4 x i32>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @mvs8p32i64v4(<4 x i64> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs8p32i64v4(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i64> [[TMP2:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i1> [[TMP6]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <4 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP9:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP8]], i32 1, <4 x i1> [[TMP7]], <4 x i64> [[TMP0:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[TMP9]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <2 x i64> %2 to <4 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = shufflevector <8 x i1> %6, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %8 = tail call <4 x i64> @llvm.x86.avx512.mask.gather3siv4.di(<4 x i64> %0, i8* %4, <4 x i32> %5, <4 x i1> %7, i32 8)
  ret <4 x i64> %8
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @m0s8p32i64v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m0s8p32i64v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <8 x i64> @llvm.masked.gather.v8i64.v8p0(<8 x ptr> [[TMP4]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i64> zeroinitializer)
; CHECK-NEXT:    ret <8 x i64> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <4 x i64> %0 to <8 x i32>
  %4 = tail call <8 x i64> @llvm.x86.avx512.mask.gather.dpq.512(<8 x i64> zeroinitializer, i8* %2, <8 x i32> %3, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x i64> %4
}

; Function Attrs: nofree nounwind readonly
declare <8 x i64> @llvm.x86.avx512.mask.gather.dpq.512(<8 x i64>, i8*, <8 x i32>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @m1s8p32i64v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s8p32i64v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <8 x i64> @llvm.masked.gather.v8i64.v8p0(<8 x ptr> [[TMP4]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i64> zeroinitializer)
; CHECK-NEXT:    ret <8 x i64> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <4 x i64> %0 to <8 x i32>
  %4 = tail call <8 x i64> @llvm.x86.avx512.mask.gather.dpq.512(<8 x i64> zeroinitializer, i8* %2, <8 x i32> %3, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x i64> %4
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @mvs8p32i64v8(<8 x i64> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs8p32i64v8(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <4 x i64> [[TMP2:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <8 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <8 x i64> @llvm.masked.gather.v8i64.v8p0(<8 x ptr> [[TMP7]], i32 1, <8 x i1> [[TMP6]], <8 x i64> [[TMP0:%.*]])
; CHECK-NEXT:    ret <8 x i64> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <4 x i64> %2 to <8 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = tail call <8 x i64> @llvm.x86.avx512.mask.gather.dpq.512(<8 x i64> %0, i8* %4, <8 x i32> %5, <8 x i1> %6, i32 8)
  ret <8 x i64> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x double> @m1s8p32f64v2(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s8p32f64v2(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x i32> [[TMP3]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <2 x i32> [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP5]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[TMP6]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <2 x i64> %0 to <4 x i32>
  %4 = tail call <2 x double> @llvm.x86.avx512.mask.gather3siv2.df(<2 x double> zeroinitializer, i8* %2, <4 x i32> %3, <2 x i1> <i1 true, i1 true>, i32 8)
  ret <2 x double> %4
}

; Function Attrs: nofree nounwind readonly
declare <2 x double> @llvm.x86.avx512.mask.gather3siv2.df(<2 x double>, i8*, <4 x i32>, <2 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x double> @mvs8p32f64v2(<2 x double> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs8p32f64v2(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i64> [[TMP2:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i1> [[TMP6]], <8 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x i32> [[TMP5]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <2 x i32> [[TMP8]]
; CHECK-NEXT:    [[TMP10:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP9]], i32 1, <2 x i1> [[TMP7]], <2 x double> [[TMP0:%.*]])
; CHECK-NEXT:    ret <2 x double> [[TMP10]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <2 x i64> %2 to <4 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = shufflevector <8 x i1> %6, <8 x i1> poison, <2 x i32> <i32 0, i32 1>
  %8 = tail call <2 x double> @llvm.x86.avx512.mask.gather3siv2.df(<2 x double> %0, i8* %4, <4 x i32> %5, <2 x i1> %7, i32 8)
  ret <2 x double> %8
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x double> @m1s8p32f64v4(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s8p32f64v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <4 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP4]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <2 x i64> %0 to <4 x i32>
  %4 = tail call <4 x double> @llvm.x86.avx512.mask.gather3siv4.df(<4 x double> zeroinitializer, i8* %2, <4 x i32> %3, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <4 x double> %4
}

; Function Attrs: nofree nounwind readonly
declare <4 x double> @llvm.x86.avx512.mask.gather3siv4.df(<4 x double>, i8*, <4 x i32>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x double> @mvs8p32f64v4(<4 x double> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs8p32f64v4(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i64> [[TMP2:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i1> [[TMP6]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <4 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP9:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP8]], i32 1, <4 x i1> [[TMP7]], <4 x double> [[TMP0:%.*]])
; CHECK-NEXT:    ret <4 x double> [[TMP9]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <2 x i64> %2 to <4 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = shufflevector <8 x i1> %6, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %8 = tail call <4 x double> @llvm.x86.avx512.mask.gather3siv4.df(<4 x double> %0, i8* %4, <4 x i32> %5, <4 x i1> %7, i32 8)
  ret <4 x double> %8
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x double> @m0s8p32f64v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m0s8p32f64v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <8 x double> @llvm.masked.gather.v8f64.v8p0(<8 x ptr> [[TMP4]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x double> zeroinitializer)
; CHECK-NEXT:    ret <8 x double> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <4 x i64> %0 to <8 x i32>
  %4 = tail call <8 x double> @llvm.x86.avx512.mask.gather.dpd.512(<8 x double> zeroinitializer, i8* %2, <8 x i32> %3, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x double> %4
}

; Function Attrs: nofree nounwind readonly
declare <8 x double> @llvm.x86.avx512.mask.gather.dpd.512(<8 x double>, i8*, <8 x i32>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x double> @m1s8p32f64v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s8p32f64v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i32> [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <8 x double> @llvm.masked.gather.v8f64.v8p0(<8 x ptr> [[TMP4]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x double> zeroinitializer)
; CHECK-NEXT:    ret <8 x double> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = bitcast <4 x i64> %0 to <8 x i32>
  %4 = tail call <8 x double> @llvm.x86.avx512.mask.gather.dpd.512(<8 x double> zeroinitializer, i8* %2, <8 x i32> %3, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x double> %4
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x double> @mvs8p32f64v8(<8 x double> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs8p32f64v8(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <4 x i64> [[TMP2:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <8 x i32> [[TMP5]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <8 x double> @llvm.masked.gather.v8f64.v8p0(<8 x ptr> [[TMP7]], i32 1, <8 x i1> [[TMP6]], <8 x double> [[TMP0:%.*]])
; CHECK-NEXT:    ret <8 x double> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast <4 x i64> %2 to <8 x i32>
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = tail call <8 x double> @llvm.x86.avx512.mask.gather.dpd.512(<8 x double> %0, i8* %4, <8 x i32> %5, <8 x i1> %6, i32 8)
  ret <8 x double> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @m1s4p64i32v2(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64i32v2(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <2 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <2 x i32> [[TMP4]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <4 x i32> [[TMP5]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[TMP6]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <4 x i32> @llvm.x86.avx512.mask.gather3div4.si(<4 x i32> zeroinitializer, i8* %2, <2 x i64> %0, <2 x i1> <i1 true, i1 true>, i32 4)
  %4 = bitcast <4 x i32> %3 to <2 x i64>
  ret <2 x i64> %4
}

; Function Attrs: nofree nounwind readonly
declare <4 x i32> @llvm.x86.avx512.mask.gather3div4.si(<4 x i32>, i8*, <2 x i64>, <2 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @mvs4p64i32v2(<2 x i64> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64i32v2(
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i1> [[TMP6]], <8 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x i1> [[TMP7]], <2 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP9:%.*]] = shufflevector <4 x i32> [[TMP4]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], <2 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP11:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0(<2 x ptr> [[TMP10]], i32 1, <2 x i1> [[TMP8]], <2 x i32> [[TMP9]])
; CHECK-NEXT:    [[TMP12:%.*]] = shufflevector <2 x i32> [[TMP11]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast <4 x i32> [[TMP12]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[TMP13]]
;
  %4 = bitcast <2 x i64> %0 to <4 x i32>
  %5 = load i8*, i8** @base, align 8
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = shufflevector <8 x i1> %6, <8 x i1> poison, <2 x i32> <i32 0, i32 1>
  %8 = tail call <4 x i32> @llvm.x86.avx512.mask.gather3div4.si(<4 x i32> %4, i8* %5, <2 x i64> %2, <2 x i1> %7, i32 4)
  %9 = bitcast <4 x i32> %8 to <2 x i64>
  ret <2 x i64> %9
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @m1s4p64i32v4(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64i32v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <4 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <4 x i32> [[TMP4]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <4 x i32> @llvm.x86.avx512.mask.gather3div8.si(<4 x i32> zeroinitializer, i8* %2, <4 x i64> %0, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 4)
  %4 = bitcast <4 x i32> %3 to <2 x i64>
  ret <2 x i64> %4
}

; Function Attrs: nofree nounwind readonly
declare <4 x i32> @llvm.x86.avx512.mask.gather3div8.si(<4 x i32>, i8*, <4 x i64>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @mvs4p64i32v4(<2 x i64> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64i32v4(
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i64> [[TMP0:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <8 x i1> [[TMP6]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], <4 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP9:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0(<4 x ptr> [[TMP8]], i32 1, <4 x i1> [[TMP7]], <4 x i32> [[TMP4]])
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast <4 x i32> [[TMP9]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[TMP10]]
;
  %4 = bitcast <2 x i64> %0 to <4 x i32>
  %5 = load i8*, i8** @base, align 8
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = shufflevector <8 x i1> %6, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %8 = tail call <4 x i32> @llvm.x86.avx512.mask.gather3div8.si(<4 x i32> %4, i8* %5, <4 x i64> %2, <4 x i1> %7, i32 4)
  %9 = bitcast <4 x i32> %8 to <2 x i64>
  ret <2 x i64> %9
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @m0s4p64i32v8(<8 x i64> noundef %0) {
; CHECK-LABEL: @m0s4p64i32v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <8 x i32> [[TMP4]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x i32> @llvm.x86.avx512.mask.gather.qpi.512(<8 x i32> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  %4 = bitcast <8 x i32> %3 to <4 x i64>
  ret <4 x i64> %4
}

; Function Attrs: nofree nounwind readonly
declare <8 x i32> @llvm.x86.avx512.mask.gather.qpi.512(<8 x i32>, i8*, <8 x i64>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @m1s4p64i32v8(<8 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64i32v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <8 x i32> [[TMP4]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x i32> @llvm.x86.avx512.mask.gather.qpi.512(<8 x i32> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  %4 = bitcast <8 x i32> %3 to <4 x i64>
  ret <4 x i64> %4
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @mvs4p64i32v8(<4 x i64> noundef %0, i8 noundef zeroext %1, <8 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64i32v8(
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i64> [[TMP0:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], <8 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[TMP7]], i32 1, <8 x i1> [[TMP6]], <8 x i32> [[TMP4]])
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast <8 x i32> [[TMP8]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[TMP9]]
;
  %4 = bitcast <4 x i64> %0 to <8 x i32>
  %5 = load i8*, i8** @base, align 8
  %6 = bitcast i8 %1 to <8 x i1>
  %7 = tail call <8 x i32> @llvm.x86.avx512.mask.gather.qpi.512(<8 x i32> %4, i8* %5, <8 x i64> %2, <8 x i1> %6, i32 4)
  %8 = bitcast <8 x i32> %7 to <4 x i64>
  ret <4 x i64> %8
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x float> @m1s4p64f32v2(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64f32v2(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <2 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <2 x float> [[TMP4]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[TMP5]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <4 x float> @llvm.x86.avx512.mask.gather3div4.sf(<4 x float> zeroinitializer, i8* %2, <2 x i64> %0, <2 x i1> <i1 true, i1 true>, i32 4)
  ret <4 x float> %3
}

; Function Attrs: nofree nounwind readonly
declare <4 x float> @llvm.x86.avx512.mask.gather3div4.sf(<4 x float>, i8*, <2 x i64>, <2 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x float> @mvs4p64f32v2(<4 x float> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64f32v2(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x i1> [[TMP5]], <8 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <2 x i1> [[TMP6]], <2 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x float> [[TMP0:%.*]], <4 x float> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], <2 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP10:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0(<2 x ptr> [[TMP9]], i32 1, <2 x i1> [[TMP7]], <2 x float> [[TMP8]])
; CHECK-NEXT:    [[TMP11:%.*]] = shufflevector <2 x float> [[TMP10]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[TMP11]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = shufflevector <8 x i1> %5, <8 x i1> poison, <2 x i32> <i32 0, i32 1>
  %7 = tail call <4 x float> @llvm.x86.avx512.mask.gather3div4.sf(<4 x float> %0, i8* %4, <2 x i64> %2, <2 x i1> %6, i32 4)
  ret <4 x float> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x float> @m1s4p64f32v4(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64f32v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <4 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <4 x float> @llvm.x86.avx512.mask.gather3div8.sf(<4 x float> zeroinitializer, i8* %2, <4 x i64> %0, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 4)
  ret <4 x float> %3
}

; Function Attrs: nofree nounwind readonly
declare <4 x float> @llvm.x86.avx512.mask.gather3div8.sf(<4 x float>, i8*, <4 x i64>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x float> @mvs4p64f32v4(<4 x float> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64f32v4(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x i1> [[TMP5]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], <4 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0(<4 x ptr> [[TMP7]], i32 1, <4 x i1> [[TMP6]], <4 x float> [[TMP0:%.*]])
; CHECK-NEXT:    ret <4 x float> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = shufflevector <8 x i1> %5, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %7 = tail call <4 x float> @llvm.x86.avx512.mask.gather3div8.sf(<4 x float> %0, i8* %4, <4 x i64> %2, <4 x i1> %6, i32 4)
  ret <4 x float> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x float> @m0s4p64f32v8(<8 x i64> noundef %0) {
; CHECK-LABEL: @m0s4p64f32v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x float> @llvm.x86.avx512.mask.gather.qps.512(<8 x float> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  ret <8 x float> %3
}

; Function Attrs: nofree nounwind readonly
declare <8 x float> @llvm.x86.avx512.mask.gather.qps.512(<8 x float>, i8*, <8 x i64>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x float> @m1s4p64f32v8(<8 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64f32v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x float> @llvm.x86.avx512.mask.gather.qps.512(<8 x float> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 4)
  ret <8 x float> %3
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x float> @mvs4p64f32v8(<8 x float> noundef %0, i8 noundef zeroext %1, <8 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64f32v8(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], <8 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP7:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0(<8 x ptr> [[TMP6]], i32 1, <8 x i1> [[TMP5]], <8 x float> [[TMP0:%.*]])
; CHECK-NEXT:    ret <8 x float> [[TMP7]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = tail call <8 x float> @llvm.x86.avx512.mask.gather.qps.512(<8 x float> %0, i8* %4, <8 x i64> %2, <8 x i1> %5, i32 4)
  ret <8 x float> %6
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @m1s4p64i64v4(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64i64v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <2 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <2 x i64> @llvm.x86.avx512.mask.gather3div2.di(<2 x i64> zeroinitializer, i8* %2, <2 x i64> %0, <2 x i1> <i1 true, i1 true>, i32 8)
  ret <2 x i64> %3
}

; Function Attrs: nofree nounwind readonly
declare <2 x i64> @llvm.x86.avx512.mask.gather3div2.di(<2 x i64>, i8*, <2 x i64>, <2 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x i64> @mvs4p64i64v4(<2 x i64> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64i64v4(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x i1> [[TMP5]], <8 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <2 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0(<2 x ptr> [[TMP7]], i32 1, <2 x i1> [[TMP6]], <2 x i64> [[TMP0:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = shufflevector <8 x i1> %5, <8 x i1> poison, <2 x i32> <i32 0, i32 1>
  %7 = tail call <2 x i64> @llvm.x86.avx512.mask.gather3div2.di(<2 x i64> %0, i8* %4, <2 x i64> %2, <2 x i1> %6, i32 8)
  ret <2 x i64> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @m1s4p64i64v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64i64v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <4 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <4 x i64> @llvm.x86.avx512.mask.gather3div4.di(<4 x i64> zeroinitializer, i8* %2, <4 x i64> %0, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <4 x i64> %3
}

; Function Attrs: nofree nounwind readonly
declare <4 x i64> @llvm.x86.avx512.mask.gather3div4.di(<4 x i64>, i8*, <4 x i64>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x i64> @mvs4p64i64v8(<4 x i64> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64i64v8(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x i1> [[TMP5]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <4 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0(<4 x ptr> [[TMP7]], i32 1, <4 x i1> [[TMP6]], <4 x i64> [[TMP0:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = shufflevector <8 x i1> %5, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %7 = tail call <4 x i64> @llvm.x86.avx512.mask.gather3div4.di(<4 x i64> %0, i8* %4, <4 x i64> %2, <4 x i1> %6, i32 8)
  ret <4 x i64> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @m0s4p64i64v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m0s4p64i64v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x i64> @llvm.masked.gather.v8i64.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i64> zeroinitializer)
; CHECK-NEXT:    ret <8 x i64> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x i64> @llvm.x86.avx512.mask.gather.qpq.512(<8 x i64> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x i64> %3
}

; Function Attrs: nofree nounwind readonly
declare <8 x i64> @llvm.x86.avx512.mask.gather.qpq.512(<8 x i64>, i8*, <8 x i64>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @m1s4p64i64v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64i64v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x i64> @llvm.masked.gather.v8i64.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i64> zeroinitializer)
; CHECK-NEXT:    ret <8 x i64> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x i64> @llvm.x86.avx512.mask.gather.qpq.512(<8 x i64> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x i64> %3
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x i64> @mvs4p64i64v16(<8 x i64> noundef %0, i8 noundef zeroext %1, <8 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64i64v16(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <8 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP7:%.*]] = call <8 x i64> @llvm.masked.gather.v8i64.v8p0(<8 x ptr> [[TMP6]], i32 1, <8 x i1> [[TMP5]], <8 x i64> [[TMP0:%.*]])
; CHECK-NEXT:    ret <8 x i64> [[TMP7]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = tail call <8 x i64> @llvm.x86.avx512.mask.gather.qpq.512(<8 x i64> %0, i8* %4, <8 x i64> %2, <8 x i1> %5, i32 8)
  ret <8 x i64> %6
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x double> @m1s4p64f64v4(<2 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64f64v4(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <2 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP3]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <2 x double> @llvm.x86.avx512.mask.gather3div2.df(<2 x double> zeroinitializer, i8* %2, <2 x i64> %0, <2 x i1> <i1 true, i1 true>, i32 8)
  ret <2 x double> %3
}

; Function Attrs: nofree nounwind readonly
declare <2 x double> @llvm.x86.avx512.mask.gather3div2.df(<2 x double>, i8*, <2 x i64>, <2 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <2 x double> @mvs4p64f64v4(<2 x double> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64f64v4(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x i1> [[TMP5]], <8 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <2 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0(<2 x ptr> [[TMP7]], i32 1, <2 x i1> [[TMP6]], <2 x double> [[TMP0:%.*]])
; CHECK-NEXT:    ret <2 x double> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = shufflevector <8 x i1> %5, <8 x i1> poison, <2 x i32> <i32 0, i32 1>
  %7 = tail call <2 x double> @llvm.x86.avx512.mask.gather3div2.df(<2 x double> %0, i8* %4, <2 x i64> %2, <2 x i1> %6, i32 8)
  ret <2 x double> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x double> @m1s4p64f64v8(<4 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64f64v8(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <4 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP3]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <4 x double> @llvm.x86.avx512.mask.gather3div4.df(<4 x double> zeroinitializer, i8* %2, <4 x i64> %0, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <4 x double> %3
}

; Function Attrs: nofree nounwind readonly
declare <4 x double> @llvm.x86.avx512.mask.gather3div4.df(<4 x double>, i8*, <4 x i64>, <4 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <4 x double> @mvs4p64f64v8(<4 x double> noundef %0, i8 noundef zeroext %1, <4 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64f64v8(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x i1> [[TMP5]], <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <4 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP8:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0(<4 x ptr> [[TMP7]], i32 1, <4 x i1> [[TMP6]], <4 x double> [[TMP0:%.*]])
; CHECK-NEXT:    ret <4 x double> [[TMP8]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = shufflevector <8 x i1> %5, <8 x i1> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %7 = tail call <4 x double> @llvm.x86.avx512.mask.gather3div4.df(<4 x double> %0, i8* %4, <4 x i64> %2, <4 x i1> %6, i32 8)
  ret <4 x double> %7
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x double> @m0s4p64f64v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m0s4p64f64v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x double> @llvm.masked.gather.v8f64.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x double> zeroinitializer)
; CHECK-NEXT:    ret <8 x double> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x double> @llvm.x86.avx512.mask.gather.qpd.512(<8 x double> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x double> %3
}

; Function Attrs: nofree nounwind readonly
declare <8 x double> @llvm.x86.avx512.mask.gather.qpd.512(<8 x double>, i8*, <8 x i64>, <8 x i1>, i32 immarg) #0

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x double> @m1s4p64f64v16(<8 x i64> noundef %0) {
; CHECK-LABEL: @m1s4p64f64v16(
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, ptr [[TMP2]], <8 x i64> [[TMP0:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = call <8 x double> @llvm.masked.gather.v8f64.v8p0(<8 x ptr> [[TMP3]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x double> zeroinitializer)
; CHECK-NEXT:    ret <8 x double> [[TMP4]]
;
  %2 = load i8*, i8** @base, align 8
  %3 = tail call <8 x double> @llvm.x86.avx512.mask.gather.qpd.512(<8 x double> zeroinitializer, i8* %2, <8 x i64> %0, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, i32 8)
  ret <8 x double> %3
}

; Function Attrs: mustprogress nofree nounwind readonly uwtable willreturn
define dso_local noundef <8 x double> @mvs4p64f64v16(<8 x double> noundef %0, i8 noundef zeroext %1, <8 x i64> noundef %2) {
; CHECK-LABEL: @mvs4p64f64v16(
; CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr @base, align 8
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast i8 [[TMP1:%.*]] to <8 x i1>
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i64, ptr [[TMP4]], <8 x i64> [[TMP2:%.*]]
; CHECK-NEXT:    [[TMP7:%.*]] = call <8 x double> @llvm.masked.gather.v8f64.v8p0(<8 x ptr> [[TMP6]], i32 1, <8 x i1> [[TMP5]], <8 x double> [[TMP0:%.*]])
; CHECK-NEXT:    ret <8 x double> [[TMP7]]
;
  %4 = load i8*, i8** @base, align 8
  %5 = bitcast i8 %1 to <8 x i1>
  %6 = tail call <8 x double> @llvm.x86.avx512.mask.gather.qpd.512(<8 x double> %0, i8* %4, <8 x i64> %2, <8 x i1> %5, i32 8)
  ret <8 x double> %6
}

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(read) }
