; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update
; RUN: opt -opaque-pointers=0 -x86-inst-combine -enable-intel-advanced-opts=true -mcpu=skylake -S -mtriple=x86_64-unknown-linux-gnu -mattr=avx2 < %s | FileCheck %s

@int_base = external dso_local global [0 x i32], align 4

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s1p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i32v4Dv2_x(
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <4 x i8*> [[TMP1]] to <4 x i32*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP2]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

; Function Attrs: nofree nounwind readonly
declare <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32>, i8*, <4 x i32>, <4 x i32>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s1p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i8*> [[TMP2]] to <4 x i32*>
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %b, <4 x i32> %c, i8 1)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s1p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8*> [[TMP0]] to <8 x i32*>
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP1]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

; Function Attrs: nofree nounwind readonly
declare <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32>, i8*, <8 x i32>, <8 x i32>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s1p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x i8*> [[TMP2]] to <8 x i32*>
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP3]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %b, <8 x i32> %c, i8 1)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s1p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i8*> [[TMP1]] to <2 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP2]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 1)
  ret <2 x i64> %b
}

; Function Attrs: nofree nounwind readonly
declare <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64>, i8*, <4 x i32>, <2 x i64>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s1p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i8*> [[TMP3]] to <2 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP4]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> %mask, i8 1)
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s1p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i8*> [[TMP0]] to <4 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 1)
  ret <4 x i64> %b
}

; Function Attrs: nofree nounwind readonly
declare <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64>, i8*, <4 x i32>, <4 x i64>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s1p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i8*> [[TMP2]] to <4 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> %mask, i8 1)
  ret <4 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s1p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i8*> [[TMP0]] to <2 x i32*>
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP2]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: nofree nounwind readonly
declare <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32>, i8*, <2 x i64>, <4 x i32>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s1p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i8*> [[TMP4]] to <2 x i32*>
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP5]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP6]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> %b, i8 1)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s1p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i8*> [[TMP0]] to <4 x i32*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 1)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: nofree nounwind readonly
declare <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32>, i8*, <4 x i64>, <4 x i32>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s1p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i8*> [[TMP2]] to <4 x i32*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> %b, i8 1)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s1p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i8*> [[TMP0]] to <2 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 1)
  ret <2 x i64> %a
}

; Function Attrs: nofree nounwind readonly
declare <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64>, i8*, <2 x i64>, <2 x i64>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s1p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i8*> [[TMP2]] to <2 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> %mask, i8 1)
  ret <2 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s1p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i8*> [[TMP0]] to <4 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 1)
  ret <4 x i64> %a
}

; Function Attrs: nofree nounwind readonly
declare <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64>, i8*, <4 x i64>, <4 x i64>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s1p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i8*> [[TMP2]] to <4 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> %mask, i8 1)
  ret <4 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s1p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i8*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <4 x float> %b
}

; Function Attrs: nofree nounwind readonly
declare <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float>, i8*, <4 x i32>, <4 x float>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s1p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i8*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> %b, i8 1)
  ret <4 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z10s1p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i8*> [[TMP0]] to <8 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP1]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <8 x float> %b
}

; Function Attrs: nofree nounwind readonly
declare <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float>, i8*, <8 x i32>, <8 x float>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z12s1p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <8 x i8*> [[TMP3]] to <8 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP4]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> %b, i8 1)
  ret <8 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s1p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i8*> [[TMP1]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP2]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <2 x double> %b
}

; Function Attrs: nofree nounwind readonly
declare <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double>, i8*, <4 x i32>, <2 x double>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s1p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i8*> [[TMP3]] to <2 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP4]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> %b, i8 1)
  ret <2 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s1p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i8*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <4 x double> %b
}

; Function Attrs: nofree nounwind readonly
declare <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double>, i8*, <4 x i32>, <4 x double>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s1p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i8*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> %b, i8 1)
  ret <4 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s1p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i8*> [[TMP0]] to <2 x float*>
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP2]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <4 x float> %a
}

; Function Attrs: nofree nounwind readonly
declare <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float>, i8*, <2 x i64>, <4 x float>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s1p64f32v2m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f32v2m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i1> [[TMP2]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[SRC:%.*]], <4 x float> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <2 x i8*> [[TMP5]] to <2 x float*>
; CHECK-NEXT:    [[TMP7:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[TMP6]], i32 1, <2 x i1> [[TMP3]], <2 x float> [[TMP4]])
; CHECK-NEXT:    [[B:%.*]] = shufflevector <2 x float> [[TMP7]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x float> %a, i8 1)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s1p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i8*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 1)
  ret <4 x float> %a
}

; Function Attrs: nofree nounwind readonly
declare <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float>, i8*, <4 x i64>, <4 x float>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s1p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i8*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> %a, i8 1)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s1p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i8*> [[TMP0]] to <2 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <2 x double> %a
}

; Function Attrs: nofree nounwind readonly
declare <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double>, i8*, <2 x i64>, <2 x double>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s1p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i8*> [[TMP2]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> %a, i8 1)
  ret <2 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s1p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s1p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i8*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 1)
  ret <4 x double> %a
}

; Function Attrs: nofree nounwind readonly
declare <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double>, i8*, <4 x i64>, <4 x double>, i8 immarg)

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s1p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s1p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i8*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> %a, i8 1)
  ret <4 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s2p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x i32*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s2p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i16*> [[TMP2]] to <4 x i32*>
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %b, <4 x i32> %c, i8 2)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s2p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i16*> [[TMP0]] to <8 x i32*>
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP1]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s2p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <8 x i32> [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x i16*> [[TMP2]] to <8 x i32*>
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP3]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %b, <8 x i32> %c, i8 2)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s2p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i16*> [[TMP1]] to <2 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP2]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 2)
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s2p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i16*> [[TMP3]] to <2 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP4]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> %mask, i8 2)
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s2p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 2)
  ret <4 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s2p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i16*> [[TMP2]] to <4 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> %mask, i8 2)
  ret <4 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s2p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i16*> [[TMP0]] to <2 x i32*>
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP2]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s2p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i16*> [[TMP4]] to <2 x i32*>
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP5]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP6]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> %b, i8 2)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s2p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x i32*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 2)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s2p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i16*> [[TMP2]] to <4 x i32*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> %b, i8 2)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s2p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i16*> [[TMP0]] to <2 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 2)
  ret <2 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s2p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i16*> [[TMP2]] to <2 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> %mask, i8 2)
  ret <2 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s2p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 2)
  ret <4 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s2p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i16*> [[TMP2]] to <4 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> %mask, i8 2)
  ret <4 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s2p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s2p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i16*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> %b, i8 2)
  ret <4 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z10s2p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i16*> [[TMP0]] to <8 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP1]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <8 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z12s2p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <8 x i16*> [[TMP3]] to <8 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP4]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> %b, i8 2)
  ret <8 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s2p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i16*> [[TMP1]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP2]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <2 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s2p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i16*> [[TMP3]] to <2 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP4]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> %b, i8 2)
  ret <2 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s2p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <4 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s2p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i16*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> %b, i8 2)
  ret <4 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s2p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i16*> [[TMP0]] to <2 x float*>
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP2]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <4 x float> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s2p64f32v2m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f32v2m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i1> [[TMP2]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[SRC:%.*]], <4 x float> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <2 x i16*> [[TMP5]] to <2 x float*>
; CHECK-NEXT:    [[TMP7:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[TMP6]], i32 1, <2 x i1> [[TMP3]], <2 x float> [[TMP4]])
; CHECK-NEXT:    [[B:%.*]] = shufflevector <2 x float> [[TMP7]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x float> %a, i8 2)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s2p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 2)
  ret <4 x float> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s2p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i16*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> %a, i8 2)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s2p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i16*> [[TMP0]] to <2 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <2 x double> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s2p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i16*> [[TMP2]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> %a, i8 2)
  ret <2 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s2p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s2p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i16*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 2)
  ret <4 x double> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s2p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s2p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i16, i16* bitcast ([0 x i32]* @int_base to i16*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i16*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> %a, i8 2)
  ret <4 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s4p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s4p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %b, <4 x i32> %c, i8 4)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s4p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <8 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP0]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s4p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <8 x i32> [[B]]
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP2]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %b, <8 x i32> %c, i8 4)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s4p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i32*> [[TMP1]] to <2 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP2]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 4)
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s4p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i32*> [[TMP3]] to <2 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP4]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> %mask, i8 4)
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s4p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i32*> [[TMP0]] to <4 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 4)
  ret <4 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s4p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i32*> [[TMP2]] to <4 x i64*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> %mask, i8 4)
  ret <4 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s4p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP1]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s4p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP4]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP5]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> %b, i8 4)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s4p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 4)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s4p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> %b, i8 4)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s4p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i32*> [[TMP0]] to <2 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 4)
  ret <2 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s4p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32*> [[TMP2]] to <2 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> %mask, i8 4)
  ret <2 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s4p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i32*> [[TMP0]] to <4 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 4)
  ret <4 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s4p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i32*> [[TMP2]] to <4 x i64*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> %mask, i8 4)
  ret <4 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s4p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i32*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s4p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i32*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> %b, i8 4)
  ret <4 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z10s4p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i32*> [[TMP0]] to <8 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP1]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <8 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z12s4p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <8 x i32*> [[TMP3]] to <8 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP4]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> %b, i8 4)
  ret <8 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s4p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i32*> [[TMP1]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP2]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <2 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s4p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i32*> [[TMP3]] to <2 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP4]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> %b, i8 4)
  ret <2 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s4p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i32*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <4 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s4p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i32*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> %b, i8 4)
  ret <4 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s4p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i32*> [[TMP0]] to <2 x float*>
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP2]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <4 x float> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s4p64f32v2m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f32v2m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i1> [[TMP2]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[SRC:%.*]], <4 x float> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast <2 x i32*> [[TMP5]] to <2 x float*>
; CHECK-NEXT:    [[TMP7:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[TMP6]], i32 1, <2 x i1> [[TMP3]], <2 x float> [[TMP4]])
; CHECK-NEXT:    [[B:%.*]] = shufflevector <2 x float> [[TMP7]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x float> %a, i8 4)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s4p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i32*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 4)
  ret <4 x float> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s4p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i32*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> %a, i8 4)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s4p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i32*> [[TMP0]] to <2 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <2 x double> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s4p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32*> [[TMP2]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> %a, i8 4)
  ret <2 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s4p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s4p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i32*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 4)
  ret <4 x double> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s4p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s4p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @int_base, i32 0, i32 0), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i32*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> %a, i8 4)
  ret <4 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s8p32i32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i64*> [[TMP0]] to <4 x i32*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i32> [[B]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %c = bitcast <4 x i32> %b to <2 x i64>
  ret <2 x i64> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s8p32i32v4m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i32v4m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64*> [[TMP2]] to <4 x i32*>
; CHECK-NEXT:    [[D:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <4 x i32> [[D]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[E]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %index to <4 x i32>
  %c = bitcast <2 x i64> %mask to <4 x i32>
  %d = tail call <4 x i32> @llvm.x86.avx2.gather.d.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %b, <4 x i32> %c, i8 8)
  %e = bitcast <4 x i32> %d to <2 x i64>
  ret <2 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s8p32i32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i64*> [[TMP0]] to <8 x i32*>
; CHECK-NEXT:    [[B:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP1]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> zeroinitializer)
; CHECK-NEXT:    [[C:%.*]] = bitcast <8 x i32> [[B]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x i32> <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %c = bitcast <8 x i32> %b to <4 x i64>
  ret <4 x i64> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s8p32i32v8m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i32v8m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[SRC:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[C:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <8 x i32> [[C]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <8 x i32> [[TMP0]] to <8 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <8 x i32> [[B]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <8 x i64*> [[TMP2]] to <8 x i32*>
; CHECK-NEXT:    [[D:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> [[TMP3]], i32 1, <8 x i1> [[TMP1]], <8 x i32> [[A]])
; CHECK-NEXT:    [[E:%.*]] = bitcast <8 x i32> [[D]] to <4 x i64>
; CHECK-NEXT:    ret <4 x i64> [[E]]
;
entry:
  %a = bitcast <4 x i64> %src to <8 x i32>
  %b = bitcast <4 x i64> %index to <8 x i32>
  %c = bitcast <4 x i64> %mask to <8 x i32>
  %d = tail call <8 x i32> @llvm.x86.avx2.gather.d.d.256(<8 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %b, <8 x i32> %c, i8 8)
  %e = bitcast <8 x i32> %d to <4 x i64>
  ret <4 x i64> %e
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s8p32i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> <i64 -1, i64 -1>, i8 8)
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s8p32i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[B:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <2 x i64> @llvm.x86.avx2.gather.d.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x i64> %mask, i8 8)
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s8p32i64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32i64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 8)
  ret <4 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s8p32i64v4m0Dv2_xDv4_xS0_(<2 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32i64v4m0Dv2_xDv4_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[A]]
; CHECK-NEXT:    [[B:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call <4 x i64> @llvm.x86.avx2.gather.d.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x i64> %mask, i8 8)
  ret <4 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s8p64i32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i64*> [[TMP0]] to <2 x i32*>
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x i32> [[TMP2]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s8p64i32v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i32v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i1> [[TMP1]], <4 x i1> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <2 x i64*> [[TMP4]] to <2 x i32*>
; CHECK-NEXT:    [[TMP6:%.*]] = call <2 x i32> @llvm.masked.gather.v2i32.v2p0i32(<2 x i32*> [[TMP5]], i32 1, <2 x i1> [[TMP2]], <2 x i32> [[TMP3]])
; CHECK-NEXT:    [[C:%.*]] = shufflevector <2 x i32> [[TMP6]], <2 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x i32> %b, i8 8)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s8p64i32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i64*> [[TMP0]] to <4 x i32*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i32> zeroinitializer)
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i32> [[A]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[B]]
;
entry:
  %a = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>, i8 8)
  %b = bitcast <4 x i32> %a to <2 x i64>
  ret <2 x i64> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s8p64i32v4m0Dv4_xDv2_xS0_(<4 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i32v4m0Dv4_xDv2_xS0_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[SRC:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i32> [[B]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i32> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64*> [[TMP2]] to <4 x i32*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x i32> @llvm.masked.gather.v4i32.v4p0i32(<4 x i32*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x i32> [[A]])
; CHECK-NEXT:    [[D:%.*]] = bitcast <4 x i32> [[C]] to <2 x i64>
; CHECK-NEXT:    ret <2 x i64> [[D]]
;
entry:
  %a = bitcast <2 x i64> %src to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x i32>
  %c = tail call <4 x i32> @llvm.x86.avx2.gather.q.d.256(<4 x i32> %a, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i32> %b, i8 8)
  %d = bitcast <4 x i32> %c to <2 x i64>
  ret <2 x i64> %d
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z10s8p64i64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP0]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x i64> zeroinitializer)
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> <i64 -1, i64 -1>, i8 8)
  ret <2 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x i64> @_Z12s8p64i64v2m0Dv2_xS_S_(<2 x i64> noundef %index, <2 x i64> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i64v2m0Dv2_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <2 x i64> @llvm.masked.gather.v2i64.v2p0i64(<2 x i64*> [[TMP2]], i32 1, <2 x i1> [[TMP1]], <2 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x i64> [[A]]
;
entry:
  %a = tail call <2 x i64> @llvm.x86.avx2.gather.q.q(<2 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x i64> %mask, i8 8)
  ret <2 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z10s8p64i64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64i64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP0]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x i64> zeroinitializer)
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> <i64 -1, i64 -1, i64 -1, i64 -1>, i8 8)
  ret <4 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x i64> @_Z12s8p64i64v4m0Dv4_xS_S_(<4 x i64> noundef %index, <4 x i64> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64i64v4m0Dv4_xS_S_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[A:%.*]] = call <4 x i64> @llvm.masked.gather.v4i64.v4p0i64(<4 x i64*> [[TMP2]], i32 1, <4 x i1> [[TMP1]], <4 x i64> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x i64> [[A]]
;
entry:
  %a = tail call <4 x i64> @llvm.x86.avx2.gather.q.q.256(<4 x i64> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x i64> %mask, i8 8)
  ret <4 x i64> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s8p32f32v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f32v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i64*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s8p32f32v4m0Dv2_xDv4_fS_(<2 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f32v4m0Dv2_xDv4_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[B]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i64*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <4 x float>
  %c = tail call fast <4 x float> @llvm.x86.avx2.gather.d.ps(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x float> %b, i8 8)
  ret <4 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z10s8p32f32v8Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f32v8Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <8 x i64*> [[TMP0]] to <8 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP1]], i32 1, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x float> zeroinitializer)
; CHECK-NEXT:    ret <8 x float> [[B]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <8 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <8 x float> @_Z12s8p32f32v8m0Dv4_xDv8_fS_(<4 x i64> noundef %index, <8 x float> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f32v8m0Dv4_xDv8_fS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <4 x i64> [[INDEX:%.*]] to <8 x i32>
; CHECK-NEXT:    [[B:%.*]] = bitcast <4 x i64> [[MASK:%.*]] to <8 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <8 x float> [[B]] to <8 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <8 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <8 x i32> [[TMP1]] to <8 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <8 x i32> [[A]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <8 x i64*> [[TMP3]] to <8 x float*>
; CHECK-NEXT:    [[C:%.*]] = call <8 x float> @llvm.masked.gather.v8f32.v8p0f32(<8 x float*> [[TMP4]], i32 1, <8 x i1> [[TMP2]], <8 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <8 x float> [[C]]
;
entry:
  %a = bitcast <4 x i64> %index to <8 x i32>
  %b = bitcast <4 x i64> %mask to <8 x float>
  %c = tail call fast <8 x float> @llvm.x86.avx2.gather.d.ps.256(<8 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <8 x i32> %a, <8 x float> %b, i8 8)
  ret <8 x float> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s8p32f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i32> [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast <2 x i64*> [[TMP1]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP2]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <2 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s8p32f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x i32> [[A]], <4 x i32> poison, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i32> [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <2 x i64*> [[TMP3]] to <2 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP4]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <2 x i64> %mask to <2 x double>
  %c = tail call fast <2 x double> @llvm.x86.avx2.gather.d.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <2 x double> %b, i8 8)
  ret <2 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s8p32f64v4Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p32f64v4Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i64*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <4 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s8p32f64v4m0Dv2_xDv4_dDv4_x(<2 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p32f64v4m0Dv2_xDv4_dDv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[INDEX:%.*]] to <4 x i32>
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i32> [[A]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[C:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[C]]
;
entry:
  %a = bitcast <2 x i64> %index to <4 x i32>
  %b = bitcast <4 x i64> %mask to <4 x double>
  %c = tail call fast <4 x double> @llvm.x86.avx2.gather.d.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i32> %a, <4 x double> %b, i8 8)
  ret <4 x double> %c
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s8p64f32v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f32v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i64*> [[TMP0]] to <2 x float*>
; CHECK-NEXT:    [[TMP2:%.*]] = call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[A:%.*]] = shufflevector <2 x float> [[TMP2]], <2 x float> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 2>
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <4 x float> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z10s8p64f32v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f32v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i64*> [[TMP0]] to <4 x float*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x float> zeroinitializer)
; CHECK-NEXT:    ret <4 x float> [[A]]
;
entry:
  %a = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> <float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000>, i8 8)
  ret <4 x float> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x float> @_Z12s8p64f32v4m0Dv4_xDv4_fDv2_x(<4 x i64> noundef %index, <4 x float> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64f32v4m0Dv4_xDv4_fDv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = bitcast <2 x i64> [[MASK:%.*]] to <4 x float>
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast <4 x float> [[A]] to <4 x i32>
; CHECK-NEXT:    [[TMP1:%.*]] = lshr <4 x i32> [[TMP0]], <i32 31, i32 31, i32 31, i32 31>
; CHECK-NEXT:    [[TMP2:%.*]] = trunc <4 x i32> [[TMP1]] to <4 x i1>
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast <4 x i64*> [[TMP3]] to <4 x float*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x float> @llvm.masked.gather.v4f32.v4p0f32(<4 x float*> [[TMP4]], i32 1, <4 x i1> [[TMP2]], <4 x float> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x float> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <4 x float>
  %b = tail call fast <4 x float> @llvm.x86.avx2.gather.q.ps.256(<4 x float> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x float> %a, i8 8)
  ret <4 x float> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z10s8p64f64v2Dv2_x(<2 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f64v2Dv2_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <2 x i64*> [[TMP0]] to <2 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP1]], i32 1, <2 x i1> <i1 true, i1 true>, <2 x double> zeroinitializer)
; CHECK-NEXT:    ret <2 x double> [[A]]
;
entry:
  %a = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <2 x double> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <2 x double> @_Z12s8p64f64v2m0Dv2_xDv2_dS_(<2 x i64> noundef %index, <2 x double> noundef %src, <2 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64f64v2m0Dv2_xDv2_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <2 x i64> [[MASK:%.*]], <i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <2 x i64> [[TMP0]] to <2 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <2 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i64*> [[TMP2]] to <2 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <2 x double> @llvm.masked.gather.v2f64.v2p0f64(<2 x double*> [[TMP3]], i32 1, <2 x i1> [[TMP1]], <2 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <2 x double> [[B]]
;
entry:
  %a = bitcast <2 x i64> %mask to <2 x double>
  %b = tail call fast <2 x double> @llvm.x86.avx2.gather.q.pd(<2 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <2 x i64> %index, <2 x double> %a, i8 8)
  ret <2 x double> %b
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z10s8p64f64v4Dv4_x(<4 x i64> noundef %index) local_unnamed_addr {
; CHECK-LABEL: @_Z10s8p64f64v4Dv4_x(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast <4 x i64*> [[TMP0]] to <4 x double*>
; CHECK-NEXT:    [[A:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP1]], i32 1, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> zeroinitializer)
; CHECK-NEXT:    ret <4 x double> [[A]]
;
entry:
  %a = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> zeroinitializer, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> <double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF, double 0xFFFFFFFFFFFFFFFF>, i8 8)
  ret <4 x double> %a
}

; Function Attrs: mustprogress nofree nounwind readonly willreturn uwtable
define dso_local noundef <4 x double> @_Z12s8p64f64v4m0Dv4_xDv4_dS_(<4 x i64> noundef %index, <4 x double> noundef %src, <4 x i64> noundef %mask) local_unnamed_addr {
; CHECK-LABEL: @_Z12s8p64f64v4m0Dv4_xDv4_dS_(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = lshr <4 x i64> [[MASK:%.*]], <i64 63, i64 63, i64 63, i64 63>
; CHECK-NEXT:    [[TMP1:%.*]] = trunc <4 x i64> [[TMP0]] to <4 x i1>
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* bitcast ([0 x i32]* @int_base to i64*), <4 x i64> [[INDEX:%.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <4 x i64*> [[TMP2]] to <4 x double*>
; CHECK-NEXT:    [[B:%.*]] = call <4 x double> @llvm.masked.gather.v4f64.v4p0f64(<4 x double*> [[TMP3]], i32 1, <4 x i1> [[TMP1]], <4 x double> [[SRC:%.*]])
; CHECK-NEXT:    ret <4 x double> [[B]]
;
entry:
  %a = bitcast <4 x i64> %mask to <4 x double>
  %b = tail call fast <4 x double> @llvm.x86.avx2.gather.q.pd.256(<4 x double> %src, i8* bitcast ([0 x i32]* @int_base to i8*), <4 x i64> %index, <4 x double> %a, i8 8)
  ret <4 x double> %b
}
