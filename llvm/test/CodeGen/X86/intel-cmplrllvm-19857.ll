; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu | FileCheck %s

; This code contains a loop that has been unrolled 8 times. It calculates the
; max value of a bunch of memory location and saves the corresponding max
; element. So there are 8 selects chained together and each select calculates
; the running max.
;
; The goal of this test is to ensure that we keep the selects (for max) as
; cmoves in the final assembly. Rather than having them converted to control
; flow by thecmov conversion pass.

define void @widget([240 x i32]* %arg, i64 %arg1, i32* %arg2) {
; CHECK-LABEL: widget:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    incq %rsi
; CHECK-NEXT:    addq $28, %rdi
; CHECK-NEXT:    movl $-1000000, %eax # imm = 0xFFF0BDC0
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_1: # %bb4
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl -28(%rdi), %ecx
; CHECK-NEXT:    movl -24(%rdi), %r8d
; CHECK-NEXT:    cmpl %eax, %ecx
; CHECK-NEXT:    cmovgel %ecx, %eax
; CHECK-NEXT:    cmpl %eax, %r8d
; CHECK-NEXT:    cmovgel %r8d, %eax
; CHECK-NEXT:    movl -20(%rdi), %ecx
; CHECK-NEXT:    cmpl %eax, %ecx
; CHECK-NEXT:    cmovgel %ecx, %eax
; CHECK-NEXT:    movl -16(%rdi), %ecx
; CHECK-NEXT:    cmpl %eax, %ecx
; CHECK-NEXT:    cmovgel %ecx, %eax
; CHECK-NEXT:    movl -12(%rdi), %ecx
; CHECK-NEXT:    cmpl %eax, %ecx
; CHECK-NEXT:    cmovgel %ecx, %eax
; CHECK-NEXT:    movl -8(%rdi), %ecx
; CHECK-NEXT:    cmpl %eax, %ecx
; CHECK-NEXT:    cmovgel %ecx, %eax
; CHECK-NEXT:    movl -4(%rdi), %ecx
; CHECK-NEXT:    cmpl %eax, %ecx
; CHECK-NEXT:    cmovgel %ecx, %eax
; CHECK-NEXT:    movl (%rdi), %ecx
; CHECK-NEXT:    cmpl %eax, %ecx
; CHECK-NEXT:    cmovgel %ecx, %eax
; CHECK-NEXT:    addq $32, %rdi
; CHECK-NEXT:    decq %rsi
; CHECK-NEXT:    jne .LBB0_1
; CHECK-NEXT:  # %bb.2: # %bb65
; CHECK-NEXT:    movl %eax, (%rdx)
; CHECK-NEXT:    retq
bb:
  br label %bb4

bb4:                                              ; preds = %bb4, %bb
  %tmp = phi i64 [ 0, %bb ], [ %tmp63, %bb4 ]
  %tmp5 = phi i32 [ -1000000, %bb ], [ %tmp62, %bb4 ]
  %tmp7 = shl i64 %tmp, 3
  %tmp8 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp7
  %tmp9 = load i32, i32* %tmp8, align 16
  %tmp11 = icmp sgt i32 %tmp9, %tmp5
  %tmp13 = select i1 %tmp11, i32 %tmp9, i32 %tmp5
  %tmp14 = or i64 %tmp7, 1
  %tmp15 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp14
  %tmp16 = load i32, i32* %tmp15, align 4
  %tmp18 = icmp sgt i32 %tmp16, %tmp13
  %tmp20 = select i1 %tmp18, i32 %tmp16, i32 %tmp13
  %tmp21 = or i64 %tmp7, 2
  %tmp22 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp21
  %tmp23 = load i32, i32* %tmp22, align 8
  %tmp25 = icmp sgt i32 %tmp23, %tmp20
  %tmp27 = select i1 %tmp25, i32 %tmp23, i32 %tmp20
  %tmp28 = or i64 %tmp7, 3
  %tmp29 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp28
  %tmp30 = load i32, i32* %tmp29, align 4
  %tmp32 = icmp sgt i32 %tmp30, %tmp27
  %tmp34 = select i1 %tmp32, i32 %tmp30, i32 %tmp27
  %tmp35 = or i64 %tmp7, 4
  %tmp36 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp35
  %tmp37 = load i32, i32* %tmp36, align 16
  %tmp39 = icmp sgt i32 %tmp37, %tmp34
  %tmp41 = select i1 %tmp39, i32 %tmp37, i32 %tmp34
  %tmp42 = or i64 %tmp7, 5
  %tmp43 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp42
  %tmp44 = load i32, i32* %tmp43, align 4
  %tmp46 = icmp sgt i32 %tmp44, %tmp41
  %tmp48 = select i1 %tmp46, i32 %tmp44, i32 %tmp41
  %tmp49 = or i64 %tmp7, 6
  %tmp50 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp49
  %tmp51 = load i32, i32* %tmp50, align 8
  %tmp53 = icmp sgt i32 %tmp51, %tmp48
  %tmp55 = select i1 %tmp53, i32 %tmp51, i32 %tmp48
  %tmp56 = or i64 %tmp7, 7
  %tmp57 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp56
  %tmp58 = load i32, i32* %tmp57, align 4
  %tmp60 = icmp sgt i32 %tmp58, %tmp55
  %tmp62 = select i1 %tmp60, i32 %tmp58, i32 %tmp55
  %tmp63 = add nuw nsw i64 %tmp, 1
  %tmp64 = icmp eq i64 %tmp, %arg1
  br i1 %tmp64, label %bb65, label %bb4

bb65:                                             ; preds = %bb4
  store i32 %tmp62, i32* %arg2
  ret void
}
