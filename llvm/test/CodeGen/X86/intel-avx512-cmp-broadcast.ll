; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-unknown-unknown -mattr=+avx512f,+avx512vl,+avx512bw,+avx512dq < %s | FileCheck %s

define <16 x i1> @v16i16(i16 %a) {
; CHECK-LABEL: v16i16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpw $1, %di
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i16 %a, 0
  %1 = insertelement <16 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <16 x i1> %1, <16 x i1> undef, <16 x i32> zeroinitializer
  ret <16 x i1> %2
}

define <16 x i1> @v16i16_and(i16 %a) {
; CHECK-LABEL: v16i16_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %ymm0
; CHECK-NEXT:    movw $21845, %ax # imm = 0x5555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmw %ymm0, %ymm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i16 %a, 0
  %1 = insertelement <16 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <16 x i1> %1, <16 x i1> undef, <16 x i32> zeroinitializer
  %3 = and <16 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <16 x i1> %3
}

define <16 x i1> @v16i16_bcst(i16 %a, <16 x i16>* %m) {
; CHECK-LABEL: v16i16_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %ymm0
; CHECK-NEXT:    vmovdqa %ymm0, (%rsi)
; CHECK-NEXT:    vptestnmw %ymm0, %ymm0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <16 x i16> undef, i16 %a, i32 0
  %1 = shufflevector <16 x i16> %0, <16 x i16> undef, <16 x i32> zeroinitializer
  store <16 x i16> %1, <16 x i16>* %m
  %2 = icmp eq i16 %a, 0
  %3 = insertelement <16 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <16 x i1> %3, <16 x i1> undef, <16 x i32> zeroinitializer
  ret <16 x i1> %4
}

define <16 x i1> @v16i16_and_bcst(i16 %a, <16 x i16>* %m) {
; CHECK-LABEL: v16i16_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %ymm0
; CHECK-NEXT:    vmovdqa %ymm0, (%rsi)
; CHECK-NEXT:    movw $21845, %ax # imm = 0x5555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmw %ymm0, %ymm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <16 x i16> undef, i16 %a, i32 0
  %1 = shufflevector <16 x i16> %0, <16 x i16> undef, <16 x i32> zeroinitializer
  store <16 x i16> %1, <16 x i16>* %m
  %2 = icmp eq i16 %a, 0
  %3 = insertelement <16 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <16 x i1> %3, <16 x i1> undef, <16 x i32> zeroinitializer
  %5 = and <16 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <16 x i1> %5
}

define <32 x i1> @v32i16(i16 %a) {
; CHECK-LABEL: v32i16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpw $1, %di
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i16 %a, 0
  %1 = insertelement <32 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <32 x i1> %1, <32 x i1> undef, <32 x i32> zeroinitializer
  ret <32 x i1> %2
}

define <32 x i1> @v32i16_and(i16 %a) {
; CHECK-LABEL: v32i16_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %zmm0
; CHECK-NEXT:    movl $1431655765, %eax # imm = 0x55555555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmw %zmm0, %zmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i16 %a, 0
  %1 = insertelement <32 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <32 x i1> %1, <32 x i1> undef, <32 x i32> zeroinitializer
  %3 = and <32 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <32 x i1> %3
}

define <32 x i1> @v32i16_bcst(i16 %a, <32 x i16>* %m) {
; CHECK-LABEL: v32i16_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    vptestnmw %zmm0, %zmm0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <32 x i16> undef, i16 %a, i32 0
  %1 = shufflevector <32 x i16> %0, <32 x i16> undef, <32 x i32> zeroinitializer
  store <32 x i16> %1, <32 x i16>* %m
  %2 = icmp eq i16 %a, 0
  %3 = insertelement <32 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <32 x i1> %3, <32 x i1> undef, <32 x i32> zeroinitializer
  ret <32 x i1> %4
}

define <32 x i1> @v32i16_and_bcst(i16 %a, <32 x i16>* %m) {
; CHECK-LABEL: v32i16_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    movl $1431655765, %eax # imm = 0x55555555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmw %zmm0, %zmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <32 x i16> undef, i16 %a, i32 0
  %1 = shufflevector <32 x i16> %0, <32 x i16> undef, <32 x i32> zeroinitializer
  store <32 x i16> %1, <32 x i16>* %m
  %2 = icmp eq i16 %a, 0
  %3 = insertelement <32 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <32 x i1> %3, <32 x i1> undef, <32 x i32> zeroinitializer
  %5 = and <32 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <32 x i1> %5
}

define <64 x i1> @v64i16(i16 %a) {
; CHECK-LABEL: v64i16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpw $1, %di
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i16 %a, 0
  %1 = insertelement <64 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <64 x i1> %1, <64 x i1> undef, <64 x i32> zeroinitializer
  ret <64 x i1> %2
}

define <64 x i1> @v64i16_and(i16 %a) {
; CHECK-LABEL: v64i16_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpw $1, %di
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    movabsq $6148914691236517205, %rax # imm = 0x5555555555555555
; CHECK-NEXT:    kmovq %rax, %k1
; CHECK-NEXT:    kandq %k1, %k0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i16 %a, 0
  %1 = insertelement <64 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <64 x i1> %1, <64 x i1> undef, <64 x i32> zeroinitializer
  %3 = and <64 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <64 x i1> %3
}

define <64 x i1> @v64i16_bcst(i16 %a, <64 x i16>* %m) {
; CHECK-LABEL: v64i16_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpw $1, %di
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <64 x i16> undef, i16 %a, i32 0
  %1 = shufflevector <64 x i16> %0, <64 x i16> undef, <64 x i32> zeroinitializer
  store <64 x i16> %1, <64 x i16>* %m
  %2 = icmp eq i16 %a, 0
  %3 = insertelement <64 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <64 x i1> %3, <64 x i1> undef, <64 x i32> zeroinitializer
  ret <64 x i1> %4
}

define <64 x i1> @v64i16_and_bcst(i16 %a, <64 x i16>* %m) {
; CHECK-LABEL: v64i16_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastw %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpw $1, %di
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    movabsq $6148914691236517205, %rax # imm = 0x5555555555555555
; CHECK-NEXT:    kmovq %rax, %k1
; CHECK-NEXT:    kandq %k1, %k0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <64 x i16> undef, i16 %a, i32 0
  %1 = shufflevector <64 x i16> %0, <64 x i16> undef, <64 x i32> zeroinitializer
  store <64 x i16> %1, <64 x i16>* %m
  %2 = icmp eq i16 %a, 0
  %3 = insertelement <64 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <64 x i1> %3, <64 x i1> undef, <64 x i32> zeroinitializer
  %5 = and <64 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <64 x i1> %5
}

define <4 x i1> @v4i32(i32 %a) {
; CHECK-LABEL: v4i32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2d %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <4 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <4 x i1> %1, <4 x i1> undef, <4 x i32> zeroinitializer
  ret <4 x i1> %2
}

define <4 x i1> @v4i32_and(i32 %a) {
; CHECK-LABEL: v4i32_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %xmm0
; CHECK-NEXT:    movb $5, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmd %xmm0, %xmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2d %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <4 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <4 x i1> %1, <4 x i1> undef, <4 x i32> zeroinitializer
  %3 = and <4 x i1> %2, <i1 1, i1 0, i1 1, i1 0>
  ret <4 x i1> %3
}

define <4 x i1> @v4i32_bcst(i32 %a, <4 x i32>* %m) {
; CHECK-LABEL: v4i32_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %xmm0
; CHECK-NEXT:    vmovdqa %xmm0, (%rsi)
; CHECK-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; CHECK-NEXT:    vpcmpeqd %xmm1, %xmm0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <4 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <4 x i32> %0, <4 x i32> undef, <4 x i32> zeroinitializer
  store <4 x i32> %1, <4 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <4 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <4 x i1> %3, <4 x i1> undef, <4 x i32> zeroinitializer
  ret <4 x i1> %4
}

define <4 x i1> @v4i32_and_bcst(i32 %a, <4 x i32>* %m) {
; CHECK-LABEL: v4i32_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %xmm0
; CHECK-NEXT:    vmovdqa %xmm0, (%rsi)
; CHECK-NEXT:    movb $5, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmd %xmm0, %xmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2d %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <4 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <4 x i32> %0, <4 x i32> undef, <4 x i32> zeroinitializer
  store <4 x i32> %1, <4 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <4 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <4 x i1> %3, <4 x i1> undef, <4 x i32> zeroinitializer
  %5 = and <4 x i1> %4, <i1 1, i1 0, i1 1, i1 0>
  ret <4 x i1> %5
}

define <8 x i1> @v8i32(i32 %a) {
; CHECK-LABEL: v8i32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <8 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <8 x i1> %1, <8 x i1> undef, <8 x i32> zeroinitializer
  ret <8 x i1> %2
}

define <8 x i1> @v8i32_and(i32 %a) {
; CHECK-LABEL: v8i32_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %ymm0
; CHECK-NEXT:    movb $85, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmd %ymm0, %ymm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <8 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <8 x i1> %1, <8 x i1> undef, <8 x i32> zeroinitializer
  %3 = and <8 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <8 x i1> %3
}

define <8 x i1> @v8i32_bcst(i32 %a, <8 x i32>* %m) {
; CHECK-LABEL: v8i32_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %ymm0
; CHECK-NEXT:    vmovdqa %ymm0, (%rsi)
; CHECK-NEXT:    vptestnmd %ymm0, %ymm0, %k0
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <8 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <8 x i32> %0, <8 x i32> undef, <8 x i32> zeroinitializer
  store <8 x i32> %1, <8 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <8 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <8 x i1> %3, <8 x i1> undef, <8 x i32> zeroinitializer
  ret <8 x i1> %4
}

define <8 x i1> @v8i32_and_bcst(i32 %a, <8 x i32>* %m) {
; CHECK-LABEL: v8i32_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %ymm0
; CHECK-NEXT:    vmovdqa %ymm0, (%rsi)
; CHECK-NEXT:    movb $85, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmd %ymm0, %ymm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <8 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <8 x i32> %0, <8 x i32> undef, <8 x i32> zeroinitializer
  store <8 x i32> %1, <8 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <8 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <8 x i1> %3, <8 x i1> undef, <8 x i32> zeroinitializer
  %5 = and <8 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <8 x i1> %5
}

define <16 x i1> @v16i32(i32 %a) {
; CHECK-LABEL: v16i32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <16 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <16 x i1> %1, <16 x i1> undef, <16 x i32> zeroinitializer
  ret <16 x i1> %2
}

define <16 x i1> @v16i32_and(i32 %a) {
; CHECK-LABEL: v16i32_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %zmm0
; CHECK-NEXT:    movw $21845, %ax # imm = 0x5555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmd %zmm0, %zmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <16 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <16 x i1> %1, <16 x i1> undef, <16 x i32> zeroinitializer
  %3 = and <16 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <16 x i1> %3
}

define <16 x i1> @v16i32_bcst(i32 %a, <16 x i32>* %m) {
; CHECK-LABEL: v16i32_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    vptestnmd %zmm0, %zmm0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <16 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <16 x i32> %0, <16 x i32> undef, <16 x i32> zeroinitializer
  store <16 x i32> %1, <16 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <16 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <16 x i1> %3, <16 x i1> undef, <16 x i32> zeroinitializer
  ret <16 x i1> %4
}

define <16 x i1> @v16i32_and_bcst(i32 %a, <16 x i32>* %m) {
; CHECK-LABEL: v16i32_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    movw $21845, %ax # imm = 0x5555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmd %zmm0, %zmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <16 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <16 x i32> %0, <16 x i32> undef, <16 x i32> zeroinitializer
  store <16 x i32> %1, <16 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <16 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <16 x i1> %3, <16 x i1> undef, <16 x i32> zeroinitializer
  %5 = and <16 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <16 x i1> %5
}

define <32 x i1> @v32i32(i32 %a) {
; CHECK-LABEL: v32i32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <32 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <32 x i1> %1, <32 x i1> undef, <32 x i32> zeroinitializer
  ret <32 x i1> %2
}

define <32 x i1> @v32i32_and(i32 %a) {
; CHECK-LABEL: v32i32_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <32 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <32 x i1> %1, <32 x i1> undef, <32 x i32> zeroinitializer
  %3 = and <32 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <32 x i1> %2
}

define <32 x i1> @v32i32_bcst(i32 %a, <32 x i32>* %m) {
; CHECK-LABEL: v32i32_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <32 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <32 x i32> %0, <32 x i32> undef, <32 x i32> zeroinitializer
  store <32 x i32> %1, <32 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <32 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <32 x i1> %3, <32 x i1> undef, <32 x i32> zeroinitializer
  ret <32 x i1> %4
}

define <32 x i1> @v32i32_and_bcst(i32 %a, <32 x i32>* %m) {
; CHECK-LABEL: v32i32_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    movl $1431655765, %eax # imm = 0x55555555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    kandd %k1, %k0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %ymm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <32 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <32 x i32> %0, <32 x i32> undef, <32 x i32> zeroinitializer
  store <32 x i32> %1, <32 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <32 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <32 x i1> %3, <32 x i1> undef, <32 x i32> zeroinitializer
  %5 = and <32 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <32 x i1> %5
}

define <64 x i1> @v64i32(i32 %a) {
; CHECK-LABEL: v64i32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <64 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <64 x i1> %1, <64 x i1> undef, <64 x i32> zeroinitializer
  ret <64 x i1> %2
}

define <64 x i1> @v64i32_and(i32 %a) {
; CHECK-LABEL: v64i32_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    movabsq $6148914691236517205, %rax # imm = 0x5555555555555555
; CHECK-NEXT:    kmovq %rax, %k1
; CHECK-NEXT:    kandq %k1, %k0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i32 %a, 0
  %1 = insertelement <64 x i1> undef, i1 %0, i32 0
  %2 = shufflevector <64 x i1> %1, <64 x i1> undef, <64 x i32> zeroinitializer
  %3 = and <64 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <64 x i1> %3
}

define <64 x i1> @v64i32_bcst(i32 %a, <64 x i32>* %m) {
; CHECK-LABEL: v64i32_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 192(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, 128(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <64 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <64 x i32> %0, <64 x i32> undef, <64 x i32> zeroinitializer
  store <64 x i32> %1, <64 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <64 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <64 x i1> %3, <64 x i1> undef, <64 x i32> zeroinitializer
  ret <64 x i1> %4
}

define <64 x i1> @v64i32_and_bcst(i32 %a, <64 x i32>* %m) {
; CHECK-LABEL: v64i32_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastd %edi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 192(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, 128(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpl $1, %edi
; CHECK-NEXT:    sbbq %rax, %rax
; CHECK-NEXT:    kmovq %rax, %k0
; CHECK-NEXT:    movabsq $6148914691236517205, %rax # imm = 0x5555555555555555
; CHECK-NEXT:    kmovq %rax, %k1
; CHECK-NEXT:    kandq %k1, %k0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %zmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <64 x i32> undef, i32 %a, i32 0
  %1 = shufflevector <64 x i32> %0, <64 x i32> undef, <64 x i32> zeroinitializer
  store <64 x i32> %1, <64 x i32>* %m
  %2 = icmp eq i32 %a, 0
  %3 = insertelement <64 x i1> undef, i1 %2, i32 0
  %4 = shufflevector <64 x i1> %3, <64 x i1> undef, <64 x i32> zeroinitializer
  %5 = and <64 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <64 x i1> %5
}

define <2 x i1> @v2i64(i64 %a) {
; CHECK-LABEL: v2i64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpq $1, %rdi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2q %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <2 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <2 x i1> %1, <2 x i1> undef, <2 x i32> zeroinitializer
  ret <2 x i1> %2
}

define <2 x i1> @v2i64_and(i64 %a) {
; CHECK-LABEL: v2i64_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %xmm0
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmq %xmm0, %xmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2q %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <2 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <2 x i1> %1, <2 x i1> undef, <2 x i32> zeroinitializer
  %3 = and <2 x i1> %2, <i1 1, i1 0>
  ret <2 x i1> %3
}

define <2 x i1> @v2i64_bcst(i64 %a, <2 x i64>* %m) {
; CHECK-LABEL: v2i64_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %xmm0
; CHECK-NEXT:    vmovdqa %xmm0, (%rsi)
; CHECK-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; CHECK-NEXT:    vpcmpeqq %xmm1, %xmm0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <2 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <2 x i64> %0, <2 x i64> undef, <2 x i32> zeroinitializer
  store <2 x i64> %1, <2 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <2 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <2 x i1> %3, <2 x i1> undef, <2 x i32> zeroinitializer
  ret <2 x i1> %4
}

define <2 x i1> @v2i64_and_bcst(i64 %a, <2 x i64>* %m) {
; CHECK-LABEL: v2i64_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %xmm0
; CHECK-NEXT:    vmovdqa %xmm0, (%rsi)
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmq %xmm0, %xmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2q %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <2 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <2 x i64> %0, <2 x i64> undef, <2 x i32> zeroinitializer
  store <2 x i64> %1, <2 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <2 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <2 x i1> %3, <2 x i1> undef, <2 x i32> zeroinitializer
  %5 = and <2 x i1> %4, <i1 1, i1 0>
  ret <2 x i1> %5
}

define <4 x i1> @v4i64(i64 %a) {
; CHECK-LABEL: v4i64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpq $1, %rdi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2d %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <4 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <4 x i1> %1, <4 x i1> undef, <4 x i32> zeroinitializer
  ret <4 x i1> %2
}

define <4 x i1> @v4i64_and(i64 %a) {
; CHECK-LABEL: v4i64_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %ymm0
; CHECK-NEXT:    movb $5, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmq %ymm0, %ymm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2d %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <4 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <4 x i1> %1, <4 x i1> undef, <4 x i32> zeroinitializer
  %3 = and <4 x i1> %2, <i1 1, i1 0, i1 1, i1 0>
  ret <4 x i1> %3
}

define <4 x i1> @v4i64_bcst(i64 %a, <4 x i64>* %m) {
; CHECK-LABEL: v4i64_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %ymm0
; CHECK-NEXT:    vmovdqa %ymm0, (%rsi)
; CHECK-NEXT:    vptestnmq %ymm0, %ymm0, %k0
; CHECK-NEXT:    vpmovm2d %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <4 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <4 x i64> %0, <4 x i64> undef, <4 x i32> zeroinitializer
  store <4 x i64> %1, <4 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <4 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <4 x i1> %3, <4 x i1> undef, <4 x i32> zeroinitializer
  ret <4 x i1> %4
}

define <4 x i1> @v4i64_and_bcst(i64 %a, <4 x i64>* %m) {
; CHECK-LABEL: v4i64_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %ymm0
; CHECK-NEXT:    vmovdqa %ymm0, (%rsi)
; CHECK-NEXT:    movb $5, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmq %ymm0, %ymm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2d %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <4 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <4 x i64> %0, <4 x i64> undef, <4 x i32> zeroinitializer
  store <4 x i64> %1, <4 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <4 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <4 x i1> %3, <4 x i1> undef, <4 x i32> zeroinitializer
  %5 = and <4 x i1> %4, <i1 1, i1 0, i1 1, i1 0>
  ret <4 x i1> %5
}

define <8 x i1> @v8i64(i64 %a) {
; CHECK-LABEL: v8i64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpq $1, %rdi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <8 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <8 x i1> %1, <8 x i1> undef, <8 x i32> zeroinitializer
  ret <8 x i1> %2
}

define <8 x i1> @v8i64_and(i64 %a) {
; CHECK-LABEL: v8i64_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %zmm0
; CHECK-NEXT:    movb $85, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmq %zmm0, %zmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <8 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <8 x i1> %1, <8 x i1> undef, <8 x i32> zeroinitializer
  %3 = and <8 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <8 x i1> %3
}

define <8 x i1> @v8i64_bcst(i64 %a, <8 x i64>* %m) {
; CHECK-LABEL: v8i64_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    vptestnmq %zmm0, %zmm0, %k0
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <8 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <8 x i64> %0, <8 x i64> undef, <8 x i32> zeroinitializer
  store <8 x i64> %1, <8 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <8 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <8 x i1> %3, <8 x i1> undef, <8 x i32> zeroinitializer
  ret <8 x i1> %4
}

define <8 x i1> @v8i64_and_bcst(i64 %a, <8 x i64>* %m) {
; CHECK-LABEL: v8i64_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    movb $85, %al
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    vptestnmq %zmm0, %zmm0, %k0 {%k1}
; CHECK-NEXT:    vpmovm2w %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <8 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <8 x i64> %0, <8 x i64> undef, <8 x i32> zeroinitializer
  store <8 x i64> %1, <8 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <8 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <8 x i1> %3, <8 x i1> undef, <8 x i32> zeroinitializer
  %5 = and <8 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <8 x i1> %5
}

define <16 x i1> @v16i64(i64 %a) {
; CHECK-LABEL: v16i64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpq $1, %rdi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <16 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <16 x i1> %1, <16 x i1> undef, <16 x i32> zeroinitializer
  ret <16 x i1> %2
}

define <16 x i1> @v16i64_and(i64 %a) {
; CHECK-LABEL: v16i64_and:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpq $1, %rdi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    movw $21845, %ax # imm = 0x5555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    kandw %k1, %k0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    retq
entry:
  %0 = icmp eq i64 %a, 0
  %1 = insertelement <16 x i1> undef, i1 %0, i64 0
  %2 = shufflevector <16 x i1> %1, <16 x i1> undef, <16 x i32> zeroinitializer
  %3 = and <16 x i1> %2, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <16 x i1> %3
}

define <16 x i1> @v16i64_bcst(i64 %a, <16 x i64>* %m) {
; CHECK-LABEL: v16i64_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpq $1, %rdi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <16 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <16 x i64> %0, <16 x i64> undef, <16 x i32> zeroinitializer
  store <16 x i64> %1, <16 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <16 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <16 x i1> %3, <16 x i1> undef, <16 x i32> zeroinitializer
  ret <16 x i1> %4
}

define <16 x i1> @v16i64_and_bcst(i64 %a, <16 x i64>* %m) {
; CHECK-LABEL: v16i64_and_bcst:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpbroadcastq %rdi, %zmm0
; CHECK-NEXT:    vmovdqa64 %zmm0, 64(%rsi)
; CHECK-NEXT:    vmovdqa64 %zmm0, (%rsi)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    cmpq $1, %rdi
; CHECK-NEXT:    sbbl %eax, %eax
; CHECK-NEXT:    kmovd %eax, %k0
; CHECK-NEXT:    movw $21845, %ax # imm = 0x5555
; CHECK-NEXT:    kmovd %eax, %k1
; CHECK-NEXT:    kandw %k1, %k0, %k0
; CHECK-NEXT:    vpmovm2b %k0, %xmm0
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = insertelement <16 x i64> undef, i64 %a, i64 0
  %1 = shufflevector <16 x i64> %0, <16 x i64> undef, <16 x i32> zeroinitializer
  store <16 x i64> %1, <16 x i64>* %m
  %2 = icmp eq i64 %a, 0
  %3 = insertelement <16 x i1> undef, i1 %2, i64 0
  %4 = shufflevector <16 x i1> %3, <16 x i1> undef, <16 x i32> zeroinitializer
  %5 = and <16 x i1> %4, <i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0, i1 1, i1 0>
  ret <16 x i1> %5
}
