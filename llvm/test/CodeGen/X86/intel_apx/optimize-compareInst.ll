; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; REQUIRES: intel_feature_isa_apx_f
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=+ndd -show-mc-encoding | FileCheck %s

@d = dso_local global i8 0, align 1
@d64 = dso_local global i64 0

define i32 @test8(i64 %res) nounwind {
; CHECK-LABEL: test8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    shrq $32, %rdi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0xc1,0xef,0x20]
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    subl $3, %ecx, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x83,0xe9,0x03]
; CHECK-NEXT:    setb %al # encoding: [0x0f,0x92,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %lnot = icmp ult i64 %res, 12884901888
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test11(i64 %l) nounwind {
; CHECK-LABEL: test11:
; CHECK:       # %bb.0:
; CHECK-NEXT:    shrq $47, %rdi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0xc1,0xef,0x2f]
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    subl $1, %ecx, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x83,0xe9,0x01]
; CHECK-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %shr.mask = and i64 %l, -140737488355328
  %cmp = icmp eq i64 %shr.mask, 140737488355328
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; PR19964
define zeroext i1 @test15(i32 %bf.load, i32 %n) {
; CHECK-LABEL: test15:
; CHECK:       # %bb.0:
; CHECK-NEXT:    shrl $16, %edi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0xc1,0xef,0x10]
; CHECK-NEXT:    testl %eax, %eax # encoding: [0x85,0xc0]
; CHECK-NEXT:    sete %cl # encoding: [0x0f,0x94,0xc1]
; CHECK-NEXT:    subl %esi, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x29,0xf0]
; CHECK-NEXT:    setae %al # encoding: [0x0f,0x93,0xc0]
; CHECK-NEXT:    orb %al, %cl, %al # encoding: [0x62,0xf4,0x7c,0x18,0x08,0xc1]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %bf.lshr = lshr i32 %bf.load, 16
  %cmp2 = icmp eq i32 %bf.lshr, 0
  %cmp5 = icmp uge i32 %bf.lshr, %n
  %.cmp5 = or i1 %cmp2, %cmp5
  ret i1 %.cmp5
}

; Make sure we use a 32-bit comparison without an extend based on the input
; being pre-sign extended by caller.
define i32 @pr42189(i16 signext %c) {
; CHECK-LABEL: pr42189:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    subl $32767, %edi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x81,0xef,0xff,0x7f,0x00,0x00]
; CHECK-NEXT:    # imm = 0x7FFF
; CHECK-NEXT:    jne f@PLT # TAILCALL
; CHECK-NEXT:    # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: f@PLT-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    jmp g@PLT # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: g@PLT-1, kind: FK_PCRel_1
entry:
  %cmp = icmp eq i16 %c, 32767
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call i32 @g()
  br label %return

if.end:                                           ; preds = %entry
  %call2 = tail call i32 @f()
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call2, %if.end ]
  ret i32 %retval.0
}

declare i32 @g()
declare i32 @f()

define i32 @lowmask_i64_mask64(i64 %val) {
; CHECK-LABEL: lowmask_i64_mask64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    shlq $16, %rdi # encoding: [0x48,0xc1,0xe7,0x10]
; CHECK-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 281474976710655
  %cmp = icmp eq i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i64 @lowmask_i64_mask64_extra_use(i64 %val) nounwind {
; CHECK-LABEL: lowmask_i64_mask64_extra_use:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    movq %rdi, %rcx # encoding: [0x48,0x89,0xf9]
; CHECK-NEXT:    shlq $16, %rcx # encoding: [0x48,0xc1,0xe1,0x10]
; CHECK-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    imulq %rdi, %rax, %rax # encoding: [0x62,0xf4,0xfc,0x18,0xaf,0xc7]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 281474976710655
  %cmp = icmp eq i64 %and, 0
  %z = zext i1 %cmp to i64
  %ret = mul i64 %z, %val
  ret i64 %ret
}

define i32 @lowmask_i64_mask32(i64 %val) {
; CHECK-LABEL: lowmask_i64_mask32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    shlq $44, %rdi # encoding: [0x48,0xc1,0xe7,0x2c]
; CHECK-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, 1048575
  %cmp = icmp ne i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define i32 @test7(i64 %res) nounwind {
; CHECK-LABEL: test7:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    shrq $32, %rdi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0xc1,0xef,0x20]
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    testq %rcx, %rcx # encoding: [0x48,0x85,0xc9]
; CHECK-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %lnot = icmp ult i64 %res, 4294967296
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test9(i64 %res) nounwind {
; CHECK-LABEL: test9:
; CHECK:       # %bb.0:
; CHECK-NEXT:    shrq $33, %rdi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0xc1,0xef,0x21]
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    testq %rcx, %rcx # encoding: [0x48,0x85,0xc9]
; CHECK-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %lnot = icmp ult i64 %res, 8589934592
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test10(i64 %res) nounwind {
; CHECK-LABEL: test10:
; CHECK:       # %bb.0:
; CHECK-NEXT:    shrq $32, %rdi, %rcx # encoding: [0x62,0xf4,0xf4,0x18,0xc1,0xef,0x20]
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    testq %rcx, %rcx # encoding: [0x48,0x85,0xc9]
; CHECK-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %lnot = icmp uge i64 %res, 4294967296
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define i32 @test14(i32 %mask, i32 %base, i32 %intra) {
; CHECK-LABEL: test14:
; CHECK:       # %bb.0:
; CHECK-NEXT:    shrl $7, %edi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0xc1,0xef,0x07]
; CHECK-NEXT:    testl %eax, %eax # encoding: [0x85,0xc0]
; CHECK-NEXT:    cmovnsl %edx, %esi, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x49,0xf2]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %s = lshr i32 %mask, 7
  %tobool = icmp sgt i32 %s, -1
  %cond = select i1 %tobool, i32 %intra, i32 %base
  ret i32 %cond
}

define i64 @highmask_i64_mask64_extra_use(i64 %val) nounwind {
; CHECK-LABEL: highmask_i64_mask64_extra_use:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    movq %rdi, %rcx # encoding: [0x48,0x89,0xf9]
; CHECK-NEXT:    shrq $41, %rcx # encoding: [0x48,0xc1,0xe9,0x29]
; CHECK-NEXT:    setne %al # encoding: [0x0f,0x95,0xc0]
; CHECK-NEXT:    imulq %rdi, %rax, %rax # encoding: [0x62,0xf4,0xfc,0x18,0xaf,0xc7]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -2199023255552
  %cmp = icmp ne i64 %and, 0
  %z = zext i1 %cmp to i64
  %ret = mul i64 %z, %val
  ret i64 %ret
}

define i32 @highmask_i64_mask32(i64 %val) {
; CHECK-LABEL: highmask_i64_mask32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    shrq $20, %rdi # encoding: [0x48,0xc1,0xef,0x14]
; CHECK-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %and = and i64 %val, -1048576
  %cmp = icmp eq i64 %and, 0
  %ret = zext i1 %cmp to i32
  ret i32 %ret
}

define void @shl(i32 %x) nounwind {
; CHECK-LABEL: shl:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addl %edi, %edi, %edi # encoding: [0x62,0xf4,0x44,0x18,0x01,0xff]
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    jne foo@PLT # TAILCALL
; CHECK-NEXT:    # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo@PLT-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %return
; CHECK-NEXT:    retq # encoding: [0xc3]
  %shl = shl i32 %x, 1
  %cmp = icmp eq i32 %shl, 0
  br i1 %cmp, label %return, label %bb

bb:
  tail call void @foo(i32 %shl)
  br label %return

return:
  ret void
}

define zeroext i1 @adc(i128 %x) nounwind {
; CHECK-LABEL: adc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    movabsq $-9223372036854775808, %rax # encoding: [0x48,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80]
; CHECK-NEXT:    # imm = 0x8000000000000000
; CHECK-NEXT:    addq %rax, %rdi, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x01,0xc7]
; CHECK-NEXT:    adcq $0, %rsi, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x83,0xd6,0x00]
; CHECK-NEXT:    testq %rax, %rax # encoding: [0x48,0x85,0xc0]
; CHECK-NEXT:    sete %al # encoding: [0x0f,0x94,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %add = add i128 %x, 9223372036854775808
  %cmp = icmp ult i128 %add, 18446744073709551616
  ret i1 %cmp
}

define zeroext i1 @sbb(i128 %x, i128 %y) nounwind {
; CHECK-LABEL: sbb:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subq %rdx, %rdi, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x29,0xd7]
; CHECK-NEXT:    sbbq %rcx, %rsi, %rax # encoding: [0x62,0xf4,0xfc,0x18,0x19,0xce]
; CHECK-NEXT:    testq %rax, %rax # encoding: [0x48,0x85,0xc0]
; CHECK-NEXT:    setns %al # encoding: [0x0f,0x99,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
  %sub = sub i128 %x, %y
  %cmp = icmp sge i128 %sub, 0
  ret i1 %cmp
}

define i32 @test4(i32 %a, i32 %b) nounwind  {
; CHECK-LABEL: test4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %edi, %eax # encoding: [0x89,0xf8]
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB16_1: # %bb
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    xorl %esi, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x31,0xf0]
; CHECK-NEXT:    notl %eax, %ecx # encoding: [0x62,0xf4,0x74,0x18,0xf7,0xd0]
; CHECK-NEXT:    andl %esi, %ecx, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x21,0xf1]
; CHECK-NEXT:    addl %ecx, %ecx, %esi # encoding: [0x62,0xf4,0x4c,0x18,0x01,0xc9]
; CHECK-NEXT:    testl %esi, %esi # encoding: [0x85,0xf6]
; CHECK-NEXT:    jne .LBB16_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB16_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %bb12
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  br label %bb
bb:
  %b_addr.0 = phi i32 [ %b, %entry ], [ %tmp8, %bb ]
  %a_addr.0 = phi i32 [ %a, %entry ], [ %tmp3, %bb ]
  %tmp3 = xor i32 %a_addr.0, %b_addr.0
  %tmp4not = xor i32 %tmp3, 2147483647
  %tmp6 = and i32 %tmp4not, %b_addr.0
  %tmp8 = shl i32 %tmp6, 1
  %tmp10 = icmp eq i32 %tmp8, 0
  br i1 %tmp10, label %bb12, label %bb
bb12:
  ret i32 %tmp3
}

define i8 @test6(i8 %a, i8 %b) nounwind  {
; CHECK-LABEL: test6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %edi, %eax # encoding: [0x89,0xf8]
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB17_1: # %bb
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    xorb %sil, %al, %al # encoding: [0x62,0xf4,0x7c,0x18,0x30,0xf0]
; CHECK-NEXT:    notb %al, %cl # encoding: [0x62,0xf4,0x74,0x18,0xf6,0xd0]
; CHECK-NEXT:    andb %sil, %cl, %cl # encoding: [0x62,0xf4,0x74,0x18,0x20,0xf1]
; CHECK-NEXT:    addb %cl, %cl, %sil # encoding: [0x62,0xf4,0x4c,0x18,0x00,0xc9]
; CHECK-NEXT:    testb %sil, %sil # encoding: [0x40,0x84,0xf6]
; CHECK-NEXT:    jne .LBB17_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB17_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %bb12
; CHECK-NEXT:    # kill: def $al killed $al killed $eax
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  br label %bb
bb:
  %b_addr.0 = phi i8 [ %b, %entry ], [ %tmp8, %bb ]
  %a_addr.0 = phi i8 [ %a, %entry ], [ %tmp3, %bb ]
  %tmp3 = xor i8 %a_addr.0, %b_addr.0
  %tmp4not = xor i8 %tmp3, 127
  %tmp6 = and i8 %tmp4not, %b_addr.0
  %tmp8 = shl i8 %tmp6, 1
  %tmp10 = icmp eq i8 %tmp8, 0
  br i1 %tmp10, label %bb12, label %bb
bb12:
  ret i8 %tmp3
}

define i32 @test7_1(i32 %a, i32 %b) nounwind  {
; CHECK-LABEL: test7_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %edi, %eax # encoding: [0x89,0xf8]
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB18_1: # %bb
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    xorl %esi, %eax, %eax # encoding: [0x62,0xf4,0x7c,0x18,0x31,0xf0]
; CHECK-NEXT:    xorl $2147483646, %eax, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x81,0xf0,0xfe,0xff,0xff,0x7f]
; CHECK-NEXT:    # imm = 0x7FFFFFFE
; CHECK-NEXT:    andl %esi, %ecx, %ecx # encoding: [0x62,0xf4,0x74,0x18,0x21,0xf1]
; CHECK-NEXT:    addl %ecx, %ecx, %esi # encoding: [0x62,0xf4,0x4c,0x18,0x01,0xc9]
; CHECK-NEXT:    testl %esi, %esi # encoding: [0x85,0xf6]
; CHECK-NEXT:    jne .LBB18_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB18_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %bb12
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  br label %bb
bb:
  %b_addr.0 = phi i32 [ %b, %entry ], [ %tmp8, %bb ]
  %a_addr.0 = phi i32 [ %a, %entry ], [ %tmp3, %bb ]
  %tmp3 = xor i32 %a_addr.0, %b_addr.0
  %tmp4not = xor i32 %tmp3, 2147483646
  %tmp6 = and i32 %tmp4not, %b_addr.0
  %tmp8 = shl i32 %tmp6, 1
  %tmp10 = icmp eq i32 %tmp8, 0
  br i1 %tmp10, label %bb12, label %bb
bb12:
  ret i32 %tmp3
}

declare void @foo(i32 %shl)
