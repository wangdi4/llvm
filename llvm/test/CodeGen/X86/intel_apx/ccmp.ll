; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; REQUIRES: intel_feature_isa_apx_f
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ccmp -verify-machineinstrs | FileCheck %s

define void @ccmp32rr_zf(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp32rr_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi
; CHECK-NEXT:    ccmpnel {zf} %edx, %esi
; CHECK-NEXT:    jne .LBB0_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB0_1: # %if.end
; CHECK-NEXT:    retq
entry:
  %cmp = icmp eq i32 %a, %c
  %cmp1 = icmp eq i32 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64rr_sf(i64 noundef %a, i64 noundef %b, i64 noundef %c) {
; CHECK-LABEL: ccmp64rr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rdx, %rdi
; CHECK-NEXT:    ccmpleq {sf} %rdx, %rsi
; CHECK-NEXT:    jge .LBB1_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:  .LBB1_1: # %if.end
; CHECK-NEXT:    retq
entry:
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

declare dso_local void @foo(...)
