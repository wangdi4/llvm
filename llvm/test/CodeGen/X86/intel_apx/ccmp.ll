; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ccmp -verify-machineinstrs -show-mc-encoding | FileCheck %s
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ccmp,+ndd -verify-machineinstrs -show-mc-encoding | FileCheck %s --check-prefix=NDD

define void @ccmp8rr_zf(i8 noundef %a, i8 noundef %b, i8 noundef %c) {
; CHECK-LABEL: ccmp8rr_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %dl, %dil # encoding: [0x40,0x38,0xd7]
; CHECK-NEXT:    ccmpneb {zf} %dl, %sil # encoding: [0x62,0xf4,0x14,0x05,0x38,0xd6]
; CHECK-NEXT:    jne .LBB0_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB0_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB0_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp8rr_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %dl, %dil # encoding: [0x40,0x38,0xd7]
; NDD-NEXT:    ccmpneb {zf} %dl, %sil # encoding: [0x62,0xf4,0x14,0x05,0x38,0xd6]
; NDD-NEXT:    jne .LBB0_1 # encoding: [0x75,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB0_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB0_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp eq i8 %a, %c
  %cmp1 = icmp eq i8 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16rr_sf(i16 noundef %a, i16 noundef %b, i16 noundef %c) {
; CHECK-LABEL: ccmp16rr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; CHECK-NEXT:    ccmplew {sf} %dx, %si # encoding: [0x62,0xf4,0x25,0x0e,0x39,0xd6]
; CHECK-NEXT:    jge .LBB1_1 # encoding: [0x7d,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB1_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB1_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp16rr_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; NDD-NEXT:    ccmplew {sf} %dx, %si # encoding: [0x62,0xf4,0x25,0x0e,0x39,0xd6]
; NDD-NEXT:    jge .LBB1_1 # encoding: [0x7d,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB1_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB1_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32rr_cf(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp32rr_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; CHECK-NEXT:    ccmpbl {cf} %edx, %esi # encoding: [0x62,0xf4,0x0c,0x02,0x39,0xd6]
; CHECK-NEXT:    ja .LBB2_1 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB2_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB2_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp32rr_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; NDD-NEXT:    ccmpbl {cf} %edx, %esi # encoding: [0x62,0xf4,0x0c,0x02,0x39,0xd6]
; NDD-NEXT:    ja .LBB2_1 # encoding: [0x77,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB2_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB2_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp uge i32 %a, %c
  %cmp1 = icmp ule i32 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64rr_of(i64 %a, i64 %b) {
; CHECK-LABEL: ccmp64rr_of:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; CHECK-NEXT:    ccmpneq {of} %rsi, %rdi # encoding: [0x62,0xf4,0xc4,0x05,0x39,0xf7]
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp64rr_of:
; NDD:       # %bb.0: # %bb
; NDD-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; NDD-NEXT:    ccmpneq {of} %rsi, %rdi # encoding: [0x62,0xf4,0xc4,0x05,0x39,0xf7]
; NDD-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp eq i64 %a, 0
  br i1 %cond1, label %bb3, label %bb1

bb1:                                              ; preds = %bb
  %smul = call {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)
  %obit = extractvalue {i64, i1} %smul, 1
  br i1 %obit, label %bb3, label %bb2

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ccmp8ri_zf(i8 noundef %a, i8 noundef %b, i8 noundef %c) {
; CHECK-LABEL: ccmp8ri_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %dl, %dil # encoding: [0x40,0x38,0xd7]
; CHECK-NEXT:    ccmpleb {zf} $123, %sil # encoding: [0x62,0xf4,0x14,0x0e,0x80,0xfe,0x7b]
; CHECK-NEXT:    jne .LBB4_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB4_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB4_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp8ri_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %dl, %dil # encoding: [0x40,0x38,0xd7]
; NDD-NEXT:    ccmpleb {zf} $123, %sil # encoding: [0x62,0xf4,0x14,0x0e,0x80,0xfe,0x7b]
; NDD-NEXT:    jne .LBB4_1 # encoding: [0x75,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB4_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB4_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp sgt i8 %a, %c
  %cmp1 = icmp eq i8 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16ri8_zf(i16 noundef %a, i16 noundef %b, i16 noundef %c) {
; CHECK-LABEL: ccmp16ri8_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; CHECK-NEXT:    ccmplew {zf} $122, %si # encoding: [0x62,0xf4,0x15,0x0e,0x83,0xfe,0x7a]
; CHECK-NEXT:    jg .LBB5_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB5_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB5_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp16ri8_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; NDD-NEXT:    ccmplew {zf} $122, %si # encoding: [0x62,0xf4,0x15,0x0e,0x83,0xfe,0x7a]
; NDD-NEXT:    jg .LBB5_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB5_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB5_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32ri8_cf(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp32ri8_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; CHECK-NEXT:    ccmpal {cf} $123, %esi # encoding: [0x62,0xf4,0x0c,0x07,0x83,0xfe,0x7b]
; CHECK-NEXT:    ja .LBB6_1 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB6_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB6_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp32ri8_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; NDD-NEXT:    ccmpal {cf} $123, %esi # encoding: [0x62,0xf4,0x0c,0x07,0x83,0xfe,0x7b]
; NDD-NEXT:    ja .LBB6_1 # encoding: [0x77,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB6_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB6_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp ule i32 %a, %c
  %cmp1 = icmp ule i32 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64ri8_zf(i64 noundef %a, i64 noundef %b, i64 noundef %c) {
; CHECK-LABEL: ccmp64ri8_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rdx, %rdi # encoding: [0x48,0x39,0xd7]
; CHECK-NEXT:    ccmpleq {zf} $122, %rsi # encoding: [0x62,0xf4,0x94,0x0e,0x83,0xfe,0x7a]
; CHECK-NEXT:    jg .LBB7_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB7_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB7_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp64ri8_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rdx, %rdi # encoding: [0x48,0x39,0xd7]
; NDD-NEXT:    ccmpleq {zf} $122, %rsi # encoding: [0x62,0xf4,0x94,0x0e,0x83,0xfe,0x7a]
; NDD-NEXT:    jg .LBB7_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB7_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB7_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16ri_zf(i16 noundef %a, i16 noundef %b, i16 noundef %c) {
; CHECK-LABEL: ccmp16ri_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; CHECK-NEXT:    movswl %si, %eax # encoding: [0x0f,0xbf,0xc6]
; CHECK-NEXT:    ccmpael {zf} $1233, %eax # encoding: [0x62,0xf4,0x14,0x03,0x81,0xf8,0xd1,0x04,0x00,0x00]
; CHECK-NEXT:    # imm = 0x4D1
; CHECK-NEXT:    jg .LBB8_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB8_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB8_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp16ri_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; NDD-NEXT:    movswl %si, %eax # encoding: [0x0f,0xbf,0xc6]
; NDD-NEXT:    ccmpael {zf} $1233, %eax # encoding: [0x62,0xf4,0x14,0x03,0x81,0xf8,0xd1,0x04,0x00,0x00]
; NDD-NEXT:    # imm = 0x4D1
; NDD-NEXT:    jg .LBB8_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB8_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB8_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp ult i16 %a, %c
  %cmp1 = icmp slt i16 %b, 1234
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32ri_cf(i32 noundef %a, i32 noundef %b, i32 noundef %c) {
; CHECK-LABEL: ccmp32ri_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; CHECK-NEXT:    ccmpbl {cf} $123456, %esi # encoding: [0x62,0xf4,0x0c,0x02,0x81,0xfe,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    ja .LBB9_1 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB9_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB9_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp32ri_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; NDD-NEXT:    ccmpbl {cf} $123456, %esi # encoding: [0x62,0xf4,0x0c,0x02,0x81,0xfe,0x40,0xe2,0x01,0x00]
; NDD-NEXT:    # imm = 0x1E240
; NDD-NEXT:    ja .LBB9_1 # encoding: [0x77,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB9_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB9_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp uge i32 %a, %c
  %cmp1 = icmp ule i32 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64ri32_zf(i64 noundef %a, i64 noundef %b, i64 noundef %c) {
; CHECK-LABEL: ccmp64ri32_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rdx, %rdi # encoding: [0x48,0x39,0xd7]
; CHECK-NEXT:    ccmpbeq {zf} $123455, %rsi # encoding: [0x62,0xf4,0x94,0x06,0x81,0xfe,0x3f,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E23F
; CHECK-NEXT:    jg .LBB10_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB10_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB10_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp64ri32_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rdx, %rdi # encoding: [0x48,0x39,0xd7]
; NDD-NEXT:    ccmpbeq {zf} $123455, %rsi # encoding: [0x62,0xf4,0x94,0x06,0x81,0xfe,0x3f,0xe2,0x01,0x00]
; NDD-NEXT:    # imm = 0x1E23F
; NDD-NEXT:    jg .LBB10_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB10_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB10_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %cmp = icmp ugt i64 %a, %c
  %cmp1 = icmp slt i64 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp8rm_zf(i8 noundef %a, i8 noundef %b, i8 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp8rm_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %dl, %dil # encoding: [0x40,0x38,0xd7]
; CHECK-NEXT:    ccmpneb {zf} (%rcx), %sil # encoding: [0x62,0xf4,0x14,0x05,0x3a,0x31]
; CHECK-NEXT:    jne .LBB11_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB11_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB11_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp8rm_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %dl, %dil # encoding: [0x40,0x38,0xd7]
; NDD-NEXT:    ccmpneb {zf} (%rcx), %sil # encoding: [0x62,0xf4,0x14,0x05,0x3a,0x31]
; NDD-NEXT:    jne .LBB11_1 # encoding: [0x75,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB11_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB11_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i8, ptr %ptr
  %cmp = icmp eq i8 %a, %c
  %cmp1 = icmp eq i8 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16rm_sf(i16 noundef %a, i16 noundef %b, i16 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp16rm_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; CHECK-NEXT:    ccmplew {sf} (%rcx), %si # encoding: [0x62,0xf4,0x25,0x0e,0x3b,0x31]
; CHECK-NEXT:    jge .LBB12_1 # encoding: [0x7d,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB12_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB12_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp16rm_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %dx, %di # encoding: [0x66,0x39,0xd7]
; NDD-NEXT:    ccmplew {sf} (%rcx), %si # encoding: [0x62,0xf4,0x25,0x0e,0x3b,0x31]
; NDD-NEXT:    jge .LBB12_1 # encoding: [0x7d,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB12_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB12_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i16, ptr %ptr
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32rm_cf(i32 noundef %a, i32 noundef %b, i32 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp32rm_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; CHECK-NEXT:    ccmpgl {cf} (%rcx), %esi # encoding: [0x62,0xf4,0x0c,0x0f,0x3b,0x31]
; CHECK-NEXT:    ja .LBB13_1 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB13_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB13_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp32rm_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %edx, %edi # encoding: [0x39,0xd7]
; NDD-NEXT:    ccmpgl {cf} (%rcx), %esi # encoding: [0x62,0xf4,0x0c,0x0f,0x3b,0x31]
; NDD-NEXT:    ja .LBB13_1 # encoding: [0x77,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB13_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB13_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i32, ptr %ptr
  %cmp = icmp sle i32 %a, %c
  %cmp1 = icmp ule i32 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64rm_sf(i64 noundef %a, i64 noundef %b, i64 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp64rm_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rdx, %rdi # encoding: [0x48,0x39,0xd7]
; CHECK-NEXT:    ccmpleq {sf} (%rcx), %rsi # encoding: [0x62,0xf4,0xa4,0x0e,0x3b,0x31]
; CHECK-NEXT:    jge .LBB14_1 # encoding: [0x7d,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB14_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB14_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp64rm_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rdx, %rdi # encoding: [0x48,0x39,0xd7]
; NDD-NEXT:    ccmpleq {sf} (%rcx), %rsi # encoding: [0x62,0xf4,0xa4,0x0e,0x3b,0x31]
; NDD-NEXT:    jge .LBB14_1 # encoding: [0x7d,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB14_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB14_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i64, ptr %ptr
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, %d
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp8mr_zf(i8 noundef %a, i8 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp8mr_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %sil, %dil # encoding: [0x40,0x38,0xf7]
; CHECK-NEXT:    ccmpgeb {zf} %sil, (%rdx) # encoding: [0x62,0xf4,0x14,0x0d,0x38,0x32]
; CHECK-NEXT:    jne .LBB15_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB15_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB15_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp8mr_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %sil, %dil # encoding: [0x40,0x38,0xf7]
; NDD-NEXT:    ccmpgeb {zf} %sil, (%rdx) # encoding: [0x62,0xf4,0x14,0x0d,0x38,0x32]
; NDD-NEXT:    jne .LBB15_1 # encoding: [0x75,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB15_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB15_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i8, ptr %ptr
  %cmp = icmp slt i8 %a, %c
  %cmp1 = icmp eq i8 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16mr_sf(i16 noundef %a, i16 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp16mr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %si, %di # encoding: [0x66,0x39,0xf7]
; CHECK-NEXT:    ccmplew {sf} %si, (%rdx) # encoding: [0x62,0xf4,0x25,0x0e,0x39,0x32]
; CHECK-NEXT:    jge .LBB16_1 # encoding: [0x7d,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB16_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB16_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp16mr_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %si, %di # encoding: [0x66,0x39,0xf7]
; NDD-NEXT:    ccmplew {sf} %si, (%rdx) # encoding: [0x62,0xf4,0x25,0x0e,0x39,0x32]
; NDD-NEXT:    jge .LBB16_1 # encoding: [0x7d,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB16_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB16_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i16, ptr %ptr
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32mr_cf(i32 noundef %a, i32 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp32mr_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; CHECK-NEXT:    ccmpll {cf} %esi, (%rdx) # encoding: [0x62,0xf4,0x0c,0x0c,0x39,0x32]
; CHECK-NEXT:    ja .LBB17_1 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB17_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB17_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp32mr_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; NDD-NEXT:    ccmpll {cf} %esi, (%rdx) # encoding: [0x62,0xf4,0x0c,0x0c,0x39,0x32]
; NDD-NEXT:    ja .LBB17_1 # encoding: [0x77,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB17_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB17_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i32, ptr %ptr
  %cmp = icmp sge i32 %a, %c
  %cmp1 = icmp ule i32 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64mr_sf(i64 noundef %a, i64 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp64mr_sf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rsi, %rdi # encoding: [0x48,0x39,0xf7]
; CHECK-NEXT:    ccmpleq {sf} %rsi, (%rdx) # encoding: [0x62,0xf4,0xa4,0x0e,0x39,0x32]
; CHECK-NEXT:    jge .LBB18_1 # encoding: [0x7d,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB18_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB18_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp64mr_sf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rsi, %rdi # encoding: [0x48,0x39,0xf7]
; NDD-NEXT:    ccmpleq {sf} %rsi, (%rdx) # encoding: [0x62,0xf4,0xa4,0x0e,0x39,0x32]
; NDD-NEXT:    jge .LBB18_1 # encoding: [0x7d,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB18_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB18_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i64, ptr %ptr
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, %c
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp8mi_zf(i8 noundef %a, i8 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp8mi_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb %sil, %dil # encoding: [0x40,0x38,0xf7]
; CHECK-NEXT:    ccmpneb {zf} $123, (%rdx) # encoding: [0x62,0xf4,0x14,0x05,0x80,0x3a,0x7b]
; CHECK-NEXT:    jne .LBB19_1 # encoding: [0x75,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB19_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB19_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp8mi_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpb %sil, %dil # encoding: [0x40,0x38,0xf7]
; NDD-NEXT:    ccmpneb {zf} $123, (%rdx) # encoding: [0x62,0xf4,0x14,0x05,0x80,0x3a,0x7b]
; NDD-NEXT:    jne .LBB19_1 # encoding: [0x75,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB19_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB19_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i8, ptr %ptr
  %cmp = icmp eq i8 %a, %c
  %cmp1 = icmp eq i8 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16mi8_zf(i16 noundef %a, i16 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp16mi8_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %si, %di # encoding: [0x66,0x39,0xf7]
; CHECK-NEXT:    ccmplew {zf} $122, (%rdx) # encoding: [0x62,0xf4,0x15,0x0e,0x83,0x3a,0x7a]
; CHECK-NEXT:    jg .LBB20_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB20_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB20_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp16mi8_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %si, %di # encoding: [0x66,0x39,0xf7]
; NDD-NEXT:    ccmplew {zf} $122, (%rdx) # encoding: [0x62,0xf4,0x15,0x0e,0x83,0x3a,0x7a]
; NDD-NEXT:    jg .LBB20_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB20_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB20_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i16, ptr %ptr
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32mi8_cf(i32 noundef %a, i32 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp32mi8_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; CHECK-NEXT:    ccmpnel {cf} $123, (%rdx) # encoding: [0x62,0xf4,0x0c,0x05,0x83,0x3a,0x7b]
; CHECK-NEXT:    ja .LBB21_1 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB21_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB21_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp32mi8_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; NDD-NEXT:    ccmpnel {cf} $123, (%rdx) # encoding: [0x62,0xf4,0x0c,0x05,0x83,0x3a,0x7b]
; NDD-NEXT:    ja .LBB21_1 # encoding: [0x77,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB21_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB21_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i32, ptr %ptr
  %cmp = icmp eq i32 %a, %c
  %cmp1 = icmp ule i32 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64mi8_zf(i64 noundef %a, i64 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp64mi8_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rsi, %rdi # encoding: [0x48,0x39,0xf7]
; CHECK-NEXT:    ccmpleq {zf} $122, (%rdx) # encoding: [0x62,0xf4,0x94,0x0e,0x83,0x3a,0x7a]
; CHECK-NEXT:    jg .LBB22_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB22_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB22_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp64mi8_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rsi, %rdi # encoding: [0x48,0x39,0xf7]
; NDD-NEXT:    ccmpleq {zf} $122, (%rdx) # encoding: [0x62,0xf4,0x94,0x0e,0x83,0x3a,0x7a]
; NDD-NEXT:    jg .LBB22_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB22_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB22_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i64, ptr %ptr
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, 123
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp16mi_zf(i16 noundef %a, i16 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp16mi_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpw %si, %di # encoding: [0x66,0x39,0xf7]
; CHECK-NEXT:    movswl (%rdx), %eax # encoding: [0x0f,0xbf,0x02]
; TODO: Could we generate ccmplew {zf} $1233, (%rdx)?
; CHECK-NEXT:    ccmplel {zf} $1233, %eax # encoding: [0x62,0xf4,0x14,0x0e,0x81,0xf8,0xd1,0x04,0x00,0x00]
; CHECK-NEXT:    # imm = 0x4D1
; CHECK-NEXT:    jg .LBB23_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB23_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB23_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp16mi_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpw %si, %di # encoding: [0x66,0x39,0xf7]
; NDD-NEXT:    movswl (%rdx), %eax # encoding: [0x0f,0xbf,0x02]
; TODO: Could we generate ccmplew {zf} $1233, (%rdx)?
; NDD-NEXT:    ccmplel {zf} $1233, %eax # encoding: [0x62,0xf4,0x14,0x0e,0x81,0xf8,0xd1,0x04,0x00,0x00]
; NDD-NEXT:    # imm = 0x4D1
; NDD-NEXT:    jg .LBB23_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB23_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB23_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i16, ptr %ptr
  %cmp = icmp sgt i16 %a, %c
  %cmp1 = icmp slt i16 %b, 1234
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp32mi_cf(i32 noundef %a, i32 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp32mi_cf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; CHECK-NEXT:    ccmpnel {cf} $123456, (%rdx) # encoding: [0x62,0xf4,0x0c,0x05,0x81,0x3a,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    ja .LBB24_1 # encoding: [0x77,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB24_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB24_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp32mi_cf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpl %esi, %edi # encoding: [0x39,0xf7]
; NDD-NEXT:    ccmpnel {cf} $123456, (%rdx) # encoding: [0x62,0xf4,0x0c,0x05,0x81,0x3a,0x40,0xe2,0x01,0x00]
; NDD-NEXT:    # imm = 0x1E240
; NDD-NEXT:    ja .LBB24_1 # encoding: [0x77,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB24_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB24_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i32, ptr %ptr
  %cmp = icmp eq i32 %a, %c
  %cmp1 = icmp ule i32 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

define void @ccmp64mi32_zf(i64 noundef %a, i64 noundef %c, ptr %ptr) {
; CHECK-LABEL: ccmp64mi32_zf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq %rsi, %rdi # encoding: [0x48,0x39,0xf7]
; CHECK-NEXT:    ccmpleq {zf} $123455, (%rdx) # encoding: [0x62,0xf4,0x94,0x0e,0x81,0x3a,0x3f,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E23F
; CHECK-NEXT:    jg .LBB25_1 # encoding: [0x7f,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB25_1-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.2: # %if.then
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    jmp foo # TAILCALL
; CHECK-NEXT:    # encoding: [0xeb,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; CHECK-NEXT:  .LBB25_1: # %if.end
; CHECK-NEXT:    retq # encoding: [0xc3]
;
; NDD-LABEL: ccmp64mi32_zf:
; NDD:       # %bb.0: # %entry
; NDD-NEXT:    cmpq %rsi, %rdi # encoding: [0x48,0x39,0xf7]
; NDD-NEXT:    ccmpleq {zf} $123455, (%rdx) # encoding: [0x62,0xf4,0x94,0x0e,0x81,0x3a,0x3f,0xe2,0x01,0x00]
; NDD-NEXT:    # imm = 0x1E23F
; NDD-NEXT:    jg .LBB25_1 # encoding: [0x7f,A]
; NDD-NEXT:    # fixup A - offset: 1, value: .LBB25_1-1, kind: FK_PCRel_1
; NDD-NEXT:  # %bb.2: # %if.then
; NDD-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; NDD-NEXT:    jmp foo # TAILCALL
; NDD-NEXT:    # encoding: [0xeb,A]
; NDD-NEXT:    # fixup A - offset: 1, value: foo-1, kind: FK_PCRel_1
; NDD-NEXT:  .LBB25_1: # %if.end
; NDD-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i64, ptr %ptr
  %cmp = icmp sgt i64 %a, %c
  %cmp1 = icmp slt i64 %b, 123456
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void (...) @foo()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret void
}

declare dso_local void @foo(...)
declare {i64, i1} @llvm.ssub.with.overflow.i64(i64, i64) nounwind readnone
