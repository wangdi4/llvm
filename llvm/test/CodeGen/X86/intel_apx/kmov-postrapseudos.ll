; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; REQUIRES: intel_feature_isa_apx_f
; RUN: llc < %s -mtriple=x86_64-unknown -stop-after=postrapseudos -mattr=+avx512f,+egpr | FileCheck --check-prefix=AVX512 %s
; RUN: llc < %s -mtriple=x86_64-unknown -stop-after=postrapseudos -mattr=+avx512f,+avx512bw,+egpr | FileCheck --check-prefix=AVX512BW %s

define void @kmovkr_1(i1 %cmp23.not) {
  ; AVX512-LABEL: name: kmovkr_1
  ; AVX512: bb.0.entry:
  ; AVX512-NEXT:   liveins: $edi
  ; AVX512-NEXT: {{  $}}
  ; AVX512-NEXT:   $k1 = KMOVWkr_EVEX killed $edi
  ; AVX512-NEXT:   renamable $xmm0 = VMOVSDZrmkz killed renamable $k1, $rip, 1, $noreg, %const.0, $noreg :: (load (s64) from constant-pool)
  ; AVX512-NEXT:   VMOVSDZmr $noreg, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s64) into `ptr null`)
  ; AVX512-NEXT:   RET 0
  ; AVX512BW-LABEL: name: kmovkr_1
  ; AVX512BW: bb.0.entry:
  ; AVX512BW-NEXT:   liveins: $edi
  ; AVX512BW-NEXT: {{  $}}
  ; AVX512BW-NEXT:   $k1 = KMOVDkr_EVEX killed $edi
  ; AVX512BW-NEXT:   renamable $xmm0 = VMOVSDZrmkz killed renamable $k1, $rip, 1, $noreg, %const.0, $noreg :: (load (s64) from constant-pool)
  ; AVX512BW-NEXT:   VMOVSDZmr $noreg, 1, $noreg, 0, $noreg, killed renamable $xmm0 :: (store (s64) into `ptr null`)
  ; AVX512BW-NEXT:   RET 0
entry:
  %0 = select i1 %cmp23.not, double 1.000000e+00, double 0.000000e+00
  store double %0, ptr null, align 8
  ret void
}

define void @kmovkr_2() {
  ; AVX512-LABEL: name: kmovkr_2
  ; AVX512: bb.0.alloca_21:
  ; AVX512-NEXT:   $xmm0 = VXORPSrr undef $xmm0, undef $xmm0, implicit-def $zmm0
  ; AVX512-NEXT:   renamable $ax = MOV16ri 3, implicit-def $eax
  ; AVX512-NEXT:   $k1 = KMOVWkr_EVEX killed $eax
  ; AVX512-NEXT:   VMOVUPSZmrk $noreg, 1, $noreg, 0, $noreg, killed renamable $k1, killed renamable $zmm0 :: (store unknown-size into `ptr null`, align 1)
  ; AVX512-NEXT:   RET 0
  ; AVX512BW-LABEL: name: kmovkr_2
  ; AVX512BW: bb.0.alloca_21:
  ; AVX512BW-NEXT:   $xmm0 = VXORPSrr undef $xmm0, undef $xmm0, implicit-def $zmm0
  ; AVX512BW-NEXT:   renamable $ax = MOV16ri 3, implicit-def $eax
  ; AVX512BW-NEXT:   $k1 = KMOVDkr_EVEX killed $eax
  ; AVX512BW-NEXT:   VMOVUPSZmrk $noreg, 1, $noreg, 0, $noreg, killed renamable $k1, killed renamable $zmm0 :: (store unknown-size into `ptr null`, align 1)
  ; AVX512BW-NEXT:   RET 0
alloca_21:
  call void @llvm.masked.store.v4f32.p0(<4 x float> zeroinitializer, ptr null, i32 1, <4 x i1> <i1 true, i1 true, i1 false, i1 false>)
  ret void
}

declare void @llvm.masked.store.v4f32.p0(<4 x float>, ptr nocapture, i32 immarg, <4 x i1>)
