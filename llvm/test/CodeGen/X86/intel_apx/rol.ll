; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ndd -verify-machineinstrs | FileCheck %s

define i8 @rol8m1(ptr %ptr) {
; CHECK-LABEL: rol8m1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolb (%rdi), %al
; CHECK-NEXT:    retq
entry:
  %a = load i8, ptr %ptr
  %0 = shl i8 %a, 1
  %1 = lshr i8 %a, 7
  %rol = or i8 %0, %1
  ret i8 %rol
}

define i16 @rol16m1(ptr %ptr) {
; CHECK-LABEL: rol16m1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolw (%rdi), %ax
; CHECK-NEXT:    retq
entry:
  %a = load i16, ptr %ptr
  %0 = shl i16 %a, 1
  %1 = lshr i16 %a, 15
  %rol = or i16 %0, %1
  ret i16 %rol
}

define i32 @rol32m1(ptr %ptr) {
; CHECK-LABEL: rol32m1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    roll (%rdi), %eax
; CHECK-NEXT:    retq
entry:
  %a = load i32, ptr %ptr
  %0 = shl i32 %a, 1
  %1 = lshr i32 %a, 31
  %rol = or i32 %0, %1
  ret i32 %rol
}

define i64 @rol64m1(ptr %ptr) {
; CHECK-LABEL: rol64m1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolq (%rdi), %rax
; CHECK-NEXT:    retq
entry:
  %a = load i64, ptr %ptr
  %0 = shl i64 %a, 1
  %1 = lshr i64 %a, 63
  %rol = or i64 %0, %1
  ret i64 %rol
}

define i8 @rol8mcl(ptr %ptr, i8 %cl) {
; CHECK-LABEL: rol8mcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    rolb %cl, (%rdi), %al
; CHECK-NEXT:    retq
entry:
  %a = load i8, ptr %ptr
  %0 = shl i8 %a, %cl
  %1 = sub i8 8, %cl
  %2 = lshr i8 %a, %1
  %rol = or i8 %0, %2
  ret i8 %rol
}

define i16 @rol16mcl(ptr %ptr, i16 %cl) {
; CHECK-LABEL: rol16mcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    rolw %cl, (%rdi), %ax
; CHECK-NEXT:    retq
entry:
  %a = load i16, ptr %ptr
  %0 = shl i16 %a, %cl
  %1 = sub i16 16, %cl
  %2 = lshr i16 %a, %1
  %rol = or i16 %0, %2
  ret i16 %rol
}

define i32 @rol32mcl(ptr %ptr, i32 %cl) {
; CHECK-LABEL: rol32mcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    roll %cl, (%rdi), %eax
; CHECK-NEXT:    retq
entry:
  %a = load i32, ptr %ptr
  %0 = shl i32 %a, %cl
  %1 = sub i32 32, %cl
  %2 = lshr i32 %a, %1
  %rol = or i32 %0, %2
  ret i32 %rol
}

define i64 @rol64mcl(ptr %ptr, i64 %cl) {
; CHECK-LABEL: rol64mcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %rsi, %rcx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $rcx
; CHECK-NEXT:    rolq %cl, (%rdi), %rax
; CHECK-NEXT:    retq
entry:
  %a = load i64, ptr %ptr
  %0 = shl i64 %a, %cl
  %1 = sub i64 64, %cl
  %2 = lshr i64 %a, %1
  %rol = or i64 %0, %2
  ret i64 %rol
}

define i8 @rol8mi(ptr %ptr) {
; CHECK-LABEL: rol8mi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolb $3, (%rdi), %al
; CHECK-NEXT:    retq
entry:
  %a = load i8, ptr %ptr
  %0 = shl i8 %a, 3
  %1 = lshr i8 %a, 5
  %rol = or i8 %0, %1
  ret i8 %rol
}

define i16 @rol16mi(ptr %ptr) {
; CHECK-LABEL: rol16mi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolw $3, (%rdi), %ax
; CHECK-NEXT:    retq
entry:
  %a = load i16, ptr %ptr
  %0 = shl i16 %a, 3
  %1 = lshr i16 %a, 13
  %rol = or i16 %0, %1
  ret i16 %rol
}

define i32 @rol32mi(ptr %ptr) {
; CHECK-LABEL: rol32mi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    roll $3, (%rdi), %eax
; CHECK-NEXT:    retq
entry:
  %a = load i32, ptr %ptr
  %0 = shl i32 %a, 3
  %1 = lshr i32 %a, 29
  %rol = or i32 %0, %1
  ret i32 %rol
}

define i64 @rol64mi(ptr %ptr) {
; CHECK-LABEL: rol64mi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolq $3, (%rdi), %rax
; CHECK-NEXT:    retq
entry:
  %a = load i64, ptr %ptr
  %0 = shl i64 %a, 3
  %1 = lshr i64 %a, 61
  %rol = or i64 %0, %1
  ret i64 %rol
}

define i8 @rol8r1(i8 noundef %a) {
; CHECK-LABEL: rol8r1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolb %dil, %al
; CHECK-NEXT:    retq
entry:
  %0 = shl i8 %a, 1
  %1 = lshr i8 %a, 7
  %rol = or i8 %0, %1
  ret i8 %rol
}

define i16 @rol16r1(i16 noundef %a) {
; CHECK-LABEL: rol16r1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolw %di, %ax
; CHECK-NEXT:    retq
entry:
  %0 = shl i16 %a, 1
  %1 = lshr i16 %a, 15
  %rol = or i16 %0, %1
  ret i16 %rol
}

define i32 @rol32r1(i32 noundef %a) {
; CHECK-LABEL: rol32r1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    roll %edi, %eax
; CHECK-NEXT:    retq
entry:
  %0 = shl i32 %a, 1
  %1 = lshr i32 %a, 31
  %rol = or i32 %0, %1
  ret i32 %rol
}

define i64 @rol64r1(i64 noundef %a) {
; CHECK-LABEL: rol64r1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolq %rdi, %rax
; CHECK-NEXT:    retq
entry:
  %0 = shl i64 %a, 1
  %1 = lshr i64 %a, 63
  %rol = or i64 %0, %1
  ret i64 %rol
}

define i8 @rol8rcl(i8 noundef %a, i8 %cl) {
; CHECK-LABEL: rol8rcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    rolb %cl, %dil, %al
; CHECK-NEXT:    retq
entry:
  %0 = shl i8 %a, %cl
  %1 = sub i8 8, %cl
  %2 = lshr i8 %a, %1
  %rol = or i8 %0, %2
  ret i8 %rol
}

define i16 @rol16rcl(i16 noundef %a, i16 %cl) {
; CHECK-LABEL: rol16rcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    rolw %cl, %di, %ax
; CHECK-NEXT:    retq
entry:
  %0 = shl i16 %a, %cl
  %1 = sub i16 16, %cl
  %2 = lshr i16 %a, %1
  %rol = or i16 %0, %2
  ret i16 %rol
}

define i32 @rol32rcl(i32 noundef %a, i32 %cl) {
; CHECK-LABEL: rol32rcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    roll %cl, %edi, %eax
; CHECK-NEXT:    retq
entry:
  %0 = shl i32 %a, %cl
  %1 = sub i32 32, %cl
  %2 = lshr i32 %a, %1
  %rol = or i32 %0, %2
  ret i32 %rol
}

define i64 @rol64rcl(i64 noundef %a, i64 %cl) {
; CHECK-LABEL: rol64rcl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %rsi, %rcx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $rcx
; CHECK-NEXT:    rolq %cl, %rdi, %rax
; CHECK-NEXT:    retq
entry:
  %0 = shl i64 %a, %cl
  %1 = sub i64 64, %cl
  %2 = lshr i64 %a, %1
  %rol = or i64 %0, %2
  ret i64 %rol
}

define i8 @rol8ri(i8 noundef %a) {
; CHECK-LABEL: rol8ri:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolb $3, %dil, %al
; CHECK-NEXT:    retq
entry:
  %0 = shl i8 %a, 3
  %1 = lshr i8 %a, 5
  %rol = or i8 %0, %1
  ret i8 %rol
}

define i16 @rol16ri(i16 noundef %a) {
; CHECK-LABEL: rol16ri:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolw $3, %di, %ax
; CHECK-NEXT:    retq
entry:
  %0 = shl i16 %a, 3
  %1 = lshr i16 %a, 13
  %rol = or i16 %0, %1
  ret i16 %rol
}

define i32 @rol32ri(i32 noundef %a) {
; CHECK-LABEL: rol32ri:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    roll $3, %edi, %eax
; CHECK-NEXT:    retq
entry:
  %0 = shl i32 %a, 3
  %1 = lshr i32 %a, 29
  %rol = or i32 %0, %1
  ret i32 %rol
}

define i64 @rol64ri(i64 noundef %a) {
; CHECK-LABEL: rol64ri:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolq $3, %rdi, %rax
; CHECK-NEXT:    retq
entry:
  %0 = shl i64 %a, 3
  %1 = lshr i64 %a, 61
  %rol = or i64 %0, %1
  ret i64 %rol
}

define void @rol8m1_legacy(ptr %ptr) {
; CHECK-LABEL: rol8m1_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolb (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i8, ptr %ptr
  %0 = shl i8 %a, 1
  %1 = lshr i8 %a, 7
  %rol = or i8 %0, %1
  store i8 %rol, ptr %ptr
  ret void
}

define void @rol16m1_legacy(ptr %ptr) {
; CHECK-LABEL: rol16m1_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movzwl (%rdi), %eax
; CHECK-NEXT:    addl %eax, %eax, %ecx
; CHECK-NEXT:    shrl $7, %eax
; CHECK-NEXT:    orl %ecx, %eax
; CHECK-NEXT:    movw %ax, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i16, ptr %ptr
  %0 = shl i16 %a, 1
  %1 = lshr i16 %a, 7
  %rol = or i16 %0, %1
  store i16 %rol, ptr %ptr
  ret void
}

define void @rol32m1_legacy(ptr %ptr) {
; CHECK-LABEL: rol32m1_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl (%rdi), %eax
; CHECK-NEXT:    addl %eax, %eax, %ecx
; CHECK-NEXT:    shrl $7, %eax
; CHECK-NEXT:    orl %ecx, %eax
; CHECK-NEXT:    movl %eax, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i32, ptr %ptr
  %0 = shl i32 %a, 1
  %1 = lshr i32 %a, 7
  %rol = or i32 %0, %1
  store i32 %rol, ptr %ptr
  ret void
}

define void @rol64m1_legacy(ptr %ptr) {
; CHECK-LABEL: rol64m1_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq (%rdi), %rax
; CHECK-NEXT:    addq %rax, %rax, %rcx
; CHECK-NEXT:    shrq $7, %rax
; CHECK-NEXT:    orq %rcx, %rax
; CHECK-NEXT:    movq %rax, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i64, ptr %ptr
  %0 = shl i64 %a, 1
  %1 = lshr i64 %a, 7
  %rol = or i64 %0, %1
  store i64 %rol, ptr %ptr
  ret void
}

define void @rol8mcl_legacy(ptr %ptr, i8 %cl) {
; CHECK-LABEL: rol8mcl_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    rolb %cl, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i8, ptr %ptr
  %0 = shl i8 %a, %cl
  %1 = sub i8 8, %cl
  %2 = lshr i8 %a, %1
  %rol = or i8 %0, %2
  store i8 %rol, ptr %ptr
  ret void
}

define void @rol16mcl_legacy(ptr %ptr, i16 %cl) {
; CHECK-LABEL: rol16mcl_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    rolw %cl, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i16, ptr %ptr
  %0 = shl i16 %a, %cl
  %1 = sub i16 16, %cl
  %2 = lshr i16 %a, %1
  %rol = or i16 %0, %2
  store i16 %rol, ptr %ptr
  ret void
}

define void @rol32mcl_legacy(ptr %ptr, i32 %cl) {
; CHECK-LABEL: rol32mcl_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $ecx
; CHECK-NEXT:    roll %cl, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i32, ptr %ptr
  %0 = shl i32 %a, %cl
  %1 = sub i32 32, %cl
  %2 = lshr i32 %a, %1
  %rol = or i32 %0, %2
  store i32 %rol, ptr %ptr
  ret void
}

define void @rol64mcl_legacy(ptr %ptr, i64 %cl) {
; CHECK-LABEL: rol64mcl_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq %rsi, %rcx
; CHECK-NEXT:    # kill: def $cl killed $cl killed $rcx
; CHECK-NEXT:    rolq %cl, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i64, ptr %ptr
  %0 = shl i64 %a, %cl
  %1 = sub i64 64, %cl
  %2 = lshr i64 %a, %1
  %rol = or i64 %0, %2
  store i64 %rol, ptr %ptr
  ret void
}

define void @rol8mi_legacy(ptr %ptr) {
; CHECK-LABEL: rol8mi_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    rolb $3, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i8, ptr %ptr
  %0 = shl i8 %a, 3
  %1 = lshr i8 %a, 5
  %rol = or i8 %0, %1
  store i8 %rol, ptr %ptr
  ret void
}

define void @rol16mi_legacy(ptr %ptr) {
; CHECK-LABEL: rol16mi_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movzwl (%rdi), %eax
; CHECK-NEXT:    shll $3, %eax, %ecx
; CHECK-NEXT:    shrl $5, %eax
; CHECK-NEXT:    orl %ecx, %eax
; CHECK-NEXT:    movw %ax, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i16, ptr %ptr
  %0 = shl i16 %a, 3
  %1 = lshr i16 %a, 5
  %rol = or i16 %0, %1
  store i16 %rol, ptr %ptr
  ret void
}

define void @rol32mi_legacy(ptr %ptr) {
; CHECK-LABEL: rol32mi_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl (%rdi), %eax
; CHECK-NEXT:    shll $3, %eax, %ecx
; CHECK-NEXT:    shrl $5, %eax
; CHECK-NEXT:    orl %ecx, %eax
; CHECK-NEXT:    movl %eax, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i32, ptr %ptr
  %0 = shl i32 %a, 3
  %1 = lshr i32 %a, 5
  %rol = or i32 %0, %1
  store i32 %rol, ptr %ptr
  ret void
}

define void @rol64mi_legacy(ptr %ptr) {
; CHECK-LABEL: rol64mi_legacy:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq (%rdi), %rax
; CHECK-NEXT:    shlq $3, %rax, %rcx
; CHECK-NEXT:    shrq $5, %rax
; CHECK-NEXT:    orq %rcx, %rax
; CHECK-NEXT:    movq %rax, (%rdi)
; CHECK-NEXT:    retq
entry:
  %a = load i64, ptr %ptr
  %0 = shl i64 %a, 3
  %1 = lshr i64 %a, 5
  %rol = or i64 %0, %1
  store i64 %rol, ptr %ptr
  ret void
}
