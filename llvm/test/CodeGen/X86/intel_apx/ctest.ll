; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; REQUIRES: intel_feature_isa_apx_f
; RUN: llc < %s -mtriple=x86_64-unknown -mattr=+ccmp -verify-machineinstrs -show-mc-encoding | FileCheck %s

define void @ctest8rr_zf(i8 %a, i8 %b) {
; CHECK-LABEL: ctest8rr_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctesteb {zf} %sil, %dil # encoding: [0x62,0xf4,0x14,0x14,0x84,0xf7]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp eq i8 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i8 %a, %b
  %cond2 = icmp sgt i8 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest16rr_sf(i16 %a, i16 %b) {
; CHECK-LABEL: ctest16rr_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; CHECK-NEXT:    ctestew {sf} %si, %di # encoding: [0x62,0xf4,0x25,0x14,0x85,0xf7]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp ule i16 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i16 %a, %b
  %cond2 = icmp sge i16 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest32rr_zf(i32 %a, i32 %b) {
; CHECK-LABEL: ctest32rr_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    movb $1, %al # encoding: [0xb0,0x01]
; CHECK-NEXT:    testb %al, %al # encoding: [0x84,0xc0]
; CHECK-NEXT:    ctestel {zf} %esi, %edi # encoding: [0x62,0xf4,0x14,0x14,0x85,0xf7]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp ult i32 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i32 %a, %b
  %cond2 = icmp ugt i32 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest64rr_sf(i64 %a, i64 %b) {
; CHECK-LABEL: ctest64rr_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; CHECK-NEXT:    ctestsq {sf} %rsi, %rdi # encoding: [0x62,0xf4,0xa4,0x18,0x85,0xf7]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp slt i64 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i64 %a, %b
  %cond2 = icmp sge i64 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest8ri_zf(i8 %a) {
; CHECK-LABEL: ctest8ri_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctestsb {zf} $123, %dil # encoding: [0x62,0xf4,0x14,0x18,0xf6,0xc7,0x7b]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp slt i8 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i8 %a, 123
  %cond2 = icmp ugt i8 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest16ri_sf(i16 %a) {
; CHECK-LABEL: ctest16ri_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; CHECK-NEXT:    ctestnel {sf} $1234, %edi # encoding: [0x62,0xf4,0x24,0x15,0xf7,0xc7,0xd2,0x04,0x00,0x00]
; CHECK-NEXT:    # imm = 0x4D2
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp ne i16 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i16 %a, 1234
  %cond2 = icmp sge i16 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest32ri_zf(i32 %a) {
; CHECK-LABEL: ctest32ri_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    ctestel {zf} $123456, %edi # encoding: [0x62,0xf4,0x14,0x14,0xf7,0xc7,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp eq i32 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i32 %a, 123456
  %cond2 = icmp sgt i32 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest64ri_sf(i64 %a) {
; CHECK-LABEL: ctest64ri_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    cmpq $122, %rdi # encoding: [0x48,0x83,0xff,0x7a]
; CHECK-NEXT:    ctestlel {sf} $123456, %edi # encoding: [0x62,0xf4,0x24,0x1e,0xf7,0xc7,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %cond1 = icmp slt i64 %a, 123
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i64 %a, 123456
  %cond2 = icmp sge i64 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest8mr_zf(i8 %a, ptr %ptr) {
; CHECK-LABEL: ctest8mr_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctesteb {zf} %dil, (%rsi) # encoding: [0x62,0xf4,0x14,0x14,0x84,0x3e]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i8, ptr %ptr
  %cond1 = icmp eq i8 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i8 %a, %b
  %cond2 = icmp ugt i8 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest16mr_sf(i16 %a, ptr %ptr) {
; CHECK-LABEL: ctest16mr_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; CHECK-NEXT:    ctestew {sf} %di, (%rsi) # encoding: [0x62,0xf4,0x25,0x14,0x85,0x3e]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i16, ptr %ptr
  %cond1 = icmp eq i16 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i16 %a, %b
  %cond2 = icmp sge i16 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest32mr_zf(i32 %a, ptr %ptr) {
; CHECK-LABEL: ctest32mr_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    ctestel {zf} %edi, (%rsi) # encoding: [0x62,0xf4,0x14,0x14,0x85,0x3e]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i32, ptr %ptr
  %cond1 = icmp eq i32 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i32 %a, %b
  %cond2 = icmp sgt i32 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest64mr_sf(i64 %a, ptr %ptr) {
; CHECK-LABEL: ctest64mr_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; CHECK-NEXT:    ctestnsq {sf} %rdi, (%rsi) # encoding: [0x62,0xf4,0xa4,0x19,0x85,0x3e]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i64, ptr %ptr
  %cond1 = icmp sge i64 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i64 %a, %b
  %cond2 = icmp sge i64 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest8mi_zf(i8 %a, ptr %ptr) {
; CHECK-LABEL: ctest8mi_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctesteb {zf} $123, (%rsi) # encoding: [0x62,0xf4,0x14,0x14,0xf6,0x06,0x7b]
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i8, ptr %ptr
  %cond1 = icmp eq i8 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i8 %b, 123
  %cond2 = icmp sgt i8 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest16mi_sf(i16 %a, ptr %ptr) {
; CHECK-LABEL: ctest16mi_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    movzwl (%rsi), %eax # encoding: [0x0f,0xb7,0x06]
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; TODO: Could we generate ctestgw {sf} $1234, (%rsi)?
; CHECK-NEXT:    ctestgl {sf} $1234, %eax # encoding: [0x62,0xf4,0x24,0x1f,0xf7,0xc0,0xd2,0x04,0x00,0x00]
; CHECK-NEXT:    # imm = 0x4D2
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i16, ptr %ptr
  %cond1 = icmp sgt i16 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i16 %b, 1234
  %cond2 = icmp sge i16 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest32mi_zf(i32 %a, ptr %ptr) {
; CHECK-LABEL: ctest32mi_zf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    ctestel {zf} $123456, (%rsi) # encoding: [0x62,0xf4,0x14,0x14,0xf7,0x06,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i32, ptr %ptr
  %cond1 = icmp eq i32 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i32 %b, 123456
  %cond2 = icmp ugt i32 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define void @ctest64mi_sf(i64 %a, ptr %ptr) {
; CHECK-LABEL: ctest64mi_sf:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    movq (%rsi), %rax # encoding: [0x48,0x8b,0x06]
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; TODO: Could we generate ctestlel {sf} $123456, (%rsi)?
; CHECK-NEXT:    ctestlel {sf} $123456, %eax # encoding: [0x62,0xf4,0x24,0x1e,0xf7,0xc0,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    retq # encoding: [0xc3]
bb:
  %b = load i64, ptr %ptr
  %cond1 = icmp sle i64 %a, 0
  br i1 %cond1, label %bb1, label %bb3

bb1:                                              ; preds = %bb
  %and = and i64 %b, 123456
  %cond2 = icmp sge i64 %and, 0
  br i1 %cond2, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %tmp = ptrtoint ptr null to i64
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1, %bb
  ret void
}

define i8 @ctest8rr_zf_opt(i8 %a, i8 %b, i8* nocapture %c)  {
; CHECK-LABEL: ctest8rr_zf_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andl %edi, %esi # encoding: [0x21,0xfe]
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctestneb {zf} %sil, %sil # encoding: [0x62,0xf4,0x14,0x15,0x84,0xf6]
; CHECK-NEXT:    jle .LBB16_2 # encoding: [0x7e,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB16_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rdx) # encoding: [0x40,0x88,0x3a]
; CHECK-NEXT:  .LBB16_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp ne i8 %a, 0
  %and = and i8 %a, %b
  %cmp = icmp sgt i8 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i8 0
}

define i16 @ctest16rr_sf_opt(i16 %a, i16 %b, i16* nocapture %c)  {
; CHECK-LABEL: ctest16rr_sf_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andl %edi, %esi # encoding: [0x21,0xfe]
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; CHECK-NEXT:    ctestsw {sf} %si, %si # encoding: [0x62,0xf4,0x25,0x18,0x85,0xf6]
; CHECK-NEXT:    js .LBB17_2 # encoding: [0x78,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB17_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movw %di, (%rdx) # encoding: [0x66,0x89,0x3a]
; CHECK-NEXT:  .LBB17_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp slt i16 %a, 0
  %and = and i16 %a, %b
  %cmp = icmp sge i16 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 %a, i16* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i16 0
}

define i32 @ctest32rr_zf_opt(i32 %a, i32 %b, i32* nocapture %c)  {
; CHECK-LABEL: ctest32rr_zf_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    ctestnel {zf} %esi, %edi # encoding: [0x62,0xf4,0x14,0x15,0x85,0xf7]
; CHECK-NEXT:    je .LBB18_2 # encoding: [0x74,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB18_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movl %edi, (%rdx) # encoding: [0x89,0x3a]
; CHECK-NEXT:  .LBB18_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp ne i32 %a, 0
  %and = and i32 %a, %b
  %cmp = icmp ugt i32 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 %a, i32* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

define i64 @ctest64rr_sf_opt(i64 %a, i64 %b, i64* nocapture %c)  {
; CHECK-LABEL: ctest64rr_sf_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; CHECK-NEXT:    ctestneq {sf} %rsi, %rdi # encoding: [0x62,0xf4,0xa4,0x15,0x85,0xf7]
; CHECK-NEXT:    js .LBB19_2 # encoding: [0x78,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB19_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movq %rdi, (%rdx) # encoding: [0x48,0x89,0x3a]
; CHECK-NEXT:  .LBB19_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp ne i64 %a, 0
  %and = and i64 %a, %b
  %cmp = icmp sge i64 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 %a, i64* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 0
}

define i8 @ctest8mr_opt(i8 %a, i8 %b, i8* nocapture %c, i8* %ptr)  {
; CHECK-LABEL: ctest8mr_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctestneb {} %sil, (%rcx) # encoding: [0x62,0xf4,0x04,0x15,0x84,0x31]
; CHECK-NEXT:    jns .LBB20_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB20_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rdx) # encoding: [0x40,0x88,0x3a]
; CHECK-NEXT:  .LBB20_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i8, i8* %ptr
  %tobool = icmp ne i8 %a, 0
  %and = and i8 %b, %d
  %cmp = icmp slt i8 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i8 0
}

define i16 @ctest16mr_opt(i16 %a, i16 %b, i16* nocapture %c, i16* %ptr)  {
; CHECK-LABEL: ctest16mr_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; CHECK-NEXT:    ctestnew {} %si, (%rcx) # encoding: [0x62,0xf4,0x05,0x15,0x85,0x31]
; CHECK-NEXT:    jns .LBB21_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB21_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movw %di, (%rdx) # encoding: [0x66,0x89,0x3a]
; CHECK-NEXT:  .LBB21_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i16, i16* %ptr
  %tobool = icmp ne i16 %a, 0
  %and = and i16 %b, %d
  %cmp = icmp slt i16 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 %a, i16* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i16 0
}

define i32 @ctest32mr_opt(i32 %a, i32 %b, i32* nocapture %c, i32* %ptr)  {
; CHECK-LABEL: ctest32mr_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    ctestnel {} %esi, (%rcx) # encoding: [0x62,0xf4,0x04,0x15,0x85,0x31]
; CHECK-NEXT:    jns .LBB22_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB22_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movl %edi, (%rdx) # encoding: [0x89,0x3a]
; CHECK-NEXT:  .LBB22_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i32, i32* %ptr
  %tobool = icmp ne i32 %a, 0
  %and = and i32 %b, %d
  %cmp = icmp slt i32 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 %a, i32* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

define i64 @ctest64mr_opt(i64 %a, i64 %b, i64* nocapture %c, i64* %ptr)  {
; CHECK-LABEL: ctest64mr_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; CHECK-NEXT:    ctestneq {} %rsi, (%rcx) # encoding: [0x62,0xf4,0x84,0x15,0x85,0x31]
; CHECK-NEXT:    jns .LBB23_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB23_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movq %rdi, (%rdx) # encoding: [0x48,0x89,0x3a]
; CHECK-NEXT:  .LBB23_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %d = load i64, i64* %ptr
  %tobool = icmp ne i64 %a, 0
  %and = and i64 %b, %d
  %cmp = icmp slt i64 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 %a, i64* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 0
}

define i8 @ctest8ri_opt(i8 %a, i8 %b, i8* nocapture %c)  {
; CHECK-LABEL: ctest8ri_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctestneb {} $123, %sil # encoding: [0x62,0xf4,0x04,0x15,0xf6,0xc6,0x7b]
; CHECK-NEXT:    jns .LBB24_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB24_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rdx) # encoding: [0x40,0x88,0x3a]
; CHECK-NEXT:  .LBB24_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp ne i8 %a, 0
  %and = and i8 %b, 123
  %cmp = icmp slt i8 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i8 0
}

define i16 @ctest16ri_opt(i16 %a, i16 %b, i16* nocapture %c)  {
; CHECK-LABEL: ctest16ri_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; CHECK-NEXT:    ctestnel {} $1234, %esi # encoding: [0x62,0xf4,0x04,0x15,0xf7,0xc6,0xd2,0x04,0x00,0x00]
; CHECK-NEXT:    # imm = 0x4D2
; CHECK-NEXT:    jns .LBB25_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB25_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movw %di, (%rdx) # encoding: [0x66,0x89,0x3a]
; CHECK-NEXT:  .LBB25_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp ne i16 %a, 0
  %and = and i16 %b, 1234
  %cmp = icmp slt i16 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 %a, i16* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i16 0
}

define i32 @ctest32ri_opt(i32 %a, i32 %b, i32* nocapture %c)  {
; CHECK-LABEL: ctest32ri_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    ctestnel {} $123456, %esi # encoding: [0x62,0xf4,0x04,0x15,0xf7,0xc6,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    jns .LBB26_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB26_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movl %edi, (%rdx) # encoding: [0x89,0x3a]
; CHECK-NEXT:  .LBB26_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp ne i32 %a, 0
  %and = and i32 %b, 123456
  %cmp = icmp slt i32 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 %a, i32* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

define i64 @ctest64ri_opt(i64 %a, i64 %b, i64* nocapture %c)  {
; CHECK-LABEL: ctest64ri_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; CHECK-NEXT:    ctestnel {} $123456, %esi # encoding: [0x62,0xf4,0x04,0x15,0xf7,0xc6,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    jns .LBB27_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB27_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movq %rdi, (%rdx) # encoding: [0x48,0x89,0x3a]
; CHECK-NEXT:  .LBB27_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %tobool = icmp ne i64 %a, 0
  %and = and i64 %b, 123456
  %cmp = icmp slt i64 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 %a, i64* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 0
}

define i8 @ctest8mi_opt(i8 %a, i8* %ptr, i8* nocapture %c)  {
; CHECK-LABEL: ctest8mi_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    testb %dil, %dil # encoding: [0x40,0x84,0xff]
; CHECK-NEXT:    ctestneb {} $123, (%rsi) # encoding: [0x62,0xf4,0x04,0x15,0xf6,0x06,0x7b]
; CHECK-NEXT:    jns .LBB28_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB28_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movb %dil, (%rdx) # encoding: [0x40,0x88,0x3a]
; CHECK-NEXT:  .LBB28_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i8, i8* %ptr
  %tobool = icmp ne i8 %a, 0
  %and = and i8 %b, 123
  %cmp = icmp slt i8 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 %a, i8* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i8 0
}

define i16 @ctest16mi_opt(i16 %a, i16* %ptr, i16* nocapture %c)  {
; CHECK-LABEL: ctest16mi_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movzwl (%rsi), %eax # encoding: [0x0f,0xb7,0x06]
; CHECK-NEXT:    testw %di, %di # encoding: [0x66,0x85,0xff]
; TODO: Could we generate ctestnew {} $1234, (%rsi)?
; CHECK-NEXT:    ctestnel {} $1234, %eax # encoding: [0x62,0xf4,0x04,0x15,0xf7,0xc0,0xd2,0x04,0x00,0x00]
; CHECK-NEXT:    # imm = 0x4D2
; CHECK-NEXT:    jns .LBB29_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB29_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movw %di, (%rdx) # encoding: [0x66,0x89,0x3a]
; CHECK-NEXT:  .LBB29_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i16, i16* %ptr
  %tobool = icmp ne i16 %a, 0
  %and = and i16 %b, 1234
  %cmp = icmp slt i16 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i16 %a, i16* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i16 0
}

define i32 @ctest32mi_opt(i32 %a, i32* %ptr, i32* nocapture %c)  {
; CHECK-LABEL: ctest32mi_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movl $123456, %eax # encoding: [0xb8,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    testl %edi, %edi # encoding: [0x85,0xff]
; CHECK-NEXT:    ctestnel {} %eax, (%rsi) # encoding: [0x62,0xf4,0x04,0x15,0x85,0x06]
; CHECK-NEXT:    jns .LBB30_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB30_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movl %edi, (%rdx) # encoding: [0x89,0x3a]
; CHECK-NEXT:  .LBB30_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i32, i32* %ptr
  %tobool = icmp ne i32 %a, 0
  %and = and i32 %b, 123456
  %cmp = icmp slt i32 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 %a, i32* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

define i64 @ctest64mi_opt(i64 %a, i64* %ptr, i64* nocapture %c)  {
; CHECK-LABEL: ctest64mi_opt:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movq (%rsi), %rax # encoding: [0x48,0x8b,0x06]
; CHECK-NEXT:    testq %rdi, %rdi # encoding: [0x48,0x85,0xff]
; TODO: Could we generate ctestnel {} $123456, (%rsi)?
; CHECK-NEXT:    ctestnel {} $123456, %eax # encoding: [0x62,0xf4,0x04,0x15,0xf7,0xc0,0x40,0xe2,0x01,0x00]
; CHECK-NEXT:    # imm = 0x1E240
; CHECK-NEXT:    jns .LBB31_2 # encoding: [0x79,A]
; CHECK-NEXT:    # fixup A - offset: 1, value: .LBB31_2-1, kind: FK_PCRel_1
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    movq %rdi, (%rdx) # encoding: [0x48,0x89,0x3a]
; CHECK-NEXT:  .LBB31_2: # %if.end
; CHECK-NEXT:    xorl %eax, %eax # encoding: [0x31,0xc0]
; CHECK-NEXT:    retq # encoding: [0xc3]
entry:
  %b = load i64, i64* %ptr
  %tobool = icmp ne i64 %a, 0
  %and = and i64 %b, 123456
  %cmp = icmp slt i64 %and, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 %a, i64* %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i64 0
}
