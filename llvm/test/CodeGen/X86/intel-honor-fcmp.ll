; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=sse2 | FileCheck %s --check-prefix=SSE
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=avx2 | FileCheck %s --check-prefixes=AVX2
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=avx512f | FileCheck %s --check-prefixes=AVX512

@g3 = local_unnamed_addr constant double 3.000000e+00, align 8

; Function Attrs: nounwind readnone
define i32 @test_self_eq_f32(float %x) local_unnamed_addr #0 {
; SSE-LABEL: test_self_eq_f32:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    ucomiss %xmm0, %xmm0
; SSE-NEXT:    setnp %al
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_self_eq_f32:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    vucomiss %xmm0, %xmm0
; AVX2-NEXT:    setnp %al
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_self_eq_f32:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    vucomiss %xmm0, %xmm0
; AVX512-NEXT:    setnp %al
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f32(float %x, float %x, metadata !"oeq")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_self_eq_f64(double %x) local_unnamed_addr #0 {
; SSE-LABEL: test_self_eq_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    ucomisd %xmm0, %xmm0
; SSE-NEXT:    setnp %al
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_self_eq_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    vucomisd %xmm0, %xmm0
; AVX2-NEXT:    setnp %al
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_self_eq_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    vucomisd %xmm0, %xmm0
; AVX512-NEXT:    setnp %al
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f64(double %x, double %x, metadata !"oeq")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_self_ne_f32(float %x) local_unnamed_addr #0 {
; SSE-LABEL: test_self_ne_f32:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    ucomiss %xmm0, %xmm0
; SSE-NEXT:    setp %al
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_self_ne_f32:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    vucomiss %xmm0, %xmm0
; AVX2-NEXT:    setp %al
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_self_ne_f32:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    vucomiss %xmm0, %xmm0
; AVX512-NEXT:    setp %al
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f32(float %x, float %x, metadata !"une")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_self_ne_f64(double %x) local_unnamed_addr #0 {
; SSE-LABEL: test_self_ne_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    ucomisd %xmm0, %xmm0
; SSE-NEXT:    setp %al
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_self_ne_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    vucomisd %xmm0, %xmm0
; AVX2-NEXT:    setp %al
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_self_ne_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    vucomisd %xmm0, %xmm0
; AVX512-NEXT:    setp %al
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f64(double %x, double %x, metadata !"une")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_nan_eq_f32(float %x) local_unnamed_addr #0 {
; SSE-LABEL: test_nan_eq_f32:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_nan_eq_f32:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_nan_eq_f32:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f32(float %x, float 0x7FF8000000000000, metadata !"oeq")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_nan_eq_f64(double %x) local_unnamed_addr #0 {
; SSE-LABEL: test_nan_eq_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_nan_eq_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_nan_eq_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f64(double %x, double 0x7FF8000000000000, metadata !"oeq")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_nan_ne_f32(float %x) local_unnamed_addr #0 {
; SSE-LABEL: test_nan_ne_f32:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    movl $1, %eax
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_nan_ne_f32:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    movl $1, %eax
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_nan_ne_f32:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    movl $1, %eax
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f32(float %x, float 0x7FF8000000000000, metadata !"une")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_nan_ne_f64(double %x) local_unnamed_addr #0 {
; SSE-LABEL: test_nan_ne_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    movl $1, %eax
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_nan_ne_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    movl $1, %eax
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_nan_ne_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    movl $1, %eax
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f64(double %x, double 0x7FF8000000000000, metadata !"une")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define <4 x i32> @test_vec_eq_f32(<4 x float> %x, <4 x float> %y) local_unnamed_addr #0 {
; SSE-LABEL: test_vec_eq_f32:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    cmpeqps %xmm1, %xmm0
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_vec_eq_f32:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    vcmpeqps %xmm1, %xmm0, %xmm0
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_vec_eq_f32:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    vcmpeqps %xmm1, %xmm0, %xmm0
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn <4 x i1> @llvm.intel.honor.fcmp.v4f32(<4 x float> %x, <4 x float> %y, metadata !"oeq")
  %sext = sext <4 x i1> %cmp to <4 x i32>
  ret <4 x i32> %sext
}

; Function Attrs: nounwind readnone
define <4 x i32> @test_vec_gt_f32(<4 x float> %x, <4 x float> %y) local_unnamed_addr #0 {
; SSE-LABEL: test_vec_gt_f32:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    cmpltps %xmm0, %xmm1
; SSE-NEXT:    movaps %xmm1, %xmm0
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_vec_gt_f32:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    vcmpltps %xmm0, %xmm1, %xmm0
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_vec_gt_f32:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    vcmpltps %xmm0, %xmm1, %xmm0
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn <4 x i1> @llvm.intel.honor.fcmp.v4f32(<4 x float> %x, <4 x float> %y, metadata !"ogt")
  %sext = sext <4 x i1> %cmp to <4 x i32>
  ret <4 x i32> %sext
}

; Function Attrs: nounwind readnone
define <2 x i64> @test_vec_eq_f64(<2 x double> %x, <2 x double> %y) local_unnamed_addr #0 {
; SSE-LABEL: test_vec_eq_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    cmpeqpd %xmm1, %xmm0
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_vec_eq_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    vcmpeqpd %xmm1, %xmm0, %xmm0
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_vec_eq_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    vcmpeqpd %xmm1, %xmm0, %xmm0
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn <2 x i1> @llvm.intel.honor.fcmp.v2f64(<2 x double> %x, <2 x double> %y, metadata !"oeq")
  %sext = sext <2 x i1> %cmp to <2 x i64>
  ret <2 x i64> %sext
}

; Function Attrs: nounwind readnone
define <2 x i64> @test_vec_gt_f64(<2 x double> %x, <2 x double> %y) local_unnamed_addr #0 {
; SSE-LABEL: test_vec_gt_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    cmpltpd %xmm0, %xmm1
; SSE-NEXT:    movapd %xmm1, %xmm0
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_vec_gt_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    vcmpltpd %xmm0, %xmm1, %xmm0
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_vec_gt_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    vcmpltpd %xmm0, %xmm1, %xmm0
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn <2 x i1> @llvm.intel.honor.fcmp.v2f64(<2 x double> %x, <2 x double> %y, metadata !"ogt")
  %sext = sext <2 x i1> %cmp to <2 x i64>
  ret <2 x i64> %sext
}

; Function Attrs: nounwind readnone
define i32 @test_const_nan_eq_f64(double %x) local_unnamed_addr #0 {
; SSE-LABEL: test_const_nan_eq_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    xorl %eax, %eax
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_const_nan_eq_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    xorl %eax, %eax
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_const_nan_eq_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    xorl %eax, %eax
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f64(double 3.000000e+00, double 0x7FF8000000000000, metadata !"oeq")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone
define i32 @test_self_sub_eq0_f64(double %x) local_unnamed_addr #0 {
; SSE-LABEL: test_self_sub_eq0_f64:
; SSE:       # %bb.0: # %entry
; SSE-NEXT:    movl $1, %eax
; SSE-NEXT:    retq
;
; AVX2-LABEL: test_self_sub_eq0_f64:
; AVX2:       # %bb.0: # %entry
; AVX2-NEXT:    movl $1, %eax
; AVX2-NEXT:    retq
;
; AVX512-LABEL: test_self_sub_eq0_f64:
; AVX512:       # %bb.0: # %entry
; AVX512-NEXT:    movl $1, %eax
; AVX512-NEXT:    retq
entry:
  %cmp = tail call reassoc ninf nsz arcp contract afn i1 @llvm.intel.honor.fcmp.f64(double 0.000000e+00, double 0.000000e+00, metadata !"oeq")
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone speculatable willreturn
declare i1 @llvm.intel.honor.fcmp.f32(float, float, metadata) #1
declare i1 @llvm.intel.honor.fcmp.f64(double, double, metadata) #1
declare <4 x i1> @llvm.intel.honor.fcmp.v4f32(<4 x float>, <4 x float>, metadata) #1
declare <2 x i1> @llvm.intel.honor.fcmp.v2f64(<2 x double>, <2 x double>, metadata) #1

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind readnone speculatable willreturn }
