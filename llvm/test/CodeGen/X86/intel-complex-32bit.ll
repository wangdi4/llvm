; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=i386-linux-gnu | FileCheck %s

; Check that we handle the ABI of the complex functions correctly for 32-bit.

declare <2 x half> @llvm.intel.complex.fmul.v2f16(<2 x half>, <2 x half>)
declare <2 x float> @llvm.intel.complex.fmul.v2f32(<2 x float>, <2 x float>)
declare <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double>, <2 x double>)
declare <2 x x86_fp80> @llvm.intel.complex.fmul.v2f80(<2 x x86_fp80>, <2 x x86_fp80>)
declare <2 x fp128> @llvm.intel.complex.fmul.v2f128(<2 x fp128>, <2 x fp128>)

define <2 x half> @intrinsic_f16(<2 x half> %z, <2 x half> %w) {
; CHECK-LABEL: intrinsic_f16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    subl $8, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset %esi, -8
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %edx
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl %ecx
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl %edx
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    calll __mulhc3@PLT
; CHECK-NEXT:    addl $24, %esp
; CHECK-NEXT:    .cfi_adjust_cfa_offset -24
; CHECK-NEXT:    popl %esi
; CHECK-NEXT:    .cfi_def_cfa_offset 4
; CHECK-NEXT:    retl
  %mul = call <2 x half> @llvm.intel.complex.fmul.v2f16(<2 x half> %z, <2 x half> %w)
  ret <2 x half> %mul
}

define <2 x float> @intrinsic_f32(<2 x float> %z, <2 x float> %w) {
; CHECK-LABEL: intrinsic_f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subl $28, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    flds {{[0-9]+}}(%esp)
; CHECK-NEXT:    flds {{[0-9]+}}(%esp)
; CHECK-NEXT:    flds {{[0-9]+}}(%esp)
; CHECK-NEXT:    flds {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstps {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstps {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstps {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstps (%esp)
; CHECK-NEXT:    calll __mulsc3@PLT
; CHECK-NEXT:    movl %edx, {{[0-9]+}}(%esp)
; CHECK-NEXT:    movl %eax, {{[0-9]+}}(%esp)
; CHECK-NEXT:    flds {{[0-9]+}}(%esp)
; CHECK-NEXT:    flds {{[0-9]+}}(%esp)
; CHECK-NEXT:    addl $28, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 4
; CHECK-NEXT:    retl
  %mul = call <2 x float> @llvm.intel.complex.fmul.v2f32(<2 x float> %z, <2 x float> %w)
  ret <2 x float> %mul
}


define <2 x double> @intrinsic_f64(<2 x double> %z, <2 x double> %w) {
; CHECK-LABEL: intrinsic_f64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subl $60, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 64
; CHECK-NEXT:    fldl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpl {{[0-9]+}}(%esp)
; CHECK-NEXT:    leal {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    movl %eax, (%esp)
; CHECK-NEXT:    calll __muldc3@PLT
; CHECK-NEXT:    fldl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldl {{[0-9]+}}(%esp)
; CHECK-NEXT:    fxch %st(1)
; CHECK-NEXT:    addl $60, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 4
; CHECK-NEXT:    retl
  %mul = call <2 x double> @llvm.intel.complex.fmul.v2f64(<2 x double> %z, <2 x double> %w)
  ret <2 x double> %mul
}

define <2 x x86_fp80> @intrinsic_f80(<2 x x86_fp80> %z, <2 x x86_fp80> %w) {
; CHECK-LABEL: intrinsic_f80:
; CHECK:       # %bb.0:
; CHECK-NEXT:    subl $92, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    fldt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fstpt {{[0-9]+}}(%esp)
; CHECK-NEXT:    leal {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    movl %eax, (%esp)
; CHECK-NEXT:    calll __mulxc3@PLT
; CHECK-NEXT:    fldt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fldt {{[0-9]+}}(%esp)
; CHECK-NEXT:    fxch %st(1)
; CHECK-NEXT:    addl $92, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 4
; CHECK-NEXT:    retl
  %mul = call <2 x x86_fp80> @llvm.intel.complex.fmul.v2f80(<2 x x86_fp80> %z, <2 x x86_fp80> %w)
  ret <2 x x86_fp80> %mul
}

define <2 x fp128> @intrinsic_f128(<2 x fp128> %z, <2 x fp128> %w) {
; CHECK-LABEL: intrinsic_f128:
; CHECK:       # %bb.0:
; CHECK-NEXT:    pushl %ebp
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    pushl %ebx
; CHECK-NEXT:    .cfi_def_cfa_offset 12
; CHECK-NEXT:    pushl %edi
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    pushl %esi
; CHECK-NEXT:    .cfi_def_cfa_offset 20
; CHECK-NEXT:    subl $60, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 80
; CHECK-NEXT:    .cfi_offset %esi, -20
; CHECK-NEXT:    .cfi_offset %edi, -16
; CHECK-NEXT:    .cfi_offset %ebx, -12
; CHECK-NEXT:    .cfi_offset %ebp, -8
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CHECK-NEXT:    subl $12, %esp
; CHECK-NEXT:    .cfi_adjust_cfa_offset 12
; CHECK-NEXT:    leal {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl {{[0-9]+}}(%esp)
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    pushl %eax
; CHECK-NEXT:    .cfi_adjust_cfa_offset 4
; CHECK-NEXT:    calll __multc3@PLT
; CHECK-NEXT:    addl $80, %esp
; CHECK-NEXT:    .cfi_adjust_cfa_offset -80
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %edx
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %edi
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %ebx
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %ebp
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK-NEXT:    movl %ecx, 28(%esi)
; CHECK-NEXT:    movl %eax, 24(%esi)
; CHECK-NEXT:    movl %ebp, 20(%esi)
; CHECK-NEXT:    movl %ebx, 16(%esi)
; CHECK-NEXT:    movl %edi, 12(%esi)
; CHECK-NEXT:    movl %edx, 8(%esi)
; CHECK-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Reload
; CHECK-NEXT:    movl %eax, 4(%esi)
; CHECK-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Reload
; CHECK-NEXT:    movl %eax, (%esi)
; CHECK-NEXT:    movl %esi, %eax
; CHECK-NEXT:    addl $60, %esp
; CHECK-NEXT:    .cfi_def_cfa_offset 20
; CHECK-NEXT:    popl %esi
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    popl %edi
; CHECK-NEXT:    .cfi_def_cfa_offset 12
; CHECK-NEXT:    popl %ebx
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    popl %ebp
; CHECK-NEXT:    .cfi_def_cfa_offset 4
; CHECK-NEXT:    retl $4
  %mul = call <2 x fp128> @llvm.intel.complex.fmul.v2f128(<2 x fp128> %z, <2 x fp128> %w)
  ret <2 x fp128> %mul
}

