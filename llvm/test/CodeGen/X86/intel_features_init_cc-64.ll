; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=sse2 | FileCheck %s
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=avx2 | FileCheck %s
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mattr=avx512f | FileCheck %s

%struct.FeatureDefType = type { i8*, i32, i8* }

@proc_info_features = internal unnamed_addr global [63 x %struct.FeatureDefType] zeroinitializer, align 16
@.str.1 = private unnamed_addr constant [13 x i8] c"GENERIC_IA32\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"X87\00", align 1
@__libirc_isa_info_initialized = internal unnamed_addr global i1 false, align 4

define intel_features_init_cc i32 @__intel_cpu_features_init_x() #0 {
; CHECK-LABEL: __intel_cpu_features_init_x:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    callq __intel_cpu_features_init_body@PLT
; CHECK-NEXT:    addq $8, %rsp
; CHECK-NEXT:    retq
entry:
  %call = tail call intel_features_init_cc i32 @__intel_cpu_features_init_body(i32 0) #0
  ret i32 %call
}

define intel_features_init_cc i32 @__intel_cpu_features_init() #0 {
; CHECK-LABEL: __intel_cpu_features_init:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    callq __intel_cpu_features_init_body@PLT
; CHECK-NEXT:    addq $8, %rsp
; CHECK-NEXT:    retq
entry:
  %call = tail call intel_features_init_cc i32 @__intel_cpu_features_init_body(i32 1)
  ret i32 %call
}

define intel_features_init_cc i32 @__libirc_get_feature_bitpos(i32 %feature_id) #0 {
; CHECK-LABEL: __libirc_get_feature_bitpos:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rcx
; CHECK-NEXT:    movl %eax, %ecx
; CHECK-NEXT:    cmpb $0, __libirc_isa_info_initialized(%rip)
; CHECK-NEXT:    jne .LBB2_2
; CHECK-NEXT:  # %bb.1: # %land.lhs.true
; CHECK-NEXT:    callq __libirc_isa_init_once@PLT
; CHECK-NEXT:  .LBB2_2: # %if.end
; CHECK-NEXT:    movl %ecx, %eax
; CHECK-NEXT:    leaq (%rax,%rax,2), %rax
; CHECK-NEXT:    movl proc_info_features+8(,%rax,8), %ecx
; CHECK-NEXT:    leal -128(%rcx), %eax
; CHECK-NEXT:    cmpl $-129, %eax
; CHECK-NEXT:    movl $-3, %eax
; CHECK-NEXT:    cmovael %ecx, %eax
; CHECK-NEXT:    popq %rcx
; CHECK-NEXT:    retq
entry:
  %.b = load i1, i1* @__libirc_isa_info_initialized, align 4
  br i1 %.b, label %if.end, label %land.lhs.true

land.lhs.true:
  tail call intel_features_init_cc void @__libirc_isa_init_once()
  br label %if.end

if.end:
  %idxprom = zext i32 %feature_id to i64
  %bitpos2 = getelementptr inbounds [63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 %idxprom, i32 1
  %0 = load i32, i32* %bitpos2, align 8
  %1 = add i32 %0, -128
  %2 = icmp ult i32 %1, -129
  %spec.select = select i1 %2, i32 -3, i32 %0
  ret i32 %spec.select
}

declare intel_features_init_cc i32 @__intel_cpu_features_init_body(i32 %vendor_check) #0

define intel_features_init_cc i32 @__libirc_set_cpu_feature(i64* noalias nocapture %features_ptr, i32 %feature) #0 {
; CHECK-LABEL: __libirc_set_cpu_feature:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rdx
; CHECK-NEXT:    pushq %rsi
; CHECK-NEXT:    pushq %rdi
; CHECK-NEXT:    movq %rax, %rdx
; CHECK-NEXT:    cmpb $0, __libirc_isa_info_initialized(%rip)
; CHECK-NEXT:    jne .LBB3_2
; CHECK-NEXT:  # %bb.1: # %land.lhs.true.i
; CHECK-NEXT:    callq __libirc_isa_init_once@PLT
; CHECK-NEXT:  .LBB3_2: # %__libirc_get_feature_bitpos.exit
; CHECK-NEXT:    movl %ecx, %eax
; CHECK-NEXT:    leaq (%rax,%rax,2), %rax
; CHECK-NEXT:    movl proc_info_features+8(,%rax,8), %ecx
; CHECK-NEXT:    leal -128(%rcx), %eax
; CHECK-NEXT:    cmpl $-129, %eax
; CHECK-NEXT:    movl $-3, %eax
; CHECK-NEXT:    cmovael %ecx, %eax
; CHECK-NEXT:    testl %eax, %eax
; CHECK-NEXT:    js .LBB3_4
; CHECK-NEXT:  # %bb.3: # %if.end
; CHECK-NEXT:    movl %eax, %esi
; CHECK-NEXT:    shrl $6, %esi
; CHECK-NEXT:    movl %esi, %ecx
; CHECK-NEXT:    shll $6, %ecx
; CHECK-NEXT:    subl %ecx, %eax
; CHECK-NEXT:    movl $1, %edi
; CHECK-NEXT:    movl %eax, %ecx
; CHECK-NEXT:    shlq %cl, %rdi
; CHECK-NEXT:    orq %rdi, (%rdx,%rsi,8)
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:  .LBB3_4: # %cleanup
; CHECK-NEXT:    popq %rdi
; CHECK-NEXT:    popq %rsi
; CHECK-NEXT:    popq %rdx
; CHECK-NEXT:    retq
entry:
  %.b.i = load i1, i1* @__libirc_isa_info_initialized, align 4
  br i1 %.b.i, label %__libirc_get_feature_bitpos.exit, label %land.lhs.true.i

land.lhs.true.i:
  tail call intel_features_init_cc void @__libirc_isa_init_once()
  br label %__libirc_get_feature_bitpos.exit

__libirc_get_feature_bitpos.exit:
  %idxprom.i = zext i32 %feature to i64
  %bitpos2.i = getelementptr inbounds [63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 %idxprom.i, i32 1
  %0 = load i32, i32* %bitpos2.i, align 8
  %1 = add i32 %0, -128
  %2 = icmp ult i32 %1, -129
  %spec.select.i = select i1 %2, i32 -3, i32 %0
  %cmp = icmp slt i32 %spec.select.i, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:
  %conv11 = zext i32 %spec.select.i to i64
  %conv112 = lshr i32 %spec.select.i, 6
  %3 = zext i32 %conv112 to i64
  %mul = shl nuw nsw i64 %3, 6
  %sub = sub nsw i64 %conv11, %mul
  %shl = shl nuw i64 1, %sub
  %arrayidx = getelementptr inbounds i64, i64* %features_ptr, i64 %3
  %4 = load i64, i64* %arrayidx, align 8
  %or = or i64 %4, %shl
  store i64 %or, i64* %arrayidx, align 8
  br label %cleanup

cleanup:
  %retval.0 = phi i32 [ 0, %if.end ], [ %spec.select.i, %__libirc_get_feature_bitpos.exit ]
  ret i32 %retval.0
}

define intel_features_init_cc void @__libirc_isa_init_once() #0 {
; CHECK-LABEL: __libirc_isa_init_once:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpb $0, __libirc_isa_info_initialized(%rip)
; CHECK-NEXT:    jne .LBB4_2
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    movl $-1, proc_info_features+416(%rip)
; CHECK-NEXT:    movl $-1, proc_info_features+440(%rip)
; CHECK-NEXT:    movl $-1, proc_info_features+464(%rip)
; CHECK-NEXT:    movl $-1, proc_info_features+488(%rip)
; CHECK-NEXT:    movq $.L.str.1, proc_info_features+24(%rip)
; CHECK-NEXT:    movl $0, proc_info_features+32(%rip)
; CHECK-NEXT:    movq $.L.str.2, proc_info_features+48(%rip)
; CHECK-NEXT:    movl $1, proc_info_features+56(%rip)
; CHECK-NEXT:    movb $1, __libirc_isa_info_initialized(%rip)
; CHECK-NEXT:  .LBB4_2: # %cleanup
; CHECK-NEXT:    retq
entry:
  %.b = load i1, i1* @__libirc_isa_info_initialized, align 4
  br i1 %.b, label %cleanup, label %for.body.preheader

for.body.preheader:
  store i32 -1, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 17, i32 1), align 16
  store i32 -1, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 18, i32 1), align 8
  store i32 -1, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 19, i32 1), align 16
  store i32 -1, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 20, i32 1), align 8
 store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1, i64 0, i64 0), i8** getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 1, i32 0), align 8
  store i32 0, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 1, i32 1), align 16
  store i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0), i8** getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 2, i32 0), align 16
  store i32 1, i32* getelementptr inbounds ([63 x %struct.FeatureDefType], [63 x %struct.FeatureDefType]* @proc_info_features, i64 0, i64 2, i32 1), align 8
  store i1 true, i1* @__libirc_isa_info_initialized, align 4
  br label %cleanup

cleanup:
  ret void
}

attributes #0 = { nounwind }
