; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-apple-darwin -mcpu=sapphirerapids | FileCheck %s

; Spot check some features to make sure sapphirerapids is inheriting from ICL
; TODO: Check WCL features

; Check for AVX512F
define <16 x float> @test_mm512_mask_add_round_ps_current(<16 x float> %a0, <16 x float> %a1, <16 x float> %src, i16 %mask) {
; CHECK-LABEL: test_mm512_mask_add_round_ps_current:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vaddps %zmm1, %zmm0, %zmm2 {%k1}
; CHECK-NEXT:    vmovaps %zmm2, %zmm0
; CHECK-NEXT:    retq
  %1 = call <16 x float> @llvm.x86.avx512.add.ps.512(<16 x float> %a0, <16 x float> %a1, i32 4)
  %2 = bitcast i16 %mask to <16 x i1>
  %3 = select <16 x i1> %2, <16 x float> %1, <16 x float> %src
  ret <16 x float> %3
}
declare <16 x float> @llvm.x86.avx512.add.ps.512(<16 x float>, <16 x float>, i32)

; Check for AVX512VL
define <8 x float> @test_mm256_mask_add_round_ps_current(<8 x float> %a0, <8 x float> %a1, <8 x float> %src, i8 %mask) {
; CHECK-LABEL: test_mm256_mask_add_round_ps_current:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vaddps %ymm1, %ymm0, %ymm2 {%k1}
; CHECK-NEXT:    vmovaps %ymm2, %ymm0
; CHECK-NEXT:    retq
  %1 = fadd <8 x float> %a0, %a1
  %2 = bitcast i8 %mask to <8 x i1>
  %3 = select <8 x i1> %2, <8 x float> %1, <8 x float> %src
  ret <8 x float> %3
}

; Check for GFNI
define <16 x i8> @test_vgf2p8affineinvqb_128(<16 x i8> %src1, <16 x i8> %src2, <16 x i8> %passthru, i16 %mask) {
; CHECK-LABEL: test_vgf2p8affineinvqb_128:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vgf2p8affineinvqb $3, %xmm1, %xmm0, %xmm1
; CHECK-NEXT:    vmovdqu8 %xmm1, %xmm0 {%k1} {z}
; CHECK-NEXT:    vmovdqu8 %xmm1, %xmm2 {%k1}
; CHECK-NEXT:    vpternlogq $150, %xmm2, %xmm1, %xmm0
; CHECK-NEXT:    retq
  %1 = bitcast i16 %mask to <16 x i1>
  %2 = call <16 x i8> @llvm.x86.vgf2p8affineinvqb.128(<16 x i8> %src1, <16 x i8> %src2, i8 3)
  %3 = select <16 x i1> %1, <16 x i8> %2, <16 x i8> zeroinitializer
  %4 = select <16 x i1> %1, <16 x i8> %2, <16 x i8> %passthru
  %5 = xor <16 x i8> %3, %4
  %6 = xor <16 x i8> %5, %2
  ret <16 x i8> %6
}
declare <16 x i8> @llvm.x86.vgf2p8affineinvqb.128(<16 x i8>, <16 x i8>, i8)

; Check for VCLMULQDQ
define <8 x i64> @test_x86_pclmulqdq(<8 x i64> %a0, <8 x i64> %a1) {
; CHECK-LABEL: test_x86_pclmulqdq:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpclmulqdq $1, %zmm1, %zmm0, %zmm0
; CHECK-NEXT:    retq
  %res = call <8 x i64> @llvm.x86.pclmulqdq.512(<8 x i64> %a0, <8 x i64> %a1, i8 1)
  ret <8 x i64> %res
}
declare <8 x i64> @llvm.x86.pclmulqdq.512(<8 x i64>, <8 x i64>, i8) nounwind readnone

; Check for AVX512BITALG
define i16 @test_vpshufbitqmb_128(<16 x i8> %a, <16 x i8> %b, <16 x i8> %c, <16 x i8> %d) {
; CHECK-LABEL: test_vpshufbitqmb_128:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpshufbitqmb %xmm1, %xmm0, %k1
; CHECK-NEXT:    vpshufbitqmb %xmm3, %xmm2, %k0 {%k1}
; CHECK-NEXT:    kmovd %k0, %eax
; CHECK-NEXT:    ## kill: def $ax killed $ax killed $eax
; CHECK-NEXT:    retq
  %tmp = call <16 x i1> @llvm.x86.avx512.vpshufbitqmb.128(<16 x i8> %a, <16 x i8> %b)
  %tmp1 = call <16 x i1> @llvm.x86.avx512.vpshufbitqmb.128(<16 x i8> %c, <16 x i8> %d)
  %tmp2 = and <16 x i1> %tmp, %tmp1
  %tmp3 = bitcast <16 x i1> %tmp2 to i16
  ret i16 %tmp3
}
declare <16 x i1> @llvm.x86.avx512.vpshufbitqmb.128(<16 x i8>, <16 x i8>)

; Check for VBMI2
define <16 x i32> @test_int_x86_avx512_mask_vpshld_d_512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> %x3, i16 %x4) {
; CHECK-LABEL: test_int_x86_avx512_mask_vpshld_d_512:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vpshldd $22, %zmm1, %zmm0, %zmm2 {%k1}
; CHECK-NEXT:    vpshldd $23, %zmm1, %zmm0, %zmm0
; CHECK-NEXT:    vpaddd %zmm0, %zmm2, %zmm0
; CHECK-NEXT:    retq
  %1 = call <16 x i32> @llvm.fshl.v16i32(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> <i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22>)
  %2 = bitcast i16 %x4 to <16 x i1>
  %3 = select <16 x i1> %2, <16 x i32> %1, <16 x i32> %x3
  %4 = call <16 x i32> @llvm.fshl.v16i32(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> <i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23, i32 23>)
  %res2 = add <16 x i32> %3, %4
  ret <16 x i32> %res2
}
declare <16 x i32> @llvm.fshl.v16i32(<16 x i32>, <16 x i32>, <16 x i32>)

; Check for VAES
define <8 x i64> @test_x86_aesni_aesdeclast_512(<8 x i64> %a0, <8 x i64> %a1) {
; CHECK-LABEL: test_x86_aesni_aesdeclast_512:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vaesdeclast %zmm1, %zmm0, %zmm0
; CHECK-NEXT:    retq
  %res = call <8 x i64> @llvm.x86.aesni.aesdeclast.512(<8 x i64> %a0, <8 x i64> %a1)
  ret <8 x i64> %res
}
declare <8 x i64> @llvm.x86.aesni.aesdeclast.512(<8 x i64>, <8 x i64>) nounwind readnone

; Check for AVX512VNNI
define <16 x i32>@test_int_x86_avx512_mask_vpdpbusd_512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32>* %x2p, <16 x i32> %x4, i16 %x3) {
; CHECK-LABEL: test_int_x86_avx512_mask_vpdpbusd_512:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpdpbusd (%rdi), %zmm1, %zmm0
; CHECK-NEXT:    retq
  %x2 = load <16 x i32>, <16 x i32>* %x2p
  %1 = call <16 x i32> @llvm.x86.avx512.vpdpbusd.512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> %x2)
  ret <16 x i32> %1
}
declare <16 x i32> @llvm.x86.avx512.vpdpbusd.512(<16 x i32>, <16 x i32>, <16 x i32>)

define void @clwb(i8* %p) nounwind {
; CHECK-LABEL: clwb:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    clwb (%rdi)
; CHECK-NEXT:    retq
  tail call void @llvm.x86.clwb(i8* %p)
  ret void
}
declare void @llvm.x86.clwb(i8*) nounwind

define i32 @test_builtin_rdpid() {
; CHECK-LABEL: test_builtin_rdpid:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    rdpid %rax
; CHECK-NEXT:    ## kill: def $eax killed $eax killed $rax
; CHECK-NEXT:    retq
  %1 = tail call i32 @llvm.x86.rdpid()
  ret i32 %1
}
declare i32 @llvm.x86.rdpid()

define void @wbnoinvd() nounwind {
; CHECK-LABEL: wbnoinvd:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    wbnoinvd
; CHECK-NEXT:    retq
  tail call void @llvm.x86.wbnoinvd()
  ret void
}
declare void @llvm.x86.wbnoinvd() nounwind

