; INTEL_FEATURE_CPU_GLC
; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-apple-darwin -mcpu=goldencove | FileCheck %s
; REQUIRES: intel_feature_cpu_glc

; Spot check some features to make sure goldencove is inheriting from ICL
; TODO: Check WCL features

; Check for AVX512F
define <16 x float> @test_mm512_mask_add_round_ps_current(<16 x float> %a0, <16 x float> %a1, <16 x float> %src, i16 %mask) {
; CHECK-LABEL: test_mm512_mask_add_round_ps_current:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vaddps %zmm1, %zmm0, %zmm2 {%k1}
; CHECK-NEXT:    vmovaps %zmm2, %zmm0
; CHECK-NEXT:    retq
  %1 = call <16 x float> @llvm.x86.avx512.add.ps.512(<16 x float> %a0, <16 x float> %a1, i32 4)
  %2 = bitcast i16 %mask to <16 x i1>
  %3 = select <16 x i1> %2, <16 x float> %1, <16 x float> %src
  ret <16 x float> %3
}
declare <16 x float> @llvm.x86.avx512.add.ps.512(<16 x float>, <16 x float>, i32)

; Check for AVX512VL
define <8 x float> @test_mm256_mask_add_round_ps_current(<8 x float> %a0, <8 x float> %a1, <8 x float> %src, i8 %mask) {
; CHECK-LABEL: test_mm256_mask_add_round_ps_current:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vaddps %ymm1, %ymm0, %ymm2 {%k1}
; CHECK-NEXT:    vmovaps %ymm2, %ymm0
; CHECK-NEXT:    retq
  %1 = fadd <8 x float> %a0, %a1
  %2 = bitcast i8 %mask to <8 x i1>
  %3 = select <8 x i1> %2, <8 x float> %1, <8 x float> %src
  ret <8 x float> %3
}

; Check for GFNI
define <16 x i8> @test_vgf2p8affineinvqb_128(<16 x i8> %src1, <16 x i8> %src2, <16 x i8> %passthru, i16 %mask) {
; CHECK-LABEL: test_vgf2p8affineinvqb_128:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vgf2p8affineinvqb $3, %xmm1, %xmm0, %xmm3
; CHECK-NEXT:    vgf2p8affineinvqb $3, %xmm1, %xmm0, %xmm4 {%k1} {z}
; CHECK-NEXT:    vgf2p8affineinvqb $3, %xmm1, %xmm0, %xmm2 {%k1}
; CHECK-NEXT:    vpxor %xmm2, %xmm4, %xmm0
; CHECK-NEXT:    vpxor %xmm3, %xmm0, %xmm0
; CHECK-NEXT:    retq
  %1 = bitcast i16 %mask to <16 x i1>
  %2 = call <16 x i8> @llvm.x86.vgf2p8affineinvqb.128(<16 x i8> %src1, <16 x i8> %src2, i8 3)
  %3 = select <16 x i1> %1, <16 x i8> %2, <16 x i8> zeroinitializer
  %4 = select <16 x i1> %1, <16 x i8> %2, <16 x i8> %passthru
  %5 = xor <16 x i8> %3, %4
  %6 = xor <16 x i8> %5, %2
  ret <16 x i8> %6
}
declare <16 x i8> @llvm.x86.vgf2p8affineinvqb.128(<16 x i8>, <16 x i8>, i8)

; Check for VCLMULQDQ
define <8 x i64> @test_x86_pclmulqdq(<8 x i64> %a0, <8 x i64> %a1) {
; CHECK-LABEL: test_x86_pclmulqdq:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpclmulqdq $1, %zmm1, %zmm0, %zmm0
; CHECK-NEXT:    retq
  %res = call <8 x i64> @llvm.x86.pclmulqdq.512(<8 x i64> %a0, <8 x i64> %a1, i8 1)
  ret <8 x i64> %res
}
declare <8 x i64> @llvm.x86.pclmulqdq.512(<8 x i64>, <8 x i64>, i8) nounwind readnone

; Check for AVX512BITALG
define i16 @test_vpshufbitqmb_128(<16 x i8> %a, <16 x i8> %b, <16 x i8> %c, <16 x i8> %d) {
; CHECK-LABEL: test_vpshufbitqmb_128:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpshufbitqmb %xmm1, %xmm0, %k1
; CHECK-NEXT:    vpshufbitqmb %xmm3, %xmm2, %k0 {%k1}
; CHECK-NEXT:    kmovd %k0, %eax
; CHECK-NEXT:    ## kill: def $ax killed $ax killed $eax
; CHECK-NEXT:    retq
  %tmp = call <16 x i1> @llvm.x86.avx512.vpshufbitqmb.128(<16 x i8> %a, <16 x i8> %b)
  %tmp1 = call <16 x i1> @llvm.x86.avx512.vpshufbitqmb.128(<16 x i8> %c, <16 x i8> %d)
  %tmp2 = and <16 x i1> %tmp, %tmp1
  %tmp3 = bitcast <16 x i1> %tmp2 to i16
  ret i16 %tmp3
}
declare <16 x i1> @llvm.x86.avx512.vpshufbitqmb.128(<16 x i8>, <16 x i8>)

; Check for VBMI2
define <16 x i32> @test_int_x86_avx512_mask_vpshld_d_512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> %x3, i16 %x4) {
; CHECK-LABEL: test_int_x86_avx512_mask_vpshld_d_512:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vpshldd $22, %zmm1, %zmm0, %zmm3
; CHECK-NEXT:    kmovd %edi, %k1
; CHECK-NEXT:    vpshldd $22, %zmm1, %zmm0, %zmm2 {%k1}
; CHECK-NEXT:    vpaddd %zmm3, %zmm2, %zmm0
; CHECK-NEXT:    retq
  %1 = call <16 x i32> @llvm.fshl.v16i32(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> <i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22>)
  %2 = bitcast i16 %x4 to <16 x i1>
  %3 = select <16 x i1> %2, <16 x i32> %1, <16 x i32> %x3
  %4 = call <16 x i32> @llvm.fshl.v16i32(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> <i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22, i32 22>)
  %res2 = add <16 x i32> %3, %4
  ret <16 x i32> %res2
}
declare <16 x i32> @llvm.fshl.v16i32(<16 x i32>, <16 x i32>, <16 x i32>)

; Check for VAES
define <8 x i64> @test_x86_aesni_aesdeclast_512(<8 x i64> %a0, <8 x i64> %a1) {
; CHECK-LABEL: test_x86_aesni_aesdeclast_512:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    vaesdeclast %zmm1, %zmm0, %zmm0
; CHECK-NEXT:    retq
  %res = call <8 x i64> @llvm.x86.aesni.aesdeclast.512(<8 x i64> %a0, <8 x i64> %a1)
  ret <8 x i64> %res
}
declare <8 x i64> @llvm.x86.aesni.aesdeclast.512(<8 x i64>, <8 x i64>) nounwind readnone

; Check for AVX512VNNI
define <16 x i32>@test_int_x86_avx512_mask_vpdpbusd_512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32>* %x2p, <16 x i32> %x4, i16 %x3) {
; CHECK-LABEL: test_int_x86_avx512_mask_vpdpbusd_512:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    kmovd %esi, %k1
; CHECK-NEXT:    vmovaps %zmm0, %zmm3
; CHECK-NEXT:    vpdpbusd (%rdi), %zmm1, %zmm3 {%k1}
; CHECK-NEXT:    vmovaps %zmm0, %zmm4
; CHECK-NEXT:    vpdpbusd %zmm2, %zmm1, %zmm4
; CHECK-NEXT:    vpdpbusd %zmm2, %zmm1, %zmm0 {%k1} {z}
; CHECK-NEXT:    vpaddd %zmm0, %zmm4, %zmm0
; CHECK-NEXT:    vpaddd %zmm0, %zmm3, %zmm0
; CHECK-NEXT:    retq
  %x2 = load <16 x i32>, <16 x i32>* %x2p
  %1 = call <16 x i32> @llvm.x86.avx512.vpdpbusd.512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> %x2)
  %2 = bitcast i16 %x3 to <16 x i1>
  %3 = select <16 x i1> %2, <16 x i32> %1, <16 x i32> %x0
  %4 = call <16 x i32> @llvm.x86.avx512.vpdpbusd.512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> %x4)
  %5 = call <16 x i32> @llvm.x86.avx512.vpdpbusd.512(<16 x i32> %x0, <16 x i32> %x1, <16 x i32> %x4)
  %6 = bitcast i16 %x3 to <16 x i1>
  %7 = select <16 x i1> %6, <16 x i32> %5, <16 x i32> zeroinitializer
  %res3 = add <16 x i32> %3, %4
  %res4 = add <16 x i32> %7, %res3
  ret <16 x i32> %res4
}
declare <16 x i32> @llvm.x86.avx512.vpdpbusd.512(<16 x i32>, <16 x i32>, <16 x i32>)

define void @clwb(i8* %p) nounwind {
; CHECK-LABEL: clwb:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    clwb (%rdi)
; CHECK-NEXT:    retq
  tail call void @llvm.x86.clwb(i8* %p)
  ret void
}
declare void @llvm.x86.clwb(i8*) nounwind

define i32 @test_builtin_rdpid() {
; CHECK-LABEL: test_builtin_rdpid:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    rdpid %rax
; CHECK-NEXT:    ## kill: def $eax killed $eax killed $rax
; CHECK-NEXT:    retq
  %1 = tail call i32 @llvm.x86.rdpid()
  ret i32 %1
}
declare i32 @llvm.x86.rdpid()

define void @wbnoinvd() nounwind {
; CHECK-LABEL: wbnoinvd:
; CHECK:       ## %bb.0:
; CHECK-NEXT:    wbnoinvd
; CHECK-NEXT:    retq
  tail call void @llvm.x86.wbnoinvd()
  ret void
}
declare void @llvm.x86.wbnoinvd() nounwind

; end INTEL_FEATURE_CPU_GLC
