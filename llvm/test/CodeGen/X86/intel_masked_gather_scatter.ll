; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mcpu=skylake-avx512 | FileCheck %s --check-prefix=CHECK --check-prefix=SKX
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mcpu=knl | FileCheck %s --check-prefix=CHECK --check-prefix=KNL

%struct.ST = type { i32, i32 }

; Make sure we don't use a displacement on the gather. The constant from the
; struct offset should be folded into the constant pool load for the vector
; add.
define <8 x i32> @test1(%struct.ST* %base, <8 x i64> %i1) {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vpaddq {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm0, %zmm1
; CHECK-NEXT:    kxnorw %k0, %k0, %k1
; CHECK-NEXT:    vpxor %xmm0, %xmm0, %xmm0
; CHECK-NEXT:    vpgatherqd 4(%rdi,%zmm1,8), %ymm0 {%k1}
; CHECK-NEXT:    retq
entry:
  %add = add <8 x i64> %i1, <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7>
  %arrayidx = getelementptr  %struct.ST, %struct.ST* %base, <8 x i64> %add, i32 1
  %res = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> %arrayidx, i32 4, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> undef)
  ret <8 x i32> %res
}
declare <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*>, i32, <8 x i1>, <8 x i32>)

define <8 x i32> @test2(%struct.ST* %base, <8 x i1> %mask) {
; SKX-LABEL: test2:
; SKX:       # %bb.0: # %entry
; SKX-NEXT:    vpsllw $15, %xmm0, %xmm0
; SKX-NEXT:    vpmovw2m %xmm0, %k1
; SKX-NEXT:    vpbroadcastd 4(%rdi), %ymm0 {%k1} {z}
; SKX-NEXT:    retq
;
; KNL-LABEL: test2:
; KNL:       # %bb.0: # %entry
; KNL-NEXT:    vpmovsxwq %xmm0, %zmm0
; KNL-NEXT:    vpsllq $63, %zmm0, %zmm0
; KNL-NEXT:    vptestmq %zmm0, %zmm0, %k1
; KNL-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; KNL-NEXT:    vpxor %xmm0, %xmm0, %xmm0
; KNL-NEXT:    vpgatherdd 4(%rdi,%zmm1,4), %zmm0 {%k1}
; KNL-NEXT:    # kill: def $ymm0 killed $ymm0 killed $zmm0
; KNL-NEXT:    retq
entry:
  %arrayidx = getelementptr  %struct.ST, %struct.ST* %base, <8 x i64> zeroinitializer, i32 1
  %res = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> %arrayidx, i32 4, <8 x i1> %mask, <8 x i32> undef)
  ret <8 x i32> %res
}

define <8 x i32> @test3(%struct.ST* %base, <8 x i1> %mask) {
; SKX-LABEL: test3:
; SKX:       # %bb.0: # %entry
; SKX-NEXT:    vpsllw $15, %xmm0, %xmm0
; SKX-NEXT:    vpmovw2m %xmm0, %k1
; SKX-NEXT:    vpbroadcastd 4(%rdi), %ymm0 {%k1} {z}
; SKX-NEXT:    retq
;
; KNL-LABEL: test3:
; KNL:       # %bb.0: # %entry
; KNL-NEXT:    vpmovsxwq %xmm0, %zmm0
; KNL-NEXT:    vpsllq $63, %zmm0, %zmm0
; KNL-NEXT:    vptestmq %zmm0, %zmm0, %k1
; KNL-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; KNL-NEXT:    vpxor %xmm0, %xmm0, %xmm0
; KNL-NEXT:    vpgatherdd 4(%rdi,%zmm1,4), %zmm0 {%k1}
; KNL-NEXT:    # kill: def $ymm0 killed $ymm0 killed $zmm0
; KNL-NEXT:    retq
entry:
  %arrayidx = getelementptr  %struct.ST, %struct.ST* %base, <8 x i64> zeroinitializer, i32 1
  %res = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> %arrayidx, i32 4, <8 x i1> %mask, <8 x i32> zeroinitializer)
  ret <8 x i32> %res
}

define <8 x i32> @test4(%struct.ST* %base, <8 x i32> %passthru, <8 x i1> %mask) {
; SKX-LABEL: test4:
; SKX:       # %bb.0: # %entry
; SKX-NEXT:    vpsllw $15, %xmm1, %xmm1
; SKX-NEXT:    vpmovw2m %xmm1, %k1
; SKX-NEXT:    vpbroadcastd 4(%rdi), %ymm0 {%k1}
; SKX-NEXT:    retq
;
; KNL-LABEL: test4:
; KNL:       # %bb.0: # %entry
; KNL-NEXT:    # kill: def $ymm0 killed $ymm0 def $zmm0
; KNL-NEXT:    vpmovsxwq %xmm1, %zmm1
; KNL-NEXT:    vpsllq $63, %zmm1, %zmm1
; KNL-NEXT:    vptestmq %zmm1, %zmm1, %k1
; KNL-NEXT:    vpxor %xmm1, %xmm1, %xmm1
; KNL-NEXT:    vpgatherdd 4(%rdi,%zmm1,4), %zmm0 {%k1}
; KNL-NEXT:    # kill: def $ymm0 killed $ymm0 killed $zmm0
; KNL-NEXT:    retq
entry:
  %arrayidx = getelementptr  %struct.ST, %struct.ST* %base, <8 x i64> zeroinitializer, i32 1
  %res = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> %arrayidx, i32 4, <8 x i1> %mask, <8 x i32> %passthru)
  ret <8 x i32> %res
}

define <8 x i32> @test5(%struct.ST* %base) {
; CHECK-LABEL: test5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vbroadcastss 4(%rdi), %ymm0
; CHECK-NEXT:    retq
entry:
  %arrayidx = getelementptr  %struct.ST, %struct.ST* %base, <8 x i64> zeroinitializer, i32 1
  %res = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> %arrayidx, i32 4, <8 x i1> <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>, <8 x i32> undef)
  ret <8 x i32> %res
}

; Make sure we can fold stack addresses into gather.
%struct.ST2 = type { i32, [8 x i32] }

define <8 x i32> @test6(<8 x i1> %mask, <8 x i64> %index) {
; SKX-LABEL: test6:
; SKX:       # %bb.0: # %entry
; SKX-NEXT:    vpsllw $15, %xmm0, %xmm0
; SKX-NEXT:    vpmovw2m %xmm0, %k1
; SKX-NEXT:    vpxor %xmm0, %xmm0, %xmm0
; SKX-NEXT:    vpgatherqd -36(%rsp,%zmm1,4), %ymm0 {%k1}
; SKX-NEXT:    retq
;
; KNL-LABEL: test6:
; KNL:       # %bb.0: # %entry
; KNL-NEXT:    vpmovsxwq %xmm0, %zmm0
; KNL-NEXT:    vpsllq $63, %zmm0, %zmm0
; KNL-NEXT:    vptestmq %zmm0, %zmm0, %k1
; KNL-NEXT:    vpxor %xmm0, %xmm0, %xmm0
; KNL-NEXT:    vpgatherqd -36(%rsp,%zmm1,4), %ymm0 {%k1}
; KNL-NEXT:    retq
entry:
  %base = alloca %struct.ST2
  %gep = getelementptr %struct.ST2, %struct.ST2* %base, i32 0, i32 1
  %arrayidx = getelementptr [8 x i32], [8 x i32]* %gep, i32 0, <8 x i64> %index
  %res = call <8 x i32> @llvm.masked.gather.v8i32.v8p0i32(<8 x i32*> %arrayidx, i32 4, <8 x i1> %mask, <8 x i32> undef)
  ret <8 x i32> %res
}

