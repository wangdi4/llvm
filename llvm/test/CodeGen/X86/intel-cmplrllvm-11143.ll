; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu | FileCheck %s

; This code contains a loop that has been unrolled 8 times. It calculates the
; max value of a bunch of memory location and saves the corresponding index of
; the max element. So there are 8 pairs of selects chained together. One of the
; selects in each pair calculates the running max and one updates the index if
; the max changes.
;
; The goal of this test is to ensure that we keep the selects as cmoves in the
; final assembly. Rather than having them converted to control flow by the
; cmov conversion pass.

define void @widget([240 x i32]* %arg, i32* %arg1, i32* %arg2, i64 %arg3) {
; CHECK-LABEL: widget:
; CHECK:       # %bb.0: # %bb
; CHECK-NEXT:    incq %rcx
; CHECK-NEXT:    movl $-1000000, %eax # imm = 0xFFF0BDC0
; CHECK-NEXT:    xorl %r8d, %r8d
; CHECK-NEXT:    # implicit-def: $r9d
; CHECK-NEXT:    .p2align 4, 0x90
; CHECK-NEXT:  .LBB0_1: # %bb4
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movl (%rdi,%r8,4), %r10d
; CHECK-NEXT:    movl 4(%rdi,%r8,4), %r11d
; CHECK-NEXT:    cmpl %eax, %r10d
; CHECK-NEXT:    cmovgl %r8d, %r9d
; CHECK-NEXT:    cmovgl %r10d, %eax
; CHECK-NEXT:    leal 1(%r8), %r10d
; CHECK-NEXT:    cmpl %eax, %r11d
; CHECK-NEXT:    cmovlel %r9d, %r10d
; CHECK-NEXT:    cmovgl %r11d, %eax
; CHECK-NEXT:    movl 8(%rdi,%r8,4), %r9d
; CHECK-NEXT:    leal 2(%r8), %r11d
; CHECK-NEXT:    cmpl %eax, %r9d
; CHECK-NEXT:    cmovlel %r10d, %r11d
; CHECK-NEXT:    cmovgl %r9d, %eax
; CHECK-NEXT:    movl 12(%rdi,%r8,4), %r9d
; CHECK-NEXT:    leal 3(%r8), %r10d
; CHECK-NEXT:    cmpl %eax, %r9d
; CHECK-NEXT:    cmovlel %r11d, %r10d
; CHECK-NEXT:    cmovgl %r9d, %eax
; CHECK-NEXT:    movl 16(%rdi,%r8,4), %r9d
; CHECK-NEXT:    leal 4(%r8), %r11d
; CHECK-NEXT:    cmpl %eax, %r9d
; CHECK-NEXT:    cmovlel %r10d, %r11d
; CHECK-NEXT:    cmovgl %r9d, %eax
; CHECK-NEXT:    movl 20(%rdi,%r8,4), %r9d
; CHECK-NEXT:    leal 5(%r8), %r10d
; CHECK-NEXT:    cmpl %eax, %r9d
; CHECK-NEXT:    cmovlel %r11d, %r10d
; CHECK-NEXT:    cmovgl %r9d, %eax
; CHECK-NEXT:    movl 24(%rdi,%r8,4), %r9d
; CHECK-NEXT:    leal 6(%r8), %r11d
; CHECK-NEXT:    cmpl %eax, %r9d
; CHECK-NEXT:    cmovlel %r10d, %r11d
; CHECK-NEXT:    cmovgl %r9d, %eax
; CHECK-NEXT:    movl 28(%rdi,%r8,4), %r10d
; CHECK-NEXT:    leal 7(%r8), %r9d
; CHECK-NEXT:    cmpl %eax, %r10d
; CHECK-NEXT:    cmovlel %r11d, %r9d
; CHECK-NEXT:    cmovgl %r10d, %eax
; CHECK-NEXT:    addq $8, %r8
; CHECK-NEXT:    decq %rcx
; CHECK-NEXT:    jne .LBB0_1
; CHECK-NEXT:  # %bb.2: # %bb65
; CHECK-NEXT:    movl %r9d, (%rsi)
; CHECK-NEXT:    movl %eax, (%rdx)
; CHECK-NEXT:    retq
bb:
  br label %bb4

bb4:                                              ; preds = %bb4, %bb
  %tmp = phi i64 [ 0, %bb ], [ %tmp63, %bb4 ]
  %tmp5 = phi i32 [ -1000000, %bb ], [ %tmp62, %bb4 ]
  %tmp6 = phi i32 [ undef, %bb ], [ %tmp61, %bb4 ]
  %tmp7 = shl i64 %tmp, 3
  %tmp8 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp7
  %tmp9 = load i32, i32* %tmp8, align 16
  %tmp10 = trunc i64 %tmp7 to i32
  %tmp11 = icmp sgt i32 %tmp9, %tmp5
  %tmp12 = select i1 %tmp11, i32 %tmp10, i32 %tmp6
  %tmp13 = select i1 %tmp11, i32 %tmp9, i32 %tmp5
  %tmp14 = or i64 %tmp7, 1
  %tmp15 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp14
  %tmp16 = load i32, i32* %tmp15, align 4
  %tmp17 = trunc i64 %tmp14 to i32
  %tmp18 = icmp sgt i32 %tmp16, %tmp13
  %tmp19 = select i1 %tmp18, i32 %tmp17, i32 %tmp12
  %tmp20 = select i1 %tmp18, i32 %tmp16, i32 %tmp13
  %tmp21 = or i64 %tmp7, 2
  %tmp22 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp21
  %tmp23 = load i32, i32* %tmp22, align 8
  %tmp24 = trunc i64 %tmp21 to i32
  %tmp25 = icmp sgt i32 %tmp23, %tmp20
  %tmp26 = select i1 %tmp25, i32 %tmp24, i32 %tmp19
  %tmp27 = select i1 %tmp25, i32 %tmp23, i32 %tmp20
  %tmp28 = or i64 %tmp7, 3
  %tmp29 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp28
  %tmp30 = load i32, i32* %tmp29, align 4
  %tmp31 = trunc i64 %tmp28 to i32
  %tmp32 = icmp sgt i32 %tmp30, %tmp27
  %tmp33 = select i1 %tmp32, i32 %tmp31, i32 %tmp26
  %tmp34 = select i1 %tmp32, i32 %tmp30, i32 %tmp27
  %tmp35 = or i64 %tmp7, 4
  %tmp36 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp35
  %tmp37 = load i32, i32* %tmp36, align 16
  %tmp38 = trunc i64 %tmp35 to i32
  %tmp39 = icmp sgt i32 %tmp37, %tmp34
  %tmp40 = select i1 %tmp39, i32 %tmp38, i32 %tmp33
  %tmp41 = select i1 %tmp39, i32 %tmp37, i32 %tmp34
  %tmp42 = or i64 %tmp7, 5
  %tmp43 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp42
  %tmp44 = load i32, i32* %tmp43, align 4
  %tmp45 = trunc i64 %tmp42 to i32
  %tmp46 = icmp sgt i32 %tmp44, %tmp41
  %tmp47 = select i1 %tmp46, i32 %tmp45, i32 %tmp40
  %tmp48 = select i1 %tmp46, i32 %tmp44, i32 %tmp41
  %tmp49 = or i64 %tmp7, 6
  %tmp50 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp49
  %tmp51 = load i32, i32* %tmp50, align 8
  %tmp52 = trunc i64 %tmp49 to i32
  %tmp53 = icmp sgt i32 %tmp51, %tmp48
  %tmp54 = select i1 %tmp53, i32 %tmp52, i32 %tmp47
  %tmp55 = select i1 %tmp53, i32 %tmp51, i32 %tmp48
  %tmp56 = or i64 %tmp7, 7
  %tmp57 = getelementptr inbounds [240 x i32], [240 x i32]* %arg, i64 0, i64 %tmp56
  %tmp58 = load i32, i32* %tmp57, align 4
  %tmp59 = trunc i64 %tmp56 to i32
  %tmp60 = icmp sgt i32 %tmp58, %tmp55
  %tmp61 = select i1 %tmp60, i32 %tmp59, i32 %tmp54
  %tmp62 = select i1 %tmp60, i32 %tmp58, i32 %tmp55
  %tmp63 = add nuw nsw i64 %tmp, 1
  %tmp64 = icmp eq i64 %tmp, %arg3
  br i1 %tmp64, label %bb65, label %bb4

bb65:                                             ; preds = %bb4
  store i32 %tmp61, i32* %arg1
  store i32 %tmp62, i32* %arg2
  ret void
}
