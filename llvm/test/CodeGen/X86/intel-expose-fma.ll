; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-linux-gnu -mcpu=skylake-avx512 | FileCheck %s

; Basic test:
; R1 = (A - X) * Y
; R2 = (B - X) * Y
;  =>
; R0 = X * Y
; R1 = A * Y - R0
; R2 = B * Y - R0
; That may seems like doing additional multiplication, but
; R1 and R2 computations can be turned into FMA-like instruction.
; According to instruction tables, latencies and throughput of
; vsubss, vmulss and vfmsubXXXss are equal. So after generating
; FMSub instructions we win 1 operation.

define i1 @basic_test(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: basic_test:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm2 = (xmm2 * xmm0) - xmm1
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm0 = (xmm0 * mem) - xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; No combine (values must come from loads)
define i1 @basic_test_no_loads(float %A, float %B, float %X, float %Y) "unsafe-fp-math"="true"{
; CHECK-LABEL: basic_test_no_loads:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vsubss %xmm2, %xmm0, %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm0, %xmm0
; CHECK-NEXT:    vsubss %xmm2, %xmm1, %xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm1, %xmm0
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; No combine no unsafe attribute
define i1 @no_unsafe_attrib(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) {
; CHECK-LABEL: no_unsafe_attrib:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm3 = mem[0],zero,zero,zero
; CHECK-NEXT:    vsubss %xmm2, %xmm0, %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm0, %xmm0
; CHECK-NEXT:    vsubss %xmm2, %xmm1, %xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm1, %xmm0
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; No combine (Y should have only 2 users)
define i1 @Y_has_other_users(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: Y_has_other_users:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm3 = mem[0],zero,zero,zero
; CHECK-NEXT:    vsubss %xmm2, %xmm0, %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm0, %xmm0
; CHECK-NEXT:    vsubss %xmm2, %xmm1, %xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm1, %xmm0
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    vucomiss %xmm3, %xmm0
; CHECK-NEXT:    seta %dl
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    orb %dl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %cmp3 = fcmp fast olt float %Y, 3.000000e+00
  %ret = or i1 %cmp1, %cmp2
  %ret2 = or i1 %ret, %cmp3
  ret i1 %ret2
}

; No combine (fsub should have single user)
define i1 @sub1_has_other_users(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: sub1_has_other_users:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm3 = mem[0],zero,zero,zero
; CHECK-NEXT:    vsubss %xmm2, %xmm0, %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm0, %xmm4
; CHECK-NEXT:    vsubss %xmm2, %xmm1, %xmm1
; CHECK-NEXT:    vmulss %xmm3, %xmm1, %xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm4
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm1
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    orb %al, %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  %cmp3 = fcmp fast olt float %sub1, 3.000000e+00
  %ret2 = or i1 %ret, %cmp3
  ret i1 %ret2
}

; No combine (fsub should have single user)
define i1 @sub2_has_other_users(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: sub2_has_other_users:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm1 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmovss {{.*#+}} xmm3 = mem[0],zero,zero,zero
; CHECK-NEXT:    vsubss %xmm2, %xmm0, %xmm0
; CHECK-NEXT:    vmulss %xmm3, %xmm0, %xmm0
; CHECK-NEXT:    vsubss %xmm2, %xmm1, %xmm1
; CHECK-NEXT:    vmulss %xmm3, %xmm1, %xmm2
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    orb %al, %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm1
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  %cmp3 = fcmp fast olt float %sub2, 3.000000e+00
  %ret2 = or i1 %ret, %cmp3
  ret i1 %ret2
}

; Combine:
; R1 = (X - A) * Y
; R2 = (X - B) * Y
define i1 @swap_operands1(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: swap_operands1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfnmadd132ss {{.*#+}} xmm2 = -(xmm2 * xmm0) + xmm1
; CHECK-NEXT:    vfnmadd132ss {{.*#+}} xmm0 = -(xmm0 * mem) + xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %X, %A
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %X, %B
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = (X - A) * Y
; R2 = (B - X) * Y
define i1 @swap_operands2(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: swap_operands2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfnmadd132ss {{.*#+}} xmm2 = -(xmm2 * xmm0) + xmm1
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm0 = (xmm0 * mem) - xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %X, %A
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = (A - X) * Y
; R2 = (X - B) * Y
define i1 @swap_operands3(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: swap_operands3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm2 = (xmm2 * xmm0) - xmm1
; CHECK-NEXT:    vfnmadd132ss {{.*#+}} xmm0 = -(xmm0 * mem) + xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %X, %B
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = (A - X) * Y
; R2 = Y * (B - X)
define i1 @swap_operands4(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: swap_operands4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm2 = (xmm2 * xmm0) - xmm1
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm0 = (xmm0 * mem) - xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %Y, %sub2
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = Y * (A - X)
; R2 = (B - X) * Y
define i1 @swap_operands5(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: swap_operands5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm2 = (xmm2 * xmm0) - xmm1
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm0 = (xmm0 * mem) - xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %Y, %sub1
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; Combine:
; R1 = Y * (A - X)
; R2 = Y * (B - X)
define i1 @swap_operands6(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: swap_operands6:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm2 = (xmm2 * xmm0) - xmm1
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm0 = (xmm0 * mem) - xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %Y, %sub1
  %sub2 = fsub fast float %B, %X
  %mul2 = fmul fast float %Y, %sub2
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; We do the same transformation for additions
; R1 = (A + X) * Y
; R2 = (B + X) * Y
define i1 @basic_test_add(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: basic_test_add:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfmadd132ss {{.*#+}} xmm2 = (xmm2 * xmm0) + xmm1
; CHECK-NEXT:    vfmadd132ss {{.*#+}} xmm0 = (xmm0 * mem) + xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fadd fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fadd fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}

; We also handle mixed sub and add instructions.
; R1 = (A - X) * Y
; R2 = (B + X) * Y
define i1 @mixed_sub_and_add(float* %ptrA, float* %ptrB, float* %ptrX, float* %ptrY) "unsafe-fp-math"="true" {
; CHECK-LABEL: mixed_sub_and_add:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vmulss (%rdx), %xmm0, %xmm1
; CHECK-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero
; CHECK-NEXT:    vfmsub132ss {{.*#+}} xmm2 = (xmm2 * xmm0) - xmm1
; CHECK-NEXT:    vfmadd132ss {{.*#+}} xmm0 = (xmm0 * mem) + xmm1
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm2
; CHECK-NEXT:    setb %cl
; CHECK-NEXT:    vucomiss {{.*}}(%rip), %xmm0
; CHECK-NEXT:    setb %al
; CHECK-NEXT:    orb %cl, %al
; CHECK-NEXT:    retq
entry:
  %A = load float, float* %ptrA
  %B = load float, float* %ptrB
  %X = load float, float* %ptrX
  %Y = load float, float* %ptrY
  %sub1 = fsub fast float %A, %X
  %mul1 = fmul fast float %sub1, %Y
  %sub2 = fadd fast float %B, %X
  %mul2 = fmul fast float %sub2, %Y
  %cmp1 = fcmp fast olt float %mul1, 1.000000e+00
  %cmp2 = fcmp fast olt float %mul2, 2.000000e+00
  %ret = or i1 %cmp1, %cmp2
  ret i1 %ret
}
