; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -x86-enable-unaligned-vector-move -mattr=sse4.2 | FileCheck %s -check-prefix=CHECK_SSE
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -x86-enable-unaligned-vector-move -mattr=avx  | FileCheck %s -check-prefix=CHECK_AVX
; RUN: llc < %s -mtriple=i686-unknown-unknown -x86-enable-unaligned-vector-move -mattr=sse4.2 | FileCheck %s -check-prefix=CHECK_SSE32
; RUN: llc < %s -mtriple=i686-unknown-unknown -x86-enable-unaligned-vector-move -mattr=avx | FileCheck %s -check-prefix=CHECK_AVX32

define void @test_256_load(double* nocapture %d, float* nocapture %f, <4 x i64>* nocapture %i) nounwind {
; CHECK_SSE-LABEL: test_256_load:
; CHECK_SSE:       # %bb.0: # %entry
; CHECK_SSE-NEXT:    pushq %r15
; CHECK_SSE-NEXT:    pushq %r14
; CHECK_SSE-NEXT:    pushq %rbx
; CHECK_SSE-NEXT:    subq $96, %rsp
; CHECK_SSE-NEXT:    movq %rdx, %rbx
; CHECK_SSE-NEXT:    movq %rsi, %r14
; CHECK_SSE-NEXT:    movq %rdi, %r15
; CHECK_SSE-NEXT:    movaps (%rdx), %xmm4
; CHECK_SSE-NEXT:    movaps %xmm4, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps 16(%rdx), %xmm5
; CHECK_SSE-NEXT:    movaps %xmm5, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps (%rsi), %xmm2
; CHECK_SSE-NEXT:    movaps %xmm2, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps 16(%rsi), %xmm3
; CHECK_SSE-NEXT:    movaps %xmm3, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps (%rdi), %xmm0
; CHECK_SSE-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps 16(%rdi), %xmm1
; CHECK_SSE-NEXT:    movaps %xmm1, (%rsp) # 16-byte Spill
; CHECK_SSE-NEXT:    callq dummy@PLT
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, (%r15)
; CHECK_SSE-NEXT:    movaps (%rsp), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, 16(%r15)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, (%r14)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, 16(%r14)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, (%rbx)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, 16(%rbx)
; CHECK_SSE-NEXT:    addq $96, %rsp
; CHECK_SSE-NEXT:    popq %rbx
; CHECK_SSE-NEXT:    popq %r14
; CHECK_SSE-NEXT:    popq %r15
; CHECK_SSE-NEXT:    retq
;
; CHECK_AVX-LABEL: test_256_load:
; CHECK_AVX:       # %bb.0: # %entry
; CHECK_AVX-NEXT:    pushq %r15
; CHECK_AVX-NEXT:    pushq %r14
; CHECK_AVX-NEXT:    pushq %rbx
; CHECK_AVX-NEXT:    subq $96, %rsp
; CHECK_AVX-NEXT:    movq %rdx, %rbx
; CHECK_AVX-NEXT:    movq %rsi, %r14
; CHECK_AVX-NEXT:    movq %rdi, %r15
; CHECK_AVX-NEXT:    vmovups (%rdi), %ymm0 # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vmovups %ymm0, {{[-0-9]+}}(%r{{[sb]}}p) # 32-byte Spill
; CHECK_AVX-NEXT:    vmovups (%rsi), %ymm1 # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vmovups %ymm1, {{[-0-9]+}}(%r{{[sb]}}p) # 32-byte Spill
; CHECK_AVX-NEXT:    vmovups (%rdx), %ymm2 # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vmovups %ymm2, (%rsp) # 32-byte Spill
; CHECK_AVX-NEXT:    callq dummy@PLT
; CHECK_AVX-NEXT:    vmovups {{[-0-9]+}}(%r{{[sb]}}p), %ymm0 # 32-byte Reload
; CHECK_AVX-NEXT:    vmovups %ymm0, (%r15) # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vmovups {{[-0-9]+}}(%r{{[sb]}}p), %ymm0 # 32-byte Reload
; CHECK_AVX-NEXT:    vmovups %ymm0, (%r14) # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vmovups (%rsp), %ymm0 # 32-byte Reload
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rbx) # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    addq $96, %rsp
; CHECK_AVX-NEXT:    popq %rbx
; CHECK_AVX-NEXT:    popq %r14
; CHECK_AVX-NEXT:    popq %r15
; CHECK_AVX-NEXT:    vzeroupper
; CHECK_AVX-NEXT:    retq
;
; CHECK_SSE32-LABEL: test_256_load:
; CHECK_SSE32:       # %bb.0: # %entry
; CHECK_SSE32-NEXT:    pushl %ebp
; CHECK_SSE32-NEXT:    movl %esp, %ebp
; CHECK_SSE32-NEXT:    pushl %ebx
; CHECK_SSE32-NEXT:    pushl %edi
; CHECK_SSE32-NEXT:    pushl %esi
; CHECK_SSE32-NEXT:    andl $-16, %esp
; CHECK_SSE32-NEXT:    subl $160, %esp
; CHECK_SSE32-NEXT:    movl 16(%ebp), %esi
; CHECK_SSE32-NEXT:    movl 12(%ebp), %edi
; CHECK_SSE32-NEXT:    movl 8(%ebp), %ebx
; CHECK_SSE32-NEXT:    movaps (%ebx), %xmm0
; CHECK_SSE32-NEXT:    movaps %xmm0, {{[-0-9]+}}(%e{{[sb]}}p) # 16-byte Spill
; CHECK_SSE32-NEXT:    movaps 16(%ebx), %xmm1
; CHECK_SSE32-NEXT:    movaps %xmm1, {{[-0-9]+}}(%e{{[sb]}}p) # 16-byte Spill
; CHECK_SSE32-NEXT:    movaps (%edi), %xmm2
; CHECK_SSE32-NEXT:    movaps %xmm2, {{[-0-9]+}}(%e{{[sb]}}p) # 16-byte Spill
; CHECK_SSE32-NEXT:    movaps 16(%edi), %xmm3
; CHECK_SSE32-NEXT:    movaps %xmm3, {{[-0-9]+}}(%e{{[sb]}}p) # 16-byte Spill
; CHECK_SSE32-NEXT:    movaps (%esi), %xmm4
; CHECK_SSE32-NEXT:    movaps %xmm4, {{[-0-9]+}}(%e{{[sb]}}p) # 16-byte Spill
; CHECK_SSE32-NEXT:    movaps 16(%esi), %xmm5
; CHECK_SSE32-NEXT:    movaps %xmm5, {{[-0-9]+}}(%e{{[sb]}}p) # 16-byte Spill
; CHECK_SSE32-NEXT:    movaps %xmm5, {{[0-9]+}}(%esp)
; CHECK_SSE32-NEXT:    movaps %xmm4, {{[0-9]+}}(%esp)
; CHECK_SSE32-NEXT:    movaps %xmm3, (%esp)
; CHECK_SSE32-NEXT:    calll dummy@PLT
; CHECK_SSE32-NEXT:    movaps {{[-0-9]+}}(%e{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE32-NEXT:    movaps %xmm0, (%ebx)
; CHECK_SSE32-NEXT:    movaps {{[-0-9]+}}(%e{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE32-NEXT:    movaps %xmm0, 16(%ebx)
; CHECK_SSE32-NEXT:    movaps {{[-0-9]+}}(%e{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE32-NEXT:    movaps %xmm0, (%edi)
; CHECK_SSE32-NEXT:    movaps {{[-0-9]+}}(%e{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE32-NEXT:    movaps %xmm0, 16(%edi)
; CHECK_SSE32-NEXT:    movaps {{[-0-9]+}}(%e{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE32-NEXT:    movaps %xmm0, (%esi)
; CHECK_SSE32-NEXT:    movaps {{[-0-9]+}}(%e{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE32-NEXT:    movaps %xmm0, 16(%esi)
; CHECK_SSE32-NEXT:    leal -12(%ebp), %esp
; CHECK_SSE32-NEXT:    popl %esi
; CHECK_SSE32-NEXT:    popl %edi
; CHECK_SSE32-NEXT:    popl %ebx
; CHECK_SSE32-NEXT:    popl %ebp
; CHECK_SSE32-NEXT:    retl
;
; CHECK_AVX32-LABEL: test_256_load:
; CHECK_AVX32:       # %bb.0: # %entry
; CHECK_AVX32-NEXT:    pushl %ebx
; CHECK_AVX32-NEXT:    pushl %edi
; CHECK_AVX32-NEXT:    pushl %esi
; CHECK_AVX32-NEXT:    subl $96, %esp
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %esi
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %edi
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %ebx
; CHECK_AVX32-NEXT:    vmovups (%ebx), %ymm0 # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vmovups %ymm0, {{[-0-9]+}}(%e{{[sb]}}p) # 32-byte Spill
; CHECK_AVX32-NEXT:    vmovups (%edi), %ymm1 # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vmovups %ymm1, {{[-0-9]+}}(%e{{[sb]}}p) # 32-byte Spill
; CHECK_AVX32-NEXT:    vmovups (%esi), %ymm2 # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vmovups %ymm2, (%esp) # 32-byte Spill
; CHECK_AVX32-NEXT:    calll dummy@PLT
; CHECK_AVX32-NEXT:    vmovups {{[-0-9]+}}(%e{{[sb]}}p), %ymm0 # 32-byte Reload
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%ebx) # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vmovups {{[-0-9]+}}(%e{{[sb]}}p), %ymm0 # 32-byte Reload
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%edi) # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vmovups (%esp), %ymm0 # 32-byte Reload
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%esi) # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    addl $96, %esp
; CHECK_AVX32-NEXT:    popl %esi
; CHECK_AVX32-NEXT:    popl %edi
; CHECK_AVX32-NEXT:    popl %ebx
; CHECK_AVX32-NEXT:    vzeroupper
; CHECK_AVX32-NEXT:    retl
entry:
  %0 = bitcast double* %d to <4 x double>*
  %tmp1.i = load <4 x double>, <4 x double>* %0, align 32
  %1 = bitcast float* %f to <8 x float>*
  %tmp1.i17 = load <8 x float>, <8 x float>* %1, align 32
  %tmp1.i16 = load <4 x i64>, <4 x i64>* %i, align 32
  tail call void @dummy(<4 x double> %tmp1.i, <8 x float> %tmp1.i17, <4 x i64> %tmp1.i16) nounwind
  store <4 x double> %tmp1.i, <4 x double>* %0, align 32
  store <8 x float> %tmp1.i17, <8 x float>* %1, align 32
  store <4 x i64> %tmp1.i16, <4 x i64>* %i, align 32
  ret void
}

declare void @dummy(<4 x double>, <8 x float>, <4 x i64>)

define void @storev16i16(<16 x i16> %a) nounwind {
; CHECK_SSE-LABEL: storev16i16:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, (%rax)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rax)
;
; CHECK_AVX-LABEL: storev16i16:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rax) # AlignMOV convert to UnAlignMOV
;
; CHECK_SSE32-LABEL: storev16i16:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movaps %xmm1, (%eax)
; CHECK_SSE32-NEXT:    movaps %xmm0, (%eax)
;
; CHECK_AVX32-LABEL: storev16i16:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax) # AlignMOV convert to UnAlignMOV
  store <16 x i16> %a, <16 x i16>* undef, align 32
  unreachable
}

define void @storev16i16_01(<16 x i16> %a) nounwind {
; CHECK_SSE-LABEL: storev16i16_01:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movups %xmm1, (%rax)
; CHECK_SSE-NEXT:    movups %xmm0, (%rax)
;
; CHECK_AVX-LABEL: storev16i16_01:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rax)
;
; CHECK_SSE32-LABEL: storev16i16_01:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movups %xmm1, (%eax)
; CHECK_SSE32-NEXT:    movups %xmm0, (%eax)
;
; CHECK_AVX32-LABEL: storev16i16_01:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax)
  store <16 x i16> %a, <16 x i16>* undef, align 4
  unreachable
}

define void @storev32i8(<32 x i8> %a) nounwind {
; CHECK_SSE-LABEL: storev32i8:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, (%rax)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rax)
;
; CHECK_AVX-LABEL: storev32i8:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rax) # AlignMOV convert to UnAlignMOV
;
; CHECK_SSE32-LABEL: storev32i8:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movaps %xmm1, (%eax)
; CHECK_SSE32-NEXT:    movaps %xmm0, (%eax)
;
; CHECK_AVX32-LABEL: storev32i8:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax) # AlignMOV convert to UnAlignMOV
  store <32 x i8> %a, <32 x i8>* undef, align 32
  unreachable
}

define void @storev32i8_01(<32 x i8> %a) nounwind {
; CHECK_SSE-LABEL: storev32i8_01:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movups %xmm1, (%rax)
; CHECK_SSE-NEXT:    movups %xmm0, (%rax)
;
; CHECK_AVX-LABEL: storev32i8_01:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rax)
;
; CHECK_SSE32-LABEL: storev32i8_01:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movups %xmm1, (%eax)
; CHECK_SSE32-NEXT:    movups %xmm0, (%eax)
;
; CHECK_AVX32-LABEL: storev32i8_01:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax)
  store <32 x i8> %a, <32 x i8>* undef, align 4
  unreachable
}

; It is faster to make two saves, if the data is already in xmm registers. For
; example, after making an integer operation.
define void @double_save(<4 x i32> %A, <4 x i32> %B, <8 x i32>* %P) nounwind ssp {
; CHECK_SSE-LABEL: double_save:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK_AVX-LABEL: double_save:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups %xmm1, 16(%rdi) # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vmovups %xmm0, (%rdi) # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    retq
;
; CHECK_SSE32-LABEL: double_save:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_SSE32-NEXT:    movaps %xmm1, 16(%eax)
; CHECK_SSE32-NEXT:    movaps %xmm0, (%eax)
; CHECK_SSE32-NEXT:    retl
;
; CHECK_AVX32-LABEL: double_save:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_AVX32-NEXT:    vmovups %xmm1, 16(%eax) # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vmovups %xmm0, (%eax) # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    retl
  %Z = shufflevector <4 x i32>%A, <4 x i32>%B, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i32> %Z, <8 x i32>* %P, align 16
  ret void
}

define void @double_save_volatile(<4 x i32> %A, <4 x i32> %B, <8 x i32>* %P) nounwind {
; CHECK_SSE-LABEL: double_save_volatile:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK_AVX-LABEL: double_save_volatile:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    # kill: def $xmm0 killed $xmm0 def $ymm0
; CHECK_AVX-NEXT:    vinsertf128 $1, %xmm1, %ymm0, %ymm0
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rdi)
; CHECK_AVX-NEXT:    vzeroupper
; CHECK_AVX-NEXT:    retq
;
; CHECK_SSE32-LABEL: double_save_volatile:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_SSE32-NEXT:    movaps %xmm1, 16(%eax)
; CHECK_SSE32-NEXT:    movaps %xmm0, (%eax)
; CHECK_SSE32-NEXT:    retl
;
; CHECK_AVX32-LABEL: double_save_volatile:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    # kill: def $xmm0 killed $xmm0 def $ymm0
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_AVX32-NEXT:    vinsertf128 $1, %xmm1, %ymm0, %ymm0
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax)
; CHECK_AVX32-NEXT:    vzeroupper
; CHECK_AVX32-NEXT:    retl
  %Z = shufflevector <4 x i32>%A, <4 x i32>%B, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store volatile <8 x i32> %Z, <8 x i32>* %P, align 16
  ret void
}

define void @add8i32(<8 x i32>* %ret, <8 x i32>* %bp) nounwind {
; CHECK_SSE-LABEL: add8i32:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movups (%rsi), %xmm0
; CHECK_SSE-NEXT:    movups 16(%rsi), %xmm1
; CHECK_SSE-NEXT:    movups %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movups %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK_AVX-LABEL: add8i32:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups (%rsi), %ymm0
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rdi)
; CHECK_AVX-NEXT:    vzeroupper
; CHECK_AVX-NEXT:    retq
;
; CHECK_SSE32-LABEL: add8i32:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK_SSE32-NEXT:    movups (%ecx), %xmm0
; CHECK_SSE32-NEXT:    movups 16(%ecx), %xmm1
; CHECK_SSE32-NEXT:    movups %xmm1, 16(%eax)
; CHECK_SSE32-NEXT:    movups %xmm0, (%eax)
; CHECK_SSE32-NEXT:    retl
;
; CHECK_AVX32-LABEL: add8i32:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK_AVX32-NEXT:    vmovups (%ecx), %ymm0
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax)
; CHECK_AVX32-NEXT:    vzeroupper
; CHECK_AVX32-NEXT:    retl
  %b = load <8 x i32>, <8 x i32>* %bp, align 1
  %x = add <8 x i32> zeroinitializer, %b
  store <8 x i32> %x, <8 x i32>* %ret, align 1
  ret void
}

define void @add4i64a64(<4 x i64>* %ret, <4 x i64>* %bp) nounwind {
; CHECK_SSE-LABEL: add4i64a64:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps (%rsi), %xmm0
; CHECK_SSE-NEXT:    movaps 16(%rsi), %xmm1
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK_AVX-LABEL: add4i64a64:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups (%rsi), %ymm0 # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rdi) # AlignMOV convert to UnAlignMOV
; CHECK_AVX-NEXT:    vzeroupper
; CHECK_AVX-NEXT:    retq
;
; CHECK_SSE32-LABEL: add4i64a64:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK_SSE32-NEXT:    movaps (%ecx), %xmm0
; CHECK_SSE32-NEXT:    movaps 16(%ecx), %xmm1
; CHECK_SSE32-NEXT:    movaps %xmm0, (%eax)
; CHECK_SSE32-NEXT:    movaps %xmm1, 16(%eax)
; CHECK_SSE32-NEXT:    retl
;
; CHECK_AVX32-LABEL: add4i64a64:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK_AVX32-NEXT:    vmovups (%ecx), %ymm0 # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax) # AlignMOV convert to UnAlignMOV
; CHECK_AVX32-NEXT:    vzeroupper
; CHECK_AVX32-NEXT:    retl
  %b = load <4 x i64>, <4 x i64>* %bp, align 64
  %x = add <4 x i64> zeroinitializer, %b
  store <4 x i64> %x, <4 x i64>* %ret, align 64
  ret void
}

define void @add4i64a16(<4 x i64>* %ret, <4 x i64>* %bp) nounwind {
; CHECK_SSE-LABEL: add4i64a16:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps (%rsi), %xmm0
; CHECK_SSE-NEXT:    movaps 16(%rsi), %xmm1
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK_AVX-LABEL: add4i64a16:
; CHECK_AVX:       # %bb.0:
; CHECK_AVX-NEXT:    vmovups (%rsi), %ymm0
; CHECK_AVX-NEXT:    vmovups %ymm0, (%rdi)
; CHECK_AVX-NEXT:    vzeroupper
; CHECK_AVX-NEXT:    retq
;
; CHECK_SSE32-LABEL: add4i64a16:
; CHECK_SSE32:       # %bb.0:
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_SSE32-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK_SSE32-NEXT:    movaps (%ecx), %xmm0
; CHECK_SSE32-NEXT:    movaps 16(%ecx), %xmm1
; CHECK_SSE32-NEXT:    movaps %xmm1, 16(%eax)
; CHECK_SSE32-NEXT:    movaps %xmm0, (%eax)
; CHECK_SSE32-NEXT:    retl
;
; CHECK_AVX32-LABEL: add4i64a16:
; CHECK_AVX32:       # %bb.0:
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %eax
; CHECK_AVX32-NEXT:    movl {{[0-9]+}}(%esp), %ecx
; CHECK_AVX32-NEXT:    vmovups (%ecx), %ymm0
; CHECK_AVX32-NEXT:    vmovups %ymm0, (%eax)
; CHECK_AVX32-NEXT:    vzeroupper
; CHECK_AVX32-NEXT:    retl
  %b = load <4 x i64>, <4 x i64>* %bp, align 16
  %x = add <4 x i64> zeroinitializer, %b
  store <4 x i64> %x, <4 x i64>* %ret, align 16
  ret void
}
