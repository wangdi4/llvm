; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=sse4.2,slow-unaligned-mem-16 | FileCheck %s -check-prefix=CHECK_SSE
; RUN: llc < %s -mtriple=x86_64-unknown-unknown -mattr=avx,slow-unaligned-mem-32  | FileCheck %s

define void @test_256_load(double* nocapture %d, float* nocapture %f, <4 x i64>* nocapture %i) nounwind {
; CHECK_SSE-LABEL: test_256_load:
; CHECK_SSE:       # %bb.0: # %entry
; CHECK_SSE-NEXT:    pushq %r15
; CHECK_SSE-NEXT:    pushq %r14
; CHECK_SSE-NEXT:    pushq %rbx
; CHECK_SSE-NEXT:    subq $96, %rsp
; CHECK_SSE-NEXT:    movq %rdx, %r14
; CHECK_SSE-NEXT:    movq %rsi, %r15
; CHECK_SSE-NEXT:    movq %rdi, %rbx
; CHECK_SSE-NEXT:    movaps (%rdx), %xmm4
; CHECK_SSE-NEXT:    movaps %xmm4, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps 16(%rdx), %xmm5
; CHECK_SSE-NEXT:    movaps %xmm5, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps (%rsi), %xmm2
; CHECK_SSE-NEXT:    movaps %xmm2, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps 16(%rsi), %xmm3
; CHECK_SSE-NEXT:    movaps %xmm3, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps (%rdi), %xmm0
; CHECK_SSE-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
; CHECK_SSE-NEXT:    movaps 16(%rdi), %xmm1
; CHECK_SSE-NEXT:    movaps %xmm1, (%rsp) # 16-byte Spill
; CHECK_SSE-NEXT:    callq dummy
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, (%rbx)
; CHECK_SSE-NEXT:    movaps (%rsp), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, 16(%rbx)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, (%r15)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, 16(%r15)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, (%r14)
; CHECK_SSE-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
; CHECK_SSE-NEXT:    movaps %xmm0, 16(%r14)
; CHECK_SSE-NEXT:    addq $96, %rsp
; CHECK_SSE-NEXT:    popq %rbx
; CHECK_SSE-NEXT:    popq %r14
; CHECK_SSE-NEXT:    popq %r15
; CHECK_SSE-NEXT:    retq
;
; CHECK-LABEL: test_256_load:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %r15
; CHECK-NEXT:    pushq %r14
; CHECK-NEXT:    pushq %rbx
; CHECK-NEXT:    subq $96, %rsp
; CHECK-NEXT:    movq %rdx, %r14
; CHECK-NEXT:    movq %rsi, %r15
; CHECK-NEXT:    movq %rdi, %rbx
; CHECK-NEXT:    vmovaps (%rdi), %ymm0
; CHECK-NEXT:    vmovups %ymm0, {{[-0-9]+}}(%r{{[sb]}}p) # 32-byte Spill
; CHECK-NEXT:    vmovaps (%rsi), %ymm1
; CHECK-NEXT:    vmovups %ymm1, {{[-0-9]+}}(%r{{[sb]}}p) # 32-byte Spill
; CHECK-NEXT:    vmovaps (%rdx), %ymm2
; CHECK-NEXT:    vmovups %ymm2, (%rsp) # 32-byte Spill
; CHECK-NEXT:    callq dummy
; CHECK-NEXT:    vmovups {{[-0-9]+}}(%r{{[sb]}}p), %ymm0 # 32-byte Reload
; CHECK-NEXT:    vmovaps %ymm0, (%rbx)
; CHECK-NEXT:    vmovups {{[-0-9]+}}(%r{{[sb]}}p), %ymm0 # 32-byte Reload
; CHECK-NEXT:    vmovaps %ymm0, (%r15)
; CHECK-NEXT:    vmovups (%rsp), %ymm0 # 32-byte Reload
; CHECK-NEXT:    vmovaps %ymm0, (%r14)
; CHECK-NEXT:    addq $96, %rsp
; CHECK-NEXT:    popq %rbx
; CHECK-NEXT:    popq %r14
; CHECK-NEXT:    popq %r15
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
entry:
  %0 = bitcast double* %d to <4 x double>*
  %tmp1.i = load <4 x double>, <4 x double>* %0, align 32
  %1 = bitcast float* %f to <8 x float>*
  %tmp1.i17 = load <8 x float>, <8 x float>* %1, align 32
  %tmp1.i16 = load <4 x i64>, <4 x i64>* %i, align 32
  tail call void @dummy(<4 x double> %tmp1.i, <8 x float> %tmp1.i17, <4 x i64> %tmp1.i16) nounwind
  store <4 x double> %tmp1.i, <4 x double>* %0, align 32
  store <8 x float> %tmp1.i17, <8 x float>* %1, align 32
  store <4 x i64> %tmp1.i16, <4 x i64>* %i, align 32
  ret void
}

declare void @dummy(<4 x double>, <8 x float>, <4 x i64>)

define void @storev16i16(<16 x i16> %a) nounwind {
; CHECK_SSE-LABEL: storev16i16:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, (%rax)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rax)
;
; CHECK-LABEL: storev16i16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmovaps %ymm0, (%rax)
  store <16 x i16> %a, <16 x i16>* undef, align 32
  unreachable
}

define void @storev16i16_01(<16 x i16> %a) nounwind {
; CHECK_SSE-LABEL: storev16i16_01:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movups %xmm1, (%rax)
; CHECK_SSE-NEXT:    movups %xmm0, (%rax)
;
; CHECK-LABEL: storev16i16_01:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vextractf128 $1, %ymm0, (%rax)
; CHECK-NEXT:    vmovups %xmm0, (%rax)
  store <16 x i16> %a, <16 x i16>* undef, align 4
  unreachable
}

define void @storev32i8(<32 x i8> %a) nounwind {
; CHECK_SSE-LABEL: storev32i8:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, (%rax)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rax)
;
; CHECK-LABEL: storev32i8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmovaps %ymm0, (%rax)
  store <32 x i8> %a, <32 x i8>* undef, align 32
  unreachable
}

define void @storev32i8_01(<32 x i8> %a) nounwind {
; CHECK_SSE-LABEL: storev32i8_01:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movups %xmm1, (%rax)
; CHECK_SSE-NEXT:    movups %xmm0, (%rax)
;
; CHECK-LABEL: storev32i8_01:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vextractf128 $1, %ymm0, (%rax)
; CHECK-NEXT:    vmovups %xmm0, (%rax)
  store <32 x i8> %a, <32 x i8>* undef, align 4
  unreachable
}

; It is faster to make two saves, if the data is already in xmm registers. For
; example, after making an integer operation.
define void @double_save(<4 x i32> %A, <4 x i32> %B, <8 x i32>* %P) nounwind ssp {
; CHECK_SSE-LABEL: double_save:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK-LABEL: double_save:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmovaps %xmm1, 16(%rdi)
; CHECK-NEXT:    vmovaps %xmm0, (%rdi)
; CHECK-NEXT:    retq
  %Z = shufflevector <4 x i32>%A, <4 x i32>%B, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i32> %Z, <8 x i32>* %P, align 16
  ret void
}

define void @double_save_volatile(<4 x i32> %A, <4 x i32> %B, <8 x i32>* %P) nounwind {
; CHECK_SSE-LABEL: double_save_volatile:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK-LABEL: double_save_volatile:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $xmm0 killed $xmm0 def $ymm0
; CHECK-NEXT:    vinsertf128 $1, %xmm1, %ymm0, %ymm0
; CHECK-NEXT:    vmovups %ymm0, (%rdi)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %Z = shufflevector <4 x i32>%A, <4 x i32>%B, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store volatile <8 x i32> %Z, <8 x i32>* %P, align 16
  ret void
}

define void @add8i32(<8 x i32>* %ret, <8 x i32>* %bp) nounwind {
; CHECK_SSE-LABEL: add8i32:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movups (%rsi), %xmm0
; CHECK_SSE-NEXT:    movups 16(%rsi), %xmm1
; CHECK_SSE-NEXT:    movups %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movups %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK-LABEL: add8i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmovups (%rsi), %xmm0
; CHECK-NEXT:    vmovups 16(%rsi), %xmm1
; CHECK-NEXT:    vmovups %xmm1, 16(%rdi)
; CHECK-NEXT:    vmovups %xmm0, (%rdi)
; CHECK-NEXT:    retq
  %b = load <8 x i32>, <8 x i32>* %bp, align 1
  %x = add <8 x i32> zeroinitializer, %b
  store <8 x i32> %x, <8 x i32>* %ret, align 1
  ret void
}

define void @add4i64a64(<4 x i64>* %ret, <4 x i64>* %bp) nounwind {
; CHECK_SSE-LABEL: add4i64a64:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps (%rsi), %xmm0
; CHECK_SSE-NEXT:    movaps 16(%rsi), %xmm1
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK-LABEL: add4i64a64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmovaps (%rsi), %ymm0
; CHECK-NEXT:    vmovaps %ymm0, (%rdi)
; CHECK-NEXT:    vzeroupper
; CHECK-NEXT:    retq
  %b = load <4 x i64>, <4 x i64>* %bp, align 64
  %x = add <4 x i64> zeroinitializer, %b
  store <4 x i64> %x, <4 x i64>* %ret, align 64
  ret void
}

define void @add4i64a16(<4 x i64>* %ret, <4 x i64>* %bp) nounwind {
; CHECK_SSE-LABEL: add4i64a16:
; CHECK_SSE:       # %bb.0:
; CHECK_SSE-NEXT:    movaps (%rsi), %xmm0
; CHECK_SSE-NEXT:    movaps 16(%rsi), %xmm1
; CHECK_SSE-NEXT:    movaps %xmm1, 16(%rdi)
; CHECK_SSE-NEXT:    movaps %xmm0, (%rdi)
; CHECK_SSE-NEXT:    retq
;
; CHECK-LABEL: add4i64a16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    vmovaps (%rsi), %xmm0
; CHECK-NEXT:    vmovaps 16(%rsi), %xmm1
; CHECK-NEXT:    vmovaps %xmm1, 16(%rdi)
; CHECK-NEXT:    vmovaps %xmm0, (%rdi)
; CHECK-NEXT:    retq
  %b = load <4 x i64>, <4 x i64>* %bp, align 16
  %x = add <4 x i64> zeroinitializer, %b
  store <4 x i64> %x, <4 x i64>* %ret, align 16
  ret void
}
