; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=x86_64-pc-linux -mcpu=sapphirerapids -verify-machineinstrs -disable-block-placement -disable-peephole < %s | FileCheck -allow-deprecated-dag-overlap %s

@blocker = dso_local local_unnamed_addr global i32* null, align 8
@t0 = dso_local local_unnamed_addr global i32 0, align 4

; Function Attrs: mustprogress nofree norecurse nosync nounwind uwtable willreturn
define dso_local i32 @test_1(i32* nocapture noundef %a, i64 noundef %len, i32 %n) local_unnamed_addr {
; CHECK-LABEL: test_1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andl $61440, %esi # imm = 0xF000
; CHECK-NEXT:    leaq (%rdi,%rsi,4), %rax
; CHECK-NEXT:    addl %edx, (%rax)
; CHECK-NEXT:    movq blocker(%rip), %rcx
; CHECK-NEXT:    addl %edx, (%rcx)
; CHECK-NEXT:    movl (%rax), %ecx
; CHECK-NEXT:    addl %edx, %ecx
; CHECK-NEXT:    movl %ecx, (%rax)
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    retq
entry:
  %conv = and i64 %len, 61440
  %arrayidx = getelementptr inbounds i32, i32* %a, i64 %conv
  %0 = load i32, i32* %arrayidx, align 4
  %inc = add nsw i32 %0, %n
  store i32 %inc, i32* %arrayidx, align 4
  %1 = load i32*, i32** @blocker, align 8
  %2 = load i32, i32* %1, align 4
  %inc1 = add nsw i32 %2, %n
  store i32 %inc1, i32* %1, align 4
  %3 = load i32, i32* %arrayidx, align 4
  %inc4 = add nsw i32 %3, %n
  store i32 %inc4, i32* %arrayidx, align 4
  ret i32 1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind uwtable willreturn
define dso_local i32 @test_2() local_unnamed_addr {
; CHECK-LABEL: test_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    leaq t0(%rip), %rax
; CHECK-NEXT:    incl (%rax)
; CHECK-NEXT:    movq blocker(%rip), %rax
; CHECK-NEXT:    incl (%rax)
; CHECK-NEXT:    leaq t0(%rip), %rax
; CHECK-NEXT:    incl (%rax)
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    retq
entry:
  %0 = load i32, i32* @t0, align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, i32* @t0, align 4
  %1 = load i32*, i32** @blocker, align 8
  %2 = load i32, i32* %1, align 4
  %inc1 = add nsw i32 %2, 1
  store i32 %inc1, i32* %1, align 4
  %3 = load i32, i32* @t0, align 4
  %inc2 = add nsw i32 %3, 1
  store i32 %inc2, i32* @t0, align 4
  ret i32 1
}

define dso_local void @test_3(i32 *%arr, i32 *%arr2, i32 %a, i32 %b, i32 %c, i32 %n) {
; CHECK-LABEL: test_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    jne .LBB2_5
; CHECK-NEXT:  # %bb.1: # %while.body.preheader
; CHECK-NEXT:    movl %edx, %ecx
; CHECK-NEXT:    xorl %esi, %esi
; CHECK-NEXT:  .LBB2_2: # %while.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    movslq %esi, %r8
; CHECK-NEXT:    leaq (%rdi,%r8,4), %rax
; CHECK-NEXT:    movl (%rax), %eax
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %ecx
; CHECK-NEXT:    movl %eax, %edx
; CHECK-NEXT:    movl $11, %eax
; CHECK-NEXT:    movl %ecx, %r10d
; CHECK-NEXT:    subl %ecx, %edx
; CHECK-NEXT:    ja .LBB2_4
; CHECK-NEXT:  # %bb.3: # %while.body
; CHECK-NEXT:    # in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    movl $22, %eax
; CHECK-NEXT:    movl $22, %r10d
; CHECK-NEXT:  .LBB2_4: # %while.body
; CHECK-NEXT:    # in Loop: Header=BB2_2 Depth=1
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    divl %r10d
; CHECK-NEXT:    leaq (%rdi,%r8,4), %rax
; CHECK-NEXT:    movl %edx, (%rax)
; CHECK-NEXT:    incl %esi
; CHECK-NEXT:    movl %esi, %eax
; CHECK-NEXT:    subl %r9d, %eax
; CHECK-NEXT:    ja .LBB2_2
; CHECK-NEXT:  .LBB2_5: # %while.end
; CHECK-NEXT:    retq
entry:
  %cmp10 = icmp ugt i32 0, %n
  br i1 %cmp10, label %while.body, label %while.end

while.body:                                       ; preds = %entry, %while.body
  %i = phi i32 [ %i_inc, %while.body ], [ 0, %entry ]
  %arr_i = getelementptr inbounds i32, i32* %arr, i32 %i
  %x = load i32, i32* %arr_i, align 4
  %div = udiv i32 %x, %a
  %cond = icmp ugt i32 %div, %a
  %condOpp = icmp ule i32 %div, %a
  %s1 = select i1 %cond, i32 11, i32 22
  %s2 = select i1 %condOpp, i32 %s1, i32 %a
  %sum = urem i32 %s1, %s2
  store i32 %sum, i32* %arr_i, align 4
  %i_inc = add i32 %i, 1
  %cmp = icmp ugt i32 %i_inc, %n
  br i1 %cmp, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind uwtable willreturn
define dso_local i32 @test_4(i32* nocapture noundef %a, i64 noundef %len, i32 %n) local_unnamed_addr {
; CHECK-LABEL: test_4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andl $61440, %esi # imm = 0xF000
; CHECK-NEXT:    leaq (%rdi,%rsi,4), %rax
; CHECK-NEXT:    addl %edx, (%rax)
; CHECK-NEXT:    movq blocker(%rip), %rcx
; CHECK-NEXT:    addl %edx, (%rcx)
; CHECK-NEXT:    movl (%rax), %eax
; CHECK-NEXT:    cmpl $0, %eax
; CHECK-NEXT:    je .LBB3_2
; CHECK-NEXT:  # %bb.1: # %end.0
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB3_2: # %end.1
; CHECK-NEXT:    movl $1, %eax
; CHECK-NEXT:    retq
entry:
  %conv = and i64 %len, 61440
  %arrayidx = getelementptr inbounds i32, i32* %a, i64 %conv
  %0 = load i32, i32* %arrayidx, align 4
  %inc = add nsw i32 %0, %n
  store i32 %inc, i32* %arrayidx, align 4
  %1 = load i32*, i32** @blocker, align 8
  %2 = load i32, i32* %1, align 4
  %inc1 = add nsw i32 %2, %n
  store i32 %inc1, i32* %1, align 4
  %3 = load i32, i32* %arrayidx, align 4
  %res = icmp eq i32 %3, 0
  br i1 %res, label %end.1, label %end.0
end.0:
  ret i32 0
end.1:
  ret i32 1
}

define dso_local void @test_5(i32 %n, i32 %num) {
; CHECK-LABEL: test_5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    movb $1, %al
; CHECK-NEXT:    testb %al, %al
; CHECK-NEXT:    jne .LBB4_3
; CHECK-NEXT:  # %bb.1: # %while.body.preheader
; CHECK-NEXT:    xorl %eax, %eax
; CHECK-NEXT:  .LBB4_2: # %while.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    leaq t0(%rip), %rcx
; CHECK-NEXT:    movl (%rcx), %edx
; CHECK-NEXT:    addl %esi, %edx
; CHECK-NEXT:    movl %edx, (%rcx)
; CHECK-NEXT:    addl %esi, %eax
; CHECK-NEXT:    movl %eax, %ecx
; CHECK-NEXT:    subl %edi, %ecx
; CHECK-NEXT:    ja .LBB4_2
; CHECK-NEXT:  .LBB4_3: # %while.end
; CHECK-NEXT:    retq
entry:
  %cmp10 = icmp ugt i32 0, %n
  br i1 %cmp10, label %while.body, label %while.end

while.body:                                       ; preds = %entry, %while.body
  %i = phi i32 [ %i_inc, %while.body ], [ 0, %entry ]
  %ld = load i32, i32* @t0, align 4
  %inc2 = add nsw i32 %ld, %num
  store i32 %inc2, i32* @t0, align 4
  %i_inc = add i32 %i, %num
  %cmp = icmp ugt i32 %i_inc, %n
  br i1 %cmp, label %while.body, label %while.end

while.end:                                        ; preds = %while.body, %entry
  ret void
}

