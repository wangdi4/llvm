; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes='lower-subscript' -S < %s | FileCheck %s
; RUN: opt -mtriple=x86_64-pc-linux-gnu -pre-isel-intrinsic-lowering -S < %s | FileCheck %s

define void @foo_exact(ptr noalias nocapture %"foo_$A", i64 %s) {
; CHECK-LABEL: @foo_exact(
; Compute offset in bytes, "0 + stride*index".
; CHECK:         [[TMP0:%.*]] = mul nsw i64 [[S:%.*]], %"var$2.07"
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr %"foo_$A", i64 [[TMP0]]
; CHECK-NEXT:    store i32 2, ptr [[TMP2]], align 1
;
alloca_0:
  br label %bb12

bb12:                                             ; preds = %alloca_0, %bb12
  %"var$2.07" = phi i64 [ 1, %alloca_0 ], [ %add, %bb12 ]
  %"foo_$A_entry[]" = tail call ptr @llvm.intel.subscript.p0.i64.i64.p0.i64(i8 0, i64 0, i64 %s, ptr elementtype(i32) %"foo_$A", i64 %"var$2.07")
  store i32 2, ptr %"foo_$A_entry[]", align 1
  %add = add nuw nsw i64 %"var$2.07", 1
  %exitcond = icmp eq i64 %add, 11
  br i1 %exitcond, label %bb13, label %bb12

bb13:                                             ; preds = %bb12
  ret void
}

define void @bar_nonexact(ptr noalias nocapture %"foo_$A", i64 %s) {
; CHECK-LABEL: @bar_nonexact(
; CHECK:         [[TMP0:%.*]] = mul nsw i64 [[S:%.*]], %"var$2.07"
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr %"foo_$A", i64 [[TMP0]]
; CHECK-NEXT:    store i32 2, ptr [[TMP2]], align 1
;
alloca_0:
  br label %bb12

  bb12:                                             ; preds = %alloca_0, %bb12
  %"var$2.07" = phi i64 [ 1, %alloca_0 ], [ %add, %bb12 ]
  %"foo_$A_entry[]" = tail call ptr @llvm.intel.subscript.nonexact.p0.i64.i64.p0.i64(i8 0, i64 0, i64 %s, ptr elementtype(i32) %"foo_$A", i64 %"var$2.07")
  store i32 2, ptr %"foo_$A_entry[]", align 1
  %add = add nuw nsw i64 %"var$2.07", 1
  %exitcond = icmp eq i64 %add, 11
  br i1 %exitcond, label %bb13, label %bb12

  bb13:                                             ; preds = %bb12
  ret void
}

declare ptr @llvm.intel.subscript.p0.i64.i64.p0.i64(i8, i64, i64, ptr, i64)
declare ptr @llvm.intel.subscript.nonexact.p0.i64.i64.p0.i64(i8, i64, i64, ptr, i64)

