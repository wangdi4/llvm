# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -o - %s -march=x86-64 -mcpu=skylake -run-pass=mir-debugify,x86-generate-lea-opt,mir-check-debugify 2>&1 | FileCheck %s --check-prefixes=SKL
# RUN: llc -o - %s -march=x86-64 -mcpu=icelake-client -run-pass=mir-debugify,x86-generate-lea-opt,mir-check-debugify 2>&1 | FileCheck %s --check-prefixes=ICL
# RUN: llc -o - %s -march=x86-64 -mcpu=icelake-server -run-pass=mir-debugify,x86-generate-lea-opt,mir-check-debugify 2>&1 | FileCheck %s --check-prefixes=ICX
# RUN: llc -o - %s -march=x86-64 -mcpu=alderlake -run-pass=mir-debugify,x86-generate-lea-opt,mir-check-debugify 2>&1 | FileCheck %s --check-prefixes=ADL
# RUN: llc -o - %s -march=x86-64 -mcpu=sapphirerapids -run-pass=mir-debugify,x86-generate-lea-opt,mir-check-debugify 2>&1 | FileCheck %s --check-prefixes=SPR
--- |
  target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-unknown-linux-gnu"

  @block_ = internal global [9 x [9 x [9 x i32]]] zeroinitializer, align 8

  ; Function Attrs: nounwind
  define internal fastcc void @lea_opt(i64 %in) unnamed_addr #0 {
    %base_addr = getelementptr i8, i8* bitcast ([9 x [9 x [9 x i32]]]* @block_ to i8*), i64 %in
    %addr_0 = getelementptr i8, i8* %base_addr, i64 2412
    %val_0 = bitcast i8* %addr_0 to i32*
    store i32 10, i32* %val_0, align 4
    %addr_1 = getelementptr i8, i8* %base_addr, i64 12
    %val_1 = bitcast i8* %addr_1 to i32*
    store i32 10, i32* %val_1, align 4
    %addr_2 = getelementptr i8, i8* %base_addr, i64 2062
    %val_2 = bitcast i8* %addr_2 to i32*
    store i32 10, i32* %val_2, align 4
    ret void
  }

  attributes #0 = { nounwind "contains-rec-pro-clone" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="true" }

...
---
name:            lea_opt
alignment:       4
tracksRegLiveness: true
registers:
  - { id: 0, class: gr64 }
liveins:
  - { reg: '$rdi', virtual-reg: '%0' }
machineFunctionInfo: {}
body:             |
  bb.0 (%ir-block.0):
    liveins: $rdi
    ; SKL-LABEL: name: lea_opt
    ; SKL: liveins: $rdi
    ; SKL: [[COPY:%[0-9]+]]:gr64 = COPY $rdi, debug-location !19
    ; SKL: DBG_VALUE [[COPY]], $noreg, !11, !DIExpression(), debug-location !19
    ; SKL: [[LEA64r:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2412, $noreg, debug-location !20
    ; SKL: MOV32mi [[LEA64r]], 1, $noreg, 0, $noreg, 10, debug-location !20 :: (store (s32) into %ir.val_0)
    ; SKL: DBG_VALUE 0, $noreg, !13, !DIExpression(), debug-location !20
    ; SKL: [[LEA64r1:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 12, $noreg, debug-location !21
    ; SKL: MOV32mi [[LEA64r1]], 1, $noreg, 0, $noreg, 10, debug-location !21 :: (store (s32) into %ir.val_1)
    ; SKL: DBG_VALUE 1, $noreg, !14, !DIExpression(), debug-location !21
    ; SKL: [[LEA64r2:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2062, $noreg, debug-location !22
    ; SKL: MOV32mi [[LEA64r2]], 1, $noreg, 0, $noreg, 10, debug-location !22 :: (store (s32) into %ir.val_2)
    ; SKL: DBG_VALUE 2, $noreg, !11, !DIExpression(), debug-location !22
    ; SKL: RET 0, debug-location !23
    ; ICL-LABEL: name: lea_opt
    ; ICL: liveins: $rdi
    ; ICL: [[COPY:%[0-9]+]]:gr64 = COPY $rdi, debug-location !19
    ; ICL: DBG_VALUE [[COPY]], $noreg, !11, !DIExpression(), debug-location !19
    ; ICL: [[LEA64r:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2412, $noreg, debug-location !20
    ; ICL: MOV32mi [[LEA64r]], 1, $noreg, 0, $noreg, 10, debug-location !20 :: (store (s32) into %ir.val_0)
    ; ICL: DBG_VALUE 0, $noreg, !13, !DIExpression(), debug-location !20
    ; ICL: [[LEA64r1:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 12, $noreg, debug-location !21
    ; ICL: MOV32mi [[LEA64r1]], 1, $noreg, 0, $noreg, 10, debug-location !21 :: (store (s32) into %ir.val_1)
    ; ICL: DBG_VALUE 1, $noreg, !14, !DIExpression(), debug-location !21
    ; ICL: [[LEA64r2:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2062, $noreg, debug-location !22
    ; ICL: MOV32mi [[LEA64r2]], 1, $noreg, 0, $noreg, 10, debug-location !22 :: (store (s32) into %ir.val_2)
    ; ICL: DBG_VALUE 2, $noreg, !11, !DIExpression(), debug-location !22
    ; ICL: RET 0, debug-location !23
    ; ICX-LABEL: name: lea_opt
    ; ICX: liveins: $rdi
    ; ICX: [[COPY:%[0-9]+]]:gr64 = COPY $rdi, debug-location !19
    ; ICX: DBG_VALUE [[COPY]], $noreg, !11, !DIExpression(), debug-location !19
    ; ICX: [[LEA64r:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2412, $noreg, debug-location !20
    ; ICX: MOV32mi [[LEA64r]], 1, $noreg, 0, $noreg, 10, debug-location !20 :: (store (s32) into %ir.val_0)
    ; ICX: DBG_VALUE 0, $noreg, !13, !DIExpression(), debug-location !20
    ; ICX: [[LEA64r1:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 12, $noreg, debug-location !21
    ; ICX: MOV32mi [[LEA64r1]], 1, $noreg, 0, $noreg, 10, debug-location !21 :: (store (s32) into %ir.val_1)
    ; ICX: DBG_VALUE 1, $noreg, !14, !DIExpression(), debug-location !21
    ; ICX: [[LEA64r2:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2062, $noreg, debug-location !22
    ; ICX: MOV32mi [[LEA64r2]], 1, $noreg, 0, $noreg, 10, debug-location !22 :: (store (s32) into %ir.val_2)
    ; ICX: DBG_VALUE 2, $noreg, !11, !DIExpression(), debug-location !22
    ; ICX: RET 0, debug-location !23
    ; ADL-LABEL: name: lea_opt
    ; ADL: liveins: $rdi
    ; ADL: [[COPY:%[0-9]+]]:gr64 = COPY $rdi, debug-location !19
    ; ADL: DBG_VALUE [[COPY]], $noreg, !11, !DIExpression(), debug-location !19
    ; ADL: [[LEA64r:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2412, $noreg, debug-location !20
    ; ADL: MOV32mi [[LEA64r]], 1, $noreg, 0, $noreg, 10, debug-location !20 :: (store (s32) into %ir.val_0)
    ; ADL: DBG_VALUE 0, $noreg, !13, !DIExpression(), debug-location !20
    ; ADL: [[LEA64r1:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 12, $noreg, debug-location !21
    ; ADL: MOV32mi [[LEA64r1]], 1, $noreg, 0, $noreg, 10, debug-location !21 :: (store (s32) into %ir.val_1)
    ; ADL: DBG_VALUE 1, $noreg, !14, !DIExpression(), debug-location !21
    ; ADL: [[LEA64r2:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2062, $noreg, debug-location !22
    ; ADL: MOV32mi [[LEA64r2]], 1, $noreg, 0, $noreg, 10, debug-location !22 :: (store (s32) into %ir.val_2)
    ; ADL: DBG_VALUE 2, $noreg, !11, !DIExpression(), debug-location !22
    ; ADL: RET 0, debug-location !23
    ; SPR-LABEL: name: lea_opt
    ; SPR: liveins: $rdi
    ; SPR: [[COPY:%[0-9]+]]:gr64 = COPY $rdi, debug-location !19
    ; SPR: DBG_VALUE [[COPY]], $noreg, !11, !DIExpression(), debug-location !19
    ; SPR: [[LEA64r:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2412, $noreg, debug-location !20
    ; SPR: MOV32mi [[LEA64r]], 1, $noreg, 0, $noreg, 10, debug-location !20 :: (store (s32) into %ir.val_0)
    ; SPR: DBG_VALUE 0, $noreg, !13, !DIExpression(), debug-location !20
    ; SPR: [[LEA64r1:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 12, $noreg, debug-location !21
    ; SPR: MOV32mi [[LEA64r1]], 1, $noreg, 0, $noreg, 10, debug-location !21 :: (store (s32) into %ir.val_1)
    ; SPR: DBG_VALUE 1, $noreg, !14, !DIExpression(), debug-location !21
    ; SPR: [[LEA64r2:%[0-9]+]]:gr64 = LEA64r [[COPY]], 1, $noreg, @block_ + 2062, $noreg, debug-location !22
    ; SPR: MOV32mi [[LEA64r2]], 1, $noreg, 0, $noreg, 10, debug-location !22 :: (store (s32) into %ir.val_2)
    ; SPR: DBG_VALUE 2, $noreg, !11, !DIExpression(), debug-location !22
    ; SPR: RET 0, debug-location !23
    %0:gr64 = COPY $rdi
    MOV32mi %0, 1, $noreg, @block_ + 2412, $noreg, 10 :: (store 4 into %ir.val_0)
    MOV32mi %0, 1, $noreg, @block_ + 12, $noreg, 10 :: (store 4 into %ir.val_1)
    MOV32mi %0, 1, $noreg, @block_ + 2062, $noreg, 10 :: (store 4 into %ir.val_2)
    RET 0

...

