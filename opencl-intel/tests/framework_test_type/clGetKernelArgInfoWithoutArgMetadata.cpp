#include "CL/cl.h"
#include "cl_types.h"

#include <fstream>
#include <iterator>
#include <stdio.h>
#include <string>

#include "FrameworkTest.h"
#include "common_utils.h"

extern cl_device_type gDeviceType;

/**************************************************************************************************
* clGetKernelArgInfoWithoutArgMetadata
* -------------------
* (1) get device id (gDeviceType)
* (2) create context
* (3) load binary (bitcode: SPIRV Friendly IR, generated by non-spirv CPU AOT)
* (4) create program with binary
* (5) build program
* (6) query kernel arg info

The input bitcode must have "spir64_x86_64" triple.
This test is not supported on 32bit systems.
**************************************************************************************************/

// Disassembled sycl-kernel-without-arg-metadata.bc
// clang-format off

// target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
// target triple = "spir64_x86_64-unknown-unknown-sycldevice"

// %"class._ZTSN2cl4sycl5rangeILi1EEE.cl::sycl::range.1" = type { %"class._ZTSN2cl4sycl6detail5arrayILi1EEE.cl::sycl::detail::array.0" }
// %"class._ZTSN2cl4sycl6detail5arrayILi1EEE.cl::sycl::detail::array.0" = type { [1 x i64] }

// $_ZTS7kernelT = comdat any

// ; Function Attrs: norecurse
// define weak_odr dso_local spir_kernel void @_ZTS7kernelT(float addrspace(1)* %_arg_, %"class._ZTSN2cl4sycl5rangeILi1EEE.cl::sycl::range.1"* byval(%"class._ZTSN2cl4sycl5rangeILi1EEE.cl::sycl::range.1") align 8 %_arg_1) local_unnamed_addr #0 comdat {
// entry:
//   ret void
// }

// attributes #0 = { norecurse "denormal-fp-math"="preserve-sign,preserve-sign" "denormal-fp-math-f32"="ieee,ieee" "frame-pointer"="all" "min-legal-vector-width"="0" "no-infs-fp-math"="true" "no-nans-fp-math"="true" "no-signed-zeros-fp-math"="true" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "sycl-module-id"="a.cpp" "uniform-work-group-size"="true" "unsafe-fp-math"="true" }

// !opencl.spir.version = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
// !spirv.Source = !{!1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1}
// !opencl.used.extensions = !{!2, !2, !2, !2, !2, !2, !2, !2, !2, !2, !2, !2}
// !opencl.used.optional.core.features = !{!2, !2, !2, !3, !2, !3, !2, !2, !2, !3, !2, !3}
// !opencl.compiler.options = !{!2, !2, !2, !2, !2, !2, !2, !2, !2, !2, !2, !2}
// !llvm.ident = !{!4, !4, !4, !4, !4, !4, !4, !4, !4, !4, !4, !4}
// !llvm.module.flags = !{!5, !6}

// !0 = !{i32 1, i32 2}
// !1 = !{i32 4, i32 100000}
// !2 = !{}
// !3 = !{!"cl_doubles"}
// !4 = !{!"Intel(R) oneAPI DPC++/C++ Compiler 2021.4.0 (2021.x.0.YYYYMMDD)"}
// !5 = !{i32 1, !"wchar_size", i32 4}
// !6 = !{i32 7, !"frame-pointer", i32 2}

// clang-format on

bool clGetKernelArgInfoWithoutArgMetadataTest() {
  bool Result = true;

  printf("---------------------------------------\n");
  printf("clGetKernelArgInfoWithoutArgMetadata\n");
  printf("---------------------------------------\n");
  cl_device_id Device = NULL;
  cl_int BinaryStatus;
  cl_context Ctx;
  cl_platform_id Platform = 0;
  cl_program Program = 0;

  cl_int Ret = clGetPlatformIDs(1, &Platform, NULL);
  Result &= Check("clGetPlatformIDs", CL_SUCCESS, Ret);
  if (!Result)
    return Result;

  cl_context_properties Props[3] = {CL_CONTEXT_PLATFORM,
                                    (cl_context_properties)Platform, 0};
  Ret = clGetDeviceIDs(Platform, gDeviceType, 1, &Device, NULL);
  Result &= Check("clGetDeviceIDs", CL_SUCCESS, Ret);
  if (!Result)
    return Result;

  // create context
  Ctx = clCreateContext(Props, 1, &Device, NULL, NULL, &Ret);
  Result &= Check("clCreateContext", CL_SUCCESS, Ret);
  if (!Result)
    return Result;
  printf("context = %p\n", (void *)Ctx);

  // read bitcode
  std::ifstream BitcodeFile(get_exe_dir() +
                                "sycl-kernel-without-arg-metadata.bc",
                            std::fstream::binary);
  std::vector<char> Bitcode(std::istreambuf_iterator<char>(BitcodeFile), {});
  size_t FileSize = Bitcode.size();
  unsigned char *Binaries[] = {
      reinterpret_cast<unsigned char *>(Bitcode.data())};

  // create program with binary
  Program = clCreateProgramWithBinary(
      Ctx, 1, &Device, &FileSize, const_cast<const unsigned char **>(Binaries),
      &BinaryStatus, &Ret);
  Result &= Check("clCreateProgramWithBinary", CL_SUCCESS, Ret);
  if (!Result)
    return Result;

  // build program
  Ret = clBuildProgram(Program, 1, &Device, NULL, NULL, NULL);
  Result &= Check("clBuildProgram", CL_SUCCESS, Ret);
  if (!Result)
    return Result;

  // create kernel
  cl_kernel Kernel = clCreateKernel(Program, "_ZTS7kernelT", &Ret);
  Result &= Check("clCreateKernel", CL_SUCCESS, Ret);
  if (!Result)
    return Result;

  // query kernel arg info
  // kernel signature:
  // define weak_odr dso_local spir_kernel void @_ZTS7kernelT(float
  // addrspace(1)* %_arg_,
  // %"class._ZTSN2cl4sycl5rangeILi1EEE.cl::sycl::range.1"*
  // byval(%"class._ZTSN2cl4sycl5rangeILi1EEE.cl::sycl::range.1") align 8
  // %_arg_1)

  // Address qualifier
  cl_kernel_arg_address_qualifier AddressQ;
  Ret |= clGetKernelArgInfo(Kernel, 0, CL_KERNEL_ARG_ADDRESS_QUALIFIER,
                            sizeof(cl_kernel_arg_address_qualifier), &AddressQ,
                            nullptr);
  Result &= Check("Address qualifier of arg[0]", CL_KERNEL_ARG_ADDRESS_GLOBAL,
                  AddressQ);
  Ret |= clGetKernelArgInfo(Kernel, 1, CL_KERNEL_ARG_ADDRESS_QUALIFIER,
                            sizeof(cl_kernel_arg_address_qualifier), &AddressQ,
                            nullptr);
  Result &= Check("Address qualifier of arg[1]", CL_KERNEL_ARG_ADDRESS_PRIVATE,
                  AddressQ);

  // Access qualifier
  cl_kernel_arg_access_qualifier AccessQ;
  Ret |= clGetKernelArgInfo(Kernel, 0, CL_KERNEL_ARG_ACCESS_QUALIFIER,
                            sizeof(cl_kernel_arg_access_qualifier), &AccessQ,
                            nullptr);
  Result &=
      Check("Access qualifier of arg[0]", CL_KERNEL_ARG_ACCESS_NONE, AccessQ);
  Ret |= clGetKernelArgInfo(Kernel, 1, CL_KERNEL_ARG_ACCESS_QUALIFIER,
                            sizeof(cl_kernel_arg_access_qualifier), &AccessQ,
                            nullptr);
  Result &=
      Check("Access qualifier of arg[1]", CL_KERNEL_ARG_ACCESS_NONE, AccessQ);

  // Type qualifier
  cl_kernel_arg_type_qualifier TypeQ;
  Ret |=
      clGetKernelArgInfo(Kernel, 0, CL_KERNEL_ARG_TYPE_QUALIFIER,
                         sizeof(cl_kernel_arg_type_qualifier), &TypeQ, nullptr);
  Result &= Check("Type qualifier of arg[0]", CL_KERNEL_ARG_TYPE_NONE, TypeQ);
  Ret |=
      clGetKernelArgInfo(Kernel, 1, CL_KERNEL_ARG_TYPE_QUALIFIER,
                         sizeof(cl_kernel_arg_type_qualifier), &TypeQ, nullptr);
  Result &= Check("Type qualifier of arg[1]", CL_KERNEL_ARG_TYPE_NONE, TypeQ);

  // Type name
  char TypeName[255];
  Ret |= clGetKernelArgInfo(Kernel, 0, CL_KERNEL_ARG_TYPE_NAME,
                            sizeof(TypeName), TypeName, nullptr);
  Result &= CheckStr("Type name of arg[0]", "float addrspace(1)*", TypeName);
  memset(TypeName, 0, 255);
  Ret |= clGetKernelArgInfo(Kernel, 1, CL_KERNEL_ARG_TYPE_NAME,
                            sizeof(TypeName), TypeName, nullptr);
  Result &= CheckStr("Type name of arg[1]",
                     "%\"class._ZTSN2cl4sycl5rangeILi1EEE.cl::sycl::range.1\"*",
                     TypeName);

  clReleaseKernel(Kernel);
  clReleaseProgram(Program);
  clReleaseContext(Ctx);
  return Result;
}
