#include "CL/cl.h"
#include "cl_types.h"

#include <stdio.h>
#include <string>

#include "FrameworkTest.h"
#include "common_utils.h"

extern cl_device_type gDeviceType;

/**************************************************************************************************
* clBuildSpirvFriendlyIRProgramWithBinaryTest
* -------------------
* (1) get device id (gDeviceType)
* (2) create context
* (3) load binary (bitcode: SPIRV Friendly IR, generated by non-spirv CPU AOT)
* (4) create program with binary
* (5) build program

The input bitcode must have "spir64_x86_64" triple.
This test is not supported on 32bit systems (CL_INVALID_BINARY).
**************************************************************************************************/

bool clBuildSpirvFriendlyIRProgramWithBinaryTest() {
  if (gDeviceType != CL_DEVICE_TYPE_CPU)
    return true;

  bool bResult = true;

  printf("---------------------------------------\n");
  printf("clBuildSpirvFriendlyIRProgramWithBinaryTest\n");
  printf("---------------------------------------\n");
  cl_device_id device = NULL;
  cl_int binaryStatus;
  cl_context context;
  cl_platform_id platform = 0;
  cl_program program = 0;

  cl_int iRet = clGetPlatformIDs(1, &platform, NULL);
  bResult &= Check("clGetPlatformIDs", CL_SUCCESS, iRet);

  if (!bResult) {
    return bResult;
  }

  cl_context_properties prop[3] = {CL_CONTEXT_PLATFORM,
                                   (cl_context_properties)platform, 0};

  iRet = clGetDeviceIDs(platform, gDeviceType, 1, &device, NULL);
  bResult &= Check("clGetDeviceIDs", CL_SUCCESS, iRet);

  if (!bResult) {
    return bResult;
  }

  // create context
  context = clCreateContext(prop, 1, &device, NULL, NULL, &iRet);
  bResult &= Check("clCreateContext", CL_SUCCESS, iRet);

  if (!bResult) {
    return bResult;
  }
  printf("context = %p\n", (void *)context);

  // create binary container
  size_t uiContSize = 0;
  FILE *pIRfile = NULL;

  // compiled from a simple sycl program with
  // dpcpp -fsycl-targets=x86_64
  std::string filename = get_exe_dir() + "spirv-friendly-llvm-ir.bc";
  FOPEN(pIRfile, filename.c_str(), "rb");

  fpos_t fileSize;
  SET_FPOS_T(fileSize, 0);
  if (NULL == pIRfile) {
    printf("Failed open file.\n");
    return false;
  }
  fseek(pIRfile, 0, SEEK_END);
  fgetpos(pIRfile, &fileSize);
  uiContSize += (size_t)GET_FPOS_T(fileSize);
  fseek(pIRfile, 0, SEEK_SET);

  unsigned char *pCont = (unsigned char *)malloc(uiContSize);
  if (NULL == pCont) {
    return false;
  }
  // Construct program container
  size_t ret =
      fread(((unsigned char *)pCont), 1, (size_t)GET_FPOS_T(fileSize), pIRfile);
  if (ret != (size_t)GET_FPOS_T(fileSize)) {
    printf("Failed read file.\n");
    return false;
  }

  fclose(pIRfile);

  // create program with binary
  program = clCreateProgramWithBinary(
      context, 1, &device, &uiContSize,
      const_cast<const unsigned char **>(&pCont), &binaryStatus, &iRet);
#if defined(_WIN32) && !defined(_WIN64)
  bResult &= Check("clCreateProgramWithBinary", CL_INVALID_BINARY, iRet);
  return bResult;
#else
  bResult &= Check("clCreateProgramWithBinary", CL_SUCCESS, iRet);

  if (!bResult) {
    return bResult;
  }

  // build program
  iRet = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
  bResult &= Check("clBuildProgram", CL_SUCCESS, iRet);

  if (!bResult) {
    return bResult;
  }

  clReleaseProgram(program);
  clReleaseContext(context);
  return bResult;
#endif
}
