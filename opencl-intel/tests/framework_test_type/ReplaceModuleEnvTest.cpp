// Copyright (C) 2022 Intel Corporation
//
// This software and the related documents are Intel copyrighted materials, and
// your use of them is governed by the express license under which they were
// provided to you ("License"). Unless the License provides otherwise, you may
// not use, modify, copy, publish, distribute, disclose or transmit this
// software or the related documents without Intel's prior written permission.
//
// This software and the related documents are provided as is, with no express
// or implied warranties, other than those that are expressly stated in the
// License.

#include "FrameworkTestThreads.h"
#include "TestsHelpClasses.h"
#include "common_utils.h"

extern cl_device_type gDeviceType;

class ReplaceModuleEnvTest : public ::testing::Test {
protected:
  virtual void SetUp() override {
    cl_int err = clGetPlatformIDs(1, &m_platform, nullptr);
    ASSERT_OCL_SUCCESS(err, "clGetPlatformIDs");

    err = clGetDeviceIDs(m_platform, gDeviceType, 1, &m_device, nullptr);
    ASSERT_OCL_SUCCESS(err, "clGetDeviceIDs");

    m_context = clCreateContext(nullptr, 1, &m_device, nullptr, nullptr, &err);
    ASSERT_OCL_SUCCESS(err, "clCreateContext");

    m_queue =
        clCreateCommandQueueWithProperties(m_context, m_device, nullptr, &err);
    ASSERT_OCL_SUCCESS(err, "clCreateCommandQueueWithProperties");

    const char *source = R"(
      kernel void test(global int *dst) {
        dst[0] = 0;
      }
    )";
    for (int i = 0; i < 2; ++i) {
      m_programs[i] =
          clCreateProgramWithSource(m_context, 1, &source, nullptr, &err);
      ASSERT_OCL_SUCCESS(err, "clCreateProgramWithSource");
    }
  }

  virtual void TearDown() override {
    cl_int err;
    for (auto &k : m_kernels) {
      if (k) {
        err = clReleaseKernel(k);
        EXPECT_OCL_SUCCESS(err, "clReleaseKernel");
      }
    }
    for (auto &p : m_programs) {
      if (p) {
        err = clReleaseProgram(p);
        EXPECT_OCL_SUCCESS(err, "clReleaseProgram");
      }
    }
    if (m_queue) {
      err = clReleaseCommandQueue(m_queue);
      EXPECT_OCL_SUCCESS(err, "clReleaseCommandQueue");
    }
    if (m_context) {
      err = clReleaseContext(m_context);
      EXPECT_OCL_SUCCESS(err, "clReleaseContext");
    }
  }

protected:
  void runImpl();

  cl_platform_id m_platform;
  cl_device_id m_device;
  cl_context m_context = nullptr;
  cl_command_queue m_queue = nullptr;
  cl_program m_programs[2] = {nullptr};
  cl_kernel m_kernels[2] = {nullptr};
  cl_int m_results[2] = {0};
};

void ReplaceModuleEnvTest::runImpl() {
  for (int i = 0; i < 2; ++i) {
    cl_int err =
        clBuildProgram(m_programs[i], 1, &m_device, "", nullptr, nullptr);
    ASSERT_OCL_SUCCESS(err, "clBuildProgram");

    m_kernels[i] = clCreateKernel(m_programs[i], "test", &err);
    ASSERT_OCL_SUCCESS(err, "clCreateKernel blocking_test");

    /// Test clMemBlockingFreeINTEL when enqueue succeed.
    err = clSetKernelArgMemPointerINTEL(m_kernels[i], 0, &m_results[i]);
    ASSERT_OCL_SUCCESS(err, "clSetKernelArgMemPointerINTEL");
    size_t gdim = 1;
    size_t ldim = 1;
    err = clEnqueueNDRangeKernel(m_queue, m_kernels[i], 1, nullptr, &gdim,
                                 &ldim, 0, nullptr, nullptr);
    ASSERT_OCL_SUCCESS(err, "clEnqueueNDRangeKernel");

    err = clFinish(m_queue);
    ASSERT_OCL_SUCCESS(err, "clFinish");
  }
}

// This test checks that llvm module is replaced before optimizer.
// In case the test fails, please re-generate replace-module-before-optimizer.ll
// by running this test with env "CL_CONFIG_DUMP_IR_BEFORE_OPTIMIZER=True" and
// then modify the first dumped IR to store 1 to dst and the second dumped IR to
// store 2 to dst.
TEST_F(ReplaceModuleEnvTest, beforeOptimizer) {
  std::string irName = get_exe_dir() + "replace-module-before-optimizer-1.ll," +
                       get_exe_dir() + "replace-module-before-optimizer-2.ll";
  const char *envName = "CL_CONFIG_REPLACE_IR_BEFORE_OPTIMIZER";
  ASSERT_TRUE(SETENV(envName, irName.c_str()));
  ASSERT_NO_FATAL_FAILURE(runImpl());
  EXPECT_EQ(1, m_results[0]);
  EXPECT_EQ(2, m_results[1]);
  ASSERT_TRUE(UNSETENV(envName));
}

// Disable the test on windows since replace-module-after-optimizer.ll has
// triple x86_64-pc-linux.
#ifndef _WIN32

// This test checks that llvm module is replaced after optimizer.
// replace-module-after-optimizer.ll is generated by running this test with env
// "CL_CONFIG_DUMP_IR_AFTER_OPTIMIZER=True" and then modify the first dumped IR
// to store 3 to dst and the second dumped IR to store 4 to dst.
TEST_F(ReplaceModuleEnvTest, afterOptimizer) {
  std::string irName = get_exe_dir() + "replace-module-after-optimizer-1.ll," +
                       get_exe_dir() + "replace-module-after-optimizer-2.ll";
  const char *envName = "CL_CONFIG_REPLACE_IR_AFTER_OPTIMIZER";
  ASSERT_TRUE(SETENV(envName, irName.c_str()));
  ASSERT_NO_FATAL_FAILURE(runImpl());
  EXPECT_EQ(3, m_results[0]);
  EXPECT_EQ(4, m_results[1]);
  ASSERT_TRUE(UNSETENV(envName));
}

#endif // #ifndef _WIN32
