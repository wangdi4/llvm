// Copyright (C) 2022 Intel Corporation
//
// This software and the related documents are Intel copyrighted materials, and
// your use of them is governed by the express license under which they were
// provided to you ("License"). Unless the License provides otherwise, you may
// not use, modify, copy, publish, distribute, disclose or transmit this
// software or the related documents without Intel's prior written permission.
//
// This software and the related documents are provided as is, with no express
// or implied warranties, other than those that are expressly stated in the
// License.

#include "FrameworkTestThreads.h"
#include "TestsHelpClasses.h"
#include "common_utils.h"

extern cl_device_type gDeviceType;

class ReplaceModuleEnvTest : public ::testing::Test {
protected:
  virtual void SetUp() override {
    cl_int err = clGetPlatformIDs(1, &m_platform, nullptr);
    ASSERT_OCL_SUCCESS(err, "clGetPlatformIDs");

    err = clGetDeviceIDs(m_platform, gDeviceType, 1, &m_device, nullptr);
    ASSERT_OCL_SUCCESS(err, "clGetDeviceIDs");

    m_context = clCreateContext(nullptr, 1, &m_device, nullptr, nullptr, &err);
    ASSERT_OCL_SUCCESS(err, "clCreateContext");

    m_queue =
        clCreateCommandQueueWithProperties(m_context, m_device, nullptr, &err);
    ASSERT_OCL_SUCCESS(err, "clCreateCommandQueueWithProperties");

    const char *source = R"(
      kernel void test(global int *dst) {
        dst[0] = 0;
      }
    )";
    m_program = clCreateProgramWithSource(m_context, 1, &source, nullptr, &err);
    ASSERT_OCL_SUCCESS(err, "clCreateProgramWithSource");
  }

  virtual void TearDown() override {
    cl_int err;
    if (m_kernel) {
      err = clReleaseKernel(m_kernel);
      EXPECT_OCL_SUCCESS(err, "clReleaseKernel");
    }
    if (m_program) {
      err = clReleaseProgram(m_program);
      EXPECT_OCL_SUCCESS(err, "clReleaseProgram");
    }
    if (m_queue) {
      err = clReleaseCommandQueue(m_queue);
      EXPECT_OCL_SUCCESS(err, "clReleaseCommandQueue");
    }
    if (m_kernel) {
      err = clReleaseContext(m_context);
      EXPECT_OCL_SUCCESS(err, "clReleaseContext");
    }
  }

protected:
  void runImpl();

  cl_platform_id m_platform;
  cl_device_id m_device;
  cl_context m_context = nullptr;
  cl_command_queue m_queue = nullptr;
  cl_program m_program = nullptr;
  cl_kernel m_kernel = nullptr;
  cl_int m_result = 0;
};

void ReplaceModuleEnvTest::runImpl() {
  cl_int err = clBuildProgram(m_program, 1, &m_device, "", nullptr, nullptr);
  ASSERT_OCL_SUCCESS(err, "clBuildProgram");

  m_kernel = clCreateKernel(m_program, "test", &err);
  ASSERT_OCL_SUCCESS(err, "clCreateKernel blocking_test");

  /// Test clMemBlockingFreeINTEL when enqueue succeed.
  err = clSetKernelArgMemPointerINTEL(m_kernel, 0, &m_result);
  ASSERT_OCL_SUCCESS(err, "clSetKernelArgMemPointerINTEL");
  size_t gdim = 1;
  size_t ldim = 1;
  err = clEnqueueNDRangeKernel(m_queue, m_kernel, 1, nullptr, &gdim, &ldim, 0,
                               nullptr, nullptr);
  ASSERT_OCL_SUCCESS(err, "clEnqueueNDRangeKernel");

  err = clFinish(m_queue);
  ASSERT_OCL_SUCCESS(err, "clFinish");
}

// This test checks that llvm module is replaced before optimizer.
// In case the test fails, please re-generate replace-module-before-optimizer.ll
// by running this test with env "VOLCANO_EQUALIZER_STATS=All" and then modify
// dumped IR to store 1 to dst.
TEST_F(ReplaceModuleEnvTest, beforeOptimizer) {
  std::string irName = get_exe_dir() + "replace-module-before-optimizer.ll";
  const char *envName = "CL_CONFIG_REPLACE_IR_BEFORE_OPTIMIZER";
  ASSERT_TRUE(SETENV(envName, irName.c_str()));
  ASSERT_NO_FATAL_FAILURE(runImpl());
  EXPECT_EQ(1, m_result);
  ASSERT_TRUE(UNSETENV(envName));
}

// Disable the test on windows since replace-module-after-optimizer.ll has
// triple x86_64-pc-linux.
#ifndef _WIN32

// This test checks that llvm module is replaced after optimizer.
// replace-module-after-optimizer.ll is generated by running this test with env
// "VOLCANO_STATS=All" and then modify dumped IR to store 2 to dst.
TEST_F(ReplaceModuleEnvTest, afterOptimizer) {
  std::string irName = get_exe_dir() + "replace-module-after-optimizer.ll";
  const char *envName = "CL_CONFIG_REPLACE_IR_AFTER_OPTIMIZER";
  ASSERT_TRUE(SETENV(envName, irName.c_str()));
  ASSERT_NO_FATAL_FAILURE(runImpl());
  EXPECT_EQ(2, m_result);
  ASSERT_TRUE(UNSETENV(envName));
}

#endif // #ifndef _WIN32
