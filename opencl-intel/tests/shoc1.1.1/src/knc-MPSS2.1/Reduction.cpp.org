// ****************************************************************************
// File: Reduction.cpp
//
// Purpose:
//   Contains performance tests on a basic sum reduction
//
// Programmer:  Kyle Spafford
// Creation:    November 19, 2010
//
// ****************************************************************************

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cmath>
#include <vector>
#include <string>
#include "omp.h"

#include "offload.h"
#include "Timer.h"

#include "OptionParser.h"
#include "ResultDatabase.h"

#ifdef TARGET_ARCH_LRB
#include <lmmintrin.h>
#include <pthread.h>
#include <pthread_affinity_np.h>
#endif


using namespace std;

template <class T>
void RunTest(string testName, ResultDatabase &resultDB, OptionParser &op);

// ****************************************************************************
// Function: reduceGold
//
// Purpose:
//   Simple cpu reduce routine to verify device results
//
// Arguments:
//   data : the input data
//   size : size of the input data
//
// Returns:  sum of the data
//
// Programmer: Kyle Spafford
//
// Modifications:
//
// ****************************************************************************
template <class T>
T reduceGold(const T *data, int size)
{
    T sum = 0;
    for (int i = 0; i < size; i++)
    {
        sum += data[i];
    }
    return sum;
}


// CPU Tests 
// Vanilla OpenMP
float cpuOMP(float *data, size_t size)
{

	float ret = 0;
	#pragma omp parallel for reduction(+:ret)
	for(int i=0;i<size;i++) 
  {
		ret += data[i];
  }

	return ret;
}

// Single-thread CEAN - C++ Extended Array Notation
float cpuCEAN(float *data, size_t size)
{ 

	float ret = 0;
	ret = __sec_reduce_add(data[0:size]);
	return ret;

}

// OpenMP + CEAN
float cpuOMP_CEAN(float *data, size_t size)
{
  float ret=0;
  {
     int nThreads = omp_get_max_threads();
     int nPerThread = size / nThreads;
     #pragma omp parallel for reduction(+:ret)
      for(int i = 0; i < nThreads;i++){ 
         ret = __sec_reduce_add(data[i*nPerThread:nPerThread]);
      }
      //rest of the array
      for(int i = nThreads * nPerThread; i < size; i++)
      ret += data[i];
  }
   return ret;
}

// Kernel which allocs, transfers, and frees
float KNF_OMP(float *data, size_t size)
{
	float ret = 0;
	#pragma offload target(mic) in(data:length(size) )
	{
		#pragma omp parallel for reduction(+:ret)
		for(int i=0;i<size;i++) {       
       ret +=data[i];
    }
	}
	return ret;
}

// Device Kernel using CEAN
float KNF_OMP_CEAN(float *data, size_t size)
{
  float ret=0;
  #pragma offload target(mic) in(data:length(size))
  {
     int nThreads = omp_get_max_threads();
     int nPerThread = size / nThreads;
     #pragma omp parallel for reduction(+:ret)
      for(int i = 0; i < nThreads;i++){ 
         ret = __sec_reduce_add(data[i*nPerThread:nPerThread]);
      }
      //rest of the array
      for(int i = nThreads * nPerThread; i < size; i++)
      ret += data[i];
  }
   return ret;
}

double KNF_OMP_CEAN_NT(float *data, size_t size)
{
  double ret=0;
  
  // Ideally, I'd like to be able to put these copy directives
  // in a different function, but when I tried that (compiler 0.0.17)
  // earlier, I ran into major problems (scrolling pages of errors 
  // about buffer not being sent).

  #pragma offload target(mic) in(data:length(size) free_if(0))
  {}
  
  // Repeatedly execute the kernel to amortize PCIe
  // transfer time
  double start = curr_second();
  for (int j = 0; j < 100; j++) {
     ret = 0;
  #pragma offload target(mic) nocopy(data, ret)
  {
     int nThreads = omp_get_max_threads();
     int nPerThread = size / nThreads;
     #pragma omp parallel for reduction(+:ret)
      for(int i = 0; i < nThreads;i++){ 
         ret = __sec_reduce_add(data[i*nPerThread:nPerThread]);
      }
      //rest of the array
      for(int i = nThreads * nPerThread; i < size; i++)
      ret += data[i];
  }

  }
  double stop = curr_second();
  // Free data
  #pragma offload target(mic) in(data:length(size) alloc_if(0))
  {}
  
  //return ret;
  return stop - start;
}


bool check(float result, float ref) {
 
   float  diff = fabs(result - ref);
   float threshold = 1e-2;
   if (diff >= threshold * ref)            
   {
      cout << "Pass FAILED\n";
      cout << "Diff: " << diff;
      exit(-1); // (don't report erroneous results)
   }
   return true;
}

void addBenchmarkSpecOptions(OptionParser& op) {
   op.addOption("mb", OPT_INT, "0", "specify custom size in MB", 'm');
   return; // No specific options yet
}


void RunBenchmark(OptionParser& op, ResultDatabase& resultDB) {
    
     
    int probSizes[4] = { 4, 8, 32, 64 };
    int N = probSizes[op.getOptionInt("size")-1];
    int customN = op.getOptionInt("mb");
    if (customN) N = customN;
    N = (N * 1024 * 1024) / sizeof(float);
    double gbytes = (double)(N*sizeof(float))/(1000.*1000.*1000.);

    float* data = new float[N];

    // Initialize host memory
    cout << "Initializing memory." << endl;
    
    for(int i = 0; i < N; i++)
    {
        data[i] = i % 5; // Fill with some pattern
    }
  
    float ref = reduceGold(data, N);

    int passes = op.getOptionInt("passes");
    int iterations = 100;

    // Test attributes
    char atts[1024];
    sprintf(atts, "%d_items",N);

    for (int k = 0; k < passes; k++)
    {
        float result;
        double start, stop;
        double avgTime;
        cout << "Pass #" << k << "\n";

        cout << "Testing CPU with OpenMP" << endl;
        // Start the clock (current implementation uses gettimeofday())
        start = curr_second();
        for (int j=0; j<iterations; j++) {
           result = cpuOMP(data, N);
        }
        // Stop the clock
        stop = curr_second();
        // Uncomment to enable correctness checking.
        // With large problem sizes this check will always fail.
        // Need to add Kahan summation to checking routine
        //check(result, ref);
        avgTime = (stop - start) / (double)iterations;
        resultDB.AddResult("CPU-OMP", atts, "GB/s", gbytes / avgTime);

        cout << "Testing CPU with CEAN" << endl;
        start = curr_second();
        for (int j=0; j<iterations; j++) {
           result = cpuCEAN(data, N);
        }
        stop = curr_second();
        
        // Uncomment to enable correctness checking.
        // With large problem sizes this check will always fail.
        // Need to add Kahan summation to checking routine
        //check(result, ref);
        avgTime = (stop - start) / (double)iterations;
        resultDB.AddResult("CPU-CEAN", atts, "GB/s", gbytes / avgTime);

        cout << "Testing CPU with OpenMP+CEAN" << endl;
        start = curr_second();
        for (int j=0; j<iterations; j++) {
           result = cpuOMP_CEAN(data, N);
        }
        stop = curr_second();
               
        // Uncomment to enable correctness checking.
        // With large problem sizes this check will always fail.
        // Need to add Kahan summation to checking routine
        //check(result, ref);
        
        avgTime = (stop - start) / (double)iterations;
        resultDB.AddResult("CPU-OMP-CEAN", atts, "GB/s", gbytes / avgTime);
/*
        cout << "Testing KNF with OpenMP" << endl;
        start = curr_second();
        for (int j=0; j<iterations; j++) {
           result = KNF_OMP(data, N);
        }
        stop = curr_second();
        check(result, ref);
        avgTime = (stop - start) / (double)iterations;
        resultDB.AddResult("KNF-OMP", atts, "GB/s", gbytes / avgTime);

        cout << "Testing KNF with OpenMP & CEAN" << endl;
        start = curr_second();
        for (int j=0; j<iterations; j++) {
           result = KNF_OMP_CEAN(data, N);
        }
        stop = curr_second();
        check(result, ref);
        avgTime = (stop - start) / (double)iterations;
        resultDB.AddResult("KNF-OMP-CEAN", atts, "GB/s", gbytes / avgTime);
*/
        // The general structure changes a little for this test. Since the data
        // transfer pragmas seem to need to be in the same function
        // as the kernel, we do the timing in the kernel function
        // itself, and return the result.
        
        cout << "Testing KNF with OpenMP & CEAN -- No Copy" << endl;        
        result = KNF_OMP_CEAN_NT(data, N);
        resultDB.AddResult("KNF-OMP-CEAN-NT", atts, "GB/s", gbytes / (result / 100.));
    }

   delete[] data;
} 
