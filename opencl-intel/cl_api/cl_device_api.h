// Copyright (c) 2006-2008 Intel Corporation
// All rights reserved.
// 
// WARRANTY DISCLAIMER
// 
// THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
// MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Intel Corporation is the author of the Materials, and requests that all
// problem reports or change requests be submitted to it directly

/*
*
* File cl_device_API.h
* The interface between the device and the Open CL frame work.
*
*/
#ifndef __CL_DEVICE_API_H__
#define __CL_DEVICE_API_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "CL\cl.h"

// All device maximum working dimension
#define MAX_WORK_DIM		3

// Predefined structures types
typedef struct _cl_dev_entry_points		cl_dev_entry_points;
typedef struct _cl_dev_call_backs		cl_dev_call_backs;
typedef struct _cl_dev_log_descriptor	cl_dev_log_descriptor;

// ------------------------------------------------------------------------------
// Program container defintion.
// Data types and structures
// ------------------------------------------------------------------------------
// Defines possible values for IR/binary types supported by the program container
typedef enum cl_prog_binary_type
{
	CL_PROG_BIN_DASHER,				//	Containers holds Intel DASHER intermediate
	CL_PROG_BIN_LLVM,				//	Container holds Apple OCL LLVM intermediate
	CL_PROG_DLL_X86,				//	Container is a dynamically loaded library name
	CL_PROG_OBJ_X86,				//	Container holds x86 object code (.obj)
	CL_PROG_BIN_X86,				//	Container holds x86 binary code
	CL_PROG_BIN_PTX,				//	Container holds NVidia PTX intermediate
	CL_PROG_BIN_CUBIN,				//	Container holds NVidia CUBIN binary
};

// Defines possible values for containers types supported by the program container
typedef enum cl_prog_container_type
{
	CL_PROG_CNT_PRIVATE,			//	Containers is private container and it’s structure is unknown
	CL_PROG_CNT_PROGRAM,			//	Container holds OCL program container as defined by cl_prog_program
};


// Defines possible values for kernel argument types
typedef enum cl_kernel_arg_type
{
	CL_KRNL_ARG_INT		= 0,	// Argument is a signed integer.
	CL_KRNL_ARG_UINT,			// Argument is an unsigned integer.
	CL_KRNL_ARG_FLOAT,			// Argument is a float.
	CL_KRNL_ARG_DOUBLE,			// Argument is a double.
	CL_KRNL_ARG_VECTOR,			// Argument is a vector of basic types, like int8, float4, etc.
	CL_KRNL_ARG_SAMPLER,		// Argument is a sampler object
	CL_KRNL_ARG_PTR_LOCAL,		// Argument is a pointer to array declared in local memory
	//	Memory object types bellow this line
	CL_KRNL_ARG_PTR_GLOBAL,		// Argument is a pointer to array in global memory of various types
								// The array type could be char, short, int, float or double
								// User must pass a handle to a memory buffer for this argument type
	CL_KRNL_ARG_PTR_CONST,		// Argument is a pointer to buffer declared in constant(global) memory
	CL_KRNL_ARG_PTR_IMG_2D,		// Argument is a pointer to 2D image
	CL_KRNL_ARG_PTR_IMG_3D,		// Argument is a pointer to 3D image
};

// Defines possible values for kernel argument types
typedef struct _cl_kernel_argument
{
	cl_kernel_arg_type			type;			// Type of the argument.
	unsigned int				size_in_bytes;	// Size of the argument in bytes,
												// for pointer types the size is 0,
												// for vectors the high part indicates size of basic element in bytes
												//				the lower part indicates number of elements
} cl_kernel_argument;

// This structure defines a container description of binary
typedef struct _cl_prog_binary_desc
{
	cl_prog_binary_type	bin_type;		//	Binary/IR type that is held by a container
	cl_ushort			bin_ver_major;	//	Binary/IR major version identifier
	cl_ushort			bin_ver_minor;	//	Binary/IR minor version identifier
} cl_prog_binary_desc;

// This structure defines a single kernel container.
typedef struct _cl_prog_kernel
{
	const char*					name;			// A pointer to kernel name
	int							arg_count;		// A number of arguments to the kernel
	const cl_kernel_argument*	args;			// An array of kernel argument
	size_t						metadata_size;	// Size in bytes of the metadata generated by the back-end compiler.
	const void*					metadata;		// A pointer to buffer that holds metadata generated by the back-end compiler
	size_t						imp_local_size;	// Size in bytes of the implicitly defined local memory buffers
	size_t						bin_size;		// Size in bytes of kernel binary/IR representation
												// If 0, bin points to code segment
	const void*					bin;			// A pointer to kernel binary representation
} cl_prog_kernel;

// This structure defines a specific container for binaries or IR of OCL programs
typedef struct _cl_prog_program
{
	cl_uint			kernel_count;			// Number of kernels in a program
	cl_prog_kernel*	kernels;				// A pointer to list of cl_prog_kernel
} cl_prog_program;

// This structure defines a container that holds binaries or IR of OCL compiled programs
#define _CL_CONTAINER_MASK_		"CLPC"

typedef struct _cl_prog_container
{
	cl_char					mask[4];		// A container identifier mask must be "CLPC"
	cl_prog_binary_desc		description;	// Binary/IR description that is held by a container
	cl_prog_container_type	container_type;	// Type of container that stores program binary, as defined by cl_prog_container_type
	size_t					container_size; // Size in bytes of the container data
	const void*				container;		// Pointer to the container data
} cl_prog_container;

// ------------------------------------------------------------------------------
// Device API data types defenition
// ------------------------------------------------------------------------------

// Command list handle defenition
typedef void*	cl_dev_cmd_list;
typedef void*	cl_dev_cmd_id;
// Program handle definition
typedef void* cl_dev_program;
// Kernel handle definition
typedef void* cl_dev_kernel;

//Defines device return values that are used by the OCL framework.
typedef enum cl_dev_err_code
{
	CL_DEV_SUCCESS				= 0,			// Function call or query call succeeded
	CL_DEV_ERROR_FAIL			= 0x80000000,	// Internal unspecified error
	CL_DEV_INVALID_VALUE,						// Invalid value was passed to the function.
	CL_DEV_INVALID_PROPERTIES,					// Properties might be valid but not supported
	CL_DEV_OUT_OF_MEMORY,						// Resource allocation failure
	CL_DEV_INVALID_COMMAND_LIST,				// Invalid command list handle
	CL_DEV_INVALID_COMMAND_TYPE,				// Invalid command type
	CL_DEV_INVALID_COMMAND_PARAM,				// Invalid command parameter
	CL_DEV_INVALID_MEM_OBJECT,					// Invalid memory object
	CL_DEV_INVALID_KERNEL,						// Invalid kernel identifier
	CL_DEV_INVALID_OPERATION,					// Device cannot perform requested operation
	CL_DEV_INVALID_WRK_DIM,						// Invalid work dimension (i.e. a value between 1 and 3)
	CL_DEV_INVALID_WG_SIZE,						// Invalid work-group size
	CL_DEV_INVALID_GLB_OFFSET,					// Invalid global offset, only (0, 0, 0) is supported
	CL_DEV_INVALID_WRK_ITEM_SIZE,				// Invalid work-item size
	CL_DEV_INVALID_IMG_FORMAT,					// Invalid image format
	CL_DEV_INVALID_IMG_SIZE,					// Width or height of the image are 0 or exceed maximum possible values
	CL_DEV_OBJECT_ALLOC_FAIL,					// Failed to allocate resources for memory object
	CL_DEV_INVALID_BINARY,						// The binary is not supported by the device or program container content is invalid
	CL_DEV_INVALID_BUILD_OPTIONS,				// One of more build options specified for the back-end compiler are invalid
	CL_DEV_INVALID_PROGRAM,						// Invalid program object handle 
	CL_DEV_BUILD_IN_PROGRESS,					// Back-end compiler is still in operation
	CL_DEV_BUILD_ERROR,							// Error occurred during back-end build process
	CL_DEV_INVALID_KERNEL_NAME,					// Kernel name is not found in the program
	CL_DEV_OBJECT_ALREADY_LOCKED,				// Object already is locked
};

/**
* CL_FAILED
* Checks whether a return code is failure
*/
#define CL_DEV_FAILED(code)				(CL_DEV_SUCCESS > (code))
#define CL_DEV_SUCCEEDED(code)			(CL_DEV_SUCCESS <= (code))

//Defines possible values of device allocated buffer
typedef enum cl_dev_mem_flags
{
	CL_DEV_MEM_READ			= 1,	// Buffer is accessible only for READ
	CL_DEV_MEM_WRITE		= 2,	// Buffer is accessible only for WRITE
	CL_DEV_MEM_READ_WRITE	= 3,	// Buffer is accessible for both READING and WRITING.
	CL_DEV_MEM_HOST_MEM		= 4,	// Buffer should be allocated within host memory accessible by the device.
									// The buffer could be accessed by map commands. 
};

//Defines possible values of a host pointer provided for device memory object.
typedef enum cl_dev_host_ptr_flags
{
	CL_DEV_HOST_PTR_NONE			= 0,		// The host buffer could be used internally by the agent.
	CL_DEV_HOST_PTR_DATA_AVAIL		= 1,		// The HOST pointer contains initial data for the memory object.
	CL_DEV_HOST_PTR_MAPPED_REGION	= 2,		// The host pointer defines a region wherein map operation must be completed.
};

//Defines possible values of device list properties
typedef enum cl_dev_cmd_list_props
{
	CL_DEV_LIST_NONE = 0,		// Determines a list wherein all items will be executed sequentially.
	CL_DEV_LIST_ENABLE_OOO,		// Determines whether the out-of-order optimization could be applied on items in the command list
};

//Defines possible values of device command identifiers that is passed within cl_dev_cmd_desc structure.
typedef enum cl_dev_cmd_type
{
	CL_DEV_CMD_READ = 0,			//Read buffer command
	CL_DEV_CMD_WRITE,				//Write buffer command
	CL_DEV_CMD_COPY,				//Copy buffer command
	CL_DEV_CMD_MAP,					//Map Command
	CL_DEV_CMD_UNMAP,				//UnMap command
	CL_DEV_CMD_EXEC_KERNEL,			//Execute Kernel Command
	CL_DEV_CMD_EXEC_TASK,			//Execute task command
	CL_DEV_CMD_EXEC_NATIVE,			//Execute native kernel command
	//--------------------
	CL_DEV_CMD_MAX_COMMAND_TYPE
};

//Defines possible values of mapped region of a memory object.
typedef enum cl_dev_map_flags
{
	CL_DEV_MAP_READ			= 1,			//The mapped region is READ only.
	CL_DEV_MAP_WRITE		= 2,			//The mapped region is WRITE only.
	CL_DEV_MAP_READ_WRITE	= 3,			//The mapped region is accessible for both reading and writing.
};

//Defines possible values of memory object types.
typedef enum cl_dev_mem_object_type
{
	CL_DEV_MEM_OBJECT_IMAGE2D = 1,	//The memory object is 2D image.
	CL_DEV_MEM_OBJECT_IMAGE3D,		//The memory object is 3D image.
	CL_DEV_MEM_OBJECT_BUFFER		//The memory object is 1D buffer.
};

// Defines possible values of binary that is passed to clDevBuildProgram function.
typedef enum cl_dev_binary_prop
{
	CL_DEV_BINARY_COMPILER = 1,		// The origin of binary is one of the Front-End compilers
	CL_DEV_BINARY_USER,				// The origin of binary is a binary loaded by user
};

// Defines possible values of the kernel information that could be retrieved by clDevGetKernelInfo function.
typedef enum cl_dev_kernel_info
{
	CL_DEV_KERNEL_NAME					= 1,	// Specifies NULL terminated function name.
	CL_DEV_KERNEL_PROTOTYPE,					// Specifies list of kernel arguments (prototype)
												// as defined by cl_kernel_arg_type.
	CL_DEV_KERNEL_WG_SIZE,						// Returns the work-group size that can be used to execute
												// a kernel. The device agent uses resource requirements
												// of the kernel to determine optimal work-group size.
	CL_DEV_KERNEL_WG_SIZE_REQUIRED,				// Specifies the required work-group size as was declared during
												// kernel compilation.
	CL_DEV_KERNEL_IMPLICIT_LOCAL_SIZE,			// Specifies size of implicit local memory buffers defined in kernel.
};

typedef enum _cl_dev_sampler_prop
{
    __ADDRESS_BASE								= 0,
    CL_DEV_SAMPLER_ADDRESS_NONE					= 0,
    CL_DEV_SAMPLER_ADDRESS_CLAMP				= 1 << __ADDRESS_BASE ,
    CL_DEV_SAMPLER_ADDRESS_CLAMP_TO_EDGE		= 2 << __ADDRESS_BASE,
    CL_DEV_SAMPLER_ADDRESS_REPEAT				= 3 << __ADDRESS_BASE,
    __ADDRESS_BITS								= 3,        // number of bits required to represent address info
    __ADDRESS_MASK								= ( (1<<__ADDRESS_BITS) -1),

    __NORMALIZED_BASE							= __ADDRESS_BITS,
    CL_DEV_SAMPLER_NORMALIZED_COORDS_FALSE		= 0,
    CL_DEV_SAMPLER_NORMALIZED_COORDS_TRUE		= 1 << __NORMALIZED_BASE,
    __NORMALIZED_BITS							=	1,        // number of bits required to represent normalization 
    __NORMALIZED_MASK							= ( ((1<<__NORMALIZED_BITS)-1) << __NORMALIZED_BASE ),

    __FILTER_BASE								= __NORMALIZED_BASE + __NORMALIZED_BITS,
    CL_DEV_SAMPLER_FILTER_NEAREST				= 0 << __FILTER_BASE,
    CL_DEV_SAMPLER_FILTER_LINEAR				= 1 << __FILTER_BASE,
    __FILTER_BITS					            = 2,        // number of bits required to represent address info
    __FILTER_MASK								= ( ((1<<__FILTER_BITS)-1) << __FILTER_BASE),

} cl_dev_sampler_prop;

// ------------------------------------------------------------------------------
// Device API data structure defenition
// ------------------------------------------------------------------------------

//This structure holds a description of a command that is passed to the device for execution.
typedef struct _cl_dev_cmd_desc
{
	cl_dev_cmd_type	type;				// Command type identifier, defined in cl_dev_cmd_type
	cl_dev_cmd_id	id;					// Framework provided command identifier. It will be used
										// during command completion notification in clDevCmdStatusChanged()
	void*			data;				// A Pointer to user specific information It will be used
										// during command completion notification in clDevCmdStatusChanged()
	void*			params;				// Pointer to a buffer that holds command specific parameters
	size_t			param_size;			// Size of the parameter buffer in bytes
	bool			profiling;			// Enable profiling data for this command
} cl_dev_cmd_desc;

// This structure describes a handle of device memory object
typedef struct _cl_dev_mem
{
	cl_uint	allocId;					// Identifier of the allocator that has allocated the memory object.
										// When memory object is allocated by device, the value is device id.
	void*	objHandle;					// Handle of the allocated memory object.
} *cl_dev_mem;

//This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_READ and CL_DEV_CMD_WRITE identifiers.
typedef struct _cl_dev_cmd_param_rw
{
	cl_dev_mem		memObj;					// Handle to a memory object from where/to the data to be read/written.
											// It can be a buffer, image2D or image3D
	cl_uint			dim_count;				// A number of dimensions in the memory object.
	size_t			origin[MAX_WORK_DIM];	// Multi-dimensional iffset in the memory object. 
											// For 2Dimages origin[2] must be 0.
	size_t			region[MAX_WORK_DIM];	// Defines multi-dimensional region of the memory object to be used. 
											// region[0] is width of region,
											// region[1] is height of the region,
											// region[2] is depth of the region.
	void*			ptr;					// Pointer to the host memory where the data to be read/written
	size_t			pitch[MAX_WORK_DIM-1];	// A pointer to array of dimension pitches in bytes for the mapped region. The size of the array is dim_count-1.
											// pitch[0] will contain the scan-line pitch in bytes for the mapped region,
											// picth[1] will contain the size in bytes of each 2D slice for the mapped region.									
} cl_dev_cmd_param_rw;

// This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_COPY identifier.
typedef struct _cl_dev_cmd_param_copy
{
	cl_dev_mem		srcMemObj;					// Handle to a source memory object from where the data to be read.
	cl_dev_mem		dstMemObj;					// Handle to a source memory object to where the data to be written.
	cl_uint			src_dim_count;				// A number of dimensions in the source memory object.
	cl_uint			dst_dim_count;				// A number of dimensions in the destination memory object.
	size_t			src_origin[MAX_WORK_DIM];	// Multi-dimensional offset in the source memory object.
	size_t			dst_origin[MAX_WORK_DIM];	// Multi-dimensional offset in the destination memory object.
	size_t			region[MAX_WORK_DIM];		// Defines multi-dimensional region of the memory object to be copied. 
												//	region[0] is width of region,
												//	region[1] is height of the region,
												//	region[2] is depth of the region.
} cl_dev_cmd_param_copy;

// This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_MAP identifier.
typedef struct	_cl_dev_cmd_param_map
{
	cl_dev_mem			memObj;					// Handle to a memory object to be mapped
	void*				ptr;					// A pointer to mapped region associated with the map command.
	cl_dev_map_flags	flags;					// A bit-field is set to indicate how the mapped region will be used.
												// The values are defined by cl_dev_map_flags.
	cl_uint				dim_count;				// A number of dimensions in the mapped memory object.
	size_t				origin[MAX_WORK_DIM];	// Multi-dimensional offset in the memory object to mapped.
	size_t				region[MAX_WORK_DIM];	// Defines multi-dimensional region of the memory object to be mapped. 
												// region[0] is width of region,
												// region[1] is height of the region,
												// region[2] is depth of the region.
	size_t				pitch[MAX_WORK_DIM-1];	// A pointer to array of dimension pitches in bytes for the mapped region. The size of the array is dim_count-1.
												// pitch[0] will contain the scan-line pitch in bytes for the mapped region,
												// picth[1] will contain the size in bytes of each 2D slice for the mapped region.
} cl_dev_cmd_param_map;

//This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_KERNEL and CL_DEV_CMD_TASK identifiers.
typedef struct	_cl_dev_cmd_param_kernel
{
	cl_dev_kernel		kernel; 					// Handle to a kernel object to be executed
	cl_uint				work_dim;					// The number of dimensions used to specify the global work-items and work-items in the work-group.
													// Work_dim must be greater than 0 and less than or equal to 3.
													// When executing a task, this value must be equal to 1.
	size_t				glb_wrk_offs[MAX_WORK_DIM];	// Currently must be (0, 0, 0). In a future revision of OpenCL,
													// glb_work_offs can be used to specify an array of work_dim unsigned
													// values that describe the offset used to calculate the global ID of a work-item.
	size_t				glb_wrk_size[MAX_WORK_DIM];	// An array of work_dim unsigned values that describe the number of global work-items
													// in work_dim dimensions that will execute the kernel function. The total number of
													// global work-items is computed as glb_wrk_size[0] * … *glb_wrk_size[work_dim – 1].
													// When executing a task, this value must be equal to 1.
	size_t				lcl_wrk_size[MAX_WORK_DIM];	// An array of work_dim unsigned values that describe the number of work-items
													// that make up a work-group (also referred to as the size of the work-group)
													// that will execute the kernel specified by kernel. The total number of work-items in a work-group
													// is computed as lcl_wrk_size[0] * … * lcl_wrk_size[work_dim – 1].
													// When executing a task, this value must be equal to 1. When the values are 0, and hint or required
													// work-group size is defined for the kernel, the agent will use these values for execution.
													// When the values are 0, and neither hint nor required work-group sizes is not defined,
													// the agent will use optimal work-group size.
	const void*			arg_values;					// An array of argument values of the specific kernel.
													// An order of the values must be the same as the order of parameters in the kernel prototype.
													// If an argument is a memory object, a relevant value contains its handle (dev_mem_obj).
	size_t				arg_size;					// Size in bytes of the arg_values array.
} cl_dev_cmd_param_kernel;


//This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_NATIVE identifier.
typedef struct _cl_dev_cmd_param_native
{
	void*			func_ptr;			// A pointer to a host callable user function.
	size_t			args;				// The size in bytes of the argument list that argv points to.
	void*			argv;				// A pointer to the args list that user function should be called with. Some items contain handles to device memory objects. Before the user function is executed, the memory object handles are replaced by pointers to global memory.
	cl_uint			mem_num;			// The number of buffer objects that are passed in argv. These values will be updated by the device agent.
	void**			mem_loc;			// An offset to appropriate locations that argv points to where memory object handles (cl_dev_mem values) are stored.
} cl_dev_cmd_param_native;

// ------------------------------------------------------------------------------
// Device API functions defenition
// ------------------------------------------------------------------------------

#define IN

#define OUT

#define INOUT

//
//Device Initialization functions
//
/* clDevInitDevice
   Description
		Initialize internal state of the device driver, returns a set of device driver entry points. 
   Input 
		dev_id				Device identifier as it appears in framework. This value is used in cl_dev_mem object identification.
		pDevCallBacks		A pointer to structure that holds set of pointers to callback functions provided to the device by the framework
   Output 
		pDevEntry			A pointer to structure that holds set of pointers to device driver entry points
   Returns
		CL_DEV_SUCCESS		The device was successfully created. pDevEntry holds updated pointers
		CL_DEV_ERROR_FAIL	Internal error
*/
cl_int clDevCreateDeviceInstance (	
                        cl_uint					dev_id,
						cl_dev_entry_points		*dev_entry,
						cl_dev_call_backs		*dev_callbacks,
						cl_dev_log_descriptor	*log_desc
						);

typedef cl_int (fn_clDevCreateDeviceInstance)(
                        cl_uint		dev_id,
						cl_dev_entry_points		*dev_entry,
						cl_dev_call_backs		*dev_callbacks,
						cl_dev_log_descriptor	*log_desc
						);

/************************************************************************************************************************
   clDevGetDeviceInfo
	Description
		This function return device specific information defined by cl_device_info enumeration as specified in OCL spec. table 4.3.
	Input
		param					An enumeration that identifies the device information being queried. It can be one of
								the following values as specified in OCL spec. table 4.3
		valSize				Specifies the size in bytes of memory pointed to by paramValue. This size in
								bytes must be >= size of return type
	Output
		paramVal				A pointer to memory location where appropriate values for a given param as specified in OCL spec. table 4.3 will be returned. If paramVal is NULL, it is ignored
		paramValSize_ret		Returns the actual size in bytes of data being queried by paramVal. If paramValSize_ret is NULL, it is ignored
	Returns
		CL_DEV_SUCCESS			If functions is executed successfully.
		CL_DEV_INVALID_VALUE	If param_name is not one of the supported values or if size in bytes specified by paramValSize is < size of return type as specified in OCL spec. table 4.3 and paramVal is not a NULL value
**************************************************************************************************************************/
cl_int clDevGetDeviceInfo(  cl_device_info  IN  param, 
                            size_t          IN  valSize, 
                            void*           OUT paramVal,
				            size_t*         OUT paramValSizeRet
                            );

typedef cl_int (fn_clDevGetDeviceInfo)(
                        cl_device_info  IN  param, 
                        size_t          IN  valSize, 
                        void*           OUT paramVal,
                        size_t*         OUT paramValSizeRet						
						);

//
//Device Callback function prototypes
//
/* clDevCmdStatusChanged
	Description
		This function is called when previously enqueued command changes its state to RUNNING or COMPLETED. 
	Input
		cmd_id				Identifier of the enqueued command that changes its status
		data				A pointer to buffer that was passed within cl_dev_cmd_desc within clDevCommandListExecute().
		cmd_status			New command status
		completion_result	Indicates completion result. CL_DEV_SUCCESS the command was successfully completed.
							CL_DEV_ERROR_FAILED indicated that command completed with an error.
		timer				Time in nano seconds of the device timer when the status changed occurred,
							available only when profiling is enabled.
	Output
		None
	Returns
		None
*/
typedef void (fn_clDevCmdStatusChanged)(	cl_dev_cmd_id	IN cmd_id,
											void*			IN	data,
											cl_int			IN cmd_status,
											cl_int			IN completion_result,
											cl_ulong		IN timer
											);

/* clDevBuildStatusUpdate
	Description
		This function is called during build process of the specific program. Currently this function
		is called when program build is finished.
	Input
		prog			Identifier of the notified program. That was returned with clDevBuildProgram().
		data			A pointer to buffer that was passed to clDevBuildProgram().
		status			An updated status of build process
*/

typedef void (fn_clDevBuildStatusUpdate)( cl_dev_program	IN prog,
										  void*			IN data,
										  cl_build_status IN status
										);

//
// Command List function prototypes
//
/* clDevCreateCommandList
	Description
		This function creates a dependent command list on a device. This function performs an implicit retain of the command list.
	Input
		props						Determines whether the out-of-order optimization could be applied on items in the command list.
	Output
		list						A valid (non zero) handle to device command list.
	Returns
		CL_DEV_SUCCESS				The command queue successfully created
		CL_DEV_INVALID_VALUE		If values specified in properties are not valid
		CL_DEV_INVALID_PROPERTIES	If values specified in properties are valid but are not supported by the device
		CL_DEV_OUT_OF_MEMORY		If there is a failure to allocate resources required by the OCL device driver
*/
typedef cl_int (fn_clDevCreateCommandList)(	cl_dev_cmd_list_props IN props,
										   cl_dev_cmd_list* OUT list
										   );

/* clDevFlushCommandList
	Description
		This function flushes the content of a list, all waiting commands are sent to execution.
	Input
		list						A valid handle to device command list
	Output
		None
	Returns
		CL_DEV_SUCCESS				The function is executed successfully
		CL_DEV_INVALID_COMMAND_LIST	If command list is not a valid command list
*/
typedef cl_int (fn_clDevFlushCommandList)(	cl_dev_cmd_list IN list
										  );

/* clDevRetainCommandList
	Description
		Increments the command list reference count. 
	Input
		list						A valid handle to device command list
	Output
		None
	Returns
		CL_DEV_SUCCESS				The function is executed successfully
		CL_DEV_INVALID_COMMAND_LIST	If command list is not a valid command list
*/
typedef cl_int (fn_clDevRetainCommandList)(	cl_dev_cmd_list IN list
											);

/* clDevReleaseCommandList
	Description
		Decrements the command list reference count. After the command list reference count becomes zero and
		all commands of the command list have completed (eg. Kernel executions, memory object updates etc.),
		the command queue is deleted. 
	Input
		list						A valid handle to device command list
	Output
		None
	Returns
		CL_DEV_SUCCESS				The function is executed successfully
		CL_DEV_INVALID_COMMAND_LIST	If command list is not a valid command list
*/
typedef cl_int (fn_clDevReleaseCommandList)( cl_dev_cmd_list IN list
											 );

/* clDevCommandListExecute
	Description
		Passes a list of dependent commands into a specified command list for execution.
		If the list was created without OOO optimizations the commands are depended by the list index: item[n] depends on item[n-1].
		First item (item[0]) is dependent on the last item that was passed within previous  call for the same list identifier.
	Input
		list							A valid handle to device command list, where to add list of commands. If value is NULL,
										the new independent list is created for given commands
		cmds							A pointer to a vector of command list to execute, each entry contains a pointer to cl_dev_cmd_desc structure
		count							Number of entries in cmds parameter
	Output
		None
	 Returns
		CL_DEV_SUCCESS					The function is executed successfully.
		CL_DEV_INVALID_COMMAND_LIST		If command list is not a valid command list
		CL_DEV_INVALID_COMMAND_TYPE		If command type specified in one of the cmds entries is not a valid command.
		CL_DEV_INVALID_MEM_OBJECT		If one or more memory objects specified in parameters in one or more of cmds entries
										are not valid or are not buffer objects.
		CL_DEV_INVALID_KERNEL			If kernel identifier specified in execution parameters is not valid.
		CL_DEV_INVALID_OPERATION		If specific device can’t execute native kernel.
		CL_DEV_OUT_OF_RESOURCES			Is a failure to queue the execution instance of kernel because of insufficient resources
										needed to execute the kernel.
		CL_DEV_INVALID_WRK_DIM			If work_dim is not a valid value (i.e. a value between 1 and 3).
		CL_DEV_INVALID_WG_SIZE			If lcl_wrk_size is specified and number of workitems specified by glb_wrk_size is
										not evenly divisable by size of work-group given by lcl_wrk_size or does not match
										the work-group size specified for kernel using the __attribute__((reqd_work_group_size(X, Y, Z)))
										qualifier in program source.
		CL_DEV_INVALID_GLB_OFFSET		If glb_wrk_offset is not (0, 0, 0).
		CL_DEV_INVALID_WRK_ITEM_SIZE	If the number of work-items specified in any of lcl_wrk_size[] is greater than the corresponding
										values specified by CL_DEVICE_MAX_WORK_ITEM_SIZES[]
*/
typedef cl_int (fn_clDevCommandListExecute)( cl_dev_cmd_list IN list,
											 cl_dev_cmd_desc* IN *cmds,
											 cl_uint IN count
											 );

//
// Memory Object function prototypes
//
/* clDevGetSupportedImageFormats
	Description
		This function returns the list of image formats supported by an OCL implementation when the information about
		an image memory object is specified and device supports image objects.
	Input
		flags					A bit-field that is used to specify allocation and usage information such as the memory arena
								that should be used to allocate the image object and how it will be used.
		image_type				Describes the image type as described in (cl_dev_mem_object_type).Only image formats are supported.
		num_entries				Specifies the number of entries that can be returned in the memory location given by formats.
								If value is 0 and formats is NULL, the num_entries_ret returns actual number of supported formats.
	Output
		formats					A pointer to array of structures that describes format properties of the image to be allocated.
								Refer to OCL spec section 5.2.4.1 for a detailed description of the image format descriptor.
		num_entries_ret			The actual number of supported image formats for a specific context and values specified by flags.
								If the value is NULL, it is ignored.
	 Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_VALUE	If values specified in parameters is not valid or if num_entries is 0 and formats is not NULL.
*/
typedef cl_int (fn_clDevGetSupportedImageFormats)( cl_dev_mem_flags IN flags,
								   cl_dev_mem_object_type IN image_type,
								   cl_uint IN num_entries,
								   cl_image_format* OUT formats,
								   cl_uint* OUT num_entries_ret
								   );
/* clDevCreateMemoryObject
	Description
		This function creates a reference and allocates resources required by different memory objects, like buffer,
		2D image and new 3D image. It’s not mandatory that actual physical memory will be allocated.
	Input
		flags			A bit-field that is used to specify allocation and usage information such as the memory arena
						that should be used to allocate the image object and how it will be used.
		format			A pointer to a structure that describes format properties of the image to be allocated.
						Refer to OCL spec section 5.2.4.1 for a detailed description of the image format descriptor.
						When creating buffers this parameter must be NULL.
		dim_count		A number of dimensions in the required memory object.
		dim_size		A pointer to a buffer that defines object dimentions.
						When creating a buffer, dim points size of the buffer in bytes.
						dim[0] specifies width of the image in pixel, 
						dim[1] specifies height of the image in pixel,
						dim[2] specifies depth of the image in pixel,
						dim[dim_count-1] specefies size of the dim_count dimension.
						All values must be greater or equal to 1.
		buffer_ptr		A pointer to memory buffer that will be used for object data storage.
						When the value is not NULL, no additional host memory will be allocated
						and provided pointer will be used for data storage.
						In some case the data will be cached on the device itself.
		pitch			A pointer to array of dimension pitches in bytes for the mapped region.
						The size of the array is dim_count-1.
							pitch[0] will contain the scan-line pitch in bytes of the mapped region,
							picth[1] will contain the size in bytes of each 2D slice of the mapped region.
							The NULL value is valid only for 1D buffers.
		host_flags		A set of flags specify the properties of the given host pointer. When CL_DEV_HOST_PTR_NONE,
						this pointer could be used by the agent to store actual buffer data.
	Output
		memObj			A valid (non zero) handle to allocated recourses of the memory object.
	Returns
		CL_DEV_SUCCESS					The function is executed successfully.
		CL_DEV_INVALID_VALUE			If values specified in properties are not valid.
		CL_DEV_INVALID_IMG_FORMAT		If values specified in format are not valid or if it is NULL and width or height not equal 1.
		CL_DEV_INVALID_IMG_SIZE			If width or height are 0 or if they exceed maximum possible values.
		CL_DEV_IMG_FORMAT_NOT_SUPPORTED	If the format is not supported.
		CL_DEV_OBJECT_ALLOC_FAIL		If there is a failure to allocate resources for memory object.
		CL_DEV_INVALID_OPERATION		If the device does not support images.
*/
typedef cl_int (fn_clDevCreateMemoryObject)( cl_dev_mem_flags	IN flags,
								const cl_image_format*			IN format,
								cl_uint							IN dim_count,
								const size_t*					IN dim_size,
								void*							IN buffer_ptr,
								const size_t*					IN pitch,
								cl_dev_host_ptr_flags			IN host_flags,
								cl_dev_mem*						OUT memObj
								);

/* clDevDeleteMemoryObject
	Description
		This function deletes previously created memory object.
	Input
		memObj						A valid handle to memory object
	Output
		NONE
	Returns
		CL_DEV_SUCCESS				The function is executed successfully.
		CL_DEV_INVALID_MEM_OBJECT	If memObj is not a valid memory object.
		CL_DEV_INVALID_OPERATION	If memObj has one or mapped regions.
*/
typedef cl_int (fn_clDevDeleteMemoryObject)( cl_dev_mem IN memObj
											 );
/* clDevCreateMappedRegion
	Description
		Creates host mapped memory region for further buffer map operation.
	Input/Output
		pMapParams					A valid pointer to descriptor of memory mapped region.
									Input:
									memObj	- Valid memory object handle,
									flags	- Bitset of flags of mapped region,
									offset	- Mapped region offset,
									region	- Mapped region size.
									Output:
									ptr		- Pointer to the mapped region,
									pitch	- pitches in bytes for the mapped region. The size of the array is dim_count-1,
												pitch[0] will contain the scan-line pitch in bytes for the mapped region,
												picth[1] will contain the size in bytes of each 2D slice for the mapped region.

	Returns
		CL_DEV_SUCCESS				The function is executed successfully.
		CL_DEV_INVALID_MEM_OBJECT	If memObj is not a valid memory object.
		CL_INVALID_VALUE			If region being mapped given by (origin, origin+region) is out of bounds.
									If object is a buffer and origin[1] or origin[2] are not equal to 0, or region[1]  or region[2] are not equal to 1.
									If object is a 2D image and origin[2] is not equal to 0 or region[2] is not equal to 1.
									If object is a 2D or 3D image and row_pitch is NULL.
									If image is a 3D image object and slice_pitch is NULL
*/
typedef cl_int (fn_clDevCreateMappedRegion)( cl_dev_cmd_param_map*	INOUT	pMapParams
											 );

/* clDevReleaseMappedRegion
	Description
		Releases previously created host mapped memory region.
	Input
		pMapParams					A valid pointer to descriptor of memory mapped region.
	Output
		NONE
	Returns
		CL_DEV_SUCCESS				The function is executed successfully.
		CL_DEV_INVALID_MEM_OBJECT	If memObj is not a valid memory object.
		CL_INVALID_VALUE			If mapped memory pointer is not associated with memory object.
*/
typedef cl_int (fn_clDevReleaseMappedRegion)( cl_dev_cmd_param_map*	IN	pMapParams
											  );

//
// Program build function prototypes
//

/* clDevCheckProgramBinary
	Description
		Performs syntax validation of the intermediate or binary to be built by the device during later stages.
	Input
		bin_size				Size of the binary buffer
		bin						A pointer to binary buffer that holds program container defined by cl_prog_container.
	Output
		NONE
	Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_VALUE	If bin_size is 0 or bin is NULL.
		CL_DEV_INVALID_BINARY	If the binary is not supported by the device or program container content is invalid.
*/
typedef cl_int (fn_clDevCheckProgramBinary)( size_t IN bin_size,
											 const void* IN bin
											 );

/* clDevCreateProgram
	Description
		Creates a device specific program entity (no build is performed).
	Input
		bin_size						Size of the binary buffer
		bin								A pointer to binary buffer that holds program container defined by cl_prog_container. 
		prop							Specifies the origin of the input binary. The values is defined by cl_dev_binary_prop.
	Output
		prog							A valid (non zero) handle to created program object.
	Returns
		CL_DEV_SUCCESS					The function is executed successfully.
		CL_DEV_INVALID_BINARY			If the back-end compiler failed to process binary.
		CL_DEV_OUT_OF_MEMORY			If the device failed to allocate memory for the program.
*/
typedef cl_int (fn_clDevCreateProgram)( size_t IN bin_size,
									   const void* IN bin,
									   cl_dev_binary_prop IN prop,
									   cl_dev_program* OUT prog
									   );

/* clDevBuildProgram
	Description
		Builds (compiles & links) a program executable from the program intermediate or binary.
	Input
		prog							Program handle to be built
		options							A pointer to a string that describes the build options to be used for building the program executable.
										The list of supported options is described in section 5.4.3 in OCL spec. document.
		user_data						This value will be passed as an argument when clDevBuildFinished is called. Can be NULL.
	Returns
		CL_DEV_SUCCESS					The function is executed successfully.
		CL_DEV_INVALID_BUILD_OPTIONS	If build options for back-end compiler specified by options are invalid.
		CL_DEV_INVALID_BINARY			If the back-end compiler failed to process binary.
		CL_DEV_OUT_OF_MEMORY			If the device failed to allocate memory for the program.
*/
typedef cl_int (fn_clDevBuildProgram)( cl_dev_program IN prog,
									   const cl_char* IN options,
									   void* IN user_data								   
									   );

/* clDevReleaseProgram
	Description
		Deletes previously created program object and releases all related resources.
	Input
		prog							A handle to program object to be deleted
	Output
		NONE
	Returns
		CL_DEV_SUCCESS					The function is executed successfully.
		CL_DEV_INVALID_PROGRAM			Invalid program object was specified.
*/
typedef cl_int (fn_clDevReleaseProgram)(cl_dev_program IN prog);

/* clDevUnloadCompiler
	Description
		Allows the framework to release the resources allocated by the back-end compiler.
		This is a hint from the framework and does not guarantee that the compiler will not be used in the future
		or that the compiler will actually be unloaded by the device.
	Input
		NONE
	Output
		NONE
	Returns
		CL_DEV_SUCCESS	The function is executed successfully.
*/
typedef cl_int (fn_clDevUnloadCompiler)();

/* clDevGetProgramBinary
	Description
		Returns the compiled program binary. The output buffer contains program container as defined cl_prog_binary_desc.
	Input
		prog					A handle to created program object.
		size					Size in bytes of the buffer passed to the function. 
	Output
		binary					A pointer to buffer wherein program binary will be stored.
		size_ret				The actual size in bytes of the returned buffer. When size is equal to 0 and binary is NULL, returns size in bytes of a program binary. If NULL the parameter is ignored.
	Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
		CL_DEV_INVALID_VALUE	If size is not enough to store the binary or binary is NULL and size is not 0.
*/
typedef cl_int (fn_clDevGetProgramBinary)( cl_dev_program IN prog,
										 size_t	IN size,
										 void* OUT binary,
										 size_t* OUT size_ret
										 );
/* clDevGetBuildLog
	Description
		Returns the build log after clDevBuildProgram was called and finished.
	Input
		prog					A handle to created program object.
		size					Size in bytes of the buffer passed to the function. 
	Output
		log						A pointer to buffer wherein program build log will be stored.
		size_ret				The actual size in bytes of the returned buffer. When size is equal to 0 and binary is NULL,
								returns size in bytes of the log. If NULL the parameter is ignored.
	Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
		CL_DEV_INVALID_VALUE	If size is not enough to store the binary or binary is NULL and size is not 0.
		CL_DEV_STILL_BUILDING	If program is under build process.
*/
typedef cl_int (fn_clDevGetBuildLog)( cl_dev_program IN prog,
									  size_t IN size,
									  char* OUT log,
									  size_t* OUT size_ret
									  );

/* clDevGetSupportedBinaries (optional)
	Description
		Returns the list of supported binaries.
	Input
		count					Size of the buffer passed to the function in terms of cl_prog_binary_desc. 
	Output
		types					A pointer to buffer wherein binary types will be stored.
		count_ret				The actual size ofthe buffer returned by the function in terms of cl_prog_binary_desc.
								When count is equal to 0 and types is NULL, function returns a size of the list.
								If NULL the parameter is ignored.
	Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
		CL_DEV_INVALID_VALUE	If count is not enough to store the binary or types is NULL and count is not 0.
*/
typedef cl_int (fn_clDevGetSupportedBinaries)( size_t IN size,
										   cl_prog_binary_desc* OUT types,
										   size_t* OUT size_ret
										   );

//
// Kernel function prototypes
//

/* clDevGetKernelId
	Description
		Returns an internal identifier of the kernel.
	Input
		prog					A handle to created program object.
		name					A pointer to NULL terminated string that contains kernel name. 
	Output
		kernel_id				A valid (non zero) kernel internal identifier.
	Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_VALUE	If name is NULL.
		CL_DEV_INVALID_PROGRAM	If prog is not a valid program object.
		CL_INVALID_KERNEL_NAME	If name is not found in the program
*/
typedef cl_int (fn_clDevGetKernelId)( cl_dev_program IN prog,
									  const char* IN name,
									  cl_dev_kernel* OUT kernel_id
									  );
/* clDevGetProgramKernels
	Description
		Returns identifiers of all kernels belong to specific program object.
	Input
		prog					A handle to created program object.
		num_kernels				Size of array pointed to by kernels specified as the number of cl_dev_kernel entries. 
	Output
		kernels					The buffer where the kernel objects for kernels in program will be returned.
		num_kernels_ret			The number of kernels in program. When num_kernels is equal to 0 and kernels is NULL,
								returns only the number of kernels. If NULL the parameter is ignored.
	Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
		CL_DEV_INVALID_VALUE	If num_kernels is not enough to store the identifiers or kernels is NULL and num_kernels is not 0.
*/
typedef cl_int (fn_clDevGetProgramKernels)( cl_dev_program IN prog,
										 cl_uint IN num_kernels,
										 cl_dev_kernel* OUT kernels,
										 cl_uint* OUT num_kernels_ret
										 );

/* clDevGetKernelInfo
	Description
		Returns information about the kernel in program object
	Input
		kernel			An identifier of kernel in program object
		param			Specifies the information to query. The list is defined by cl_dev_kernel_info.
		value_size		Size in bytes of memory buffer pointed to by value.
	Output
		value			A pointer to memory where the appropriate result being queried is returned.
		value_size_ret	The actual size in bytes of data copied to value. When value_size is equal to 0 and value is NULL,
						returns only the size of data. If NULL the parameter is ignored.
*/
typedef cl_int (fn_clDevGetKernelInfo)( cl_dev_kernel IN kernel,
									    cl_dev_kernel_info IN param,
										size_t IN value_size,
										void* OUT value,
										size_t* OUT value_size_ret
										);

/* clDevCloseDevice
	De-initialize internal state of the device agent and releases all allocated data.
	Input
		NONE
	Output
		NONE
	Returns
		NONE
*/
typedef void (fn_clDevCloseDevice)(
								   void
								   );

//
// Logger function prototypes
//

/* clDevSetLogger
	Description
		This function sets framework logger for the device.
	Input
		loger			A pointer to a structure that hold framework logger entry points.
	Output
		NONE
	Returns
						CL_DEV_SUCCESS	The function is executed successfully.
						CL_DEV_INVALID_OPERATION	Device doesn’t supports logging operations.
*/
typedef cl_int (fn_clDevSetLogger)(cl_dev_log_descriptor* IN logger);

/* clLogCreateClient
	Description
		This function creates a logger client for the device. Each device may create multiple logger clients,
		e.g. client per each internal component.
	Input
		dev_id				A pointer to a structure that hold framework logger entry points.
		client_name			Name associated with logger client.
	Output
		client_id			An client logger identifier to be used in further calls to clLogAddLine().
	Returns
		CL_DEV_SUCCESS		The function is executed successfully.
		CL_DEV_FAILED		Logger internal error occurred.
*/
typedef cl_int (fn_clLogCreateClient)( cl_int IN dev_id,
						  wchar_t* IN client_name,
						  cl_int* OUT client_id
						  );
/* clLogReleaseClient
	Description
		This function releases previously created logger client.
	Input
		client_id				A logger client identifier that created with clLogCreateClient().
	Output
		NONE
	Returns
		CL_DEV_SUCCESS			The function is executed successfully.
		CL_DEV_INVALID_VALUE	Invalid client identifier.
*/
typedef cl_int (fn_clLogReleaseClient)(cl_int IN client_id);

/* clLogAddLine
	This function adds a logger line to logger client. The logged line will appear in the logger only if logger line level
	is equal or above of the current client logger level.
	Input
		client_id	Logger client identifier that was created with clLogCreateClient()
		log_level	Logging level of the message.
		source_file	Name of the source file that has added the log message.
		function_name	Name of the function from where the log line was added.
		line_num	Line number from where the log line was added.
		message	The used message to be added into the log line. The message format string is identical to printf() format.
	Output
		NONE
	Returns
		CL_DEV_SUCCESS	The function is executed successfully.
		CL_DEV_INVALID_VALUE	Logger client id is not valid.
*/
typedef cl_int (fn_clLogAddLine)( cl_int IN client_id,
								 cl_int IN log_level,
								 const wchar_t* IN source_file,
								 const wchar_t* IN function_name,
								 cl_int IN line_num,
								 const wchar_t* IN message, ...);

// ------------------------------------------------------
// Device / Framework entry points defenition
// ------------------------------------------------------

//This structure holds pointers to the device driver entry points
typedef struct _cl_dev_entry_points
{
	fn_clDevCreateCommandList*			pclDevCreateCommandList;		// Pointer to clDevCreateCommandList function
	fn_clDevFlushCommandList*			pclDevFlushCommandList;			// Pointer to clDevFlushCommandList function
	fn_clDevRetainCommandList*			pclDevRetainCommandList;		// Pointer to clDevRetainCommandList function
	fn_clDevReleaseCommandList*			pclDevReleaseCommandList;		// Pointer to clDevReleaseCommandList function
	fn_clDevCommandListExecute*			pclDevCommandListExecute;		// Pointer to clDevCommandListExecute function
	fn_clDevGetSupportedImageFormats*	pclDevGetSupportedImageFormats;	// Pointer to clDevGetSupportedImageFormats function
	fn_clDevCreateMemoryObject*			pclDevCreateMemoryObject;		// Pointer to clDevCreateMemoryObject function
	fn_clDevDeleteMemoryObject*			pclDevDeleteMemoryObject;		// Pointer to clDevDeleteMemoryObject function
	fn_clDevCreateMappedRegion*			pclDevCreateMappedRegion;		// Pointer to clDevCreateMappedRegion function
	fn_clDevReleaseMappedRegion*		pclDevReleaseMappedRegion;		// Pointer to clDevReleaseMappedRegion function
	fn_clDevCheckProgramBinary*			pclDevCheckProgramBinary;		// Pointer to clDevCheckProgramBinary function
	fn_clDevCreateProgram*				pclDevCreateProgram;			// Pointer to clDevCreateProgram function
	fn_clDevBuildProgram*				pclDevBuildProgram;				// Pointer to clDevBuildProgram function
	fn_clDevReleaseProgram*				pclDevReleaseProgram;			// Pointer to clDevReleaseProgram function
	fn_clDevUnloadCompiler*				pclDevUnloadCompiler;			// Pointer to clDevUnloadCompiler function
	fn_clDevGetProgramBinary*			pclDevGetProgramBinary;			// Pointer to clDevGetProgramBinary function
	fn_clDevGetBuildLog*				pclDevGetBuildLog;				// Pointer to clDevGetBuildLog function
	fn_clDevGetSupportedBinaries*		pclDevGetSupportedBinaries;		// Pointer to clDevGetSupportedBinaries(optional) function.
																		// Could be NULL for some devices
	fn_clDevGetKernelId*				pclDevGetKernelId;				// Pointer to clDevGetKernelId function
	fn_clDevGetProgramKernels*			pclDevGetProgramKernels;		// Pointer to clDevGetProgramKernels function
	fn_clDevGetKernelInfo*				pclDevGetKernelInfo;			// Pointer to clDevGetKernelInfo function
																		// This pointer is optional and could be NULL.
	fn_clDevCloseDevice*				pclDevCloseDevice;				// Pointer to clDevCloseDevice
} cl_dev_entry_points;

//This structure holds pointers to the device driver callbacks into the framework.
typedef struct	_cl_dev_call_backs
{
	fn_clDevCmdStatusChanged*	pclDevCmdStatusChanged;		// Pointer to clDevCmdStatusChanged callback. 
	fn_clDevBuildStatusUpdate*	pclDevBuildStatusUpdate;	// Pointer to clDevBuildStatusUpdate callback.
} cl_dev_call_backs;

// This structure holds a description of functions provided by the framework logger.
typedef struct	_cl_dev_log_descriptor
{
	fn_clLogCreateClient*	pfnclLogCreateClient;		// Pointer to clLogCreateClient() function.
	fn_clLogAddLine*		pfnclLogAddLine;			// Pointer to clLogAddLine() function.
	fn_clLogReleaseClient*	pfnclLogReleaseClient;		// Pointer to clLogReleaseClient() function.
} cl_log_descriptor;

/**
* clErrTxt
* returns a wide-character string of the error code
*/
char* clDevErr2Txt(cl_dev_err_code error_code);

typedef void (fn_clNativeKernel)(void* INOUT param);

#ifdef __cplusplus
}
#endif

#endif  // __CL_DEVICE_API_H__
