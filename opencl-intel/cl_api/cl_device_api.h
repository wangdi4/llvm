/*****************************************************************************\

Copyright (c) Intel Corporation (2010).

    INTEL MAKES NO WARRANTY OF ANY KIND REGARDING THE CODE.  THIS CODE IS
    LICENSED ON AN "AS IS" BASIS AND INTEL WILL NOT PROVIDE ANY SUPPORT,
    ASSISTANCE, INSTALLATION, TRAINING OR OTHER SERVICES.  INTEL DOES NOT
    PROVIDE ANY UPDATES, ENHANCEMENTS OR EXTENSIONS.  INTEL SPECIFICALLY
    DISCLAIMS ANY WARRANTY OF MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR ANY
    PARTICULAR PURPOSE, OR ANY OTHER WARRANTY.  Intel disclaims all liability,
    including liability for infringement of any proprietary rights, relating to
    use of the code. No license, express or implied, by estoppels or otherwise,
    to any intellectual property rights is granted herein.

File Name:  cl_device_api.h

\*****************************************************************************/

/*
*
* File cl_device_API.h
* The interface between the device and the Open CL frame work.
*
*/
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "CL/cl.h"

// All device maximum working dimension
#define MAX_WORK_DIM		3

// ------------------------------------------------------------------------------
// Program container definition.
// Data types and structures
// ------------------------------------------------------------------------------
// Defines possible values for IR/binary types supported by the program container
typedef enum _cl_prog_binary_type
{
	CL_PROG_BIN_DASHER,				//	Containers holds Intel DASHER intermediate
	CL_PROG_BIN_LLVM,				//	Container holds Apple OCL LLVM intermediate
	CL_PROG_DLL_X86,				//	Container is a dynamically loaded library name
	CL_PROG_OBJ_X86,				//	Container holds x86 object code (.obj)
	CL_PROG_BIN_X86,				//	Container holds x86 binary code
	CL_PROG_BIN_PTX,				//	Container holds NVidia PTX intermediate
	CL_PROG_BIN_CUBIN				//	Container holds NVidia CUBIN binary
} cl_prog_binary_type;

// Defines possible values for containers types supported by the program container
typedef enum _cl_prog_container_type
{
	CL_PROG_CNT_PRIVATE,			//	Containers is private container and it’s structure is unknown
	CL_PROG_CNT_PROGRAM			//	Container holds OCL program container as defined by cl_prog_program
} cl_prog_container_type;


// Defines possible values for kernel argument types
typedef enum _cl_kernel_arg_type
{
	CL_KRNL_ARG_INT		= 0,	// Argument is a signed integer.
	CL_KRNL_ARG_UINT,			// Argument is an unsigned integer.
	CL_KRNL_ARG_FLOAT,			// Argument is a float.
	CL_KRNL_ARG_DOUBLE,			// Argument is a double.
	CL_KRNL_ARG_VECTOR,			// Argument is a vector of basic types, like int8, float4, etc.
	CL_KRNL_ARG_SAMPLER,		// Argument is a sampler object
	CL_KRNL_ARG_PTR_LOCAL,		// Argument is a pointer to array declared in local memory
	//	Memory object types bellow this line
	CL_KRNL_ARG_PTR_GLOBAL,		// Argument is a pointer to array in global memory of various types
								// The array type could be char, short, int, float or double
								// User must pass a handle to a memory buffer for this argument type
	CL_KRNL_ARG_PTR_CONST,		// Argument is a pointer to buffer declared in constant(global) memory
	CL_KRNL_ARG_PTR_IMG_2D,		// Argument is a pointer to 2D image
	CL_KRNL_ARG_PTR_IMG_3D		// Argument is a pointer to 3D image
} cl_kernel_arg_type;

// Defines possible values for kernel argument types
typedef struct _cl_kernel_argument
{
	cl_kernel_arg_type			type;			// Type of the argument.
	unsigned int				size_in_bytes;	// Size of the argument in bytes,
												// for pointer types the size is 0,
												// for vectors the high part indicates size of basic element in bytes
												//				the lower part indicates number of elements
} cl_kernel_argument;

// This structure defines a container description of binary
typedef struct _cl_prog_binary_desc
{
	cl_prog_binary_type	bin_type;		//	Binary/IR type that is held by a container
	cl_ushort			bin_ver_major;	//	Binary/IR major version identifier
	cl_ushort			bin_ver_minor;	//	Binary/IR minor version identifier
} cl_prog_binary_desc;

// This structure defines a single kernel container.
typedef struct _cl_prog_kernel
{
	const char*					name;			// A pointer to kernel name
	int							arg_count;		// A number of arguments to the kernel
	const cl_kernel_argument*	args;			// An array of kernel argument
	size_t						metadata_size;	// Size in bytes of the metadata generated by the back-end compiler.
	const void*					metadata;		// A pointer to buffer that holds metadata generated by the back-end compiler
	size_t						imp_local_size;	// Size in bytes of the implicitly defined local memory buffers
	size_t						bin_size;		// Size in bytes of kernel binary/IR representation
												// If 0, bin points to code segment
	const void*					bin;			// A pointer to kernel binary representation
} cl_prog_kernel;

// This structure defines a specific container for binaries or IR of OCL programs
typedef struct _cl_prog_program
{
	cl_uint			kernel_count;			// Number of kernels in a program
	cl_prog_kernel*	kernels;				// A pointer to list of cl_prog_kernel
} cl_prog_program;

// This structure defines a container that holds binaries or IR of OCL compiled programs
#define _CL_CONTAINER_MASK_		"CLPC"

typedef struct _cl_prog_container_header
{
	cl_char					mask[4];		// A container identifier mask must be "CLPC"
	cl_prog_binary_desc		description;	// Binary/IR description that is held by a container
	cl_prog_container_type	container_type;	// Type of container that stores program binary, as defined by cl_prog_container_type
	size_t					container_size; // Size in bytes of the container data
} cl_prog_container_header;

// ------------------------------------------------------------------------------
// Device API data types definition
// ------------------------------------------------------------------------------

// Command list handle definition
typedef void*	cl_dev_cmd_list;
typedef void*	cl_dev_cmd_id;
// Program handle definition
typedef void* cl_dev_program;
// Kernel handle definition
typedef void* cl_dev_kernel;
// Sub-device ID definition
typedef void* cl_dev_subdevice_id;

//Defines device return values that are used by the OCL framework.
typedef enum _cl_dev_err_code
{
	CL_DEV_SUCCESS				= 0,			// Function call or query call succeeded
	CL_DEV_ERROR_FAIL			= 0x80000000,	// Internal unspecified error
	CL_DEV_INVALID_VALUE,						// Invalid value was passed to the function.
	CL_DEV_INVALID_PROPERTIES,					// Properties might be valid but not supported
	CL_DEV_OUT_OF_MEMORY,						// Resource allocation failure
	CL_DEV_INVALID_COMMAND_LIST,				// Invalid command list handle
	CL_DEV_INVALID_COMMAND_TYPE,				// Invalid command type
	CL_DEV_INVALID_COMMAND_PARAM,				// Invalid command parameter
	CL_DEV_INVALID_MEM_OBJECT,					// Invalid memory object
	CL_DEV_INVALID_KERNEL,						// Invalid kernel identifier
	CL_DEV_INVALID_OPERATION,					// Device cannot perform requested operation
	CL_DEV_INVALID_WRK_DIM,						// Invalid work dimension (i.e. a value between 1 and 3)
	CL_DEV_INVALID_WG_SIZE,						// Invalid work-group size
	CL_DEV_INVALID_GLB_OFFSET,					// Invalid global offset, only (0, 0, 0) is supported
	CL_DEV_INVALID_WRK_ITEM_SIZE,				// Invalid work-item size
	CL_DEV_INVALID_IMG_FORMAT,					// Invalid image format
	CL_DEV_INVALID_IMG_SIZE,					// Width or height of the image are 0 or exceed maximum possible values
	CL_DEV_OBJECT_ALLOC_FAIL,					// Failed to allocate resources for memory object
	CL_DEV_INVALID_BINARY,						// The binary is not supported by the device or program container content is invalid
	CL_DEV_INVALID_BUILD_OPTIONS,				// One of more build options specified for the back-end compiler are invalid
	CL_DEV_INVALID_PROGRAM,						// Invalid program object handle 
	CL_DEV_BUILD_IN_PROGRESS,					// Back-end compiler is still in operation
	CL_DEV_BUILD_ALREADY_COMPLETE,				// Back-end compiler previously compiled this program
	CL_DEV_BUILD_ERROR,							// Error occurred during back-end build process
	CL_DEV_INVALID_KERNEL_NAME,					// Kernel name is not found in the program
	CL_DEV_OBJECT_ALREADY_LOCKED,				// Object already is locked
	CL_DEV_NOT_SUPPORTED						// The operation is not supported by the device
} cl_dev_err_code;

/**
* CL_FAILED
* Checks whether a return code is failure
*/
#define CL_DEV_FAILED(code)				((int)CL_DEV_SUCCESS > (int)(code))
#define CL_DEV_SUCCEEDED(code)			((int)CL_DEV_SUCCESS <= (int)(code))

//Defines possible values of device allocated buffer
typedef enum _cl_dev_mem_flags
{
	CL_DEV_MEM_READ			= 1,	// Buffer is accessible only for READ
	CL_DEV_MEM_WRITE		= 2,	// Buffer is accessible only for WRITE
	CL_DEV_MEM_READ_WRITE	= 3,	// Buffer is accessible for both READING and WRITING.
	CL_DEV_MEM_HOST_MEM		= 4		// Buffer should be allocated within host memory accessible by the device.
									// The buffer could be accessed by map commands. 
} cl_dev_mem_flags;

//Defines possible values of a host pointer provided for device memory object.
typedef enum _cl_dev_host_ptr_flags
{
	CL_DEV_HOST_PTR_NONE			= 0,		// The host buffer could be used internally by the agent.
	CL_DEV_HOST_PTR_DATA_AVAIL		= 1,		// The HOST pointer contains initial data for the memory object.
	CL_DEV_HOST_PTR_MAPPED_REGION	= 2			// The host pointer defines a region wherein map operation must be completed.
} cl_dev_host_ptr_flags;

//Defines possible values of device list properties
typedef enum _cl_dev_cmd_list_props
{
	CL_DEV_LIST_NONE       = 0, // Determines a list wherein all items will be executed sequentially.
	CL_DEV_LIST_ENABLE_OOO = 1,	// Determines whether the out-of-order optimization could be applied on items in the command list
    CL_DEV_LIST_SUBDEVICE  = 2  // Determines whether the command list executes on a root-level device or on a sub-device
} cl_dev_cmd_list_props;

//Defines possible values of device command identifiers that is passed within cl_dev_cmd_desc structure.
typedef enum _cl_dev_cmd_type
{
	CL_DEV_CMD_READ = 0,			//Read buffer command
	CL_DEV_CMD_WRITE,				//Write buffer command
	CL_DEV_CMD_COPY,				//Copy buffer command
	CL_DEV_CMD_MAP,					//Map Command
	CL_DEV_CMD_UNMAP,				//UnMap command
	CL_DEV_CMD_EXEC_KERNEL,			//Execute Kernel Command
	CL_DEV_CMD_EXEC_TASK,			//Execute task command
	CL_DEV_CMD_EXEC_NATIVE,			//Execute native kernel command
	//--------------------
	CL_DEV_CMD_MAX_COMMAND_TYPE
} cl_dev_cmd_type;

//Defines possible values of mapped region of a memory object.
typedef enum _cl_dev_map_flags
{
	CL_DEV_MAP_READ			= 1,			//The mapped region is READ only.
	CL_DEV_MAP_WRITE		= 2,			//The mapped region is WRITE only.
	CL_DEV_MAP_READ_WRITE	= 3				//The mapped region is accessible for both reading and writing.
} cl_dev_map_flags;

//Defines possible values of memory object types.
typedef enum _cl_dev_mem_object_type
{
	CL_DEV_MEM_OBJECT_IMAGE2D = 1,	//The memory object is 2D image.
	CL_DEV_MEM_OBJECT_IMAGE3D,		//The memory object is 3D image.
	CL_DEV_MEM_OBJECT_BUFFER		//The memory object is 1D buffer.
} cl_dev_mem_object_type;

// Defines possible values of binary that is passed to clDevBuildProgram function.
typedef enum _cl_dev_binary_prop
{
	CL_DEV_BINARY_COMPILER = 1,		// The origin of binary is one of the Front-End compilers
	CL_DEV_BINARY_USER				// The origin of binary is a binary loaded by user
} cl_dev_binary_prop;

// Defines possible values of the kernel information that could be retrieved by clDevGetKernelInfo function.
typedef enum _cl_dev_kernel_info
{
	CL_DEV_KERNEL_NAME					= 1,	// Specifies NULL terminated function name.
	CL_DEV_KERNEL_PROTOTYPE,					// Specifies list of kernel arguments (prototype)
												// as defined by cl_kernel_arg_type.
	CL_DEV_KERNEL_MAX_WG_SIZE,					// Returns the maximum work-group size that can be used to execute
												// a kernel. The device agent uses resource requirements
												// of the kernel to determine optimal work-group size.
	CL_DEV_KERNEL_WG_SIZE,						// Returns the work-group size that can be used to execute
												// a kernel. The device agent uses resource requirements
												// of the kernel to determine optimal work-group size.
	CL_DEV_KERNEL_WG_SIZE_REQUIRED,				// Specifies the required work-group size as was declared during
												// kernel compilation.
	CL_DEV_KERNEL_IMPLICIT_LOCAL_SIZE,			// Specifies size of implicit local memory buffers defined in kernel.
	CL_DEV_KERNEL_PRIVATE_SIZE					// Specifies size of private memory required for
												// execution of singe instance of a kernel
} cl_dev_kernel_info;

typedef enum _cl_dev_sampler_prop
{
    __ADDRESS_BASE								= 0,
    CL_DEV_SAMPLER_ADDRESS_NONE					= 0,
    CL_DEV_SAMPLER_ADDRESS_CLAMP				= 1 << __ADDRESS_BASE ,
    CL_DEV_SAMPLER_ADDRESS_CLAMP_TO_EDGE		= 2 << __ADDRESS_BASE,
    CL_DEV_SAMPLER_ADDRESS_REPEAT				= 3 << __ADDRESS_BASE,
	CL_DEV_SAMPLER_ADDRESS_MIRRORED_REPEAT		= 4 << __ADDRESS_BASE,
    __ADDRESS_BITS								= 3,        // number of bits required to represent address info
    __ADDRESS_MASK								= ( (1<<__ADDRESS_BITS) -1),

    __NORMALIZED_BASE							= __ADDRESS_BITS,
    CL_DEV_SAMPLER_NORMALIZED_COORDS_FALSE		= 0,
    CL_DEV_SAMPLER_NORMALIZED_COORDS_TRUE		= 1 << __NORMALIZED_BASE,
    __NORMALIZED_BITS							=	1,        // number of bits required to represent normalization 
    __NORMALIZED_MASK							= ( ((1<<__NORMALIZED_BITS)-1) << __NORMALIZED_BASE ),

    __FILTER_BASE								= __NORMALIZED_BASE + __NORMALIZED_BITS,
    CL_DEV_SAMPLER_FILTER_NEAREST				= 0 << __FILTER_BASE,
    CL_DEV_SAMPLER_FILTER_LINEAR				= 1 << __FILTER_BASE,
    __FILTER_BITS					            = 2,        // number of bits required to represent address info
    __FILTER_MASK								= ( ((1<<__FILTER_BITS)-1) << __FILTER_BASE)

} cl_dev_sampler_prop;

//A list of possible device partitioning properties. Reflects the list in the Device Fission extension. Not all are supported
typedef enum _cl_dev_partition_prop
{
    CL_DEV_PARTITION_EQUALLY = 1,
    CL_DEV_PARTITION_BY_COUNTS,
    CL_DEV_PARTITION_BY_NAMES,
    CL_DEV_PARTITION_AFFINITY_L1,
    CL_DEV_PARTITION_AFFINITY_L2,
    CL_DEV_PARTITION_AFFINITY_L3,
    CL_DEV_PARTITION_AFFINITY_L4,
    CL_DEV_PARTITION_AFFINITY_NUMA,
    CL_DEV_PARTITION_AFFINITY_NEXT
} cl_dev_partition_prop;

// ------------------------------------------------------------------------------
// Device API data structure definition
// ------------------------------------------------------------------------------

//This structure holds a description of a command that is passed to the device for execution.
typedef struct _cl_dev_cmd_desc
{
	cl_dev_cmd_type	type;				// Command type identifier, defined in cl_dev_cmd_type
	cl_dev_cmd_id	id;					// Framework provided command identifier. It will be used
										// during command completion notification in clDevCmdStatusChanged()
	void*			data;				// A Pointer to user specific information It will be used
										// during command completion notification in clDevCmdStatusChanged()
	void*			params;				// Pointer to a buffer that holds command specific parameters
	size_t			param_size;			// Size of the parameter buffer in bytes
	bool			profiling;			// Enable profiling data for this command
} cl_dev_cmd_desc;

// This structure describes a handle of device memory object
typedef struct _cl_dev_mem
{
	cl_uint	allocId;					// Identifier of the allocator that has allocated the memory object.
										// When memory object is allocated by device, the value is device id.
	void*	objHandle;					// Handle of the allocated memory object.
} *cl_dev_mem;

//This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_READ and CL_DEV_CMD_WRITE identifiers.
typedef struct _cl_dev_cmd_param_rw
{
	cl_dev_mem		memObj;					// Handle to a memory object from where/to the data to be read/written.
											// It can be a buffer, image2D or image3D
	cl_uint			dim_count;				// A number of dimensions in the memory object.
	size_t			origin[MAX_WORK_DIM];	// Multi-dimensional offset in the memory object. 
											// For 2Dimages origin[2] must be 0.
	size_t			region[MAX_WORK_DIM];	// Defines multi-dimensional region of the memory object to be used. 
											// region[0] is width of region,
											// region[1] is height of the region,
											// region[2] is depth of the region.
	size_t			memobj_pitch[MAX_WORK_DIM-1];	// A pointer to array of dimension pitches in bytes for the mapped region. The size of the array is dim_count-1.
											// memobj_pitch[0] will contain the scan-line pitch in bytes for the mapped region,
											// memobj_pitch[1] will contain the size in bytes of each 2D slice for the mapped region.
	void*			ptr;					// Pointer to the host memory where the data to be read/written
	size_t			pitch[MAX_WORK_DIM-1];	// A pointer to array of dimension pitches in bytes for the pointer parameter. The size of the array is dim_count-1.
											// pitch[0] will contain the scan-line pitch in bytes for the mapped region,
											// pitch[1] will contain the size in bytes of each 2D slice for the mapped region.									
	size_t			ptr_origin[MAX_WORK_DIM]; // Multi-dimensional offset in the ptr.	
} cl_dev_cmd_param_rw;

// This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_COPY identifier.
typedef struct _cl_dev_cmd_param_copy
{
	cl_dev_mem		srcMemObj;					// Handle to a source memory object from where the data to be read.
	cl_dev_mem		dstMemObj;					// Handle to a source memory object to where the data to be written.
	cl_uint			src_dim_count;				// A number of dimensions in the source memory object.
	cl_uint			dst_dim_count;				// A number of dimensions in the destination memory object.
	size_t			src_origin[MAX_WORK_DIM];	// Multi-dimensional offset in the source memory object.
	size_t			dst_origin[MAX_WORK_DIM];	// Multi-dimensional offset in the destination memory object.
	size_t			region[MAX_WORK_DIM];		// Defines multi-dimensional region of the memory object to be copied. 
												//	region[0] is width of region,
												//	region[1] is height of the region,
												//	region[2] is depth of the region.
	size_t			src_pitch[MAX_WORK_DIM-1];	// src memory object pitch, non-relevant pitch values are filled with zero
	size_t			dst_pitch[MAX_WORK_DIM-1];	// dst memory object pitch, non-relevant pitch values are filled with zero

} cl_dev_cmd_param_copy;

// This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_MAP identifier.
typedef struct	_cl_dev_cmd_param_map
{
	cl_dev_mem			memObj;					// Handle to a memory object to be mapped
	void*				ptr;					// A pointer to mapped region associated with the map command.
	cl_dev_map_flags	flags;					// A bit-field is set to indicate how the mapped region will be used.
												// The values are defined by cl_dev_map_flags.
	cl_uint				dim_count;				// A number of dimensions in the mapped memory object.
	size_t				origin[MAX_WORK_DIM];	// Multi-dimensional offset in the memory object to mapped.
	size_t				region[MAX_WORK_DIM];	// Defines multi-dimensional region of the memory object to be mapped. 
												// region[0] is width of region,
												// region[1] is height of the region,
												// region[2] is depth of the region.
	size_t				pitch[MAX_WORK_DIM-1];	// A pointer to array of dimension pitches in bytes for the mapped region. The size of the array is dim_count-1.
												// pitch[0] will contain the scan-line pitch in bytes for the mapped region,
												// picth[1] will contain the size in bytes of each 2D slice for the mapped region.
} cl_dev_cmd_param_map;

//This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_KERNEL and CL_DEV_CMD_TASK identifiers.
typedef struct	_cl_dev_cmd_param_kernel
{
	cl_dev_kernel		kernel; 					// Handle to a kernel object to be executed
	cl_uint				work_dim;					// The number of dimensions used to specify the global work-items and work-items in the work-group.
													// Work_dim must be greater than 0 and less than or equal to 3.
													// When executing a task, this value must be equal to 1.
	size_t				glb_wrk_offs[MAX_WORK_DIM];	// Currently must be (0, 0, 0). In a future revision of OpenCL,
													// glb_work_offs can be used to specify an array of work_dim unsigned
													// values that describe the offset used to calculate the global ID of a work-item.
	size_t				glb_wrk_size[MAX_WORK_DIM];	// An array of work_dim unsigned values that describe the number of global work-items
													// in work_dim dimensions that will execute the kernel function. The total number of
													// global work-items is computed as glb_wrk_size[0] * … *glb_wrk_size[work_dim – 1].
													// When executing a task, this value must be equal to 1.
	size_t				lcl_wrk_size[MAX_WORK_DIM];	// An array of work_dim unsigned values that describe the number of work-items
													// that make up a work-group (also referred to as the size of the work-group)
													// that will execute the kernel specified by kernel. The total number of work-items in a work-group
													// is computed as lcl_wrk_size[0] * … * lcl_wrk_size[work_dim – 1].
													// When executing a task, this value must be equal to 1. When the values are 0, and hint or required
													// work-group size is defined for the kernel, the agent will use these values for execution.
													// When the values are 0, and neither hint nor required work-group sizes is not defined,
													// the agent will use optimal work-group size.
	const void*			arg_values;					// An array of argument values of the specific kernel.
													// An order of the values must be the same as the order of parameters in the kernel prototype.
													// If an argument is a memory object, a relevant value contains its handle (dev_mem_obj).
	size_t				arg_size;					// Size in bytes of the arg_values array.
} cl_dev_cmd_param_kernel;


typedef void (*pUserFnc_t)(void *);
//This structure holds a value of parameters which are passed within cl_dev_cmd_desc and associated with CL_DEV_CMD_NATIVE identifier.
typedef struct _cl_dev_cmd_param_native
{
	pUserFnc_t        func_ptr;			// A pointer to a host callable user function.
	size_t			args;				// The size in bytes of the argument list that argv points to.
	void*			argv;				// A pointer to the args list that user function should be called with. Some items contain handles to device memory objects. Before the user function is executed, the memory object handles are replaced by pointers to global memory.
	cl_uint			mem_num;			// The number of buffer objects that are passed in argv. These values will be updated by the device agent.
	void**			mem_loc;			// An offset to appropriate locations that argv points to where memory object handles (cl_dev_mem values) are stored.
} cl_dev_cmd_param_native;

// ------------------------------------------------------------------------------
// Device API functions definition
// ------------------------------------------------------------------------------

#define IN

#define OUT

#define INOUT

class IOCLFrameworkCallbacks;
class IOCLDevLogDescriptor;
class IOCLDevice;

//
//Device Initialization functions
//
/* clDevInitDevice
   Description
		Initialize internal state of the device driver, returns a set of device driver entry points. 
   Input 
		dev_id			Device identifier as it appears in framework. This value is used in cl_dev_mem object identification.
		pDevCallBacks	A pointer to an interface for callback functions provided to the device by the framework
		pLogDesc		A pointer to an interface for logger functions provided to the device by the framework
   Output 
		pDevice			A pointer to an interface to the device 
   Returns
		CL_DEV_SUCCESS		The device was successfully created. pDevEntry holds updated pointers
		CL_DEV_ERROR_FAIL	Internal error
*/
cl_dev_err_code (clDevCreateDeviceInstance)(
                        cl_uint		dev_id,
						IOCLFrameworkCallbacks	*pDevCallBacks,
						IOCLDevLogDescriptor	*pLogDesc,
						IOCLDevice*				*pDevice
						);

typedef cl_dev_err_code (fn_clDevCreateDeviceInstance)(
								   cl_uint		dev_id,
								   IOCLFrameworkCallbacks	*pDevCallBacks,
								   IOCLDevLogDescriptor		*pLogDesc,
								   IOCLDevice*				*pDevice
								   );

/************************************************************************************************************************
   clDevGetDeviceInfo
	Description
		This function return device specific information defined by cl_device_info enumeration as specified in OCL spec. table 4.3.
	Input
		param					An enumeration that identifies the device information being queried. It can be one of
								the following values as specified in OCL spec. table 4.3
		valSize				Specifies the size in bytes of memory pointed to by paramValue. This size in
								bytes must be >= size of return type
	Output
		paramVal				A pointer to memory location where appropriate values for a given param as specified in OCL spec. table 4.3 will be returned. If paramVal is NULL, it is ignored
		paramValSize_ret		Returns the actual size in bytes of data being queried by paramVal. If paramValSize_ret is NULL, it is ignored
	Returns
		CL_DEV_SUCCESS			If functions is executed successfully.
		CL_DEV_INVALID_VALUE	If param_name is not one of the supported values or if size in bytes specified by paramValSize is < size of return type as specified in OCL spec. table 4.3 and paramVal is not a NULL value
**************************************************************************************************************************/
cl_dev_err_code clDevGetDeviceInfo(  cl_device_info  IN  param, 
                            size_t          IN  valSize, 
                            void*           OUT paramVal,
				            size_t*         OUT paramValSizeRet
                            );

typedef cl_dev_err_code (fn_clDevGetDeviceInfo)(
                        cl_device_info  IN  param, 
                        size_t          IN  valSize, 
                        void*           OUT paramVal,
                        size_t*         OUT paramValSizeRet						
						);

//
//Device Callback interface prototype
//
class IOCLFrameworkCallbacks
{
public:
/* clDevCmdStatusChanged
	Description
		This function is called when previously enqueued command changes its state to RUNNING or COMPLETED. 
	Input
		cmd_id				Identifier of the enqueued command that changes its status
		data				A pointer to buffer that was passed within cl_dev_cmd_desc within clDevCommandListExecute().
		cmd_status			New command status
		completion_result	Indicates completion result. CL_DEV_SUCCESS the command was successfully completed.
							CL_DEV_ERROR_FAILED indicated that command completed with an error.
		timer				Time in nano seconds of the device timer when the status changed occurred,
							available only when profiling is enabled.
	Output
		None
	Returns
		None
*/
	virtual void clDevCmdStatusChanged(	cl_dev_cmd_id	IN cmd_id,
											void*			IN	data,
											cl_int			IN cmd_status,
											cl_int			IN completion_result,
											cl_ulong		IN timer
											) = 0;

/* clDevBuildStatusUpdate
	Description
		This function is called during build process of the specific program. Currently this function
		is called when program build is finished.
	Input
		prog			Identifier of the notified program. That was returned with clDevBuildProgram().
		data			A pointer to buffer that was passed to clDevBuildProgram().
		status			An updated status of build process
*/

	virtual void clDevBuildStatusUpdate( cl_dev_program	IN prog,
										  void*			IN data,
										  cl_build_status IN status
										) = 0;

};


class IOCLDevice
{
public:
	//
	// Command List function prototypes
	//
	/* clDevPartition
		Description
			This function partitions the device into sub-devices allowing execution on parts of a device's compute units.
		Input
			props						The desired partitioning criterion
            num_subdevices              The number of sub-devices to be generated if using CL_DEV_PARTITION_BY_COUNTS or BY_NAMES
            param                       An optional param: the partition size in case of PARTITION_EQUALLY, the count list if BY_COUNTS, the name list if BY_NAMES etc
		Output
            num_subdevices              The number of sub-devices to be generated if partitioning equally or by affinity
			cl_dev_subdevice_id 		A list of ids, one for each partition created
		Returns
			CL_DEV_SUCCESS				The command queue successfully created
			CL_DEV_INVALID_VALUE		If values specified in properties are not valid, num_subdevices is NULL, *num_subdevices is > 0 but subdevice_ids is NULL
			CL_DEV_INVALID_PROPERTIES	If values specified in properties are valid but are not supported by the device
			CL_DEV_OUT_OF_MEMORY		If there is a failure to allocate resources required by the OCL device driver
	*/
    virtual cl_dev_err_code (clDevPartition)(  cl_dev_partition_prop IN     props, 
                                               cl_uint*              INOUT  num_subdevices, 
                                               void*                 IN     param,
                                               cl_dev_subdevice_id*  OUT    subdevice_ids
                                            ) = 0;

	/* clDevReleaseSubdevice
		Description
			This function releases the resources associated with the given sub-device ID. 
            Behaviour is undefined if command lists still exist that reference that sub-device. 
            It is the framework's responsibility to ensure this is not called prematurely. 
		Input
			subdevice_id				The sub-device to release
		Returns
			CL_DEV_SUCCESS				The command queue successfully created
			CL_DEV_INVALID_VALUE		If the subdevice_id is invalid
	*/
    virtual cl_dev_err_code (clDevReleaseSubdevice)(  cl_dev_subdevice_id IN subdevice_id
                                                   ) = 0;


	/* clDevCreateCommandList
		Description
			This function creates a command list on a device. This function performs an implicit retain of the command list.
		Input
			props						Determines whether the out-of-order optimization could be applied on items in the command list.
            subdevice_id                0 if creating a command list for a root-level device, or a sub-device ID returned from clDevPartitionDevice
		Output
			list						A valid (non zero) handle to device command list.
		Returns
			CL_DEV_SUCCESS				The command queue successfully created
			CL_DEV_INVALID_VALUE		If values specified in properties are not valid or subdevice_id is not a valid sub-device ID
			CL_DEV_INVALID_PROPERTIES	If values specified in properties are valid but are not supported by the device
			CL_DEV_OUT_OF_MEMORY		If there is a failure to allocate resources required by the OCL device driver
	*/
	virtual cl_dev_err_code (clDevCreateCommandList)(	cl_dev_cmd_list_props IN props,
                                                        cl_dev_subdevice_id   IN subdevice_id,
										   cl_dev_cmd_list* OUT list
										   ) = 0;

	/* clDevFlushCommandList
		Description
			This function flushes the content of a list, all waiting commands are sent to execution.
		Input
			list						A valid handle to device command list
		Output
			None
		Returns
			CL_DEV_SUCCESS				The function is executed successfully
			CL_DEV_INVALID_COMMAND_LIST	If command list is not a valid command list
	*/
	virtual cl_dev_err_code (clDevFlushCommandList)(	cl_dev_cmd_list IN list
										  ) = 0;

	/* clDevRetainCommandList
		Description
			Increments the command list reference count. 
		Input
			list						A valid handle to device command list
		Output
			None
		Returns
			CL_DEV_SUCCESS				The function is executed successfully
			CL_DEV_INVALID_COMMAND_LIST	If command list is not a valid command list
	*/
	virtual cl_dev_err_code (clDevRetainCommandList)(	cl_dev_cmd_list IN list
											) = 0;

	/* clDevReleaseCommandList
		Description
			Decrements the command list reference count. After the command list reference count becomes zero and
			all commands of the command list have completed (eg. Kernel executions, memory object updates etc.),
			the command queue is deleted. 
		Input
			list						A valid handle to device command list
		Output
			None
		Returns
			CL_DEV_SUCCESS				The function is executed successfully
			CL_DEV_INVALID_COMMAND_LIST	If command list is not a valid command list
	*/
	virtual cl_dev_err_code (clDevReleaseCommandList)( cl_dev_cmd_list IN list
											 ) = 0;

	/* clDevCommandListExecute
		Description
			Passes a list of dependent commands into a specified command list for execution.
			If the list was created without OOO optimizations the commands are depended by the list index: item[n] depends on item[n-1].
			First item (item[0]) is dependent on the last item that was passed within previous  call for the same list identifier.
		Input
			list							A valid handle to device command list, where to add list of commands. If value is NULL,
											the new independent list is created for given commands
			cmds							A pointer to a vector of command list to execute, each entry contains a pointer to cl_dev_cmd_desc structure
			count							Number of entries in cmds parameter
		Output
			None
		 Returns
			CL_DEV_SUCCESS					The function is executed successfully.
			CL_DEV_INVALID_COMMAND_LIST		If command list is not a valid command list
			CL_DEV_INVALID_COMMAND_TYPE		If command type specified in one of the cmds entries is not a valid command.
			CL_DEV_INVALID_MEM_OBJECT		If one or more memory objects specified in parameters in one or more of cmds entries
											are not valid or are not buffer objects.
			CL_DEV_INVALID_KERNEL			If kernel identifier specified in execution parameters is not valid.
			CL_DEV_INVALID_OPERATION		If specific device can’t execute native kernel.
			CL_DEV_OUT_OF_RESOURCES			Is a failure to queue the execution instance of kernel because of insufficient resources
											needed to execute the kernel.
			CL_DEV_INVALID_WRK_DIM			If work_dim is not a valid value (i.e. a value between 1 and 3).
			CL_DEV_INVALID_WG_SIZE			If lcl_wrk_size is specified and number of workitems specified by glb_wrk_size is
											not evenly divisable by size of work-group given by lcl_wrk_size or does not match
											the work-group size specified for kernel using the __attribute__((reqd_work_group_size(X, Y, Z)))
											qualifier in program source.
			CL_DEV_INVALID_GLB_OFFSET		If glb_wrk_offset is not (0, 0, 0).
			CL_DEV_INVALID_WRK_ITEM_SIZE	If the number of work-items specified in any of lcl_wrk_size[] is greater than the corresponding
											values specified by CL_DEVICE_MAX_WORK_ITEM_SIZES[]
	*/
	virtual cl_dev_err_code (clDevCommandListExecute)( cl_dev_cmd_list IN list,
												 cl_dev_cmd_desc* IN *cmds,
												 cl_uint IN count
												 ) = 0;

	/* clDevCommandListWaitCompletion
		Description
			Add the calling thread to execution pool and wait for all submitted commands to completed.
		Input
			list							A valid handle to device command list, where to add list of commands. If value is NULL,
											the new independent list is created for given commands
		Output
			None
		 Returns
			CL_DEV_SUCCESS					The function is executed successfully, all commands are completed
			CL_DEV_INVALID_COMMAND_LIST		If command list is not a valid command list
			CL_DEV_NOT_SUPPORTED			The operation is not supported by device. The runtime should handle wait by itself
	*/
	virtual cl_dev_err_code (clDevCommandListWaitCompletion)( cl_dev_cmd_list IN list
												 ) = 0;

	//
	// Memory Object function prototypes
	//
	/* clDevGetSupportedImageFormats
		Description
			This function returns the list of image formats supported by an OCL implementation when the information about
			an image memory object is specified and device supports image objects.
		Input
			flags					A bit-field that is used to specify allocation and usage information such as the memory arena
									that should be used to allocate the image object and how it will be used.
			image_type				Describes the image type as described in (cl_dev_mem_object_type).Only image formats are supported.
			num_entries				Specifies the number of entries that can be returned in the memory location given by formats.
									If value is 0 and formats is NULL, the num_entries_ret returns actual number of supported formats.
		Output
			formats					A pointer to array of structures that describes format properties of the image to be allocated.
									Refer to OCL spec section 5.2.4.1 for a detailed description of the image format descriptor.
			num_entries_ret			The actual number of supported image formats for a specific context and values specified by flags.
									If the value is NULL, it is ignored.
		 Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_VALUE	If values specified in parameters is not valid or if num_entries is 0 and formats is not NULL.
	*/
	virtual cl_dev_err_code (clDevGetSupportedImageFormats)( cl_dev_mem_flags IN flags,
									   cl_dev_mem_object_type IN image_type,
									   cl_uint IN num_entries,
									   cl_image_format* OUT formats,
									   cl_uint* OUT num_entries_ret
									   ) = 0;
	/* clDevCreateMemoryObject
		Description
			This function creates a reference and allocates resources required by different memory objects, like buffer,
			2D image and new 3D image. It’s not mandatory that actual physical memory will be allocated.
		Input
			flags			A bit-field that is used to specify allocation and usage information such as the memory arena
							that should be used to allocate the image object and how it will be used.
			format			A pointer to a structure that describes format properties of the image to be allocated.
							Refer to OCL spec section 5.2.4.1 for a detailed description of the image format descriptor.
							When creating buffers this parameter must be NULL.
			dim_count		A number of dimensions in the required memory object.
			dim_size		A pointer to a buffer that defines object dimentions.
							When creating a buffer, dim points size of the buffer in bytes.
							dim[0] specifies width of the image in pixel, 
							dim[1] specifies height of the image in pixel,
							dim[2] specifies depth of the image in pixel,
							dim[dim_count-1] specefies size of the dim_count dimension.
							All values must be greater or equal to 1.
			buffer_ptr		A pointer to memory buffer that will be used for object data storage.
							When the value is not NULL, no additional host memory will be allocated
							and provided pointer will be used for data storage.
							In some case the data will be cached on the device itself.
			pitch			A pointer to array of dimension pitches in bytes for the mapped region.
							The size of the array is dim_count-1.
								pitch[0] will contain the scan-line pitch in bytes of the mapped region,
								picth[1] will contain the size in bytes of each 2D slice of the mapped region.
								The NULL value is valid only for 1D buffers.
			host_flags		A set of flags specify the properties of the given host pointer. When CL_DEV_HOST_PTR_NONE,
							this pointer could be used by the agent to store actual buffer data.
		Output
			memObj			A valid (non zero) handle to allocated recourses of the memory object.
		Returns
			CL_DEV_SUCCESS					The function is executed successfully.
			CL_DEV_INVALID_VALUE			If values specified in properties are not valid.
			CL_DEV_INVALID_IMG_FORMAT		If values specified in format are not valid or if it is NULL and width or height not equal 1.
			CL_DEV_INVALID_IMG_SIZE			If width or height are 0 or if they exceed maximum possible values.
			CL_DEV_IMG_FORMAT_NOT_SUPPORTED	If the format is not supported.
			CL_DEV_OBJECT_ALLOC_FAIL		If there is a failure to allocate resources for memory object.
			CL_DEV_INVALID_OPERATION		If the device does not support images.
	*/
	virtual cl_dev_err_code (clDevCreateMemoryObject)( cl_dev_mem_flags	IN flags,
									const cl_image_format*			IN format,
									cl_uint							IN dim_count,
									const size_t*					IN dim_size,
									void*							IN buffer_ptr,
									const size_t*					IN pitch,
									cl_dev_host_ptr_flags			IN host_flags,
									cl_dev_mem*						OUT memObj
									) = 0;

	/* clDevDeleteMemoryObject
		Description
			This function deletes previously created memory object.
		Input
			memObj						A valid handle to memory object
		Output
			NONE
		Returns
			CL_DEV_SUCCESS				The function is executed successfully.
			CL_DEV_INVALID_MEM_OBJECT	If memObj is not a valid memory object.
			CL_DEV_INVALID_OPERATION	If memObj has one or mapped regions.
	*/
	virtual cl_dev_err_code (clDevDeleteMemoryObject)( cl_dev_mem IN memObj
												 ) = 0;
	/* clDevCreateMappedRegion
		Description
			Creates host mapped memory region for further buffer map operation.
		Input/Output
			pMapParams					A valid pointer to descriptor of memory mapped region.
										Input:
										memObj	- Valid memory object handle,
										flags	- Bitset of flags of mapped region,
										offset	- Mapped region offset,
										region	- Mapped region size.
										Output:
										ptr		- Pointer to the mapped region,
										pitch	- pitches in bytes for the mapped region. The size of the array is dim_count-1,
													pitch[0] will contain the scan-line pitch in bytes for the mapped region,
													picth[1] will contain the size in bytes of each 2D slice for the mapped region.

		Returns
			CL_DEV_SUCCESS				The function is executed successfully.
			CL_DEV_INVALID_MEM_OBJECT	If memObj is not a valid memory object.
			CL_INVALID_VALUE			If region being mapped given by (origin, origin+region) is out of bounds.
										If object is a buffer and origin[1] or origin[2] are not equal to 0, or region[1]  or region[2] are not equal to 1.
										If object is a 2D image and origin[2] is not equal to 0 or region[2] is not equal to 1.
										If object is a 2D or 3D image and row_pitch is NULL.
										If image is a 3D image object and slice_pitch is NULL
	*/
	virtual cl_dev_err_code (clDevCreateMappedRegion)( cl_dev_cmd_param_map*	INOUT	pMapParams
												 ) = 0;

	/* clDevReleaseMappedRegion
		Description
			Releases previously created host mapped memory region.
		Input
			pMapParams					A valid pointer to descriptor of memory mapped region.
		Output
			NONE
		Returns
			CL_DEV_SUCCESS				The function is executed successfully.
			CL_DEV_INVALID_MEM_OBJECT	If memObj is not a valid memory object.
			CL_INVALID_VALUE			If mapped memory pointer is not associated with memory object.
	*/
	virtual cl_dev_err_code (clDevReleaseMappedRegion)( cl_dev_cmd_param_map*	IN	pMapParams
												  ) = 0;

	//
	// Program build function prototypes
	//

	/* clDevCheckProgramBinary
		Description
			Performs syntax validation of the intermediate or binary to be built by the device during later stages.
		Input
			bin_size				Size of the binary buffer
			bin						A pointer to binary buffer that holds program container defined by cl_prog_container.
		Output
			NONE
		Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_VALUE	If bin_size is 0 or bin is NULL.
			CL_DEV_INVALID_BINARY	If the binary is not supported by the device or program container content is invalid.
	*/
	virtual cl_dev_err_code (clDevCheckProgramBinary)( size_t IN bin_size,
												 const void* IN bin
												 ) = 0;

	/* clDevCreateProgram
		Description
			Creates a device specific program entity (no build is performed).
		Input
			bin_size						Size of the binary buffer
			bin								A pointer to binary buffer that holds program container defined by cl_prog_container. 
			prop							Specifies the origin of the input binary. The values is defined by cl_dev_binary_prop.
		Output
			prog							A valid (non zero) handle to created program object.
		Returns
			CL_DEV_SUCCESS					The function is executed successfully.
			CL_DEV_INVALID_BINARY			If the back-end compiler failed to process binary.
			CL_DEV_OUT_OF_MEMORY			If the device failed to allocate memory for the program.
	*/
	virtual cl_dev_err_code (clDevCreateProgram)( size_t IN bin_size,
										   const void* IN bin,
										   cl_dev_binary_prop IN prop,
										   cl_dev_program* OUT prog
										   ) = 0;

	/* clDevBuildProgram
		Description
			Builds (compiles & links) a program executable from the program intermediate or binary.
		Input
			prog							Program handle to be built
			options							A pointer to a string that describes the build options to be used for building the program executable.
											The list of supported options is described in section 5.4.3 in OCL spec. document.
			user_data						This value will be passed as an argument when clDevBuildFinished is called. Can be NULL.
		Returns
			CL_DEV_SUCCESS					The function is executed successfully.
			CL_DEV_INVALID_BUILD_OPTIONS	If build options for back-end compiler specified by options are invalid.
			CL_DEV_INVALID_BINARY			If the back-end compiler failed to process binary.
			CL_DEV_OUT_OF_MEMORY			If the device failed to allocate memory for the program.
	*/
	virtual cl_dev_err_code (clDevBuildProgram)( cl_dev_program IN prog,
										   const char* IN options,
										   void* IN user_data								   
										   ) = 0;

	/* clDevReleaseProgram
		Description
			Deletes previously created program object and releases all related resources.
		Input
			prog							A handle to program object to be deleted
		Output
			NONE
		Returns
			CL_DEV_SUCCESS					The function is executed successfully.
			CL_DEV_INVALID_PROGRAM			Invalid program object was specified.
	*/
	virtual cl_dev_err_code (clDevReleaseProgram)(cl_dev_program IN prog) = 0;

	/* clDevUnloadCompiler
		Description
			Allows the framework to release the resources allocated by the back-end compiler.
			This is a hint from the framework and does not guarantee that the compiler will not be used in the future
			or that the compiler will actually be unloaded by the device.
		Input
			NONE
		Output
			NONE
		Returns
			CL_DEV_SUCCESS	The function is executed successfully.
	*/
	virtual cl_dev_err_code (clDevUnloadCompiler)() = 0;

	/* clDevGetProgramBinary
		Description
			Returns the compiled program binary. The output buffer contains program container as defined cl_prog_binary_desc.
		Input
			prog					A handle to created program object.
			size					Size in bytes of the buffer passed to the function. 
		Output
			binary					A pointer to buffer wherein program binary will be stored.
			size_ret				The actual size in bytes of the returned buffer. When size is equal to 0 and binary is NULL, returns size in bytes of a program binary. If NULL the parameter is ignored.
		Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
			CL_DEV_INVALID_VALUE	If size is not enough to store the binary or binary is NULL and size is not 0.
	*/
	virtual cl_dev_err_code (clDevGetProgramBinary)( cl_dev_program IN prog,
											 size_t	IN size,
											 void* OUT binary,
											 size_t* OUT size_ret
											 ) = 0;
	/* clDevGetBuildLog
		Description
			Returns the build log after clDevBuildProgram was called and finished.
		Input
			prog					A handle to created program object.
			size					Size in bytes of the buffer passed to the function. 
		Output
			log						A pointer to buffer wherein program build log will be stored.
			size_ret				The actual size in bytes of the returned buffer. When size is equal to 0 and binary is NULL,
									returns size in bytes of the log. If NULL the parameter is ignored.
		Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
			CL_DEV_INVALID_VALUE	If size is not enough to store the binary or binary is NULL and size is not 0.
			CL_DEV_STILL_BUILDING	If program is under build process.
	*/
	virtual cl_dev_err_code (clDevGetBuildLog)( cl_dev_program IN prog,
										  size_t IN size,
										  char* OUT log,
										  size_t* OUT size_ret
										  ) = 0;

	/* clDevGetSupportedBinaries (optional)
		Description
			Returns the list of supported binaries.
		Input
			count					Size of the buffer passed to the function in terms of cl_prog_binary_desc. 
		Output
			types					A pointer to buffer wherein binary types will be stored.
			count_ret				The actual size ofthe buffer returned by the function in terms of cl_prog_binary_desc.
									When count is equal to 0 and types is NULL, function returns a size of the list.
									If NULL the parameter is ignored.
		Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
			CL_DEV_INVALID_VALUE	If count is not enough to store the binary or types is NULL and count is not 0.
	*/
	virtual cl_dev_err_code (clDevGetSupportedBinaries)( size_t IN size,
											   cl_prog_binary_desc* OUT types,
											   size_t* OUT size_ret
											   ) = 0;

	//
	// Kernel function prototypes
	//

	/* clDevGetKernelId
		Description
			Returns an internal identifier of the kernel.
		Input
			prog					A handle to created program object.
			name					A pointer to NULL terminated string that contains kernel name. 
		Output
			kernel_id				A valid (non zero) kernel internal identifier.
		Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_VALUE	If name is NULL.
			CL_DEV_INVALID_PROGRAM	If prog is not a valid program object.
			CL_INVALID_KERNEL_NAME	If name is not found in the program
	*/
	virtual cl_dev_err_code (clDevGetKernelId)( cl_dev_program IN prog,
										  const char* IN name,
										  cl_dev_kernel* OUT kernel_id
										  ) = 0;
	/* clDevGetProgramKernels
		Description
			Returns identifiers of all kernels belong to specific program object.
		Input
			prog					A handle to created program object.
			num_kernels				Size of array pointed to by kernels specified as the number of cl_dev_kernel entries. 
		Output
			kernels					The buffer where the kernel objects for kernels in program will be returned.
			num_kernels_ret			The number of kernels in program. When num_kernels is equal to 0 and kernels is NULL,
									returns only the number of kernels. If NULL the parameter is ignored.
		Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_PROGRAM	If program is not valid program object. 
			CL_DEV_INVALID_VALUE	If num_kernels is not enough to store the identifiers or kernels is NULL and num_kernels is not 0.
	*/
	virtual cl_dev_err_code (clDevGetProgramKernels)( cl_dev_program IN prog,
											 cl_uint IN num_kernels,
											 cl_dev_kernel* OUT kernels,
											 size_t* OUT num_kernels_ret
											 ) = 0;

	/* clDevGetKernelInfo
		Description
			Returns information about the kernel in program object
		Input
			kernel			An identifier of kernel in program object
			param			Specifies the information to query. The list is defined by cl_dev_kernel_info.
			value_size		Size in bytes of memory buffer pointed to by value.
		Output
			value			A pointer to memory where the appropriate result being queried is returned.
			value_size_ret	The actual size in bytes of data copied to value. When value_size is equal to 0 and value is NULL,
							returns only the size of data. If NULL the parameter is ignored.
	*/
	virtual cl_dev_err_code (clDevGetKernelInfo)( cl_dev_kernel IN kernel,
											cl_dev_kernel_info IN param,
											size_t IN value_size,
											void* OUT value,
											size_t* OUT value_size_ret
											) = 0;

	/* clDevGetPerfomanceCounter
		Description
			Retrieves current performance counter from the device
		Input
			None
		Output
			Current performance counter value
	*/
	virtual cl_ulong (clDevGetPerformanceCounter)() = 0;

	/* clDevSetLogger
		Description
			This function sets framework logger for the device.
		Input
			logger			A pointer to a structure that hold framework logger entry points.
		Output
			NONE
		Returns
							CL_DEV_SUCCESS	The function is executed successfully.
							CL_DEV_INVALID_OPERATION	Device doesn't supports logging operations.
	*/
	virtual cl_dev_err_code (clDevSetLogger)(IOCLDevLogDescriptor* IN pLogger) = 0;

	/* clDevGetTimeCounter
		Description
			This function returns 64bit value that describes current device time counted in nanoseconds
		Input
			NONE
		Output
			Device time counter
	*/


	/* clDevCloseDevice
		De-initialize internal state of the device agent and releases all allocated data.
		Input
			NONE
		Output
			NONE
		Returns
			NONE
	*/
	virtual void (clDevCloseDevice)() = 0;

};

//
// Logger function prototypes
//
class IOCLDevLogDescriptor
{
public:
	/* clLogCreateClient
		Description
			This function creates a logger client for the device. Each device may create multiple logger clients,
			e.g. client per each internal component.
		Input
			dev_id				A pointer to a structure that hold framework logger entry points.
			client_name			Name associated with logger client.
		Output
			client_id			An client logger identifier to be used in further calls to clLogAddLine().
		Returns
			CL_DEV_SUCCESS		The function is executed successfully.
			CL_DEV_FAILED		Logger internal error occurred.
	*/
	virtual cl_int (clLogCreateClient)( cl_int IN dev_id,
							  const wchar_t* IN client_name,
							  cl_int* OUT client_id
							  ) = 0;
	/* clLogReleaseClient
		Description
			This function releases previously created logger client.
		Input
			client_id				A logger client identifier that created with clLogCreateClient().
		Output
			NONE
		Returns
			CL_DEV_SUCCESS			The function is executed successfully.
			CL_DEV_INVALID_VALUE	Invalid client identifier.
	*/
	virtual cl_int (clLogReleaseClient)(cl_int IN client_id) = 0;

	/* clLogAddLine
		This function adds a logger line to logger client. The logged line will appear in the logger only if logger line level
		is equal or above of the current client logger level.
		Input
			client_id	Logger client identifier that was created with clLogCreateClient()
			log_level	Logging level of the message.
			source_file	Name of the source file that has added the log message.
			function_name	Name of the function from where the log line was added.
			line_num	Line number from where the log line was added.
			message	The used message to be added into the log line. The message format string is identical to printf() format.
		Output
			NONE
		Returns
			CL_DEV_SUCCESS	The function is executed successfully.
			CL_DEV_INVALID_VALUE	Logger client id is not valid.
	*/
	virtual cl_int (clLogAddLine)( cl_int IN client_id,
									 cl_int IN log_level,
									 const wchar_t* IN source_file,
									 const wchar_t* IN function_name,
									 cl_int IN line_num,
									 const wchar_t* IN message, ...) = 0;
	virtual cl_int (clLogAddLine)( cl_int IN client_id,
									 cl_int IN log_level,
									 const char* IN source_file,
									 const char* IN function_name,
									 cl_int IN line_num,
									 const wchar_t* IN message, ...) = 0;

};


/**
* clErrTxt
* returns a wide-character string of the error code
*/
const char* clDevErr2Txt(cl_dev_err_code error_code);

typedef void (fn_clNativeKernel)(void* INOUT param);

#ifdef __cplusplus
}
#endif
