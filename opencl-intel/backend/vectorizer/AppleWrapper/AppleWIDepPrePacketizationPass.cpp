#include "AppleWIDepPrePacketizationPass.h"
#include "llvm/Support/InstIterator.h"
#include "VectorizerUtils.h"
#include "Mangler.h"

char intel::AppleWIDepPrePacketizationPass::ID = 0;

namespace intel{

AppleWIDepPrePacketizationPass::AppleWIDepPrePacketizationPass():
FunctionPass(ID) {
  initializePostDominatorTreePass(*PassRegistry::getPassRegistry());
}

AppleWIDepPrePacketizationPass::~AppleWIDepPrePacketizationPass() {
}

bool AppleWIDepPrePacketizationPass::runOnFunction(Function& F) {
  bool changed = false;
  m_curModule = F.getParent();
  m_appleRuntimeServices = (OpenclRuntime*) RuntimeServices::get();
  for ( inst_iterator ii = inst_begin(&F), ie = inst_end(&F); ii != ie; ++ii ) {
    if (CallInst *CI = dyn_cast<CallInst>(&*ii))  {
      std::string funcName = CI->getCalledFunction()->getName().str();
      if (m_appleRuntimeServices->isFakeWriteImage(funcName)) {
        handleWriteImage(CI, funcName);
        changed = true;
      }
    }
  }

  if (changed) {
    std::vector<Instruction *>::iterator it = m_removedInsts.begin();
    std::vector<Instruction *>::iterator e = m_removedInsts.end();
    for (; it!=e; ++it) {
      Instruction *curInst = *it;
      curInst->replaceAllUsesWith(UndefValue::get(curInst->getType()));
      curInst->eraseFromParent();
    }
  }
  return changed;
}

void AppleWIDepPrePacketizationPass::handleWriteImage(CallInst *CI, std::string &funcName) {
  std::string resolvedName = Mangler::demangle_fake_builtin(funcName);
  Value *xCoord = CI->getArgOperand(1);
  Value *yCoord = CI->getArgOperand(2);
  WIAnalysis *depAnalysis = &getAnalysis<WIAnalysis>();
  PostDominatorTree* PDT = &getAnalysis<PostDominatorTree>();
  BasicBlock *curBlock = CI->getParent();
  BasicBlock &entry = curBlock->getParent()->getEntryBlock();

  // incase x is consecutive and  y unioform don't need to do nothing and packetization can occur
  // otherwise need to fallback to original call 
  if (WIAnalysis::CONSECUTIVE != depAnalysis->whichDepend(xCoord) ||
      WIAnalysis::UNIFORM != depAnalysis->whichDepend(yCoord) ||
      !PDT->dominates(curBlock,&entry)) { // currently we don't support masked write image
    //getting here we cant vectorize the write image call we fall back to the original write image
    Function *origWriteImg = m_curModule->getFunction(resolvedName);
    V_ASSERT(origWriteImg && "write img declaration should be in the rt module");
    const FunctionType *origWriteImgType = origWriteImg->getFunctionType();

    // obtain write image arguments
    SmallVector<Value *, 3> writeImgArgs(3);
    Value *fakeImg = CI->getArgOperand(0);
    Type *imgType = origWriteImg->getFunctionType()->getParamType(0);
    writeImgArgs[0] = VectorizerUtils::getCastedArgIfNeeded(fakeImg, imgType, CI); // img

    Value *coordsVec = getWriteImgCoordsVector(xCoord, yCoord, CI);
    Type *coordsType = origWriteImgType->getParamType(1);
    writeImgArgs[1] = VectorizerUtils::getCastedArgIfNeeded( coordsVec , coordsType, CI);

    Value *colors = CI->getArgOperand(3);
    Type *colorsType = origWriteImgType->getParamType(2);
    writeImgArgs[2] = VectorizerUtils::getCastedArgIfNeeded(colors , colorsType, CI);
    
    // create new call 
    CallInst::Create(origWriteImg, ArrayRef<Value*>(writeImgArgs), "", CI);

    // mark old call for removal
    m_removedInsts.push_back(CI);
  }
}

Value *AppleWIDepPrePacketizationPass::getWriteImgCoordsVector(Value *xCoord, Value *yCoord, CallInst *CI)
{
   Type *i32Ty = Type::getInt32Ty(CI->getContext());
   Type *coordType = VectorType::get(i32Ty, 2);
   Constant *constZero = ConstantInt::get(i32Ty, 0);
   Constant *constOne = ConstantInt::get(i32Ty, 1);
   
   // if scalar coords are generated by extract take original vector 
   ExtractElementInst *xExtract = dyn_cast<ExtractElementInst>(xCoord);
   ExtractElementInst *yExtract = dyn_cast<ExtractElementInst>(yCoord);
   if (xExtract &&
       yExtract &&
       xExtract->getOperand(1) == constZero &&
       yExtract->getOperand(1) == constOne) {
     Value *inputVector = xExtract->getOperand(0);
     if (inputVector == yExtract->getOperand(0) && inputVector->getType() == coordType) 
       return xExtract->getOperand(0);
   }

   // assembel coords vector from xCoord and yCoord
   Value *newCoordsVec = UndefValue::get(coordType);
   newCoordsVec = InsertElementInst::Create(newCoordsVec, xCoord, constZero, "insert.x.coord", CI);
   newCoordsVec = InsertElementInst::Create(newCoordsVec, yCoord, constOne, "insert.y.coord", CI);
   return newCoordsVec;
}

}// namespace intel


extern "C"
FunctionPass *createAppleWIDepPrePacketizationPass() { 
  return new intel::AppleWIDepPrePacketizationPass();
}

static RegisterPass<intel::AppleWIDepPrePacketizationPass>
AppleWIDepPrePack("AppleWIDepPrePack", "handle pre packetization wi-dep special builtins for apple envioronment");