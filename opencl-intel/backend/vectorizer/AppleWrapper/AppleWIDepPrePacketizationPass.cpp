/*=================================================================================
Copyright (c) 2012, Intel Corporation
Subject to the terms and conditions of the Master Development License
Agreement between Intel and Apple dated August 26, 2005; under the Category 2 Intel
OpenCL CPU Backend Software PA/License dated November 15, 2012 ; and RS-NDA #58744
==================================================================================*/
#include "AppleWIDepPrePacketizationPass.h"
#include "VectorizerUtils.h"
#include "OCLPassSupport.h"
#include "InitializePasses.h"
#include "Mangler.h"

#include "llvm/IR/Module.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/InstIterator.h"


namespace intel{

char AppleWIDepPrePacketizationPass::ID = 0;

OCL_INITIALIZE_PASS_BEGIN(AppleWIDepPrePacketizationPass, "AppleWIDepPrePack", "handle pre packetization wi-dep special builtins for apple envioronment", false, false)
OCL_INITIALIZE_PASS_DEPENDENCY(PostDominatorTreeWrapperPass)
OCL_INITIALIZE_PASS_DEPENDENCY(WIAnalysis)
OCL_INITIALIZE_PASS_DEPENDENCY(BuiltinLibInfo)
OCL_INITIALIZE_PASS_END(AppleWIDepPrePacketizationPass, "AppleWIDepPrePack", "handle pre packetization wi-dep special builtins for apple envioronment", false, false)

AppleWIDepPrePacketizationPass::AppleWIDepPrePacketizationPass():
FunctionPass(ID) {
  initializeAppleWIDepPrePacketizationPassPass(*PassRegistry::getPassRegistry());
}

AppleWIDepPrePacketizationPass::~AppleWIDepPrePacketizationPass() {
}

bool AppleWIDepPrePacketizationPass::runOnFunction(Function& F) {
  bool changed = false;
  m_curModule = F.getParent();
  m_appleRuntimeServices = static_cast<OpenclRuntime *>(getAnalysis<BuiltinLibInfo>().getRuntimeServices());
  for ( inst_iterator ii = inst_begin(&F), ie = inst_end(&F); ii != ie; ++ii ) {
    if (CallInst *CI = dyn_cast<CallInst>(&*ii))  {
      std::string funcName = CI->getCalledFunction()->getName().str();
      if (m_appleRuntimeServices->isFakeWriteImage(funcName)) {
        handleWriteImage(CI, funcName);
        changed = true;
      }
    }
  }

  if (changed) {
    std::vector<Instruction *>::iterator it = m_removedInsts.begin();
    std::vector<Instruction *>::iterator e = m_removedInsts.end();
    for (; it!=e; ++it) {
      Instruction *curInst = *it;
      curInst->replaceAllUsesWith(UndefValue::get(curInst->getType()));
      curInst->eraseFromParent();
    }
  }
  return changed;
}

void AppleWIDepPrePacketizationPass::handleWriteImage(CallInst *CI, std::string &funcName) {
  std::string resolvedName = Mangler::demangle_fake_builtin(funcName);
  Value *xCoord = CI->getArgOperand(1);
  Value *yCoord = CI->getArgOperand(2);
  WIAnalysis *depAnalysis = &getAnalysis<WIAnalysis>();
  PostDominatorTree* PDT = &getAnalysis<PostDominatorTreeWrapperPass>().getPostDomTree();
  BasicBlock *curBlock = CI->getParent();
  BasicBlock &entry = curBlock->getParent()->getEntryBlock();

  // incase x is consecutive and  y unioform don't need to do nothing and packetization can occur
  // otherwise need to fallback to original call
  if (WIAnalysis::CONSECUTIVE != depAnalysis->whichDepend(xCoord) ||
      WIAnalysis::UNIFORM != depAnalysis->whichDepend(yCoord) ||
      !PDT->dominates(curBlock,&entry)) { // currently we don't support masked write image
    //getting here we cant vectorize the write image call we fall back to the original write image
    Function *origWriteImg = m_curModule->getFunction(resolvedName);
    V_ASSERT(origWriteImg && "write img declaration should be in the rt module");
    const FunctionType *origWriteImgType = origWriteImg->getFunctionType();

    // obtain write image arguments
    SmallVector<Value *, 3> writeImgArgs(3);
    Value *fakeImg = CI->getArgOperand(0);
    Type *imgType = origWriteImg->getFunctionType()->getParamType(0);
    writeImgArgs[0] = VectorizerUtils::getCastedArgIfNeeded(fakeImg, imgType, CI); // img

    Value *coordsVec = getWriteImgCoordsVector(xCoord, yCoord, CI);
    Type *coordsType = origWriteImgType->getParamType(1);
    writeImgArgs[1] = VectorizerUtils::getCastedArgIfNeeded( coordsVec , coordsType, CI);

    Value *colors = CI->getArgOperand(3);
    Type *colorsType = origWriteImgType->getParamType(2);
    writeImgArgs[2] = VectorizerUtils::getCastedArgIfNeeded(colors , colorsType, CI);

    // create new call
    CallInst::Create(origWriteImg, ArrayRef<Value*>(writeImgArgs), "", CI);

    // mark old call for removal
    m_removedInsts.push_back(CI);
  }
}

Value *AppleWIDepPrePacketizationPass::getWriteImgCoordsVector(Value *xCoord, Value *yCoord, CallInst *CI)
{
   Type *i32Ty = Type::getInt32Ty(CI->getContext());
   Type *coordType = VectorType::get(i32Ty, 2);
   Constant *constZero = ConstantInt::get(i32Ty, 0);
   Constant *constOne = ConstantInt::get(i32Ty, 1);

   // if scalar coords are generated by extract take original vector
   ExtractElementInst *xExtract = dyn_cast<ExtractElementInst>(xCoord);
   ExtractElementInst *yExtract = dyn_cast<ExtractElementInst>(yCoord);
   if (xExtract &&
       yExtract &&
       xExtract->getOperand(1) == constZero &&
       yExtract->getOperand(1) == constOne) {
     Value *inputVector = xExtract->getOperand(0);
     if (inputVector == yExtract->getOperand(0) && inputVector->getType() == coordType)
       return xExtract->getOperand(0);
   }

   // assembel coords vector from xCoord and yCoord
   Value *newCoordsVec = UndefValue::get(coordType);
   newCoordsVec = InsertElementInst::Create(newCoordsVec, xCoord, constZero, "insert.x.coord", CI);
   newCoordsVec = InsertElementInst::Create(newCoordsVec, yCoord, constOne, "insert.y.coord", CI);
   return newCoordsVec;
}

}// namespace intel


extern "C"
FunctionPass *createAppleWIDepPrePacketizationPass() {
  return new intel::AppleWIDepPrePacketizationPass();
}

