// INTEL CONFIDENTIAL
//
// Copyright 2012-2018 Intel Corporation.
//
// This software and the related documents are Intel copyrighted materials, and
// your use of them is governed by the express license under which they were
// provided to you (License). Unless the License provides otherwise, you may not
// use, modify, copy, publish, distribute, disclose or transmit this software or
// the related documents without Intel's prior written permission.
//
// This software and the related documents are provided as is, with no express
// or implied warranties, other than those that are expressly stated in the
// License.

#ifndef __INSTCOUNTER__H__
#define __INSTCOUNTER__H__

#include "BuiltinLibInfo.h"

#include "llvm/Pass.h"
#include "llvm/ADT/DenseMap.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Analysis/ScalarEvolution.h"
#include "llvm/Analysis/PostDominators.h"
#include "llvm/IR/Dominators.h"
#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/StringMap.h"

#include <stdlib.h>

#include "cl_cpu_detect.h"
using namespace llvm;

namespace intel {
  class VectorizationPossibilityPass : public FunctionPass {
  public:
    static char ID; // Pass ID, replacement for typeid
    VectorizationPossibilityPass(): FunctionPass(ID), m_canVectorize(false) {}

    bool runOnFunction(Function &F) override;

    virtual void getAnalysisUsage(AnalysisUsage &AU) const override {
      AU.addRequired<DominatorTreeWrapperPass>();
      AU.addRequired<BuiltinLibInfo>();
    }

    // Returns false is the code is essentially non-vectorizeable.
    // This is not advice, this is a final decision.
    bool isVectorizable() const {
      return m_canVectorize;
    }

  private:
    bool m_canVectorize;
  };

  class CanVectorizeImpl
  {
  public:
    // Checks whether we can (as opposed to should) vectorize
    // this function.
    static bool canVectorize(Function &F, DominatorTree &DT, RuntimeServices* services);
    // Checks for VPO.
    static bool canVectorizeForVPO(Function &F, RuntimeServices *services);

  private:
    // Functions imported as is from old heuristic.

    // Checks if the program has reducible control flow
    static bool isReducibleControlFlow(Function &F, DominatorTree &DT);

    // Check if the function has variable access to get_global/loval_id(X)
    static bool hasVariableGetTIDAccess(Function &F, RuntimeServices* services);

    // Checks if the incoming program has illegal types
    // An illegal type in this context is iX, where X > 64.
    // TODO: Check if this is still relevant to the current codegen.
    static bool hasIllegalTypes(Function &F);

    // Checks if the incoming program has unsupported function calls
    // An unsupported function call is function that contains
    // barrier/get_local_id/get_global_id or a call to unsupported function.
    // Vectorize of kernel that calls non-inline function is done today by
    // calling the scalar version of called function VecWidth times.
    // This means that the implict arguments sent to the vectorized kernel
    // that is respone for calculating the barrier/get_local_id/get_global_id
    // cannot passed as is to the scalar function, what make it too difficult
    // to support these cases.
    static bool hasNonInlineUnsupportedFunctions(Function &F);

    // Checks if the function directly calls stream read/write image functions.
    // We never want to vectorize that, as it doesn't make any sense.
    static bool hasDirectStreamCalls(Function &F, RuntimeServices* services);

    // Check whether any of the basic blocks terminates with 'unreachable'
    // We check this after dead code has been eliminated, so finding an
    // 'unreachable' instruction implies esoteric code we would not want to
    // apply the vectorizer to, for example:
    //   tail call void @llvm.trap()
    //   unreachable
    // generated by LLVM for invalid code (e.g dereferencing an
    // uninitialized pointer).
    static bool hasUnreachableInstructions(Function &F);
  };
}

#endif // __INSTCOUNTER__H__
