// Copyright (c) 2017 Intel Corporation
// All rights reserved.
//
// WARRANTY DISCLAIMER
//
// THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
// MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of the Materials, and requests that all
// problem reports or change requests be submitted to it directly

#include "PipeSupport.h"

#include <BuiltinLibInfo.h>
#include <CompilationUtils.h>
#include <InitializePasses.h>
#include <OCLAddressSpace.h>
#include <OCLPassSupport.h>

#include <llvm/ADT/MapVector.h>
#include <llvm/ADT/SmallString.h>
#include <llvm/Analysis/ValueTracking.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Transforms/Utils/BasicBlockUtils.h>

#include <algorithm>

using namespace llvm;
using namespace Intel::OpenCL::DeviceBackend;

namespace intel {

char PipeSupport::ID = 0;
OCL_INITIALIZE_PASS_BEGIN(
    PipeSupport, "pipe-support",
    "Apply transformation required by pipe built-ins implementation", false,
    true)
OCL_INITIALIZE_PASS_DEPENDENCY(BuiltinLibInfo)
OCL_INITIALIZE_PASS_DEPENDENCY(ChannelPipeTransformation)
OCL_INITIALIZE_PASS_END(
    PipeSupport, "pipe-support",
    "Apply transformation required by pipe built-ins implementation", false,
    true)

static Function *importBIDecl(Module &TargetModule,
                              const SmallVectorImpl<Module *> &RTLs,
                              StringRef Name) {
  for (auto *BIModule : RTLs) {
    if (auto *F = BIModule->getFunction(Name)) {
      return cast<Function>(
          CompilationUtils::importFunctionDecl(&TargetModule, F));
    }
  }

  return nullptr;
}

static Value *findPipeOriginValue(Module *M, Value *Pipe) {
  SmallVector<Value *, 8> Objects;
  GetUnderlyingObjects(Pipe, Objects, M->getDataLayout(),
                       /*LoopInfo=*/nullptr,
                       /*MaxLookup=*/16);

  // Pipe access must be resolved at compile time, so we should have only 1 pipe
  // object, excluding undefs (which may be generated by the vectorizer).
  auto Obj = std::find_if_not(Objects.begin(), Objects.end(),
                              [](Value *V) { return isa<UndefValue>(V); });

  if (Obj == Objects.end()) return nullptr;
  Value *PipeOrigin = *Obj;

  bool isSingleOrigin = false;

  // Only global pipes can be loaded
  bool isGlobalPipe = isa<LoadInst>(PipeOrigin);

  // We have either a value or a load from global variable.
  // Check that the pipe object is the same in both cases
  if (isGlobalPipe) {
    Value *GlobalPtr =
        cast<LoadInst>(PipeOrigin)->getPointerOperand()->stripPointerCasts();
    isSingleOrigin =
        std::all_of(Objects.begin(), Objects.end(), [GlobalPtr](Value *V) {
          if (isa<UndefValue>(V))
            return true;
          auto *Load = dyn_cast<LoadInst>(V);
          return Load ? GlobalPtr ==
                            Load->getPointerOperand()->stripPointerCasts()
                      : false;
        });
  } else {
    isSingleOrigin =
        std::all_of(Objects.begin(), Objects.end(), [PipeOrigin](Value *V) {
          if (isa<UndefValue>(V))
            return true;
          return PipeOrigin == V;
        });
  }

  if (!isSingleOrigin) {
    return nullptr; // couldn't resolve to single object
  }

  return PipeOrigin;
}

PipeSupport::PipeSupport() : ModulePass(ID) {}

/// PipeLookup class finds a corresponding global pipe variable from a pipe call
/// instruction, or a local pipe if it is a function argument.
class PipeLookup {
  // pipe variable can be either a global pointer (a GEP from a global array
  // with static indexing)
  Value *GlobalPtr;
  // or a local variable (a function argument)
  Value *Local;

public:
  PipeLookup(CallInst *PipeCall);

  Value *findGlobalPtr() const { return GlobalPtr; }
  Value *findLocal() const { return Local; }
};

PipeLookup::PipeLookup(CallInst *PipeCall)
    : GlobalPtr(nullptr), Local(nullptr) {
  assert(PipeCall && "Invalid PipeCall instruction.");

  Module *M = PipeCall->getModule();
  Value *PipeArg = PipeCall->getArgOperand(0)->stripPointerCasts();
  Value *Pipe = findPipeOriginValue(M, PipeArg);
  if (!Pipe) {
    return;
  }

  if (auto *Load = dyn_cast<LoadInst>(Pipe)) {
    auto *PipeGlobal = Load->getPointerOperand()->stripPointerCasts();
    if ((GlobalPtr = dyn_cast<Constant>(PipeGlobal)))
      return;
    if ((GlobalPtr = dyn_cast<GlobalVariable>(PipeGlobal)))
      return;

    return; // lookup failed to resolve pipe call statically
  }

  auto *F = PipeCall->getFunction();
  auto FunArg = std::find_if(F->arg_begin(), F->arg_end(),
                             [Pipe](Value &V) { return &V == Pipe; });

  Local = (FunArg != F->arg_end()) ? Pipe : nullptr;

  assert((GlobalPtr || Local) && "Unexpected pipe object type.");
}

static void
findNonBlockingPipeCalls(Function &F,
                         MapVector<CallInst *, PipeKind> &CallKindMap) {
  for (auto &I : instructions(F)) {
    auto *Call = dyn_cast<CallInst>(&I);
    if (!Call) {
      continue;
    }
    auto *Callee = Call->getCalledFunction();
    if (!Callee) {
      continue;
    }

    StringRef Name = Callee->getName();
    PipeKind Kind = CompilationUtils::getPipeKind(Name);
    if (Kind && !Kind.Blocking) {
      CallKindMap.insert({Call, Kind});
    }
  }
}

static bool hasBlockingPipeBIs(const Function &F) {
  for (auto &I : instructions(F)) {
    auto *Call = dyn_cast<CallInst>(&I);
    if (!Call) {
      continue;
    }

    auto *Callee = Call->getCalledFunction();
    if (!Callee || !CompilationUtils::isPipeBuiltin(Callee->getName())) {
      continue;
    }

    PipeKind Kind = CompilationUtils::getPipeKind(Callee->getName());
    if (Kind.Blocking) {
      return true;
    }
  }

  return false;
}

static Function *
createFlushAllFunctionStub(Function &F, const SmallVectorImpl<Value *> &Args) {

  SmallVector<Type *, 16> ArgTy;
  for (const auto *Arg : Args) {
    ArgTy.push_back(Arg->getType());
  }

  auto *FunTy = FunctionType::get(Type::getVoidTy(F.getContext()), ArgTy,
                                  /*isVarArg=*/false);
  SmallString<64> FlushAllName;
  (StringRef("__flush_all_") + F.getName()).toStringRef(FlushAllName);

  auto *FlushAll =
      cast<Function>(F.getParent()->getOrInsertFunction(FlushAllName, FunTy));

  BasicBlock::Create(F.getContext(), "entry", FlushAll);

  return FlushAll;
}

/// Creates __flush_all_<function_name> function, which flushes all pipes used
/// by a given function \p F.
static Function *createFlushAllFunction(
    Function &F,
    Function *ReadFlush, Function *WriteFlush,
    MapVector<CallInst *, PipeKind> &CallKindMap,
    const SmallVectorImpl<Value *> &Args) {

  assert(ReadFlush && "Invalid ReadFlush function");
  assert(WriteFlush && "Invalid WriteFlush function");

  auto *FlushAll = createFlushAllFunctionStub(F, Args);

  IRBuilder<> Builder(&FlushAll->getEntryBlock());

  auto Arg = FlushAll->arg_begin();
  for (const auto &KV : CallKindMap) {
    auto Kind = KV.second;
    Function *FlushFn =
      (Kind.Access == PipeKind::READ) ? ReadFlush : WriteFlush;

    Value *FlushArgs[] = {Builder.CreateBitCast(
        &*Arg, FlushFn->getFunctionType()->getParamType(0))};
    Builder.CreateCall(FlushFn, FlushArgs);

    ++Arg;
  }

  Builder.CreateRetVoid();
  return FlushAll;
}

static Value *getNonBlockingPipeCallRetcode(CallInst* Call,
                                            IRBuilder<> Builder) {
  auto *F = Call->getCalledFunction();
  assert(F && "CallInst does not have a Function");

  // SIMD read pipe built-in has a retcode as a second parameter
  PipeKind Kind = CompilationUtils::getPipeKind(F->getName());
  assert(!Kind.Blocking &&
         "Retcode of blocking pipe call is meaningless (always succeed)");

  if (Kind.Access == PipeKind::READ && !Kind.SimdSuffix.empty()) {
    auto *RetcodePtr = Call->getArgOperand(1);
    return Builder.CreateLoad(RetcodePtr);
  }

  // all others just return it directly
  return Call;
}

/// Adds a \p FlushAll function call if \p Call returned -1 (cannot write/read
/// because a pipe is full/empty)
void insertFlushAtCall(CallInst *Call, Function *FlushAll,
                       const SmallVectorImpl<Value *> &Args) {
  assert(Call->getNextNode() && "Call does not have a next node");
  IRBuilder<> Builder(Call->getNextNode());

  auto *Retcode = getNonBlockingPipeCallRetcode(Call, Builder);

  auto *CallSuccessRetcode =
      ConstantInt::get(Type::getInt32Ty(FlushAll->getContext()), 0);

  auto *IsCallFailed = Builder.CreateICmpNE(Retcode, CallSuccessRetcode);

  auto *ThenBB = llvm::SplitBlockAndInsertIfThen(
      IsCallFailed, cast<Instruction>(IsCallFailed)->getNextNode(),
      /*Unreachable=*/false);

  CallInst::Create(FlushAll, Args, "", ThenBB);
}

void insertFlushAtExit(Function &F, Function *FlushAll,
                       const SmallVectorImpl<Value *> &Args) {
  for (auto &BB : F) {
    auto *Term = BB.getTerminator();
    assert(Term && "Ill-formed BasicBlock.");
    if (!isa<ReturnInst>(Term)) {
      continue;
    }

    CallInst::Create(FlushAll, Args, "", Term);
  }
}

bool insertFlushCalls(Function &F, Function *ReadFlush, Function *WriteFlush) {
  MapVector<CallInst *, PipeKind> CallKindMap;
  findNonBlockingPipeCalls(F, CallKindMap);

  if (CallKindMap.empty()) {
    return false;
  }

  SmallVector<Value *, 16> FlushAllArgs;

  IRBuilder<> Builder(&F.getEntryBlock().front());
  for (const auto &KV : CallKindMap) {
    auto *Call = KV.first;

    PipeLookup Pipe(Call);
    if (auto *GlobalPtr = Pipe.findGlobalPtr()) {
      // Globals must be loaded before use
      auto *PipeTy = cast<PointerType>(GlobalPtr->getType())->getElementType();

      // Insert a bitcast for first element access from a pipe array. For this
      // case, original bitcast from ArrayType to PointerType have been thrown
      // away by stripPointerCasts().
      if (auto *PipeArrayTy = dyn_cast<ArrayType>(PipeTy)) {
        PipeTy = CompilationUtils::getArrayElementType(PipeArrayTy);
        auto PipePtrTy =
            PointerType::get(PipeTy, Utils::OCLAddressSpace::Global);
        GlobalPtr = Builder.CreateBitCast(GlobalPtr, PipePtrTy);
      }

      FlushAllArgs.push_back(Builder.CreateLoad(PipeTy, GlobalPtr));
    } else if (auto *Local = Pipe.findLocal()) {
      FlushAllArgs.push_back(Local);
    } else {
      llvm_unreachable("Couldn't resolve pipe access");
    }
  }

  Function *FlushAll =
      createFlushAllFunction(F, ReadFlush, WriteFlush,
                             CallKindMap, FlushAllArgs);

  // When 2 kernels (A and B) are communicating over pipes:
  //         ..
  // ------  -----> ------     '.' means a cached packet
  // | A  |         | B  |     'x' means a visible packet
  // ------  -----> ------
  //         xxxxx
  //
  // - Kernel A writes 2 packets, but they are cached, i.e. kernel B
  //   doesn't see them yet.
  // - Then Kernel A writes 5 packets and cannot proceed further, because
  //   the pipe is full.
  // - According to the algorithm, kernel B should read packets from
  //   the 1st pipe, than proceed to the 2nd pipe.
  //
  // Since packets in 1st pipe are cached, kernel B cannot read anything,
  // and kernel A is blocked on 2nd pipe ('pipe full' condition).
  //
  // If non-blocking pipe built-in returned -1, we must flush all pipes, because
  // keeping elements in cache may cause a deadlock.
  //
  // NOTE: we rely on the two facts:
  //  - that *blocking* builins are implemented as a loop around non-blocking
  //    builtins
  //  - built-in import and inliner passes are done - we only have non-blocking
  //    calls
  //
  assert(!hasBlockingPipeBIs(F) &&
         "Blocking pipe BIs should already be inlined!");
  for (const auto &KV : CallKindMap) {
    auto *Call = KV.first;
    insertFlushAtCall(Call, FlushAll, FlushAllArgs);
  }

  // Ensure that nothing is cached upon exit from a function
  insertFlushAtExit(F, FlushAll, FlushAllArgs);

  return true;
}

static bool
addImplicitFlushCalls(Module &M,
                      const SmallVectorImpl<Module *> &BuiltinModules) {
  bool Changed = false;

  auto *ReadFlush  = importBIDecl(M, BuiltinModules, "__flush_read_pipe");
  auto *WriteFlush = importBIDecl(M, BuiltinModules, "__flush_write_pipe");
  assert(ReadFlush && "Built-in not found.");
  assert(WriteFlush && "Built-in not found.");

  SmallVector<Function *, 64> Funcs;
  for (auto &F : M) {
    if (F.isDeclaration()) {
      continue;
    }
    Funcs.push_back(&F);
  }

  for (auto *F : Funcs) {
    Changed |= insertFlushCalls(*F, ReadFlush, WriteFlush);
  }

  return Changed;
}

bool PipeSupport::runOnModule(Module &M) {
  bool Changed = false;

  BuiltinLibInfo &BLI = getAnalysis<BuiltinLibInfo>();
  SmallVector<Module *, 2> BuiltinModules = BLI.getBuiltinModules();

  Changed |= addImplicitFlushCalls(M, BuiltinModules);

  return Changed;
}

void PipeSupport::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.addRequired<BuiltinLibInfo>();
}

} // namespace intel

extern "C" {
ModulePass *createPipeSupportPass() { return new intel::PipeSupport(); }
}
