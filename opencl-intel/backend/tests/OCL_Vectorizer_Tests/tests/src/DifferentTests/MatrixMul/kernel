/*	Matrix multiplication on the device: C = A * B	*/

__kernel void multiply(__global int* arg, __global float *data1, __global float *data2
	, __global float *data3, __local float* As, __local float* Bs)
{	
	int M = arg[0];	/* ;HA height of A */
	int N = arg[1];	/* ;WA width of	 A */
	int R = arg[2];	/* ;WB width of  B */
	
	/* global thread index */
	int ty = get_global_id(0);
	int tx = get_global_id(1);

	/* if we have passed the matrix limit we may do nothing */
	if(tx >= R || ty >= M) return ;
	
	/* from this point just threads between (0,0) - (M-1,R-1) 
		are relevant */
		
	/* local thread index */
	int ly = get_local_id(0);
	int lx = get_local_id(1);

	/* group index */
	int by = get_group_id(0);
	int bx = get_group_id(1);

	/* group dim (BLOCK) */
	int dim = arg[3];

	/* Index of the first sub-matrix of A (data1) processed by the block */
	int aBegin	= N * dim * by;

	/* Index of the last sub-matrix of A (data1) processed by the block	 */
	int aEnd	= aBegin + N - 1;

	/* Step size used to iterate through the sub-matrices of A (data1)	 */
	int aStep = dim;

	/* Index of the first sub-matrix of B processed by the block */
	int bBegin = dim * bx;

	/* Step size used to iterate through the sub-matrices of B   */
	int bStep = dim * R;
	
	/* Csub is used to store the element of the block sub-matrix
	   that is computed by the thread	*/
	float Csub = 0;

	/* Loop over all the sub-matrices of A and B
	   required to compute the block sub-matrix	*/
	for(int a = aBegin, b = bBegin;
			a <= aEnd;
			a += aStep, b += bStep) {
		
		/* Note */
			/* As is local shared memory which used to store the 
			   sub-Matrix of data1	*/
			/* Bs is local shared memory which used to store the
				sub-Matrix of data2 */

			/* Load the matrices from global memory to local memory; 
			   each thread loads one element of each matrix			*/
			
			As[ly*dim +lx] = data1[a + N * ly + lx];
/* ?@?@ */	As[dim*dim + ly*dim +lx] = data2[b + R * ly + lx];			

			/* Synchronize to make sure the matrices are loaded		*/
			barrier(CLK_LOCAL_MEM_FENCE);
/* ^%^% */
			/* Multiply the two matrices together; each thread computes one element
			   of the block sub-matrix		*/
			for (int k = 0; k < dim; ++k) {
				Csub += As[ly*dim+k] * As[dim*dim+k*dim+lx];				
				}					
			/* Synchronize to make sure that the preceding computation is done 
			before loading two new sub-matrices of data(1\2) in the next iteration */
			barrier(CLK_LOCAL_MEM_FENCE);			
		} 

	/* Write the block sub-matrix to device memory;
	   each thread writes one element	*/
	int c = R * dim * by + dim * bx;
	unsigned int indx_in = c + R*ly + lx;
	data3[indx_in] = Csub;
}