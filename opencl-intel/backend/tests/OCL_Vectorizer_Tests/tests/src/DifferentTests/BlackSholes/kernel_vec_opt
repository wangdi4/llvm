/******************************************************************************
	Black Scholes Vector Kernel optimized for CPU
	This kernel computes Black Scholes Call & Put Results in Vector mode.
	
	NOTE: This version optimized for the CPU, and may didn't work in the later 
		versions of OpenCL. [it doesn't work in the GPU]
******************************************************************************/

#define	VEC_SIZE	4

/******************************************************************************
 some constants for the approximation 
******************************************************************************/

#define A1 0.31938153f
#define A2 -0.356563782f
#define A3 1.781477937f
#define A4 -1.821255978f
#define A5 1.330274429f
#define RSQRT2PI 0.3989422804f

/******************************************************************************
 Polynomial approximation of cumulative normal distribution function
******************************************************************************/

float4 CND(__private float4 d){
    float4
        K = 1.0f / (1.0f + 0.2316419f * fabs(d));

    float4
        cnd = RSQRT2PI * exp(- 0.5f * d * d) * 
        (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5)))));

    if(d.x > 0) cnd.x = 1.0f - cnd.x;
	if(d.y > 0) cnd.y = 1.0f - cnd.y;
	if(d.z > 0) cnd.z = 1.0f - cnd.z;
	if(d.w > 0) cnd.w = 1.0f - cnd.w;			

    return cnd;
}
/******************************************************************************
 Black-Scholes formula for both call and put
******************************************************************************/
void BlackScholesBody(
    __global float* CallResult,
    __global float* PutResult,
    __global float* S, /*	Stock price		*/
    __global float* X, /*	Option strike	*/
    __global float* T, /*	Option years	*/
    __private float R, /*	Risk	rate	*/
    __private float V  /*	Volatility rate	*/
){ 
    float4 sqrtT, expRT;
    float4 d1, d2, CNDD1, CNDD2;
	
	float4 S_vec = *((float4*) S); 
	float4 X_vec = *((float4*) X); 
	float4 T_vec = *((float4*) T); 

    sqrtT = sqrt(T_vec);
    d1 = (log(S_vec / X_vec) + (R + 0.5f * V * V) * T_vec) / (V * sqrtT);
    d2 = d1 - V * sqrtT;

    CNDD1 = CND(d1);
    CNDD2 = CND(d2);

    expRT = exp(- R * T_vec);
	
    (*(float4 *)CallResult) = S_vec * CNDD1 - X_vec * expRT * CNDD2;
    (*(float4 *)PutResult)  = X_vec * expRT * (1.0f - CNDD2) - S_vec * (1.0f - CNDD1);
}


/******************************************************************************
 Process an array of optN options on DEVICE
******************************************************************************/
 __kernel void BlackScholes(
    __global float *d_CallResult,
    __global float *d_PutResult,
    __global float *d_StockPrice,
    __global float *d_OptionStrike,
    __global float *d_OptionYears,
    __global float *args
){
	/* getting some arguments */
	float	Risk = args[0];
	float	Volatility = args[1];
	
	/* how many options */
	const int OPT_N = args[2];
	/* how many threads is executeing the kernel */
	const int Threads = args[3];

	int tid = VEC_SIZE * get_global_thread_id(0);
	
	for(int opt = tid; opt < OPT_N; opt += Threads * VEC_SIZE)	
		BlackScholesBody(
					&(d_CallResult[tid]),
					&(d_PutResult[tid]),
					
					&(d_StockPrice[tid]),
					&(d_OptionStrike[tid]),
					&d_OptionYears[tid],
					
					Risk,
					Volatility);
	
}