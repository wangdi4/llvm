/*********************************************************************************************
 * Copyright Â© 2010, Intel Corporation
 * Subject to the terms and conditions of the Master Development License
 * Agreement between Intel and Apple dated August 26, 2005; under the Intel
 * CPU Vectorizer for OpenCL Category 2 PA License dated January 2010; and RS-NDA #58744
 *********************************************************************************************/
#include "controlflow.h"


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Scan control flow structures, looking for boundary checks with early exits
/////////////////////////////////////////////////////////////////////////////////////////////////////
void HandleControlFlow::scanForBoundaryChecks()
{
	// Start by checking the exit point. if it contains code other then "ret" inst - there are no supported early exits
	BasicBlock * exitBlock = funcProperties->getRetInst()->getParent();
	if (cast<Instruction>(exitBlock->begin()) != funcProperties->getRetInst()) return;
	
	// If exit block has only one predecesor - there is no early exit
	if (exitBlock->getSinglePredecessor() != NULL) return;
	
	// look for supported early exit patterns, and replace with fake special-case functions
	while (1)
	{
		// Loop until all the early exits (in the kernel's entry block) are found
		if (!findAndCollapseEarlyExit(exitBlock)) break;
	}
}	


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Scan function for supported early-exit patterns, and call function to replace with special-case fake function.
// Supported structures:
//
//     boolVal = cmp tid_depend, const_val
// [optional] boolVal = and/or boolVal1, boolVal2
//     br boolVal, label forExit, continue
//   forExit:
//     br exitBlock
//   continue:
//
// Look for the following properties:
// 1) Compare and branch must be in kernel's entry block
// 2) Current block ends with a conditional branch
// 3) one of the branch targets is a block with nothing but a direct jump to exitBlock (or
//    jump to exitBlock directly)
// 4) Branch predicate is generated by an integer compare (or and/or of several compares). One argument must be a constant value (non TID dependent) 
//    and the second is either constant or TID-dependent instruction which has consequtive values
// 5) Branch is not preceded by any instruction with side-effect (from start of kernel)
/////////////////////////////////////////////////////////////////////////////////////////////////////
bool HandleControlFlow::findAndCollapseEarlyExit(BasicBlock * kernelExitBlock)
{
	// Check for conditional branch
	BranchInst * condBranch = dyn_cast<BranchInst>(cast<BasicBlock>(CURRENT_FUNCTION->begin())->getTerminator());
	if (!condBranch || condBranch->isUnconditional()) return false; // Not even a conditional branch...
	
	BasicBlock * targetTrue = condBranch->getSuccessor(0);
	BasicBlock * targetFalse = condBranch->getSuccessor(1);
	bool branchSideToEarlyExitIsTrue;  // TRUE if branch's true side leads to early exit. false if false side leads to early exit
	
	// Check first branch target - whether it leads directly to early exit
	if (targetTrue == kernelExitBlock ||														/* target is the exit block */
		(cast<Instruction>(targetTrue->begin()) == targetTrue->getTerminator() &&				/* target has one instruction */
		 isa<BranchInst>(targetTrue->getTerminator()) &&										/* .. Which is a branch */
		 cast<BranchInst>(targetTrue->getTerminator())->isUnconditional() &&					/* .. unconditional */
		 cast<BranchInst>(targetTrue->getTerminator())->getSuccessor(0) == kernelExitBlock))	/* ... to the exit block */
	{
		// True side leads to early exit
		branchSideToEarlyExitIsTrue = true;
	}
	else if (targetFalse == kernelExitBlock ||														/* target is the exit block */
			 (cast<Instruction>(targetFalse->begin()) == targetFalse->getTerminator() &&			/* target has one instruction */
			  isa<BranchInst>(targetFalse->getTerminator()) &&										/* .. Which is a branch */
			  cast<BranchInst>(targetFalse->getTerminator())->isUnconditional() &&					/* .. unconditional */
			  cast<BranchInst>(targetFalse->getTerminator())->getSuccessor(0) == kernelExitBlock))	/* ... to the exit block */
	{
		// False side leads to early exit
		branchSideToEarlyExitIsTrue = false;
	}
	else
	{
		// No side leads to early exit.
		return false;
	}

	V_PRINT("\tFound potential early exit:: " << *(condBranch->getCondition()) << "\n");

	// Validate that there are no instructions with side-effect preceding the branch
	if (!validateNoSideEffect(cast<BasicBlock>(CURRENT_FUNCTION->begin())))
	{
		V_PRINT("\t\tFailed! Detected potential side-effect/s before the early exit...\n");
		return false;
	}
		
	// Make sure that if we already processed a TID-depending early exit, there isn't another one coming
	if (funcProperties->getFuncProperty(FUNC_HAS_TID_DEPEND_EARLY_EXITS) && funcProperties->getProperty(condBranch ,PR_TID_DEPEND))
	{
		V_PRINT("\t\tFailed! Detected more than one TID-depending early exit...\n");
		return false;
	}
	
	// Scan back to the conditional/s. Only supported structure is a compare, or several
	// compares merged thru an AND or OR. Each compare must either be a constant compare (not
	// TID dependent) or TID-dependent compare to a constant (where we exit if the TID-dependent
	// value is larger than some K...)
	SmallVector<ICmpInst *, 2> earlyExitConditionals; // collect conditionals in here	
	SmallVector<Instruction *, 4> instsToRemove; // collect instructions that will need to be removed (if early exit analysis is successful)	
	Value * lastCondition = condBranch->getCondition();
	bool isLegal = searchUpConditional(lastCondition, branchSideToEarlyExitIsTrue, earlyExitConditionals, instsToRemove);
	if (!isLegal)
	{
		V_PRINT("\t\tFailed! Illegal conditionals...\n");
		return false;
	}
	V_ASSERT(earlyExitConditionals.size() > 0); // if rooting didnt fail, we should have at least one conditional..

	// Check legality of each conditional (at most one TID-dependent size, etc..). Only if all are legal, we can process them.
	for (unsigned i = 0; i < earlyExitConditionals.size(); ++i)
	{
		ICmpInst * compare = earlyExitConditionals[i];
		V_ASSERT(compare); // sanity
		V_PRINT("\tAnalyzing compare inst: " << *compare << "\n");
		CmpInst::Predicate pred = compare->getPredicate();
	
		// Check that the conditional has at most one TID-dependent side (and place it as LHS)
		if (funcProperties->getProperty(compare->getOperand(1) ,PR_TID_DEPEND))
		{
			// If the RHS operand is TID dependent, swap sides (reversing the predicate) to keep it in the LHS
			compare->swapOperands();
		}
		if (funcProperties->getProperty(compare->getOperand(1) ,PR_TID_DEPEND)) 
		{
			V_PRINT("\t\tFailed! Both operands are TID-dependent\n");
			return false; // Failed. Both operands are TID-dependent
		}

		// If compare is TID dependent, check that it is legal (comparing and exiting on out-of-bound)
		if (funcProperties->getProperty(compare->getOperand(0) ,PR_TID_DEPEND)) 
		{
			V_ASSERT(funcProperties->getProperty(compare ,PR_TID_DEPEND)); // sanity
			if (!funcProperties->getProperty(compare->getOperand(0) ,PR_TID_VALS_CONSECUTIVE)) 
			{
				V_PRINT("\t\tFailed! TID dependent values are not consecutive...\n");
				return false; // must have ID sequentiality
			}
			// If the LHS is tid-dependent, make sure that the early exit is due to LHS being bigger than a constant value...
			if (!compare->isRelational())
			{
				V_PRINT("\t\tFailed! TID dependent compare is for equality. Unsupported...\n");
				return false; // An equality compare - not supported
			}
			bool isBiggerPred = (pred == CmpInst::ICMP_UGT || pred == CmpInst::ICMP_UGE || 
								 pred == CmpInst::ICMP_SGT || pred == CmpInst::ICMP_SGE);
			// If testing that TIDInst is bigger than const, early exit must be on TRUE (and vice-versa)
			if (isBiggerPred != branchSideToEarlyExitIsTrue) 
			{
				V_PRINT("\t\tFailed! Early exiting if the TID is SMALLER than some constant...\n");
				return false; // Exit early on TIDValue smaller than const...
			}
		}
	}
	
	// Reaching here, all the compares of the early exit branch are legal. Replace them with appropriate fake functions
	for (unsigned i = 0; i < earlyExitConditionals.size(); ++i)
	{
		replaceEarlyExit(earlyExitConditionals[i], branchSideToEarlyExitIsTrue);
	}	
	
	// Collapse the original early exit branch, and erase the compare instruction/s
	// Prepare for merging the basic blocks
	BasicBlock * successorBlock, * branchToExitBlock;
	if (branchSideToEarlyExitIsTrue)
	{
		successorBlock = condBranch->getSuccessor(1);
		branchToExitBlock = condBranch->getSuccessor(0);
	}
	else
	{
		successorBlock = condBranch->getSuccessor(0);
		branchToExitBlock = condBranch->getSuccessor(1);
	}
	
	// Replace the conditional branch with unconditional
	BranchInst::Create(successorBlock, condBranch);
	funcProperties->setProperty(condBranch, PR_INST_IS_REMOVED);
	condBranch->dropAllReferences();
	condBranch->eraseFromParent();
	
	
	// Instructions that are no longer needed (compares, ORs, ANDs) are marked for deletion (will be deleted in vectorization phase)
	for (unsigned i = 0; i < instsToRemove.size(); ++i)
	{
		funcProperties->setProperty(instsToRemove[i], PR_FUNC_PREP_TO_REMOVE);
	}
	
	// Erase the conditional destination block that leads to exit block - if has no more predecessors
	if (pred_begin(branchToExitBlock) == pred_end(branchToExitBlock))
		DeleteDeadBlock(branchToExitBlock);
		
	// merge the continuation block into the head block
	bool mergeBlocksStatus = MergeBlockIntoPredecessor(successorBlock);
	
	if (mergeBlocksStatus)
	{
		V_PRINT("\tEarly Exit collapsing successful!\n");
	}
	else
	{
		V_PRINT("\tEarly Exit collapsing successful, but failed to merge the direct-jump!\n");
	}
	return true;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// Fill conditionalsList with compare instructions which are early exits.
// For conditionals which are ANDed or ORed, list their root conditionals. return FALSE if roots
// are not proper (supported) conditionals
/////////////////////////////////////////////////////////////////////////////////////////////////////
bool HandleControlFlow::searchUpConditional(Value * rootCondition, bool isEarlyExitOnTrueSize, SmallVectorImpl<ICmpInst*> &conditionalsList, SmallVectorImpl<Instruction*> &instsToRemove)
{
	if (!isa<Instruction>(rootCondition)) return false; // completely constant conditionals are not considered early exit
	Instruction * rootInst = cast<Instruction>(rootCondition);
	if (rootInst->hasNUses(1))
	{
		// If this instruction has only one usage - its for the early exit. So this inst will eventually have to be removed
		instsToRemove.push_back(rootInst);
	}
	
	if (isa<ICmpInst>(rootInst))
	{
		// conditional is a proper compare. No need to root backwards...
		conditionalsList.push_back(cast<ICmpInst>(rootInst));
		return true;
	}
	else if (rootInst->getOpcode() == Instruction::And)  // Check for AND of conditionals. 
	{
		// If we AND early exits, then we actually AND "non-early-exits", so the early exit must be on the FALSE side of the compare
		if (isEarlyExitOnTrueSize == true)
		{
			V_PRINT("\tFailed rooting early exit conditional. Early exiting only if both sub-conditions are met?!?...\n");
			return false;
		}
		// recursively root for conditionals 
		if (searchUpConditional(rootInst->getOperand(0), true, conditionalsList, instsToRemove) && 
			searchUpConditional(rootInst->getOperand(1), true, conditionalsList, instsToRemove)) 
		{
			return true;
		}
		return false;
	}
	else if (rootInst->getOpcode() == Instruction::Or)  // Check for OR of conditionals. 
	{
		// If we OR early exits, then we can early exit if any of the sub-conditionals are true
		if (isEarlyExitOnTrueSize == false)
		{
			V_PRINT("\tFailed rooting early exit conditional. Early exiting only if neither sub-conditions are met?!?...\n");
			return false;
		}
		// recursively root for conditionals 
		if (searchUpConditional(rootInst->getOperand(0), false, conditionalsList, instsToRemove) && 
			searchUpConditional(rootInst->getOperand(1), false, conditionalsList, instsToRemove)) 
		{
			return true;
		}
		return false;
	}
	else
	{
		// Reached an unsupported conditional instruction
		V_PRINT("\tFailed rooting early exit conditional. Instruction is: " << *rootInst << "\n");
		return false;
	}
}



static unsigned staticIndex = 0;
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Replace early exit code section with Fake special case function
/////////////////////////////////////////////////////////////////////////////////////////////////////
void HandleControlFlow::replaceEarlyExit(ICmpInst * compare, bool earlyExitIsTrue)
{
	bool hasIdDep = funcProperties->getProperty(compare ,PR_TID_DEPEND);
	
	// Obtain proper "fake" early-exit function
	std::stringstream fakeFuncStream;
	fakeFuncStream << EARLY_EXIT_FAKE_NAME_PREFIX << (earlyExitIsTrue? 1 : 0) << "_" << (char)(compare->getPredicate());
	fakeFuncStream << "_" << (char)staticIndex++;
	V_PRINT("\tUsing fake function: " << fakeFuncStream.str() << "\n");
	
	// Declare or use if already declared, the fake function
	Constant * fakeEarlyExitFunc = CURRENT_MODULE->getFunction(fakeFuncStream.str());
	if (!fakeEarlyExitFunc)
	{
		// Function was not declared yet. First create the needed prototype...
		std::vector<const Type *> funcArgs(2, compare->getOperand(0)->getType());
		FunctionType * earlyExitFuncType = FunctionType::get(getVoidTy, funcArgs, false);
		fakeEarlyExitFunc = CURRENT_MODULE->getOrInsertFunction(fakeFuncStream.str(), earlyExitFuncType);
		funcProperties->addFakeFunctionToList(cast<Function>(fakeEarlyExitFunc));
	}
	V_ASSERT(fakeEarlyExitFunc);
	
	// Prepare arguments for fake function call
	std::vector<Value *> newArgs;
	newArgs.push_back(compare->getOperand(0));
	newArgs.push_back(compare->getOperand(1));
	
	// generate call to fake function
	Instruction * fakeEarlyExitCall = CallInst::Create(fakeEarlyExitFunc, newArgs.begin(), newArgs.end(), "", compare);
	funcProperties->duplicateProperties(fakeEarlyExitCall, compare); 
	funcProperties->setProperty(fakeEarlyExitCall, PR_SPECIAL_CASE_BUILT_IN);
	funcProperties->setProperty(fakeEarlyExitCall, PR_NO_SIDE_EFFECT);
	funcProperties->setProperty(fakeEarlyExitCall, PR_SC_BOUNDARY_CHECK);
	if (hasIdDep) 
		funcProperties->setProperty(fakeEarlyExitCall, PR_TID_VALS_CONSECUTIVE);
		
	// Mark the function as having an early exit
	if (hasIdDep) 
	{
		funcProperties->setFuncProperty(FUNC_HAS_TID_DEPEND_EARLY_EXITS);
	}
	else
	{
		funcProperties->setFuncProperty(FUNC_HAS_INDEPENDENT_EARLY_EXITS);
	}
}

