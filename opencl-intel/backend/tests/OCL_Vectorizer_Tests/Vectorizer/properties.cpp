/*********************************************************************************************
 * Copyright Â© 2010, Intel Corporation
 * Subject to the terms and conditions of the Master Development License
 * Agreement between Intel and Apple dated August 26, 2005; under the Intel
 * CPU Vectorizer for OpenCL Category 2 PA License dated January 2010; and RS-NDA #58744
 *********************************************************************************************/
#include "properties.h"


/////////////////////////////////////////////////////////////////////////////////////////////////////
// CodeProperties object constructor
/////////////////////////////////////////////////////////////////////////////////////////////////////
CodeProperties::CodeProperties(Module *targetModule, const Module *runtimeMod, Function * currFunc, unsigned archVectorWidth): 
	currentModule(targetModule),
	runtimeModule(runtimeMod),
	currentFunction(currFunc)
{
	moduleContext = &(currentModule->getContext());
	m_archVectorWidth = archVectorWidth;
	functionProperties = 0;
	TIDSetter_iterator = 0;
	PseudoDependentInsts_iterator = 0;
	FakeFunctions_iterator = 0;
	V_PRINT("properties constructor\n");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// CodeProperties object destructor
/////////////////////////////////////////////////////////////////////////////////////////////////////
CodeProperties::~CodeProperties()
{
	V_PRINT("properties ");
	// Free allocations which are stored in special-case lists 
	DenseMap<Instruction*,ValueList*>::iterator iter, iterEnd;
	for (iter = specialCaseListsMap.begin(), iterEnd = specialCaseListsMap.end(); iter != iterEnd; ++iter)
	{
		ValueList * currList = iter->second;
		if (currList != NULL)
		{
			delete currList; // delete valueList
		}
	}
	
	V_PRINT("... ");
	// Free allocations of scalarizable Functions list
	for (iter = scalarizableFunctionsMap.begin(), iterEnd = scalarizableFunctionsMap.end(); iter != iterEnd; ++iter)
	{
		ValueList * currList = iter->second;
		if (currList != NULL)
		{
			delete currList; // delete valueList
		}
	}	
	V_PRINT("destructor\n");
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Return TRUE if property exist for given Value/Instruction
/////////////////////////////////////////////////////////////////////////////////////////////////////
bool CodeProperties::getProperty(Value * inst, instProperty prop)
{
	if (!propertiesMap.count(inst)) return false;
	
	return (propertiesMap[inst] & prop);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Return TRUE if any of the given properties exist for given Value/Instruction
/////////////////////////////////////////////////////////////////////////////////////////////////////
bool CodeProperties::getAnyProperty(Value * inst, instProperty properties)
{
	if (!propertiesMap.count(inst)) return false;
	
	return (propertiesMap[inst] & properties);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Returns several properties of given Value/Instruction, according to mask
/////////////////////////////////////////////////////////////////////////////////////////////////////
instProperty CodeProperties::getPropertyGroup(Value * inst, instProperty propertyMask)
{
	if (propertiesMap.count(inst))
		return propertiesMap[inst] & propertyMask;
	else
		return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set property for given Value/Instruction
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setProperty(Value * inst, instProperty prop)
{
	if (!propertiesMap.count(inst)) 
	{
		propertiesMap[inst] = prop;
	}
	else
	{
		propertiesMap[inst] |= prop;
	}	
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Clear a specific property from given Value/Instruction
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::clearProperty(Value * inst, instProperty prop)
{
	propertiesMap[inst] &= ~((instProperty)prop);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Duplicate all properties from one Value to another
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::duplicateProperties(Value * dst, Value * src)
{
	propertiesMap[dst] = 0; // initialize the value, if not existing already
	propertiesMap[dst] = propertiesMap[src];
	clearProperty(dst, PR_INST_IS_REMOVED);
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// return TRUE if function holds the given function-property
/////////////////////////////////////////////////////////////////////////////////////////////////////
bool CodeProperties::getFuncProperty(funcProperty prop)
{
	return (functionProperties & prop);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set a given function-property
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setFuncProperty(funcProperty prop)
{
	functionProperties |= prop;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// Add instruction to list of TID setters
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::addToTIDSettersList(Instruction * inst)
{
	setProperty(inst, PR_APPEARS_IN_LISTS);
	TIDSetters.push_back(inst);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// TID setters iterator: get first from list
/////////////////////////////////////////////////////////////////////////////////////////////////////
Instruction * CodeProperties::firstTIDSetterFromList()
{
	TIDSetter_iterator = 0;
	return nextTIDSetterFromList();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// TID setters iterator: get next from list
/////////////////////////////////////////////////////////////////////////////////////////////////////
Instruction * CodeProperties::nextTIDSetterFromList()
{
	if (TIDSetters.size() <= TIDSetter_iterator) return NULL;
	return TIDSetters[TIDSetter_iterator++];
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Add instruction to list of PseudoDependent instructions
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::addToPseudoDependentList(Instruction * inst)
{
	setProperty(inst, PR_APPEARS_IN_LISTS);
	PseudoDependentInsts.push_back(inst);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// PseudoDependent iterator: get first from list
/////////////////////////////////////////////////////////////////////////////////////////////////////
Instruction * CodeProperties::firstPseudoDependentFromList()
{
	PseudoDependentInsts_iterator = 0;
	return nextPseudoDependentFromList();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// PseudoDependent iterator: get next from list
/////////////////////////////////////////////////////////////////////////////////////////////////////
Instruction * CodeProperties::nextPseudoDependentFromList()
{
	if (PseudoDependentInsts.size() <= PseudoDependentInsts_iterator) return NULL;
	return PseudoDependentInsts[PseudoDependentInsts_iterator++];
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// Add fake function to list of of fake functions in module
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::addFakeFunctionToList(Function * func)
{
	FakeFunctions.push_back(func);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// fake functions iterator: get first from list
/////////////////////////////////////////////////////////////////////////////////////////////////////
Function * CodeProperties::firstFakeFunctionFromList()
{
	FakeFunctions_iterator = 0;
	return nextFakeFunctionFromList();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Fake functions iterator: get next from list
/////////////////////////////////////////////////////////////////////////////////////////////////////
Function * CodeProperties::nextFakeFunctionFromList()
{
	if (FakeFunctions.size() <= FakeFunctions_iterator) return NULL;
	return FakeFunctions[FakeFunctions_iterator++];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Fake functions iterator: clear the fake fuction entry on which the iterator is currently standing
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::clearFakeFunctionFromList()
{
	V_ASSERT(FakeFunctions_iterator > 0);
	FakeFunctions[FakeFunctions_iterator-1] = (Function *)-1;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// Add arguments list, for a given Special-case function call
/////////////////////////////////////////////////////////////////////////////////////////////////////
bool CodeProperties::setSCList(Instruction * inst, SmallVectorImpl<Value *> *list)
{
	if (specialCaseListsMap.count(inst)) return false;
	setProperty(inst, PR_APPEARS_IN_LISTS);
	for (unsigned i = 0; i < list->size(); i++)
	{
		setProperty((*list)[i], PR_APPEARS_IN_LISTS);
	}
	specialCaseListsMap[inst] = list;
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Obtain arguments list, for a given Special-case function call
/////////////////////////////////////////////////////////////////////////////////////////////////////
SmallVectorImpl<Value *> * CodeProperties::getSCList(Instruction * inst)
{
	if (!specialCaseListsMap.count(inst)) return NULL;
	return specialCaseListsMap[inst];
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Add arguments list, for a given built-in function call
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setScalarizableFunc(Instruction * callInst, SmallVectorImpl<Value *> *list)
{
	V_ASSERT(list != NULL);
	setProperty(callInst, PR_APPEARS_IN_LISTS);
	for (unsigned i = 0; i < list->size(); i++)
	{
		setProperty((*list)[i], PR_APPEARS_IN_LISTS);
	}
	scalarizableFunctionsMap[callInst] = list;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Obtain arguments list, for a given built-in function call
/////////////////////////////////////////////////////////////////////////////////////////////////////
SmallVectorImpl<Value *> * CodeProperties::getScalarizableList(Instruction * inst)
{
	if (!scalarizableFunctionsMap.count(inst)) return NULL;
	return scalarizableFunctionsMap[inst];
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set RET instruction of function
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setRetInst(Instruction * inst)
{
	retInst = inst;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get RET instruction of function
/////////////////////////////////////////////////////////////////////////////////////////////////////
Instruction * CodeProperties::getRetInst()
{
	return retInst;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set iteration-count instruction of function's mega-loop
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setIterCountInst(Instruction * inst)
{
	iterCount = inst;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get iteration-count instruction of function's mega-loop
/////////////////////////////////////////////////////////////////////////////////////////////////////
Instruction * CodeProperties::getIterCountInst()
{
	return iterCount;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set Loop-size instruction/Value of function's mega-loop
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setLoopSizeVal(Instruction * inst)
{
	loopSize = inst;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get Loop-size instruction/Value of function's mega-loop
/////////////////////////////////////////////////////////////////////////////////////////////////////
Instruction * CodeProperties::getLoopSizeVal()
{
	return loopSize;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set exit-block for early exits
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setExitBlock(BasicBlock * block)
{
	exitBlock = block;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get exit-block for early exits
/////////////////////////////////////////////////////////////////////////////////////////////////////
BasicBlock * CodeProperties::getExitBlock()
{
	return exitBlock;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set remainder-block for early exits
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setRemainderBlock(BasicBlock * block)
{
	remainderBlock = block;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get remainder-block for early exits
/////////////////////////////////////////////////////////////////////////////////////////////////////
BasicBlock * CodeProperties::getRemainderBlock()
{
	return remainderBlock;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Set scalar-loop-block for early exits
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::setScalarLoopBlock(BasicBlock * block)
{
	scalarLoopBlock = block;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get scalar-loop-block for early exits
/////////////////////////////////////////////////////////////////////////////////////////////////////
BasicBlock * CodeProperties::getScalarLoopBlock()
{
	return scalarLoopBlock;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// When replacing one instruction with another, move all properties to the new instruction
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CodeProperties::replaceAllInstProperties(Instruction * src, Instruction * dst)
{
	V_PRINT("\tReplacing properties of:   " << *src);
	V_PRINT("\t  With:   " << *dst << "\n");
	propertiesMap[dst] = 0; // initialize the value, if not existing already
	propertiesMap[dst] = propertiesMap[src];

	// If Instruction appears in other lists as well, Need to replace it...
	if (getProperty(src, PR_APPEARS_IN_LISTS))
	{	
		V_PRINT("\t  Appears in other lists as well\n");
		// Check in TID-setters list
		for (unsigned i = 0; i < TIDSetters.size(); i++)
		{
			if (TIDSetters[i] == src)
			{
				TIDSetters[i] = dst;
				V_PRINT("\t  Replaced in TID setters list\n");
			}
		}
		
		// Check in PseudoDependent list
		for (unsigned i = 0; i < PseudoDependentInsts.size(); i++)
		{
			if (PseudoDependentInsts[i] == src) 
			{
				PseudoDependentInsts[i] = dst;
				V_PRINT("\t  Replaced in PseudoDependent list\n");
			}
		}
		
		// Check special-case list
		DenseMap<Instruction*,ValueList*>::iterator iter, iterEnd;
		for (iter = specialCaseListsMap.begin(), iterEnd = specialCaseListsMap.end(); iter != iterEnd; ++iter)
		{
			ValueList * currList = iter->second;
			for (unsigned i = 0; i < currList->size(); i++)
			{
				if ((*currList)[i] == src) 
				{
					(*currList)[i] = dst;
					V_PRINT("\t  Replaced in SC list of another instruction\n");
				}
			}
		}
		if (specialCaseListsMap.count(src))
		{
			setSCList(dst, specialCaseListsMap[src]);
			specialCaseListsMap.erase(src);
			V_PRINT("\t  Held an SC list. Copied.\n");
		}
		
		// Check scalarizable-functions list
		DenseMap<Instruction*,ValueList*>::iterator iter2, iterEnd2;
		for (iter2 = scalarizableFunctionsMap.begin(), iterEnd2 = scalarizableFunctionsMap.end(); iter2 != iterEnd2; ++iter2)
		{
			ValueList * currList = iter2->second;
			V_ASSERT(currList != NULL);
			for (unsigned i = 0; i < currList->size(); i++)
			{
				if ((*currList)[i] == src) 
				{
					(*currList)[i] = dst;
					V_PRINT("\t  Replaced in Scalarizable funcs list of another instruction\n");
				}
			}
		}
		if (scalarizableFunctionsMap.count(src))
		{
			setScalarizableFunc(dst, scalarizableFunctionsMap[src]);
			scalarizableFunctionsMap.erase(src);
			V_PRINT("\t  Held a scalarizable func list. Copied.\n");
		}
	}

	// check if this is the ret inst
	if (src == retInst) retInst = dst;
		
	V_PRINT("\tDone Replacing properties \n");
}




