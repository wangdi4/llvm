; NOTE: Assertions have been autogenerated by utils/intel_update_vplan_checks.py
; RUN: %oclopt %s -enable-vector-variant-passes -vector-variant-lowering -VPlanDriver -vplan-force-vf=2 -mtriple x86_64-unknown-linux-gnu -S | FileCheck %s

; Test that we are able to vectorize the function after vector-variants attributes processing.

%"class.cl::sycl::intel::SimdFunction" = type { %"struct.std::array" }
%"struct.std::array" = type { [2 x i32 (i32, float)*] }

define dso_local i32 @_Z3barPii(i32* nocapture readnone %a, i32 %n) {
; CHECK:  define dso_local i32 @_Z3barPii(i32* nocapture readnone [[A0:%.*]], i32 [[N0:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[FOO_SIMD0:%.*]] = alloca %"class.cl::sycl::intel::SimdFunction", align 8
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast %"class.cl::sycl::intel::SimdFunction"* [[FOO_SIMD0]] to i8*
; CHECK-NEXT:    [[TMP1:%.*]] = tail call i32 (i32, float)* @llvm.create.simd.variant.p0f_i32i32f32f.p0f_i32i32f32f(i32 (i32, float)* nonnull @_Z3fooif) #1
; CHECK-NEXT:    [[TMP2:%.*]] = tail call i32 (i32, float)* @llvm.create.simd.variant.p0f_i32i32f32f.p0f_i32i32f32f(i32 (i32, float)* nonnull @_Z3fooif) #2
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds %"class.cl::sycl::intel::SimdFunction", %"class.cl::sycl::intel::SimdFunction"* [[FOO_SIMD0]], i64 0, i32 0, i32 0, i64 0
; CHECK-NEXT:    store i32 (i32, float)* [[TMP1]], i32 (i32, float)** [[TMP3]], align 8
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds %"class.cl::sycl::intel::SimdFunction", %"class.cl::sycl::intel::SimdFunction"* [[FOO_SIMD0]], i64 0, i32 0, i32 0, i64 1
; CHECK-NEXT:    store i32 (i32, float)* [[TMP2]], i32 (i32, float)** [[TMP4]], align 8
; CHECK-NEXT:    [[CMP0:%.*]] = icmp sgt i32 [[N0]], 0
; CHECK-NEXT:    br i1 [[CMP0]], label [[DIR_OMP_SIMD_20:%.*]], label [[OMP_PRECOND_END0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.SIMD.2:
; CHECK-NEXT:    br label [[DIR_OMP_SIMD_10:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.SIMD.1:
; CHECK-NEXT:    [[PTRS_I0:%.*]] = getelementptr inbounds %"class.cl::sycl::intel::SimdFunction", %"class.cl::sycl::intel::SimdFunction"* [[FOO_SIMD0]], i64 0, i32 0
; CHECK-NEXT:    [[N_MOD_VF0:%.*]] = urem i32 [[N0]], 2
; CHECK-NEXT:    [[N_VEC0:%.*]] = sub i32 [[N0]], [[N_MOD_VF0]]
; CHECK-NEXT:    [[CMP_ZERO0:%.*]] = icmp eq i32 [[N_VEC0]], 0
; CHECK-NEXT:    br i1 [[CMP_ZERO0]], label [[SCALAR_PH0:%.*]], label [[VECTOR_PH0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.ph:
; CHECK-NEXT:    br label [[VECTOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  vector.body:
; CHECK-NEXT:    [[UNI_PHI0:%.*]] = phi i32 [ 0, [[VECTOR_PH0]] ], [ [[TMP11:%.*]], [[VECTOR_BODY0]] ]
; CHECK-NEXT:    [[UNI_PHI10:%.*]] = phi i32 [ [[TMP10:%.*]], [[VECTOR_BODY0]] ], [ 0, [[VECTOR_PH0]] ]
; CHECK-NEXT:    [[VEC_PHI0:%.*]] = phi <2 x i32> [ [[TMP9:%.*]], [[VECTOR_BODY0]] ], [ <i32 0, i32 1>, [[VECTOR_PH0]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 (i32, float)** @_ZNKSt5arrayIPFiifELm2EE4dataEv(%"struct.std::array"* {{(nonnull )?}}[[PTRS_I0]])
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 (i32, float)** @_ZNKSt5arrayIPFiifELm2EE4dataEv(%"struct.std::array"* {{(nonnull )?}}[[PTRS_I0]])
; CHECK-NEXT:    [[TMP7:%.*]] = call i32 (i32 (i32, float)**, ...) @llvm.indirect.call.i32.p0p0f_i32i32f32f(i32 (i32, float)** [[TMP5]], i32 5, float 2.000000e+00)
; CHECK-NEXT:    [[TMP8:%.*]] = call i32 (i32 (i32, float)**, ...) @llvm.indirect.call.i32.p0p0f_i32i32f32f(i32 (i32, float)** [[TMP6]], i32 5, float 2.000000e+00)
; CHECK-NEXT:    [[TMP9]] = add nuw nsw <2 x i32> [[VEC_PHI0]], <i32 2, i32 2>
; CHECK-NEXT:    [[TMP10]] = add nuw nsw i32 [[UNI_PHI10]], 2
; CHECK-NEXT:    [[TMP11]] = add i32 [[UNI_PHI0]], 2
; CHECK-NEXT:    [[TMP12:%.*]] = icmp eq i32 [[TMP11]], [[N_VEC0]]
; CHECK-NEXT:    br i1 [[TMP12]], label [[VPLANNEDBB0:%.*]], label [[VECTOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  VPlannedBB:
; CHECK-NEXT:    [[TMP13:%.*]] = mul i32 1, [[N_VEC0]]
; CHECK-NEXT:    [[TMP14:%.*]] = add i32 0, [[TMP13]]
; CHECK-NEXT:    br label [[MIDDLE_BLOCK0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  middle.block:
; CHECK-NEXT:    [[CMP_N0:%.*]] = icmp eq i32 [[N0]], [[N_VEC0]]
; CHECK-NEXT:    br i1 [[CMP_N0]], label [[DIR_OMP_END_SIMD_30:%.*]], label [[SCALAR_PH0]]
; CHECK-EMPTY:
; CHECK-NEXT:  scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL0:%.*]] = phi i32 [ 0, [[DIR_OMP_SIMD_10]] ], [ [[TMP14]], [[MIDDLE_BLOCK0]] ]
; CHECK-NEXT:    br label [[OMP_INNER_FOR_BODY0:%.*]]
; CHECK-EMPTY:
; CHECK-NEXT:  omp.inner.for.body:
; CHECK-NEXT:    [[DOTOMP_IV_LOCAL_0190:%.*]] = phi i32 [ [[ADD90:%.*]], [[OMP_INNER_FOR_BODY0]] ], [ [[BC_RESUME_VAL0]], [[SCALAR_PH0]] ]
; CHECK-NEXT:    [[CALL_I0:%.*]] = call i32 (i32, float)** @_ZNKSt5arrayIPFiifELm2EE4dataEv(%"struct.std::array"* nonnull [[PTRS_I0]])
; CHECK-NEXT:    [[TMP15:%.*]] = call i32 (i32 (i32, float)**, ...) @llvm.indirect.call.i32.p0p0f_i32i32f32f(i32 (i32, float)** [[CALL_I0]], i32 5, float 2.000000e+00) #3
; CHECK-NEXT:    [[ADD90]] = add nuw nsw i32 [[DOTOMP_IV_LOCAL_0190]], 1
; CHECK-NEXT:    [[EXITCOND0:%.*]] = icmp eq i32 [[ADD90]], [[N0]]
; CHECK-NEXT:    br i1 [[EXITCOND0]], label [[DIR_OMP_END_SIMD_30]], label [[OMP_INNER_FOR_BODY0]]
; CHECK-EMPTY:
; CHECK-NEXT:  DIR.OMP.END.SIMD.3:
; CHECK-NEXT:    br label [[OMP_PRECOND_END0]]
; CHECK-EMPTY:
; CHECK-NEXT:  omp.precond.end:
; CHECK-NEXT:    ret i32 0
; CHECK-NEXT:  }
;
entry:
  %foo_simd = alloca %"class.cl::sycl::intel::SimdFunction", align 8
  %0 = bitcast %"class.cl::sycl::intel::SimdFunction"* %foo_simd to i8*
  %1 = tail call i32 (i32, float)* @llvm.create.simd.variant.p0f_i32i32f32f.p0f_i32i32f32f(i32 (i32, float)* nonnull @_Z3fooif) #1
  %2 = tail call i32 (i32, float)* @llvm.create.simd.variant.p0f_i32i32f32f.p0f_i32i32f32f(i32 (i32, float)* nonnull @_Z3fooif) #2
  %3 = getelementptr inbounds %"class.cl::sycl::intel::SimdFunction", %"class.cl::sycl::intel::SimdFunction"* %foo_simd, i64 0, i32 0, i32 0, i64 0
  store i32 (i32, float)* %1, i32 (i32, float)** %3, align 8
  %4 = getelementptr inbounds %"class.cl::sycl::intel::SimdFunction", %"class.cl::sycl::intel::SimdFunction"* %foo_simd, i64 0, i32 0, i32 0, i64 1
  store i32 (i32, float)* %2, i32 (i32, float)** %4, align 8
  %cmp = icmp sgt i32 %n, 0
  br i1 %cmp, label %DIR.OMP.SIMD.2, label %omp.precond.end

DIR.OMP.SIMD.2:                                   ; preds = %entry
  %5 = call token @llvm.directive.region.entry() [ "DIR.OMP.SIMD"(), "QUAL.OMP.NORMALIZED.IV"(i8* null), "QUAL.OMP.NORMALIZED.UB"(i8* null) ]
  br label %DIR.OMP.SIMD.1

DIR.OMP.SIMD.1:                                   ; preds = %DIR.OMP.SIMD.2
  %ptrs.i = getelementptr inbounds %"class.cl::sycl::intel::SimdFunction", %"class.cl::sycl::intel::SimdFunction"* %foo_simd, i64 0, i32 0 ;, !intel-tbaa !2
  br label %omp.inner.for.body

omp.inner.for.body:                               ; preds = %omp.inner.for.body, %DIR.OMP.SIMD.1
  %.omp.iv.local.019 = phi i32 [ %add9, %omp.inner.for.body ], [ 0, %DIR.OMP.SIMD.1 ]
  %call.i = call i32 (i32, float)** @_ZNKSt5arrayIPFiifELm2EE4dataEv(%"struct.std::array"* nonnull %ptrs.i)
  %6 = call i32 (i32 (i32, float)**, ...) @llvm.indirect.call.i32.p0p0f_i32i32f32f(i32 (i32, float)** %call.i, i32 5, float 2.000000e+00) #3
  %add9 = add nuw nsw i32 %.omp.iv.local.019, 1
  %exitcond = icmp eq i32 %add9, %n
  br i1 %exitcond, label %DIR.OMP.END.SIMD.3, label %omp.inner.for.body

DIR.OMP.END.SIMD.3:                               ; preds = %omp.inner.for.body
  call void @llvm.directive.region.exit(token %5) [ "DIR.OMP.END.SIMD"() ]
  br label %omp.precond.end

omp.precond.end:                                  ; preds = %DIR.OMP.END.SIMD.3, %entry
  ret i32 0
}

declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)

declare dso_local i32 @_Z3fooif(i32 %i, float %f)

declare dso_local i32 (i32, float)** @_ZNKSt5arrayIPFiifELm2EE4dataEv(%"struct.std::array"*)

declare i32 (i32, float)* @llvm.create.simd.variant.p0f_i32i32f32f.p0f_i32i32f32f(i32 (i32, float)*)

declare i32 @llvm.indirect.call.i32.p0p0f_i32i32f32f(i32 (i32, float)**, ...)

attributes #1 = { nounwind "vector-variant"="_ZGVxN0lu__Z3fooif" }
attributes #2 = { nounwind "vector-variant"="_ZGVxM0vv__Z3fooif" }
attributes #3 = { nounwind "vector-variants"="_ZGVxN0lu_XXX,_ZGVxM0vv_XXX" }
