; RUN: opt -runtimelib %p/../Full/runtime.bc -runtime=rs -builtin-import -rsVec %s -S  -o - \
; RUN: | FileCheck %s 

; CHECK-NOT: @__Vectorized_.list_create.wrapper.indexed
; CHECK: @__Vectorized_.list_reset.wrapper.indexed
; CHECK-NOT: @__Vectorized_.list_create.wrapper.indexed
; CHECK !0 = metadata

target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:64:128-a0:0:64-n32-S64"
target triple = "armv7-none-linux-gnueabi"

%struct.rs_allocation = type <{ i32* }>
%struct.Allocation = type { [32 x i8], %struct.anon }
%struct.anon = type { i8*, %struct.anon.0, %struct.DrvState }
%struct.anon.0 = type { i8*, i32, i32, i32, i32, i8, i8, i8, i8*, i32, i8*, i64 }
%struct.DrvState = type { [16 x %struct.LodState], i32, i32, i32, %struct.YuvState }
%struct.LodState = type { i8*, i32, i32, i32, i32 }
%struct.YuvState = type { i32, i32 }
%struct.Element = type { [32 x i8], %struct.anon.1 }
%struct.anon.1 = type { i8*, %struct.anon.0.0 }
%struct.anon.0.0 = type { i32, i32, i32, i32, i8**, i32*, i8**, i32*, i32*, i32 }
%struct.Mesh = type { [32 x i8], %struct.anon.3 }
%struct.anon.3 = type { i8*, %struct.anon.0.2 }
%struct.anon.0.2 = type { i8**, i32, i8**, i32, i32*, i32 }
%struct.rs_matrix4x4 = type { [16 x float] }
%struct.rs_matrix3x3 = type { [9 x float] }
%struct.rs_matrix2x2 = type { [4 x float] }
%struct.ProgramStore = type { [40 x i8], %struct.anon.5 }
%struct.anon.5 = type { %struct.anon.0.4 }
%struct.anon.0.4 = type { i8, i8, i8, i8, i8, i32, i32, i8, i32 }
%struct.ProgramRaster = type { [36 x i8], %struct.anon.1.6 }
%struct.anon.1.6 = type { i8*, %struct.anon.2 }
%struct.anon.2 = type { i8, i32 }
%struct.Sampler = type { [32 x i8], %struct.anon.1.14 }
%struct.anon.1.14 = type { i8*, %struct.anon.2.13 }
%struct.anon.2.13 = type { i32, i32, i32, i32, i32, float }

@particleRadius = global float 1.562500e-02, align 4
@gridSize = global i32 32, align 4
@pHList = common global i32* null, align 4
@allocPList = common global %struct.rs_allocation zeroinitializer, align 4
@allocPos = common global %struct.rs_allocation zeroinitializer, align 4

; Function Attrs: alwaysinline nounwind readnone
define i32 @list_reset(i32 %x) #0 {
  ret i32 -1
}

; Function Attrs: alwaysinline nounwind
define i32 @list_create(<4 x float> %in, i32 %x) #1 {
  %1 = extractelement <4 x float> %in, i32 0
  %2 = load float, float* @particleRadius, align 4, !tbaa !18
  %3 = fmul float %2, 2.000000e+00
  %4 = fdiv float %1, %3
  %5 = fptosi float %4 to i32
  %6 = icmp sgt i32 %5, 0
  %7 = select i1 %6, i32 %5, i32 0
  %8 = load i32, i32* @gridSize, align 4, !tbaa !21
  %9 = add nsw i32 %8, -1
  %10 = icmp slt i32 %7, %9
  %11 = select i1 %10, i32 %7, i32 %9
  %12 = extractelement <4 x float> %in, i32 1
  %13 = fdiv float %12, %3
  %14 = fptosi float %13 to i32
  %15 = icmp sgt i32 %14, 0
  %16 = select i1 %15, i32 %14, i32 0
  %17 = icmp slt i32 %16, %9
  %18 = select i1 %17, i32 %16, i32 %9
  %19 = extractelement <4 x float> %in, i32 2
  %20 = fdiv float %19, %3
  %21 = fptosi float %20 to i32
  %22 = icmp sgt i32 %21, 0
  %23 = select i1 %22, i32 %21, i32 0
  %24 = icmp slt i32 %23, %9
  %25 = select i1 %24, i32 %23, i32 %9
  %26 = mul nsw i32 %25, %8
  %27 = add i32 %26, %18
  %28 = mul i32 %27, %8
  %29 = add nsw i32 %28, %11
  %30 = load i32*, i32** @pHList, align 4, !tbaa !22
  %31 = getelementptr inbounds i32, i32* %30, i32 %29
  %32 = load i32, i32* %31, align 4, !tbaa !21
  br label %33

; <label>:33                                      ; preds = %33, %0
  %oldVal.0.i = phi i32 [ %32, %0 ], [ %34, %33 ]
  %atom_op = cmpxchg i32* %31, i32 %oldVal.0.i, i32 %x seq_cst seq_cst
  %34 = extractvalue { i32, i1 } %atom_op, 0
  %35 = icmp eq i32 %oldVal.0.i, %34
  br i1 %35, label %atomicXchg.exit, label %33

atomicXchg.exit:                                  ; preds = %33
  ret i32 %oldVal.0.i
}

; Function Attrs: nounwind
define void @.rs.dtor() #2 {
  tail call void @_Z13rsClearObjectP13rs_allocation(%struct.rs_allocation* @allocPList) #2
  tail call void @_Z13rsClearObjectP13rs_allocation(%struct.rs_allocation* @allocPos) #2
  ret void
}

declare void @_Z13rsClearObjectP13rs_allocation(%struct.rs_allocation*)

define i32 @get.id() {
  ret i32 0
}

; Function Attrs: alwaysinline
define void @list_reset.wrapper(i32*, i32 %x) #3 {
init:
  store i32 -1, i32* %0
  ret void
}

define void @list_reset.wrapper.indexed(i32*, i32 %x) {
init:
  %1 = call i32 @get.id()
  %outElement = getelementptr inbounds i32, i32* %0, i32 %1
  store i32 -1, i32* %outElement
  ret void
}

; Function Attrs: alwaysinline
define void @list_create.wrapper(<4 x float>* %pin, i32*, i32 %x) #3 {
init:
  %Input = load <4 x float>, <4 x float>* %pin
  %1 = extractelement <4 x float> %Input, i32 0
  %2 = load float, float* @particleRadius, align 4, !tbaa !18
  %3 = fmul float %2, 2.000000e+00
  %4 = fdiv float %1, %3
  %5 = fptosi float %4 to i32
  %6 = icmp sgt i32 %5, 0
  %7 = select i1 %6, i32 %5, i32 0
  %8 = load i32, i32* @gridSize, align 4, !tbaa !21
  %9 = add nsw i32 %8, -1
  %10 = icmp slt i32 %7, %9
  %11 = select i1 %10, i32 %7, i32 %9
  %12 = extractelement <4 x float> %Input, i32 1
  %13 = fdiv float %12, %3
  %14 = fptosi float %13 to i32
  %15 = icmp sgt i32 %14, 0
  %16 = select i1 %15, i32 %14, i32 0
  %17 = icmp slt i32 %16, %9
  %18 = select i1 %17, i32 %16, i32 %9
  %19 = extractelement <4 x float> %Input, i32 2
  %20 = fdiv float %19, %3
  %21 = fptosi float %20 to i32
  %22 = icmp sgt i32 %21, 0
  %23 = select i1 %22, i32 %21, i32 0
  %24 = icmp slt i32 %23, %9
  %25 = select i1 %24, i32 %23, i32 %9
  %26 = mul nsw i32 %25, %8
  %27 = add i32 %26, %18
  %28 = mul i32 %27, %8
  %29 = add nsw i32 %28, %11
  %30 = load i32*, i32** @pHList, align 4, !tbaa !22
  %31 = getelementptr inbounds i32, i32* %30, i32 %29
  %32 = load i32, i32* %31, align 4, !tbaa !21
  br label %33

; <label>:33                                      ; preds = %33, %init
  %oldVal.0.i.i = phi i32 [ %32, %init ], [ %34, %33 ]
  %atom_op = cmpxchg i32* %31, i32 %oldVal.0.i.i, i32 %x seq_cst seq_cst
  %34 = extractvalue { i32, i1 } %atom_op, 0
  %35 = icmp eq i32 %oldVal.0.i.i, %34
  br i1 %35, label %list_create.exit, label %33

list_create.exit:                                 ; preds = %33
  store i32 %oldVal.0.i.i, i32* %0
  ret void
}

define void @list_create.wrapper.indexed(<4 x float>* %pin, i32*, i32 %x) {
init:
  %1 = call i32 @get.id()
  %inElement = getelementptr inbounds <4 x float>, <4 x float>* %pin, i32 %1
  %outElement = getelementptr inbounds i32, i32* %0, i32 %1
  %currentX = add i32 %x, %1
  %Input.i = load <4 x float>, <4 x float>* %inElement
  %2 = extractelement <4 x float> %Input.i, i32 0
  %3 = load float, float* @particleRadius, align 4, !tbaa !18
  %4 = fmul float %3, 2.000000e+00
  %5 = fdiv float %2, %4
  %6 = fptosi float %5 to i32
  %7 = icmp sgt i32 %6, 0
  %8 = select i1 %7, i32 %6, i32 0
  %9 = load i32, i32* @gridSize, align 4, !tbaa !21
  %10 = add nsw i32 %9, -1
  %11 = icmp slt i32 %8, %10
  %12 = select i1 %11, i32 %8, i32 %10
  %13 = extractelement <4 x float> %Input.i, i32 1
  %14 = fdiv float %13, %4
  %15 = fptosi float %14 to i32
  %16 = icmp sgt i32 %15, 0
  %17 = select i1 %16, i32 %15, i32 0
  %18 = icmp slt i32 %17, %10
  %19 = select i1 %18, i32 %17, i32 %10
  %20 = extractelement <4 x float> %Input.i, i32 2
  %21 = fdiv float %20, %4
  %22 = fptosi float %21 to i32
  %23 = icmp sgt i32 %22, 0
  %24 = select i1 %23, i32 %22, i32 0
  %25 = icmp slt i32 %24, %10
  %26 = select i1 %25, i32 %24, i32 %10
  %27 = mul nsw i32 %26, %9
  %28 = add i32 %27, %19
  %29 = mul i32 %28, %9
  %30 = add nsw i32 %29, %12
  %31 = load i32*, i32** @pHList, align 4, !tbaa !22
  %32 = getelementptr inbounds i32, i32* %31, i32 %30
  %33 = load i32, i32* %32, align 4, !tbaa !21
  br label %34

; <label>:34                                      ; preds = %34, %init
  %oldVal.0.i.i.i = phi i32 [ %33, %init ], [ %35, %34 ]
  %35 = call i32 @cmpxchg.mock(i32* %32, i32 %oldVal.0.i.i.i, i32 %currentX)
  ;%36 = cmpxchg i32* %32, i32 %oldVal.0.i.i.i, i32 %currentX seq_cst
  %36 = icmp eq i32 %oldVal.0.i.i.i, %35
  br i1 %36, label %list_create.wrapper.exit, label %34

list_create.wrapper.exit:                         ; preds = %34
  store i32 %oldVal.0.i.i.i, i32* %outElement
  ret void
}

; Function Attrs: nounwind readonly
define i32 @_Z19rsAllocationGetDimX13rs_allocation([1 x i32] %a.coerce) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %4 = load i32, i32* %3, align 4, !tbaa !21
  ret i32 %4
}

; Function Attrs: nounwind readonly
define i32 @_Z19rsAllocationGetDimY13rs_allocation([1 x i32] %a.coerce) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %4 = load i32, i32* %3, align 4, !tbaa !21
  ret i32 %4
}

; Function Attrs: nounwind readonly
define i32 @_Z19rsAllocationGetDimZ13rs_allocation([1 x i32] %a.coerce) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 4
  %4 = load i32, i32* %3, align 4, !tbaa !21
  ret i32 %4
}

; Function Attrs: nounwind readonly
define i32 @_Z21rsAllocationGetDimLOD13rs_allocation([1 x i32] %a.coerce) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 5
  %4 = load i8, i8* %3, align 1, !tbaa !23, !range !24
  %5 = zext i8 %4 to i32
  ret i32 %5
}

; Function Attrs: nounwind readonly
define i32 @_Z23rsAllocationGetDimFaces13rs_allocation([1 x i32] %a.coerce) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 6
  %4 = load i8, i8* %3, align 1, !tbaa !23, !range !24
  %5 = zext i8 %4 to i32
  ret i32 %5
}

; Function Attrs: nounwind readonly
define i32 @_Z22rsAllocationGetElement13rs_allocation([1 x i32] %a.coerce) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %10, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Allocation*
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %4, i32 0, i32 1, i32 1, i32 0
  %6 = load i8*, i8** %5, align 4, !tbaa !22
  %7 = getelementptr inbounds i8, i8* %6, i32 36
  %8 = bitcast i8* %7 to i8**
  %9 = load i8*, i8** %8, align 4, !tbaa !22
  %phitmp = ptrtoint i8* %9 to i32
  br label %10

; <label>:10                                      ; preds = %3, %0
  %.sroa.0.0 = phi i32 [ %phitmp, %3 ], [ 0, %0 ]
  ret i32 %.sroa.0.0
}

; Function Attrs: nounwind readonly
define i8* @rsOffset([1 x i32] %a.coerce, i32 %sizeOf, i32 %x, i32 %y, i32 %z) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, %sizeOf
  %10 = mul i32 %8, %z
  %tmp = add i32 %10, %y
  %tmp1 = mul i32 %tmp, %6
  %11 = add i32 %tmp1, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  ret i8* %12
}

; Function Attrs: nounwind readonly
define i8* @_Z14rsGetElementAt13rs_allocationj([1 x i32] %a.coerce, i32 %x) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 4
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %6, %x
  %8 = getelementptr inbounds i8, i8* %4, i32 %7
  ret i8* %8
}

; Function Attrs: nounwind readonly
define i8* @_Z14rsGetElementAt13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 4
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %6, %x
  %10 = mul i32 %8, %y
  %11 = add i32 %10, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  ret i8* %12
}

; Function Attrs: nounwind readonly
define i8* @_Z14rsGetElementAt13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 4
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !21
  %11 = mul i32 %6, %x
  %12 = mul i32 %10, %z
  %tmp = add i32 %12, %y
  %tmp1 = mul i32 %tmp, %8
  %13 = add i32 %tmp1, %11
  %14 = getelementptr inbounds i8, i8* %4, i32 %13
  ret i8* %14
}

; Function Attrs: nounwind
define void @_Z14rsSetElementAt13rs_allocationPvj([1 x i32] %a.coerce, i8* %ptr, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 4
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %6, %x
  %8 = getelementptr inbounds i8, i8* %4, i32 %7
  %9 = icmp eq i32 %6, 0
  br i1 %9, label %memcpy.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %0
  %n.mod.vf.i = and i32 %6, 15
  %n.vec.i = sub i32 %6, %n.mod.vf.i
  %cmp.zero.i = icmp eq i32 %n.mod.vf.i, %6
  %10 = add i32 %6, -1
  br i1 %cmp.zero.i, label %middle.block.i, label %vector.memcheck.i

vector.memcheck.i:                                ; preds = %.lr.ph.i
  %scevgep4.i = getelementptr i8, i8* %ptr, i32 %10
  %.sum = add i32 %7, %10
  %scevgep.i = getelementptr i8, i8* %4, i32 %.sum
  %bound1.i = icmp uge i8* %scevgep.i, %ptr
  %bound0.i = icmp uge i8* %scevgep4.i, %8
  %found.conflict.i = and i1 %bound0.i, %bound1.i
  %ptr.ind.end.i = getelementptr i8, i8* %ptr, i32 %n.vec.i
  %.sum1 = add i32 %n.vec.i, %7
  %ptr.ind.end6.i = getelementptr i8, i8* %4, i32 %.sum1
  br i1 %found.conflict.i, label %middle.block.i, label %vector.body.i

vector.body.i:                                    ; preds = %vector.body.i, %vector.memcheck.i
  %index.i = phi i32 [ %index.next.i, %vector.body.i ], [ 0, %vector.memcheck.i ]
  %next.gep.i = getelementptr i8, i8* %ptr, i32 %index.i
  %.sum2 = add i32 %index.i, %7
  %next.gep55.i = getelementptr i8, i8* %4, i32 %.sum2
  %11 = bitcast i8* %next.gep.i to <16 x i8>*
  %wide.load.i = load <16 x i8>, <16 x i8>* %11, align 1
  %12 = bitcast i8* %next.gep55.i to <16 x i8>*
  store <16 x i8> %wide.load.i, <16 x i8>* %12, align 1
  %index.next.i = add i32 %index.i, 16
  %13 = icmp eq i32 %index.next.i, %n.vec.i
  br i1 %13, label %middle.block.i, label %vector.body.i

middle.block.i:                                   ; preds = %vector.body.i, %vector.memcheck.i, %.lr.ph.i
  %resume.val.i = phi i8* [ %ptr, %.lr.ph.i ], [ %ptr, %vector.memcheck.i ], [ %ptr.ind.end.i, %vector.body.i ]
  %resume.val5.i = phi i8* [ %8, %.lr.ph.i ], [ %8, %vector.memcheck.i ], [ %ptr.ind.end6.i, %vector.body.i ]
  %resume.val7.i = phi i32 [ %6, %.lr.ph.i ], [ %6, %vector.memcheck.i ], [ %n.mod.vf.i, %vector.body.i ]
  %new.indc.resume.val.i = phi i32 [ 0, %.lr.ph.i ], [ 0, %vector.memcheck.i ], [ %n.vec.i, %vector.body.i ]
  %cmp.n.i = icmp eq i32 %new.indc.resume.val.i, %6
  br i1 %cmp.n.i, label %memcpy.exit, label %scalar.ph.i

scalar.ph.i:                                      ; preds = %scalar.ph.i, %middle.block.i
  %src_c.03.i = phi i8* [ %14, %scalar.ph.i ], [ %resume.val.i, %middle.block.i ]
  %dst_c.02.i = phi i8* [ %16, %scalar.ph.i ], [ %resume.val5.i, %middle.block.i ]
  %.01.i = phi i32 [ %17, %scalar.ph.i ], [ %resume.val7.i, %middle.block.i ]
  %14 = getelementptr inbounds i8, i8* %src_c.03.i, i32 1
  %15 = load i8, i8* %src_c.03.i, align 1, !tbaa !19
  %16 = getelementptr inbounds i8, i8* %dst_c.02.i, i32 1
  store i8 %15, i8* %dst_c.02.i, align 1, !tbaa !19
  %17 = add i32 %.01.i, -1
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %memcpy.exit, label %scalar.ph.i, !llvm.loop !25

memcpy.exit:                                      ; preds = %scalar.ph.i, %middle.block.i, %0
  ret void
}

; Function Attrs: nounwind
define void @_Z14rsSetElementAt13rs_allocationPvjj([1 x i32] %a.coerce, i8* %ptr, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 4
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %6, %x
  %10 = mul i32 %8, %y
  %11 = add i32 %10, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = icmp eq i32 %6, 0
  br i1 %13, label %memcpy.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %0
  %n.mod.vf.i = and i32 %6, 15
  %n.vec.i = sub i32 %6, %n.mod.vf.i
  %cmp.zero.i = icmp eq i32 %n.mod.vf.i, %6
  %14 = add i32 %6, -1
  br i1 %cmp.zero.i, label %middle.block.i, label %vector.memcheck.i

vector.memcheck.i:                                ; preds = %.lr.ph.i
  %scevgep4.i = getelementptr i8, i8* %ptr, i32 %14
  %.sum = add i32 %11, %14
  %scevgep.i = getelementptr i8, i8* %4, i32 %.sum
  %bound1.i = icmp uge i8* %scevgep.i, %ptr
  %bound0.i = icmp uge i8* %scevgep4.i, %12
  %found.conflict.i = and i1 %bound0.i, %bound1.i
  %ptr.ind.end.i = getelementptr i8, i8* %ptr, i32 %n.vec.i
  %.sum1 = add i32 %11, %n.vec.i
  %ptr.ind.end6.i = getelementptr i8, i8* %4, i32 %.sum1
  br i1 %found.conflict.i, label %middle.block.i, label %vector.body.i

vector.body.i:                                    ; preds = %vector.body.i, %vector.memcheck.i
  %index.i = phi i32 [ %index.next.i, %vector.body.i ], [ 0, %vector.memcheck.i ]
  %next.gep.i = getelementptr i8, i8* %ptr, i32 %index.i
  %.sum2 = add i32 %index.i, %11
  %next.gep55.i = getelementptr i8, i8* %4, i32 %.sum2
  %15 = bitcast i8* %next.gep.i to <16 x i8>*
  %wide.load.i = load <16 x i8>, <16 x i8>* %15, align 1
  %16 = bitcast i8* %next.gep55.i to <16 x i8>*
  store <16 x i8> %wide.load.i, <16 x i8>* %16, align 1
  %index.next.i = add i32 %index.i, 16
  %17 = icmp eq i32 %index.next.i, %n.vec.i
  br i1 %17, label %middle.block.i, label %vector.body.i

middle.block.i:                                   ; preds = %vector.body.i, %vector.memcheck.i, %.lr.ph.i
  %resume.val.i = phi i8* [ %ptr, %.lr.ph.i ], [ %ptr, %vector.memcheck.i ], [ %ptr.ind.end.i, %vector.body.i ]
  %resume.val5.i = phi i8* [ %12, %.lr.ph.i ], [ %12, %vector.memcheck.i ], [ %ptr.ind.end6.i, %vector.body.i ]
  %resume.val7.i = phi i32 [ %6, %.lr.ph.i ], [ %6, %vector.memcheck.i ], [ %n.mod.vf.i, %vector.body.i ]
  %new.indc.resume.val.i = phi i32 [ 0, %.lr.ph.i ], [ 0, %vector.memcheck.i ], [ %n.vec.i, %vector.body.i ]
  %cmp.n.i = icmp eq i32 %new.indc.resume.val.i, %6
  br i1 %cmp.n.i, label %memcpy.exit, label %scalar.ph.i

scalar.ph.i:                                      ; preds = %scalar.ph.i, %middle.block.i
  %src_c.03.i = phi i8* [ %18, %scalar.ph.i ], [ %resume.val.i, %middle.block.i ]
  %dst_c.02.i = phi i8* [ %20, %scalar.ph.i ], [ %resume.val5.i, %middle.block.i ]
  %.01.i = phi i32 [ %21, %scalar.ph.i ], [ %resume.val7.i, %middle.block.i ]
  %18 = getelementptr inbounds i8, i8* %src_c.03.i, i32 1
  %19 = load i8, i8* %src_c.03.i, align 1, !tbaa !19
  %20 = getelementptr inbounds i8, i8* %dst_c.02.i, i32 1
  store i8 %19, i8* %dst_c.02.i, align 1, !tbaa !19
  %21 = add i32 %.01.i, -1
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %memcpy.exit, label %scalar.ph.i, !llvm.loop !25

memcpy.exit:                                      ; preds = %scalar.ph.i, %middle.block.i, %0
  ret void
}

; Function Attrs: nounwind
define void @_Z14rsSetElementAt13rs_allocationPvjjj([1 x i32] %a.coerce, i8* %ptr, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 1, i32 4
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !21
  %11 = mul i32 %6, %x
  %12 = mul i32 %10, %z
  %tmp = add i32 %12, %y
  %tmp3 = mul i32 %tmp, %8
  %13 = add i32 %tmp3, %11
  %14 = getelementptr inbounds i8, i8* %4, i32 %13
  %15 = icmp eq i32 %6, 0
  br i1 %15, label %memcpy.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %0
  %n.mod.vf.i = and i32 %6, 15
  %n.vec.i = sub i32 %6, %n.mod.vf.i
  %cmp.zero.i = icmp eq i32 %n.mod.vf.i, %6
  %16 = add i32 %6, -1
  br i1 %cmp.zero.i, label %middle.block.i, label %vector.memcheck.i

vector.memcheck.i:                                ; preds = %.lr.ph.i
  %scevgep4.i = getelementptr i8, i8* %ptr, i32 %16
  %.sum = add i32 %13, %16
  %scevgep.i = getelementptr i8, i8* %4, i32 %.sum
  %bound1.i = icmp uge i8* %scevgep.i, %ptr
  %bound0.i = icmp uge i8* %scevgep4.i, %14
  %found.conflict.i = and i1 %bound0.i, %bound1.i
  %ptr.ind.end.i = getelementptr i8, i8* %ptr, i32 %n.vec.i
  %.sum1 = add i32 %13, %n.vec.i
  %ptr.ind.end6.i = getelementptr i8, i8* %4, i32 %.sum1
  br i1 %found.conflict.i, label %middle.block.i, label %vector.body.i

vector.body.i:                                    ; preds = %vector.body.i, %vector.memcheck.i
  %index.i = phi i32 [ %index.next.i, %vector.body.i ], [ 0, %vector.memcheck.i ]
  %next.gep.i = getelementptr i8, i8* %ptr, i32 %index.i
  %.sum2 = add i32 %index.i, %13
  %next.gep55.i = getelementptr i8, i8* %4, i32 %.sum2
  %17 = bitcast i8* %next.gep.i to <16 x i8>*
  %wide.load.i = load <16 x i8>, <16 x i8>* %17, align 1
  %18 = bitcast i8* %next.gep55.i to <16 x i8>*
  store <16 x i8> %wide.load.i, <16 x i8>* %18, align 1
  %index.next.i = add i32 %index.i, 16
  %19 = icmp eq i32 %index.next.i, %n.vec.i
  br i1 %19, label %middle.block.i, label %vector.body.i

middle.block.i:                                   ; preds = %vector.body.i, %vector.memcheck.i, %.lr.ph.i
  %resume.val.i = phi i8* [ %ptr, %.lr.ph.i ], [ %ptr, %vector.memcheck.i ], [ %ptr.ind.end.i, %vector.body.i ]
  %resume.val5.i = phi i8* [ %14, %.lr.ph.i ], [ %14, %vector.memcheck.i ], [ %ptr.ind.end6.i, %vector.body.i ]
  %resume.val7.i = phi i32 [ %6, %.lr.ph.i ], [ %6, %vector.memcheck.i ], [ %n.mod.vf.i, %vector.body.i ]
  %new.indc.resume.val.i = phi i32 [ 0, %.lr.ph.i ], [ 0, %vector.memcheck.i ], [ %n.vec.i, %vector.body.i ]
  %cmp.n.i = icmp eq i32 %new.indc.resume.val.i, %6
  br i1 %cmp.n.i, label %memcpy.exit, label %scalar.ph.i

scalar.ph.i:                                      ; preds = %scalar.ph.i, %middle.block.i
  %src_c.03.i = phi i8* [ %20, %scalar.ph.i ], [ %resume.val.i, %middle.block.i ]
  %dst_c.02.i = phi i8* [ %22, %scalar.ph.i ], [ %resume.val5.i, %middle.block.i ]
  %.01.i = phi i32 [ %23, %scalar.ph.i ], [ %resume.val7.i, %middle.block.i ]
  %20 = getelementptr inbounds i8, i8* %src_c.03.i, i32 1
  %21 = load i8, i8* %src_c.03.i, align 1, !tbaa !19
  %22 = getelementptr inbounds i8, i8* %dst_c.02.i, i32 1
  store i8 %21, i8* %dst_c.02.i, align 1, !tbaa !19
  %23 = add i32 %.01.i, -1
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %memcpy.exit, label %scalar.ph.i, !llvm.loop !25

memcpy.exit:                                      ; preds = %scalar.ph.i, %middle.block.i, %0
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_char13rs_allocationcj([1 x i32] %a.coerce, i8 signext %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds i8, i8* %4, i32 %x
  store i8 %val, i8* %5, align 1, !tbaa !27
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_char13rs_allocationcjj([1 x i32] %a.coerce, i8 signext %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %tmp1.i.i = mul i32 %y, %6
  %7 = add i32 %tmp1.i.i, %x
  %8 = getelementptr inbounds i8, i8* %4, i32 %7
  store i8 %val, i8* %8, align 1, !tbaa !27
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_char13rs_allocationcjjj([1 x i32] %a.coerce, i8 signext %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i.i = add i32 %9, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %10 = add i32 %tmp1.i.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  store i8 %val, i8* %11, align 1, !tbaa !27
  ret void
}

; Function Attrs: nounwind
define signext i8 @_Z19rsGetElementAt_char13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds i8, i8* %4, i32 %x
  %6 = load i8, i8* %5, align 1, !tbaa !27
  ret i8 %6
}

; Function Attrs: nounwind
define signext i8 @_Z19rsGetElementAt_char13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %tmp1.i.i = mul i32 %y, %6
  %7 = add i32 %tmp1.i.i, %x
  %8 = getelementptr inbounds i8, i8* %4, i32 %7
  %9 = load i8, i8* %8, align 1, !tbaa !27
  ret i8 %9
}

; Function Attrs: nounwind
define signext i8 @_Z19rsGetElementAt_char13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i.i = add i32 %9, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %10 = add i32 %tmp1.i.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  %12 = load i8, i8* %11, align 1, !tbaa !27
  ret i8 %12
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char213rs_allocationDv2_cj([1 x i32] %a.coerce, <2 x i8> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %7, align 2, !tbaa !30
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char213rs_allocationDv2_cjj([1 x i32] %a.coerce, <2 x i8> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %10, align 2, !tbaa !30
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char213rs_allocationDv2_cjjj([1 x i32] %a.coerce, <2 x i8> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %13, align 2, !tbaa !30
  ret void
}

; Function Attrs: nounwind
define <2 x i8> @_Z20rsGetElementAt_char213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i8>*
  %8 = load <2 x i8>, <2 x i8>* %7, align 2, !tbaa !30
  ret <2 x i8> %8
}

; Function Attrs: nounwind
define <2 x i8> @_Z20rsGetElementAt_char213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i8>*
  %11 = load <2 x i8>, <2 x i8>* %10, align 2, !tbaa !30
  ret <2 x i8> %11
}

; Function Attrs: nounwind
define <2 x i8> @_Z20rsGetElementAt_char213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  %14 = load <2 x i8>, <2 x i8>* %13, align 2, !tbaa !30
  ret <2 x i8> %14
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char313rs_allocationDv3_cj([1 x i32] %a.coerce, <3 x i8> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i8>*
  store <4 x i8> %7, <4 x i8>* %8, align 4, !tbaa !31
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char313rs_allocationDv3_cjj([1 x i32] %a.coerce, <3 x i8> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i8>*
  store <4 x i8> %10, <4 x i8>* %11, align 4, !tbaa !31
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char313rs_allocationDv3_cjjj([1 x i32] %a.coerce, <3 x i8> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %13, <4 x i8>* %14, align 4, !tbaa !31
  ret void
}

; Function Attrs: nounwind
define <3 x i8> @_Z20rsGetElementAt_char313rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i8>*
  %8 = load <4 x i8>, <4 x i8>* %7, align 4, !tbaa !31
  %9 = shufflevector <4 x i8> %8, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %9
}

; Function Attrs: nounwind
define <3 x i8> @_Z20rsGetElementAt_char313rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i8>*
  %11 = load <4 x i8>, <4 x i8>* %10, align 4, !tbaa !31
  %12 = shufflevector <4 x i8> %11, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %12
}

; Function Attrs: nounwind
define <3 x i8> @_Z20rsGetElementAt_char313rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !31
  %15 = shufflevector <4 x i8> %14, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %15
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char413rs_allocationDv4_cj([1 x i32] %a.coerce, <4 x i8> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %7, align 4, !tbaa !32
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char413rs_allocationDv4_cjj([1 x i32] %a.coerce, <4 x i8> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %10, align 4, !tbaa !32
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_char413rs_allocationDv4_cjjj([1 x i32] %a.coerce, <4 x i8> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %13, align 4, !tbaa !32
  ret void
}

; Function Attrs: nounwind
define <4 x i8> @_Z20rsGetElementAt_char413rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i8>*
  %8 = load <4 x i8>, <4 x i8>* %7, align 4, !tbaa !32
  ret <4 x i8> %8
}

; Function Attrs: nounwind
define <4 x i8> @_Z20rsGetElementAt_char413rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i8>*
  %11 = load <4 x i8>, <4 x i8>* %10, align 4, !tbaa !32
  ret <4 x i8> %11
}

; Function Attrs: nounwind
define <4 x i8> @_Z20rsGetElementAt_char413rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !32
  ret <4 x i8> %14
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uchar13rs_allocationhj([1 x i32] %a.coerce, i8 zeroext %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds i8, i8* %4, i32 %x
  store i8 %val, i8* %5, align 1, !tbaa !33
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uchar13rs_allocationhjj([1 x i32] %a.coerce, i8 zeroext %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %tmp1.i.i = mul i32 %y, %6
  %7 = add i32 %tmp1.i.i, %x
  %8 = getelementptr inbounds i8, i8* %4, i32 %7
  store i8 %val, i8* %8, align 1, !tbaa !33
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uchar13rs_allocationhjjj([1 x i32] %a.coerce, i8 zeroext %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i.i = add i32 %9, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %10 = add i32 %tmp1.i.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  store i8 %val, i8* %11, align 1, !tbaa !33
  ret void
}

; Function Attrs: nounwind
define zeroext i8 @_Z20rsGetElementAt_uchar13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds i8, i8* %4, i32 %x
  %6 = load i8, i8* %5, align 1, !tbaa !33
  ret i8 %6
}

; Function Attrs: nounwind
define zeroext i8 @_Z20rsGetElementAt_uchar13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %tmp1.i.i = mul i32 %y, %6
  %7 = add i32 %tmp1.i.i, %x
  %8 = getelementptr inbounds i8, i8* %4, i32 %7
  %9 = load i8, i8* %8, align 1, !tbaa !33
  ret i8 %9
}

; Function Attrs: nounwind
define zeroext i8 @_Z20rsGetElementAt_uchar13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i.i = add i32 %9, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %10 = add i32 %tmp1.i.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  %12 = load i8, i8* %11, align 1, !tbaa !33
  ret i8 %12
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar213rs_allocationDv2_hj([1 x i32] %a.coerce, <2 x i8> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %7, align 2, !tbaa !34
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar213rs_allocationDv2_hjj([1 x i32] %a.coerce, <2 x i8> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %10, align 2, !tbaa !34
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar213rs_allocationDv2_hjjj([1 x i32] %a.coerce, <2 x i8> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %13, align 2, !tbaa !34
  ret void
}

; Function Attrs: nounwind
define <2 x i8> @_Z21rsGetElementAt_uchar213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i8>*
  %8 = load <2 x i8>, <2 x i8>* %7, align 2, !tbaa !34
  ret <2 x i8> %8
}

; Function Attrs: nounwind
define <2 x i8> @_Z21rsGetElementAt_uchar213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i8>*
  %11 = load <2 x i8>, <2 x i8>* %10, align 2, !tbaa !34
  ret <2 x i8> %11
}

; Function Attrs: nounwind
define <2 x i8> @_Z21rsGetElementAt_uchar213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  %14 = load <2 x i8>, <2 x i8>* %13, align 2, !tbaa !34
  ret <2 x i8> %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar313rs_allocationDv3_hj([1 x i32] %a.coerce, <3 x i8> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i8>*
  store <4 x i8> %7, <4 x i8>* %8, align 4, !tbaa !35
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar313rs_allocationDv3_hjj([1 x i32] %a.coerce, <3 x i8> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i8>*
  store <4 x i8> %10, <4 x i8>* %11, align 4, !tbaa !35
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar313rs_allocationDv3_hjjj([1 x i32] %a.coerce, <3 x i8> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %13, <4 x i8>* %14, align 4, !tbaa !35
  ret void
}

; Function Attrs: nounwind
define <3 x i8> @_Z21rsGetElementAt_uchar313rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i8>*
  %8 = load <4 x i8>, <4 x i8>* %7, align 4, !tbaa !35
  %9 = shufflevector <4 x i8> %8, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %9
}

; Function Attrs: nounwind
define <3 x i8> @_Z21rsGetElementAt_uchar313rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i8>*
  %11 = load <4 x i8>, <4 x i8>* %10, align 4, !tbaa !35
  %12 = shufflevector <4 x i8> %11, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %12
}

; Function Attrs: nounwind
define <3 x i8> @_Z21rsGetElementAt_uchar313rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !35
  %15 = shufflevector <4 x i8> %14, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %15
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar413rs_allocationDv4_hj([1 x i32] %a.coerce, <4 x i8> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %7, align 4, !tbaa !36
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar413rs_allocationDv4_hjj([1 x i32] %a.coerce, <4 x i8> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %10, align 4, !tbaa !36
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_uchar413rs_allocationDv4_hjjj([1 x i32] %a.coerce, <4 x i8> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %13, align 4, !tbaa !36
  ret void
}

; Function Attrs: nounwind
define <4 x i8> @_Z21rsGetElementAt_uchar413rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i8>*
  %8 = load <4 x i8>, <4 x i8>* %7, align 4, !tbaa !36
  ret <4 x i8> %8
}

; Function Attrs: nounwind
define <4 x i8> @_Z21rsGetElementAt_uchar413rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i8>*
  %11 = load <4 x i8>, <4 x i8>* %10, align 4, !tbaa !36
  ret <4 x i8> %11
}

; Function Attrs: nounwind
define <4 x i8> @_Z21rsGetElementAt_uchar413rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !36
  ret <4 x i8> %14
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_short13rs_allocationsj([1 x i32] %a.coerce, i16 signext %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i16*
  store i16 %val, i16* %7, align 2, !tbaa !37
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_short13rs_allocationsjj([1 x i32] %a.coerce, i16 signext %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i16*
  store i16 %val, i16* %10, align 2, !tbaa !37
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_short13rs_allocationsjjj([1 x i32] %a.coerce, i16 signext %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  store i16 %val, i16* %13, align 2, !tbaa !37
  ret void
}

; Function Attrs: nounwind
define signext i16 @_Z20rsGetElementAt_short13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i16*
  %8 = load i16, i16* %7, align 2, !tbaa !37
  ret i16 %8
}

; Function Attrs: nounwind
define signext i16 @_Z20rsGetElementAt_short13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i16*
  %11 = load i16, i16* %10, align 2, !tbaa !37
  ret i16 %11
}

; Function Attrs: nounwind
define signext i16 @_Z20rsGetElementAt_short13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  %14 = load i16, i16* %13, align 2, !tbaa !37
  ret i16 %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short213rs_allocationDv2_sj([1 x i32] %a.coerce, <2 x i16> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %7, align 4, !tbaa !38
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short213rs_allocationDv2_sjj([1 x i32] %a.coerce, <2 x i16> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %10, align 4, !tbaa !38
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short213rs_allocationDv2_sjjj([1 x i32] %a.coerce, <2 x i16> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %13, align 4, !tbaa !38
  ret void
}

; Function Attrs: nounwind
define <2 x i16> @_Z21rsGetElementAt_short213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i16>*
  %8 = load <2 x i16>, <2 x i16>* %7, align 4, !tbaa !38
  ret <2 x i16> %8
}

; Function Attrs: nounwind
define <2 x i16> @_Z21rsGetElementAt_short213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i16>*
  %11 = load <2 x i16>, <2 x i16>* %10, align 4, !tbaa !38
  ret <2 x i16> %11
}

; Function Attrs: nounwind
define <2 x i16> @_Z21rsGetElementAt_short213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  %14 = load <2 x i16>, <2 x i16>* %13, align 4, !tbaa !38
  ret <2 x i16> %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short313rs_allocationDv3_sj([1 x i32] %a.coerce, <3 x i16> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i16>*
  store <4 x i16> %7, <4 x i16>* %8, align 8, !tbaa !39
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short313rs_allocationDv3_sjj([1 x i32] %a.coerce, <3 x i16> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i16>*
  store <4 x i16> %10, <4 x i16>* %11, align 8, !tbaa !39
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short313rs_allocationDv3_sjjj([1 x i32] %a.coerce, <3 x i16> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %13, <4 x i16>* %14, align 8, !tbaa !39
  ret void
}

; Function Attrs: nounwind
define <3 x i16> @_Z21rsGetElementAt_short313rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i16>*
  %8 = load <4 x i16>, <4 x i16>* %7, align 8, !tbaa !39
  %9 = shufflevector <4 x i16> %8, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %9
}

; Function Attrs: nounwind
define <3 x i16> @_Z21rsGetElementAt_short313rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i16>*
  %11 = load <4 x i16>, <4 x i16>* %10, align 8, !tbaa !39
  %12 = shufflevector <4 x i16> %11, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %12
}

; Function Attrs: nounwind
define <3 x i16> @_Z21rsGetElementAt_short313rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !39
  %15 = shufflevector <4 x i16> %14, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %15
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short413rs_allocationDv4_sj([1 x i32] %a.coerce, <4 x i16> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %7, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short413rs_allocationDv4_sjj([1 x i32] %a.coerce, <4 x i16> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %10, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_short413rs_allocationDv4_sjjj([1 x i32] %a.coerce, <4 x i16> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %13, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind
define <4 x i16> @_Z21rsGetElementAt_short413rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i16>*
  %8 = load <4 x i16>, <4 x i16>* %7, align 8, !tbaa !40
  ret <4 x i16> %8
}

; Function Attrs: nounwind
define <4 x i16> @_Z21rsGetElementAt_short413rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i16>*
  %11 = load <4 x i16>, <4 x i16>* %10, align 8, !tbaa !40
  ret <4 x i16> %11
}

; Function Attrs: nounwind
define <4 x i16> @_Z21rsGetElementAt_short413rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !40
  ret <4 x i16> %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ushort13rs_allocationtj([1 x i32] %a.coerce, i16 zeroext %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i16*
  store i16 %val, i16* %7, align 2, !tbaa !41
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ushort13rs_allocationtjj([1 x i32] %a.coerce, i16 zeroext %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i16*
  store i16 %val, i16* %10, align 2, !tbaa !41
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ushort13rs_allocationtjjj([1 x i32] %a.coerce, i16 zeroext %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  store i16 %val, i16* %13, align 2, !tbaa !41
  ret void
}

; Function Attrs: nounwind
define zeroext i16 @_Z21rsGetElementAt_ushort13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 2
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i16*
  %8 = load i16, i16* %7, align 2, !tbaa !41
  ret i16 %8
}

; Function Attrs: nounwind
define zeroext i16 @_Z21rsGetElementAt_ushort13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 2
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i16*
  %11 = load i16, i16* %10, align 2, !tbaa !41
  ret i16 %11
}

; Function Attrs: nounwind
define zeroext i16 @_Z21rsGetElementAt_ushort13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  %14 = load i16, i16* %13, align 2, !tbaa !41
  ret i16 %14
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort213rs_allocationDv2_tj([1 x i32] %a.coerce, <2 x i16> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %7, align 4, !tbaa !42
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort213rs_allocationDv2_tjj([1 x i32] %a.coerce, <2 x i16> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %10, align 4, !tbaa !42
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort213rs_allocationDv2_tjjj([1 x i32] %a.coerce, <2 x i16> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %13, align 4, !tbaa !42
  ret void
}

; Function Attrs: nounwind
define <2 x i16> @_Z22rsGetElementAt_ushort213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i16>*
  %8 = load <2 x i16>, <2 x i16>* %7, align 4, !tbaa !42
  ret <2 x i16> %8
}

; Function Attrs: nounwind
define <2 x i16> @_Z22rsGetElementAt_ushort213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i16>*
  %11 = load <2 x i16>, <2 x i16>* %10, align 4, !tbaa !42
  ret <2 x i16> %11
}

; Function Attrs: nounwind
define <2 x i16> @_Z22rsGetElementAt_ushort213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  %14 = load <2 x i16>, <2 x i16>* %13, align 4, !tbaa !42
  ret <2 x i16> %14
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort313rs_allocationDv3_tj([1 x i32] %a.coerce, <3 x i16> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i16>*
  store <4 x i16> %7, <4 x i16>* %8, align 8, !tbaa !43
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort313rs_allocationDv3_tjj([1 x i32] %a.coerce, <3 x i16> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i16>*
  store <4 x i16> %10, <4 x i16>* %11, align 8, !tbaa !43
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort313rs_allocationDv3_tjjj([1 x i32] %a.coerce, <3 x i16> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %13, <4 x i16>* %14, align 8, !tbaa !43
  ret void
}

; Function Attrs: nounwind
define <3 x i16> @_Z22rsGetElementAt_ushort313rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i16>*
  %8 = load <4 x i16>, <4 x i16>* %7, align 8, !tbaa !43
  %9 = shufflevector <4 x i16> %8, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %9
}

; Function Attrs: nounwind
define <3 x i16> @_Z22rsGetElementAt_ushort313rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i16>*
  %11 = load <4 x i16>, <4 x i16>* %10, align 8, !tbaa !43
  %12 = shufflevector <4 x i16> %11, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %12
}

; Function Attrs: nounwind
define <3 x i16> @_Z22rsGetElementAt_ushort313rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !43
  %15 = shufflevector <4 x i16> %14, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %15
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort413rs_allocationDv4_tj([1 x i32] %a.coerce, <4 x i16> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %7, align 8, !tbaa !44
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort413rs_allocationDv4_tjj([1 x i32] %a.coerce, <4 x i16> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %10, align 8, !tbaa !44
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_ushort413rs_allocationDv4_tjjj([1 x i32] %a.coerce, <4 x i16> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %13, align 8, !tbaa !44
  ret void
}

; Function Attrs: nounwind
define <4 x i16> @_Z22rsGetElementAt_ushort413rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i16>*
  %8 = load <4 x i16>, <4 x i16>* %7, align 8, !tbaa !44
  ret <4 x i16> %8
}

; Function Attrs: nounwind
define <4 x i16> @_Z22rsGetElementAt_ushort413rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i16>*
  %11 = load <4 x i16>, <4 x i16>* %10, align 8, !tbaa !44
  ret <4 x i16> %11
}

; Function Attrs: nounwind
define <4 x i16> @_Z22rsGetElementAt_ushort413rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !44
  ret <4 x i16> %14
}

; Function Attrs: nounwind
define void @_Z18rsSetElementAt_int13rs_allocationij([1 x i32] %a.coerce, i32 %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i32*
  store i32 %val, i32* %7, align 4, !tbaa !45
  ret void
}

; Function Attrs: nounwind
define void @_Z18rsSetElementAt_int13rs_allocationijj([1 x i32] %a.coerce, i32 %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i32*
  store i32 %val, i32* %10, align 4, !tbaa !45
  ret void
}

; Function Attrs: nounwind
define void @_Z18rsSetElementAt_int13rs_allocationijjj([1 x i32] %a.coerce, i32 %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  store i32 %val, i32* %13, align 4, !tbaa !45
  ret void
}

; Function Attrs: nounwind
define i32 @_Z18rsGetElementAt_int13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i32*
  %8 = load i32, i32* %7, align 4, !tbaa !45
  ret i32 %8
}

; Function Attrs: nounwind
define i32 @_Z18rsGetElementAt_int13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i32*
  %11 = load i32, i32* %10, align 4, !tbaa !45
  ret i32 %11
}

; Function Attrs: nounwind
define i32 @_Z18rsGetElementAt_int13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13, align 4, !tbaa !45
  ret i32 %14
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int213rs_allocationDv2_ij([1 x i32] %a.coerce, <2 x i32> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %7, align 8, !tbaa !46
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int213rs_allocationDv2_ijj([1 x i32] %a.coerce, <2 x i32> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %10, align 8, !tbaa !46
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int213rs_allocationDv2_ijjj([1 x i32] %a.coerce, <2 x i32> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %13, align 8, !tbaa !46
  ret void
}

; Function Attrs: nounwind
define <2 x i32> @_Z19rsGetElementAt_int213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i32>*
  %8 = load <2 x i32>, <2 x i32>* %7, align 8, !tbaa !46
  ret <2 x i32> %8
}

; Function Attrs: nounwind
define <2 x i32> @_Z19rsGetElementAt_int213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i32>*
  %11 = load <2 x i32>, <2 x i32>* %10, align 8, !tbaa !46
  ret <2 x i32> %11
}

; Function Attrs: nounwind
define <2 x i32> @_Z19rsGetElementAt_int213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  %14 = load <2 x i32>, <2 x i32>* %13, align 8, !tbaa !46
  ret <2 x i32> %14
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int313rs_allocationDv3_ij([1 x i32] %a.coerce, <3 x i32> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i32>*
  store <4 x i32> %7, <4 x i32>* %8, align 16, !tbaa !47
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int313rs_allocationDv3_ijj([1 x i32] %a.coerce, <3 x i32> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i32>*
  store <4 x i32> %10, <4 x i32>* %11, align 16, !tbaa !47
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int313rs_allocationDv3_ijjj([1 x i32] %a.coerce, <3 x i32> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %13, <4 x i32>* %14, align 16, !tbaa !47
  ret void
}

; Function Attrs: nounwind
define <3 x i32> @_Z19rsGetElementAt_int313rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i32>*
  %8 = load <4 x i32>, <4 x i32>* %7, align 8, !tbaa !47
  %9 = shufflevector <4 x i32> %8, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %9
}

; Function Attrs: nounwind
define <3 x i32> @_Z19rsGetElementAt_int313rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i32>*
  %11 = load <4 x i32>, <4 x i32>* %10, align 8, !tbaa !47
  %12 = shufflevector <4 x i32> %11, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %12
}

; Function Attrs: nounwind
define <3 x i32> @_Z19rsGetElementAt_int313rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 8, !tbaa !47
  %15 = shufflevector <4 x i32> %14, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %15
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int413rs_allocationDv4_ij([1 x i32] %a.coerce, <4 x i32> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %7, align 16, !tbaa !48
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int413rs_allocationDv4_ijj([1 x i32] %a.coerce, <4 x i32> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %10, align 16, !tbaa !48
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_int413rs_allocationDv4_ijjj([1 x i32] %a.coerce, <4 x i32> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %13, align 16, !tbaa !48
  ret void
}

; Function Attrs: nounwind
define <4 x i32> @_Z19rsGetElementAt_int413rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i32>*
  %8 = load <4 x i32>, <4 x i32>* %7, align 16, !tbaa !48
  ret <4 x i32> %8
}

; Function Attrs: nounwind
define <4 x i32> @_Z19rsGetElementAt_int413rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i32>*
  %11 = load <4 x i32>, <4 x i32>* %10, align 16, !tbaa !48
  ret <4 x i32> %11
}

; Function Attrs: nounwind
define <4 x i32> @_Z19rsGetElementAt_int413rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 16, !tbaa !48
  ret <4 x i32> %14
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_uint13rs_allocationjj([1 x i32] %a.coerce, i32 %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i32*
  store i32 %val, i32* %7, align 4, !tbaa !49
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_uint13rs_allocationjjj([1 x i32] %a.coerce, i32 %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i32*
  store i32 %val, i32* %10, align 4, !tbaa !49
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_uint13rs_allocationjjjj([1 x i32] %a.coerce, i32 %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  store i32 %val, i32* %13, align 4, !tbaa !49
  ret void
}

; Function Attrs: nounwind
define i32 @_Z19rsGetElementAt_uint13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i32*
  %8 = load i32, i32* %7, align 4, !tbaa !49
  ret i32 %8
}

; Function Attrs: nounwind
define i32 @_Z19rsGetElementAt_uint13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i32*
  %11 = load i32, i32* %10, align 4, !tbaa !49
  ret i32 %11
}

; Function Attrs: nounwind
define i32 @_Z19rsGetElementAt_uint13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13, align 4, !tbaa !49
  ret i32 %14
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint213rs_allocationDv2_jj([1 x i32] %a.coerce, <2 x i32> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %7, align 8, !tbaa !50
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint213rs_allocationDv2_jjj([1 x i32] %a.coerce, <2 x i32> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %10, align 8, !tbaa !50
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint213rs_allocationDv2_jjjj([1 x i32] %a.coerce, <2 x i32> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %13, align 8, !tbaa !50
  ret void
}

; Function Attrs: nounwind
define <2 x i32> @_Z20rsGetElementAt_uint213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i32>*
  %8 = load <2 x i32>, <2 x i32>* %7, align 8, !tbaa !50
  ret <2 x i32> %8
}

; Function Attrs: nounwind
define <2 x i32> @_Z20rsGetElementAt_uint213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i32>*
  %11 = load <2 x i32>, <2 x i32>* %10, align 8, !tbaa !50
  ret <2 x i32> %11
}

; Function Attrs: nounwind
define <2 x i32> @_Z20rsGetElementAt_uint213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  %14 = load <2 x i32>, <2 x i32>* %13, align 8, !tbaa !50
  ret <2 x i32> %14
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint313rs_allocationDv3_jj([1 x i32] %a.coerce, <3 x i32> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i32>*
  store <4 x i32> %7, <4 x i32>* %8, align 16, !tbaa !51
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint313rs_allocationDv3_jjj([1 x i32] %a.coerce, <3 x i32> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i32>*
  store <4 x i32> %10, <4 x i32>* %11, align 16, !tbaa !51
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint313rs_allocationDv3_jjjj([1 x i32] %a.coerce, <3 x i32> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %13, <4 x i32>* %14, align 16, !tbaa !51
  ret void
}

; Function Attrs: nounwind
define <3 x i32> @_Z20rsGetElementAt_uint313rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i32>*
  %8 = load <4 x i32>, <4 x i32>* %7, align 8, !tbaa !51
  %9 = shufflevector <4 x i32> %8, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %9
}

; Function Attrs: nounwind
define <3 x i32> @_Z20rsGetElementAt_uint313rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i32>*
  %11 = load <4 x i32>, <4 x i32>* %10, align 8, !tbaa !51
  %12 = shufflevector <4 x i32> %11, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %12
}

; Function Attrs: nounwind
define <3 x i32> @_Z20rsGetElementAt_uint313rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 8, !tbaa !51
  %15 = shufflevector <4 x i32> %14, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %15
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint413rs_allocationDv4_jj([1 x i32] %a.coerce, <4 x i32> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %7, align 16, !tbaa !52
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint413rs_allocationDv4_jjj([1 x i32] %a.coerce, <4 x i32> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %10, align 16, !tbaa !52
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_uint413rs_allocationDv4_jjjj([1 x i32] %a.coerce, <4 x i32> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %13, align 16, !tbaa !52
  ret void
}

; Function Attrs: nounwind
define <4 x i32> @_Z20rsGetElementAt_uint413rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i32>*
  %8 = load <4 x i32>, <4 x i32>* %7, align 16, !tbaa !52
  ret <4 x i32> %8
}

; Function Attrs: nounwind
define <4 x i32> @_Z20rsGetElementAt_uint413rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i32>*
  %11 = load <4 x i32>, <4 x i32>* %10, align 16, !tbaa !52
  ret <4 x i32> %11
}

; Function Attrs: nounwind
define <4 x i32> @_Z20rsGetElementAt_uint413rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 16, !tbaa !52
  ret <4 x i32> %14
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_long13rs_allocationlj([1 x i32] %a.coerce, i64 %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i64*
  store i64 %val, i64* %7, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_long13rs_allocationljj([1 x i32] %a.coerce, i64 %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i64*
  store i64 %val, i64* %10, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind
define void @_Z19rsSetElementAt_long13rs_allocationljjj([1 x i32] %a.coerce, i64 %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  store i64 %val, i64* %13, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind
define i64 @_Z19rsGetElementAt_long13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !53
  ret i64 %8
}

; Function Attrs: nounwind
define i64 @_Z19rsGetElementAt_long13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !53
  ret i64 %11
}

; Function Attrs: nounwind
define i64 @_Z19rsGetElementAt_long13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !53
  ret i64 %14
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long213rs_allocationDv2_lj([1 x i32] %a.coerce, <2 x i64> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %7, align 16, !tbaa !54
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long213rs_allocationDv2_ljj([1 x i32] %a.coerce, <2 x i64> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %10, align 16, !tbaa !54
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long213rs_allocationDv2_ljjj([1 x i32] %a.coerce, <2 x i64> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %13, align 16, !tbaa !54
  ret void
}

; Function Attrs: nounwind
define <2 x i64> @_Z20rsGetElementAt_long213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i64>*
  %8 = load <2 x i64>, <2 x i64>* %7, align 16, !tbaa !54
  ret <2 x i64> %8
}

; Function Attrs: nounwind
define <2 x i64> @_Z20rsGetElementAt_long213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i64>*
  %11 = load <2 x i64>, <2 x i64>* %10, align 16, !tbaa !54
  ret <2 x i64> %11
}

; Function Attrs: nounwind
define <2 x i64> @_Z20rsGetElementAt_long213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  %14 = load <2 x i64>, <2 x i64>* %13, align 16, !tbaa !54
  ret <2 x i64> %14
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long313rs_allocationDv3_lj([1 x i32] %a.coerce, <3 x i64> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 32
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i64>*
  store <4 x i64> %7, <4 x i64>* %8, align 32, !tbaa !55
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long313rs_allocationDv3_ljj([1 x i32] %a.coerce, <3 x i64> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i64>*
  store <4 x i64> %10, <4 x i64>* %11, align 32, !tbaa !55
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long313rs_allocationDv3_ljjj([1 x i32] %a.coerce, <3 x i64> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %13, <4 x i64>* %14, align 32, !tbaa !55
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsGetElementAt_long313rs_allocationj(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = mul i32 %x, 32
  %7 = getelementptr inbounds i8, i8* %5, i32 %6
  %8 = bitcast i8* %7 to <4 x i64>*
  %9 = load <4 x i64>, <4 x i64>* %8, align 32
  %10 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %9, <4 x i64>* %10, align 32, !tbaa !55
  %11 = bitcast <3 x i64>* %1 to <4 x i64>*
  %12 = load <4 x i64>, <4 x i64>* %11, align 32
  %13 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsGetElementAt_long313rs_allocationjj(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %7
  %9 = add i32 %tmp1.i.i, %8
  %10 = getelementptr inbounds i8, i8* %5, i32 %9
  %11 = bitcast i8* %10 to <4 x i64>*
  %12 = load <4 x i64>, <4 x i64>* %11, align 32
  %13 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !55
  %14 = bitcast <3 x i64>* %1 to <4 x i64>*
  %15 = load <4 x i64>, <4 x i64>* %14, align 32
  %16 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %15, <4 x i64>* %16, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsGetElementAt_long313rs_allocationjjj(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !21
  %10 = mul i32 %x, 32
  %11 = mul i32 %9, %z
  %tmp.i.i = add i32 %11, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %7
  %12 = add i32 %tmp1.i.i, %10
  %13 = getelementptr inbounds i8, i8* %5, i32 %12
  %14 = bitcast i8* %13 to <4 x i64>*
  %15 = load <4 x i64>, <4 x i64>* %14, align 32
  %16 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %15, <4 x i64>* %16, align 32, !tbaa !55
  %17 = bitcast <3 x i64>* %1 to <4 x i64>*
  %18 = load <4 x i64>, <4 x i64>* %17, align 32
  %19 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %18, <4 x i64>* %19, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long413rs_allocationDv4_lj([1 x i32] %a.coerce, <4 x i64> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 32
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %7, align 32, !tbaa !56
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long413rs_allocationDv4_ljj([1 x i32] %a.coerce, <4 x i64> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %10, align 32, !tbaa !56
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_long413rs_allocationDv4_ljjj([1 x i32] %a.coerce, <4 x i64> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %13, align 32, !tbaa !56
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsGetElementAt_long413rs_allocationj(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x) #5 {
  %1 = alloca <4 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = mul i32 %x, 32
  %7 = getelementptr inbounds i8, i8* %5, i32 %6
  %8 = bitcast i8* %7 to <4 x i64>*
  %9 = load <4 x i64>, <4 x i64>* %8, align 32, !tbaa !28
  store <4 x i64> %9, <4 x i64>* %1, align 32, !tbaa !56
  %10 = load <4 x i64>, <4 x i64>* %1, align 32, !tbaa !19
  store <4 x i64> %10, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsGetElementAt_long413rs_allocationjj(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = alloca <4 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %7
  %9 = add i32 %tmp1.i.i, %8
  %10 = getelementptr inbounds i8, i8* %5, i32 %9
  %11 = bitcast i8* %10 to <4 x i64>*
  %12 = load <4 x i64>, <4 x i64>* %11, align 32, !tbaa !28
  store <4 x i64> %12, <4 x i64>* %1, align 32, !tbaa !56
  %13 = load <4 x i64>, <4 x i64>* %1, align 32, !tbaa !19
  store <4 x i64> %13, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsGetElementAt_long413rs_allocationjjj(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = alloca <4 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !21
  %10 = mul i32 %x, 32
  %11 = mul i32 %9, %z
  %tmp.i.i = add i32 %11, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %7
  %12 = add i32 %tmp1.i.i, %10
  %13 = getelementptr inbounds i8, i8* %5, i32 %12
  %14 = bitcast i8* %13 to <4 x i64>*
  %15 = load <4 x i64>, <4 x i64>* %14, align 32, !tbaa !28
  store <4 x i64> %15, <4 x i64>* %1, align 32, !tbaa !56
  %16 = load <4 x i64>, <4 x i64>* %1, align 32, !tbaa !19
  store <4 x i64> %16, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_ulong13rs_allocationyj([1 x i32] %a.coerce, i64 %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i64*
  store i64 %val, i64* %7, align 8, !tbaa !57
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_ulong13rs_allocationyjj([1 x i32] %a.coerce, i64 %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i64*
  store i64 %val, i64* %10, align 8, !tbaa !57
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_ulong13rs_allocationyjjj([1 x i32] %a.coerce, i64 %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  store i64 %val, i64* %13, align 8, !tbaa !57
  ret void
}

; Function Attrs: nounwind
define i64 @_Z20rsGetElementAt_ulong13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !57
  ret i64 %8
}

; Function Attrs: nounwind
define i64 @_Z20rsGetElementAt_ulong13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !57
  ret i64 %11
}

; Function Attrs: nounwind
define i64 @_Z20rsGetElementAt_ulong13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !57
  ret i64 %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong213rs_allocationDv2_yj([1 x i32] %a.coerce, <2 x i64> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %7, align 16, !tbaa !58
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong213rs_allocationDv2_yjj([1 x i32] %a.coerce, <2 x i64> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %10, align 16, !tbaa !58
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong213rs_allocationDv2_yjjj([1 x i32] %a.coerce, <2 x i64> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %13, align 16, !tbaa !58
  ret void
}

; Function Attrs: nounwind
define <2 x i64> @_Z21rsGetElementAt_ulong213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x i64>*
  %8 = load <2 x i64>, <2 x i64>* %7, align 16, !tbaa !58
  ret <2 x i64> %8
}

; Function Attrs: nounwind
define <2 x i64> @_Z21rsGetElementAt_ulong213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x i64>*
  %11 = load <2 x i64>, <2 x i64>* %10, align 16, !tbaa !58
  ret <2 x i64> %11
}

; Function Attrs: nounwind
define <2 x i64> @_Z21rsGetElementAt_ulong213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  %14 = load <2 x i64>, <2 x i64>* %13, align 16, !tbaa !58
  ret <2 x i64> %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong313rs_allocationDv3_yj([1 x i32] %a.coerce, <3 x i64> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 32
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x i64>*
  store <4 x i64> %7, <4 x i64>* %8, align 32, !tbaa !59
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong313rs_allocationDv3_yjj([1 x i32] %a.coerce, <3 x i64> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x i64>*
  store <4 x i64> %10, <4 x i64>* %11, align 32, !tbaa !59
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong313rs_allocationDv3_yjjj([1 x i32] %a.coerce, <3 x i64> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %13, <4 x i64>* %14, align 32, !tbaa !59
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsGetElementAt_ulong313rs_allocationj(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = mul i32 %x, 32
  %7 = getelementptr inbounds i8, i8* %5, i32 %6
  %8 = bitcast i8* %7 to <4 x i64>*
  %9 = load <4 x i64>, <4 x i64>* %8, align 32
  %10 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %9, <4 x i64>* %10, align 32, !tbaa !59
  %11 = bitcast <3 x i64>* %1 to <4 x i64>*
  %12 = load <4 x i64>, <4 x i64>* %11, align 32
  %13 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsGetElementAt_ulong313rs_allocationjj(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %7
  %9 = add i32 %tmp1.i.i, %8
  %10 = getelementptr inbounds i8, i8* %5, i32 %9
  %11 = bitcast i8* %10 to <4 x i64>*
  %12 = load <4 x i64>, <4 x i64>* %11, align 32
  %13 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !59
  %14 = bitcast <3 x i64>* %1 to <4 x i64>*
  %15 = load <4 x i64>, <4 x i64>* %14, align 32
  %16 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %15, <4 x i64>* %16, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsGetElementAt_ulong313rs_allocationjjj(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !21
  %10 = mul i32 %x, 32
  %11 = mul i32 %9, %z
  %tmp.i.i = add i32 %11, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %7
  %12 = add i32 %tmp1.i.i, %10
  %13 = getelementptr inbounds i8, i8* %5, i32 %12
  %14 = bitcast i8* %13 to <4 x i64>*
  %15 = load <4 x i64>, <4 x i64>* %14, align 32
  %16 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %15, <4 x i64>* %16, align 32, !tbaa !59
  %17 = bitcast <3 x i64>* %1 to <4 x i64>*
  %18 = load <4 x i64>, <4 x i64>* %17, align 32
  %19 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %18, <4 x i64>* %19, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong413rs_allocationDv4_yj([1 x i32] %a.coerce, <4 x i64> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 32
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %7, align 32, !tbaa !60
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong413rs_allocationDv4_yjj([1 x i32] %a.coerce, <4 x i64> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %10, align 32, !tbaa !60
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_ulong413rs_allocationDv4_yjjj([1 x i32] %a.coerce, <4 x i64> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %13, align 32, !tbaa !60
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsGetElementAt_ulong413rs_allocationj(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x) #5 {
  %1 = alloca <4 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = mul i32 %x, 32
  %7 = getelementptr inbounds i8, i8* %5, i32 %6
  %8 = bitcast i8* %7 to <4 x i64>*
  %9 = load <4 x i64>, <4 x i64>* %8, align 32, !tbaa !28
  store <4 x i64> %9, <4 x i64>* %1, align 32, !tbaa !60
  %10 = load <4 x i64>, <4 x i64>* %1, align 32, !tbaa !19
  store <4 x i64> %10, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsGetElementAt_ulong413rs_allocationjj(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = alloca <4 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %7
  %9 = add i32 %tmp1.i.i, %8
  %10 = getelementptr inbounds i8, i8* %5, i32 %9
  %11 = bitcast i8* %10 to <4 x i64>*
  %12 = load <4 x i64>, <4 x i64>* %11, align 32, !tbaa !28
  store <4 x i64> %12, <4 x i64>* %1, align 32, !tbaa !60
  %13 = load <4 x i64>, <4 x i64>* %1, align 32, !tbaa !19
  store <4 x i64> %13, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsGetElementAt_ulong413rs_allocationjjj(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = alloca <4 x i64>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !21
  %10 = mul i32 %x, 32
  %11 = mul i32 %9, %z
  %tmp.i.i = add i32 %11, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %7
  %12 = add i32 %tmp1.i.i, %10
  %13 = getelementptr inbounds i8, i8* %5, i32 %12
  %14 = bitcast i8* %13 to <4 x i64>*
  %15 = load <4 x i64>, <4 x i64>* %14, align 32, !tbaa !28
  store <4 x i64> %15, <4 x i64>* %1, align 32, !tbaa !60
  %16 = load <4 x i64>, <4 x i64>* %1, align 32, !tbaa !19
  store <4 x i64> %16, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_float13rs_allocationfj([1 x i32] %a.coerce, float %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to float*
  store float %val, float* %7, align 4, !tbaa !61
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_float13rs_allocationfjj([1 x i32] %a.coerce, float %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to float*
  store float %val, float* %10, align 4, !tbaa !61
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsSetElementAt_float13rs_allocationfjjj([1 x i32] %a.coerce, float %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to float*
  store float %val, float* %13, align 4, !tbaa !61
  ret void
}

; Function Attrs: nounwind
define float @_Z20rsGetElementAt_float13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 4
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to float*
  %8 = load float, float* %7, align 4, !tbaa !61
  ret float %8
}

; Function Attrs: nounwind
define float @_Z20rsGetElementAt_float13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 4
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to float*
  %11 = load float, float* %10, align 4, !tbaa !61
  ret float %11
}

; Function Attrs: nounwind
define float @_Z20rsGetElementAt_float13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to float*
  %14 = load float, float* %13, align 4, !tbaa !61
  ret float %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float213rs_allocationDv2_fj([1 x i32] %a.coerce, <2 x float> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x float>*
  store <2 x float> %val, <2 x float>* %7, align 8, !tbaa !62
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float213rs_allocationDv2_fjj([1 x i32] %a.coerce, <2 x float> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x float>*
  store <2 x float> %val, <2 x float>* %10, align 8, !tbaa !62
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float213rs_allocationDv2_fjjj([1 x i32] %a.coerce, <2 x float> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x float>*
  store <2 x float> %val, <2 x float>* %13, align 8, !tbaa !62
  ret void
}

; Function Attrs: nounwind
define <2 x float> @_Z21rsGetElementAt_float213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x float>*
  %8 = load <2 x float>, <2 x float>* %7, align 8, !tbaa !62
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <2 x float> @_Z21rsGetElementAt_float213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x float>*
  %11 = load <2 x float>, <2 x float>* %10, align 8, !tbaa !62
  ret <2 x float> %11
}

; Function Attrs: nounwind
define <2 x float> @_Z21rsGetElementAt_float213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x float>*
  %14 = load <2 x float>, <2 x float>* %13, align 8, !tbaa !62
  ret <2 x float> %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float313rs_allocationDv3_fj([1 x i32] %a.coerce, <3 x float> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x float> %val, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x float>*
  store <4 x float> %7, <4 x float>* %8, align 16, !tbaa !63
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float313rs_allocationDv3_fjj([1 x i32] %a.coerce, <3 x float> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x float> %val, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x float>*
  store <4 x float> %10, <4 x float>* %11, align 16, !tbaa !63
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float313rs_allocationDv3_fjjj([1 x i32] %a.coerce, <3 x float> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x float> %val, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x float>*
  store <4 x float> %13, <4 x float>* %14, align 16, !tbaa !63
  ret void
}

; Function Attrs: nounwind
define <3 x float> @_Z21rsGetElementAt_float313rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x float>*
  %8 = load <4 x float>, <4 x float>* %7, align 8, !tbaa !63
  %9 = shufflevector <4 x float> %8, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <3 x float> @_Z21rsGetElementAt_float313rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x float>*
  %11 = load <4 x float>, <4 x float>* %10, align 8, !tbaa !63
  %12 = shufflevector <4 x float> %11, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <3 x float> @_Z21rsGetElementAt_float313rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x float>*
  %14 = load <4 x float>, <4 x float>* %13, align 8, !tbaa !63
  %15 = shufflevector <4 x float> %14, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %15
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float413rs_allocationDv4_fj([1 x i32] %a.coerce, <4 x float> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x float>*
  store <4 x float> %val, <4 x float>* %7, align 16, !tbaa !64
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float413rs_allocationDv4_fjj([1 x i32] %a.coerce, <4 x float> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x float>*
  store <4 x float> %val, <4 x float>* %10, align 16, !tbaa !64
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_float413rs_allocationDv4_fjjj([1 x i32] %a.coerce, <4 x float> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x float>*
  store <4 x float> %val, <4 x float>* %13, align 16, !tbaa !64
  ret void
}

; Function Attrs: nounwind
define <4 x float> @_Z21rsGetElementAt_float413rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x float>*
  %8 = load <4 x float>, <4 x float>* %7, align 16, !tbaa !64
  ret <4 x float> %8
}

; Function Attrs: nounwind
define <4 x float> @_Z21rsGetElementAt_float413rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x float>*
  %11 = load <4 x float>, <4 x float>* %10, align 16, !tbaa !64
  ret <4 x float> %11
}

; Function Attrs: nounwind
define <4 x float> @_Z21rsGetElementAt_float413rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x float>*
  %14 = load <4 x float>, <4 x float>* %13, align 16, !tbaa !64
  ret <4 x float> %14
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_double13rs_allocationdj([1 x i32] %a.coerce, double %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to double*
  store double %val, double* %7, align 8, !tbaa !65
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_double13rs_allocationdjj([1 x i32] %a.coerce, double %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to double*
  store double %val, double* %10, align 8, !tbaa !65
  ret void
}

; Function Attrs: nounwind
define void @_Z21rsSetElementAt_double13rs_allocationdjjj([1 x i32] %a.coerce, double %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to double*
  store double %val, double* %13, align 8, !tbaa !65
  ret void
}

; Function Attrs: nounwind
define double @_Z21rsGetElementAt_double13rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 8
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to double*
  %8 = load double, double* %7, align 8, !tbaa !65
  ret double %8
}

; Function Attrs: nounwind
define double @_Z21rsGetElementAt_double13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 8
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to double*
  %11 = load double, double* %10, align 8, !tbaa !65
  ret double %11
}

; Function Attrs: nounwind
define double @_Z21rsGetElementAt_double13rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to double*
  %14 = load double, double* %13, align 8, !tbaa !65
  ret double %14
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double213rs_allocationDv2_dj([1 x i32] %a.coerce, <2 x double> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x double>*
  store <2 x double> %val, <2 x double>* %7, align 16, !tbaa !66
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double213rs_allocationDv2_djj([1 x i32] %a.coerce, <2 x double> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x double>*
  store <2 x double> %val, <2 x double>* %10, align 16, !tbaa !66
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double213rs_allocationDv2_djjj([1 x i32] %a.coerce, <2 x double> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x double>*
  store <2 x double> %val, <2 x double>* %13, align 16, !tbaa !66
  ret void
}

; Function Attrs: nounwind
define <2 x double> @_Z22rsGetElementAt_double213rs_allocationj([1 x i32] %a.coerce, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 16
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <2 x double>*
  %8 = load <2 x double>, <2 x double>* %7, align 16, !tbaa !66
  ret <2 x double> %8
}

; Function Attrs: nounwind
define <2 x double> @_Z22rsGetElementAt_double213rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 16
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <2 x double>*
  %11 = load <2 x double>, <2 x double>* %10, align 16, !tbaa !66
  ret <2 x double> %11
}

; Function Attrs: nounwind
define <2 x double> @_Z22rsGetElementAt_double213rs_allocationjjj([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x double>*
  %14 = load <2 x double>, <2 x double>* %13, align 16, !tbaa !66
  ret <2 x double> %14
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double313rs_allocationDv3_dj([1 x i32] %a.coerce, <3 x double> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 32
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = shufflevector <3 x double> %val, <3 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %8 = bitcast i8* %6 to <4 x double>*
  store <4 x double> %7, <4 x double>* %8, align 32, !tbaa !67
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double313rs_allocationDv3_djj([1 x i32] %a.coerce, <3 x double> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = shufflevector <3 x double> %val, <3 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %11 = bitcast i8* %9 to <4 x double>*
  store <4 x double> %10, <4 x double>* %11, align 32, !tbaa !67
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double313rs_allocationDv3_djjj([1 x i32] %a.coerce, <3 x double> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x double> %val, <3 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x double>*
  store <4 x double> %13, <4 x double>* %14, align 32, !tbaa !67
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsGetElementAt_double313rs_allocationj(<3 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x) #5 {
  %1 = alloca <3 x double>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = mul i32 %x, 32
  %7 = getelementptr inbounds i8, i8* %5, i32 %6
  %8 = bitcast i8* %7 to <4 x double>*
  %9 = load <4 x double>, <4 x double>* %8, align 32
  %10 = bitcast <3 x double>* %1 to <4 x double>*
  store <4 x double> %9, <4 x double>* %10, align 32, !tbaa !67
  %11 = bitcast <3 x double>* %1 to <4 x double>*
  %12 = load <4 x double>, <4 x double>* %11, align 32
  %13 = bitcast <3 x double>* %agg.result to <4 x double>*
  store <4 x double> %12, <4 x double>* %13, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsGetElementAt_double313rs_allocationjj(<3 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = alloca <3 x double>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %7
  %9 = add i32 %tmp1.i.i, %8
  %10 = getelementptr inbounds i8, i8* %5, i32 %9
  %11 = bitcast i8* %10 to <4 x double>*
  %12 = load <4 x double>, <4 x double>* %11, align 32
  %13 = bitcast <3 x double>* %1 to <4 x double>*
  store <4 x double> %12, <4 x double>* %13, align 32, !tbaa !67
  %14 = bitcast <3 x double>* %1 to <4 x double>*
  %15 = load <4 x double>, <4 x double>* %14, align 32
  %16 = bitcast <3 x double>* %agg.result to <4 x double>*
  store <4 x double> %15, <4 x double>* %16, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsGetElementAt_double313rs_allocationjjj(<3 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = alloca <3 x double>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !21
  %10 = mul i32 %x, 32
  %11 = mul i32 %9, %z
  %tmp.i.i = add i32 %11, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %7
  %12 = add i32 %tmp1.i.i, %10
  %13 = getelementptr inbounds i8, i8* %5, i32 %12
  %14 = bitcast i8* %13 to <4 x double>*
  %15 = load <4 x double>, <4 x double>* %14, align 32
  %16 = bitcast <3 x double>* %1 to <4 x double>*
  store <4 x double> %15, <4 x double>* %16, align 32, !tbaa !67
  %17 = bitcast <3 x double>* %1 to <4 x double>*
  %18 = load <4 x double>, <4 x double>* %17, align 32
  %19 = bitcast <3 x double>* %agg.result to <4 x double>*
  store <4 x double> %18, <4 x double>* %19, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double413rs_allocationDv4_dj([1 x i32] %a.coerce, <4 x double> %val, i32 %x) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = mul i32 %x, 32
  %6 = getelementptr inbounds i8, i8* %4, i32 %5
  %7 = bitcast i8* %6 to <4 x double>*
  store <4 x double> %val, <4 x double>* %7, align 32, !tbaa !68
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double413rs_allocationDv4_djj([1 x i32] %a.coerce, <4 x double> %val, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %6
  %8 = add i32 %tmp1.i.i, %7
  %9 = getelementptr inbounds i8, i8* %4, i32 %8
  %10 = bitcast i8* %9 to <4 x double>*
  store <4 x double> %val, <4 x double>* %10, align 32, !tbaa !68
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsSetElementAt_double413rs_allocationDv4_djjj([1 x i32] %a.coerce, <4 x double> %val, i32 %x, i32 %y, i32 %z) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i.i = add i32 %10, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %6
  %11 = add i32 %tmp1.i.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x double>*
  store <4 x double> %val, <4 x double>* %13, align 32, !tbaa !68
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsGetElementAt_double413rs_allocationj(<4 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x) #5 {
  %1 = alloca <4 x double>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = mul i32 %x, 32
  %7 = getelementptr inbounds i8, i8* %5, i32 %6
  %8 = bitcast i8* %7 to <4 x double>*
  %9 = load <4 x double>, <4 x double>* %8, align 32, !tbaa !28
  store <4 x double> %9, <4 x double>* %1, align 32, !tbaa !68
  %10 = load <4 x double>, <4 x double>* %1, align 32, !tbaa !19
  store <4 x double> %10, <4 x double>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsGetElementAt_double413rs_allocationjj(<4 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = alloca <4 x double>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = mul i32 %x, 32
  %tmp1.i.i = mul i32 %y, %7
  %9 = add i32 %tmp1.i.i, %8
  %10 = getelementptr inbounds i8, i8* %5, i32 %9
  %11 = bitcast i8* %10 to <4 x double>*
  %12 = load <4 x double>, <4 x double>* %11, align 32, !tbaa !28
  store <4 x double> %12, <4 x double>* %1, align 32, !tbaa !68
  %13 = load <4 x double>, <4 x double>* %1, align 32, !tbaa !19
  store <4 x double> %13, <4 x double>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z22rsGetElementAt_double413rs_allocationjjj(<4 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #5 {
  %1 = alloca <4 x double>, align 32
  %2 = extractvalue [1 x i32] %a.coerce, 0
  %3 = inttoptr i32 %2 to %struct.Allocation*
  %4 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %5 = load i8*, i8** %4, align 4, !tbaa !22
  %6 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !21
  %8 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !21
  %10 = mul i32 %x, 32
  %11 = mul i32 %9, %z
  %tmp.i.i = add i32 %11, %y
  %tmp1.i.i = mul i32 %tmp.i.i, %7
  %12 = add i32 %tmp1.i.i, %10
  %13 = getelementptr inbounds i8, i8* %5, i32 %12
  %14 = bitcast i8* %13 to <4 x double>*
  %15 = load <4 x double>, <4 x double>* %14, align 32, !tbaa !28
  store <4 x double> %15, <4 x double>* %1, align 32, !tbaa !68
  %16 = load <4 x double>, <4 x double>* %1, align 32, !tbaa !19
  store <4 x double> %16, <4 x double>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define zeroext i8 @_Z25rsGetElementAtYuv_uchar_Y13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #5 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %tmp1.i.i = mul i32 %y, %6
  %7 = add i32 %tmp1.i.i, %x
  %8 = getelementptr inbounds i8, i8* %4, i32 %7
  %9 = load i8, i8* %8, align 1, !tbaa !33
  ret i8 %9
}

; Function Attrs: nounwind readonly
define zeroext i8 @_Z25rsGetElementAtYuv_uchar_U13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 4, i32 1
  %4 = load i32, i32* %3, align 4, !tbaa !21
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 4, i32 0
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 1, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 1, i32 0
  %10 = load i8*, i8** %9, align 4, !tbaa !22
  %11 = lshr i32 %x, %6
  %12 = mul i32 %11, %4
  %13 = lshr i32 %y, %6
  %14 = mul i32 %13, %8
  %15 = add i32 %12, %14
  %16 = getelementptr inbounds i8, i8* %10, i32 %15
  %17 = load i8, i8* %16, align 1, !tbaa !19
  ret i8 %17
}

; Function Attrs: nounwind readonly
define zeroext i8 @_Z25rsGetElementAtYuv_uchar_V13rs_allocationjj([1 x i32] %a.coerce, i32 %x, i32 %y) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 4, i32 1
  %4 = load i32, i32* %3, align 4, !tbaa !21
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 4, i32 0
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 2, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 2, i32 0
  %10 = load i8*, i8** %9, align 4, !tbaa !22
  %11 = lshr i32 %x, %6
  %12 = mul i32 %11, %4
  %13 = lshr i32 %y, %6
  %14 = mul i32 %13, %8
  %15 = add i32 %12, %14
  %16 = getelementptr inbounds i8, i8* %10, i32 %15
  %17 = load i8, i8* %16, align 1, !tbaa !19
  ret i8 %17
}

; Function Attrs: nounwind
define <2 x float> @_Z4acosDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4acosf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4acosf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4acosf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4acosDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4acosf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4acosf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4acosf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4acosDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4acosf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4acosf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4acosf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4acosf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z5acoshDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5acoshf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5acoshf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5acoshf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5acoshDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5acoshf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5acoshf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5acoshf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5acoshDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5acoshf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5acoshf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5acoshf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5acoshf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z6acospif(float %v) #5 {
  %1 = tail call float @_Z4acosf(float %v) #12
  %2 = fdiv float %1, 0x400921FB60000000
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z6acospiDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4acosf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = tail call float @_Z4acosf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z6acospiDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4acosf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = tail call float @_Z4acosf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = tail call float @_Z4acosf(float %9) #12
  %11 = fdiv float %10, 0x400921FB60000000
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z6acospiDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4acosf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = tail call float @_Z4acosf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = tail call float @_Z4acosf(float %9) #12
  %11 = fdiv float %10, 0x400921FB60000000
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = tail call float @_Z4acosf(float %13) #12
  %15 = fdiv float %14, 0x400921FB60000000
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z4asinDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4asinf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4asinf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4asinf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4asinDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4asinf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4asinf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4asinf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4asinDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4asinf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4asinf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4asinf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4asinf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z5asinhDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5asinhf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5asinhf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5asinhf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5asinhDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5asinhf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5asinhf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5asinhf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5asinhDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5asinhf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5asinhf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5asinhf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5asinhf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z6asinpif(float %v) #5 {
  %1 = tail call float @_Z4asinf(float %v) #12
  %2 = fdiv float %1, 0x400921FB60000000
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z6asinpiDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4asinf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = tail call float @_Z4asinf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z6asinpiDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4asinf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = tail call float @_Z4asinf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = tail call float @_Z4asinf(float %9) #12
  %11 = fdiv float %10, 0x400921FB60000000
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z6asinpiDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4asinf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = tail call float @_Z4asinf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = tail call float @_Z4asinf(float %9) #12
  %11 = fdiv float %10, 0x400921FB60000000
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = tail call float @_Z4asinf(float %13) #12
  %15 = fdiv float %14, 0x400921FB60000000
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z4atanDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4atanf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4atanf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4atanf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4atanDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4atanf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4atanf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4atanf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4atanDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4atanf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4atanf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4atanf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4atanf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z5atan2Dv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z5atan2ff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z5atan2ff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z5atan2ff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5atan2Dv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z5atan2ff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z5atan2ff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z5atan2ff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5atan2Dv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z5atan2ff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z5atan2ff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z5atan2ff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z5atan2ff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z5atanhDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5atanhf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5atanhf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5atanhf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5atanhDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5atanhf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5atanhf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5atanhf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5atanhDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5atanhf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5atanhf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5atanhf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5atanhf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z6atanpif(float %v) #5 {
  %1 = tail call float @_Z4atanf(float %v) #12
  %2 = fdiv float %1, 0x400921FB60000000
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z6atanpiDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4atanf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = tail call float @_Z4atanf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z6atanpiDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4atanf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = tail call float @_Z4atanf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = tail call float @_Z4atanf(float %9) #12
  %11 = fdiv float %10, 0x400921FB60000000
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z6atanpiDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4atanf(float %1) #12
  %3 = fdiv float %2, 0x400921FB60000000
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = tail call float @_Z4atanf(float %5) #12
  %7 = fdiv float %6, 0x400921FB60000000
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = tail call float @_Z4atanf(float %9) #12
  %11 = fdiv float %10, 0x400921FB60000000
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = tail call float @_Z4atanf(float %13) #12
  %15 = fdiv float %14, 0x400921FB60000000
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define float @_Z7atan2piff(float %y, float %x) #5 {
  %1 = tail call float @_Z5atan2ff(float %y, float %x) #12
  %2 = fdiv float %1, 0x400921FB60000000
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z7atan2piDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z5atan2ff(float %1, float %2) #12
  %4 = fdiv float %3, 0x400921FB60000000
  %5 = insertelement <2 x float> undef, float %4, i32 0
  %6 = extractelement <2 x float> %v1, i32 1
  %7 = extractelement <2 x float> %v2, i32 1
  %8 = tail call float @_Z5atan2ff(float %6, float %7) #12
  %9 = fdiv float %8, 0x400921FB60000000
  %10 = insertelement <2 x float> %5, float %9, i32 1
  ret <2 x float> %10
}

; Function Attrs: nounwind
define <3 x float> @_Z7atan2piDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z5atan2ff(float %1, float %2) #12
  %4 = fdiv float %3, 0x400921FB60000000
  %5 = insertelement <3 x float> undef, float %4, i32 0
  %6 = extractelement <3 x float> %v1, i32 1
  %7 = extractelement <3 x float> %v2, i32 1
  %8 = tail call float @_Z5atan2ff(float %6, float %7) #12
  %9 = fdiv float %8, 0x400921FB60000000
  %10 = insertelement <3 x float> %5, float %9, i32 1
  %11 = extractelement <3 x float> %v1, i32 2
  %12 = extractelement <3 x float> %v2, i32 2
  %13 = tail call float @_Z5atan2ff(float %11, float %12) #12
  %14 = fdiv float %13, 0x400921FB60000000
  %15 = insertelement <3 x float> %10, float %14, i32 2
  ret <3 x float> %15
}

; Function Attrs: nounwind
define <4 x float> @_Z7atan2piDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z5atan2ff(float %1, float %2) #12
  %4 = fdiv float %3, 0x400921FB60000000
  %5 = insertelement <4 x float> undef, float %4, i32 0
  %6 = extractelement <4 x float> %v1, i32 1
  %7 = extractelement <4 x float> %v2, i32 1
  %8 = tail call float @_Z5atan2ff(float %6, float %7) #12
  %9 = fdiv float %8, 0x400921FB60000000
  %10 = insertelement <4 x float> %5, float %9, i32 1
  %11 = extractelement <4 x float> %v1, i32 2
  %12 = extractelement <4 x float> %v2, i32 2
  %13 = tail call float @_Z5atan2ff(float %11, float %12) #12
  %14 = fdiv float %13, 0x400921FB60000000
  %15 = insertelement <4 x float> %10, float %14, i32 2
  %16 = extractelement <4 x float> %v1, i32 3
  %17 = extractelement <4 x float> %v2, i32 3
  %18 = tail call float @_Z5atan2ff(float %16, float %17) #12
  %19 = fdiv float %18, 0x400921FB60000000
  %20 = insertelement <4 x float> %15, float %19, i32 3
  ret <4 x float> %20
}

; Function Attrs: nounwind
define <2 x float> @_Z4cbrtDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4cbrtf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4cbrtf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4cbrtf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4cbrtDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4cbrtf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4cbrtf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4cbrtf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4cbrtDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4cbrtf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4cbrtf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4cbrtf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4cbrtf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z4ceilDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4ceilf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4ceilf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4ceilf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4ceilDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4ceilf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4ceilf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4ceilf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4ceilDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4ceilf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4ceilf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4ceilf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4ceilf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z8copysignDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z8copysignff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z8copysignff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z8copysignff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z8copysignDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z8copysignff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z8copysignff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z8copysignff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z8copysignDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z8copysignff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z8copysignff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z8copysignff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z8copysignff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z3cosDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z3cosf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z3cosf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z3cosf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3cosDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z3cosf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z3cosf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z3cosf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z3cosDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z3cosf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z3cosf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z3cosf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z3cosf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z4coshDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4coshf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4coshf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4coshf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4coshDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4coshf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4coshf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4coshf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4coshDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4coshf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4coshf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4coshf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4coshf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z5cospif(float %v) #5 {
  %1 = fmul float %v, 0x400921FB60000000
  %2 = tail call float @_Z3cosf(float %1) #12
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z5cospiDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3cosf(float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3cosf(float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z5cospiDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3cosf(float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3cosf(float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = fmul float %9, 0x400921FB60000000
  %11 = tail call float @_Z3cosf(float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5cospiDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3cosf(float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3cosf(float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = fmul float %9, 0x400921FB60000000
  %11 = tail call float @_Z3cosf(float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = fmul float %13, 0x400921FB60000000
  %15 = tail call float @_Z3cosf(float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z4erfcDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4erfcf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4erfcf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4erfcf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4erfcDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4erfcf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4erfcf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4erfcf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4erfcDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4erfcf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4erfcf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4erfcf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4erfcf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z3erfDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z3erff(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z3erff(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z3erff(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3erfDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z3erff(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z3erff(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z3erff(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z3erfDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z3erff(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z3erff(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z3erff(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z3erff(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z3expDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z3expf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z3expf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z3expf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3expDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z3expf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z3expf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z3expf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z3expDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z3expf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z3expf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z3expf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z3expf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z4exp2Dv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4exp2f(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4exp2f(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4exp2f(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4exp2Dv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4exp2f(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4exp2f(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4exp2f(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4exp2Dv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4exp2f(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4exp2f(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4exp2f(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4exp2f(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z5exp10f(float %v) #5 {
  %1 = fmul float %v, 0x400A934F00000000
  %2 = tail call float @_Z4exp2f(float %1) #12
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z5exp10Dv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = fmul float %1, 0x400A934F00000000
  %3 = tail call float @_Z4exp2f(float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = fmul float %5, 0x400A934F00000000
  %7 = tail call float @_Z4exp2f(float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z5exp10Dv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = fmul float %1, 0x400A934F00000000
  %3 = tail call float @_Z4exp2f(float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = fmul float %5, 0x400A934F00000000
  %7 = tail call float @_Z4exp2f(float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = fmul float %9, 0x400A934F00000000
  %11 = tail call float @_Z4exp2f(float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5exp10Dv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = fmul float %1, 0x400A934F00000000
  %3 = tail call float @_Z4exp2f(float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = fmul float %5, 0x400A934F00000000
  %7 = tail call float @_Z4exp2f(float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = fmul float %9, 0x400A934F00000000
  %11 = tail call float @_Z4exp2f(float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = fmul float %13, 0x400A934F00000000
  %15 = tail call float @_Z4exp2f(float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z5expm1Dv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5expm1f(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5expm1f(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5expm1f(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5expm1Dv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5expm1f(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5expm1f(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5expm1f(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5expm1Dv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5expm1f(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5expm1f(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5expm1f(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5expm1f(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind readnone
define float @_Z4fabsf(float %v) #7 {
  %1 = bitcast float %v to i32
  %2 = and i32 %1, 2147483647
  %3 = bitcast i32 %2 to float
  ret float %3
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4fabsDv2_f(<2 x float> %v) #7 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = and i32 %2, 2147483647
  %4 = bitcast i32 %3 to float
  %5 = insertelement <2 x float> undef, float %4, i32 0
  %6 = extractelement <2 x float> %v, i32 1
  %7 = bitcast float %6 to i32
  %8 = and i32 %7, 2147483647
  %9 = bitcast i32 %8 to float
  %10 = insertelement <2 x float> %5, float %9, i32 1
  ret <2 x float> %10
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4fabsDv3_f(<3 x float> %v) #7 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = and i32 %2, 2147483647
  %4 = bitcast i32 %3 to float
  %5 = insertelement <3 x float> undef, float %4, i32 0
  %6 = extractelement <3 x float> %v, i32 1
  %7 = bitcast float %6 to i32
  %8 = and i32 %7, 2147483647
  %9 = bitcast i32 %8 to float
  %10 = insertelement <3 x float> %5, float %9, i32 1
  %11 = extractelement <3 x float> %v, i32 2
  %12 = bitcast float %11 to i32
  %13 = and i32 %12, 2147483647
  %14 = bitcast i32 %13 to float
  %15 = insertelement <3 x float> %10, float %14, i32 2
  ret <3 x float> %15
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4fabsDv4_f(<4 x float> %v) #7 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = and i32 %2, 2147483647
  %4 = bitcast i32 %3 to float
  %5 = insertelement <4 x float> undef, float %4, i32 0
  %6 = extractelement <4 x float> %v, i32 1
  %7 = bitcast float %6 to i32
  %8 = and i32 %7, 2147483647
  %9 = bitcast i32 %8 to float
  %10 = insertelement <4 x float> %5, float %9, i32 1
  %11 = extractelement <4 x float> %v, i32 2
  %12 = bitcast float %11 to i32
  %13 = and i32 %12, 2147483647
  %14 = bitcast i32 %13 to float
  %15 = insertelement <4 x float> %10, float %14, i32 2
  %16 = extractelement <4 x float> %v, i32 3
  %17 = bitcast float %16 to i32
  %18 = and i32 %17, 2147483647
  %19 = bitcast i32 %18 to float
  %20 = insertelement <4 x float> %15, float %19, i32 3
  ret <4 x float> %20
}

; Function Attrs: nounwind
define <2 x float> @_Z4fdimDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z4fdimff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z4fdimff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z4fdimff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4fdimDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z4fdimff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z4fdimff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z4fdimff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z4fdimDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z4fdimff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z4fdimff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z4fdimff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z4fdimff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z5floorDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5floorf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5floorf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5floorf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5floorDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5floorf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5floorf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5floorf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5floorDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5floorf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5floorf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5floorf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5floorf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z3fmaDv2_fS_S_(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = extractelement <2 x float> %v3, i32 0
  %4 = tail call float @_Z3fmafff(float %1, float %2, float %3) #12
  %5 = insertelement <2 x float> undef, float %4, i32 0
  %6 = extractelement <2 x float> %v1, i32 1
  %7 = extractelement <2 x float> %v2, i32 1
  %8 = extractelement <2 x float> %v3, i32 1
  %9 = tail call float @_Z3fmafff(float %6, float %7, float %8) #12
  %10 = insertelement <2 x float> %5, float %9, i32 1
  ret <2 x float> %10
}

declare float @_Z3fmafff(float, float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3fmaDv3_fS_S_(<3 x float> %v1, <3 x float> %v2, <3 x float> %v3) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = extractelement <3 x float> %v3, i32 0
  %4 = tail call float @_Z3fmafff(float %1, float %2, float %3) #12
  %5 = insertelement <3 x float> undef, float %4, i32 0
  %6 = extractelement <3 x float> %v1, i32 1
  %7 = extractelement <3 x float> %v2, i32 1
  %8 = extractelement <3 x float> %v3, i32 1
  %9 = tail call float @_Z3fmafff(float %6, float %7, float %8) #12
  %10 = insertelement <3 x float> %5, float %9, i32 1
  %11 = extractelement <3 x float> %v1, i32 2
  %12 = extractelement <3 x float> %v2, i32 2
  %13 = extractelement <3 x float> %v3, i32 2
  %14 = tail call float @_Z3fmafff(float %11, float %12, float %13) #12
  %15 = insertelement <3 x float> %10, float %14, i32 2
  ret <3 x float> %15
}

; Function Attrs: nounwind
define <4 x float> @_Z3fmaDv4_fS_S_(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = extractelement <4 x float> %v3, i32 0
  %4 = tail call float @_Z3fmafff(float %1, float %2, float %3) #12
  %5 = insertelement <4 x float> undef, float %4, i32 0
  %6 = extractelement <4 x float> %v1, i32 1
  %7 = extractelement <4 x float> %v2, i32 1
  %8 = extractelement <4 x float> %v3, i32 1
  %9 = tail call float @_Z3fmafff(float %6, float %7, float %8) #12
  %10 = insertelement <4 x float> %5, float %9, i32 1
  %11 = extractelement <4 x float> %v1, i32 2
  %12 = extractelement <4 x float> %v2, i32 2
  %13 = extractelement <4 x float> %v3, i32 2
  %14 = tail call float @_Z3fmafff(float %11, float %12, float %13) #12
  %15 = insertelement <4 x float> %10, float %14, i32 2
  %16 = extractelement <4 x float> %v1, i32 3
  %17 = extractelement <4 x float> %v2, i32 3
  %18 = extractelement <4 x float> %v3, i32 3
  %19 = tail call float @_Z3fmafff(float %16, float %17, float %18) #12
  %20 = insertelement <4 x float> %15, float %19, i32 3
  ret <4 x float> %20
}

; Function Attrs: nounwind
define <2 x float> @_Z4fmodDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z4fmodff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z4fmodff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z4fmodff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4fmodDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z4fmodff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z4fmodff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z4fmodff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z4fmodDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z4fmodff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z4fmodff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z4fmodff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z4fmodff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define float @_Z5fractfPf(float %v, float* %iptr) #5 {
  %1 = tail call float @_Z5floorf(float %v) #12
  %2 = fptosi float %1 to i32
  %3 = icmp eq float* %iptr, null
  %.pre = sitofp i32 %2 to float
  br i1 %3, label %._crit_edge, label %4

; <label>:4                                       ; preds = %0
  store float %.pre, float* %iptr, align 4, !tbaa !18
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %0
  %5 = fsub float %v, %.pre
  %6 = fcmp olt float %5, 0x3FEFFFFFE0000000
  %7 = select i1 %6, float %5, float 0x3FEFFFFFE0000000
  ret float %7
}

; Function Attrs: nounwind
define <2 x float> @_Z5fractDv2_fPS_(<2 x float> %v1, <2 x float>* nocapture %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = tail call float @_Z5floorf(float %1) #12
  %3 = fptosi float %2 to i32
  %.pre.i = sitofp i32 %3 to float
  %4 = fsub float %1, %.pre.i
  %5 = fcmp olt float %4, 0x3FEFFFFFE0000000
  %6 = select i1 %5, float %4, float 0x3FEFFFFFE0000000
  %7 = insertelement <2 x float> undef, float %6, i32 0
  %8 = extractelement <2 x float> %v1, i32 1
  %9 = tail call float @_Z5floorf(float %8) #12
  %10 = fptosi float %9 to i32
  %.pre.i1 = sitofp i32 %10 to float
  %11 = fsub float %8, %.pre.i1
  %12 = fcmp olt float %11, 0x3FEFFFFFE0000000
  %13 = select i1 %12, float %11, float 0x3FEFFFFFE0000000
  %14 = insertelement <2 x float> %7, float %13, i32 1
  %15 = insertelement <2 x float> undef, float %.pre.i, i32 0
  %16 = insertelement <2 x float> %15, float %.pre.i1, i32 1
  store <2 x float> %16, <2 x float>* %v2, align 8
  ret <2 x float> %14
}

; Function Attrs: nounwind
define <3 x float> @_Z5fractDv3_fPS_(<3 x float> %v1, <3 x float>* nocapture %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = tail call float @_Z5floorf(float %1) #12
  %3 = fptosi float %2 to i32
  %.pre.i = sitofp i32 %3 to float
  %4 = fsub float %1, %.pre.i
  %5 = fcmp olt float %4, 0x3FEFFFFFE0000000
  %6 = select i1 %5, float %4, float 0x3FEFFFFFE0000000
  %7 = insertelement <3 x float> undef, float %6, i32 0
  %8 = extractelement <3 x float> %v1, i32 1
  %9 = tail call float @_Z5floorf(float %8) #12
  %10 = fptosi float %9 to i32
  %.pre.i1 = sitofp i32 %10 to float
  %11 = fsub float %8, %.pre.i1
  %12 = fcmp olt float %11, 0x3FEFFFFFE0000000
  %13 = select i1 %12, float %11, float 0x3FEFFFFFE0000000
  %14 = insertelement <3 x float> %7, float %13, i32 1
  %15 = extractelement <3 x float> %v1, i32 2
  %16 = tail call float @_Z5floorf(float %15) #12
  %17 = fptosi float %16 to i32
  %.pre.i2 = sitofp i32 %17 to float
  %18 = fsub float %15, %.pre.i2
  %19 = fcmp olt float %18, 0x3FEFFFFFE0000000
  %20 = select i1 %19, float %18, float 0x3FEFFFFFE0000000
  %21 = insertelement <3 x float> %14, float %20, i32 2
  %22 = insertelement <3 x float> undef, float %.pre.i, i32 0
  %23 = insertelement <3 x float> %22, float %.pre.i1, i32 1
  %24 = insertelement <3 x float> %23, float %.pre.i2, i32 2
  store <3 x float> %24, <3 x float>* %v2, align 16
  ret <3 x float> %21
}

; Function Attrs: nounwind
define <4 x float> @_Z5fractDv4_fPS_(<4 x float> %v1, <4 x float>* nocapture %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = tail call float @_Z5floorf(float %1) #12
  %3 = fptosi float %2 to i32
  %.pre.i = sitofp i32 %3 to float
  %4 = fsub float %1, %.pre.i
  %5 = fcmp olt float %4, 0x3FEFFFFFE0000000
  %6 = select i1 %5, float %4, float 0x3FEFFFFFE0000000
  %7 = insertelement <4 x float> undef, float %6, i32 0
  %8 = extractelement <4 x float> %v1, i32 1
  %9 = tail call float @_Z5floorf(float %8) #12
  %10 = fptosi float %9 to i32
  %.pre.i1 = sitofp i32 %10 to float
  %11 = fsub float %8, %.pre.i1
  %12 = fcmp olt float %11, 0x3FEFFFFFE0000000
  %13 = select i1 %12, float %11, float 0x3FEFFFFFE0000000
  %14 = insertelement <4 x float> %7, float %13, i32 1
  %15 = extractelement <4 x float> %v1, i32 2
  %16 = tail call float @_Z5floorf(float %15) #12
  %17 = fptosi float %16 to i32
  %.pre.i2 = sitofp i32 %17 to float
  %18 = fsub float %15, %.pre.i2
  %19 = fcmp olt float %18, 0x3FEFFFFFE0000000
  %20 = select i1 %19, float %18, float 0x3FEFFFFFE0000000
  %21 = insertelement <4 x float> %14, float %20, i32 2
  %22 = extractelement <4 x float> %v1, i32 3
  %23 = tail call float @_Z5floorf(float %22) #12
  %24 = fptosi float %23 to i32
  %.pre.i3 = sitofp i32 %24 to float
  %25 = fsub float %22, %.pre.i3
  %26 = fcmp olt float %25, 0x3FEFFFFFE0000000
  %27 = select i1 %26, float %25, float 0x3FEFFFFFE0000000
  %28 = insertelement <4 x float> %21, float %27, i32 3
  %29 = insertelement <4 x float> undef, float %.pre.i, i32 0
  %30 = insertelement <4 x float> %29, float %.pre.i1, i32 1
  %31 = insertelement <4 x float> %30, float %.pre.i2, i32 2
  %32 = insertelement <4 x float> %31, float %.pre.i3, i32 3
  store <4 x float> %32, <4 x float>* %v2, align 8
  ret <4 x float> %28
}

; Function Attrs: nounwind
define <2 x float> @_Z5frexpDv2_fPDv2_i(<2 x float> %v1, <2 x i32>* nocapture %v2) #5 {
  %t = alloca [2 x i32], align 4
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = getelementptr inbounds [2 x i32], [2 x i32]* %t, i32 0, i32 0
  %3 = call float @_Z5frexpfPi(float %1, i32* %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = getelementptr inbounds [2 x i32], [2 x i32]* %t, i32 0, i32 1
  %7 = call float @_Z5frexpfPi(float %5, i32* %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  %9 = load i32, i32* %2, align 4, !tbaa !21
  %10 = insertelement <2 x i32> undef, i32 %9, i32 0
  %11 = load i32, i32* %6, align 4, !tbaa !21
  %12 = insertelement <2 x i32> %10, i32 %11, i32 1
  store <2 x i32> %12, <2 x i32>* %v2, align 8
  ret <2 x float> %8
}

declare float @_Z5frexpfPi(float, i32*) #6

; Function Attrs: nounwind
define <3 x float> @_Z5frexpDv3_fPDv3_i(<3 x float> %v1, <3 x i32>* nocapture %v2) #5 {
  %t = alloca [3 x i32], align 4
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 0
  %3 = call float @_Z5frexpfPi(float %1, i32* %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 1
  %7 = call float @_Z5frexpfPi(float %5, i32* %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 2
  %11 = call float @_Z5frexpfPi(float %9, i32* %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  %13 = load i32, i32* %2, align 4, !tbaa !21
  %14 = insertelement <3 x i32> undef, i32 %13, i32 0
  %15 = load i32, i32* %6, align 4, !tbaa !21
  %16 = insertelement <3 x i32> %14, i32 %15, i32 1
  %17 = load i32, i32* %10, align 4, !tbaa !21
  %18 = insertelement <3 x i32> %16, i32 %17, i32 2
  store <3 x i32> %18, <3 x i32>* %v2, align 16
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5frexpDv4_fPDv4_i(<4 x float> %v1, <4 x i32>* nocapture %v2) #5 {
  %t = alloca [4 x i32], align 4
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 0
  %3 = call float @_Z5frexpfPi(float %1, i32* %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 1
  %7 = call float @_Z5frexpfPi(float %5, i32* %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 2
  %11 = call float @_Z5frexpfPi(float %9, i32* %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 3
  %15 = call float @_Z5frexpfPi(float %13, i32* %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  %17 = load i32, i32* %2, align 4, !tbaa !21
  %18 = insertelement <4 x i32> undef, i32 %17, i32 0
  %19 = load i32, i32* %6, align 4, !tbaa !21
  %20 = insertelement <4 x i32> %18, i32 %19, i32 1
  %21 = load i32, i32* %10, align 4, !tbaa !21
  %22 = insertelement <4 x i32> %20, i32 %21, i32 2
  %23 = load i32, i32* %14, align 4, !tbaa !21
  %24 = insertelement <4 x i32> %22, i32 %23, i32 3
  store <4 x i32> %24, <4 x i32>* %v2, align 8
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z5hypotDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z5hypotff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z5hypotff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z5hypotff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5hypotDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z5hypotff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z5hypotff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z5hypotff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5hypotDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z5hypotff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z5hypotff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z5hypotff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z5hypotff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x i32> @_Z5ilogbDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call i32 @_Z5ilogbf(float %1) #12
  %3 = insertelement <2 x i32> undef, i32 %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call i32 @_Z5ilogbf(float %4) #12
  %6 = insertelement <2 x i32> %3, i32 %5, i32 1
  ret <2 x i32> %6
}

declare i32 @_Z5ilogbf(float) #6

; Function Attrs: nounwind
define <3 x i32> @_Z5ilogbDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call i32 @_Z5ilogbf(float %1) #12
  %3 = insertelement <3 x i32> undef, i32 %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call i32 @_Z5ilogbf(float %4) #12
  %6 = insertelement <3 x i32> %3, i32 %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call i32 @_Z5ilogbf(float %7) #12
  %9 = insertelement <3 x i32> %6, i32 %8, i32 2
  ret <3 x i32> %9
}

; Function Attrs: nounwind
define <4 x i32> @_Z5ilogbDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call i32 @_Z5ilogbf(float %1) #12
  %3 = insertelement <4 x i32> undef, i32 %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call i32 @_Z5ilogbf(float %4) #12
  %6 = insertelement <4 x i32> %3, i32 %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call i32 @_Z5ilogbf(float %7) #12
  %9 = insertelement <4 x i32> %6, i32 %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call i32 @_Z5ilogbf(float %10) #12
  %12 = insertelement <4 x i32> %9, i32 %11, i32 3
  ret <4 x i32> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z5ldexpDv2_fDv2_i(<2 x float> %v1, <2 x i32> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x i32> %v2, i32 0
  %3 = tail call float @_Z5ldexpfi(float %1, i32 %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x i32> %v2, i32 1
  %7 = tail call float @_Z5ldexpfi(float %5, i32 %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z5ldexpfi(float, i32) #6

; Function Attrs: nounwind
define <3 x float> @_Z5ldexpDv3_fDv3_i(<3 x float> %v1, <3 x i32> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x i32> %v2, i32 0
  %3 = tail call float @_Z5ldexpfi(float %1, i32 %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x i32> %v2, i32 1
  %7 = tail call float @_Z5ldexpfi(float %5, i32 %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x i32> %v2, i32 2
  %11 = tail call float @_Z5ldexpfi(float %9, i32 %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5ldexpDv4_fDv4_i(<4 x float> %v1, <4 x i32> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x i32> %v2, i32 0
  %3 = tail call float @_Z5ldexpfi(float %1, i32 %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x i32> %v2, i32 1
  %7 = tail call float @_Z5ldexpfi(float %5, i32 %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x i32> %v2, i32 2
  %11 = tail call float @_Z5ldexpfi(float %9, i32 %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x i32> %v2, i32 3
  %15 = tail call float @_Z5ldexpfi(float %13, i32 %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z5ldexpDv2_fi(<2 x float> %v1, i32 %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = tail call float @_Z5ldexpfi(float %1, i32 %v2) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = tail call float @_Z5ldexpfi(float %4, i32 %v2) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

; Function Attrs: nounwind
define <3 x float> @_Z5ldexpDv3_fi(<3 x float> %v1, i32 %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = tail call float @_Z5ldexpfi(float %1, i32 %v2) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = tail call float @_Z5ldexpfi(float %4, i32 %v2) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v1, i32 2
  %8 = tail call float @_Z5ldexpfi(float %7, i32 %v2) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5ldexpDv4_fi(<4 x float> %v1, i32 %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = tail call float @_Z5ldexpfi(float %1, i32 %v2) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = tail call float @_Z5ldexpfi(float %4, i32 %v2) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v1, i32 2
  %8 = tail call float @_Z5ldexpfi(float %7, i32 %v2) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v1, i32 3
  %11 = tail call float @_Z5ldexpfi(float %10, i32 %v2) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z6lgammaDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z6lgammaf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z6lgammaf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z6lgammaf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z6lgammaDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z6lgammaf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z6lgammaf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z6lgammaf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z6lgammaDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z6lgammaf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z6lgammaf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z6lgammaf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z6lgammaf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z6lgammaDv2_fPDv2_i(<2 x float> %v1, <2 x i32>* nocapture %v2) #5 {
  %t = alloca [2 x i32], align 4
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = getelementptr inbounds [2 x i32], [2 x i32]* %t, i32 0, i32 0
  %3 = call float @_Z6lgammafPi(float %1, i32* %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = getelementptr inbounds [2 x i32], [2 x i32]* %t, i32 0, i32 1
  %7 = call float @_Z6lgammafPi(float %5, i32* %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  %9 = load i32, i32* %2, align 4, !tbaa !21
  %10 = insertelement <2 x i32> undef, i32 %9, i32 0
  %11 = load i32, i32* %6, align 4, !tbaa !21
  %12 = insertelement <2 x i32> %10, i32 %11, i32 1
  store <2 x i32> %12, <2 x i32>* %v2, align 8
  ret <2 x float> %8
}

declare float @_Z6lgammafPi(float, i32*) #6

; Function Attrs: nounwind
define <3 x float> @_Z6lgammaDv3_fPDv3_i(<3 x float> %v1, <3 x i32>* nocapture %v2) #5 {
  %t = alloca [3 x i32], align 4
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 0
  %3 = call float @_Z6lgammafPi(float %1, i32* %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 1
  %7 = call float @_Z6lgammafPi(float %5, i32* %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 2
  %11 = call float @_Z6lgammafPi(float %9, i32* %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  %13 = load i32, i32* %2, align 4, !tbaa !21
  %14 = insertelement <3 x i32> undef, i32 %13, i32 0
  %15 = load i32, i32* %6, align 4, !tbaa !21
  %16 = insertelement <3 x i32> %14, i32 %15, i32 1
  %17 = load i32, i32* %10, align 4, !tbaa !21
  %18 = insertelement <3 x i32> %16, i32 %17, i32 2
  store <3 x i32> %18, <3 x i32>* %v2, align 16
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z6lgammaDv4_fPDv4_i(<4 x float> %v1, <4 x i32>* nocapture %v2) #5 {
  %t = alloca [4 x i32], align 4
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 0
  %3 = call float @_Z6lgammafPi(float %1, i32* %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 1
  %7 = call float @_Z6lgammafPi(float %5, i32* %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 2
  %11 = call float @_Z6lgammafPi(float %9, i32* %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 3
  %15 = call float @_Z6lgammafPi(float %13, i32* %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  %17 = load i32, i32* %2, align 4, !tbaa !21
  %18 = insertelement <4 x i32> undef, i32 %17, i32 0
  %19 = load i32, i32* %6, align 4, !tbaa !21
  %20 = insertelement <4 x i32> %18, i32 %19, i32 1
  %21 = load i32, i32* %10, align 4, !tbaa !21
  %22 = insertelement <4 x i32> %20, i32 %21, i32 2
  %23 = load i32, i32* %14, align 4, !tbaa !21
  %24 = insertelement <4 x i32> %22, i32 %23, i32 3
  store <4 x i32> %24, <4 x i32>* %v2, align 8
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z3logDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z3logf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z3logf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z3logf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3logDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z3logf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z3logf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z3logf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z3logDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z3logf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z3logf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z3logf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z3logf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z5log10Dv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5log10f(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5log10f(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5log10f(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5log10Dv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5log10f(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5log10f(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5log10f(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5log10Dv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5log10f(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5log10f(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5log10f(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5log10f(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z4log2f(float %v) #5 {
  %1 = tail call float @_Z5log10f(float %v) #12
  %2 = fmul float %1, 0x400A934F00000000
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z4log2Dv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5log10f(float %1) #12
  %3 = fmul float %2, 0x400A934F00000000
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = tail call float @_Z5log10f(float %5) #12
  %7 = fmul float %6, 0x400A934F00000000
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z4log2Dv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5log10f(float %1) #12
  %3 = fmul float %2, 0x400A934F00000000
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = tail call float @_Z5log10f(float %5) #12
  %7 = fmul float %6, 0x400A934F00000000
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = tail call float @_Z5log10f(float %9) #12
  %11 = fmul float %10, 0x400A934F00000000
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z4log2Dv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5log10f(float %1) #12
  %3 = fmul float %2, 0x400A934F00000000
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = tail call float @_Z5log10f(float %5) #12
  %7 = fmul float %6, 0x400A934F00000000
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = tail call float @_Z5log10f(float %9) #12
  %11 = fmul float %10, 0x400A934F00000000
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = tail call float @_Z5log10f(float %13) #12
  %15 = fmul float %14, 0x400A934F00000000
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z5log1pDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5log1pf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5log1pf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5log1pf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5log1pDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5log1pf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5log1pf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5log1pf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5log1pDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5log1pf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5log1pf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5log1pf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5log1pf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z4logbDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4logbf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4logbf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4logbf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4logbDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4logbf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4logbf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4logbf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4logbDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4logbf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4logbf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4logbf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4logbf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind readnone
define float @_Z3madfff(float %a, float %b, float %c) #7 {
  %1 = fmul float %a, %b
  %2 = fadd float %1, %c
  ret float %2
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z3madDv2_fS_S_(<2 x float> %a, <2 x float> %b, <2 x float> %c) #7 {
  %1 = fmul <2 x float> %a, %b
  %2 = fadd <2 x float> %1, %c
  ret <2 x float> %2
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z3madDv3_fS_S_(<3 x float> %a, <3 x float> %b, <3 x float> %c) #7 {
  %1 = fmul <3 x float> %a, %b
  %2 = fadd <3 x float> %1, %c
  ret <3 x float> %2
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z3madDv4_fS_S_(<4 x float> %a, <4 x float> %b, <4 x float> %c) #7 {
  %1 = fmul <4 x float> %a, %b
  %2 = fadd <4 x float> %1, %c
  ret <4 x float> %2
}

; Function Attrs: nounwind
define <2 x float> @_Z4modfDv2_fPS_(<2 x float> %v1, <2 x float>* nocapture %v2) #5 {
  %t = alloca [2 x float], align 4
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = getelementptr inbounds [2 x float], [2 x float]* %t, i32 0, i32 0
  %3 = call float @_Z4modffPf(float %1, float* %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = getelementptr inbounds [2 x float], [2 x float]* %t, i32 0, i32 1
  %7 = call float @_Z4modffPf(float %5, float* %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  %9 = load float, float* %2, align 4, !tbaa !18
  %10 = insertelement <2 x float> undef, float %9, i32 0
  %11 = load float, float* %6, align 4, !tbaa !18
  %12 = insertelement <2 x float> %10, float %11, i32 1
  store <2 x float> %12, <2 x float>* %v2, align 8
  ret <2 x float> %8
}

declare float @_Z4modffPf(float, float*) #6

; Function Attrs: nounwind
define <3 x float> @_Z4modfDv3_fPS_(<3 x float> %v1, <3 x float>* nocapture %v2) #5 {
  %t = alloca [3 x float], align 4
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = getelementptr inbounds [3 x float], [3 x float]* %t, i32 0, i32 0
  %3 = call float @_Z4modffPf(float %1, float* %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = getelementptr inbounds [3 x float], [3 x float]* %t, i32 0, i32 1
  %7 = call float @_Z4modffPf(float %5, float* %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = getelementptr inbounds [3 x float], [3 x float]* %t, i32 0, i32 2
  %11 = call float @_Z4modffPf(float %9, float* %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  %13 = load float, float* %2, align 4, !tbaa !18
  %14 = insertelement <3 x float> undef, float %13, i32 0
  %15 = load float, float* %6, align 4, !tbaa !18
  %16 = insertelement <3 x float> %14, float %15, i32 1
  %17 = load float, float* %10, align 4, !tbaa !18
  %18 = insertelement <3 x float> %16, float %17, i32 2
  store <3 x float> %18, <3 x float>* %v2, align 16
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z4modfDv4_fPS_(<4 x float> %v1, <4 x float>* nocapture %v2) #5 {
  %t = alloca [4 x float], align 4
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = getelementptr inbounds [4 x float], [4 x float]* %t, i32 0, i32 0
  %3 = call float @_Z4modffPf(float %1, float* %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = getelementptr inbounds [4 x float], [4 x float]* %t, i32 0, i32 1
  %7 = call float @_Z4modffPf(float %5, float* %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = getelementptr inbounds [4 x float], [4 x float]* %t, i32 0, i32 2
  %11 = call float @_Z4modffPf(float %9, float* %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = getelementptr inbounds [4 x float], [4 x float]* %t, i32 0, i32 3
  %15 = call float @_Z4modffPf(float %13, float* %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  %17 = load float, float* %2, align 4, !tbaa !18
  %18 = insertelement <4 x float> undef, float %17, i32 0
  %19 = load float, float* %6, align 4, !tbaa !18
  %20 = insertelement <4 x float> %18, float %19, i32 1
  %21 = load float, float* %10, align 4, !tbaa !18
  %22 = insertelement <4 x float> %20, float %21, i32 2
  %23 = load float, float* %14, align 4, !tbaa !18
  %24 = insertelement <4 x float> %22, float %23, i32 3
  store <4 x float> %24, <4 x float>* %v2, align 8
  ret <4 x float> %16
}

; Function Attrs: nounwind readnone
define float @_Z3nanj(i32 %v) #7 {
  %1 = or i32 %v, 2143289344
  %2 = bitcast i32 %1 to float
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z9nextafterDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z9nextafterff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z9nextafterff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z9nextafterff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z9nextafterDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z9nextafterff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z9nextafterff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z9nextafterff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z9nextafterDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z9nextafterff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z9nextafterff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z9nextafterff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z9nextafterff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z3powDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z3powff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z3powff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z3powff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3powDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z3powff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z3powff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z3powff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z3powDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z3powff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z3powff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z3powff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z3powff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define float @_Z4pownfi(float %v, i32 %p) #5 {
  %1 = sitofp i32 %p to float
  %2 = tail call float @_Z3powff(float %v, float %1) #12
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z4pownDv2_fDv2_i(<2 x float> %v, <2 x i32> %p) #5 {
  %1 = sitofp <2 x i32> %p to <2 x float>
  %2 = extractelement <2 x float> %v, i32 0
  %3 = extractelement <2 x float> %1, i32 0
  %4 = tail call float @_Z3powff(float %2, float %3) #12
  %5 = insertelement <2 x float> undef, float %4, i32 0
  %6 = extractelement <2 x float> %v, i32 1
  %7 = extractelement <2 x float> %1, i32 1
  %8 = tail call float @_Z3powff(float %6, float %7) #12
  %9 = insertelement <2 x float> %5, float %8, i32 1
  ret <2 x float> %9
}

; Function Attrs: nounwind
define <3 x float> @_Z4pownDv3_fDv3_i(<3 x float> %v, <3 x i32> %p) #5 {
  %1 = sitofp <3 x i32> %p to <3 x float>
  %2 = extractelement <3 x float> %v, i32 0
  %3 = extractelement <3 x float> %1, i32 0
  %4 = tail call float @_Z3powff(float %2, float %3) #12
  %5 = insertelement <3 x float> undef, float %4, i32 0
  %6 = extractelement <3 x float> %v, i32 1
  %7 = extractelement <3 x float> %1, i32 1
  %8 = tail call float @_Z3powff(float %6, float %7) #12
  %9 = insertelement <3 x float> %5, float %8, i32 1
  %10 = extractelement <3 x float> %v, i32 2
  %11 = extractelement <3 x float> %1, i32 2
  %12 = tail call float @_Z3powff(float %10, float %11) #12
  %13 = insertelement <3 x float> %9, float %12, i32 2
  ret <3 x float> %13
}

; Function Attrs: nounwind
define <4 x float> @_Z4pownDv4_fDv4_i(<4 x float> %v, <4 x i32> %p) #5 {
  %1 = sitofp <4 x i32> %p to <4 x float>
  %2 = extractelement <4 x float> %v, i32 0
  %3 = extractelement <4 x float> %1, i32 0
  %4 = tail call float @_Z3powff(float %2, float %3) #12
  %5 = insertelement <4 x float> undef, float %4, i32 0
  %6 = extractelement <4 x float> %v, i32 1
  %7 = extractelement <4 x float> %1, i32 1
  %8 = tail call float @_Z3powff(float %6, float %7) #12
  %9 = insertelement <4 x float> %5, float %8, i32 1
  %10 = extractelement <4 x float> %v, i32 2
  %11 = extractelement <4 x float> %1, i32 2
  %12 = tail call float @_Z3powff(float %10, float %11) #12
  %13 = insertelement <4 x float> %9, float %12, i32 2
  %14 = extractelement <4 x float> %v, i32 3
  %15 = extractelement <4 x float> %1, i32 3
  %16 = tail call float @_Z3powff(float %14, float %15) #12
  %17 = insertelement <4 x float> %13, float %16, i32 3
  ret <4 x float> %17
}

; Function Attrs: nounwind
define float @_Z4powrff(float %v, float %p) #5 {
  %1 = tail call float @_Z3powff(float %v, float %p) #12
  ret float %1
}

; Function Attrs: nounwind
define <2 x float> @_Z4powrDv2_fS_(<2 x float> %v, <2 x float> %p) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = extractelement <2 x float> %p, i32 0
  %3 = tail call float @_Z3powff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = extractelement <2 x float> %p, i32 1
  %7 = tail call float @_Z3powff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z4powrDv3_fS_(<3 x float> %v, <3 x float> %p) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = extractelement <3 x float> %p, i32 0
  %3 = tail call float @_Z3powff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = extractelement <3 x float> %p, i32 1
  %7 = tail call float @_Z3powff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = extractelement <3 x float> %p, i32 2
  %11 = tail call float @_Z3powff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z4powrDv4_fS_(<4 x float> %v, <4 x float> %p) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = extractelement <4 x float> %p, i32 0
  %3 = tail call float @_Z3powff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = extractelement <4 x float> %p, i32 1
  %7 = tail call float @_Z3powff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = extractelement <4 x float> %p, i32 2
  %11 = tail call float @_Z3powff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = extractelement <4 x float> %p, i32 3
  %15 = tail call float @_Z3powff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z9remainderDv2_fS_(<2 x float> %v1, <2 x float> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = tail call float @_Z9remainderff(float %1, float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x float> %v2, i32 1
  %7 = tail call float @_Z9remainderff(float %5, float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

declare float @_Z9remainderff(float, float) #6

; Function Attrs: nounwind
define <3 x float> @_Z9remainderDv3_fS_(<3 x float> %v1, <3 x float> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = tail call float @_Z9remainderff(float %1, float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x float> %v2, i32 1
  %7 = tail call float @_Z9remainderff(float %5, float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x float> %v2, i32 2
  %11 = tail call float @_Z9remainderff(float %9, float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z9remainderDv4_fS_(<4 x float> %v1, <4 x float> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = tail call float @_Z9remainderff(float %1, float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x float> %v2, i32 1
  %7 = tail call float @_Z9remainderff(float %5, float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x float> %v2, i32 2
  %11 = tail call float @_Z9remainderff(float %9, float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x float> %v2, i32 3
  %15 = tail call float @_Z9remainderff(float %13, float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z6remquoDv2_fS_PDv2_i(<2 x float> %v1, <2 x float> %v2, <2 x i32>* nocapture %v3) #5 {
  %t = alloca [2 x i32], align 4
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = getelementptr inbounds [2 x i32], [2 x i32]* %t, i32 0, i32 0
  %4 = call float @_Z6remquoffPi(float %1, float %2, i32* %3) #12
  %5 = insertelement <2 x float> undef, float %4, i32 0
  %6 = extractelement <2 x float> %v1, i32 1
  %7 = extractelement <2 x float> %v2, i32 1
  %8 = getelementptr inbounds [2 x i32], [2 x i32]* %t, i32 0, i32 1
  %9 = call float @_Z6remquoffPi(float %6, float %7, i32* %8) #12
  %10 = insertelement <2 x float> %5, float %9, i32 1
  %11 = load i32, i32* %3, align 4, !tbaa !21
  %12 = insertelement <2 x i32> undef, i32 %11, i32 0
  %13 = load i32, i32* %8, align 4, !tbaa !21
  %14 = insertelement <2 x i32> %12, i32 %13, i32 1
  store <2 x i32> %14, <2 x i32>* %v3, align 8
  ret <2 x float> %10
}

declare float @_Z6remquoffPi(float, float, i32*) #6

; Function Attrs: nounwind
define <3 x float> @_Z6remquoDv3_fS_PDv3_i(<3 x float> %v1, <3 x float> %v2, <3 x i32>* nocapture %v3) #5 {
  %t = alloca [3 x i32], align 4
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 0
  %4 = call float @_Z6remquoffPi(float %1, float %2, i32* %3) #12
  %5 = insertelement <3 x float> undef, float %4, i32 0
  %6 = extractelement <3 x float> %v1, i32 1
  %7 = extractelement <3 x float> %v2, i32 1
  %8 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 1
  %9 = call float @_Z6remquoffPi(float %6, float %7, i32* %8) #12
  %10 = insertelement <3 x float> %5, float %9, i32 1
  %11 = extractelement <3 x float> %v1, i32 2
  %12 = extractelement <3 x float> %v2, i32 2
  %13 = getelementptr inbounds [3 x i32], [3 x i32]* %t, i32 0, i32 2
  %14 = call float @_Z6remquoffPi(float %11, float %12, i32* %13) #12
  %15 = insertelement <3 x float> %10, float %14, i32 2
  %16 = load i32, i32* %3, align 4, !tbaa !21
  %17 = insertelement <3 x i32> undef, i32 %16, i32 0
  %18 = load i32, i32* %8, align 4, !tbaa !21
  %19 = insertelement <3 x i32> %17, i32 %18, i32 1
  %20 = load i32, i32* %13, align 4, !tbaa !21
  %21 = insertelement <3 x i32> %19, i32 %20, i32 2
  store <3 x i32> %21, <3 x i32>* %v3, align 16
  ret <3 x float> %15
}

; Function Attrs: nounwind
define <4 x float> @_Z6remquoDv4_fS_PDv4_i(<4 x float> %v1, <4 x float> %v2, <4 x i32>* nocapture %v3) #5 {
  %t = alloca [4 x i32], align 4
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 0
  %4 = call float @_Z6remquoffPi(float %1, float %2, i32* %3) #12
  %5 = insertelement <4 x float> undef, float %4, i32 0
  %6 = extractelement <4 x float> %v1, i32 1
  %7 = extractelement <4 x float> %v2, i32 1
  %8 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 1
  %9 = call float @_Z6remquoffPi(float %6, float %7, i32* %8) #12
  %10 = insertelement <4 x float> %5, float %9, i32 1
  %11 = extractelement <4 x float> %v1, i32 2
  %12 = extractelement <4 x float> %v2, i32 2
  %13 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 2
  %14 = call float @_Z6remquoffPi(float %11, float %12, i32* %13) #12
  %15 = insertelement <4 x float> %10, float %14, i32 2
  %16 = extractelement <4 x float> %v1, i32 3
  %17 = extractelement <4 x float> %v2, i32 3
  %18 = getelementptr inbounds [4 x i32], [4 x i32]* %t, i32 0, i32 3
  %19 = call float @_Z6remquoffPi(float %16, float %17, i32* %18) #12
  %20 = insertelement <4 x float> %15, float %19, i32 3
  %21 = load i32, i32* %3, align 4, !tbaa !21
  %22 = insertelement <4 x i32> undef, i32 %21, i32 0
  %23 = load i32, i32* %8, align 4, !tbaa !21
  %24 = insertelement <4 x i32> %22, i32 %23, i32 1
  %25 = load i32, i32* %13, align 4, !tbaa !21
  %26 = insertelement <4 x i32> %24, i32 %25, i32 2
  %27 = load i32, i32* %18, align 4, !tbaa !21
  %28 = insertelement <4 x i32> %26, i32 %27, i32 3
  store <4 x i32> %28, <4 x i32>* %v3, align 8
  ret <4 x float> %20
}

; Function Attrs: nounwind
define <2 x float> @_Z4rintDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4rintf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4rintf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4rintf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4rintDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4rintf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4rintf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4rintf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4rintDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4rintf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4rintf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4rintf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4rintf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z5rootnfi(float %v, i32 %r) #5 {
  %1 = icmp eq i32 %r, 0
  br i1 %1, label %35, label %2

; <label>:2                                       ; preds = %0
  %3 = bitcast float %v to i32
  %4 = and i32 %3, 2147483647
  switch i32 %4, label %15 [
    i32 0, label %5
    i32 2139095040, label %31
  ]

; <label>:5                                       ; preds = %2
  %6 = icmp slt i32 %r, 0
  %7 = and i32 %r, 1
  %8 = icmp ne i32 %7, 0
  br i1 %6, label %9, label %12

; <label>:9                                       ; preds = %5
  br i1 %8, label %10, label %35

; <label>:10                                      ; preds = %9
  %11 = tail call float @_Z8copysignff(float 0x7FF0000000000000, float %v) #12
  br label %35

; <label>:12                                      ; preds = %5
  br i1 %8, label %13, label %35

; <label>:13                                      ; preds = %12
  %14 = tail call float @_Z8copysignff(float 0.000000e+00, float %v) #12
  br label %35

; <label>:15                                      ; preds = %2
  %16 = and i32 %3, 2139095040
  %17 = icmp eq i32 %16, 2139095040
  br i1 %17, label %18, label %isnan.exit

; <label>:18                                      ; preds = %15
  %19 = and i32 %3, 8388607
  %phitmp = icmp eq i32 %19, 0
  br label %isnan.exit

isnan.exit:                                       ; preds = %18, %15
  %20 = phi i1 [ true, %15 ], [ %phitmp, %18 ]
  %21 = fcmp olt float %v, 0.000000e+00
  %or.cond = and i1 %21, %20
  br i1 %or.cond, label %22, label %31

; <label>:22                                      ; preds = %isnan.exit
  %23 = and i32 %r, 1
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %35, label %25

; <label>:25                                      ; preds = %22
  %26 = fmul float %v, -1.000000e+00
  %27 = sitofp i32 %r to float
  %28 = fdiv float 1.000000e+00, %27
  %29 = tail call float @_Z3powff(float %26, float %28) #12
  %30 = fmul float %29, -1.000000e+00
  br label %35

; <label>:31                                      ; preds = %isnan.exit, %2
  %32 = sitofp i32 %r to float
  %33 = fdiv float 1.000000e+00, %32
  %34 = tail call float @_Z3powff(float %v, float %33) #12
  br label %35

; <label>:35                                      ; preds = %31, %25, %22, %13, %12, %10, %9, %0
  %.0 = phi float [ %11, %10 ], [ %14, %13 ], [ %34, %31 ], [ %30, %25 ], [ 0x7FF0000000000000, %9 ], [ 0.000000e+00, %12 ], [ 0x7FF8000000000000, %0 ], [ 0x7FF8000000000000, %22 ]
  ret float %.0
}

; Function Attrs: nounwind
define <2 x float> @_Z5rootnDv2_fDv2_i(<2 x float> %v1, <2 x i32> %v2) #5 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x i32> %v2, i32 0
  %3 = tail call float @_Z5rootnfi(float %1, i32 %2) #13
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v1, i32 1
  %6 = extractelement <2 x i32> %v2, i32 1
  %7 = tail call float @_Z5rootnfi(float %5, i32 %6) #13
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z5rootnDv3_fDv3_i(<3 x float> %v1, <3 x i32> %v2) #5 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x i32> %v2, i32 0
  %3 = tail call float @_Z5rootnfi(float %1, i32 %2) #13
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v1, i32 1
  %6 = extractelement <3 x i32> %v2, i32 1
  %7 = tail call float @_Z5rootnfi(float %5, i32 %6) #13
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v1, i32 2
  %10 = extractelement <3 x i32> %v2, i32 2
  %11 = tail call float @_Z5rootnfi(float %9, i32 %10) #13
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5rootnDv4_fDv4_i(<4 x float> %v1, <4 x i32> %v2) #5 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x i32> %v2, i32 0
  %3 = tail call float @_Z5rootnfi(float %1, i32 %2) #13
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v1, i32 1
  %6 = extractelement <4 x i32> %v2, i32 1
  %7 = tail call float @_Z5rootnfi(float %5, i32 %6) #13
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v1, i32 2
  %10 = extractelement <4 x i32> %v2, i32 2
  %11 = tail call float @_Z5rootnfi(float %9, i32 %10) #13
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v1, i32 3
  %14 = extractelement <4 x i32> %v2, i32 3
  %15 = tail call float @_Z5rootnfi(float %13, i32 %14) #13
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z5roundDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5roundf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5roundf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5roundf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5roundDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5roundf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5roundf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5roundf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5roundDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5roundf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5roundf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5roundf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5roundf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z5rsqrtf(float %v) #5 {
  %1 = tail call float @_Z4sqrtf(float %v) #12
  %2 = fdiv float 1.000000e+00, %1
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z5rsqrtDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = fdiv float 1.000000e+00, %2
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = tail call float @_Z4sqrtf(float %5) #12
  %7 = fdiv float 1.000000e+00, %6
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z5rsqrtDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = fdiv float 1.000000e+00, %2
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = tail call float @_Z4sqrtf(float %5) #12
  %7 = fdiv float 1.000000e+00, %6
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = tail call float @_Z4sqrtf(float %9) #12
  %11 = fdiv float 1.000000e+00, %10
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5rsqrtDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = fdiv float 1.000000e+00, %2
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = tail call float @_Z4sqrtf(float %5) #12
  %7 = fdiv float 1.000000e+00, %6
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = tail call float @_Z4sqrtf(float %9) #12
  %11 = fdiv float 1.000000e+00, %10
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = tail call float @_Z4sqrtf(float %13) #12
  %15 = fdiv float 1.000000e+00, %14
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z3sinDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z3sinf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z3sinf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z3sinf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3sinDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z3sinf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z3sinf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z3sinf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z3sinDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z3sinf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z3sinf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z3sinf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z3sinf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z6sincosfPf(float %v, float* nocapture %cosptr) #5 {
  %1 = tail call float @_Z3cosf(float %v) #12
  store float %1, float* %cosptr, align 4, !tbaa !18
  %2 = tail call float @_Z3sinf(float %v) #12
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z6sincosDv2_fPS_(<2 x float> %v, <2 x float>* nocapture %cosptr) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z3cosf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z3cosf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  store <2 x float> %6, <2 x float>* %cosptr, align 8, !tbaa !19
  %7 = tail call float @_Z3sinf(float %1) #12
  %8 = insertelement <2 x float> undef, float %7, i32 0
  %9 = tail call float @_Z3sinf(float %4) #12
  %10 = insertelement <2 x float> %8, float %9, i32 1
  ret <2 x float> %10
}

; Function Attrs: nounwind
define <3 x float> @_Z6sincosDv3_fPS_(<3 x float> %v, <3 x float>* nocapture %cosptr) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z3cosf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z3cosf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z3cosf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = bitcast <3 x float>* %cosptr to <4 x float>*
  store <4 x float> %9, <4 x float>* %10, align 16, !tbaa !19
  %11 = tail call float @_Z3sinf(float %1) #12
  %12 = insertelement <3 x float> undef, float %11, i32 0
  %13 = tail call float @_Z3sinf(float %4) #12
  %14 = insertelement <3 x float> %12, float %13, i32 1
  %15 = tail call float @_Z3sinf(float %7) #12
  %16 = insertelement <3 x float> %14, float %15, i32 2
  ret <3 x float> %16
}

; Function Attrs: nounwind
define <4 x float> @_Z6sincosDv4_fPS_(<4 x float> %v, <4 x float>* nocapture %cosptr) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z3cosf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z3cosf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z3cosf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z3cosf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  store <4 x float> %12, <4 x float>* %cosptr, align 16, !tbaa !19
  %13 = tail call float @_Z3sinf(float %1) #12
  %14 = insertelement <4 x float> undef, float %13, i32 0
  %15 = tail call float @_Z3sinf(float %4) #12
  %16 = insertelement <4 x float> %14, float %15, i32 1
  %17 = tail call float @_Z3sinf(float %7) #12
  %18 = insertelement <4 x float> %16, float %17, i32 2
  %19 = tail call float @_Z3sinf(float %10) #12
  %20 = insertelement <4 x float> %18, float %19, i32 3
  ret <4 x float> %20
}

; Function Attrs: nounwind
define <2 x float> @_Z4sinhDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4sinhf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4sinhf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4sinhf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4sinhDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4sinhf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4sinhf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4sinhf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4sinhDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4sinhf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4sinhf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4sinhf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4sinhf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z5sinpif(float %v) #5 {
  %1 = fmul float %v, 0x400921FB60000000
  %2 = tail call float @_Z3sinf(float %1) #12
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z5sinpiDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3sinf(float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3sinf(float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z5sinpiDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3sinf(float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3sinf(float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = fmul float %9, 0x400921FB60000000
  %11 = tail call float @_Z3sinf(float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5sinpiDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3sinf(float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3sinf(float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = fmul float %9, 0x400921FB60000000
  %11 = tail call float @_Z3sinf(float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = fmul float %13, 0x400921FB60000000
  %15 = tail call float @_Z3sinf(float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z3tanDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z3tanf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z3tanf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z3tanf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z3tanDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z3tanf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z3tanf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z3tanf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z3tanDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z3tanf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z3tanf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z3tanf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z3tanf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z4tanhDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4tanhf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4tanhf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z4tanhf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z4tanhDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4tanhf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4tanhf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4tanhf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z4tanhDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4tanhf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4tanhf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4tanhf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4tanhf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z5tanpif(float %v) #5 {
  %1 = fmul float %v, 0x400921FB60000000
  %2 = tail call float @_Z3tanf(float %1) #12
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z5tanpiDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3tanf(float %2) #12
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3tanf(float %6) #12
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z5tanpiDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3tanf(float %2) #12
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3tanf(float %6) #12
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = fmul float %9, 0x400921FB60000000
  %11 = tail call float @_Z3tanf(float %10) #12
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z5tanpiDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = fmul float %1, 0x400921FB60000000
  %3 = tail call float @_Z3tanf(float %2) #12
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = fmul float %5, 0x400921FB60000000
  %7 = tail call float @_Z3tanf(float %6) #12
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = fmul float %9, 0x400921FB60000000
  %11 = tail call float @_Z3tanf(float %10) #12
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = fmul float %13, 0x400921FB60000000
  %15 = tail call float @_Z3tanf(float %14) #12
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind
define <2 x float> @_Z6tgammaDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z6tgammaf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z6tgammaf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z6tgammaf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z6tgammaDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z6tgammaf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z6tgammaf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z6tgammaf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z6tgammaDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z6tgammaf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z6tgammaf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z6tgammaf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z6tgammaf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define <2 x float> @_Z5truncDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z5truncf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z5truncf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

declare float @_Z5truncf(float) #6

; Function Attrs: nounwind
define <3 x float> @_Z5truncDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z5truncf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z5truncf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z5truncf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z5truncDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z5truncf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z5truncf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z5truncf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z5truncf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind readnone
define i32 @_Z3absi(i32 %v) #7 {
  %1 = icmp slt i32 %v, 0
  %2 = sub nsw i32 0, %v
  %.0 = select i1 %1, i32 %2, i32 %v
  ret i32 %.0
}

; Function Attrs: nounwind readnone
define zeroext i16 @_Z3abss(i16 signext %v) #7 {
  %1 = icmp slt i16 %v, 0
  br i1 %1, label %2, label %6

; <label>:2                                       ; preds = %0
  %3 = zext i16 %v to i32
  %4 = sub nsw i32 0, %3
  %5 = trunc i32 %4 to i16
  br label %6

; <label>:6                                       ; preds = %2, %0
  %.0 = phi i16 [ %5, %2 ], [ %v, %0 ]
  ret i16 %.0
}

; Function Attrs: nounwind readnone
define zeroext i8 @_Z3absc(i8 signext %v) #7 {
  %1 = icmp slt i8 %v, 0
  br i1 %1, label %2, label %6

; <label>:2                                       ; preds = %0
  %3 = zext i8 %v to i32
  %4 = sub nsw i32 0, %3
  %5 = trunc i32 %4 to i8
  br label %6

; <label>:6                                       ; preds = %2, %0
  %.0 = phi i8 [ %5, %2 ], [ %v, %0 ]
  ret i8 %.0
}

; Function Attrs: nounwind readnone
define i32 @_Z3clzj(i32 %v) #7 {
  %1 = tail call i32 @llvm.ctlz.i32(i32 %v, i1 false)
  ret i32 %1
}

; Function Attrs: nounwind readnone
declare i32 @llvm.ctlz.i32(i32, i1) #8

; Function Attrs: nounwind readnone
define zeroext i16 @_Z3clzt(i16 zeroext %v) #7 {
  %1 = zext i16 %v to i32
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false)
  %3 = trunc i32 %2 to i16
  ret i16 %3
}

; Function Attrs: nounwind readnone
define zeroext i8 @_Z3clzh(i8 zeroext %v) #7 {
  %1 = zext i8 %v to i32
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false)
  %3 = trunc i32 %2 to i8
  ret i8 %3
}

; Function Attrs: nounwind readnone
define i32 @_Z3clzi(i32 %v) #7 {
  %1 = tail call i32 @llvm.ctlz.i32(i32 %v, i1 false)
  ret i32 %1
}

; Function Attrs: nounwind readnone
define signext i16 @_Z3clzs(i16 signext %v) #7 {
  %1 = sext i16 %v to i32
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false)
  %3 = trunc i32 %2 to i16
  ret i16 %3
}

; Function Attrs: nounwind readnone
define signext i8 @_Z3clzc(i8 signext %v) #7 {
  %1 = sext i8 %v to i32
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false)
  %3 = trunc i32 %2 to i8
  ret i8 %3
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z3absDv2_c(<2 x i8> %v) #7 {
  %1 = extractelement <2 x i8> %v, i32 0
  %2 = icmp slt i8 %1, 0
  br i1 %2, label %3, label %_Z3absc.exit

; <label>:3                                       ; preds = %0
  %4 = zext i8 %1 to i32
  %5 = sub nsw i32 0, %4
  %6 = trunc i32 %5 to i8
  br label %_Z3absc.exit

_Z3absc.exit:                                     ; preds = %3, %0
  %.0.i = phi i8 [ %6, %3 ], [ %1, %0 ]
  %7 = insertelement <2 x i8> undef, i8 %.0.i, i32 0
  %8 = extractelement <2 x i8> %v, i32 1
  %9 = icmp slt i8 %8, 0
  br i1 %9, label %10, label %_Z3absc.exit2

; <label>:10                                      ; preds = %_Z3absc.exit
  %11 = zext i8 %8 to i32
  %12 = sub nsw i32 0, %11
  %13 = trunc i32 %12 to i8
  br label %_Z3absc.exit2

_Z3absc.exit2:                                    ; preds = %10, %_Z3absc.exit
  %.0.i1 = phi i8 [ %13, %10 ], [ %8, %_Z3absc.exit ]
  %14 = insertelement <2 x i8> %7, i8 %.0.i1, i32 1
  ret <2 x i8> %14
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z3absDv3_c(<3 x i8> %v) #7 {
  %1 = extractelement <3 x i8> %v, i32 0
  %2 = icmp slt i8 %1, 0
  br i1 %2, label %3, label %_Z3absc.exit

; <label>:3                                       ; preds = %0
  %4 = zext i8 %1 to i32
  %5 = sub nsw i32 0, %4
  %6 = trunc i32 %5 to i8
  br label %_Z3absc.exit

_Z3absc.exit:                                     ; preds = %3, %0
  %.0.i = phi i8 [ %6, %3 ], [ %1, %0 ]
  %7 = insertelement <3 x i8> undef, i8 %.0.i, i32 0
  %8 = extractelement <3 x i8> %v, i32 1
  %9 = icmp slt i8 %8, 0
  br i1 %9, label %10, label %_Z3absc.exit4

; <label>:10                                      ; preds = %_Z3absc.exit
  %11 = zext i8 %8 to i32
  %12 = sub nsw i32 0, %11
  %13 = trunc i32 %12 to i8
  br label %_Z3absc.exit4

_Z3absc.exit4:                                    ; preds = %10, %_Z3absc.exit
  %.0.i3 = phi i8 [ %13, %10 ], [ %8, %_Z3absc.exit ]
  %14 = insertelement <3 x i8> %7, i8 %.0.i3, i32 1
  %15 = extractelement <3 x i8> %v, i32 2
  %16 = icmp slt i8 %15, 0
  br i1 %16, label %17, label %_Z3absc.exit2

; <label>:17                                      ; preds = %_Z3absc.exit4
  %18 = zext i8 %15 to i32
  %19 = sub nsw i32 0, %18
  %20 = trunc i32 %19 to i8
  br label %_Z3absc.exit2

_Z3absc.exit2:                                    ; preds = %17, %_Z3absc.exit4
  %.0.i1 = phi i8 [ %20, %17 ], [ %15, %_Z3absc.exit4 ]
  %21 = insertelement <3 x i8> %14, i8 %.0.i1, i32 2
  ret <3 x i8> %21
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z3absDv4_c(<4 x i8> %v) #7 {
  %1 = extractelement <4 x i8> %v, i32 0
  %2 = icmp slt i8 %1, 0
  br i1 %2, label %3, label %_Z3absc.exit

; <label>:3                                       ; preds = %0
  %4 = zext i8 %1 to i32
  %5 = sub nsw i32 0, %4
  %6 = trunc i32 %5 to i8
  br label %_Z3absc.exit

_Z3absc.exit:                                     ; preds = %3, %0
  %.0.i = phi i8 [ %6, %3 ], [ %1, %0 ]
  %7 = insertelement <4 x i8> undef, i8 %.0.i, i32 0
  %8 = extractelement <4 x i8> %v, i32 1
  %9 = icmp slt i8 %8, 0
  br i1 %9, label %10, label %_Z3absc.exit6

; <label>:10                                      ; preds = %_Z3absc.exit
  %11 = zext i8 %8 to i32
  %12 = sub nsw i32 0, %11
  %13 = trunc i32 %12 to i8
  br label %_Z3absc.exit6

_Z3absc.exit6:                                    ; preds = %10, %_Z3absc.exit
  %.0.i5 = phi i8 [ %13, %10 ], [ %8, %_Z3absc.exit ]
  %14 = insertelement <4 x i8> %7, i8 %.0.i5, i32 1
  %15 = extractelement <4 x i8> %v, i32 2
  %16 = icmp slt i8 %15, 0
  br i1 %16, label %17, label %_Z3absc.exit4

; <label>:17                                      ; preds = %_Z3absc.exit6
  %18 = zext i8 %15 to i32
  %19 = sub nsw i32 0, %18
  %20 = trunc i32 %19 to i8
  br label %_Z3absc.exit4

_Z3absc.exit4:                                    ; preds = %17, %_Z3absc.exit6
  %.0.i3 = phi i8 [ %20, %17 ], [ %15, %_Z3absc.exit6 ]
  %21 = insertelement <4 x i8> %14, i8 %.0.i3, i32 2
  %22 = extractelement <4 x i8> %v, i32 3
  %23 = icmp slt i8 %22, 0
  br i1 %23, label %24, label %_Z3absc.exit2

; <label>:24                                      ; preds = %_Z3absc.exit4
  %25 = zext i8 %22 to i32
  %26 = sub nsw i32 0, %25
  %27 = trunc i32 %26 to i8
  br label %_Z3absc.exit2

_Z3absc.exit2:                                    ; preds = %24, %_Z3absc.exit4
  %.0.i1 = phi i8 [ %27, %24 ], [ %22, %_Z3absc.exit4 ]
  %28 = insertelement <4 x i8> %21, i8 %.0.i1, i32 3
  ret <4 x i8> %28
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z3absDv2_s(<2 x i16> %v) #7 {
  %1 = extractelement <2 x i16> %v, i32 0
  %2 = icmp slt i16 %1, 0
  br i1 %2, label %3, label %_Z3abss.exit

; <label>:3                                       ; preds = %0
  %4 = zext i16 %1 to i32
  %5 = sub nsw i32 0, %4
  %6 = trunc i32 %5 to i16
  br label %_Z3abss.exit

_Z3abss.exit:                                     ; preds = %3, %0
  %.0.i = phi i16 [ %6, %3 ], [ %1, %0 ]
  %7 = insertelement <2 x i16> undef, i16 %.0.i, i32 0
  %8 = extractelement <2 x i16> %v, i32 1
  %9 = icmp slt i16 %8, 0
  br i1 %9, label %10, label %_Z3abss.exit2

; <label>:10                                      ; preds = %_Z3abss.exit
  %11 = zext i16 %8 to i32
  %12 = sub nsw i32 0, %11
  %13 = trunc i32 %12 to i16
  br label %_Z3abss.exit2

_Z3abss.exit2:                                    ; preds = %10, %_Z3abss.exit
  %.0.i1 = phi i16 [ %13, %10 ], [ %8, %_Z3abss.exit ]
  %14 = insertelement <2 x i16> %7, i16 %.0.i1, i32 1
  ret <2 x i16> %14
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z3absDv3_s(<3 x i16> %v) #7 {
  %1 = extractelement <3 x i16> %v, i32 0
  %2 = icmp slt i16 %1, 0
  br i1 %2, label %3, label %_Z3abss.exit

; <label>:3                                       ; preds = %0
  %4 = zext i16 %1 to i32
  %5 = sub nsw i32 0, %4
  %6 = trunc i32 %5 to i16
  br label %_Z3abss.exit

_Z3abss.exit:                                     ; preds = %3, %0
  %.0.i = phi i16 [ %6, %3 ], [ %1, %0 ]
  %7 = insertelement <3 x i16> undef, i16 %.0.i, i32 0
  %8 = extractelement <3 x i16> %v, i32 1
  %9 = icmp slt i16 %8, 0
  br i1 %9, label %10, label %_Z3abss.exit4

; <label>:10                                      ; preds = %_Z3abss.exit
  %11 = zext i16 %8 to i32
  %12 = sub nsw i32 0, %11
  %13 = trunc i32 %12 to i16
  br label %_Z3abss.exit4

_Z3abss.exit4:                                    ; preds = %10, %_Z3abss.exit
  %.0.i3 = phi i16 [ %13, %10 ], [ %8, %_Z3abss.exit ]
  %14 = insertelement <3 x i16> %7, i16 %.0.i3, i32 1
  %15 = extractelement <3 x i16> %v, i32 2
  %16 = icmp slt i16 %15, 0
  br i1 %16, label %17, label %_Z3abss.exit2

; <label>:17                                      ; preds = %_Z3abss.exit4
  %18 = zext i16 %15 to i32
  %19 = sub nsw i32 0, %18
  %20 = trunc i32 %19 to i16
  br label %_Z3abss.exit2

_Z3abss.exit2:                                    ; preds = %17, %_Z3abss.exit4
  %.0.i1 = phi i16 [ %20, %17 ], [ %15, %_Z3abss.exit4 ]
  %21 = insertelement <3 x i16> %14, i16 %.0.i1, i32 2
  ret <3 x i16> %21
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z3absDv4_s(<4 x i16> %v) #7 {
  %1 = extractelement <4 x i16> %v, i32 0
  %2 = icmp slt i16 %1, 0
  br i1 %2, label %3, label %_Z3abss.exit

; <label>:3                                       ; preds = %0
  %4 = zext i16 %1 to i32
  %5 = sub nsw i32 0, %4
  %6 = trunc i32 %5 to i16
  br label %_Z3abss.exit

_Z3abss.exit:                                     ; preds = %3, %0
  %.0.i = phi i16 [ %6, %3 ], [ %1, %0 ]
  %7 = insertelement <4 x i16> undef, i16 %.0.i, i32 0
  %8 = extractelement <4 x i16> %v, i32 1
  %9 = icmp slt i16 %8, 0
  br i1 %9, label %10, label %_Z3abss.exit6

; <label>:10                                      ; preds = %_Z3abss.exit
  %11 = zext i16 %8 to i32
  %12 = sub nsw i32 0, %11
  %13 = trunc i32 %12 to i16
  br label %_Z3abss.exit6

_Z3abss.exit6:                                    ; preds = %10, %_Z3abss.exit
  %.0.i5 = phi i16 [ %13, %10 ], [ %8, %_Z3abss.exit ]
  %14 = insertelement <4 x i16> %7, i16 %.0.i5, i32 1
  %15 = extractelement <4 x i16> %v, i32 2
  %16 = icmp slt i16 %15, 0
  br i1 %16, label %17, label %_Z3abss.exit4

; <label>:17                                      ; preds = %_Z3abss.exit6
  %18 = zext i16 %15 to i32
  %19 = sub nsw i32 0, %18
  %20 = trunc i32 %19 to i16
  br label %_Z3abss.exit4

_Z3abss.exit4:                                    ; preds = %17, %_Z3abss.exit6
  %.0.i3 = phi i16 [ %20, %17 ], [ %15, %_Z3abss.exit6 ]
  %21 = insertelement <4 x i16> %14, i16 %.0.i3, i32 2
  %22 = extractelement <4 x i16> %v, i32 3
  %23 = icmp slt i16 %22, 0
  br i1 %23, label %24, label %_Z3abss.exit2

; <label>:24                                      ; preds = %_Z3abss.exit4
  %25 = zext i16 %22 to i32
  %26 = sub nsw i32 0, %25
  %27 = trunc i32 %26 to i16
  br label %_Z3abss.exit2

_Z3abss.exit2:                                    ; preds = %24, %_Z3abss.exit4
  %.0.i1 = phi i16 [ %27, %24 ], [ %22, %_Z3abss.exit4 ]
  %28 = insertelement <4 x i16> %21, i16 %.0.i1, i32 3
  ret <4 x i16> %28
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z3absDv2_i(<2 x i32> %v) #7 {
  %1 = extractelement <2 x i32> %v, i32 0
  %2 = icmp slt i32 %1, 0
  %3 = sub nsw i32 0, %1
  %.0.i = select i1 %2, i32 %3, i32 %1
  %4 = insertelement <2 x i32> undef, i32 %.0.i, i32 0
  %5 = extractelement <2 x i32> %v, i32 1
  %6 = icmp slt i32 %5, 0
  %7 = sub nsw i32 0, %5
  %.0.i1 = select i1 %6, i32 %7, i32 %5
  %8 = insertelement <2 x i32> %4, i32 %.0.i1, i32 1
  ret <2 x i32> %8
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z3absDv3_i(<3 x i32> %v) #7 {
  %1 = extractelement <3 x i32> %v, i32 0
  %2 = icmp slt i32 %1, 0
  %3 = sub nsw i32 0, %1
  %.0.i = select i1 %2, i32 %3, i32 %1
  %4 = insertelement <3 x i32> undef, i32 %.0.i, i32 0
  %5 = extractelement <3 x i32> %v, i32 1
  %6 = icmp slt i32 %5, 0
  %7 = sub nsw i32 0, %5
  %.0.i2 = select i1 %6, i32 %7, i32 %5
  %8 = insertelement <3 x i32> %4, i32 %.0.i2, i32 1
  %9 = extractelement <3 x i32> %v, i32 2
  %10 = icmp slt i32 %9, 0
  %11 = sub nsw i32 0, %9
  %.0.i1 = select i1 %10, i32 %11, i32 %9
  %12 = insertelement <3 x i32> %8, i32 %.0.i1, i32 2
  ret <3 x i32> %12
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z3absDv4_i(<4 x i32> %v) #7 {
  %1 = extractelement <4 x i32> %v, i32 0
  %2 = icmp slt i32 %1, 0
  %3 = sub nsw i32 0, %1
  %.0.i = select i1 %2, i32 %3, i32 %1
  %4 = insertelement <4 x i32> undef, i32 %.0.i, i32 0
  %5 = extractelement <4 x i32> %v, i32 1
  %6 = icmp slt i32 %5, 0
  %7 = sub nsw i32 0, %5
  %.0.i3 = select i1 %6, i32 %7, i32 %5
  %8 = insertelement <4 x i32> %4, i32 %.0.i3, i32 1
  %9 = extractelement <4 x i32> %v, i32 2
  %10 = icmp slt i32 %9, 0
  %11 = sub nsw i32 0, %9
  %.0.i2 = select i1 %10, i32 %11, i32 %9
  %12 = insertelement <4 x i32> %8, i32 %.0.i2, i32 2
  %13 = extractelement <4 x i32> %v, i32 3
  %14 = icmp slt i32 %13, 0
  %15 = sub nsw i32 0, %13
  %.0.i1 = select i1 %14, i32 %15, i32 %13
  %16 = insertelement <4 x i32> %12, i32 %.0.i1, i32 3
  ret <4 x i32> %16
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z3clzDv2_h(<2 x i8> %v) #7 {
  %1 = extractelement <2 x i8> %v, i32 0
  %2 = zext i8 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i8
  %5 = insertelement <2 x i8> undef, i8 %4, i32 0
  %6 = extractelement <2 x i8> %v, i32 1
  %7 = zext i8 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i8
  %10 = insertelement <2 x i8> %5, i8 %9, i32 1
  ret <2 x i8> %10
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z3clzDv3_h(<3 x i8> %v) #7 {
  %1 = extractelement <3 x i8> %v, i32 0
  %2 = zext i8 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i8
  %5 = insertelement <3 x i8> undef, i8 %4, i32 0
  %6 = extractelement <3 x i8> %v, i32 1
  %7 = zext i8 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i8
  %10 = insertelement <3 x i8> %5, i8 %9, i32 1
  %11 = extractelement <3 x i8> %v, i32 2
  %12 = zext i8 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i8
  %15 = insertelement <3 x i8> %10, i8 %14, i32 2
  ret <3 x i8> %15
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z3clzDv4_h(<4 x i8> %v) #7 {
  %1 = extractelement <4 x i8> %v, i32 0
  %2 = zext i8 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i8
  %5 = insertelement <4 x i8> undef, i8 %4, i32 0
  %6 = extractelement <4 x i8> %v, i32 1
  %7 = zext i8 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i8
  %10 = insertelement <4 x i8> %5, i8 %9, i32 1
  %11 = extractelement <4 x i8> %v, i32 2
  %12 = zext i8 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i8
  %15 = insertelement <4 x i8> %10, i8 %14, i32 2
  %16 = extractelement <4 x i8> %v, i32 3
  %17 = zext i8 %16 to i32
  %18 = tail call i32 @llvm.ctlz.i32(i32 %17, i1 false) #2
  %19 = trunc i32 %18 to i8
  %20 = insertelement <4 x i8> %15, i8 %19, i32 3
  ret <4 x i8> %20
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z3clzDv2_c(<2 x i8> %v) #7 {
  %1 = extractelement <2 x i8> %v, i32 0
  %2 = sext i8 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i8
  %5 = insertelement <2 x i8> undef, i8 %4, i32 0
  %6 = extractelement <2 x i8> %v, i32 1
  %7 = sext i8 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i8
  %10 = insertelement <2 x i8> %5, i8 %9, i32 1
  ret <2 x i8> %10
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z3clzDv3_c(<3 x i8> %v) #7 {
  %1 = extractelement <3 x i8> %v, i32 0
  %2 = sext i8 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i8
  %5 = insertelement <3 x i8> undef, i8 %4, i32 0
  %6 = extractelement <3 x i8> %v, i32 1
  %7 = sext i8 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i8
  %10 = insertelement <3 x i8> %5, i8 %9, i32 1
  %11 = extractelement <3 x i8> %v, i32 2
  %12 = sext i8 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i8
  %15 = insertelement <3 x i8> %10, i8 %14, i32 2
  ret <3 x i8> %15
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z3clzDv4_c(<4 x i8> %v) #7 {
  %1 = extractelement <4 x i8> %v, i32 0
  %2 = sext i8 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i8
  %5 = insertelement <4 x i8> undef, i8 %4, i32 0
  %6 = extractelement <4 x i8> %v, i32 1
  %7 = sext i8 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i8
  %10 = insertelement <4 x i8> %5, i8 %9, i32 1
  %11 = extractelement <4 x i8> %v, i32 2
  %12 = sext i8 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i8
  %15 = insertelement <4 x i8> %10, i8 %14, i32 2
  %16 = extractelement <4 x i8> %v, i32 3
  %17 = sext i8 %16 to i32
  %18 = tail call i32 @llvm.ctlz.i32(i32 %17, i1 false) #2
  %19 = trunc i32 %18 to i8
  %20 = insertelement <4 x i8> %15, i8 %19, i32 3
  ret <4 x i8> %20
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z3clzDv2_t(<2 x i16> %v) #7 {
  %1 = extractelement <2 x i16> %v, i32 0
  %2 = zext i16 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i16
  %5 = insertelement <2 x i16> undef, i16 %4, i32 0
  %6 = extractelement <2 x i16> %v, i32 1
  %7 = zext i16 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i16
  %10 = insertelement <2 x i16> %5, i16 %9, i32 1
  ret <2 x i16> %10
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z3clzDv3_t(<3 x i16> %v) #7 {
  %1 = extractelement <3 x i16> %v, i32 0
  %2 = zext i16 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i16
  %5 = insertelement <3 x i16> undef, i16 %4, i32 0
  %6 = extractelement <3 x i16> %v, i32 1
  %7 = zext i16 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i16
  %10 = insertelement <3 x i16> %5, i16 %9, i32 1
  %11 = extractelement <3 x i16> %v, i32 2
  %12 = zext i16 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i16
  %15 = insertelement <3 x i16> %10, i16 %14, i32 2
  ret <3 x i16> %15
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z3clzDv4_t(<4 x i16> %v) #7 {
  %1 = extractelement <4 x i16> %v, i32 0
  %2 = zext i16 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i16
  %5 = insertelement <4 x i16> undef, i16 %4, i32 0
  %6 = extractelement <4 x i16> %v, i32 1
  %7 = zext i16 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i16
  %10 = insertelement <4 x i16> %5, i16 %9, i32 1
  %11 = extractelement <4 x i16> %v, i32 2
  %12 = zext i16 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i16
  %15 = insertelement <4 x i16> %10, i16 %14, i32 2
  %16 = extractelement <4 x i16> %v, i32 3
  %17 = zext i16 %16 to i32
  %18 = tail call i32 @llvm.ctlz.i32(i32 %17, i1 false) #2
  %19 = trunc i32 %18 to i16
  %20 = insertelement <4 x i16> %15, i16 %19, i32 3
  ret <4 x i16> %20
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z3clzDv2_s(<2 x i16> %v) #7 {
  %1 = extractelement <2 x i16> %v, i32 0
  %2 = sext i16 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i16
  %5 = insertelement <2 x i16> undef, i16 %4, i32 0
  %6 = extractelement <2 x i16> %v, i32 1
  %7 = sext i16 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i16
  %10 = insertelement <2 x i16> %5, i16 %9, i32 1
  ret <2 x i16> %10
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z3clzDv3_s(<3 x i16> %v) #7 {
  %1 = extractelement <3 x i16> %v, i32 0
  %2 = sext i16 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i16
  %5 = insertelement <3 x i16> undef, i16 %4, i32 0
  %6 = extractelement <3 x i16> %v, i32 1
  %7 = sext i16 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i16
  %10 = insertelement <3 x i16> %5, i16 %9, i32 1
  %11 = extractelement <3 x i16> %v, i32 2
  %12 = sext i16 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i16
  %15 = insertelement <3 x i16> %10, i16 %14, i32 2
  ret <3 x i16> %15
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z3clzDv4_s(<4 x i16> %v) #7 {
  %1 = extractelement <4 x i16> %v, i32 0
  %2 = sext i16 %1 to i32
  %3 = tail call i32 @llvm.ctlz.i32(i32 %2, i1 false) #2
  %4 = trunc i32 %3 to i16
  %5 = insertelement <4 x i16> undef, i16 %4, i32 0
  %6 = extractelement <4 x i16> %v, i32 1
  %7 = sext i16 %6 to i32
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = trunc i32 %8 to i16
  %10 = insertelement <4 x i16> %5, i16 %9, i32 1
  %11 = extractelement <4 x i16> %v, i32 2
  %12 = sext i16 %11 to i32
  %13 = tail call i32 @llvm.ctlz.i32(i32 %12, i1 false) #2
  %14 = trunc i32 %13 to i16
  %15 = insertelement <4 x i16> %10, i16 %14, i32 2
  %16 = extractelement <4 x i16> %v, i32 3
  %17 = sext i16 %16 to i32
  %18 = tail call i32 @llvm.ctlz.i32(i32 %17, i1 false) #2
  %19 = trunc i32 %18 to i16
  %20 = insertelement <4 x i16> %15, i16 %19, i32 3
  ret <4 x i16> %20
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z3clzDv2_j(<2 x i32> %v) #7 {
  %1 = extractelement <2 x i32> %v, i32 0
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false) #2
  %3 = insertelement <2 x i32> undef, i32 %2, i32 0
  %4 = extractelement <2 x i32> %v, i32 1
  %5 = tail call i32 @llvm.ctlz.i32(i32 %4, i1 false) #2
  %6 = insertelement <2 x i32> %3, i32 %5, i32 1
  ret <2 x i32> %6
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z3clzDv3_j(<3 x i32> %v) #7 {
  %1 = extractelement <3 x i32> %v, i32 0
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false) #2
  %3 = insertelement <3 x i32> undef, i32 %2, i32 0
  %4 = extractelement <3 x i32> %v, i32 1
  %5 = tail call i32 @llvm.ctlz.i32(i32 %4, i1 false) #2
  %6 = insertelement <3 x i32> %3, i32 %5, i32 1
  %7 = extractelement <3 x i32> %v, i32 2
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = insertelement <3 x i32> %6, i32 %8, i32 2
  ret <3 x i32> %9
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z3clzDv4_j(<4 x i32> %v) #7 {
  %1 = extractelement <4 x i32> %v, i32 0
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false) #2
  %3 = insertelement <4 x i32> undef, i32 %2, i32 0
  %4 = extractelement <4 x i32> %v, i32 1
  %5 = tail call i32 @llvm.ctlz.i32(i32 %4, i1 false) #2
  %6 = insertelement <4 x i32> %3, i32 %5, i32 1
  %7 = extractelement <4 x i32> %v, i32 2
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = insertelement <4 x i32> %6, i32 %8, i32 2
  %10 = extractelement <4 x i32> %v, i32 3
  %11 = tail call i32 @llvm.ctlz.i32(i32 %10, i1 false) #2
  %12 = insertelement <4 x i32> %9, i32 %11, i32 3
  ret <4 x i32> %12
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z3clzDv2_i(<2 x i32> %v) #7 {
  %1 = extractelement <2 x i32> %v, i32 0
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false) #2
  %3 = insertelement <2 x i32> undef, i32 %2, i32 0
  %4 = extractelement <2 x i32> %v, i32 1
  %5 = tail call i32 @llvm.ctlz.i32(i32 %4, i1 false) #2
  %6 = insertelement <2 x i32> %3, i32 %5, i32 1
  ret <2 x i32> %6
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z3clzDv3_i(<3 x i32> %v) #7 {
  %1 = extractelement <3 x i32> %v, i32 0
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false) #2
  %3 = insertelement <3 x i32> undef, i32 %2, i32 0
  %4 = extractelement <3 x i32> %v, i32 1
  %5 = tail call i32 @llvm.ctlz.i32(i32 %4, i1 false) #2
  %6 = insertelement <3 x i32> %3, i32 %5, i32 1
  %7 = extractelement <3 x i32> %v, i32 2
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = insertelement <3 x i32> %6, i32 %8, i32 2
  ret <3 x i32> %9
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z3clzDv4_i(<4 x i32> %v) #7 {
  %1 = extractelement <4 x i32> %v, i32 0
  %2 = tail call i32 @llvm.ctlz.i32(i32 %1, i1 false) #2
  %3 = insertelement <4 x i32> undef, i32 %2, i32 0
  %4 = extractelement <4 x i32> %v, i32 1
  %5 = tail call i32 @llvm.ctlz.i32(i32 %4, i1 false) #2
  %6 = insertelement <4 x i32> %3, i32 %5, i32 1
  %7 = extractelement <4 x i32> %v, i32 2
  %8 = tail call i32 @llvm.ctlz.i32(i32 %7, i1 false) #2
  %9 = insertelement <4 x i32> %6, i32 %8, i32 2
  %10 = extractelement <4 x i32> %v, i32 3
  %11 = tail call i32 @llvm.ctlz.i32(i32 %10, i1 false) #2
  %12 = insertelement <4 x i32> %9, i32 %11, i32 3
  ret <4 x i32> %12
}

; Function Attrs: nounwind readnone
define float @_Z7degreesf(float %radians) #7 {
  %1 = fmul float %radians, 0x404CA5DC00000000
  ret float %1
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z7degreesDv2_f(<2 x float> %radians) #7 {
  %1 = fmul <2 x float> %radians, <float 0x404CA5DC00000000, float 0x404CA5DC00000000>
  ret <2 x float> %1
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z7degreesDv3_f(<3 x float> %radians) #7 {
  %1 = fmul <3 x float> %radians, <float 0x404CA5DC00000000, float 0x404CA5DC00000000, float 0x404CA5DC00000000>
  ret <3 x float> %1
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z7degreesDv4_f(<4 x float> %radians) #7 {
  %1 = fmul <4 x float> %radians, <float 0x404CA5DC00000000, float 0x404CA5DC00000000, float 0x404CA5DC00000000, float 0x404CA5DC00000000>
  ret <4 x float> %1
}

; Function Attrs: nounwind readnone
define float @_Z3mixfff(float %start, float %stop, float %amount) #7 {
  %1 = fsub float %stop, %start
  %2 = fmul float %1, %amount
  %3 = fadd float %2, %start
  ret float %3
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z3mixDv2_fS_S_(<2 x float> %start, <2 x float> %stop, <2 x float> %amount) #7 {
  %1 = fsub <2 x float> %stop, %start
  %2 = fmul <2 x float> %1, %amount
  %3 = fadd <2 x float> %2, %start
  ret <2 x float> %3
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z3mixDv3_fS_S_(<3 x float> %start, <3 x float> %stop, <3 x float> %amount) #7 {
  %1 = fsub <3 x float> %stop, %start
  %2 = fmul <3 x float> %1, %amount
  %3 = fadd <3 x float> %2, %start
  ret <3 x float> %3
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z3mixDv4_fS_S_(<4 x float> %start, <4 x float> %stop, <4 x float> %amount) #7 {
  %1 = fsub <4 x float> %stop, %start
  %2 = fmul <4 x float> %1, %amount
  %3 = fadd <4 x float> %2, %start
  ret <4 x float> %3
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z3mixDv2_fS_f(<2 x float> %start, <2 x float> %stop, float %amount) #7 {
  %1 = fsub <2 x float> %stop, %start
  %2 = insertelement <2 x float> undef, float %amount, i32 0
  %3 = shufflevector <2 x float> %2, <2 x float> undef, <2 x i32> zeroinitializer
  %4 = fmul <2 x float> %1, %3
  %5 = fadd <2 x float> %4, %start
  ret <2 x float> %5
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z3mixDv3_fS_f(<3 x float> %start, <3 x float> %stop, float %amount) #7 {
  %1 = fsub <3 x float> %stop, %start
  %2 = insertelement <3 x float> undef, float %amount, i32 0
  %3 = shufflevector <3 x float> %2, <3 x float> undef, <3 x i32> zeroinitializer
  %4 = fmul <3 x float> %1, %3
  %5 = fadd <3 x float> %4, %start
  ret <3 x float> %5
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z3mixDv4_fS_f(<4 x float> %start, <4 x float> %stop, float %amount) #7 {
  %1 = fsub <4 x float> %stop, %start
  %2 = insertelement <4 x float> undef, float %amount, i32 0
  %3 = shufflevector <4 x float> %2, <4 x float> undef, <4 x i32> zeroinitializer
  %4 = fmul <4 x float> %1, %3
  %5 = fadd <4 x float> %4, %start
  ret <4 x float> %5
}

; Function Attrs: nounwind readnone
define float @_Z7radiansf(float %degrees) #7 {
  %1 = fmul float %degrees, 0x3F91DF46A0000000
  ret float %1
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z7radiansDv2_f(<2 x float> %degrees) #7 {
  %1 = fmul <2 x float> %degrees, <float 0x3F91DF46A0000000, float 0x3F91DF46A0000000>
  ret <2 x float> %1
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z7radiansDv3_f(<3 x float> %degrees) #7 {
  %1 = fmul <3 x float> %degrees, <float 0x3F91DF46A0000000, float 0x3F91DF46A0000000, float 0x3F91DF46A0000000>
  ret <3 x float> %1
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z7radiansDv4_f(<4 x float> %degrees) #7 {
  %1 = fmul <4 x float> %degrees, <float 0x3F91DF46A0000000, float 0x3F91DF46A0000000, float 0x3F91DF46A0000000, float 0x3F91DF46A0000000>
  ret <4 x float> %1
}

; Function Attrs: nounwind readnone
define float @_Z4stepff(float %edge, float %v) #7 {
  %1 = fcmp olt float %v, %edge
  %2 = select i1 %1, float 0.000000e+00, float 1.000000e+00
  ret float %2
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4stepDv2_fS_(<2 x float> %edge, <2 x float> %v) #7 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = extractelement <2 x float> %edge, i32 0
  %3 = fcmp olt float %1, %2
  %4 = select i1 %3, float 0.000000e+00, float 1.000000e+00
  %5 = insertelement <2 x float> undef, float %4, i32 0
  %6 = extractelement <2 x float> %v, i32 1
  %7 = extractelement <2 x float> %edge, i32 1
  %8 = fcmp olt float %6, %7
  %9 = select i1 %8, float 0.000000e+00, float 1.000000e+00
  %10 = insertelement <2 x float> %5, float %9, i32 1
  ret <2 x float> %10
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4stepDv3_fS_(<3 x float> %edge, <3 x float> %v) #7 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = extractelement <3 x float> %edge, i32 0
  %3 = fcmp olt float %1, %2
  %4 = select i1 %3, float 0.000000e+00, float 1.000000e+00
  %5 = insertelement <3 x float> undef, float %4, i32 0
  %6 = extractelement <3 x float> %v, i32 1
  %7 = extractelement <3 x float> %edge, i32 1
  %8 = fcmp olt float %6, %7
  %9 = select i1 %8, float 0.000000e+00, float 1.000000e+00
  %10 = insertelement <3 x float> %5, float %9, i32 1
  %11 = extractelement <3 x float> %v, i32 2
  %12 = extractelement <3 x float> %edge, i32 2
  %13 = fcmp olt float %11, %12
  %14 = select i1 %13, float 0.000000e+00, float 1.000000e+00
  %15 = insertelement <3 x float> %10, float %14, i32 2
  ret <3 x float> %15
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4stepDv4_fS_(<4 x float> %edge, <4 x float> %v) #7 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = extractelement <4 x float> %edge, i32 0
  %3 = fcmp olt float %1, %2
  %4 = select i1 %3, float 0.000000e+00, float 1.000000e+00
  %5 = insertelement <4 x float> undef, float %4, i32 0
  %6 = extractelement <4 x float> %v, i32 1
  %7 = extractelement <4 x float> %edge, i32 1
  %8 = fcmp olt float %6, %7
  %9 = select i1 %8, float 0.000000e+00, float 1.000000e+00
  %10 = insertelement <4 x float> %5, float %9, i32 1
  %11 = extractelement <4 x float> %v, i32 2
  %12 = extractelement <4 x float> %edge, i32 2
  %13 = fcmp olt float %11, %12
  %14 = select i1 %13, float 0.000000e+00, float 1.000000e+00
  %15 = insertelement <4 x float> %10, float %14, i32 2
  %16 = extractelement <4 x float> %v, i32 3
  %17 = extractelement <4 x float> %edge, i32 3
  %18 = fcmp olt float %16, %17
  %19 = select i1 %18, float 0.000000e+00, float 1.000000e+00
  %20 = insertelement <4 x float> %15, float %19, i32 3
  ret <4 x float> %20
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4stepDv2_ff(<2 x float> %edge, float %v) #7 {
  %1 = extractelement <2 x float> %edge, i32 0
  %2 = fcmp ogt float %1, %v
  %3 = select i1 %2, float 0.000000e+00, float 1.000000e+00
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %edge, i32 1
  %6 = fcmp ogt float %5, %v
  %7 = select i1 %6, float 0.000000e+00, float 1.000000e+00
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4stepDv3_ff(<3 x float> %edge, float %v) #7 {
  %1 = extractelement <3 x float> %edge, i32 0
  %2 = fcmp ogt float %1, %v
  %3 = select i1 %2, float 0.000000e+00, float 1.000000e+00
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %edge, i32 1
  %6 = fcmp ogt float %5, %v
  %7 = select i1 %6, float 0.000000e+00, float 1.000000e+00
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %edge, i32 2
  %10 = fcmp ogt float %9, %v
  %11 = select i1 %10, float 0.000000e+00, float 1.000000e+00
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4stepDv4_ff(<4 x float> %edge, float %v) #7 {
  %1 = extractelement <4 x float> %edge, i32 0
  %2 = fcmp ogt float %1, %v
  %3 = select i1 %2, float 0.000000e+00, float 1.000000e+00
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %edge, i32 1
  %6 = fcmp ogt float %5, %v
  %7 = select i1 %6, float 0.000000e+00, float 1.000000e+00
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %edge, i32 2
  %10 = fcmp ogt float %9, %v
  %11 = select i1 %10, float 0.000000e+00, float 1.000000e+00
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %edge, i32 3
  %14 = fcmp ogt float %13, %v
  %15 = select i1 %14, float 0.000000e+00, float 1.000000e+00
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind readnone
define float @_Z4signf(float %v) #7 {
  %1 = fcmp ogt float %v, 0.000000e+00
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = fcmp olt float %v, 0.000000e+00
  %.v = select i1 %3, float -1.000000e+00, float %v
  br label %4

; <label>:4                                       ; preds = %2, %0
  %.0 = phi float [ 1.000000e+00, %0 ], [ %.v, %2 ]
  ret float %.0
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4signDv2_f(<2 x float> %v) #7 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = fcmp ogt float %1, 0.000000e+00
  br i1 %2, label %_Z4signf.exit, label %3

; <label>:3                                       ; preds = %0
  %4 = fcmp olt float %1, 0.000000e+00
  %.v.i = select i1 %4, float -1.000000e+00, float %1
  br label %_Z4signf.exit

_Z4signf.exit:                                    ; preds = %3, %0
  %.0.i = phi float [ 1.000000e+00, %0 ], [ %.v.i, %3 ]
  %5 = insertelement <2 x float> undef, float %.0.i, i32 0
  %6 = extractelement <2 x float> %v, i32 1
  %7 = fcmp ogt float %6, 0.000000e+00
  br i1 %7, label %_Z4signf.exit3, label %8

; <label>:8                                       ; preds = %_Z4signf.exit
  %9 = fcmp olt float %6, 0.000000e+00
  %.v.i1 = select i1 %9, float -1.000000e+00, float %6
  br label %_Z4signf.exit3

_Z4signf.exit3:                                   ; preds = %8, %_Z4signf.exit
  %.0.i2 = phi float [ 1.000000e+00, %_Z4signf.exit ], [ %.v.i1, %8 ]
  %10 = insertelement <2 x float> %5, float %.0.i2, i32 1
  ret <2 x float> %10
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4signDv3_f(<3 x float> %v) #7 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = fcmp ogt float %1, 0.000000e+00
  br i1 %2, label %_Z4signf.exit, label %3

; <label>:3                                       ; preds = %0
  %4 = fcmp olt float %1, 0.000000e+00
  %.v.i = select i1 %4, float -1.000000e+00, float %1
  br label %_Z4signf.exit

_Z4signf.exit:                                    ; preds = %3, %0
  %.0.i = phi float [ 1.000000e+00, %0 ], [ %.v.i, %3 ]
  %5 = insertelement <3 x float> undef, float %.0.i, i32 0
  %6 = extractelement <3 x float> %v, i32 1
  %7 = fcmp ogt float %6, 0.000000e+00
  br i1 %7, label %_Z4signf.exit6, label %8

; <label>:8                                       ; preds = %_Z4signf.exit
  %9 = fcmp olt float %6, 0.000000e+00
  %.v.i4 = select i1 %9, float -1.000000e+00, float %6
  br label %_Z4signf.exit6

_Z4signf.exit6:                                   ; preds = %8, %_Z4signf.exit
  %.0.i5 = phi float [ 1.000000e+00, %_Z4signf.exit ], [ %.v.i4, %8 ]
  %10 = insertelement <3 x float> %5, float %.0.i5, i32 1
  %11 = extractelement <3 x float> %v, i32 2
  %12 = fcmp ogt float %11, 0.000000e+00
  br i1 %12, label %_Z4signf.exit3, label %13

; <label>:13                                      ; preds = %_Z4signf.exit6
  %14 = fcmp olt float %11, 0.000000e+00
  %.v.i1 = select i1 %14, float -1.000000e+00, float %11
  br label %_Z4signf.exit3

_Z4signf.exit3:                                   ; preds = %13, %_Z4signf.exit6
  %.0.i2 = phi float [ 1.000000e+00, %_Z4signf.exit6 ], [ %.v.i1, %13 ]
  %15 = insertelement <3 x float> %10, float %.0.i2, i32 2
  ret <3 x float> %15
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4signDv4_f(<4 x float> %v) #7 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = fcmp ogt float %1, 0.000000e+00
  br i1 %2, label %_Z4signf.exit, label %3

; <label>:3                                       ; preds = %0
  %4 = fcmp olt float %1, 0.000000e+00
  %.v.i = select i1 %4, float -1.000000e+00, float %1
  br label %_Z4signf.exit

_Z4signf.exit:                                    ; preds = %3, %0
  %.0.i = phi float [ 1.000000e+00, %0 ], [ %.v.i, %3 ]
  %5 = insertelement <4 x float> undef, float %.0.i, i32 0
  %6 = extractelement <4 x float> %v, i32 1
  %7 = fcmp ogt float %6, 0.000000e+00
  br i1 %7, label %_Z4signf.exit9, label %8

; <label>:8                                       ; preds = %_Z4signf.exit
  %9 = fcmp olt float %6, 0.000000e+00
  %.v.i7 = select i1 %9, float -1.000000e+00, float %6
  br label %_Z4signf.exit9

_Z4signf.exit9:                                   ; preds = %8, %_Z4signf.exit
  %.0.i8 = phi float [ 1.000000e+00, %_Z4signf.exit ], [ %.v.i7, %8 ]
  %10 = insertelement <4 x float> %5, float %.0.i8, i32 1
  %11 = extractelement <4 x float> %v, i32 2
  %12 = fcmp ogt float %11, 0.000000e+00
  br i1 %12, label %_Z4signf.exit6, label %13

; <label>:13                                      ; preds = %_Z4signf.exit9
  %14 = fcmp olt float %11, 0.000000e+00
  %.v.i4 = select i1 %14, float -1.000000e+00, float %11
  br label %_Z4signf.exit6

_Z4signf.exit6:                                   ; preds = %13, %_Z4signf.exit9
  %.0.i5 = phi float [ 1.000000e+00, %_Z4signf.exit9 ], [ %.v.i4, %13 ]
  %15 = insertelement <4 x float> %10, float %.0.i5, i32 2
  %16 = extractelement <4 x float> %v, i32 3
  %17 = fcmp ogt float %16, 0.000000e+00
  br i1 %17, label %_Z4signf.exit3, label %18

; <label>:18                                      ; preds = %_Z4signf.exit6
  %19 = fcmp olt float %16, 0.000000e+00
  %.v.i1 = select i1 %19, float -1.000000e+00, float %16
  br label %_Z4signf.exit3

_Z4signf.exit3:                                   ; preds = %18, %_Z4signf.exit6
  %.0.i2 = phi float [ 1.000000e+00, %_Z4signf.exit6 ], [ %.v.i1, %18 ]
  %20 = insertelement <4 x float> %15, float %.0.i2, i32 3
  ret <4 x float> %20
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z5crossDv3_fS_(<3 x float> %lhs, <3 x float> %rhs) #7 {
  %1 = extractelement <3 x float> %lhs, i32 1
  %2 = extractelement <3 x float> %rhs, i32 2
  %3 = fmul float %1, %2
  %4 = extractelement <3 x float> %lhs, i32 2
  %5 = extractelement <3 x float> %rhs, i32 1
  %6 = fmul float %4, %5
  %7 = fsub float %3, %6
  %8 = insertelement <3 x float> undef, float %7, i32 0
  %9 = extractelement <3 x float> %rhs, i32 0
  %10 = fmul float %4, %9
  %11 = extractelement <3 x float> %lhs, i32 0
  %12 = fmul float %11, %2
  %13 = fsub float %10, %12
  %14 = insertelement <3 x float> %8, float %13, i32 1
  %15 = fmul float %11, %5
  %16 = fmul float %1, %9
  %17 = fsub float %15, %16
  %18 = insertelement <3 x float> %14, float %17, i32 2
  ret <3 x float> %18
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z5crossDv4_fS_(<4 x float> %lhs, <4 x float> %rhs) #7 {
  %1 = extractelement <4 x float> %lhs, i32 1
  %2 = extractelement <4 x float> %rhs, i32 2
  %3 = fmul float %1, %2
  %4 = extractelement <4 x float> %lhs, i32 2
  %5 = extractelement <4 x float> %rhs, i32 1
  %6 = fmul float %4, %5
  %7 = fsub float %3, %6
  %8 = insertelement <4 x float> undef, float %7, i32 0
  %9 = extractelement <4 x float> %rhs, i32 0
  %10 = fmul float %4, %9
  %11 = extractelement <4 x float> %lhs, i32 0
  %12 = fmul float %11, %2
  %13 = fsub float %10, %12
  %14 = insertelement <4 x float> %8, float %13, i32 1
  %15 = fmul float %11, %5
  %16 = fmul float %1, %9
  %17 = fsub float %15, %16
  %18 = insertelement <4 x float> %14, float %17, i32 2
  %19 = insertelement <4 x float> %18, float 0.000000e+00, i32 3
  ret <4 x float> %19
}

; Function Attrs: nounwind
define float @_Z8distanceff(float %lhs, float %rhs) #5 {
  %1 = fsub float %lhs, %rhs
  ret float %1
}

; Function Attrs: nounwind
define float @_Z8distanceDv2_fS_(<2 x float> %lhs, <2 x float> %rhs) #5 {
  %1 = fsub <2 x float> %lhs, %rhs
  %2 = fmul <2 x float> %1, %1
  %3 = shufflevector <2 x float> %2, <2 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %3, <4 x float> %3) #8
  %5 = extractelement <4 x float> %4, i32 0
  %6 = tail call float @llvm.sqrt.f32(float %5) #8
  ret float %6
}

; Function Attrs: nounwind
define float @_Z8distanceDv3_fS_(<3 x float> %lhs, <3 x float> %rhs) #5 {
  %1 = fsub <3 x float> %lhs, %rhs
  %2 = fmul <3 x float> %1, %1
  %3 = shufflevector <3 x float> %2, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = bitcast <4 x float> %3 to <2 x i64>
  %5 = tail call <2 x i64> @llvm.x86.sse2.psll.dq(<2 x i64> %4, i32 32) #2
  %6 = bitcast <2 x i64> %5 to <4 x float>
  %7 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %6, <4 x float> %6) #8
  %8 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %7, <4 x float> %7) #8
  %9 = extractelement <4 x float> %8, i32 0
  %10 = tail call float @llvm.sqrt.f32(float %9) #8
  ret float %10
}

; Function Attrs: nounwind
define float @_Z8distanceDv4_fS_(<4 x float> %lhs, <4 x float> %rhs) #5 {
  %1 = fsub <4 x float> %lhs, %rhs
  %2 = fmul <4 x float> %1, %1
  %3 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %2, <4 x float> %2) #8
  %4 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %3, <4 x float> %3) #8
  %5 = extractelement <4 x float> %4, i32 0
  %6 = tail call float @llvm.sqrt.f32(float %5) #8
  ret float %6
}

; Function Attrs: nounwind readnone
define float @_Z9normalizef(float %v) #7 {
  ret float 1.000000e+00
}

; Function Attrs: nounwind
define <2 x float> @_Z9normalizeDv2_f(<2 x float> %v) #5 {
  %1 = fmul <2 x float> %v, %v
  %2 = shufflevector <2 x float> %1, <2 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %2, <4 x float> %2) #8
  %4 = extractelement <4 x float> %3, i32 0
  %5 = tail call float @llvm.sqrt.f32(float %4) #8
  %6 = insertelement <2 x float> undef, float %5, i32 0
  %7 = shufflevector <2 x float> %6, <2 x float> undef, <2 x i32> zeroinitializer
  %8 = fdiv <2 x float> %v, %7
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z9normalizeDv3_f(<3 x float> %v) #5 {
  %1 = fmul <3 x float> %v, %v
  %2 = shufflevector <3 x float> %1, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = bitcast <4 x float> %2 to <2 x i64>
  %4 = tail call <2 x i64> @llvm.x86.sse2.psll.dq(<2 x i64> %3, i32 32) #2
  %5 = bitcast <2 x i64> %4 to <4 x float>
  %6 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %5, <4 x float> %5) #8
  %7 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %6, <4 x float> %6) #8
  %8 = extractelement <4 x float> %7, i32 0
  %9 = tail call float @llvm.sqrt.f32(float %8) #8
  %10 = insertelement <3 x float> undef, float %9, i32 0
  %11 = shufflevector <3 x float> %10, <3 x float> undef, <3 x i32> zeroinitializer
  %12 = fdiv <3 x float> %v, %11
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z9normalizeDv4_f(<4 x float> %v) #5 {
  %1 = fmul <4 x float> %v, %v
  %2 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %1, <4 x float> %1) #8
  %3 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %2, <4 x float> %2) #8
  %4 = extractelement <4 x float> %3, i32 0
  %5 = tail call float @llvm.sqrt.f32(float %4) #8
  %6 = insertelement <4 x float> undef, float %5, i32 0
  %7 = shufflevector <4 x float> %6, <4 x float> undef, <4 x i32> zeroinitializer
  %8 = fdiv <4 x float> %v, %7
  ret <4 x float> %8
}

; Function Attrs: nounwind readnone
define float @_Z11fast_lengthf(float %v) #7 {
  %1 = bitcast float %v to i32
  %2 = and i32 %1, 2147483647
  %3 = bitcast i32 %2 to float
  ret float %3
}

; Function Attrs: nounwind
define float @_Z11fast_lengthDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = fmul float %1, %1
  %3 = extractelement <2 x float> %v, i32 1
  %4 = fmul float %3, %3
  %5 = fadd float %2, %4
  %6 = tail call float @_Z9half_sqrtf(float %5) #12
  ret float %6
}

; Function Attrs: nounwind
define float @_Z11fast_lengthDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = fmul float %1, %1
  %3 = extractelement <3 x float> %v, i32 1
  %4 = fmul float %3, %3
  %5 = fadd float %2, %4
  %6 = extractelement <3 x float> %v, i32 2
  %7 = fmul float %6, %6
  %8 = fadd float %7, %5
  %9 = tail call float @_Z9half_sqrtf(float %8) #12
  ret float %9
}

; Function Attrs: nounwind
define float @_Z11fast_lengthDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = fmul float %1, %1
  %3 = extractelement <4 x float> %v, i32 1
  %4 = fmul float %3, %3
  %5 = fadd float %2, %4
  %6 = extractelement <4 x float> %v, i32 2
  %7 = fmul float %6, %6
  %8 = fadd float %7, %5
  %9 = extractelement <4 x float> %v, i32 3
  %10 = fmul float %9, %9
  %11 = fadd float %10, %8
  %12 = tail call float @_Z9half_sqrtf(float %11) #12
  ret float %12
}

; Function Attrs: nounwind readnone
define float @_Z13fast_distanceff(float %lhs, float %rhs) #7 {
  %1 = fsub float %lhs, %rhs
  %2 = bitcast float %1 to i32
  %3 = and i32 %2, 2147483647
  %4 = bitcast i32 %3 to float
  ret float %4
}

; Function Attrs: nounwind
define float @_Z13fast_distanceDv2_fS_(<2 x float> %lhs, <2 x float> %rhs) #5 {
  %1 = fsub <2 x float> %lhs, %rhs
  %2 = extractelement <2 x float> %1, i32 0
  %3 = fmul float %2, %2
  %4 = extractelement <2 x float> %1, i32 1
  %5 = fmul float %4, %4
  %6 = fadd float %3, %5
  %7 = tail call float @_Z9half_sqrtf(float %6) #12
  ret float %7
}

; Function Attrs: nounwind
define float @_Z13fast_distanceDv3_fS_(<3 x float> %lhs, <3 x float> %rhs) #5 {
  %1 = fsub <3 x float> %lhs, %rhs
  %2 = extractelement <3 x float> %1, i32 0
  %3 = fmul float %2, %2
  %4 = extractelement <3 x float> %1, i32 1
  %5 = fmul float %4, %4
  %6 = fadd float %3, %5
  %7 = extractelement <3 x float> %1, i32 2
  %8 = fmul float %7, %7
  %9 = fadd float %8, %6
  %10 = tail call float @_Z9half_sqrtf(float %9) #12
  ret float %10
}

; Function Attrs: nounwind
define float @_Z13fast_distanceDv4_fS_(<4 x float> %lhs, <4 x float> %rhs) #5 {
  %1 = fsub <4 x float> %lhs, %rhs
  %2 = extractelement <4 x float> %1, i32 0
  %3 = fmul float %2, %2
  %4 = extractelement <4 x float> %1, i32 1
  %5 = fmul float %4, %4
  %6 = fadd float %3, %5
  %7 = extractelement <4 x float> %1, i32 2
  %8 = fmul float %7, %7
  %9 = fadd float %8, %6
  %10 = extractelement <4 x float> %1, i32 3
  %11 = fmul float %10, %10
  %12 = fadd float %11, %9
  %13 = tail call float @_Z9half_sqrtf(float %12) #12
  ret float %13
}

; Function Attrs: nounwind readnone
define float @_Z14fast_normalizef(float %v) #7 {
  ret float 1.000000e+00
}

; Function Attrs: nounwind
define <2 x float> @_Z14fast_normalizeDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = fmul float %1, %1
  %3 = extractelement <2 x float> %v, i32 1
  %4 = fmul float %3, %3
  %5 = fadd float %2, %4
  %6 = tail call float @_Z10half_rsqrtf(float %5) #12
  %7 = insertelement <2 x float> undef, float %6, i32 0
  %8 = shufflevector <2 x float> %7, <2 x float> undef, <2 x i32> zeroinitializer
  %9 = fmul <2 x float> %8, %v
  ret <2 x float> %9
}

; Function Attrs: nounwind
define <3 x float> @_Z14fast_normalizeDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = fmul float %1, %1
  %3 = extractelement <3 x float> %v, i32 1
  %4 = fmul float %3, %3
  %5 = fadd float %2, %4
  %6 = extractelement <3 x float> %v, i32 2
  %7 = fmul float %6, %6
  %8 = fadd float %7, %5
  %9 = tail call float @_Z10half_rsqrtf(float %8) #12
  %10 = insertelement <3 x float> undef, float %9, i32 0
  %11 = shufflevector <3 x float> %10, <3 x float> undef, <3 x i32> zeroinitializer
  %12 = fmul <3 x float> %11, %v
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z14fast_normalizeDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = fmul float %1, %1
  %3 = extractelement <4 x float> %v, i32 1
  %4 = fmul float %3, %3
  %5 = fadd float %2, %4
  %6 = extractelement <4 x float> %v, i32 2
  %7 = fmul float %6, %6
  %8 = fadd float %7, %5
  %9 = extractelement <4 x float> %v, i32 3
  %10 = fmul float %9, %9
  %11 = fadd float %10, %8
  %12 = tail call float @_Z10half_rsqrtf(float %11) #12
  %13 = insertelement <4 x float> undef, float %12, i32 0
  %14 = shufflevector <4 x float> %13, <4 x float> undef, <4 x i32> zeroinitializer
  %15 = fmul <4 x float> %14, %v
  ret <4 x float> %15
}

; Function Attrs: nounwind readnone
define float @_Z11native_exp2f(float %v) #7 {
  %1 = fptosi float %v to i32
  %2 = ashr i32 %1, 31
  %3 = add nsw i32 %2, %1
  %4 = sitofp i32 %3 to float
  %5 = fsub float %v, %4
  %6 = shl i32 %3, 23
  %7 = add i32 %6, 1065353216
  %8 = bitcast i32 %7 to float
  %9 = fmul float %5, 0x3FE6353F80000000
  %10 = fmul float %9, %9
  %11 = fadd float %9, 1.000000e+00
  %12 = fmul float %10, 5.000000e-01
  %13 = fadd float %11, %12
  %14 = fmul float %9, %10
  %15 = fmul float %14, 0x3FC5554FC0000000
  %16 = fadd float %13, %15
  %17 = fmul float %10, %10
  %18 = fmul float %17, 0x3FA5555320000000
  %19 = fadd float %18, %16
  %20 = fmul float %8, %19
  ret float %20
}

; Function Attrs: nounwind
define <2 x float> @_Z11native_exp2Dv2_f(<2 x float> %v) #5 {
  %1 = fptosi <2 x float> %v to <2 x i32>
  %2 = ashr <2 x i32> %1, <i32 31, i32 31>
  %3 = add <2 x i32> %1, %2
  %4 = sitofp <2 x i32> %3 to <2 x float>
  %5 = fsub <2 x float> %v, %4
  %6 = add <2 x i32> %3, <i32 127, i32 127>
  %7 = shl <2 x i32> %6, <i32 23, i32 23>
  %8 = bitcast <2 x i32> %7 to <2 x float>
  %9 = fmul <2 x float> %5, <float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %10 = fmul <2 x float> %9, %9
  %11 = fadd <2 x float> %9, <float 1.000000e+00, float 1.000000e+00>
  %12 = fmul <2 x float> %10, <float 5.000000e-01, float 5.000000e-01>
  %13 = fadd <2 x float> %11, %12
  %14 = fmul <2 x float> %9, %10
  %15 = fmul <2 x float> %14, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %16 = fadd <2 x float> %13, %15
  %17 = fmul <2 x float> %10, %10
  %18 = fmul <2 x float> %17, <float 0x3FA5555320000000, float 0x3FA5555320000000>
  %19 = fadd <2 x float> %18, %16
  %20 = fmul <2 x float> %8, %19
  ret <2 x float> %20
}

; Function Attrs: nounwind
define <4 x float> @_Z11native_exp2Dv4_f(<4 x float> %v) #5 {
  %1 = fptosi <4 x float> %v to <4 x i32>
  %2 = ashr <4 x i32> %1, <i32 31, i32 31, i32 31, i32 31>
  %3 = add <4 x i32> %1, %2
  %4 = sitofp <4 x i32> %3 to <4 x float>
  %5 = fsub <4 x float> %v, %4
  %6 = add <4 x i32> %3, <i32 127, i32 127, i32 127, i32 127>
  %7 = shl <4 x i32> %6, <i32 23, i32 23, i32 23, i32 23>
  %8 = bitcast <4 x i32> %7 to <4 x float>
  %9 = fmul <4 x float> %5, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %10 = fmul <4 x float> %9, %9
  %11 = fadd <4 x float> %9, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %12 = fmul <4 x float> %10, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %13 = fadd <4 x float> %11, %12
  %14 = fmul <4 x float> %9, %10
  %15 = fmul <4 x float> %14, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %16 = fadd <4 x float> %13, %15
  %17 = fmul <4 x float> %10, %10
  %18 = fmul <4 x float> %17, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %19 = fadd <4 x float> %18, %16
  %20 = fmul <4 x float> %8, %19
  ret <4 x float> %20
}

; Function Attrs: nounwind
define <3 x float> @_Z11native_exp2Dv3_f(<3 x float> %v) #5 {
  %1 = shufflevector <3 x float> %v, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %2 = shufflevector <4 x float> <float undef, float undef, float undef, float 1.000000e+00>, <4 x float> %1, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  %3 = fptosi <4 x float> %2 to <4 x i32>
  %4 = ashr <4 x i32> %3, <i32 31, i32 31, i32 31, i32 31>
  %5 = add <4 x i32> %3, %4
  %6 = sitofp <4 x i32> %5 to <4 x float>
  %7 = fsub <4 x float> %2, %6
  %8 = add <4 x i32> %5, <i32 127, i32 127, i32 127, i32 127>
  %9 = shl <4 x i32> %8, <i32 23, i32 23, i32 23, i32 23>
  %10 = bitcast <4 x i32> %9 to <4 x float>
  %11 = fmul <4 x float> %7, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %12 = fmul <4 x float> %11, %11
  %13 = fadd <4 x float> %11, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %14 = fmul <4 x float> %12, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %15 = fadd <4 x float> %13, %14
  %16 = fmul <4 x float> %11, %12
  %17 = fmul <4 x float> %16, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %18 = fadd <4 x float> %15, %17
  %19 = fmul <4 x float> %12, %12
  %20 = fmul <4 x float> %19, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %21 = fadd <4 x float> %20, %18
  %22 = fmul <4 x float> %10, %21
  %23 = shufflevector <4 x float> %22, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %23
}

; Function Attrs: nounwind readnone
define float @_Z10native_expf(float %v) #7 {
  %1 = fmul float %v, 0x3FF7154760000000
  %2 = fptosi float %1 to i32
  %3 = ashr i32 %2, 31
  %4 = add nsw i32 %3, %2
  %5 = sitofp i32 %4 to float
  %6 = fsub float %1, %5
  %7 = shl i32 %4, 23
  %8 = add i32 %7, 1065353216
  %9 = bitcast i32 %8 to float
  %10 = fmul float %6, 0x3FE6353F80000000
  %11 = fmul float %10, %10
  %12 = fadd float %10, 1.000000e+00
  %13 = fmul float %11, 5.000000e-01
  %14 = fadd float %12, %13
  %15 = fmul float %10, %11
  %16 = fmul float %15, 0x3FC5554FC0000000
  %17 = fadd float %14, %16
  %18 = fmul float %11, %11
  %19 = fmul float %18, 0x3FA5555320000000
  %20 = fadd float %19, %17
  %21 = fmul float %9, %20
  ret float %21
}

; Function Attrs: nounwind
define <2 x float> @_Z10native_expDv2_f(<2 x float> %v) #5 {
  %1 = fmul <2 x float> %v, <float 0x3FF7154760000000, float 0x3FF7154760000000>
  %2 = fptosi <2 x float> %1 to <2 x i32>
  %3 = ashr <2 x i32> %2, <i32 31, i32 31>
  %4 = add <2 x i32> %2, %3
  %5 = sitofp <2 x i32> %4 to <2 x float>
  %6 = fsub <2 x float> %1, %5
  %7 = add <2 x i32> %4, <i32 127, i32 127>
  %8 = shl <2 x i32> %7, <i32 23, i32 23>
  %9 = bitcast <2 x i32> %8 to <2 x float>
  %10 = fmul <2 x float> %6, <float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %11 = fmul <2 x float> %10, %10
  %12 = fadd <2 x float> %10, <float 1.000000e+00, float 1.000000e+00>
  %13 = fmul <2 x float> %11, <float 5.000000e-01, float 5.000000e-01>
  %14 = fadd <2 x float> %12, %13
  %15 = fmul <2 x float> %10, %11
  %16 = fmul <2 x float> %15, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %17 = fadd <2 x float> %14, %16
  %18 = fmul <2 x float> %11, %11
  %19 = fmul <2 x float> %18, <float 0x3FA5555320000000, float 0x3FA5555320000000>
  %20 = fadd <2 x float> %19, %17
  %21 = fmul <2 x float> %9, %20
  ret <2 x float> %21
}

; Function Attrs: nounwind
define <3 x float> @_Z10native_expDv3_f(<3 x float> %v) #5 {
  %1 = fmul <3 x float> %v, <float 0x3FF7154760000000, float 0x3FF7154760000000, float 0x3FF7154760000000>
  %2 = shufflevector <3 x float> %1, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = shufflevector <4 x float> <float undef, float undef, float undef, float 1.000000e+00>, <4 x float> %2, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  %4 = fptosi <4 x float> %3 to <4 x i32>
  %5 = ashr <4 x i32> %4, <i32 31, i32 31, i32 31, i32 31>
  %6 = add <4 x i32> %4, %5
  %7 = sitofp <4 x i32> %6 to <4 x float>
  %8 = fsub <4 x float> %3, %7
  %9 = add <4 x i32> %6, <i32 127, i32 127, i32 127, i32 127>
  %10 = shl <4 x i32> %9, <i32 23, i32 23, i32 23, i32 23>
  %11 = bitcast <4 x i32> %10 to <4 x float>
  %12 = fmul <4 x float> %8, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %13 = fmul <4 x float> %12, %12
  %14 = fadd <4 x float> %12, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %15 = fmul <4 x float> %13, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %16 = fadd <4 x float> %14, %15
  %17 = fmul <4 x float> %12, %13
  %18 = fmul <4 x float> %17, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %19 = fadd <4 x float> %16, %18
  %20 = fmul <4 x float> %13, %13
  %21 = fmul <4 x float> %20, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %22 = fadd <4 x float> %21, %19
  %23 = fmul <4 x float> %11, %22
  %24 = shufflevector <4 x float> %23, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %24
}

; Function Attrs: nounwind
define <4 x float> @_Z10native_expDv4_f(<4 x float> %v) #5 {
  %1 = fmul <4 x float> %v, <float 0x3FF7154760000000, float 0x3FF7154760000000, float 0x3FF7154760000000, float 0x3FF7154760000000>
  %2 = fptosi <4 x float> %1 to <4 x i32>
  %3 = ashr <4 x i32> %2, <i32 31, i32 31, i32 31, i32 31>
  %4 = add <4 x i32> %2, %3
  %5 = sitofp <4 x i32> %4 to <4 x float>
  %6 = fsub <4 x float> %1, %5
  %7 = add <4 x i32> %4, <i32 127, i32 127, i32 127, i32 127>
  %8 = shl <4 x i32> %7, <i32 23, i32 23, i32 23, i32 23>
  %9 = bitcast <4 x i32> %8 to <4 x float>
  %10 = fmul <4 x float> %6, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %11 = fmul <4 x float> %10, %10
  %12 = fadd <4 x float> %10, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %13 = fmul <4 x float> %11, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %14 = fadd <4 x float> %12, %13
  %15 = fmul <4 x float> %10, %11
  %16 = fmul <4 x float> %15, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %17 = fadd <4 x float> %14, %16
  %18 = fmul <4 x float> %11, %11
  %19 = fmul <4 x float> %18, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %20 = fadd <4 x float> %19, %17
  %21 = fmul <4 x float> %9, %20
  ret <4 x float> %21
}

; Function Attrs: nounwind readnone
define float @_Z12native_exp10f(float %v) #7 {
  %1 = fmul float %v, 0x400A934F00000000
  %2 = fptosi float %1 to i32
  %3 = ashr i32 %2, 31
  %4 = add nsw i32 %3, %2
  %5 = sitofp i32 %4 to float
  %6 = fsub float %1, %5
  %7 = shl i32 %4, 23
  %8 = add i32 %7, 1065353216
  %9 = bitcast i32 %8 to float
  %10 = fmul float %6, 0x3FE6353F80000000
  %11 = fmul float %10, %10
  %12 = fadd float %10, 1.000000e+00
  %13 = fmul float %11, 5.000000e-01
  %14 = fadd float %12, %13
  %15 = fmul float %10, %11
  %16 = fmul float %15, 0x3FC5554FC0000000
  %17 = fadd float %14, %16
  %18 = fmul float %11, %11
  %19 = fmul float %18, 0x3FA5555320000000
  %20 = fadd float %19, %17
  %21 = fmul float %9, %20
  ret float %21
}

; Function Attrs: nounwind
define <2 x float> @_Z12native_exp10Dv2_f(<2 x float> %v) #5 {
  %1 = fmul <2 x float> %v, <float 0x400A934F00000000, float 0x400A934F00000000>
  %2 = fptosi <2 x float> %1 to <2 x i32>
  %3 = ashr <2 x i32> %2, <i32 31, i32 31>
  %4 = add <2 x i32> %2, %3
  %5 = sitofp <2 x i32> %4 to <2 x float>
  %6 = fsub <2 x float> %1, %5
  %7 = add <2 x i32> %4, <i32 127, i32 127>
  %8 = shl <2 x i32> %7, <i32 23, i32 23>
  %9 = bitcast <2 x i32> %8 to <2 x float>
  %10 = fmul <2 x float> %6, <float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %11 = fmul <2 x float> %10, %10
  %12 = fadd <2 x float> %10, <float 1.000000e+00, float 1.000000e+00>
  %13 = fmul <2 x float> %11, <float 5.000000e-01, float 5.000000e-01>
  %14 = fadd <2 x float> %12, %13
  %15 = fmul <2 x float> %10, %11
  %16 = fmul <2 x float> %15, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %17 = fadd <2 x float> %14, %16
  %18 = fmul <2 x float> %11, %11
  %19 = fmul <2 x float> %18, <float 0x3FA5555320000000, float 0x3FA5555320000000>
  %20 = fadd <2 x float> %19, %17
  %21 = fmul <2 x float> %9, %20
  ret <2 x float> %21
}

; Function Attrs: nounwind
define <3 x float> @_Z12native_exp10Dv3_f(<3 x float> %v) #5 {
  %1 = fmul <3 x float> %v, <float 0x400A934F00000000, float 0x400A934F00000000, float 0x400A934F00000000>
  %2 = shufflevector <3 x float> %1, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = shufflevector <4 x float> <float undef, float undef, float undef, float 1.000000e+00>, <4 x float> %2, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  %4 = fptosi <4 x float> %3 to <4 x i32>
  %5 = ashr <4 x i32> %4, <i32 31, i32 31, i32 31, i32 31>
  %6 = add <4 x i32> %4, %5
  %7 = sitofp <4 x i32> %6 to <4 x float>
  %8 = fsub <4 x float> %3, %7
  %9 = add <4 x i32> %6, <i32 127, i32 127, i32 127, i32 127>
  %10 = shl <4 x i32> %9, <i32 23, i32 23, i32 23, i32 23>
  %11 = bitcast <4 x i32> %10 to <4 x float>
  %12 = fmul <4 x float> %8, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %13 = fmul <4 x float> %12, %12
  %14 = fadd <4 x float> %12, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %15 = fmul <4 x float> %13, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %16 = fadd <4 x float> %14, %15
  %17 = fmul <4 x float> %12, %13
  %18 = fmul <4 x float> %17, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %19 = fadd <4 x float> %16, %18
  %20 = fmul <4 x float> %13, %13
  %21 = fmul <4 x float> %20, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %22 = fadd <4 x float> %21, %19
  %23 = fmul <4 x float> %11, %22
  %24 = shufflevector <4 x float> %23, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %24
}

; Function Attrs: nounwind
define <4 x float> @_Z12native_exp10Dv4_f(<4 x float> %v) #5 {
  %1 = fmul <4 x float> %v, <float 0x400A934F00000000, float 0x400A934F00000000, float 0x400A934F00000000, float 0x400A934F00000000>
  %2 = fptosi <4 x float> %1 to <4 x i32>
  %3 = ashr <4 x i32> %2, <i32 31, i32 31, i32 31, i32 31>
  %4 = add <4 x i32> %2, %3
  %5 = sitofp <4 x i32> %4 to <4 x float>
  %6 = fsub <4 x float> %1, %5
  %7 = add <4 x i32> %4, <i32 127, i32 127, i32 127, i32 127>
  %8 = shl <4 x i32> %7, <i32 23, i32 23, i32 23, i32 23>
  %9 = bitcast <4 x i32> %8 to <4 x float>
  %10 = fmul <4 x float> %6, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %11 = fmul <4 x float> %10, %10
  %12 = fadd <4 x float> %10, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %13 = fmul <4 x float> %11, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %14 = fadd <4 x float> %12, %13
  %15 = fmul <4 x float> %10, %11
  %16 = fmul <4 x float> %15, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %17 = fadd <4 x float> %14, %16
  %18 = fmul <4 x float> %11, %11
  %19 = fmul <4 x float> %18, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %20 = fadd <4 x float> %19, %17
  %21 = fmul <4 x float> %9, %20
  ret <4 x float> %21
}

; Function Attrs: nounwind readnone
define float @_Z11native_log2f(float %v) #7 {
  %1 = bitcast float %v to i32
  %2 = lshr i32 %1, 23
  %3 = and i32 %2, 255
  %4 = and i32 %1, 8388607
  %5 = or i32 %4, 1065353216
  %6 = bitcast i32 %5 to float
  %7 = fadd float %6, -1.500000e+00
  %8 = fmul float %7, %7
  %9 = fmul float %7, 0x3FE5555560000000
  %10 = fadd float %9, 0x3FD9F323E0000000
  %11 = fmul float %8, 0x3FCC71C720000000
  %12 = fsub float %10, %11
  %13 = fmul float %7, 0x3FB948B100000000
  %14 = fmul float %13, %8
  %15 = fadd float %14, %12
  %16 = fmul float %8, 0x3FA948B100000000
  %17 = fmul float %8, %16
  %18 = fsub float %15, %17
  %19 = fmul float %7, 0x3F9AF83440000000
  %20 = fmul float %19, %8
  %21 = fmul float %8, %20
  %22 = fadd float %21, %18
  %23 = fmul float %8, 0x3F8DF75680000000
  %24 = fmul float %8, %23
  %25 = fmul float %8, %24
  %26 = fsub float %22, %25
  %27 = fmul float %26, 0x3FF7154760000000
  %28 = add nsw i32 %3, -127
  %29 = sitofp i32 %28 to float
  %30 = fadd float %29, %27
  ret float %30
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z11native_log2Dv2_f(<2 x float> %v) #7 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <2 x float> undef, float %31, i32 0
  %33 = extractelement <2 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <2 x float> %32, float %63, i32 1
  ret <2 x float> %64
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z11native_log2Dv3_f(<3 x float> %v) #7 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <3 x float> undef, float %31, i32 0
  %33 = extractelement <3 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <3 x float> %32, float %63, i32 1
  %65 = extractelement <3 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <3 x float> %64, float %95, i32 2
  ret <3 x float> %96
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z11native_log2Dv4_f(<4 x float> %v) #7 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <4 x float> undef, float %31, i32 0
  %33 = extractelement <4 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <4 x float> %32, float %63, i32 1
  %65 = extractelement <4 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <4 x float> %64, float %95, i32 2
  %97 = extractelement <4 x float> %v, i32 3
  %98 = bitcast float %97 to i32
  %99 = lshr i32 %98, 23
  %100 = and i32 %99, 255
  %101 = and i32 %98, 8388607
  %102 = or i32 %101, 1065353216
  %103 = bitcast i32 %102 to float
  %104 = fadd float %103, -1.500000e+00
  %105 = fmul float %104, %104
  %106 = fmul float %104, 0x3FE5555560000000
  %107 = fadd float %106, 0x3FD9F323E0000000
  %108 = fmul float %105, 0x3FCC71C720000000
  %109 = fsub float %107, %108
  %110 = fmul float %104, 0x3FB948B100000000
  %111 = fmul float %110, %105
  %112 = fadd float %111, %109
  %113 = fmul float %105, 0x3FA948B100000000
  %114 = fmul float %105, %113
  %115 = fsub float %112, %114
  %116 = fmul float %104, 0x3F9AF83440000000
  %117 = fmul float %116, %105
  %118 = fmul float %105, %117
  %119 = fadd float %118, %115
  %120 = fmul float %105, 0x3F8DF75680000000
  %121 = fmul float %105, %120
  %122 = fmul float %105, %121
  %123 = fsub float %119, %122
  %124 = fmul float %123, 0x3FF7154760000000
  %125 = add nsw i32 %100, -127
  %126 = sitofp i32 %125 to float
  %127 = fadd float %126, %124
  %128 = insertelement <4 x float> %96, float %127, i32 3
  ret <4 x float> %128
}

; Function Attrs: nounwind readnone
define float @_Z10native_logf(float %v) #7 {
  %1 = bitcast float %v to i32
  %2 = lshr i32 %1, 23
  %3 = and i32 %2, 255
  %4 = and i32 %1, 8388607
  %5 = or i32 %4, 1065353216
  %6 = bitcast i32 %5 to float
  %7 = fadd float %6, -1.500000e+00
  %8 = fmul float %7, %7
  %9 = fmul float %7, 0x3FE5555560000000
  %10 = fadd float %9, 0x3FD9F323E0000000
  %11 = fmul float %8, 0x3FCC71C720000000
  %12 = fsub float %10, %11
  %13 = fmul float %7, 0x3FB948B100000000
  %14 = fmul float %13, %8
  %15 = fadd float %14, %12
  %16 = fmul float %8, 0x3FA948B100000000
  %17 = fmul float %8, %16
  %18 = fsub float %15, %17
  %19 = fmul float %7, 0x3F9AF83440000000
  %20 = fmul float %19, %8
  %21 = fmul float %8, %20
  %22 = fadd float %21, %18
  %23 = fmul float %8, 0x3F8DF75680000000
  %24 = fmul float %8, %23
  %25 = fmul float %8, %24
  %26 = fsub float %22, %25
  %27 = fmul float %26, 0x3FF7154760000000
  %28 = add nsw i32 %3, -127
  %29 = sitofp i32 %28 to float
  %30 = fadd float %29, %27
  %31 = fmul float %30, 0x3FE62E4300000000
  ret float %31
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z10native_logDv2_f(<2 x float> %v) #7 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <2 x float> undef, float %31, i32 0
  %33 = extractelement <2 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <2 x float> %32, float %63, i32 1
  %65 = fmul <2 x float> %64, <float 0x3FE62E4300000000, float 0x3FE62E4300000000>
  ret <2 x float> %65
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z10native_logDv3_f(<3 x float> %v) #7 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <3 x float> undef, float %31, i32 0
  %33 = extractelement <3 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <3 x float> %32, float %63, i32 1
  %65 = extractelement <3 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <3 x float> %64, float %95, i32 2
  %97 = fmul <3 x float> %96, <float 0x3FE62E4300000000, float 0x3FE62E4300000000, float 0x3FE62E4300000000>
  ret <3 x float> %97
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z10native_logDv4_f(<4 x float> %v) #7 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <4 x float> undef, float %31, i32 0
  %33 = extractelement <4 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <4 x float> %32, float %63, i32 1
  %65 = extractelement <4 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <4 x float> %64, float %95, i32 2
  %97 = extractelement <4 x float> %v, i32 3
  %98 = bitcast float %97 to i32
  %99 = lshr i32 %98, 23
  %100 = and i32 %99, 255
  %101 = and i32 %98, 8388607
  %102 = or i32 %101, 1065353216
  %103 = bitcast i32 %102 to float
  %104 = fadd float %103, -1.500000e+00
  %105 = fmul float %104, %104
  %106 = fmul float %104, 0x3FE5555560000000
  %107 = fadd float %106, 0x3FD9F323E0000000
  %108 = fmul float %105, 0x3FCC71C720000000
  %109 = fsub float %107, %108
  %110 = fmul float %104, 0x3FB948B100000000
  %111 = fmul float %110, %105
  %112 = fadd float %111, %109
  %113 = fmul float %105, 0x3FA948B100000000
  %114 = fmul float %105, %113
  %115 = fsub float %112, %114
  %116 = fmul float %104, 0x3F9AF83440000000
  %117 = fmul float %116, %105
  %118 = fmul float %105, %117
  %119 = fadd float %118, %115
  %120 = fmul float %105, 0x3F8DF75680000000
  %121 = fmul float %105, %120
  %122 = fmul float %105, %121
  %123 = fsub float %119, %122
  %124 = fmul float %123, 0x3FF7154760000000
  %125 = add nsw i32 %100, -127
  %126 = sitofp i32 %125 to float
  %127 = fadd float %126, %124
  %128 = insertelement <4 x float> %96, float %127, i32 3
  %129 = fmul <4 x float> %128, <float 0x3FE62E4300000000, float 0x3FE62E4300000000, float 0x3FE62E4300000000, float 0x3FE62E4300000000>
  ret <4 x float> %129
}

; Function Attrs: nounwind readnone
define float @_Z12native_log10f(float %v) #7 {
  %1 = bitcast float %v to i32
  %2 = lshr i32 %1, 23
  %3 = and i32 %2, 255
  %4 = and i32 %1, 8388607
  %5 = or i32 %4, 1065353216
  %6 = bitcast i32 %5 to float
  %7 = fadd float %6, -1.500000e+00
  %8 = fmul float %7, %7
  %9 = fmul float %7, 0x3FE5555560000000
  %10 = fadd float %9, 0x3FD9F323E0000000
  %11 = fmul float %8, 0x3FCC71C720000000
  %12 = fsub float %10, %11
  %13 = fmul float %7, 0x3FB948B100000000
  %14 = fmul float %13, %8
  %15 = fadd float %14, %12
  %16 = fmul float %8, 0x3FA948B100000000
  %17 = fmul float %8, %16
  %18 = fsub float %15, %17
  %19 = fmul float %7, 0x3F9AF83440000000
  %20 = fmul float %19, %8
  %21 = fmul float %8, %20
  %22 = fadd float %21, %18
  %23 = fmul float %8, 0x3F8DF75680000000
  %24 = fmul float %8, %23
  %25 = fmul float %8, %24
  %26 = fsub float %22, %25
  %27 = fmul float %26, 0x3FF7154760000000
  %28 = add nsw i32 %3, -127
  %29 = sitofp i32 %28 to float
  %30 = fadd float %29, %27
  %31 = fmul float %30, 0x3FD3441360000000
  ret float %31
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z12native_log10Dv2_f(<2 x float> %v) #7 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <2 x float> undef, float %31, i32 0
  %33 = extractelement <2 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <2 x float> %32, float %63, i32 1
  %65 = fmul <2 x float> %64, <float 0x3FD3441360000000, float 0x3FD3441360000000>
  ret <2 x float> %65
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z12native_log10Dv3_f(<3 x float> %v) #7 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <3 x float> undef, float %31, i32 0
  %33 = extractelement <3 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <3 x float> %32, float %63, i32 1
  %65 = extractelement <3 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <3 x float> %64, float %95, i32 2
  %97 = fmul <3 x float> %96, <float 0x3FD3441360000000, float 0x3FD3441360000000, float 0x3FD3441360000000>
  ret <3 x float> %97
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z12native_log10Dv4_f(<4 x float> %v) #7 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <4 x float> undef, float %31, i32 0
  %33 = extractelement <4 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <4 x float> %32, float %63, i32 1
  %65 = extractelement <4 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <4 x float> %64, float %95, i32 2
  %97 = extractelement <4 x float> %v, i32 3
  %98 = bitcast float %97 to i32
  %99 = lshr i32 %98, 23
  %100 = and i32 %99, 255
  %101 = and i32 %98, 8388607
  %102 = or i32 %101, 1065353216
  %103 = bitcast i32 %102 to float
  %104 = fadd float %103, -1.500000e+00
  %105 = fmul float %104, %104
  %106 = fmul float %104, 0x3FE5555560000000
  %107 = fadd float %106, 0x3FD9F323E0000000
  %108 = fmul float %105, 0x3FCC71C720000000
  %109 = fsub float %107, %108
  %110 = fmul float %104, 0x3FB948B100000000
  %111 = fmul float %110, %105
  %112 = fadd float %111, %109
  %113 = fmul float %105, 0x3FA948B100000000
  %114 = fmul float %105, %113
  %115 = fsub float %112, %114
  %116 = fmul float %104, 0x3F9AF83440000000
  %117 = fmul float %116, %105
  %118 = fmul float %105, %117
  %119 = fadd float %118, %115
  %120 = fmul float %105, 0x3F8DF75680000000
  %121 = fmul float %105, %120
  %122 = fmul float %105, %121
  %123 = fsub float %119, %122
  %124 = fmul float %123, 0x3FF7154760000000
  %125 = add nsw i32 %100, -127
  %126 = sitofp i32 %125 to float
  %127 = fadd float %126, %124
  %128 = insertelement <4 x float> %96, float %127, i32 3
  %129 = fmul <4 x float> %128, <float 0x3FD3441360000000, float 0x3FD3441360000000, float 0x3FD3441360000000, float 0x3FD3441360000000>
  ret <4 x float> %129
}

; Function Attrs: nounwind
define float @_Z11native_powrff(float %v, float %y) #5 {
  %1 = bitcast float %v to i32
  %2 = lshr i32 %1, 23
  %3 = and i32 %2, 255
  %4 = and i32 %1, 8388607
  %5 = or i32 %4, 1065353216
  %6 = bitcast i32 %5 to float
  %7 = fadd float %6, -1.500000e+00
  %8 = fmul float %7, %7
  %9 = fmul float %7, 0x3FE5555560000000
  %10 = fadd float %9, 0x3FD9F323E0000000
  %11 = fmul float %8, 0x3FCC71C720000000
  %12 = fsub float %10, %11
  %13 = fmul float %7, 0x3FB948B100000000
  %14 = fmul float %13, %8
  %15 = fadd float %14, %12
  %16 = fmul float %8, 0x3FA948B100000000
  %17 = fmul float %8, %16
  %18 = fsub float %15, %17
  %19 = fmul float %7, 0x3F9AF83440000000
  %20 = fmul float %19, %8
  %21 = fmul float %8, %20
  %22 = fadd float %21, %18
  %23 = fmul float %8, 0x3F8DF75680000000
  %24 = fmul float %8, %23
  %25 = fmul float %8, %24
  %26 = fsub float %22, %25
  %27 = fmul float %26, 0x3FF7154760000000
  %28 = add nsw i32 %3, -127
  %29 = sitofp i32 %28 to float
  %30 = fadd float %29, %27
  %31 = fcmp ogt float %30, -1.250000e+02
  %32 = select i1 %31, float %30, float -1.250000e+02
  %33 = fmul float %32, %y
  %34 = fptosi float %33 to i32
  %35 = ashr i32 %34, 31
  %36 = add nsw i32 %35, %34
  %37 = sitofp i32 %36 to float
  %38 = fsub float %33, %37
  %39 = shl i32 %36, 23
  %40 = add i32 %39, 1065353216
  %41 = bitcast i32 %40 to float
  %42 = fmul float %38, 0x3FE6353F80000000
  %43 = fmul float %42, %42
  %44 = fadd float %42, 1.000000e+00
  %45 = fmul float %43, 5.000000e-01
  %46 = fadd float %44, %45
  %47 = fmul float %42, %43
  %48 = fmul float %47, 0x3FC5554FC0000000
  %49 = fadd float %46, %48
  %50 = fmul float %43, %43
  %51 = fmul float %50, 0x3FA5555320000000
  %52 = fadd float %51, %49
  %53 = fmul float %41, %52
  ret float %53
}

; Function Attrs: nounwind
define <2 x float> @_Z11native_powrDv2_fS_(<2 x float> %v, <2 x float> %y) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <2 x float> undef, float %31, i32 0
  %33 = extractelement <2 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <2 x float> %32, float %63, i32 1
  %65 = extractelement <2 x float> %64, i32 0
  %66 = fcmp ogt float %65, -1.250000e+02
  %.v2.i = select i1 %66, float %65, float -1.250000e+02
  %67 = insertelement <2 x float> undef, float %.v2.i, i32 0
  %68 = extractelement <2 x float> %64, i32 1
  %69 = fcmp ogt float %68, -1.250000e+02
  %70 = select i1 %69, float %68, float -1.250000e+02
  %71 = insertelement <2 x float> %67, float %70, i32 1
  %72 = fmul <2 x float> %71, %y
  %73 = fptosi <2 x float> %72 to <2 x i32>
  %74 = ashr <2 x i32> %73, <i32 31, i32 31>
  %75 = add <2 x i32> %73, %74
  %76 = sitofp <2 x i32> %75 to <2 x float>
  %77 = fsub <2 x float> %72, %76
  %78 = add <2 x i32> %75, <i32 127, i32 127>
  %79 = shl <2 x i32> %78, <i32 23, i32 23>
  %80 = bitcast <2 x i32> %79 to <2 x float>
  %81 = fmul <2 x float> %77, <float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %82 = fmul <2 x float> %81, %81
  %83 = fadd <2 x float> %81, <float 1.000000e+00, float 1.000000e+00>
  %84 = fmul <2 x float> %82, <float 5.000000e-01, float 5.000000e-01>
  %85 = fadd <2 x float> %83, %84
  %86 = fmul <2 x float> %81, %82
  %87 = fmul <2 x float> %86, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %88 = fadd <2 x float> %85, %87
  %89 = fmul <2 x float> %82, %82
  %90 = fmul <2 x float> %89, <float 0x3FA5555320000000, float 0x3FA5555320000000>
  %91 = fadd <2 x float> %90, %88
  %92 = fmul <2 x float> %80, %91
  ret <2 x float> %92
}

; Function Attrs: nounwind
define <3 x float> @_Z11native_powrDv3_fS_(<3 x float> %v, <3 x float> %y) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <3 x float> undef, float %31, i32 0
  %33 = extractelement <3 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <3 x float> %32, float %63, i32 1
  %65 = extractelement <3 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <3 x float> %64, float %95, i32 2
  %97 = extractelement <3 x float> %96, i32 0
  %98 = fcmp ogt float %97, -1.250000e+02
  %.v2.i = select i1 %98, float %97, float -1.250000e+02
  %99 = insertelement <3 x float> undef, float %.v2.i, i32 0
  %100 = extractelement <3 x float> %96, i32 1
  %101 = fcmp ogt float %100, -1.250000e+02
  %102 = select i1 %101, float %100, float -1.250000e+02
  %103 = insertelement <3 x float> %99, float %102, i32 1
  %104 = extractelement <3 x float> %96, i32 2
  %105 = fcmp ogt float %104, -1.250000e+02
  %.v21.i = select i1 %105, float %104, float -1.250000e+02
  %106 = insertelement <3 x float> %103, float %.v21.i, i32 2
  %107 = fmul <3 x float> %106, %y
  %108 = shufflevector <3 x float> %107, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %109 = shufflevector <4 x float> <float undef, float undef, float undef, float 1.000000e+00>, <4 x float> %108, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  %110 = fptosi <4 x float> %109 to <4 x i32>
  %111 = ashr <4 x i32> %110, <i32 31, i32 31, i32 31, i32 31>
  %112 = add <4 x i32> %110, %111
  %113 = sitofp <4 x i32> %112 to <4 x float>
  %114 = fsub <4 x float> %109, %113
  %115 = add <4 x i32> %112, <i32 127, i32 127, i32 127, i32 127>
  %116 = shl <4 x i32> %115, <i32 23, i32 23, i32 23, i32 23>
  %117 = bitcast <4 x i32> %116 to <4 x float>
  %118 = fmul <4 x float> %114, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %119 = fmul <4 x float> %118, %118
  %120 = fadd <4 x float> %118, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %121 = fmul <4 x float> %119, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %122 = fadd <4 x float> %120, %121
  %123 = fmul <4 x float> %118, %119
  %124 = fmul <4 x float> %123, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %125 = fadd <4 x float> %122, %124
  %126 = fmul <4 x float> %119, %119
  %127 = fmul <4 x float> %126, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %128 = fadd <4 x float> %127, %125
  %129 = fmul <4 x float> %117, %128
  %130 = shufflevector <4 x float> %129, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %130
}

; Function Attrs: nounwind
define <4 x float> @_Z11native_powrDv4_fS_(<4 x float> %v, <4 x float> %y) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = bitcast float %1 to i32
  %3 = lshr i32 %2, 23
  %4 = and i32 %3, 255
  %5 = and i32 %2, 8388607
  %6 = or i32 %5, 1065353216
  %7 = bitcast i32 %6 to float
  %8 = fadd float %7, -1.500000e+00
  %9 = fmul float %8, %8
  %10 = fmul float %8, 0x3FE5555560000000
  %11 = fadd float %10, 0x3FD9F323E0000000
  %12 = fmul float %9, 0x3FCC71C720000000
  %13 = fsub float %11, %12
  %14 = fmul float %8, 0x3FB948B100000000
  %15 = fmul float %14, %9
  %16 = fadd float %15, %13
  %17 = fmul float %9, 0x3FA948B100000000
  %18 = fmul float %9, %17
  %19 = fsub float %16, %18
  %20 = fmul float %8, 0x3F9AF83440000000
  %21 = fmul float %20, %9
  %22 = fmul float %9, %21
  %23 = fadd float %22, %19
  %24 = fmul float %9, 0x3F8DF75680000000
  %25 = fmul float %9, %24
  %26 = fmul float %9, %25
  %27 = fsub float %23, %26
  %28 = fmul float %27, 0x3FF7154760000000
  %29 = add nsw i32 %4, -127
  %30 = sitofp i32 %29 to float
  %31 = fadd float %30, %28
  %32 = insertelement <4 x float> undef, float %31, i32 0
  %33 = extractelement <4 x float> %v, i32 1
  %34 = bitcast float %33 to i32
  %35 = lshr i32 %34, 23
  %36 = and i32 %35, 255
  %37 = and i32 %34, 8388607
  %38 = or i32 %37, 1065353216
  %39 = bitcast i32 %38 to float
  %40 = fadd float %39, -1.500000e+00
  %41 = fmul float %40, %40
  %42 = fmul float %40, 0x3FE5555560000000
  %43 = fadd float %42, 0x3FD9F323E0000000
  %44 = fmul float %41, 0x3FCC71C720000000
  %45 = fsub float %43, %44
  %46 = fmul float %40, 0x3FB948B100000000
  %47 = fmul float %46, %41
  %48 = fadd float %47, %45
  %49 = fmul float %41, 0x3FA948B100000000
  %50 = fmul float %41, %49
  %51 = fsub float %48, %50
  %52 = fmul float %40, 0x3F9AF83440000000
  %53 = fmul float %52, %41
  %54 = fmul float %41, %53
  %55 = fadd float %54, %51
  %56 = fmul float %41, 0x3F8DF75680000000
  %57 = fmul float %41, %56
  %58 = fmul float %41, %57
  %59 = fsub float %55, %58
  %60 = fmul float %59, 0x3FF7154760000000
  %61 = add nsw i32 %36, -127
  %62 = sitofp i32 %61 to float
  %63 = fadd float %62, %60
  %64 = insertelement <4 x float> %32, float %63, i32 1
  %65 = extractelement <4 x float> %v, i32 2
  %66 = bitcast float %65 to i32
  %67 = lshr i32 %66, 23
  %68 = and i32 %67, 255
  %69 = and i32 %66, 8388607
  %70 = or i32 %69, 1065353216
  %71 = bitcast i32 %70 to float
  %72 = fadd float %71, -1.500000e+00
  %73 = fmul float %72, %72
  %74 = fmul float %72, 0x3FE5555560000000
  %75 = fadd float %74, 0x3FD9F323E0000000
  %76 = fmul float %73, 0x3FCC71C720000000
  %77 = fsub float %75, %76
  %78 = fmul float %72, 0x3FB948B100000000
  %79 = fmul float %78, %73
  %80 = fadd float %79, %77
  %81 = fmul float %73, 0x3FA948B100000000
  %82 = fmul float %73, %81
  %83 = fsub float %80, %82
  %84 = fmul float %72, 0x3F9AF83440000000
  %85 = fmul float %84, %73
  %86 = fmul float %73, %85
  %87 = fadd float %86, %83
  %88 = fmul float %73, 0x3F8DF75680000000
  %89 = fmul float %73, %88
  %90 = fmul float %73, %89
  %91 = fsub float %87, %90
  %92 = fmul float %91, 0x3FF7154760000000
  %93 = add nsw i32 %68, -127
  %94 = sitofp i32 %93 to float
  %95 = fadd float %94, %92
  %96 = insertelement <4 x float> %64, float %95, i32 2
  %97 = extractelement <4 x float> %v, i32 3
  %98 = bitcast float %97 to i32
  %99 = lshr i32 %98, 23
  %100 = and i32 %99, 255
  %101 = and i32 %98, 8388607
  %102 = or i32 %101, 1065353216
  %103 = bitcast i32 %102 to float
  %104 = fadd float %103, -1.500000e+00
  %105 = fmul float %104, %104
  %106 = fmul float %104, 0x3FE5555560000000
  %107 = fadd float %106, 0x3FD9F323E0000000
  %108 = fmul float %105, 0x3FCC71C720000000
  %109 = fsub float %107, %108
  %110 = fmul float %104, 0x3FB948B100000000
  %111 = fmul float %110, %105
  %112 = fadd float %111, %109
  %113 = fmul float %105, 0x3FA948B100000000
  %114 = fmul float %105, %113
  %115 = fsub float %112, %114
  %116 = fmul float %104, 0x3F9AF83440000000
  %117 = fmul float %116, %105
  %118 = fmul float %105, %117
  %119 = fadd float %118, %115
  %120 = fmul float %105, 0x3F8DF75680000000
  %121 = fmul float %105, %120
  %122 = fmul float %105, %121
  %123 = fsub float %119, %122
  %124 = fmul float %123, 0x3FF7154760000000
  %125 = add nsw i32 %100, -127
  %126 = sitofp i32 %125 to float
  %127 = fadd float %126, %124
  %128 = insertelement <4 x float> %96, float %127, i32 3
  %129 = extractelement <4 x float> %128, i32 0
  %130 = fcmp ogt float %129, -1.250000e+02
  %.v2.i = select i1 %130, float %129, float -1.250000e+02
  %131 = insertelement <4 x float> undef, float %.v2.i, i32 0
  %132 = extractelement <4 x float> %128, i32 1
  %133 = fcmp ogt float %132, -1.250000e+02
  %134 = select i1 %133, float %132, float -1.250000e+02
  %135 = insertelement <4 x float> %131, float %134, i32 1
  %136 = extractelement <4 x float> %128, i32 2
  %137 = fcmp ogt float %136, -1.250000e+02
  %.v21.i = select i1 %137, float %136, float -1.250000e+02
  %138 = insertelement <4 x float> %135, float %.v21.i, i32 2
  %139 = extractelement <4 x float> %128, i32 3
  %140 = fcmp ogt float %139, -1.250000e+02
  %141 = select i1 %140, float %139, float -1.250000e+02
  %142 = insertelement <4 x float> %138, float %141, i32 3
  %143 = fmul <4 x float> %142, %y
  %144 = fptosi <4 x float> %143 to <4 x i32>
  %145 = ashr <4 x i32> %144, <i32 31, i32 31, i32 31, i32 31>
  %146 = add <4 x i32> %144, %145
  %147 = sitofp <4 x i32> %146 to <4 x float>
  %148 = fsub <4 x float> %143, %147
  %149 = add <4 x i32> %146, <i32 127, i32 127, i32 127, i32 127>
  %150 = shl <4 x i32> %149, <i32 23, i32 23, i32 23, i32 23>
  %151 = bitcast <4 x i32> %150 to <4 x float>
  %152 = fmul <4 x float> %148, <float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000, float 0x3FE6353F80000000>
  %153 = fmul <4 x float> %152, %152
  %154 = fadd <4 x float> %152, <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>
  %155 = fmul <4 x float> %153, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %156 = fadd <4 x float> %154, %155
  %157 = fmul <4 x float> %152, %153
  %158 = fmul <4 x float> %157, <float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000, float 0x3FC5554FC0000000>
  %159 = fadd <4 x float> %156, %158
  %160 = fmul <4 x float> %153, %153
  %161 = fmul <4 x float> %160, <float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000, float 0x3FA5555320000000>
  %162 = fadd <4 x float> %161, %159
  %163 = fmul <4 x float> %151, %162
  ret <4 x float> %163
}

; Function Attrs: nounwind readnone
define <4 x float> @rsUnpackColor8888(<4 x i8> %c) #7 {
  %1 = uitofp <4 x i8> %c to <4 x float>
  %2 = fmul <4 x float> %1, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  ret <4 x float> %2
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicCasPViii(i32* %ptr, i32 %expectedValue, i32 %newValue) #5 {
  %1 = cmpxchg i32* %ptr, i32 %expectedValue, i32 %newValue seq_cst seq_cst
  %2 = extractvalue { i32, i1 } %1, 0
  ret i32 %2
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicCasPVjjj(i32* %ptr, i32 %expectedValue, i32 %newValue) #5 {
  %1 = cmpxchg i32* %ptr, i32 %expectedValue, i32 %newValue seq_cst seq_cst
  %2 = extractvalue { i32, i1 } %1, 0
  ret i32 %2
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicIncPVi(i32* %ptr) #5 {
  %1 = atomicrmw add i32* %ptr, i32 1 seq_cst
  ret i32 %1
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicDecPVi(i32* %ptr) #5 {
  %1 = atomicrmw sub i32* %ptr, i32 1 seq_cst
  ret i32 %1
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicAddPVii(i32* %ptr, i32 %value) #5 {
  %1 = atomicrmw add i32* %ptr, i32 %value seq_cst
  ret i32 %1
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicSubPVii(i32* %ptr, i32 %value) #5 {
  %1 = atomicrmw sub i32* %ptr, i32 %value seq_cst
  ret i32 %1
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicAndPVii(i32* %ptr, i32 %value) #5 {
  %1 = atomicrmw and i32* %ptr, i32 %value seq_cst
  ret i32 %1
}

; Function Attrs: nounwind
define i32 @_Z10rsAtomicOrPVii(i32* %ptr, i32 %value) #5 {
  %1 = atomicrmw or i32* %ptr, i32 %value seq_cst
  ret i32 %1
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicXorPVii(i32* %ptr, i32 %value) #5 {
  %1 = atomicrmw xor i32* %ptr, i32 %value seq_cst
  ret i32 %1
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicMinPVjj(i32* %ptr, i32 %value) #5 {
  br label %1

; <label>:1                                       ; preds = %1, %0
  %2 = load volatile i32, i32* %ptr, align 4, !tbaa !21
  %3 = icmp ult i32 %value, %2
  %4 = select i1 %3, i32 %value, i32 %2
  %val = cmpxchg i32* %ptr, i32 %2, i32 %4 seq_cst seq_cst
  %5 = extractvalue { i32, i1 } %val, 0
  %6 = icmp eq i32 %5, %2
  br i1 %6, label %7, label %1

; <label>:7                                       ; preds = %1
  ret i32 %2
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicMinPVii(i32* %ptr, i32 %value) #5 {
  br label %1

; <label>:1                                       ; preds = %1, %0
  %2 = load volatile i32, i32* %ptr, align 4, !tbaa !21
  %3 = icmp slt i32 %value, %2
  %4 = select i1 %3, i32 %value, i32 %2
  %val = cmpxchg i32* %ptr, i32 %2, i32 %4 seq_cst seq_cst
  %5 = extractvalue { i32, i1 } %val, 0
  %6 = icmp eq i32 %5, %2
  br i1 %6, label %7, label %1

; <label>:7                                       ; preds = %1
  ret i32 %2
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicMaxPVjj(i32* %ptr, i32 %value) #5 {
  br label %1

; <label>:1                                       ; preds = %1, %0
  %2 = load volatile i32, i32* %ptr, align 4, !tbaa !21
  %3 = icmp ugt i32 %value, %2
  %4 = select i1 %3, i32 %value, i32 %2
  %val = cmpxchg i32* %ptr, i32 %2, i32 %4 seq_cst seq_cst
  %5 = extractvalue { i32, i1 } %val, 0
  %6 = icmp eq i32 %5, %2
  br i1 %6, label %7, label %1

; <label>:7                                       ; preds = %1
  ret i32 %2
}

; Function Attrs: nounwind
define i32 @_Z11rsAtomicMaxPVii(i32* %ptr, i32 %value) #5 {
  br label %1

; <label>:1                                       ; preds = %1, %0
  %2 = load volatile i32, i32* %ptr, align 4, !tbaa !21
  %3 = icmp sgt i32 %value, %2
  %4 = select i1 %3, i32 %value, i32 %2
  %val = cmpxchg i32* %ptr, i32 %2, i32 %4 seq_cst seq_cst
  %5 = extractvalue { i32, i1 } %val, 0
  %6 = icmp eq i32 %5, %2
  br i1 %6, label %7, label %1

; <label>:7                                       ; preds = %1
  ret i32 %2
}

; Function Attrs: nounwind
define float @_Z6rsRandf(float %max) #5 {
  %1 = tail call float @_Z6rsRandff(float 0.000000e+00, float %max) #12
  ret float %1
}

declare float @_Z6rsRandff(float, float) #6

; Function Attrs: nounwind
define i32 @_Z6rsRandi(i32 %max) #5 {
  %1 = sitofp i32 %max to float
  %2 = tail call float @_Z6rsRandff(float 0.000000e+00, float %1) #12
  %3 = fptosi float %2 to i32
  ret i32 %3
}

; Function Attrs: nounwind
define i32 @_Z6rsRandii(i32 %min, i32 %max) #5 {
  %1 = sitofp i32 %min to float
  %2 = sitofp i32 %max to float
  %3 = tail call float @_Z6rsRandff(float %1, float %2) #12
  %4 = fptosi float %3 to i32
  ret i32 %4
}

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_c(i8* %txt, <2 x i8> %val) #5 {
  %1 = alloca <2 x i8>, align 2
  store <2 x i8> %val, <2 x i8>* %1, align 2, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_c(i8* %txt, <2 x i8>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_c(i8*, <2 x i8>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_c(i8* %txt, <3 x i8> %val) #5 {
  %1 = alloca <3 x i8>, align 4
  %2 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i8>* %1 to <4 x i8>*
  store <4 x i8> %2, <4 x i8>* %3, align 4, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_c(i8* %txt, <3 x i8>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_c(i8*, <3 x i8>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_c(i8* %txt, <4 x i8> %val) #5 {
  %1 = alloca <4 x i8>, align 4
  store <4 x i8> %val, <4 x i8>* %1, align 4, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_c(i8* %txt, <4 x i8>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_c(i8*, <4 x i8>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_h(i8* %txt, <2 x i8> %val) #5 {
  %1 = alloca <2 x i8>, align 2
  store <2 x i8> %val, <2 x i8>* %1, align 2, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_h(i8* %txt, <2 x i8>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_h(i8*, <2 x i8>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_h(i8* %txt, <3 x i8> %val) #5 {
  %1 = alloca <3 x i8>, align 4
  %2 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i8>* %1 to <4 x i8>*
  store <4 x i8> %2, <4 x i8>* %3, align 4, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_h(i8* %txt, <3 x i8>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_h(i8*, <3 x i8>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_h(i8* %txt, <4 x i8> %val) #5 {
  %1 = alloca <4 x i8>, align 4
  store <4 x i8> %val, <4 x i8>* %1, align 4, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_h(i8* %txt, <4 x i8>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_h(i8*, <4 x i8>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_s(i8* %txt, <2 x i16> %val) #5 {
  %1 = alloca <2 x i16>, align 4
  store <2 x i16> %val, <2 x i16>* %1, align 4, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_s(i8* %txt, <2 x i16>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_s(i8*, <2 x i16>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_s(i8* %txt, <3 x i16> %val) #5 {
  %1 = alloca <3 x i16>, align 8
  %2 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i16>* %1 to <4 x i16>*
  store <4 x i16> %2, <4 x i16>* %3, align 8, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_s(i8* %txt, <3 x i16>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_s(i8*, <3 x i16>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_s(i8* %txt, <4 x i16> %val) #5 {
  %1 = alloca <4 x i16>, align 8
  store <4 x i16> %val, <4 x i16>* %1, align 8, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_s(i8* %txt, <4 x i16>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_s(i8*, <4 x i16>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_t(i8* %txt, <2 x i16> %val) #5 {
  %1 = alloca <2 x i16>, align 4
  store <2 x i16> %val, <2 x i16>* %1, align 4, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_t(i8* %txt, <2 x i16>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_t(i8*, <2 x i16>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_t(i8* %txt, <3 x i16> %val) #5 {
  %1 = alloca <3 x i16>, align 8
  %2 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i16>* %1 to <4 x i16>*
  store <4 x i16> %2, <4 x i16>* %3, align 8, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_t(i8* %txt, <3 x i16>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_t(i8*, <3 x i16>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_t(i8* %txt, <4 x i16> %val) #5 {
  %1 = alloca <4 x i16>, align 8
  store <4 x i16> %val, <4 x i16>* %1, align 8, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_t(i8* %txt, <4 x i16>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_t(i8*, <4 x i16>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_i(i8* %txt, <2 x i32> %val) #5 {
  %1 = alloca <2 x i32>, align 8
  store <2 x i32> %val, <2 x i32>* %1, align 8, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_i(i8* %txt, <2 x i32>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_i(i8*, <2 x i32>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_i(i8* %txt, <3 x i32> %val) #5 {
  %1 = alloca <3 x i32>, align 16
  %2 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i32>* %1 to <4 x i32>*
  store <4 x i32> %2, <4 x i32>* %3, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_i(i8* %txt, <3 x i32>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_i(i8*, <3 x i32>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_i(i8* %txt, <4 x i32> %val) #5 {
  %1 = alloca <4 x i32>, align 16
  store <4 x i32> %val, <4 x i32>* %1, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_i(i8* %txt, <4 x i32>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_i(i8*, <4 x i32>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_j(i8* %txt, <2 x i32> %val) #5 {
  %1 = alloca <2 x i32>, align 8
  store <2 x i32> %val, <2 x i32>* %1, align 8, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_j(i8* %txt, <2 x i32>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_j(i8*, <2 x i32>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_j(i8* %txt, <3 x i32> %val) #5 {
  %1 = alloca <3 x i32>, align 16
  %2 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i32>* %1 to <4 x i32>*
  store <4 x i32> %2, <4 x i32>* %3, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_j(i8* %txt, <3 x i32>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_j(i8*, <3 x i32>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_j(i8* %txt, <4 x i32> %val) #5 {
  %1 = alloca <4 x i32>, align 16
  store <4 x i32> %val, <4 x i32>* %1, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_j(i8* %txt, <4 x i32>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_j(i8*, <4 x i32>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_l(i8* %txt, <2 x i64> %val) #5 {
  %1 = alloca <2 x i64>, align 16
  store <2 x i64> %val, <2 x i64>* %1, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_l(i8* %txt, <2 x i64>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_l(i8*, <2 x i64>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_l(i8* %txt, <3 x i64> %val) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %2, <4 x i64>* %3, align 32, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_l(i8* %txt, <3 x i64>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_l(i8*, <3 x i64>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_l(i8* %txt, <4 x i64> %val) #5 {
  %1 = alloca <4 x i64>, align 32
  store <4 x i64> %val, <4 x i64>* %1, align 32, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_l(i8* %txt, <4 x i64>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_l(i8*, <4 x i64>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_y(i8* %txt, <2 x i64> %val) #5 {
  %1 = alloca <2 x i64>, align 16
  store <2 x i64> %val, <2 x i64>* %1, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_y(i8* %txt, <2 x i64>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_y(i8*, <2 x i64>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_y(i8* %txt, <3 x i64> %val) #5 {
  %1 = alloca <3 x i64>, align 32
  %2 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x i64>* %1 to <4 x i64>*
  store <4 x i64> %2, <4 x i64>* %3, align 32, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_y(i8* %txt, <3 x i64>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_y(i8*, <3 x i64>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_y(i8* %txt, <4 x i64> %val) #5 {
  %1 = alloca <4 x i64>, align 32
  store <4 x i64> %val, <4 x i64>* %1, align 32, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_y(i8* %txt, <4 x i64>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_y(i8*, <4 x i64>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_f(i8* %txt, <2 x float> %val) #5 {
  %1 = alloca <2 x float>, align 8
  store <2 x float> %val, <2 x float>* %1, align 8, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_f(i8* %txt, <2 x float>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_f(i8*, <2 x float>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_f(i8* %txt, <3 x float> %val) #5 {
  %1 = alloca <3 x float>, align 16
  %2 = shufflevector <3 x float> %val, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x float>* %1 to <4 x float>*
  store <4 x float> %2, <4 x float>* %3, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_f(i8* %txt, <3 x float>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_f(i8*, <3 x float>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_f(i8* %txt, <4 x float> %val) #5 {
  %1 = alloca <4 x float>, align 16
  store <4 x float> %val, <4 x float>* %1, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_f(i8* %txt, <4 x float>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_f(i8*, <4 x float>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv2_d(i8* %txt, <2 x double> %val) #5 {
  %1 = alloca <2 x double>, align 16
  store <2 x double> %val, <2 x double>* %1, align 16, !tbaa !19
  call void @_Z7rsDebugPKcPKDv2_d(i8* %txt, <2 x double>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv2_d(i8*, <2 x double>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv3_d(i8* %txt, <3 x double> %val) #5 {
  %1 = alloca <3 x double>, align 32
  %2 = shufflevector <3 x double> %val, <3 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %3 = bitcast <3 x double>* %1 to <4 x double>*
  store <4 x double> %2, <4 x double>* %3, align 32, !tbaa !19
  call void @_Z7rsDebugPKcPKDv3_d(i8* %txt, <3 x double>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv3_d(i8*, <3 x double>*) #6

; Function Attrs: nounwind
define void @_Z7rsDebugPKcDv4_d(i8* %txt, <4 x double> %val) #5 {
  %1 = alloca <4 x double>, align 32
  store <4 x double> %val, <4 x double>* %1, align 32, !tbaa !19
  call void @_Z7rsDebugPKcPKDv4_d(i8* %txt, <4 x double>* %1) #12
  ret void
}

declare void @_Z7rsDebugPKcPKDv4_d(i8*, <4 x double>*) #6

; Function Attrs: nounwind readonly
define i32 @_Z27rsElementGetSubElementCount10rs_element([1 x i32] %e.coerce) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 9
  %6 = load i32, i32* %5, align 4, !tbaa !21
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z22rsElementGetSubElement10rs_elementj([1 x i32] %e.coerce, i32 %index) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %13, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 9
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ugt i32 %6, %index
  br i1 %7, label %8, label %13

; <label>:8                                       ; preds = %3
  %9 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 4
  %10 = load i8**, i8*** %9, align 4, !tbaa !22
  %11 = getelementptr inbounds i8*, i8** %10, i32 %index
  %12 = load i8*, i8** %11, align 4, !tbaa !22
  %phitmp = ptrtoint i8* %12 to i32
  br label %13

; <label>:13                                      ; preds = %8, %3, %0
  %.sroa.0.0 = phi i32 [ %phitmp, %8 ], [ 0, %3 ], [ 0, %0 ]
  ret i32 %.sroa.0.0
}

; Function Attrs: nounwind readonly
define i32 @_Z32rsElementGetSubElementNameLength10rs_elementj([1 x i32] %e.coerce, i32 %index) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %13, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 9
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ugt i32 %6, %index
  br i1 %7, label %8, label %13

; <label>:8                                       ; preds = %3
  %9 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 7
  %10 = load i32*, i32** %9, align 4, !tbaa !22
  %11 = getelementptr inbounds i32, i32* %10, i32 %index
  %12 = load i32, i32* %11, align 4, !tbaa !21
  br label %13

; <label>:13                                      ; preds = %8, %3, %0
  %.0 = phi i32 [ %12, %8 ], [ 0, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind
define i32 @_Z26rsElementGetSubElementName10rs_elementjPcj([1 x i32] %e.coerce, i32 %index, i8* %name, i32 %nameLength) #5 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %.loopexit, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 9
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ule i32 %6, %index
  %8 = icmp eq i32 %nameLength, 0
  %or.cond = or i1 %7, %8
  %9 = icmp eq i8* %name, null
  %or.cond1 = or i1 %or.cond, %9
  br i1 %or.cond1, label %.loopexit, label %10

; <label>:10                                      ; preds = %3
  %11 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 7
  %12 = load i32*, i32** %11, align 4, !tbaa !22
  %13 = getelementptr inbounds i32, i32* %12, i32 %index
  %14 = load i32, i32* %13, align 4, !tbaa !21
  %15 = icmp ugt i32 %14, %nameLength
  %nameLength. = select i1 %15, i32 %nameLength, i32 %14
  %16 = add i32 %nameLength., -1
  %17 = getelementptr inbounds i8, i8* %name, i32 %16
  store i8 0, i8* %17, align 1, !tbaa !19
  %18 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 6
  %19 = load i8**, i8*** %18, align 4, !tbaa !22
  %20 = getelementptr inbounds i8*, i8** %19, i32 %index
  %21 = load i8*, i8** %20, align 4, !tbaa !22
  %22 = icmp eq i32 %16, 0
  br i1 %22, label %.loopexit, label %.lr.ph

.lr.ph:                                           ; preds = %10
  %23 = xor i32 %14, -1
  %24 = xor i32 %nameLength, -1
  %25 = icmp ugt i32 %23, %24
  %umax = select i1 %25, i32 %23, i32 %24
  %26 = sub i32 -2, %umax
  %n.vec = and i32 %26, -16
  %cmp.zero = icmp eq i32 %n.vec, 0
  %27 = sub i32 -3, %umax
  br i1 %cmp.zero, label %middle.block, label %vector.memcheck

vector.memcheck:                                  ; preds = %.lr.ph
  %scevgep6 = getelementptr i8, i8* %21, i32 %27
  %scevgep = getelementptr i8, i8* %name, i32 %27
  %bound1 = icmp ule i8* %21, %scevgep
  %bound0 = icmp uge i8* %scevgep6, %name
  %found.conflict = and i1 %bound0, %bound1
  br i1 %found.conflict, label %middle.block, label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.memcheck
  %index4 = phi i32 [ %index.next, %vector.body ], [ 0, %vector.memcheck ]
  %28 = getelementptr inbounds i8, i8* %21, i32 %index4
  %29 = bitcast i8* %28 to <16 x i8>*
  %wide.load = load <16 x i8>, <16 x i8>* %29, align 1
  %30 = getelementptr inbounds i8, i8* %name, i32 %index4
  %31 = bitcast i8* %30 to <16 x i8>*
  store <16 x i8> %wide.load, <16 x i8>* %31, align 1
  %index.next = add i32 %index4, 16
  %32 = icmp eq i32 %index.next, %n.vec
  br i1 %32, label %middle.block, label %vector.body

middle.block:                                     ; preds = %vector.body, %vector.memcheck, %.lr.ph
  %resume.val = phi i32 [ 0, %.lr.ph ], [ 0, %vector.memcheck ], [ %n.vec, %vector.body ]
  %cmp.n = icmp eq i32 %26, %resume.val
  br i1 %cmp.n, label %.loopexit, label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph, %middle.block
  %i.02 = phi i32 [ %36, %scalar.ph ], [ %resume.val, %middle.block ]
  %33 = getelementptr inbounds i8, i8* %21, i32 %i.02
  %34 = load i8, i8* %33, align 1, !tbaa !19
  %35 = getelementptr inbounds i8, i8* %name, i32 %i.02
  store i8 %34, i8* %35, align 1, !tbaa !19
  %36 = add i32 %i.02, 1
  %exitcond = icmp eq i32 %36, %26
  br i1 %exitcond, label %.loopexit, label %scalar.ph, !llvm.loop !69

.loopexit:                                        ; preds = %scalar.ph, %middle.block, %10, %3, %0
  %.0 = phi i32 [ 0, %3 ], [ 0, %0 ], [ %16, %middle.block ], [ %16, %scalar.ph ], [ 0, %10 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z31rsElementGetSubElementArraySize10rs_elementj([1 x i32] %e.coerce, i32 %index) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %13, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 9
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ugt i32 %6, %index
  br i1 %7, label %8, label %13

; <label>:8                                       ; preds = %3
  %9 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 5
  %10 = load i32*, i32** %9, align 4, !tbaa !22
  %11 = getelementptr inbounds i32, i32* %10, i32 %index
  %12 = load i32, i32* %11, align 4, !tbaa !21
  br label %13

; <label>:13                                      ; preds = %8, %3, %0
  %.0 = phi i32 [ %12, %8 ], [ 0, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z33rsElementGetSubElementOffsetBytes10rs_elementj([1 x i32] %e.coerce, i32 %index) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %13, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 9
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ugt i32 %6, %index
  br i1 %7, label %8, label %13

; <label>:8                                       ; preds = %3
  %9 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 8
  %10 = load i32*, i32** %9, align 4, !tbaa !22
  %11 = getelementptr inbounds i32, i32* %10, i32 %index
  %12 = load i32, i32* %11, align 4, !tbaa !21
  br label %13

; <label>:13                                      ; preds = %8, %3, %0
  %.0 = phi i32 [ %12, %8 ], [ 0, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z21rsElementGetBytesSize10rs_element([1 x i32] %e.coerce) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 3
  %6 = load i32, i32* %5, align 4, !tbaa !21
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z20rsElementGetDataType10rs_element([1 x i32] %e.coerce) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 0
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 10000, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z20rsElementGetDataKind10rs_element([1 x i32] %e.coerce) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z22rsElementGetVectorSize10rs_element([1 x i32] %e.coerce) #4 {
  %1 = extractvalue [1 x i32] %e.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Element*
  %5 = getelementptr inbounds %struct.Element, %struct.Element* %4, i32 0, i32 1, i32 1, i32 2
  %6 = load i32, i32* %5, align 4, !tbaa !21
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z31rsgMeshGetVertexAllocationCount7rs_mesh([1 x i32] %m.coerce) #4 {
  %1 = extractvalue [1 x i32] %m.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Mesh*
  %5 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z24rsgMeshGetPrimitiveCount7rs_mesh([1 x i32] %m.coerce) #4 {
  %1 = extractvalue [1 x i32] %m.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Mesh*
  %5 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !21
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 0, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z26rsgMeshGetVertexAllocation7rs_meshj([1 x i32] %m.coerce, i32 %index) #4 {
  %1 = extractvalue [1 x i32] %m.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %13, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Mesh*
  %5 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ugt i32 %6, %index
  br i1 %7, label %8, label %13

; <label>:8                                       ; preds = %3
  %9 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 0
  %10 = load i8**, i8*** %9, align 4, !tbaa !22
  %11 = getelementptr inbounds i8*, i8** %10, i32 %index
  %12 = load i8*, i8** %11, align 4, !tbaa !22
  %phitmp = ptrtoint i8* %12 to i32
  br label %13

; <label>:13                                      ; preds = %8, %3, %0
  %.sroa.0.0 = phi i32 [ %phitmp, %8 ], [ 0, %3 ], [ 0, %0 ]
  ret i32 %.sroa.0.0
}

; Function Attrs: nounwind readonly
define i32 @_Z25rsgMeshGetIndexAllocation7rs_meshj([1 x i32] %m.coerce, i32 %index) #4 {
  %1 = extractvalue [1 x i32] %m.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %13, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Mesh*
  %5 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ugt i32 %6, %index
  br i1 %7, label %8, label %13

; <label>:8                                       ; preds = %3
  %9 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 2
  %10 = load i8**, i8*** %9, align 4, !tbaa !22
  %11 = getelementptr inbounds i8*, i8** %10, i32 %index
  %12 = load i8*, i8** %11, align 4, !tbaa !22
  %phitmp = ptrtoint i8* %12 to i32
  br label %13

; <label>:13                                      ; preds = %8, %3, %0
  %.sroa.0.0 = phi i32 [ %phitmp, %8 ], [ 0, %3 ], [ 0, %0 ]
  ret i32 %.sroa.0.0
}

; Function Attrs: nounwind readonly
define i32 @_Z19rsgMeshGetPrimitive7rs_meshj([1 x i32] %m.coerce, i32 %index) #4 {
  %1 = extractvalue [1 x i32] %m.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %13, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Mesh*
  %5 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = icmp ugt i32 %6, %index
  br i1 %7, label %8, label %13

; <label>:8                                       ; preds = %3
  %9 = getelementptr inbounds %struct.Mesh, %struct.Mesh* %4, i32 0, i32 1, i32 1, i32 4
  %10 = load i32*, i32** %9, align 4, !tbaa !22
  %11 = getelementptr inbounds i32, i32* %10, i32 %index
  %12 = load i32, i32* %11, align 4, !tbaa !19
  br label %13

; <label>:13                                      ; preds = %8, %3, %0
  %.0 = phi i32 [ %12, %8 ], [ 100, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind
define void @_Z20rsMatrixLoadIdentityP12rs_matrix4x4(%struct.rs_matrix4x4* nocapture %m) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  store float 1.000000e+00, float* %1, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  store float 0.000000e+00, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  store float 0.000000e+00, float* %4, align 4, !tbaa !18
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  store float 0.000000e+00, float* %5, align 4, !tbaa !18
  %6 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  store float 1.000000e+00, float* %6, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  store float 0.000000e+00, float* %7, align 4, !tbaa !18
  %8 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  store float 0.000000e+00, float* %8, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  store float 0.000000e+00, float* %9, align 4, !tbaa !18
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  store float 0.000000e+00, float* %10, align 4, !tbaa !18
  %11 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  store float 1.000000e+00, float* %11, align 4, !tbaa !18
  %12 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  store float 0.000000e+00, float* %12, align 4, !tbaa !18
  %13 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  store float 0.000000e+00, float* %13, align 4, !tbaa !18
  %14 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  store float 0.000000e+00, float* %14, align 4, !tbaa !18
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  store float 0.000000e+00, float* %15, align 4, !tbaa !18
  %16 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  store float 1.000000e+00, float* %16, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsMatrixLoadIdentityP12rs_matrix3x3(%struct.rs_matrix3x3* nocapture %m) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 0
  store float 1.000000e+00, float* %1, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 2
  store float 0.000000e+00, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 3
  store float 0.000000e+00, float* %4, align 4, !tbaa !18
  %5 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 4
  store float 1.000000e+00, float* %5, align 4, !tbaa !18
  %6 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 5
  store float 0.000000e+00, float* %6, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 6
  store float 0.000000e+00, float* %7, align 4, !tbaa !18
  %8 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 7
  store float 0.000000e+00, float* %8, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 8
  store float 1.000000e+00, float* %9, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsMatrixLoadIdentityP12rs_matrix2x2(%struct.rs_matrix2x2* nocapture %m) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 0
  store float 1.000000e+00, float* %1, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 2
  store float 0.000000e+00, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 3
  store float 1.000000e+00, float* %4, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix4x4PKf(%struct.rs_matrix4x4* nocapture %m, float* nocapture %f) #5 {
  %1 = load float, float* %f, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  store float %1, float* %2, align 4, !tbaa !18
  %3 = getelementptr inbounds float, float* %f, i32 1
  %4 = load float, float* %3, align 4, !tbaa !18
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  store float %4, float* %5, align 4, !tbaa !18
  %6 = getelementptr inbounds float, float* %f, i32 2
  %7 = load float, float* %6, align 4, !tbaa !18
  %8 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  store float %7, float* %8, align 4, !tbaa !18
  %9 = getelementptr inbounds float, float* %f, i32 3
  %10 = load float, float* %9, align 4, !tbaa !18
  %11 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  store float %10, float* %11, align 4, !tbaa !18
  %12 = getelementptr inbounds float, float* %f, i32 4
  %13 = load float, float* %12, align 4, !tbaa !18
  %14 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  store float %13, float* %14, align 4, !tbaa !18
  %15 = getelementptr inbounds float, float* %f, i32 5
  %16 = load float, float* %15, align 4, !tbaa !18
  %17 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  store float %16, float* %17, align 4, !tbaa !18
  %18 = getelementptr inbounds float, float* %f, i32 6
  %19 = load float, float* %18, align 4, !tbaa !18
  %20 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  store float %19, float* %20, align 4, !tbaa !18
  %21 = getelementptr inbounds float, float* %f, i32 7
  %22 = load float, float* %21, align 4, !tbaa !18
  %23 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  store float %22, float* %23, align 4, !tbaa !18
  %24 = getelementptr inbounds float, float* %f, i32 8
  %25 = load float, float* %24, align 4, !tbaa !18
  %26 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  store float %25, float* %26, align 4, !tbaa !18
  %27 = getelementptr inbounds float, float* %f, i32 9
  %28 = load float, float* %27, align 4, !tbaa !18
  %29 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  store float %28, float* %29, align 4, !tbaa !18
  %30 = getelementptr inbounds float, float* %f, i32 10
  %31 = load float, float* %30, align 4, !tbaa !18
  %32 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  store float %31, float* %32, align 4, !tbaa !18
  %33 = getelementptr inbounds float, float* %f, i32 11
  %34 = load float, float* %33, align 4, !tbaa !18
  %35 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  store float %34, float* %35, align 4, !tbaa !18
  %36 = getelementptr inbounds float, float* %f, i32 12
  %37 = load float, float* %36, align 4, !tbaa !18
  %38 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  store float %37, float* %38, align 4, !tbaa !18
  %39 = getelementptr inbounds float, float* %f, i32 13
  %40 = load float, float* %39, align 4, !tbaa !18
  %41 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  store float %40, float* %41, align 4, !tbaa !18
  %42 = getelementptr inbounds float, float* %f, i32 14
  %43 = load float, float* %42, align 4, !tbaa !18
  %44 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  store float %43, float* %44, align 4, !tbaa !18
  %45 = getelementptr inbounds float, float* %f, i32 15
  %46 = load float, float* %45, align 4, !tbaa !18
  %47 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  store float %46, float* %47, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix3x3PKf(%struct.rs_matrix3x3* nocapture %m, float* nocapture %f) #5 {
  %1 = load float, float* %f, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 0
  store float %1, float* %2, align 4, !tbaa !18
  %3 = getelementptr inbounds float, float* %f, i32 1
  %4 = load float, float* %3, align 4, !tbaa !18
  %5 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 1
  store float %4, float* %5, align 4, !tbaa !18
  %6 = getelementptr inbounds float, float* %f, i32 2
  %7 = load float, float* %6, align 4, !tbaa !18
  %8 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 2
  store float %7, float* %8, align 4, !tbaa !18
  %9 = getelementptr inbounds float, float* %f, i32 3
  %10 = load float, float* %9, align 4, !tbaa !18
  %11 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 3
  store float %10, float* %11, align 4, !tbaa !18
  %12 = getelementptr inbounds float, float* %f, i32 4
  %13 = load float, float* %12, align 4, !tbaa !18
  %14 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 4
  store float %13, float* %14, align 4, !tbaa !18
  %15 = getelementptr inbounds float, float* %f, i32 5
  %16 = load float, float* %15, align 4, !tbaa !18
  %17 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 5
  store float %16, float* %17, align 4, !tbaa !18
  %18 = getelementptr inbounds float, float* %f, i32 6
  %19 = load float, float* %18, align 4, !tbaa !18
  %20 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 6
  store float %19, float* %20, align 4, !tbaa !18
  %21 = getelementptr inbounds float, float* %f, i32 7
  %22 = load float, float* %21, align 4, !tbaa !18
  %23 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 7
  store float %22, float* %23, align 4, !tbaa !18
  %24 = getelementptr inbounds float, float* %f, i32 8
  %25 = load float, float* %24, align 4, !tbaa !18
  %26 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 8
  store float %25, float* %26, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix2x2PKf(%struct.rs_matrix2x2* nocapture %m, float* nocapture %f) #5 {
  %1 = load float, float* %f, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 0
  store float %1, float* %2, align 4, !tbaa !18
  %3 = getelementptr inbounds float, float* %f, i32 1
  %4 = load float, float* %3, align 4, !tbaa !18
  %5 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 1
  store float %4, float* %5, align 4, !tbaa !18
  %6 = getelementptr inbounds float, float* %f, i32 2
  %7 = load float, float* %6, align 4, !tbaa !18
  %8 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 2
  store float %7, float* %8, align 4, !tbaa !18
  %9 = getelementptr inbounds float, float* %f, i32 3
  %10 = load float, float* %9, align 4, !tbaa !18
  %11 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 3
  store float %10, float* %11, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix4x4PKS_(%struct.rs_matrix4x4* nocapture %m, %struct.rs_matrix4x4* nocapture %s) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  store float %2, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 1
  %5 = load float, float* %4, align 4, !tbaa !18
  %6 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  store float %5, float* %6, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 2
  %8 = load float, float* %7, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  store float %8, float* %9, align 4, !tbaa !18
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 3
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  store float %11, float* %12, align 4, !tbaa !18
  %13 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 4
  %14 = load float, float* %13, align 4, !tbaa !18
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  store float %14, float* %15, align 4, !tbaa !18
  %16 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 5
  %17 = load float, float* %16, align 4, !tbaa !18
  %18 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  store float %17, float* %18, align 4, !tbaa !18
  %19 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 6
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  store float %20, float* %21, align 4, !tbaa !18
  %22 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 7
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  store float %23, float* %24, align 4, !tbaa !18
  %25 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 8
  %26 = load float, float* %25, align 4, !tbaa !18
  %27 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  store float %26, float* %27, align 4, !tbaa !18
  %28 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 9
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  store float %29, float* %30, align 4, !tbaa !18
  %31 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 10
  %32 = load float, float* %31, align 4, !tbaa !18
  %33 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  store float %32, float* %33, align 4, !tbaa !18
  %34 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 11
  %35 = load float, float* %34, align 4, !tbaa !18
  %36 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  store float %35, float* %36, align 4, !tbaa !18
  %37 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 12
  %38 = load float, float* %37, align 4, !tbaa !18
  %39 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  store float %38, float* %39, align 4, !tbaa !18
  %40 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 13
  %41 = load float, float* %40, align 4, !tbaa !18
  %42 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  store float %41, float* %42, align 4, !tbaa !18
  %43 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 14
  %44 = load float, float* %43, align 4, !tbaa !18
  %45 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  store float %44, float* %45, align 4, !tbaa !18
  %46 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %s, i32 0, i32 0, i32 15
  %47 = load float, float* %46, align 4, !tbaa !18
  %48 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  store float %47, float* %48, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix4x4PK12rs_matrix3x3(%struct.rs_matrix4x4* nocapture %m, %struct.rs_matrix3x3* nocapture %v) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  store float %2, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 1
  %5 = load float, float* %4, align 4, !tbaa !18
  %6 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  store float %5, float* %6, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 2
  %8 = load float, float* %7, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  store float %8, float* %9, align 4, !tbaa !18
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  store float 0.000000e+00, float* %10, align 4, !tbaa !18
  %11 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 3
  %12 = load float, float* %11, align 4, !tbaa !18
  %13 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  store float %12, float* %13, align 4, !tbaa !18
  %14 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 4
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  store float %15, float* %16, align 4, !tbaa !18
  %17 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 5
  %18 = load float, float* %17, align 4, !tbaa !18
  %19 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  store float %18, float* %19, align 4, !tbaa !18
  %20 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  store float 0.000000e+00, float* %20, align 4, !tbaa !18
  %21 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 6
  %22 = load float, float* %21, align 4, !tbaa !18
  %23 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  store float %22, float* %23, align 4, !tbaa !18
  %24 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 7
  %25 = load float, float* %24, align 4, !tbaa !18
  %26 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  store float %25, float* %26, align 4, !tbaa !18
  %27 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %v, i32 0, i32 0, i32 8
  %28 = load float, float* %27, align 4, !tbaa !18
  %29 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  store float %28, float* %29, align 4, !tbaa !18
  %30 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  store float 0.000000e+00, float* %30, align 4, !tbaa !18
  %31 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  store float 0.000000e+00, float* %31, align 4, !tbaa !18
  %32 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  store float 0.000000e+00, float* %32, align 4, !tbaa !18
  %33 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  store float 0.000000e+00, float* %33, align 4, !tbaa !18
  %34 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  store float 1.000000e+00, float* %34, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix4x4PK12rs_matrix2x2(%struct.rs_matrix4x4* nocapture %m, %struct.rs_matrix2x2* nocapture %v) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %v, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  store float %2, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %v, i32 0, i32 0, i32 1
  %5 = load float, float* %4, align 4, !tbaa !18
  %6 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  store float %5, float* %6, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  store float 0.000000e+00, float* %7, align 4, !tbaa !18
  %8 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  store float 0.000000e+00, float* %8, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %v, i32 0, i32 0, i32 2
  %10 = load float, float* %9, align 4, !tbaa !18
  %11 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  store float %10, float* %11, align 4, !tbaa !18
  %12 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %v, i32 0, i32 0, i32 3
  %13 = load float, float* %12, align 4, !tbaa !18
  %14 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  store float %13, float* %14, align 4, !tbaa !18
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  store float 0.000000e+00, float* %15, align 4, !tbaa !18
  %16 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  store float 0.000000e+00, float* %16, align 4, !tbaa !18
  %17 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  store float 0.000000e+00, float* %17, align 4, !tbaa !18
  %18 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  store float 0.000000e+00, float* %18, align 4, !tbaa !18
  %19 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  store float 1.000000e+00, float* %19, align 4, !tbaa !18
  %20 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  store float 0.000000e+00, float* %20, align 4, !tbaa !18
  %21 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  store float 0.000000e+00, float* %21, align 4, !tbaa !18
  %22 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  store float 0.000000e+00, float* %22, align 4, !tbaa !18
  %23 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  store float 0.000000e+00, float* %23, align 4, !tbaa !18
  %24 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  store float 1.000000e+00, float* %24, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix3x3PKS_(%struct.rs_matrix3x3* nocapture %m, %struct.rs_matrix3x3* nocapture %s) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 0
  store float %2, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 1
  %5 = load float, float* %4, align 4, !tbaa !18
  %6 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 1
  store float %5, float* %6, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 2
  %8 = load float, float* %7, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 2
  store float %8, float* %9, align 4, !tbaa !18
  %10 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 3
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 3
  store float %11, float* %12, align 4, !tbaa !18
  %13 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 4
  %14 = load float, float* %13, align 4, !tbaa !18
  %15 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 4
  store float %14, float* %15, align 4, !tbaa !18
  %16 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 5
  %17 = load float, float* %16, align 4, !tbaa !18
  %18 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 5
  store float %17, float* %18, align 4, !tbaa !18
  %19 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 6
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 6
  store float %20, float* %21, align 4, !tbaa !18
  %22 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 7
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 7
  store float %23, float* %24, align 4, !tbaa !18
  %25 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %s, i32 0, i32 0, i32 8
  %26 = load float, float* %25, align 4, !tbaa !18
  %27 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 8
  store float %26, float* %27, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z12rsMatrixLoadP12rs_matrix2x2PKS_(%struct.rs_matrix2x2* nocapture %m, %struct.rs_matrix2x2* nocapture %s) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %s, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 0
  store float %2, float* %3, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %s, i32 0, i32 0, i32 1
  %5 = load float, float* %4, align 4, !tbaa !18
  %6 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 1
  store float %5, float* %6, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %s, i32 0, i32 0, i32 2
  %8 = load float, float* %7, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 2
  store float %8, float* %9, align 4, !tbaa !18
  %10 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %s, i32 0, i32 0, i32 3
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 3
  store float %11, float* %12, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z11rsMatrixSetP12rs_matrix4x4jjf(%struct.rs_matrix4x4* nocapture %m, i32 %row, i32 %col, float %v) #5 {
  %1 = shl i32 %row, 2
  %2 = add i32 %1, %col
  %3 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 %2
  store float %v, float* %3, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind readonly
define float @_Z11rsMatrixGetPK12rs_matrix4x4jj(%struct.rs_matrix4x4* nocapture %m, i32 %row, i32 %col) #4 {
  %1 = shl i32 %row, 2
  %2 = add i32 %1, %col
  %3 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 %2
  %4 = load float, float* %3, align 4, !tbaa !18
  ret float %4
}

; Function Attrs: nounwind
define void @_Z11rsMatrixSetP12rs_matrix3x3jjf(%struct.rs_matrix3x3* nocapture %m, i32 %row, i32 %col, float %v) #5 {
  %1 = mul i32 %row, 3
  %2 = add i32 %1, %col
  %3 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 %2
  store float %v, float* %3, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind readonly
define float @_Z11rsMatrixGetPK12rs_matrix3x3jj(%struct.rs_matrix3x3* nocapture %m, i32 %row, i32 %col) #4 {
  %1 = mul i32 %row, 3
  %2 = add i32 %1, %col
  %3 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 %2
  %4 = load float, float* %3, align 4, !tbaa !18
  ret float %4
}

; Function Attrs: nounwind
define void @_Z11rsMatrixSetP12rs_matrix2x2jjf(%struct.rs_matrix2x2* nocapture %m, i32 %row, i32 %col, float %v) #5 {
  %1 = shl i32 %row, 1
  %2 = add i32 %1, %col
  %3 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 %2
  store float %v, float* %3, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind readonly
define float @_Z11rsMatrixGetPK12rs_matrix2x2jj(%struct.rs_matrix2x2* nocapture %m, i32 %row, i32 %col) #4 {
  %1 = shl i32 %row, 1
  %2 = add i32 %1, %col
  %3 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 %2
  %4 = load float, float* %3, align 4, !tbaa !18
  ret float %4
}

; Function Attrs: nounwind readonly
define <2 x float> @_Z16rsMatrixMultiplyPK12rs_matrix2x2Dv2_f(%struct.rs_matrix2x2* nocapture %m, <2 x float> %in) #4 {
  %1 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <2 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 2
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <2 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = insertelement <2 x float> undef, float %9, i32 0
  %11 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 1
  %12 = load float, float* %11, align 4, !tbaa !18
  %13 = fmul float %3, %12
  %14 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 3
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = fmul float %7, %15
  %17 = fadd float %13, %16
  %18 = insertelement <2 x float> %10, float %17, i32 1
  ret <2 x float> %18
}

; Function Attrs: nounwind readonly
define <2 x float> @_Z16rsMatrixMultiplyP12rs_matrix2x2Dv2_f(%struct.rs_matrix2x2* nocapture %m, <2 x float> %in) #4 {
  %1 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <2 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 2
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <2 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = insertelement <2 x float> undef, float %9, i32 0
  %11 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 1
  %12 = load float, float* %11, align 4, !tbaa !18
  %13 = fmul float %3, %12
  %14 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %m, i32 0, i32 0, i32 3
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = fmul float %7, %15
  %17 = fadd float %13, %16
  %18 = insertelement <2 x float> %10, float %17, i32 1
  ret <2 x float> %18
}

; Function Attrs: nounwind
define <4 x float> @_Z16rsMatrixMultiplyP12rs_matrix4x4Dv4_f(%struct.rs_matrix4x4* %m, <4 x float> %in) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <4 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <4 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = extractelement <4 x float> %in, i32 2
  %13 = fmul float %12, %11
  %14 = fadd float %9, %13
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  %16 = load float, float* %15, align 4, !tbaa !18
  %17 = extractelement <4 x float> %in, i32 3
  %18 = fmul float %17, %16
  %19 = fadd float %14, %18
  %20 = insertelement <4 x float> undef, float %19, i32 0
  %21 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  %22 = load float, float* %21, align 4, !tbaa !18
  %23 = fmul float %3, %22
  %24 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  %25 = load float, float* %24, align 4, !tbaa !18
  %26 = fmul float %7, %25
  %27 = fadd float %23, %26
  %28 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = fmul float %12, %29
  %31 = fadd float %27, %30
  %32 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  %33 = load float, float* %32, align 4, !tbaa !18
  %34 = fmul float %17, %33
  %35 = fadd float %31, %34
  %36 = insertelement <4 x float> %20, float %35, i32 1
  %37 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  %38 = load float, float* %37, align 4, !tbaa !18
  %39 = fmul float %3, %38
  %40 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  %41 = load float, float* %40, align 4, !tbaa !18
  %42 = fmul float %7, %41
  %43 = fadd float %39, %42
  %44 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  %45 = load float, float* %44, align 4, !tbaa !18
  %46 = fmul float %12, %45
  %47 = fadd float %43, %46
  %48 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  %49 = load float, float* %48, align 4, !tbaa !18
  %50 = fmul float %17, %49
  %51 = fadd float %47, %50
  %52 = insertelement <4 x float> %36, float %51, i32 2
  %53 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  %54 = load float, float* %53, align 4, !tbaa !18
  %55 = fmul float %3, %54
  %56 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  %57 = load float, float* %56, align 4, !tbaa !18
  %58 = fmul float %7, %57
  %59 = fadd float %55, %58
  %60 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  %61 = load float, float* %60, align 4, !tbaa !18
  %62 = fmul float %12, %61
  %63 = fadd float %59, %62
  %64 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  %65 = load float, float* %64, align 4, !tbaa !18
  %66 = fmul float %17, %65
  %67 = fadd float %63, %66
  %68 = insertelement <4 x float> %52, float %67, i32 3
  ret <4 x float> %68
}

; Function Attrs: nounwind
define <4 x float> @_Z16rsMatrixMultiplyP12rs_matrix4x4Dv3_f(%struct.rs_matrix4x4* %m, <3 x float> %in) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <3 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <3 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = extractelement <3 x float> %in, i32 2
  %13 = fmul float %12, %11
  %14 = fadd float %9, %13
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  %16 = load float, float* %15, align 4, !tbaa !18
  %17 = fadd float %16, %14
  %18 = insertelement <4 x float> undef, float %17, i32 0
  %19 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = fmul float %3, %20
  %22 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = fmul float %7, %23
  %25 = fadd float %21, %24
  %26 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  %27 = load float, float* %26, align 4, !tbaa !18
  %28 = fmul float %12, %27
  %29 = fadd float %25, %28
  %30 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  %31 = load float, float* %30, align 4, !tbaa !18
  %32 = fadd float %31, %29
  %33 = insertelement <4 x float> %18, float %32, i32 1
  %34 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  %35 = load float, float* %34, align 4, !tbaa !18
  %36 = fmul float %3, %35
  %37 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  %38 = load float, float* %37, align 4, !tbaa !18
  %39 = fmul float %7, %38
  %40 = fadd float %36, %39
  %41 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  %42 = load float, float* %41, align 4, !tbaa !18
  %43 = fmul float %12, %42
  %44 = fadd float %40, %43
  %45 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  %46 = load float, float* %45, align 4, !tbaa !18
  %47 = fadd float %46, %44
  %48 = insertelement <4 x float> %33, float %47, i32 2
  %49 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  %50 = load float, float* %49, align 4, !tbaa !18
  %51 = fmul float %3, %50
  %52 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  %53 = load float, float* %52, align 4, !tbaa !18
  %54 = fmul float %7, %53
  %55 = fadd float %51, %54
  %56 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  %57 = load float, float* %56, align 4, !tbaa !18
  %58 = fmul float %12, %57
  %59 = fadd float %55, %58
  %60 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  %61 = load float, float* %60, align 4, !tbaa !18
  %62 = fadd float %61, %59
  %63 = insertelement <4 x float> %48, float %62, i32 3
  ret <4 x float> %63
}

; Function Attrs: nounwind
define <4 x float> @_Z16rsMatrixMultiplyP12rs_matrix4x4Dv2_f(%struct.rs_matrix4x4* %m, <2 x float> %in) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <2 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <2 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = fadd float %11, %9
  %13 = insertelement <4 x float> undef, float %12, i32 0
  %14 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = fmul float %3, %15
  %17 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  %18 = load float, float* %17, align 4, !tbaa !18
  %19 = fmul float %7, %18
  %20 = fadd float %16, %19
  %21 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  %22 = load float, float* %21, align 4, !tbaa !18
  %23 = fadd float %22, %20
  %24 = insertelement <4 x float> %13, float %23, i32 1
  %25 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  %26 = load float, float* %25, align 4, !tbaa !18
  %27 = fmul float %3, %26
  %28 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = fmul float %7, %29
  %31 = fadd float %27, %30
  %32 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  %33 = load float, float* %32, align 4, !tbaa !18
  %34 = fadd float %33, %31
  %35 = insertelement <4 x float> %24, float %34, i32 2
  %36 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  %37 = load float, float* %36, align 4, !tbaa !18
  %38 = fmul float %3, %37
  %39 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  %40 = load float, float* %39, align 4, !tbaa !18
  %41 = fmul float %7, %40
  %42 = fadd float %38, %41
  %43 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  %44 = load float, float* %43, align 4, !tbaa !18
  %45 = fadd float %44, %42
  %46 = insertelement <4 x float> %35, float %45, i32 3
  ret <4 x float> %46
}

; Function Attrs: nounwind
define <3 x float> @_Z16rsMatrixMultiplyP12rs_matrix3x3Dv3_f(%struct.rs_matrix3x3* %m, <3 x float> %in) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <3 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 3
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <3 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 6
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = extractelement <3 x float> %in, i32 2
  %13 = fmul float %12, %11
  %14 = fadd float %9, %13
  %15 = insertelement <3 x float> undef, float %14, i32 0
  %16 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 1
  %17 = load float, float* %16, align 4, !tbaa !18
  %18 = fmul float %3, %17
  %19 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 4
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = fmul float %7, %20
  %22 = fadd float %18, %21
  %23 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 7
  %24 = load float, float* %23, align 4, !tbaa !18
  %25 = fmul float %12, %24
  %26 = fadd float %22, %25
  %27 = insertelement <3 x float> %15, float %26, i32 1
  %28 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 2
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = fmul float %3, %29
  %31 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 5
  %32 = load float, float* %31, align 4, !tbaa !18
  %33 = fmul float %7, %32
  %34 = fadd float %30, %33
  %35 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 8
  %36 = load float, float* %35, align 4, !tbaa !18
  %37 = fmul float %12, %36
  %38 = fadd float %34, %37
  %39 = insertelement <3 x float> %27, float %38, i32 2
  ret <3 x float> %39
}

; Function Attrs: nounwind
define <3 x float> @_Z16rsMatrixMultiplyP12rs_matrix3x3Dv2_f(%struct.rs_matrix3x3* %m, <2 x float> %in) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <2 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 3
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <2 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = insertelement <3 x float> undef, float %9, i32 0
  %11 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 1
  %12 = load float, float* %11, align 4, !tbaa !18
  %13 = fmul float %3, %12
  %14 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 4
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = fmul float %7, %15
  %17 = fadd float %13, %16
  %18 = insertelement <3 x float> %10, float %17, i32 1
  %19 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 2
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = fmul float %3, %20
  %22 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 5
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = fmul float %7, %23
  %25 = fadd float %21, %24
  %26 = insertelement <3 x float> %18, float %25, i32 2
  ret <3 x float> %26
}

; Function Attrs: nounwind
define void @_Z20rsMatrixLoadMultiplyP12rs_matrix4x4PKS_S2_(%struct.rs_matrix4x4* nocapture %ret, %struct.rs_matrix4x4* nocapture %lhs, %struct.rs_matrix4x4* nocapture %rhs) #5 {
  br label %.preheader

.preheader:                                       ; preds = %.preheader, %0
  %i.06 = phi i32 [ 0, %0 ], [ %50, %.preheader ]
  %1 = shl i32 %i.06, 2
  %2 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %1
  %3 = load float, float* %2, align 4, !tbaa !18
  %4 = bitcast %struct.rs_matrix4x4* %lhs to <4 x float>*
  %5 = load <4 x float>, <4 x float>* %4, align 4
  %6 = insertelement <4 x float> undef, float %3, i32 0
  %7 = insertelement <4 x float> %6, float %3, i32 1
  %8 = insertelement <4 x float> %7, float %3, i32 2
  %9 = insertelement <4 x float> %8, float %3, i32 3
  %10 = fmul <4 x float> %9, %5
  %11 = fadd <4 x float> %10, zeroinitializer
  %12 = or i32 %1, 1
  %13 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %12
  %14 = load float, float* %13, align 4, !tbaa !18
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 4
  %16 = bitcast float* %15 to <4 x float>*
  %17 = load <4 x float>, <4 x float>* %16, align 4
  %18 = insertelement <4 x float> undef, float %14, i32 0
  %19 = insertelement <4 x float> %18, float %14, i32 1
  %20 = insertelement <4 x float> %19, float %14, i32 2
  %21 = insertelement <4 x float> %20, float %14, i32 3
  %22 = fmul <4 x float> %21, %17
  %23 = fadd <4 x float> %11, %22
  %24 = or i32 %1, 2
  %25 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %24
  %26 = load float, float* %25, align 4, !tbaa !18
  %27 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 8
  %28 = bitcast float* %27 to <4 x float>*
  %29 = load <4 x float>, <4 x float>* %28, align 4
  %30 = insertelement <4 x float> undef, float %26, i32 0
  %31 = insertelement <4 x float> %30, float %26, i32 1
  %32 = insertelement <4 x float> %31, float %26, i32 2
  %33 = insertelement <4 x float> %32, float %26, i32 3
  %34 = fmul <4 x float> %33, %29
  %35 = fadd <4 x float> %23, %34
  %36 = or i32 %1, 3
  %37 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %36
  %38 = load float, float* %37, align 4, !tbaa !18
  %39 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 12
  %40 = bitcast float* %39 to <4 x float>*
  %41 = load <4 x float>, <4 x float>* %40, align 4
  %42 = insertelement <4 x float> undef, float %38, i32 0
  %43 = insertelement <4 x float> %42, float %38, i32 1
  %44 = insertelement <4 x float> %43, float %38, i32 2
  %45 = insertelement <4 x float> %44, float %38, i32 3
  %46 = fmul <4 x float> %45, %41
  %47 = fadd <4 x float> %35, %46
  %48 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %ret, i32 0, i32 0, i32 %1
  %49 = bitcast float* %48 to <4 x float>*
  store <4 x float> %47, <4 x float>* %49, align 4
  %50 = add nsw i32 %i.06, 1
  %exitcond10 = icmp eq i32 %50, 4
  br i1 %exitcond10, label %51, label %.preheader

; <label>:51                                      ; preds = %.preheader
  ret void
}

; Function Attrs: nounwind
define void @_Z16rsMatrixMultiplyP12rs_matrix4x4PKS_(%struct.rs_matrix4x4* nocapture %lhs, %struct.rs_matrix4x4* nocapture %rhs) #5 {
  %r = alloca %struct.rs_matrix4x4, align 4
  %1 = bitcast %struct.rs_matrix4x4* %r to i8*
  call void @llvm.lifetime.start(i64 64, i8* %1) #2
  %2 = bitcast %struct.rs_matrix4x4* %lhs to <4 x float>*
  %3 = load <4 x float>, <4 x float>* %2, align 4
  %4 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 4
  %5 = bitcast float* %4 to <4 x float>*
  %6 = load <4 x float>, <4 x float>* %5, align 4
  %7 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 8
  %8 = bitcast float* %7 to <4 x float>*
  %9 = load <4 x float>, <4 x float>* %8, align 4
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 12
  %11 = bitcast float* %10 to <4 x float>*
  %12 = load <4 x float>, <4 x float>* %11, align 4
  br label %.preheader.i

.preheader.i:                                     ; preds = %.preheader.i, %0
  %i.06.i = phi i32 [ 0, %0 ], [ %51, %.preheader.i ]
  %13 = shl i32 %i.06.i, 2
  %14 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %13
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = insertelement <4 x float> undef, float %15, i32 0
  %17 = insertelement <4 x float> %16, float %15, i32 1
  %18 = insertelement <4 x float> %17, float %15, i32 2
  %19 = insertelement <4 x float> %18, float %15, i32 3
  %20 = fmul <4 x float> %3, %19
  %21 = fadd <4 x float> %20, zeroinitializer
  %22 = or i32 %13, 1
  %23 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %22
  %24 = load float, float* %23, align 4, !tbaa !18
  %25 = insertelement <4 x float> undef, float %24, i32 0
  %26 = insertelement <4 x float> %25, float %24, i32 1
  %27 = insertelement <4 x float> %26, float %24, i32 2
  %28 = insertelement <4 x float> %27, float %24, i32 3
  %29 = fmul <4 x float> %6, %28
  %30 = fadd <4 x float> %21, %29
  %31 = or i32 %13, 2
  %32 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %31
  %33 = load float, float* %32, align 4, !tbaa !18
  %34 = insertelement <4 x float> undef, float %33, i32 0
  %35 = insertelement <4 x float> %34, float %33, i32 1
  %36 = insertelement <4 x float> %35, float %33, i32 2
  %37 = insertelement <4 x float> %36, float %33, i32 3
  %38 = fmul <4 x float> %9, %37
  %39 = fadd <4 x float> %30, %38
  %40 = or i32 %13, 3
  %41 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %rhs, i32 0, i32 0, i32 %40
  %42 = load float, float* %41, align 4, !tbaa !18
  %43 = insertelement <4 x float> undef, float %42, i32 0
  %44 = insertelement <4 x float> %43, float %42, i32 1
  %45 = insertelement <4 x float> %44, float %42, i32 2
  %46 = insertelement <4 x float> %45, float %42, i32 3
  %47 = fmul <4 x float> %12, %46
  %48 = fadd <4 x float> %39, %47
  %49 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 %13
  %50 = bitcast float* %49 to <4 x float>*
  store <4 x float> %48, <4 x float>* %50, align 4
  %51 = add nsw i32 %i.06.i, 1
  %exitcond10.i = icmp eq i32 %51, 4
  br i1 %exitcond10.i, label %_Z20rsMatrixLoadMultiplyP12rs_matrix4x4PKS_S2_.exit, label %.preheader.i

_Z20rsMatrixLoadMultiplyP12rs_matrix4x4PKS_S2_.exit: ; preds = %.preheader.i
  %52 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 0
  %53 = load float, float* %52, align 4, !tbaa !18
  %54 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 0
  store float %53, float* %54, align 4, !tbaa !18
  %55 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 1
  %56 = load float, float* %55, align 4, !tbaa !18
  %57 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 1
  store float %56, float* %57, align 4, !tbaa !18
  %58 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 2
  %59 = load float, float* %58, align 4, !tbaa !18
  %60 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 2
  store float %59, float* %60, align 4, !tbaa !18
  %61 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 3
  %62 = load float, float* %61, align 4, !tbaa !18
  %63 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 3
  store float %62, float* %63, align 4, !tbaa !18
  %64 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 4
  %65 = load float, float* %64, align 4, !tbaa !18
  store float %65, float* %4, align 4, !tbaa !18
  %66 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 5
  %67 = load float, float* %66, align 4, !tbaa !18
  %68 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 5
  store float %67, float* %68, align 4, !tbaa !18
  %69 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 6
  %70 = load float, float* %69, align 4, !tbaa !18
  %71 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 6
  store float %70, float* %71, align 4, !tbaa !18
  %72 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 7
  %73 = load float, float* %72, align 4, !tbaa !18
  %74 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 7
  store float %73, float* %74, align 4, !tbaa !18
  %75 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 8
  %76 = load float, float* %75, align 4, !tbaa !18
  store float %76, float* %7, align 4, !tbaa !18
  %77 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 9
  %78 = load float, float* %77, align 4, !tbaa !18
  %79 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 9
  store float %78, float* %79, align 4, !tbaa !18
  %80 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 10
  %81 = load float, float* %80, align 4, !tbaa !18
  %82 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 10
  store float %81, float* %82, align 4, !tbaa !18
  %83 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 11
  %84 = load float, float* %83, align 4, !tbaa !18
  %85 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 11
  store float %84, float* %85, align 4, !tbaa !18
  %86 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 12
  %87 = load float, float* %86, align 4, !tbaa !18
  store float %87, float* %10, align 4, !tbaa !18
  %88 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 13
  %89 = load float, float* %88, align 4, !tbaa !18
  %90 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 13
  store float %89, float* %90, align 4, !tbaa !18
  %91 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 14
  %92 = load float, float* %91, align 4, !tbaa !18
  %93 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 14
  store float %92, float* %93, align 4, !tbaa !18
  %94 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %r, i32 0, i32 0, i32 15
  %95 = load float, float* %94, align 4, !tbaa !18
  %96 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %lhs, i32 0, i32 0, i32 15
  store float %95, float* %96, align 4, !tbaa !18
  call void @llvm.lifetime.end(i64 64, i8* %1) #2
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #2

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #2

; Function Attrs: nounwind
define void @_Z20rsMatrixLoadMultiplyP12rs_matrix3x3PKS_S2_(%struct.rs_matrix3x3* nocapture %ret, %struct.rs_matrix3x3* nocapture %lhs, %struct.rs_matrix3x3* nocapture %rhs) #5 {
.preheader:
  %0 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 0
  %1 = load float, float* %0, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 0
  %3 = load float, float* %2, align 4, !tbaa !18
  %4 = fmul float %1, %3
  %5 = fadd float %4, 0.000000e+00
  %6 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 1
  %7 = load float, float* %6, align 4, !tbaa !18
  %8 = fmul float %1, %7
  %9 = fadd float %8, 0.000000e+00
  %10 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 2
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = fmul float %1, %11
  %13 = fadd float %12, 0.000000e+00
  %14 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 1
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 3
  %17 = load float, float* %16, align 4, !tbaa !18
  %18 = fmul float %15, %17
  %19 = fadd float %5, %18
  %20 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 4
  %21 = load float, float* %20, align 4, !tbaa !18
  %22 = fmul float %15, %21
  %23 = fadd float %9, %22
  %24 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 5
  %25 = load float, float* %24, align 4, !tbaa !18
  %26 = fmul float %15, %25
  %27 = fadd float %13, %26
  %28 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 2
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 6
  %31 = load float, float* %30, align 4, !tbaa !18
  %32 = fmul float %29, %31
  %33 = fadd float %19, %32
  %34 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 7
  %35 = load float, float* %34, align 4, !tbaa !18
  %36 = fmul float %29, %35
  %37 = fadd float %23, %36
  %38 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 8
  %39 = load float, float* %38, align 4, !tbaa !18
  %40 = fmul float %29, %39
  %41 = fadd float %27, %40
  %42 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 0
  store float %33, float* %42, align 4, !tbaa !18
  %43 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 1
  store float %37, float* %43, align 4, !tbaa !18
  %44 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 2
  store float %41, float* %44, align 4, !tbaa !18
  %45 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 3
  %46 = load float, float* %45, align 4, !tbaa !18
  %47 = load float, float* %2, align 4, !tbaa !18
  %48 = fmul float %46, %47
  %49 = fadd float %48, 0.000000e+00
  %50 = load float, float* %6, align 4, !tbaa !18
  %51 = fmul float %46, %50
  %52 = fadd float %51, 0.000000e+00
  %53 = load float, float* %10, align 4, !tbaa !18
  %54 = fmul float %46, %53
  %55 = fadd float %54, 0.000000e+00
  %56 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 4
  %57 = load float, float* %56, align 4, !tbaa !18
  %58 = load float, float* %16, align 4, !tbaa !18
  %59 = fmul float %57, %58
  %60 = fadd float %49, %59
  %61 = load float, float* %20, align 4, !tbaa !18
  %62 = fmul float %57, %61
  %63 = fadd float %52, %62
  %64 = load float, float* %24, align 4, !tbaa !18
  %65 = fmul float %57, %64
  %66 = fadd float %55, %65
  %67 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 5
  %68 = load float, float* %67, align 4, !tbaa !18
  %69 = load float, float* %30, align 4, !tbaa !18
  %70 = fmul float %68, %69
  %71 = fadd float %60, %70
  %72 = load float, float* %34, align 4, !tbaa !18
  %73 = fmul float %68, %72
  %74 = fadd float %63, %73
  %75 = load float, float* %38, align 4, !tbaa !18
  %76 = fmul float %68, %75
  %77 = fadd float %66, %76
  %78 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 3
  store float %71, float* %78, align 4, !tbaa !18
  %79 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 4
  store float %74, float* %79, align 4, !tbaa !18
  %80 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 5
  store float %77, float* %80, align 4, !tbaa !18
  %81 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 6
  %82 = load float, float* %81, align 4, !tbaa !18
  %83 = load float, float* %2, align 4, !tbaa !18
  %84 = fmul float %82, %83
  %85 = fadd float %84, 0.000000e+00
  %86 = load float, float* %6, align 4, !tbaa !18
  %87 = fmul float %82, %86
  %88 = fadd float %87, 0.000000e+00
  %89 = load float, float* %10, align 4, !tbaa !18
  %90 = fmul float %82, %89
  %91 = fadd float %90, 0.000000e+00
  %92 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 7
  %93 = load float, float* %92, align 4, !tbaa !18
  %94 = load float, float* %16, align 4, !tbaa !18
  %95 = fmul float %93, %94
  %96 = fadd float %85, %95
  %97 = load float, float* %20, align 4, !tbaa !18
  %98 = fmul float %93, %97
  %99 = fadd float %88, %98
  %100 = load float, float* %24, align 4, !tbaa !18
  %101 = fmul float %93, %100
  %102 = fadd float %91, %101
  %103 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 8
  %104 = load float, float* %103, align 4, !tbaa !18
  %105 = load float, float* %30, align 4, !tbaa !18
  %106 = fmul float %104, %105
  %107 = fadd float %96, %106
  %108 = load float, float* %34, align 4, !tbaa !18
  %109 = fmul float %104, %108
  %110 = fadd float %99, %109
  %111 = load float, float* %38, align 4, !tbaa !18
  %112 = fmul float %104, %111
  %113 = fadd float %102, %112
  %114 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 6
  store float %107, float* %114, align 4, !tbaa !18
  %115 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 7
  store float %110, float* %115, align 4, !tbaa !18
  %116 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %ret, i32 0, i32 0, i32 8
  store float %113, float* %116, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z16rsMatrixMultiplyP12rs_matrix3x3PKS_(%struct.rs_matrix3x3* nocapture %lhs, %struct.rs_matrix3x3* nocapture %rhs) #5 {
  %r = alloca %struct.rs_matrix3x3, align 4
  %1 = bitcast %struct.rs_matrix3x3* %r to i8*
  call void @llvm.lifetime.start(i64 36, i8* %1) #2
  %2 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 0
  %3 = load float, float* %2, align 4, !tbaa !18
  %4 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 0
  %5 = load float, float* %4, align 4, !tbaa !18
  %6 = fmul float %3, %5
  %7 = fadd float %6, 0.000000e+00
  %8 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 1
  %9 = load float, float* %8, align 4, !tbaa !18
  %10 = fmul float %3, %9
  %11 = fadd float %10, 0.000000e+00
  %12 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 2
  %13 = load float, float* %12, align 4, !tbaa !18
  %14 = fmul float %3, %13
  %15 = fadd float %14, 0.000000e+00
  %16 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 1
  %17 = load float, float* %16, align 4, !tbaa !18
  %18 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 3
  %19 = load float, float* %18, align 4, !tbaa !18
  %20 = fmul float %17, %19
  %21 = fadd float %7, %20
  %22 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 4
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = fmul float %17, %23
  %25 = fadd float %11, %24
  %26 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 5
  %27 = load float, float* %26, align 4, !tbaa !18
  %28 = fmul float %17, %27
  %29 = fadd float %15, %28
  %30 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 2
  %31 = load float, float* %30, align 4, !tbaa !18
  %32 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 6
  %33 = load float, float* %32, align 4, !tbaa !18
  %34 = fmul float %31, %33
  %35 = fadd float %21, %34
  %36 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 7
  %37 = load float, float* %36, align 4, !tbaa !18
  %38 = fmul float %31, %37
  %39 = fadd float %25, %38
  %40 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 8
  %41 = load float, float* %40, align 4, !tbaa !18
  %42 = fmul float %31, %41
  %43 = fadd float %29, %42
  %44 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 0
  store float %35, float* %44, align 4, !tbaa !18
  %45 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 1
  store float %39, float* %45, align 4, !tbaa !18
  %46 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 2
  store float %43, float* %46, align 4, !tbaa !18
  %47 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 3
  %48 = load float, float* %47, align 4, !tbaa !18
  %49 = load float, float* %4, align 4, !tbaa !18
  %50 = fmul float %48, %49
  %51 = fadd float %50, 0.000000e+00
  %52 = load float, float* %8, align 4, !tbaa !18
  %53 = fmul float %48, %52
  %54 = fadd float %53, 0.000000e+00
  %55 = load float, float* %12, align 4, !tbaa !18
  %56 = fmul float %48, %55
  %57 = fadd float %56, 0.000000e+00
  %58 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 4
  %59 = load float, float* %58, align 4, !tbaa !18
  %60 = load float, float* %18, align 4, !tbaa !18
  %61 = fmul float %59, %60
  %62 = fadd float %51, %61
  %63 = load float, float* %22, align 4, !tbaa !18
  %64 = fmul float %59, %63
  %65 = fadd float %54, %64
  %66 = load float, float* %26, align 4, !tbaa !18
  %67 = fmul float %59, %66
  %68 = fadd float %57, %67
  %69 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 5
  %70 = load float, float* %69, align 4, !tbaa !18
  %71 = load float, float* %32, align 4, !tbaa !18
  %72 = fmul float %70, %71
  %73 = fadd float %62, %72
  %74 = load float, float* %36, align 4, !tbaa !18
  %75 = fmul float %70, %74
  %76 = fadd float %65, %75
  %77 = load float, float* %40, align 4, !tbaa !18
  %78 = fmul float %70, %77
  %79 = fadd float %68, %78
  %80 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 3
  store float %73, float* %80, align 4, !tbaa !18
  %81 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 4
  store float %76, float* %81, align 4, !tbaa !18
  %82 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 5
  store float %79, float* %82, align 4, !tbaa !18
  %83 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 6
  %84 = load float, float* %83, align 4, !tbaa !18
  %85 = load float, float* %4, align 4, !tbaa !18
  %86 = fmul float %84, %85
  %87 = fadd float %86, 0.000000e+00
  %88 = load float, float* %8, align 4, !tbaa !18
  %89 = fmul float %84, %88
  %90 = fadd float %89, 0.000000e+00
  %91 = load float, float* %12, align 4, !tbaa !18
  %92 = fmul float %84, %91
  %93 = fadd float %92, 0.000000e+00
  %94 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 7
  %95 = load float, float* %94, align 4, !tbaa !18
  %96 = load float, float* %18, align 4, !tbaa !18
  %97 = fmul float %95, %96
  %98 = fadd float %87, %97
  %99 = load float, float* %22, align 4, !tbaa !18
  %100 = fmul float %95, %99
  %101 = fadd float %90, %100
  %102 = load float, float* %26, align 4, !tbaa !18
  %103 = fmul float %95, %102
  %104 = fadd float %93, %103
  %105 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %rhs, i32 0, i32 0, i32 8
  %106 = load float, float* %105, align 4, !tbaa !18
  %107 = load float, float* %32, align 4, !tbaa !18
  %108 = fmul float %106, %107
  %109 = fadd float %98, %108
  %110 = load float, float* %36, align 4, !tbaa !18
  %111 = fmul float %106, %110
  %112 = fadd float %101, %111
  %113 = load float, float* %40, align 4, !tbaa !18
  %114 = fmul float %106, %113
  %115 = fadd float %104, %114
  %116 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 6
  store float %109, float* %116, align 4, !tbaa !18
  %117 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 7
  store float %112, float* %117, align 4, !tbaa !18
  %118 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 8
  store float %115, float* %118, align 4, !tbaa !18
  %119 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 0
  %120 = load float, float* %119, align 4, !tbaa !18
  %121 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 0
  store float %120, float* %121, align 4, !tbaa !18
  %122 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 1
  %123 = load float, float* %122, align 4, !tbaa !18
  %124 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 1
  store float %123, float* %124, align 4, !tbaa !18
  %125 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 2
  %126 = load float, float* %125, align 4, !tbaa !18
  %127 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 2
  store float %126, float* %127, align 4, !tbaa !18
  %128 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 3
  %129 = load float, float* %128, align 4, !tbaa !18
  %130 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 3
  store float %129, float* %130, align 4, !tbaa !18
  %131 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 4
  %132 = load float, float* %131, align 4, !tbaa !18
  %133 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 4
  store float %132, float* %133, align 4, !tbaa !18
  %134 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 5
  %135 = load float, float* %134, align 4, !tbaa !18
  %136 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 5
  store float %135, float* %136, align 4, !tbaa !18
  %137 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 6
  %138 = load float, float* %137, align 4, !tbaa !18
  %139 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 6
  store float %138, float* %139, align 4, !tbaa !18
  %140 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 7
  %141 = load float, float* %140, align 4, !tbaa !18
  %142 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 7
  store float %141, float* %142, align 4, !tbaa !18
  %143 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %r, i32 0, i32 0, i32 8
  %144 = load float, float* %143, align 4, !tbaa !18
  %145 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %lhs, i32 0, i32 0, i32 8
  store float %144, float* %145, align 4, !tbaa !18
  call void @llvm.lifetime.end(i64 36, i8* %1) #2
  ret void
}

; Function Attrs: nounwind
define void @_Z20rsMatrixLoadMultiplyP12rs_matrix2x2PKS_S2_(%struct.rs_matrix2x2* nocapture %ret, %struct.rs_matrix2x2* nocapture %lhs, %struct.rs_matrix2x2* nocapture %rhs) #5 {
.preheader:
  %0 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 0
  %1 = load float, float* %0, align 4, !tbaa !18
  %2 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 0
  %3 = load float, float* %2, align 4, !tbaa !18
  %4 = fmul float %1, %3
  %5 = fadd float %4, 0.000000e+00
  %6 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 1
  %7 = load float, float* %6, align 4, !tbaa !18
  %8 = fmul float %1, %7
  %9 = fadd float %8, 0.000000e+00
  %10 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 1
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 2
  %13 = load float, float* %12, align 4, !tbaa !18
  %14 = fmul float %11, %13
  %15 = fadd float %5, %14
  %16 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 3
  %17 = load float, float* %16, align 4, !tbaa !18
  %18 = fmul float %11, %17
  %19 = fadd float %9, %18
  %20 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %ret, i32 0, i32 0, i32 0
  store float %15, float* %20, align 4, !tbaa !18
  %21 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %ret, i32 0, i32 0, i32 1
  store float %19, float* %21, align 4, !tbaa !18
  %22 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 2
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = load float, float* %2, align 4, !tbaa !18
  %25 = fmul float %23, %24
  %26 = fadd float %25, 0.000000e+00
  %27 = load float, float* %6, align 4, !tbaa !18
  %28 = fmul float %23, %27
  %29 = fadd float %28, 0.000000e+00
  %30 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 3
  %31 = load float, float* %30, align 4, !tbaa !18
  %32 = load float, float* %12, align 4, !tbaa !18
  %33 = fmul float %31, %32
  %34 = fadd float %26, %33
  %35 = load float, float* %16, align 4, !tbaa !18
  %36 = fmul float %31, %35
  %37 = fadd float %29, %36
  %38 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %ret, i32 0, i32 0, i32 2
  store float %34, float* %38, align 4, !tbaa !18
  %39 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %ret, i32 0, i32 0, i32 3
  store float %37, float* %39, align 4, !tbaa !18
  ret void
}

; Function Attrs: nounwind
define void @_Z16rsMatrixMultiplyP12rs_matrix2x2PKS_(%struct.rs_matrix2x2* nocapture %lhs, %struct.rs_matrix2x2* nocapture %rhs) #5 {
  %1 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 0
  %4 = load float, float* %3, align 4, !tbaa !18
  %5 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 1
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 1
  %8 = load float, float* %7, align 4, !tbaa !18
  %9 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 2
  %10 = load float, float* %9, align 4, !tbaa !18
  %11 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %lhs, i32 0, i32 0, i32 3
  %12 = load float, float* %11, align 4, !tbaa !18
  %13 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 2
  %14 = load float, float* %13, align 4, !tbaa !18
  %15 = insertelement <4 x float> undef, float %2, i32 0
  %16 = insertelement <4 x float> %15, float %2, i32 1
  %17 = insertelement <4 x float> %16, float %4, i32 2
  %18 = insertelement <4 x float> %17, float %6, i32 3
  %19 = insertelement <4 x float> undef, float %4, i32 0
  %20 = insertelement <4 x float> %19, float %6, i32 1
  %21 = insertelement <4 x float> %20, float %14, i32 2
  %22 = insertelement <4 x float> %21, float %14, i32 3
  %23 = fmul <4 x float> %18, %22
  %24 = fadd <4 x float> %23, zeroinitializer
  %25 = getelementptr inbounds %struct.rs_matrix2x2, %struct.rs_matrix2x2* %rhs, i32 0, i32 0, i32 3
  %26 = load float, float* %25, align 4, !tbaa !18
  %27 = insertelement <4 x float> undef, float %8, i32 0
  %28 = insertelement <4 x float> %27, float %8, i32 1
  %29 = insertelement <4 x float> %28, float %10, i32 2
  %30 = insertelement <4 x float> %29, float %12, i32 3
  %31 = insertelement <4 x float> undef, float %10, i32 0
  %32 = insertelement <4 x float> %31, float %12, i32 1
  %33 = insertelement <4 x float> %32, float %26, i32 2
  %34 = insertelement <4 x float> %33, float %26, i32 3
  %35 = fmul <4 x float> %30, %34
  %36 = fadd <4 x float> %24, %35
  %37 = bitcast %struct.rs_matrix2x2* %lhs to <4 x float>*
  store <4 x float> %36, <4 x float>* %37, align 4
  ret void
}

; Function Attrs: nounwind readonly
define i32 @_Z27rsgProgramStoreGetDepthFunc16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 8
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define zeroext i1 @_Z33rsgProgramStoreIsDepthMaskEnabled16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %8, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 7
  %6 = load i8, i8* %5, align 1, !tbaa !23, !range !24
  %7 = icmp ne i8 %6, 0
  br label %8

; <label>:8                                       ; preds = %3, %0
  %.0 = phi i1 [ %7, %3 ], [ false, %0 ]
  ret i1 %.0
}

; Function Attrs: nounwind readonly
define zeroext i1 @_Z36rsgProgramStoreIsColorMaskRedEnabled16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %8, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 1
  %6 = load i8, i8* %5, align 1, !tbaa !23, !range !24
  %7 = icmp ne i8 %6, 0
  br label %8

; <label>:8                                       ; preds = %3, %0
  %.0 = phi i1 [ %7, %3 ], [ false, %0 ]
  ret i1 %.0
}

; Function Attrs: nounwind readonly
define zeroext i1 @_Z38rsgProgramStoreIsColorMaskGreenEnabled16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %8, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 2
  %6 = load i8, i8* %5, align 1, !tbaa !23, !range !24
  %7 = icmp ne i8 %6, 0
  br label %8

; <label>:8                                       ; preds = %3, %0
  %.0 = phi i1 [ %7, %3 ], [ false, %0 ]
  ret i1 %.0
}

; Function Attrs: nounwind readonly
define zeroext i1 @_Z37rsgProgramStoreIsColorMaskBlueEnabled16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %8, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 3
  %6 = load i8, i8* %5, align 1, !tbaa !23, !range !24
  %7 = icmp ne i8 %6, 0
  br label %8

; <label>:8                                       ; preds = %3, %0
  %.0 = phi i1 [ %7, %3 ], [ false, %0 ]
  ret i1 %.0
}

; Function Attrs: nounwind readonly
define zeroext i1 @_Z38rsgProgramStoreIsColorMaskAlphaEnabled16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %8, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 4
  %6 = load i8, i8* %5, align 1, !tbaa !23, !range !24
  %7 = icmp ne i8 %6, 0
  br label %8

; <label>:8                                       ; preds = %3, %0
  %.0 = phi i1 [ %7, %3 ], [ false, %0 ]
  ret i1 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z30rsgProgramStoreGetBlendSrcFunc16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z30rsgProgramStoreGetBlendDstFunc16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 6
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define zeroext i1 @_Z30rsgProgramStoreIsDitherEnabled16rs_program_store([1 x i32] %ps.coerce) #4 {
  %1 = extractvalue [1 x i32] %ps.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %8, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramStore*
  %5 = getelementptr inbounds %struct.ProgramStore, %struct.ProgramStore* %4, i32 0, i32 1, i32 0, i32 0
  %6 = load i8, i8* %5, align 1, !tbaa !23, !range !24
  %7 = icmp ne i8 %6, 0
  br label %8

; <label>:8                                       ; preds = %3, %0
  %.0 = phi i1 [ %7, %3 ], [ false, %0 ]
  ret i1 %.0
}

; Function Attrs: nounwind readonly
define zeroext i1 @_Z36rsgProgramRasterIsPointSpriteEnabled17rs_program_raster([1 x i32] %pr.coerce) #4 {
  %1 = extractvalue [1 x i32] %pr.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %8, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramRaster*
  %5 = getelementptr inbounds %struct.ProgramRaster, %struct.ProgramRaster* %4, i32 0, i32 1, i32 1, i32 0
  %6 = load i8, i8* %5, align 1, !tbaa !23, !range !24
  %7 = icmp ne i8 %6, 0
  br label %8

; <label>:8                                       ; preds = %3, %0
  %.0 = phi i1 [ %7, %3 ], [ false, %0 ]
  ret i1 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z27rsgProgramRasterGetCullMode17rs_program_raster([1 x i32] %pr.coerce) #4 {
  %1 = extractvalue [1 x i32] %pr.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.ProgramRaster*
  %5 = getelementptr inbounds %struct.ProgramRaster, %struct.ProgramRaster* %4, i32 0, i32 1, i32 1, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z8rsSample13rs_allocation10rs_samplerff([1 x i32] %a.coerce, [1 x i32] %s.coerce, float %uv, float %lod) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = extractvalue [1 x i32] %s.coerce, 0
  %3 = inttoptr i32 %1 to %struct.Allocation*
  %4 = inttoptr i32 %2 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 0
  %6 = load i8*, i8** %5, align 4, !tbaa !22
  %7 = getelementptr inbounds i8, i8* %6, i32 36
  %8 = bitcast i8* %7 to i8**
  %9 = load i8*, i8** %8, align 4, !tbaa !22
  %10 = getelementptr inbounds i8, i8* %9, i32 36
  %11 = getelementptr inbounds i8, i8* %9, i32 40
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12, align 4, !tbaa !19
  %14 = bitcast i8* %10 to i32*
  %15 = load i32, i32* %14, align 4, !tbaa !19
  %16 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 1
  %17 = load i32, i32* %16, align 4, !tbaa !19
  %18 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 0
  %19 = load i32, i32* %18, align 4, !tbaa !19
  %20 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 2
  %21 = load i32, i32* %20, align 4, !tbaa !19
  %22 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 1
  %23 = load i32, i32* %22, align 4, !tbaa !21
  %24 = and i32 %23, 2
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %1143, label %26

; <label>:26                                      ; preds = %0
  %27 = fcmp ugt float %lod, 0.000000e+00
  br i1 %27, label %349, label %28

; <label>:28                                      ; preds = %26
  %29 = icmp eq i32 %19, 0
  br i1 %29, label %30, label %127

; <label>:30                                      ; preds = %28
  %31 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %32 = load i32, i32* %31, align 4, !tbaa !21
  %33 = sitofp i32 %32 to float
  %34 = fmul float %33, %uv
  %35 = fptosi float %34 to i32
  switch i32 %21, label %wrapI.exit.i [
    i32 3, label %.thread.i.i
    i32 6, label %39
  ]

.thread.i.i:                                      ; preds = %30
  %36 = srem i32 %35, %32
  %37 = icmp slt i32 %36, 0
  %38 = select i1 %37, i32 %32, i32 0
  %..i.i = add nsw i32 %38, %36
  br label %wrapI.exit.i

; <label>:39                                      ; preds = %30
  %40 = shl nsw i32 %32, 1
  %41 = srem i32 %35, %40
  %42 = icmp slt i32 %41, 0
  %43 = select i1 %42, i32 %40, i32 0
  %.3.i.i = add nsw i32 %43, %41
  %44 = icmp slt i32 %.3.i.i, %32
  %45 = sub nsw i32 %40, %.3.i.i
  %.3..i.i = select i1 %44, i32 %.3.i.i, i32 %45
  br label %wrapI.exit.i

wrapI.exit.i:                                     ; preds = %39, %.thread.i.i, %30
  %.2.i.i = phi i32 [ %.3..i.i, %39 ], [ %..i.i, %.thread.i.i ], [ %35, %30 ]
  %46 = add nsw i32 %32, -1
  %47 = icmp slt i32 %.2.i.i, %46
  %48 = select i1 %47, i32 %.2.i.i, i32 %46
  %49 = icmp sgt i32 0, %48
  %50 = select i1 %49, i32 0, i32 %48
  %alloc.idx.i = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %alloc.idx.val.i = load i8*, i8** %alloc.idx.i, align 4, !tbaa !22
  switch i32 %13, label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit [
    i32 11, label %51
    i32 8, label %57
    i32 9, label %62
    i32 10, label %76
    i32 7, label %119
  ]

; <label>:51                                      ; preds = %wrapI.exit.i
  %52 = shl nsw i32 %50, 2
  %53 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %52
  %54 = bitcast i8* %53 to <4 x i8>*
  %55 = load <4 x i8>, <4 x i8>* %54, align 4, !tbaa !19
  %56 = uitofp <4 x i8> %55 to <4 x float>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:57                                      ; preds = %wrapI.exit.i
  %58 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %50
  %59 = load i8, i8* %58, align 1, !tbaa !19
  %60 = uitofp i8 %59 to float
  %61 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %60, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:62                                      ; preds = %wrapI.exit.i
  %63 = shl nsw i32 %50, 1
  %64 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %63
  %65 = load i8, i8* %64, align 1, !tbaa !19
  %66 = uitofp i8 %65 to float
  %67 = insertelement <2 x float> undef, float %66, i32 0
  %68 = or i32 %63, 1
  %69 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %68
  %70 = load i8, i8* %69, align 1, !tbaa !19
  %71 = uitofp i8 %70 to float
  %72 = insertelement <2 x float> %67, float %71, i32 1
  %73 = shufflevector <2 x float> %72, <2 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 1>
  %74 = shufflevector <2 x float> %72, <2 x float> undef, <4 x i32> <i32 0, i32 0, i32 undef, i32 undef>
  %75 = shufflevector <4 x float> %73, <4 x float> %74, <4 x i32> <i32 4, i32 5, i32 2, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:76                                      ; preds = %wrapI.exit.i
  %77 = icmp eq i32 %15, 13
  br i1 %77, label %78, label %102

; <label>:78                                      ; preds = %76
  %79 = bitcast i8* %alloc.idx.val.i to i16*
  %80 = load i16, i16* %79, align 2, !tbaa !70
  %81 = zext i16 %80 to i32
  %82 = lshr i32 %81, 11
  %83 = shl nuw nsw i32 %82, 3
  %84 = lshr i32 %81, 13
  %85 = or i32 %83, %84
  %86 = uitofp i32 %85 to float
  %87 = insertelement <4 x float> undef, float %86, i32 0
  %88 = lshr i32 %81, 5
  %89 = and i32 %88, 63
  %90 = shl nuw nsw i32 %89, 2
  %91 = lshr i32 %89, 4
  %92 = or i32 %90, %91
  %93 = uitofp i32 %92 to float
  %94 = insertelement <4 x float> %87, float %93, i32 1
  %95 = and i32 %81, 31
  %96 = shl nuw nsw i32 %95, 3
  %97 = lshr i32 %95, 2
  %98 = or i32 %96, %97
  %99 = uitofp i32 %98 to float
  %100 = insertelement <4 x float> %94, float %99, i32 2
  %101 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %100, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:102                                     ; preds = %76
  %103 = shl nsw i32 %50, 2
  %104 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %103
  %105 = load i8, i8* %104, align 1, !tbaa !19
  %106 = uitofp i8 %105 to float
  %107 = insertelement <4 x float> undef, float %106, i32 0
  %108 = or i32 %103, 1
  %109 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %108
  %110 = load i8, i8* %109, align 1, !tbaa !19
  %111 = uitofp i8 %110 to float
  %112 = insertelement <4 x float> %107, float %111, i32 1
  %113 = or i32 %103, 2
  %114 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %113
  %115 = load i8, i8* %114, align 1, !tbaa !19
  %116 = uitofp i8 %115 to float
  %117 = insertelement <4 x float> %112, float %116, i32 2
  %118 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %117, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:119                                     ; preds = %wrapI.exit.i
  %120 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %50
  %121 = load i8, i8* %120, align 1, !tbaa !19
  %122 = uitofp i8 %121 to float
  %123 = insertelement <3 x float> undef, float %122, i32 0
  %124 = shufflevector <3 x float> %123, <3 x float> undef, <4 x i32> <i32 0, i32 0, i32 0, i32 undef>
  %125 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %124, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit: ; preds = %wrapI.exit.i, %51, %57, %62, %78, %102, %119
  %result.0.i.i = phi <4 x float> [ <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 2.550000e+02>, %wrapI.exit.i ], [ %125, %119 ], [ %101, %78 ], [ %118, %102 ], [ %75, %62 ], [ %61, %57 ], [ %56, %51 ]
  %126 = fmul <4 x float> %result.0.i.i, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %1143

; <label>:127                                     ; preds = %28
  %128 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %129 = load i32, i32* %128, align 4, !tbaa !21
  %130 = sitofp i32 %129 to float
  %131 = fmul float %130, %uv
  %132 = fptosi float %131 to i32
  %133 = sitofp i32 %132 to float
  %134 = fsub float %131, %133
  %135 = fcmp olt float %134, 5.000000e-01
  br i1 %135, label %136, label %139

; <label>:136                                     ; preds = %127
  %137 = add nsw i32 %132, -1
  %138 = fadd float %134, 5.000000e-01
  br label %141

; <label>:139                                     ; preds = %127
  %140 = fadd float %134, -5.000000e-01
  br label %141

; <label>:141                                     ; preds = %139, %136
  %frac.0.i45 = phi float [ %138, %136 ], [ %140, %139 ]
  %iPixel.0.i46 = phi i32 [ %137, %136 ], [ %132, %139 ]
  %142 = fsub float 1.000000e+00, %frac.0.i45
  %143 = insertelement <2 x float> undef, float %142, i32 0
  %144 = insertelement <2 x float> %143, float %frac.0.i45, i32 1
  %145 = add nsw i32 %iPixel.0.i46, 1
  switch i32 %21, label %wrapI.exit.i55 [
    i32 3, label %wrapI.exit.thread.i49
    i32 6, label %wrapI.exit.thread7.i54
  ]

wrapI.exit.thread.i49:                            ; preds = %141
  %146 = srem i32 %145, %129
  %147 = icmp slt i32 %146, 0
  %148 = select i1 %147, i32 %129, i32 0
  %..i.i47 = add nsw i32 %148, %146
  %149 = add nsw i32 %129, -1
  %150 = icmp slt i32 %..i.i47, %149
  %151 = select i1 %150, i32 %..i.i47, i32 %149
  %152 = icmp sgt i32 0, %151
  %153 = select i1 %152, i32 0, i32 %151
  %154 = srem i32 %iPixel.0.i46, %129
  %155 = icmp slt i32 %154, 0
  %156 = select i1 %155, i32 %129, i32 0
  %..i1.i48 = add nsw i32 %156, %154
  br label %wrapI.exit6.i57

wrapI.exit.thread7.i54:                           ; preds = %141
  %157 = shl nsw i32 %129, 1
  %158 = srem i32 %145, %157
  %159 = icmp slt i32 %158, 0
  %160 = select i1 %159, i32 %157, i32 0
  %.3.i.i50 = add nsw i32 %160, %158
  %161 = icmp slt i32 %.3.i.i50, %129
  %162 = sub nsw i32 %157, %.3.i.i50
  %.3..i.i51 = select i1 %161, i32 %.3.i.i50, i32 %162
  %163 = add nsw i32 %129, -1
  %164 = icmp slt i32 %.3..i.i51, %163
  %165 = select i1 %164, i32 %.3..i.i51, i32 %163
  %166 = icmp sgt i32 0, %165
  %167 = select i1 %166, i32 0, i32 %165
  %168 = srem i32 %iPixel.0.i46, %157
  %169 = icmp slt i32 %168, 0
  %170 = select i1 %169, i32 %157, i32 0
  %.3.i3.i52 = add nsw i32 %170, %168
  %171 = icmp slt i32 %.3.i3.i52, %129
  %172 = sub nsw i32 %157, %.3.i3.i52
  %.3..i4.i53 = select i1 %171, i32 %.3.i3.i52, i32 %172
  br label %wrapI.exit6.i57

wrapI.exit.i55:                                   ; preds = %141
  %173 = add nsw i32 %129, -1
  %174 = icmp slt i32 %145, %173
  %175 = select i1 %174, i32 %145, i32 %173
  %176 = icmp sgt i32 0, %175
  %177 = select i1 %176, i32 0, i32 %175
  br label %wrapI.exit6.i57

wrapI.exit6.i57:                                  ; preds = %wrapI.exit.i55, %wrapI.exit.thread7.i54, %wrapI.exit.thread.i49
  %178 = phi i32 [ %167, %wrapI.exit.thread7.i54 ], [ %153, %wrapI.exit.thread.i49 ], [ %177, %wrapI.exit.i55 ]
  %179 = phi i32 [ %163, %wrapI.exit.thread7.i54 ], [ %149, %wrapI.exit.thread.i49 ], [ %173, %wrapI.exit.i55 ]
  %.2.i5.i56 = phi i32 [ %.3..i4.i53, %wrapI.exit.thread7.i54 ], [ %..i1.i48, %wrapI.exit.thread.i49 ], [ %iPixel.0.i46, %wrapI.exit.i55 ]
  %180 = icmp slt i32 %.2.i5.i56, %179
  %181 = select i1 %180, i32 %.2.i5.i56, i32 %179
  %182 = icmp sgt i32 0, %181
  %183 = select i1 %182, i32 0, i32 %181
  %184 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %185 = load i8*, i8** %184, align 4, !tbaa !22
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59 [
    i32 11, label %186
    i32 8, label %205
    i32 10, label %217
    i32 7, label %301
    i32 9, label %316
  ]

; <label>:186                                     ; preds = %wrapI.exit6.i57
  %187 = shl nsw i32 %183, 2
  %188 = getelementptr inbounds i8, i8* %185, i32 %187
  %189 = bitcast i8* %188 to <4 x i8>*
  %190 = load <4 x i8>, <4 x i8>* %189, align 4, !tbaa !19
  %191 = uitofp <4 x i8> %190 to <4 x float>
  %192 = shl nsw i32 %178, 2
  %193 = getelementptr inbounds i8, i8* %185, i32 %192
  %194 = bitcast i8* %193 to <4 x i8>*
  %195 = load <4 x i8>, <4 x i8>* %194, align 4, !tbaa !19
  %196 = uitofp <4 x i8> %195 to <4 x float>
  %197 = insertelement <4 x float> undef, float %142, i32 0
  %198 = shufflevector <4 x float> %197, <4 x float> undef, <4 x i32> zeroinitializer
  %199 = fmul <4 x float> %198, %191
  %200 = insertelement <4 x float> undef, float %frac.0.i45, i32 0
  %201 = shufflevector <4 x float> %200, <4 x float> undef, <4 x i32> zeroinitializer
  %202 = fmul <4 x float> %201, %196
  %203 = fadd <4 x float> %199, %202
  %204 = fmul <4 x float> %203, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59

; <label>:205                                     ; preds = %wrapI.exit6.i57
  %206 = getelementptr inbounds i8, i8* %185, i32 %183
  %207 = load i8, i8* %206, align 1, !tbaa !19
  %208 = uitofp i8 %207 to float
  %209 = getelementptr inbounds i8, i8* %185, i32 %178
  %210 = load i8, i8* %209, align 1, !tbaa !19
  %211 = uitofp i8 %210 to float
  %212 = fmul float %142, %208
  %213 = fmul float %frac.0.i45, %211
  %214 = fadd float %212, %213
  %215 = fmul float %214, 0x3F70101020000000
  %216 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %215, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59

; <label>:217                                     ; preds = %wrapI.exit6.i57
  %218 = icmp eq i32 %15, 13
  br i1 %218, label %219, label %256

; <label>:219                                     ; preds = %217
  %220 = bitcast i8* %185 to i16*
  %221 = load i16, i16* %220, align 2, !tbaa !70
  %222 = zext i16 %221 to i32
  %223 = lshr i32 %222, 11
  %224 = shl nuw nsw i32 %223, 3
  %225 = lshr i32 %222, 13
  %226 = or i32 %224, %225
  %227 = uitofp i32 %226 to float
  %228 = insertelement <3 x float> undef, float %227, i32 0
  %229 = lshr i32 %222, 5
  %230 = and i32 %229, 63
  %231 = shl nuw nsw i32 %230, 2
  %232 = lshr i32 %230, 4
  %233 = or i32 %231, %232
  %234 = uitofp i32 %233 to float
  %235 = insertelement <3 x float> %228, float %234, i32 1
  %236 = and i32 %222, 31
  %237 = shl nuw nsw i32 %236, 3
  %238 = lshr i32 %236, 2
  %239 = or i32 %237, %238
  %240 = uitofp i32 %239 to float
  %241 = insertelement <3 x float> %235, float %240, i32 2
  %242 = insertelement <3 x float> undef, float %142, i32 0
  %243 = shufflevector <3 x float> %242, <3 x float> undef, <3 x i32> zeroinitializer
  %244 = fmul <3 x float> %243, %241
  %245 = insertelement <3 x float> undef, float %frac.0.i45, i32 0
  %246 = shufflevector <3 x float> %245, <3 x float> undef, <3 x i32> zeroinitializer
  %247 = fmul <3 x float> %246, %241
  %248 = fadd <3 x float> %244, %247
  %249 = fmul <3 x float> %248, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %250 = extractelement <3 x float> %249, i32 0
  %251 = insertelement <4 x float> undef, float %250, i32 0
  %252 = insertelement <4 x float> %251, float %250, i32 1
  %253 = extractelement <3 x float> %249, i32 2
  %254 = insertelement <4 x float> %252, float %253, i32 2
  %255 = insertelement <4 x float> %254, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59

; <label>:256                                     ; preds = %217
  %257 = shl nsw i32 %183, 2
  %258 = getelementptr inbounds i8, i8* %185, i32 %257
  %259 = load i8, i8* %258, align 1, !tbaa !19
  %260 = uitofp i8 %259 to float
  %261 = insertelement <3 x float> undef, float %260, i32 0
  %262 = or i32 %257, 1
  %263 = getelementptr inbounds i8, i8* %185, i32 %262
  %264 = load i8, i8* %263, align 1, !tbaa !19
  %265 = uitofp i8 %264 to float
  %266 = insertelement <3 x float> %261, float %265, i32 1
  %267 = or i32 %257, 2
  %268 = getelementptr inbounds i8, i8* %185, i32 %267
  %269 = load i8, i8* %268, align 1, !tbaa !19
  %270 = uitofp i8 %269 to float
  %271 = insertelement <3 x float> %266, float %270, i32 2
  %272 = shl nsw i32 %178, 2
  %273 = getelementptr inbounds i8, i8* %185, i32 %272
  %274 = load i8, i8* %273, align 1, !tbaa !19
  %275 = uitofp i8 %274 to float
  %276 = insertelement <3 x float> undef, float %275, i32 0
  %277 = or i32 %272, 1
  %278 = getelementptr inbounds i8, i8* %185, i32 %277
  %279 = load i8, i8* %278, align 1, !tbaa !19
  %280 = uitofp i8 %279 to float
  %281 = insertelement <3 x float> %276, float %280, i32 1
  %282 = or i32 %272, 2
  %283 = getelementptr inbounds i8, i8* %185, i32 %282
  %284 = load i8, i8* %283, align 1, !tbaa !19
  %285 = uitofp i8 %284 to float
  %286 = insertelement <3 x float> %281, float %285, i32 2
  %287 = insertelement <3 x float> undef, float %142, i32 0
  %288 = shufflevector <3 x float> %287, <3 x float> undef, <3 x i32> zeroinitializer
  %289 = fmul <3 x float> %288, %271
  %290 = insertelement <3 x float> undef, float %frac.0.i45, i32 0
  %291 = shufflevector <3 x float> %290, <3 x float> undef, <3 x i32> zeroinitializer
  %292 = fmul <3 x float> %291, %286
  %293 = fadd <3 x float> %289, %292
  %294 = fmul <3 x float> %293, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %295 = extractelement <3 x float> %294, i32 0
  %296 = insertelement <4 x float> undef, float %295, i32 0
  %297 = insertelement <4 x float> %296, float %295, i32 1
  %298 = extractelement <3 x float> %294, i32 2
  %299 = insertelement <4 x float> %297, float %298, i32 2
  %300 = insertelement <4 x float> %299, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59

; <label>:301                                     ; preds = %wrapI.exit6.i57
  %302 = getelementptr inbounds i8, i8* %185, i32 %183
  %303 = load i8, i8* %302, align 1, !tbaa !19
  %304 = uitofp i8 %303 to float
  %305 = getelementptr inbounds i8, i8* %185, i32 %178
  %306 = load i8, i8* %305, align 1, !tbaa !19
  %307 = uitofp i8 %306 to float
  %308 = fmul float %142, %304
  %309 = fmul float %frac.0.i45, %307
  %310 = fadd float %308, %309
  %311 = fmul float %310, 0x3F70101020000000
  %312 = insertelement <4 x float> undef, float %311, i32 0
  %313 = insertelement <4 x float> %312, float %311, i32 1
  %314 = insertelement <4 x float> %313, float %311, i32 2
  %315 = insertelement <4 x float> %314, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59

; <label>:316                                     ; preds = %wrapI.exit6.i57
  %317 = shl nsw i32 %183, 1
  %318 = getelementptr inbounds i8, i8* %185, i32 %317
  %319 = load i8, i8* %318, align 1, !tbaa !19
  %320 = uitofp i8 %319 to float
  %321 = insertelement <2 x float> undef, float %320, i32 0
  %322 = or i32 %317, 1
  %323 = getelementptr inbounds i8, i8* %185, i32 %322
  %324 = load i8, i8* %323, align 1, !tbaa !19
  %325 = uitofp i8 %324 to float
  %326 = insertelement <2 x float> %321, float %325, i32 1
  %327 = shl nsw i32 %178, 1
  %328 = getelementptr inbounds i8, i8* %185, i32 %327
  %329 = load i8, i8* %328, align 1, !tbaa !19
  %330 = uitofp i8 %329 to float
  %331 = insertelement <2 x float> undef, float %330, i32 0
  %332 = or i32 %327, 1
  %333 = getelementptr inbounds i8, i8* %185, i32 %332
  %334 = load i8, i8* %333, align 1, !tbaa !19
  %335 = uitofp i8 %334 to float
  %336 = insertelement <2 x float> %331, float %335, i32 1
  %337 = shufflevector <2 x float> %144, <2 x float> undef, <2 x i32> zeroinitializer
  %338 = fmul <2 x float> %337, %326
  %339 = shufflevector <2 x float> %144, <2 x float> undef, <2 x i32> <i32 1, i32 1>
  %340 = fmul <2 x float> %339, %336
  %341 = fadd <2 x float> %338, %340
  %342 = fmul <2 x float> %341, <float 0x3F70101020000000, float 0x3F70101020000000>
  %343 = extractelement <2 x float> %342, i32 0
  %344 = insertelement <4 x float> undef, float %343, i32 0
  %345 = insertelement <4 x float> %344, float %343, i32 1
  %346 = insertelement <4 x float> %345, float %343, i32 2
  %347 = extractelement <2 x float> %342, i32 1
  %348 = insertelement <4 x float> %346, float %347, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59: ; preds = %wrapI.exit6.i57, %186, %205, %219, %256, %301, %316
  %.0.i.i58 = phi <4 x float> [ %348, %316 ], [ %315, %301 ], [ %255, %219 ], [ %300, %256 ], [ %216, %205 ], [ %204, %186 ], [ zeroinitializer, %wrapI.exit6.i57 ]
  br label %1143

; <label>:349                                     ; preds = %26
  switch i32 %17, label %1046 [
    i32 5, label %350
    i32 2, label %581
  ]

; <label>:350                                     ; preds = %349
  %351 = getelementptr inbounds i8, i8* %6, i32 68
  %352 = bitcast i8* %351 to i32*
  %353 = load i32, i32* %352, align 4, !tbaa !21
  %354 = add i32 %353, -1
  %355 = uitofp i32 %354 to float
  %356 = fcmp olt float %lod, %355
  %357 = select i1 %356, float %lod, float %355
  %358 = tail call float @_Z5roundf(float %357) #14
  %359 = fptoui float %358 to i32
  %360 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %359, i32 2
  %361 = load i32, i32* %360, align 4, !tbaa !21
  %362 = sitofp i32 %361 to float
  %363 = fmul float %362, %uv
  %364 = fptosi float %363 to i32
  %365 = sitofp i32 %364 to float
  %366 = fsub float %363, %365
  %367 = fcmp olt float %366, 5.000000e-01
  br i1 %367, label %368, label %371

; <label>:368                                     ; preds = %350
  %369 = add nsw i32 %364, -1
  %370 = fadd float %366, 5.000000e-01
  br label %373

; <label>:371                                     ; preds = %350
  %372 = fadd float %366, -5.000000e-01
  br label %373

; <label>:373                                     ; preds = %371, %368
  %frac.0.i30 = phi float [ %370, %368 ], [ %372, %371 ]
  %iPixel.0.i31 = phi i32 [ %369, %368 ], [ %364, %371 ]
  %374 = fsub float 1.000000e+00, %frac.0.i30
  %375 = insertelement <2 x float> undef, float %374, i32 0
  %376 = insertelement <2 x float> %375, float %frac.0.i30, i32 1
  %377 = add nsw i32 %iPixel.0.i31, 1
  switch i32 %21, label %wrapI.exit.i40 [
    i32 3, label %wrapI.exit.thread.i34
    i32 6, label %wrapI.exit.thread7.i39
  ]

wrapI.exit.thread.i34:                            ; preds = %373
  %378 = srem i32 %377, %361
  %379 = icmp slt i32 %378, 0
  %380 = select i1 %379, i32 %361, i32 0
  %..i.i32 = add nsw i32 %380, %378
  %381 = add nsw i32 %361, -1
  %382 = icmp slt i32 %..i.i32, %381
  %383 = select i1 %382, i32 %..i.i32, i32 %381
  %384 = icmp sgt i32 0, %383
  %385 = select i1 %384, i32 0, i32 %383
  %386 = srem i32 %iPixel.0.i31, %361
  %387 = icmp slt i32 %386, 0
  %388 = select i1 %387, i32 %361, i32 0
  %..i1.i33 = add nsw i32 %388, %386
  br label %wrapI.exit6.i42

wrapI.exit.thread7.i39:                           ; preds = %373
  %389 = shl nsw i32 %361, 1
  %390 = srem i32 %377, %389
  %391 = icmp slt i32 %390, 0
  %392 = select i1 %391, i32 %389, i32 0
  %.3.i.i35 = add nsw i32 %392, %390
  %393 = icmp slt i32 %.3.i.i35, %361
  %394 = sub nsw i32 %389, %.3.i.i35
  %.3..i.i36 = select i1 %393, i32 %.3.i.i35, i32 %394
  %395 = add nsw i32 %361, -1
  %396 = icmp slt i32 %.3..i.i36, %395
  %397 = select i1 %396, i32 %.3..i.i36, i32 %395
  %398 = icmp sgt i32 0, %397
  %399 = select i1 %398, i32 0, i32 %397
  %400 = srem i32 %iPixel.0.i31, %389
  %401 = icmp slt i32 %400, 0
  %402 = select i1 %401, i32 %389, i32 0
  %.3.i3.i37 = add nsw i32 %402, %400
  %403 = icmp slt i32 %.3.i3.i37, %361
  %404 = sub nsw i32 %389, %.3.i3.i37
  %.3..i4.i38 = select i1 %403, i32 %.3.i3.i37, i32 %404
  br label %wrapI.exit6.i42

wrapI.exit.i40:                                   ; preds = %373
  %405 = add nsw i32 %361, -1
  %406 = icmp slt i32 %377, %405
  %407 = select i1 %406, i32 %377, i32 %405
  %408 = icmp sgt i32 0, %407
  %409 = select i1 %408, i32 0, i32 %407
  br label %wrapI.exit6.i42

wrapI.exit6.i42:                                  ; preds = %wrapI.exit.i40, %wrapI.exit.thread7.i39, %wrapI.exit.thread.i34
  %410 = phi i32 [ %399, %wrapI.exit.thread7.i39 ], [ %385, %wrapI.exit.thread.i34 ], [ %409, %wrapI.exit.i40 ]
  %411 = phi i32 [ %395, %wrapI.exit.thread7.i39 ], [ %381, %wrapI.exit.thread.i34 ], [ %405, %wrapI.exit.i40 ]
  %.2.i5.i41 = phi i32 [ %.3..i4.i38, %wrapI.exit.thread7.i39 ], [ %..i1.i33, %wrapI.exit.thread.i34 ], [ %iPixel.0.i31, %wrapI.exit.i40 ]
  %412 = icmp slt i32 %.2.i5.i41, %411
  %413 = select i1 %412, i32 %.2.i5.i41, i32 %411
  %414 = icmp sgt i32 0, %413
  %415 = select i1 %414, i32 0, i32 %413
  %416 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %359, i32 0
  %417 = load i8*, i8** %416, align 4, !tbaa !22
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44 [
    i32 11, label %418
    i32 8, label %437
    i32 10, label %449
    i32 7, label %533
    i32 9, label %548
  ]

; <label>:418                                     ; preds = %wrapI.exit6.i42
  %419 = shl nsw i32 %415, 2
  %420 = getelementptr inbounds i8, i8* %417, i32 %419
  %421 = bitcast i8* %420 to <4 x i8>*
  %422 = load <4 x i8>, <4 x i8>* %421, align 4, !tbaa !19
  %423 = uitofp <4 x i8> %422 to <4 x float>
  %424 = shl nsw i32 %410, 2
  %425 = getelementptr inbounds i8, i8* %417, i32 %424
  %426 = bitcast i8* %425 to <4 x i8>*
  %427 = load <4 x i8>, <4 x i8>* %426, align 4, !tbaa !19
  %428 = uitofp <4 x i8> %427 to <4 x float>
  %429 = insertelement <4 x float> undef, float %374, i32 0
  %430 = shufflevector <4 x float> %429, <4 x float> undef, <4 x i32> zeroinitializer
  %431 = fmul <4 x float> %430, %423
  %432 = insertelement <4 x float> undef, float %frac.0.i30, i32 0
  %433 = shufflevector <4 x float> %432, <4 x float> undef, <4 x i32> zeroinitializer
  %434 = fmul <4 x float> %433, %428
  %435 = fadd <4 x float> %431, %434
  %436 = fmul <4 x float> %435, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44

; <label>:437                                     ; preds = %wrapI.exit6.i42
  %438 = getelementptr inbounds i8, i8* %417, i32 %415
  %439 = load i8, i8* %438, align 1, !tbaa !19
  %440 = uitofp i8 %439 to float
  %441 = getelementptr inbounds i8, i8* %417, i32 %410
  %442 = load i8, i8* %441, align 1, !tbaa !19
  %443 = uitofp i8 %442 to float
  %444 = fmul float %374, %440
  %445 = fmul float %frac.0.i30, %443
  %446 = fadd float %444, %445
  %447 = fmul float %446, 0x3F70101020000000
  %448 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %447, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44

; <label>:449                                     ; preds = %wrapI.exit6.i42
  %450 = icmp eq i32 %15, 13
  br i1 %450, label %451, label %488

; <label>:451                                     ; preds = %449
  %452 = bitcast i8* %417 to i16*
  %453 = load i16, i16* %452, align 2, !tbaa !70
  %454 = zext i16 %453 to i32
  %455 = lshr i32 %454, 11
  %456 = shl nuw nsw i32 %455, 3
  %457 = lshr i32 %454, 13
  %458 = or i32 %456, %457
  %459 = uitofp i32 %458 to float
  %460 = insertelement <3 x float> undef, float %459, i32 0
  %461 = lshr i32 %454, 5
  %462 = and i32 %461, 63
  %463 = shl nuw nsw i32 %462, 2
  %464 = lshr i32 %462, 4
  %465 = or i32 %463, %464
  %466 = uitofp i32 %465 to float
  %467 = insertelement <3 x float> %460, float %466, i32 1
  %468 = and i32 %454, 31
  %469 = shl nuw nsw i32 %468, 3
  %470 = lshr i32 %468, 2
  %471 = or i32 %469, %470
  %472 = uitofp i32 %471 to float
  %473 = insertelement <3 x float> %467, float %472, i32 2
  %474 = insertelement <3 x float> undef, float %374, i32 0
  %475 = shufflevector <3 x float> %474, <3 x float> undef, <3 x i32> zeroinitializer
  %476 = fmul <3 x float> %475, %473
  %477 = insertelement <3 x float> undef, float %frac.0.i30, i32 0
  %478 = shufflevector <3 x float> %477, <3 x float> undef, <3 x i32> zeroinitializer
  %479 = fmul <3 x float> %478, %473
  %480 = fadd <3 x float> %476, %479
  %481 = fmul <3 x float> %480, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %482 = extractelement <3 x float> %481, i32 0
  %483 = insertelement <4 x float> undef, float %482, i32 0
  %484 = insertelement <4 x float> %483, float %482, i32 1
  %485 = extractelement <3 x float> %481, i32 2
  %486 = insertelement <4 x float> %484, float %485, i32 2
  %487 = insertelement <4 x float> %486, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44

; <label>:488                                     ; preds = %449
  %489 = shl nsw i32 %415, 2
  %490 = getelementptr inbounds i8, i8* %417, i32 %489
  %491 = load i8, i8* %490, align 1, !tbaa !19
  %492 = uitofp i8 %491 to float
  %493 = insertelement <3 x float> undef, float %492, i32 0
  %494 = or i32 %489, 1
  %495 = getelementptr inbounds i8, i8* %417, i32 %494
  %496 = load i8, i8* %495, align 1, !tbaa !19
  %497 = uitofp i8 %496 to float
  %498 = insertelement <3 x float> %493, float %497, i32 1
  %499 = or i32 %489, 2
  %500 = getelementptr inbounds i8, i8* %417, i32 %499
  %501 = load i8, i8* %500, align 1, !tbaa !19
  %502 = uitofp i8 %501 to float
  %503 = insertelement <3 x float> %498, float %502, i32 2
  %504 = shl nsw i32 %410, 2
  %505 = getelementptr inbounds i8, i8* %417, i32 %504
  %506 = load i8, i8* %505, align 1, !tbaa !19
  %507 = uitofp i8 %506 to float
  %508 = insertelement <3 x float> undef, float %507, i32 0
  %509 = or i32 %504, 1
  %510 = getelementptr inbounds i8, i8* %417, i32 %509
  %511 = load i8, i8* %510, align 1, !tbaa !19
  %512 = uitofp i8 %511 to float
  %513 = insertelement <3 x float> %508, float %512, i32 1
  %514 = or i32 %504, 2
  %515 = getelementptr inbounds i8, i8* %417, i32 %514
  %516 = load i8, i8* %515, align 1, !tbaa !19
  %517 = uitofp i8 %516 to float
  %518 = insertelement <3 x float> %513, float %517, i32 2
  %519 = insertelement <3 x float> undef, float %374, i32 0
  %520 = shufflevector <3 x float> %519, <3 x float> undef, <3 x i32> zeroinitializer
  %521 = fmul <3 x float> %520, %503
  %522 = insertelement <3 x float> undef, float %frac.0.i30, i32 0
  %523 = shufflevector <3 x float> %522, <3 x float> undef, <3 x i32> zeroinitializer
  %524 = fmul <3 x float> %523, %518
  %525 = fadd <3 x float> %521, %524
  %526 = fmul <3 x float> %525, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %527 = extractelement <3 x float> %526, i32 0
  %528 = insertelement <4 x float> undef, float %527, i32 0
  %529 = insertelement <4 x float> %528, float %527, i32 1
  %530 = extractelement <3 x float> %526, i32 2
  %531 = insertelement <4 x float> %529, float %530, i32 2
  %532 = insertelement <4 x float> %531, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44

; <label>:533                                     ; preds = %wrapI.exit6.i42
  %534 = getelementptr inbounds i8, i8* %417, i32 %415
  %535 = load i8, i8* %534, align 1, !tbaa !19
  %536 = uitofp i8 %535 to float
  %537 = getelementptr inbounds i8, i8* %417, i32 %410
  %538 = load i8, i8* %537, align 1, !tbaa !19
  %539 = uitofp i8 %538 to float
  %540 = fmul float %374, %536
  %541 = fmul float %frac.0.i30, %539
  %542 = fadd float %540, %541
  %543 = fmul float %542, 0x3F70101020000000
  %544 = insertelement <4 x float> undef, float %543, i32 0
  %545 = insertelement <4 x float> %544, float %543, i32 1
  %546 = insertelement <4 x float> %545, float %543, i32 2
  %547 = insertelement <4 x float> %546, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44

; <label>:548                                     ; preds = %wrapI.exit6.i42
  %549 = shl nsw i32 %415, 1
  %550 = getelementptr inbounds i8, i8* %417, i32 %549
  %551 = load i8, i8* %550, align 1, !tbaa !19
  %552 = uitofp i8 %551 to float
  %553 = insertelement <2 x float> undef, float %552, i32 0
  %554 = or i32 %549, 1
  %555 = getelementptr inbounds i8, i8* %417, i32 %554
  %556 = load i8, i8* %555, align 1, !tbaa !19
  %557 = uitofp i8 %556 to float
  %558 = insertelement <2 x float> %553, float %557, i32 1
  %559 = shl nsw i32 %410, 1
  %560 = getelementptr inbounds i8, i8* %417, i32 %559
  %561 = load i8, i8* %560, align 1, !tbaa !19
  %562 = uitofp i8 %561 to float
  %563 = insertelement <2 x float> undef, float %562, i32 0
  %564 = or i32 %559, 1
  %565 = getelementptr inbounds i8, i8* %417, i32 %564
  %566 = load i8, i8* %565, align 1, !tbaa !19
  %567 = uitofp i8 %566 to float
  %568 = insertelement <2 x float> %563, float %567, i32 1
  %569 = shufflevector <2 x float> %376, <2 x float> undef, <2 x i32> zeroinitializer
  %570 = fmul <2 x float> %569, %558
  %571 = shufflevector <2 x float> %376, <2 x float> undef, <2 x i32> <i32 1, i32 1>
  %572 = fmul <2 x float> %571, %568
  %573 = fadd <2 x float> %570, %572
  %574 = fmul <2 x float> %573, <float 0x3F70101020000000, float 0x3F70101020000000>
  %575 = extractelement <2 x float> %574, i32 0
  %576 = insertelement <4 x float> undef, float %575, i32 0
  %577 = insertelement <4 x float> %576, float %575, i32 1
  %578 = insertelement <4 x float> %577, float %575, i32 2
  %579 = extractelement <2 x float> %574, i32 1
  %580 = insertelement <4 x float> %578, float %579, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44: ; preds = %wrapI.exit6.i42, %418, %437, %451, %488, %533, %548
  %.0.i.i43 = phi <4 x float> [ %580, %548 ], [ %547, %533 ], [ %487, %451 ], [ %532, %488 ], [ %448, %437 ], [ %436, %418 ], [ zeroinitializer, %wrapI.exit6.i42 ]
  br label %1143

; <label>:581                                     ; preds = %349
  %582 = tail call float @_Z5floorf(float %lod) #14
  %583 = fptoui float %582 to i32
  %584 = tail call float @_Z4ceilf(float %lod) #14
  %585 = fptoui float %584 to i32
  %586 = getelementptr inbounds i8, i8* %6, i32 68
  %587 = bitcast i8* %586 to i32*
  %588 = load i32, i32* %587, align 4, !tbaa !21
  %589 = add i32 %588, -1
  %590 = icmp ult i32 %583, %589
  %591 = select i1 %590, i32 %583, i32 %589
  %592 = icmp ult i32 %585, %589
  %593 = select i1 %592, i32 %585, i32 %589
  %594 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %591, i32 2
  %595 = load i32, i32* %594, align 4, !tbaa !21
  %596 = sitofp i32 %595 to float
  %597 = fmul float %596, %uv
  %598 = fptosi float %597 to i32
  %599 = sitofp i32 %598 to float
  %600 = fsub float %597, %599
  %601 = fcmp olt float %600, 5.000000e-01
  br i1 %601, label %602, label %605

; <label>:602                                     ; preds = %581
  %603 = add nsw i32 %598, -1
  %604 = fadd float %600, 5.000000e-01
  br label %607

; <label>:605                                     ; preds = %581
  %606 = fadd float %600, -5.000000e-01
  br label %607

; <label>:607                                     ; preds = %605, %602
  %frac.0.i15 = phi float [ %604, %602 ], [ %606, %605 ]
  %iPixel.0.i16 = phi i32 [ %603, %602 ], [ %598, %605 ]
  %608 = fsub float 1.000000e+00, %frac.0.i15
  %609 = insertelement <2 x float> undef, float %608, i32 0
  %610 = insertelement <2 x float> %609, float %frac.0.i15, i32 1
  %611 = add nsw i32 %iPixel.0.i16, 1
  switch i32 %21, label %wrapI.exit.i25 [
    i32 3, label %wrapI.exit.thread.i19
    i32 6, label %wrapI.exit.thread7.i24
  ]

wrapI.exit.thread.i19:                            ; preds = %607
  %612 = srem i32 %611, %595
  %613 = icmp slt i32 %612, 0
  %614 = select i1 %613, i32 %595, i32 0
  %..i.i17 = add nsw i32 %614, %612
  %615 = add nsw i32 %595, -1
  %616 = icmp slt i32 %..i.i17, %615
  %617 = select i1 %616, i32 %..i.i17, i32 %615
  %618 = icmp sgt i32 0, %617
  %619 = select i1 %618, i32 0, i32 %617
  %620 = srem i32 %iPixel.0.i16, %595
  %621 = icmp slt i32 %620, 0
  %622 = select i1 %621, i32 %595, i32 0
  %..i1.i18 = add nsw i32 %622, %620
  br label %wrapI.exit6.i27

wrapI.exit.thread7.i24:                           ; preds = %607
  %623 = shl nsw i32 %595, 1
  %624 = srem i32 %611, %623
  %625 = icmp slt i32 %624, 0
  %626 = select i1 %625, i32 %623, i32 0
  %.3.i.i20 = add nsw i32 %626, %624
  %627 = icmp slt i32 %.3.i.i20, %595
  %628 = sub nsw i32 %623, %.3.i.i20
  %.3..i.i21 = select i1 %627, i32 %.3.i.i20, i32 %628
  %629 = add nsw i32 %595, -1
  %630 = icmp slt i32 %.3..i.i21, %629
  %631 = select i1 %630, i32 %.3..i.i21, i32 %629
  %632 = icmp sgt i32 0, %631
  %633 = select i1 %632, i32 0, i32 %631
  %634 = srem i32 %iPixel.0.i16, %623
  %635 = icmp slt i32 %634, 0
  %636 = select i1 %635, i32 %623, i32 0
  %.3.i3.i22 = add nsw i32 %636, %634
  %637 = icmp slt i32 %.3.i3.i22, %595
  %638 = sub nsw i32 %623, %.3.i3.i22
  %.3..i4.i23 = select i1 %637, i32 %.3.i3.i22, i32 %638
  br label %wrapI.exit6.i27

wrapI.exit.i25:                                   ; preds = %607
  %639 = add nsw i32 %595, -1
  %640 = icmp slt i32 %611, %639
  %641 = select i1 %640, i32 %611, i32 %639
  %642 = icmp sgt i32 0, %641
  %643 = select i1 %642, i32 0, i32 %641
  br label %wrapI.exit6.i27

wrapI.exit6.i27:                                  ; preds = %wrapI.exit.i25, %wrapI.exit.thread7.i24, %wrapI.exit.thread.i19
  %644 = phi i32 [ %633, %wrapI.exit.thread7.i24 ], [ %619, %wrapI.exit.thread.i19 ], [ %643, %wrapI.exit.i25 ]
  %645 = phi i32 [ %629, %wrapI.exit.thread7.i24 ], [ %615, %wrapI.exit.thread.i19 ], [ %639, %wrapI.exit.i25 ]
  %.2.i5.i26 = phi i32 [ %.3..i4.i23, %wrapI.exit.thread7.i24 ], [ %..i1.i18, %wrapI.exit.thread.i19 ], [ %iPixel.0.i16, %wrapI.exit.i25 ]
  %646 = icmp slt i32 %.2.i5.i26, %645
  %647 = select i1 %646, i32 %.2.i5.i26, i32 %645
  %648 = icmp sgt i32 0, %647
  %649 = select i1 %648, i32 0, i32 %647
  %650 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %591, i32 0
  %651 = load i8*, i8** %650, align 4, !tbaa !22
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29 [
    i32 11, label %652
    i32 8, label %671
    i32 10, label %683
    i32 7, label %767
    i32 9, label %782
  ]

; <label>:652                                     ; preds = %wrapI.exit6.i27
  %653 = shl nsw i32 %649, 2
  %654 = getelementptr inbounds i8, i8* %651, i32 %653
  %655 = bitcast i8* %654 to <4 x i8>*
  %656 = load <4 x i8>, <4 x i8>* %655, align 4, !tbaa !19
  %657 = uitofp <4 x i8> %656 to <4 x float>
  %658 = shl nsw i32 %644, 2
  %659 = getelementptr inbounds i8, i8* %651, i32 %658
  %660 = bitcast i8* %659 to <4 x i8>*
  %661 = load <4 x i8>, <4 x i8>* %660, align 4, !tbaa !19
  %662 = uitofp <4 x i8> %661 to <4 x float>
  %663 = insertelement <4 x float> undef, float %608, i32 0
  %664 = shufflevector <4 x float> %663, <4 x float> undef, <4 x i32> zeroinitializer
  %665 = fmul <4 x float> %664, %657
  %666 = insertelement <4 x float> undef, float %frac.0.i15, i32 0
  %667 = shufflevector <4 x float> %666, <4 x float> undef, <4 x i32> zeroinitializer
  %668 = fmul <4 x float> %667, %662
  %669 = fadd <4 x float> %665, %668
  %670 = fmul <4 x float> %669, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29

; <label>:671                                     ; preds = %wrapI.exit6.i27
  %672 = getelementptr inbounds i8, i8* %651, i32 %649
  %673 = load i8, i8* %672, align 1, !tbaa !19
  %674 = uitofp i8 %673 to float
  %675 = getelementptr inbounds i8, i8* %651, i32 %644
  %676 = load i8, i8* %675, align 1, !tbaa !19
  %677 = uitofp i8 %676 to float
  %678 = fmul float %608, %674
  %679 = fmul float %frac.0.i15, %677
  %680 = fadd float %678, %679
  %681 = fmul float %680, 0x3F70101020000000
  %682 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %681, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29

; <label>:683                                     ; preds = %wrapI.exit6.i27
  %684 = icmp eq i32 %15, 13
  br i1 %684, label %685, label %722

; <label>:685                                     ; preds = %683
  %686 = bitcast i8* %651 to i16*
  %687 = load i16, i16* %686, align 2, !tbaa !70
  %688 = zext i16 %687 to i32
  %689 = lshr i32 %688, 11
  %690 = shl nuw nsw i32 %689, 3
  %691 = lshr i32 %688, 13
  %692 = or i32 %690, %691
  %693 = uitofp i32 %692 to float
  %694 = insertelement <3 x float> undef, float %693, i32 0
  %695 = lshr i32 %688, 5
  %696 = and i32 %695, 63
  %697 = shl nuw nsw i32 %696, 2
  %698 = lshr i32 %696, 4
  %699 = or i32 %697, %698
  %700 = uitofp i32 %699 to float
  %701 = insertelement <3 x float> %694, float %700, i32 1
  %702 = and i32 %688, 31
  %703 = shl nuw nsw i32 %702, 3
  %704 = lshr i32 %702, 2
  %705 = or i32 %703, %704
  %706 = uitofp i32 %705 to float
  %707 = insertelement <3 x float> %701, float %706, i32 2
  %708 = insertelement <3 x float> undef, float %608, i32 0
  %709 = shufflevector <3 x float> %708, <3 x float> undef, <3 x i32> zeroinitializer
  %710 = fmul <3 x float> %709, %707
  %711 = insertelement <3 x float> undef, float %frac.0.i15, i32 0
  %712 = shufflevector <3 x float> %711, <3 x float> undef, <3 x i32> zeroinitializer
  %713 = fmul <3 x float> %712, %707
  %714 = fadd <3 x float> %710, %713
  %715 = fmul <3 x float> %714, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %716 = extractelement <3 x float> %715, i32 0
  %717 = insertelement <4 x float> undef, float %716, i32 0
  %718 = insertelement <4 x float> %717, float %716, i32 1
  %719 = extractelement <3 x float> %715, i32 2
  %720 = insertelement <4 x float> %718, float %719, i32 2
  %721 = insertelement <4 x float> %720, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29

; <label>:722                                     ; preds = %683
  %723 = shl nsw i32 %649, 2
  %724 = getelementptr inbounds i8, i8* %651, i32 %723
  %725 = load i8, i8* %724, align 1, !tbaa !19
  %726 = uitofp i8 %725 to float
  %727 = insertelement <3 x float> undef, float %726, i32 0
  %728 = or i32 %723, 1
  %729 = getelementptr inbounds i8, i8* %651, i32 %728
  %730 = load i8, i8* %729, align 1, !tbaa !19
  %731 = uitofp i8 %730 to float
  %732 = insertelement <3 x float> %727, float %731, i32 1
  %733 = or i32 %723, 2
  %734 = getelementptr inbounds i8, i8* %651, i32 %733
  %735 = load i8, i8* %734, align 1, !tbaa !19
  %736 = uitofp i8 %735 to float
  %737 = insertelement <3 x float> %732, float %736, i32 2
  %738 = shl nsw i32 %644, 2
  %739 = getelementptr inbounds i8, i8* %651, i32 %738
  %740 = load i8, i8* %739, align 1, !tbaa !19
  %741 = uitofp i8 %740 to float
  %742 = insertelement <3 x float> undef, float %741, i32 0
  %743 = or i32 %738, 1
  %744 = getelementptr inbounds i8, i8* %651, i32 %743
  %745 = load i8, i8* %744, align 1, !tbaa !19
  %746 = uitofp i8 %745 to float
  %747 = insertelement <3 x float> %742, float %746, i32 1
  %748 = or i32 %738, 2
  %749 = getelementptr inbounds i8, i8* %651, i32 %748
  %750 = load i8, i8* %749, align 1, !tbaa !19
  %751 = uitofp i8 %750 to float
  %752 = insertelement <3 x float> %747, float %751, i32 2
  %753 = insertelement <3 x float> undef, float %608, i32 0
  %754 = shufflevector <3 x float> %753, <3 x float> undef, <3 x i32> zeroinitializer
  %755 = fmul <3 x float> %754, %737
  %756 = insertelement <3 x float> undef, float %frac.0.i15, i32 0
  %757 = shufflevector <3 x float> %756, <3 x float> undef, <3 x i32> zeroinitializer
  %758 = fmul <3 x float> %757, %752
  %759 = fadd <3 x float> %755, %758
  %760 = fmul <3 x float> %759, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %761 = extractelement <3 x float> %760, i32 0
  %762 = insertelement <4 x float> undef, float %761, i32 0
  %763 = insertelement <4 x float> %762, float %761, i32 1
  %764 = extractelement <3 x float> %760, i32 2
  %765 = insertelement <4 x float> %763, float %764, i32 2
  %766 = insertelement <4 x float> %765, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29

; <label>:767                                     ; preds = %wrapI.exit6.i27
  %768 = getelementptr inbounds i8, i8* %651, i32 %649
  %769 = load i8, i8* %768, align 1, !tbaa !19
  %770 = uitofp i8 %769 to float
  %771 = getelementptr inbounds i8, i8* %651, i32 %644
  %772 = load i8, i8* %771, align 1, !tbaa !19
  %773 = uitofp i8 %772 to float
  %774 = fmul float %608, %770
  %775 = fmul float %frac.0.i15, %773
  %776 = fadd float %774, %775
  %777 = fmul float %776, 0x3F70101020000000
  %778 = insertelement <4 x float> undef, float %777, i32 0
  %779 = insertelement <4 x float> %778, float %777, i32 1
  %780 = insertelement <4 x float> %779, float %777, i32 2
  %781 = insertelement <4 x float> %780, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29

; <label>:782                                     ; preds = %wrapI.exit6.i27
  %783 = shl nsw i32 %649, 1
  %784 = getelementptr inbounds i8, i8* %651, i32 %783
  %785 = load i8, i8* %784, align 1, !tbaa !19
  %786 = uitofp i8 %785 to float
  %787 = insertelement <2 x float> undef, float %786, i32 0
  %788 = or i32 %783, 1
  %789 = getelementptr inbounds i8, i8* %651, i32 %788
  %790 = load i8, i8* %789, align 1, !tbaa !19
  %791 = uitofp i8 %790 to float
  %792 = insertelement <2 x float> %787, float %791, i32 1
  %793 = shl nsw i32 %644, 1
  %794 = getelementptr inbounds i8, i8* %651, i32 %793
  %795 = load i8, i8* %794, align 1, !tbaa !19
  %796 = uitofp i8 %795 to float
  %797 = insertelement <2 x float> undef, float %796, i32 0
  %798 = or i32 %793, 1
  %799 = getelementptr inbounds i8, i8* %651, i32 %798
  %800 = load i8, i8* %799, align 1, !tbaa !19
  %801 = uitofp i8 %800 to float
  %802 = insertelement <2 x float> %797, float %801, i32 1
  %803 = shufflevector <2 x float> %610, <2 x float> undef, <2 x i32> zeroinitializer
  %804 = fmul <2 x float> %803, %792
  %805 = shufflevector <2 x float> %610, <2 x float> undef, <2 x i32> <i32 1, i32 1>
  %806 = fmul <2 x float> %805, %802
  %807 = fadd <2 x float> %804, %806
  %808 = fmul <2 x float> %807, <float 0x3F70101020000000, float 0x3F70101020000000>
  %809 = extractelement <2 x float> %808, i32 0
  %810 = insertelement <4 x float> undef, float %809, i32 0
  %811 = insertelement <4 x float> %810, float %809, i32 1
  %812 = insertelement <4 x float> %811, float %809, i32 2
  %813 = extractelement <2 x float> %808, i32 1
  %814 = insertelement <4 x float> %812, float %813, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29: ; preds = %wrapI.exit6.i27, %652, %671, %685, %722, %767, %782
  %.0.i.i28 = phi <4 x float> [ %814, %782 ], [ %781, %767 ], [ %721, %685 ], [ %766, %722 ], [ %682, %671 ], [ %670, %652 ], [ zeroinitializer, %wrapI.exit6.i27 ]
  %815 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %593, i32 2
  %816 = load i32, i32* %815, align 4, !tbaa !21
  %817 = sitofp i32 %816 to float
  %818 = fmul float %817, %uv
  %819 = fptosi float %818 to i32
  %820 = sitofp i32 %819 to float
  %821 = fsub float %818, %820
  %822 = fcmp olt float %821, 5.000000e-01
  br i1 %822, label %823, label %826

; <label>:823                                     ; preds = %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29
  %824 = add nsw i32 %819, -1
  %825 = fadd float %821, 5.000000e-01
  br label %828

; <label>:826                                     ; preds = %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit29
  %827 = fadd float %821, -5.000000e-01
  br label %828

; <label>:828                                     ; preds = %826, %823
  %frac.0.i = phi float [ %825, %823 ], [ %827, %826 ]
  %iPixel.0.i = phi i32 [ %824, %823 ], [ %819, %826 ]
  %829 = fsub float 1.000000e+00, %frac.0.i
  %830 = insertelement <2 x float> undef, float %829, i32 0
  %831 = insertelement <2 x float> %830, float %frac.0.i, i32 1
  %832 = add nsw i32 %iPixel.0.i, 1
  switch i32 %21, label %wrapI.exit.i14 [
    i32 3, label %wrapI.exit.thread.i
    i32 6, label %wrapI.exit.thread7.i
  ]

wrapI.exit.thread.i:                              ; preds = %828
  %833 = srem i32 %832, %816
  %834 = icmp slt i32 %833, 0
  %835 = select i1 %834, i32 %816, i32 0
  %..i.i11 = add nsw i32 %835, %833
  %836 = add nsw i32 %816, -1
  %837 = icmp slt i32 %..i.i11, %836
  %838 = select i1 %837, i32 %..i.i11, i32 %836
  %839 = icmp sgt i32 0, %838
  %840 = select i1 %839, i32 0, i32 %838
  %841 = srem i32 %iPixel.0.i, %816
  %842 = icmp slt i32 %841, 0
  %843 = select i1 %842, i32 %816, i32 0
  %..i1.i = add nsw i32 %843, %841
  br label %wrapI.exit6.i

wrapI.exit.thread7.i:                             ; preds = %828
  %844 = shl nsw i32 %816, 1
  %845 = srem i32 %832, %844
  %846 = icmp slt i32 %845, 0
  %847 = select i1 %846, i32 %844, i32 0
  %.3.i.i12 = add nsw i32 %847, %845
  %848 = icmp slt i32 %.3.i.i12, %816
  %849 = sub nsw i32 %844, %.3.i.i12
  %.3..i.i13 = select i1 %848, i32 %.3.i.i12, i32 %849
  %850 = add nsw i32 %816, -1
  %851 = icmp slt i32 %.3..i.i13, %850
  %852 = select i1 %851, i32 %.3..i.i13, i32 %850
  %853 = icmp sgt i32 0, %852
  %854 = select i1 %853, i32 0, i32 %852
  %855 = srem i32 %iPixel.0.i, %844
  %856 = icmp slt i32 %855, 0
  %857 = select i1 %856, i32 %844, i32 0
  %.3.i3.i = add nsw i32 %857, %855
  %858 = icmp slt i32 %.3.i3.i, %816
  %859 = sub nsw i32 %844, %.3.i3.i
  %.3..i4.i = select i1 %858, i32 %.3.i3.i, i32 %859
  br label %wrapI.exit6.i

wrapI.exit.i14:                                   ; preds = %828
  %860 = add nsw i32 %816, -1
  %861 = icmp slt i32 %832, %860
  %862 = select i1 %861, i32 %832, i32 %860
  %863 = icmp sgt i32 0, %862
  %864 = select i1 %863, i32 0, i32 %862
  br label %wrapI.exit6.i

wrapI.exit6.i:                                    ; preds = %wrapI.exit.i14, %wrapI.exit.thread7.i, %wrapI.exit.thread.i
  %865 = phi i32 [ %854, %wrapI.exit.thread7.i ], [ %840, %wrapI.exit.thread.i ], [ %864, %wrapI.exit.i14 ]
  %866 = phi i32 [ %850, %wrapI.exit.thread7.i ], [ %836, %wrapI.exit.thread.i ], [ %860, %wrapI.exit.i14 ]
  %.2.i5.i = phi i32 [ %.3..i4.i, %wrapI.exit.thread7.i ], [ %..i1.i, %wrapI.exit.thread.i ], [ %iPixel.0.i, %wrapI.exit.i14 ]
  %867 = icmp slt i32 %.2.i5.i, %866
  %868 = select i1 %867, i32 %.2.i5.i, i32 %866
  %869 = icmp sgt i32 0, %868
  %870 = select i1 %869, i32 0, i32 %868
  %871 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %593, i32 0
  %872 = load i8*, i8** %871, align 4, !tbaa !22
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit [
    i32 11, label %873
    i32 8, label %892
    i32 10, label %904
    i32 7, label %988
    i32 9, label %1003
  ]

; <label>:873                                     ; preds = %wrapI.exit6.i
  %874 = shl nsw i32 %870, 2
  %875 = getelementptr inbounds i8, i8* %872, i32 %874
  %876 = bitcast i8* %875 to <4 x i8>*
  %877 = load <4 x i8>, <4 x i8>* %876, align 4, !tbaa !19
  %878 = uitofp <4 x i8> %877 to <4 x float>
  %879 = shl nsw i32 %865, 2
  %880 = getelementptr inbounds i8, i8* %872, i32 %879
  %881 = bitcast i8* %880 to <4 x i8>*
  %882 = load <4 x i8>, <4 x i8>* %881, align 4, !tbaa !19
  %883 = uitofp <4 x i8> %882 to <4 x float>
  %884 = insertelement <4 x float> undef, float %829, i32 0
  %885 = shufflevector <4 x float> %884, <4 x float> undef, <4 x i32> zeroinitializer
  %886 = fmul <4 x float> %885, %878
  %887 = insertelement <4 x float> undef, float %frac.0.i, i32 0
  %888 = shufflevector <4 x float> %887, <4 x float> undef, <4 x i32> zeroinitializer
  %889 = fmul <4 x float> %888, %883
  %890 = fadd <4 x float> %886, %889
  %891 = fmul <4 x float> %890, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:892                                     ; preds = %wrapI.exit6.i
  %893 = getelementptr inbounds i8, i8* %872, i32 %870
  %894 = load i8, i8* %893, align 1, !tbaa !19
  %895 = uitofp i8 %894 to float
  %896 = getelementptr inbounds i8, i8* %872, i32 %865
  %897 = load i8, i8* %896, align 1, !tbaa !19
  %898 = uitofp i8 %897 to float
  %899 = fmul float %829, %895
  %900 = fmul float %frac.0.i, %898
  %901 = fadd float %899, %900
  %902 = fmul float %901, 0x3F70101020000000
  %903 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %902, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:904                                     ; preds = %wrapI.exit6.i
  %905 = icmp eq i32 %15, 13
  br i1 %905, label %906, label %943

; <label>:906                                     ; preds = %904
  %907 = bitcast i8* %872 to i16*
  %908 = load i16, i16* %907, align 2, !tbaa !70
  %909 = zext i16 %908 to i32
  %910 = lshr i32 %909, 11
  %911 = shl nuw nsw i32 %910, 3
  %912 = lshr i32 %909, 13
  %913 = or i32 %911, %912
  %914 = uitofp i32 %913 to float
  %915 = insertelement <3 x float> undef, float %914, i32 0
  %916 = lshr i32 %909, 5
  %917 = and i32 %916, 63
  %918 = shl nuw nsw i32 %917, 2
  %919 = lshr i32 %917, 4
  %920 = or i32 %918, %919
  %921 = uitofp i32 %920 to float
  %922 = insertelement <3 x float> %915, float %921, i32 1
  %923 = and i32 %909, 31
  %924 = shl nuw nsw i32 %923, 3
  %925 = lshr i32 %923, 2
  %926 = or i32 %924, %925
  %927 = uitofp i32 %926 to float
  %928 = insertelement <3 x float> %922, float %927, i32 2
  %929 = insertelement <3 x float> undef, float %829, i32 0
  %930 = shufflevector <3 x float> %929, <3 x float> undef, <3 x i32> zeroinitializer
  %931 = fmul <3 x float> %930, %928
  %932 = insertelement <3 x float> undef, float %frac.0.i, i32 0
  %933 = shufflevector <3 x float> %932, <3 x float> undef, <3 x i32> zeroinitializer
  %934 = fmul <3 x float> %933, %928
  %935 = fadd <3 x float> %931, %934
  %936 = fmul <3 x float> %935, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %937 = extractelement <3 x float> %936, i32 0
  %938 = insertelement <4 x float> undef, float %937, i32 0
  %939 = insertelement <4 x float> %938, float %937, i32 1
  %940 = extractelement <3 x float> %936, i32 2
  %941 = insertelement <4 x float> %939, float %940, i32 2
  %942 = insertelement <4 x float> %941, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:943                                     ; preds = %904
  %944 = shl nsw i32 %870, 2
  %945 = getelementptr inbounds i8, i8* %872, i32 %944
  %946 = load i8, i8* %945, align 1, !tbaa !19
  %947 = uitofp i8 %946 to float
  %948 = insertelement <3 x float> undef, float %947, i32 0
  %949 = or i32 %944, 1
  %950 = getelementptr inbounds i8, i8* %872, i32 %949
  %951 = load i8, i8* %950, align 1, !tbaa !19
  %952 = uitofp i8 %951 to float
  %953 = insertelement <3 x float> %948, float %952, i32 1
  %954 = or i32 %944, 2
  %955 = getelementptr inbounds i8, i8* %872, i32 %954
  %956 = load i8, i8* %955, align 1, !tbaa !19
  %957 = uitofp i8 %956 to float
  %958 = insertelement <3 x float> %953, float %957, i32 2
  %959 = shl nsw i32 %865, 2
  %960 = getelementptr inbounds i8, i8* %872, i32 %959
  %961 = load i8, i8* %960, align 1, !tbaa !19
  %962 = uitofp i8 %961 to float
  %963 = insertelement <3 x float> undef, float %962, i32 0
  %964 = or i32 %959, 1
  %965 = getelementptr inbounds i8, i8* %872, i32 %964
  %966 = load i8, i8* %965, align 1, !tbaa !19
  %967 = uitofp i8 %966 to float
  %968 = insertelement <3 x float> %963, float %967, i32 1
  %969 = or i32 %959, 2
  %970 = getelementptr inbounds i8, i8* %872, i32 %969
  %971 = load i8, i8* %970, align 1, !tbaa !19
  %972 = uitofp i8 %971 to float
  %973 = insertelement <3 x float> %968, float %972, i32 2
  %974 = insertelement <3 x float> undef, float %829, i32 0
  %975 = shufflevector <3 x float> %974, <3 x float> undef, <3 x i32> zeroinitializer
  %976 = fmul <3 x float> %975, %958
  %977 = insertelement <3 x float> undef, float %frac.0.i, i32 0
  %978 = shufflevector <3 x float> %977, <3 x float> undef, <3 x i32> zeroinitializer
  %979 = fmul <3 x float> %978, %973
  %980 = fadd <3 x float> %976, %979
  %981 = fmul <3 x float> %980, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %982 = extractelement <3 x float> %981, i32 0
  %983 = insertelement <4 x float> undef, float %982, i32 0
  %984 = insertelement <4 x float> %983, float %982, i32 1
  %985 = extractelement <3 x float> %981, i32 2
  %986 = insertelement <4 x float> %984, float %985, i32 2
  %987 = insertelement <4 x float> %986, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:988                                     ; preds = %wrapI.exit6.i
  %989 = getelementptr inbounds i8, i8* %872, i32 %870
  %990 = load i8, i8* %989, align 1, !tbaa !19
  %991 = uitofp i8 %990 to float
  %992 = getelementptr inbounds i8, i8* %872, i32 %865
  %993 = load i8, i8* %992, align 1, !tbaa !19
  %994 = uitofp i8 %993 to float
  %995 = fmul float %829, %991
  %996 = fmul float %frac.0.i, %994
  %997 = fadd float %995, %996
  %998 = fmul float %997, 0x3F70101020000000
  %999 = insertelement <4 x float> undef, float %998, i32 0
  %1000 = insertelement <4 x float> %999, float %998, i32 1
  %1001 = insertelement <4 x float> %1000, float %998, i32 2
  %1002 = insertelement <4 x float> %1001, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:1003                                    ; preds = %wrapI.exit6.i
  %1004 = shl nsw i32 %870, 1
  %1005 = getelementptr inbounds i8, i8* %872, i32 %1004
  %1006 = load i8, i8* %1005, align 1, !tbaa !19
  %1007 = uitofp i8 %1006 to float
  %1008 = insertelement <2 x float> undef, float %1007, i32 0
  %1009 = or i32 %1004, 1
  %1010 = getelementptr inbounds i8, i8* %872, i32 %1009
  %1011 = load i8, i8* %1010, align 1, !tbaa !19
  %1012 = uitofp i8 %1011 to float
  %1013 = insertelement <2 x float> %1008, float %1012, i32 1
  %1014 = shl nsw i32 %865, 1
  %1015 = getelementptr inbounds i8, i8* %872, i32 %1014
  %1016 = load i8, i8* %1015, align 1, !tbaa !19
  %1017 = uitofp i8 %1016 to float
  %1018 = insertelement <2 x float> undef, float %1017, i32 0
  %1019 = or i32 %1014, 1
  %1020 = getelementptr inbounds i8, i8* %872, i32 %1019
  %1021 = load i8, i8* %1020, align 1, !tbaa !19
  %1022 = uitofp i8 %1021 to float
  %1023 = insertelement <2 x float> %1018, float %1022, i32 1
  %1024 = shufflevector <2 x float> %831, <2 x float> undef, <2 x i32> zeroinitializer
  %1025 = fmul <2 x float> %1024, %1013
  %1026 = shufflevector <2 x float> %831, <2 x float> undef, <2 x i32> <i32 1, i32 1>
  %1027 = fmul <2 x float> %1026, %1023
  %1028 = fadd <2 x float> %1025, %1027
  %1029 = fmul <2 x float> %1028, <float 0x3F70101020000000, float 0x3F70101020000000>
  %1030 = extractelement <2 x float> %1029, i32 0
  %1031 = insertelement <4 x float> undef, float %1030, i32 0
  %1032 = insertelement <4 x float> %1031, float %1030, i32 1
  %1033 = insertelement <4 x float> %1032, float %1030, i32 2
  %1034 = extractelement <2 x float> %1029, i32 1
  %1035 = insertelement <4 x float> %1033, float %1034, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit: ; preds = %wrapI.exit6.i, %873, %892, %906, %943, %988, %1003
  %.0.i.i = phi <4 x float> [ %1035, %1003 ], [ %1002, %988 ], [ %942, %906 ], [ %987, %943 ], [ %903, %892 ], [ %891, %873 ], [ zeroinitializer, %wrapI.exit6.i ]
  %1036 = uitofp i32 %591 to float
  %1037 = fsub float %lod, %1036
  %1038 = fsub float 1.000000e+00, %1037
  %1039 = insertelement <4 x float> undef, float %1038, i32 0
  %1040 = shufflevector <4 x float> %1039, <4 x float> undef, <4 x i32> zeroinitializer
  %1041 = fmul <4 x float> %.0.i.i28, %1040
  %1042 = insertelement <4 x float> undef, float %1037, i32 0
  %1043 = shufflevector <4 x float> %1042, <4 x float> undef, <4 x i32> zeroinitializer
  %1044 = fmul <4 x float> %.0.i.i, %1043
  %1045 = fadd <4 x float> %1044, %1041
  br label %1143

; <label>:1046                                    ; preds = %349
  %1047 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %1048 = load i32, i32* %1047, align 4, !tbaa !21
  %1049 = sitofp i32 %1048 to float
  %1050 = fmul float %1049, %uv
  %1051 = fptosi float %1050 to i32
  switch i32 %21, label %wrapI.exit.i8 [
    i32 3, label %.thread.i.i2
    i32 6, label %1055
  ]

.thread.i.i2:                                     ; preds = %1046
  %1052 = srem i32 %1051, %1048
  %1053 = icmp slt i32 %1052, 0
  %1054 = select i1 %1053, i32 %1048, i32 0
  %..i.i1 = add nsw i32 %1054, %1052
  br label %wrapI.exit.i8

; <label>:1055                                    ; preds = %1046
  %1056 = shl nsw i32 %1048, 1
  %1057 = srem i32 %1051, %1056
  %1058 = icmp slt i32 %1057, 0
  %1059 = select i1 %1058, i32 %1056, i32 0
  %.3.i.i3 = add nsw i32 %1059, %1057
  %1060 = icmp slt i32 %.3.i.i3, %1048
  %1061 = sub nsw i32 %1056, %.3.i.i3
  %.3..i.i4 = select i1 %1060, i32 %.3.i.i3, i32 %1061
  br label %wrapI.exit.i8

wrapI.exit.i8:                                    ; preds = %1055, %.thread.i.i2, %1046
  %.2.i.i5 = phi i32 [ %.3..i.i4, %1055 ], [ %..i.i1, %.thread.i.i2 ], [ %1051, %1046 ]
  %1062 = add nsw i32 %1048, -1
  %1063 = icmp slt i32 %.2.i.i5, %1062
  %1064 = select i1 %1063, i32 %.2.i.i5, i32 %1062
  %1065 = icmp sgt i32 0, %1064
  %1066 = select i1 %1065, i32 0, i32 %1064
  %alloc.idx.i6 = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %alloc.idx.val.i7 = load i8*, i8** %alloc.idx.i6, align 4, !tbaa !22
  switch i32 %13, label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10 [
    i32 11, label %1067
    i32 8, label %1073
    i32 9, label %1078
    i32 10, label %1092
    i32 7, label %1135
  ]

; <label>:1067                                    ; preds = %wrapI.exit.i8
  %1068 = shl nsw i32 %1066, 2
  %1069 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1068
  %1070 = bitcast i8* %1069 to <4 x i8>*
  %1071 = load <4 x i8>, <4 x i8>* %1070, align 4, !tbaa !19
  %1072 = uitofp <4 x i8> %1071 to <4 x float>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10

; <label>:1073                                    ; preds = %wrapI.exit.i8
  %1074 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1066
  %1075 = load i8, i8* %1074, align 1, !tbaa !19
  %1076 = uitofp i8 %1075 to float
  %1077 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %1076, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10

; <label>:1078                                    ; preds = %wrapI.exit.i8
  %1079 = shl nsw i32 %1066, 1
  %1080 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1079
  %1081 = load i8, i8* %1080, align 1, !tbaa !19
  %1082 = uitofp i8 %1081 to float
  %1083 = insertelement <2 x float> undef, float %1082, i32 0
  %1084 = or i32 %1079, 1
  %1085 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1084
  %1086 = load i8, i8* %1085, align 1, !tbaa !19
  %1087 = uitofp i8 %1086 to float
  %1088 = insertelement <2 x float> %1083, float %1087, i32 1
  %1089 = shufflevector <2 x float> %1088, <2 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 1>
  %1090 = shufflevector <2 x float> %1088, <2 x float> undef, <4 x i32> <i32 0, i32 0, i32 undef, i32 undef>
  %1091 = shufflevector <4 x float> %1089, <4 x float> %1090, <4 x i32> <i32 4, i32 5, i32 2, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10

; <label>:1092                                    ; preds = %wrapI.exit.i8
  %1093 = icmp eq i32 %15, 13
  br i1 %1093, label %1094, label %1118

; <label>:1094                                    ; preds = %1092
  %1095 = bitcast i8* %alloc.idx.val.i7 to i16*
  %1096 = load i16, i16* %1095, align 2, !tbaa !70
  %1097 = zext i16 %1096 to i32
  %1098 = lshr i32 %1097, 11
  %1099 = shl nuw nsw i32 %1098, 3
  %1100 = lshr i32 %1097, 13
  %1101 = or i32 %1099, %1100
  %1102 = uitofp i32 %1101 to float
  %1103 = insertelement <4 x float> undef, float %1102, i32 0
  %1104 = lshr i32 %1097, 5
  %1105 = and i32 %1104, 63
  %1106 = shl nuw nsw i32 %1105, 2
  %1107 = lshr i32 %1105, 4
  %1108 = or i32 %1106, %1107
  %1109 = uitofp i32 %1108 to float
  %1110 = insertelement <4 x float> %1103, float %1109, i32 1
  %1111 = and i32 %1097, 31
  %1112 = shl nuw nsw i32 %1111, 3
  %1113 = lshr i32 %1111, 2
  %1114 = or i32 %1112, %1113
  %1115 = uitofp i32 %1114 to float
  %1116 = insertelement <4 x float> %1110, float %1115, i32 2
  %1117 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %1116, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10

; <label>:1118                                    ; preds = %1092
  %1119 = shl nsw i32 %1066, 2
  %1120 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1119
  %1121 = load i8, i8* %1120, align 1, !tbaa !19
  %1122 = uitofp i8 %1121 to float
  %1123 = insertelement <4 x float> undef, float %1122, i32 0
  %1124 = or i32 %1119, 1
  %1125 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1124
  %1126 = load i8, i8* %1125, align 1, !tbaa !19
  %1127 = uitofp i8 %1126 to float
  %1128 = insertelement <4 x float> %1123, float %1127, i32 1
  %1129 = or i32 %1119, 2
  %1130 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1129
  %1131 = load i8, i8* %1130, align 1, !tbaa !19
  %1132 = uitofp i8 %1131 to float
  %1133 = insertelement <4 x float> %1128, float %1132, i32 2
  %1134 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %1133, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10

; <label>:1135                                    ; preds = %wrapI.exit.i8
  %1136 = getelementptr inbounds i8, i8* %alloc.idx.val.i7, i32 %1066
  %1137 = load i8, i8* %1136, align 1, !tbaa !19
  %1138 = uitofp i8 %1137 to float
  %1139 = insertelement <3 x float> undef, float %1138, i32 0
  %1140 = shufflevector <3 x float> %1139, <3 x float> undef, <4 x i32> <i32 0, i32 0, i32 0, i32 undef>
  %1141 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %1140, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10

_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10: ; preds = %wrapI.exit.i8, %1067, %1073, %1078, %1094, %1118, %1135
  %result.0.i.i9 = phi <4 x float> [ <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 2.550000e+02>, %wrapI.exit.i8 ], [ %1141, %1135 ], [ %1117, %1094 ], [ %1134, %1118 ], [ %1091, %1078 ], [ %1077, %1073 ], [ %1072, %1067 ]
  %1142 = fmul <4 x float> %result.0.i.i9, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %1143

; <label>:1143                                    ; preds = %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit, %0
  %.0 = phi <4 x float> [ %126, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit ], [ %.0.i.i58, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit59 ], [ %.0.i.i43, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit44 ], [ %1045, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit ], [ %1142, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit10 ], [ zeroinitializer, %0 ]
  ret <4 x float> %.0
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z8rsSample13rs_allocation10rs_samplerf([1 x i32] %a.coerce, [1 x i32] %s.coerce, float %location) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = extractvalue [1 x i32] %s.coerce, 0
  %3 = inttoptr i32 %1 to %struct.Allocation*
  %4 = inttoptr i32 %2 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 0
  %6 = load i8*, i8** %5, align 4, !tbaa !22
  %7 = getelementptr inbounds i8, i8* %6, i32 36
  %8 = bitcast i8* %7 to i8**
  %9 = load i8*, i8** %8, align 4, !tbaa !22
  %10 = getelementptr inbounds i8, i8* %9, i32 36
  %11 = getelementptr inbounds i8, i8* %9, i32 40
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12, align 4, !tbaa !19
  %14 = bitcast i8* %10 to i32*
  %15 = load i32, i32* %14, align 4, !tbaa !19
  %16 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 2
  %17 = load i32, i32* %16, align 4, !tbaa !19
  %18 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 1
  %19 = load i32, i32* %18, align 4, !tbaa !21
  %20 = and i32 %19, 2
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %_Z8rsSample13rs_allocation10rs_samplerff.exit, label %22

; <label>:22                                      ; preds = %0
  %23 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 0
  %24 = load i32, i32* %23, align 4, !tbaa !19
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %123

; <label>:26                                      ; preds = %22
  %27 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %28 = load i32, i32* %27, align 4, !tbaa !21
  %29 = sitofp i32 %28 to float
  %30 = fmul float %29, %location
  %31 = fptosi float %30 to i32
  switch i32 %17, label %wrapI.exit.i [
    i32 3, label %.thread.i.i
    i32 6, label %35
  ]

.thread.i.i:                                      ; preds = %26
  %32 = srem i32 %31, %28
  %33 = icmp slt i32 %32, 0
  %34 = select i1 %33, i32 %28, i32 0
  %..i.i = add nsw i32 %34, %32
  br label %wrapI.exit.i

; <label>:35                                      ; preds = %26
  %36 = shl nsw i32 %28, 1
  %37 = srem i32 %31, %36
  %38 = icmp slt i32 %37, 0
  %39 = select i1 %38, i32 %36, i32 0
  %.3.i.i = add nsw i32 %39, %37
  %40 = icmp slt i32 %.3.i.i, %28
  %41 = sub nsw i32 %36, %.3.i.i
  %.3..i.i = select i1 %40, i32 %.3.i.i, i32 %41
  br label %wrapI.exit.i

wrapI.exit.i:                                     ; preds = %35, %.thread.i.i, %26
  %.2.i.i = phi i32 [ %.3..i.i, %35 ], [ %..i.i, %.thread.i.i ], [ %31, %26 ]
  %42 = add nsw i32 %28, -1
  %43 = icmp slt i32 %.2.i.i, %42
  %44 = select i1 %43, i32 %.2.i.i, i32 %42
  %45 = icmp sgt i32 0, %44
  %46 = select i1 %45, i32 0, i32 %44
  %alloc.idx.i = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %alloc.idx.val.i = load i8*, i8** %alloc.idx.i, align 4, !tbaa !22
  switch i32 %13, label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit [
    i32 11, label %47
    i32 8, label %53
    i32 9, label %58
    i32 10, label %72
    i32 7, label %115
  ]

; <label>:47                                      ; preds = %wrapI.exit.i
  %48 = shl nsw i32 %46, 2
  %49 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %48
  %50 = bitcast i8* %49 to <4 x i8>*
  %51 = load <4 x i8>, <4 x i8>* %50, align 4, !tbaa !19
  %52 = uitofp <4 x i8> %51 to <4 x float>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:53                                      ; preds = %wrapI.exit.i
  %54 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %46
  %55 = load i8, i8* %54, align 1, !tbaa !19
  %56 = uitofp i8 %55 to float
  %57 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %56, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:58                                      ; preds = %wrapI.exit.i
  %59 = shl nsw i32 %46, 1
  %60 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %59
  %61 = load i8, i8* %60, align 1, !tbaa !19
  %62 = uitofp i8 %61 to float
  %63 = insertelement <2 x float> undef, float %62, i32 0
  %64 = or i32 %59, 1
  %65 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %64
  %66 = load i8, i8* %65, align 1, !tbaa !19
  %67 = uitofp i8 %66 to float
  %68 = insertelement <2 x float> %63, float %67, i32 1
  %69 = shufflevector <2 x float> %68, <2 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 1>
  %70 = shufflevector <2 x float> %68, <2 x float> undef, <4 x i32> <i32 0, i32 0, i32 undef, i32 undef>
  %71 = shufflevector <4 x float> %69, <4 x float> %70, <4 x i32> <i32 4, i32 5, i32 2, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:72                                      ; preds = %wrapI.exit.i
  %73 = icmp eq i32 %15, 13
  br i1 %73, label %74, label %98

; <label>:74                                      ; preds = %72
  %75 = bitcast i8* %alloc.idx.val.i to i16*
  %76 = load i16, i16* %75, align 2, !tbaa !70
  %77 = zext i16 %76 to i32
  %78 = lshr i32 %77, 11
  %79 = shl nuw nsw i32 %78, 3
  %80 = lshr i32 %77, 13
  %81 = or i32 %79, %80
  %82 = uitofp i32 %81 to float
  %83 = insertelement <4 x float> undef, float %82, i32 0
  %84 = lshr i32 %77, 5
  %85 = and i32 %84, 63
  %86 = shl nuw nsw i32 %85, 2
  %87 = lshr i32 %85, 4
  %88 = or i32 %86, %87
  %89 = uitofp i32 %88 to float
  %90 = insertelement <4 x float> %83, float %89, i32 1
  %91 = and i32 %77, 31
  %92 = shl nuw nsw i32 %91, 3
  %93 = lshr i32 %91, 2
  %94 = or i32 %92, %93
  %95 = uitofp i32 %94 to float
  %96 = insertelement <4 x float> %90, float %95, i32 2
  %97 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %96, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:98                                      ; preds = %72
  %99 = shl nsw i32 %46, 2
  %100 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %99
  %101 = load i8, i8* %100, align 1, !tbaa !19
  %102 = uitofp i8 %101 to float
  %103 = insertelement <4 x float> undef, float %102, i32 0
  %104 = or i32 %99, 1
  %105 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %104
  %106 = load i8, i8* %105, align 1, !tbaa !19
  %107 = uitofp i8 %106 to float
  %108 = insertelement <4 x float> %103, float %107, i32 1
  %109 = or i32 %99, 2
  %110 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %109
  %111 = load i8, i8* %110, align 1, !tbaa !19
  %112 = uitofp i8 %111 to float
  %113 = insertelement <4 x float> %108, float %112, i32 2
  %114 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %113, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:115                                     ; preds = %wrapI.exit.i
  %116 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %46
  %117 = load i8, i8* %116, align 1, !tbaa !19
  %118 = uitofp i8 %117 to float
  %119 = insertelement <3 x float> undef, float %118, i32 0
  %120 = shufflevector <3 x float> %119, <3 x float> undef, <4 x i32> <i32 0, i32 0, i32 0, i32 undef>
  %121 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %120, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit: ; preds = %wrapI.exit.i, %47, %53, %58, %74, %98, %115
  %result.0.i.i = phi <4 x float> [ <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 2.550000e+02>, %wrapI.exit.i ], [ %121, %115 ], [ %97, %74 ], [ %114, %98 ], [ %71, %58 ], [ %57, %53 ], [ %52, %47 ]
  %122 = fmul <4 x float> %result.0.i.i, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_Z8rsSample13rs_allocation10rs_samplerff.exit

; <label>:123                                     ; preds = %22
  %124 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %125 = load i32, i32* %124, align 4, !tbaa !21
  %126 = sitofp i32 %125 to float
  %127 = fmul float %126, %location
  %128 = fptosi float %127 to i32
  %129 = sitofp i32 %128 to float
  %130 = fsub float %127, %129
  %131 = fcmp olt float %130, 5.000000e-01
  br i1 %131, label %132, label %135

; <label>:132                                     ; preds = %123
  %133 = add nsw i32 %128, -1
  %134 = fadd float %130, 5.000000e-01
  br label %137

; <label>:135                                     ; preds = %123
  %136 = fadd float %130, -5.000000e-01
  br label %137

; <label>:137                                     ; preds = %135, %132
  %frac.0.i = phi float [ %134, %132 ], [ %136, %135 ]
  %iPixel.0.i = phi i32 [ %133, %132 ], [ %128, %135 ]
  %138 = fsub float 1.000000e+00, %frac.0.i
  %139 = insertelement <2 x float> undef, float %138, i32 0
  %140 = insertelement <2 x float> %139, float %frac.0.i, i32 1
  %141 = add nsw i32 %iPixel.0.i, 1
  switch i32 %17, label %wrapI.exit.i4 [
    i32 3, label %wrapI.exit.thread.i
    i32 6, label %wrapI.exit.thread7.i
  ]

wrapI.exit.thread.i:                              ; preds = %137
  %142 = srem i32 %141, %125
  %143 = icmp slt i32 %142, 0
  %144 = select i1 %143, i32 %125, i32 0
  %..i.i1 = add nsw i32 %144, %142
  %145 = add nsw i32 %125, -1
  %146 = icmp slt i32 %..i.i1, %145
  %147 = select i1 %146, i32 %..i.i1, i32 %145
  %148 = icmp sgt i32 0, %147
  %149 = select i1 %148, i32 0, i32 %147
  %150 = srem i32 %iPixel.0.i, %125
  %151 = icmp slt i32 %150, 0
  %152 = select i1 %151, i32 %125, i32 0
  %..i1.i = add nsw i32 %152, %150
  br label %wrapI.exit6.i

wrapI.exit.thread7.i:                             ; preds = %137
  %153 = shl nsw i32 %125, 1
  %154 = srem i32 %141, %153
  %155 = icmp slt i32 %154, 0
  %156 = select i1 %155, i32 %153, i32 0
  %.3.i.i2 = add nsw i32 %156, %154
  %157 = icmp slt i32 %.3.i.i2, %125
  %158 = sub nsw i32 %153, %.3.i.i2
  %.3..i.i3 = select i1 %157, i32 %.3.i.i2, i32 %158
  %159 = add nsw i32 %125, -1
  %160 = icmp slt i32 %.3..i.i3, %159
  %161 = select i1 %160, i32 %.3..i.i3, i32 %159
  %162 = icmp sgt i32 0, %161
  %163 = select i1 %162, i32 0, i32 %161
  %164 = srem i32 %iPixel.0.i, %153
  %165 = icmp slt i32 %164, 0
  %166 = select i1 %165, i32 %153, i32 0
  %.3.i3.i = add nsw i32 %166, %164
  %167 = icmp slt i32 %.3.i3.i, %125
  %168 = sub nsw i32 %153, %.3.i3.i
  %.3..i4.i = select i1 %167, i32 %.3.i3.i, i32 %168
  br label %wrapI.exit6.i

wrapI.exit.i4:                                    ; preds = %137
  %169 = add nsw i32 %125, -1
  %170 = icmp slt i32 %141, %169
  %171 = select i1 %170, i32 %141, i32 %169
  %172 = icmp sgt i32 0, %171
  %173 = select i1 %172, i32 0, i32 %171
  br label %wrapI.exit6.i

wrapI.exit6.i:                                    ; preds = %wrapI.exit.i4, %wrapI.exit.thread7.i, %wrapI.exit.thread.i
  %174 = phi i32 [ %163, %wrapI.exit.thread7.i ], [ %149, %wrapI.exit.thread.i ], [ %173, %wrapI.exit.i4 ]
  %175 = phi i32 [ %159, %wrapI.exit.thread7.i ], [ %145, %wrapI.exit.thread.i ], [ %169, %wrapI.exit.i4 ]
  %.2.i5.i = phi i32 [ %.3..i4.i, %wrapI.exit.thread7.i ], [ %..i1.i, %wrapI.exit.thread.i ], [ %iPixel.0.i, %wrapI.exit.i4 ]
  %176 = icmp slt i32 %.2.i5.i, %175
  %177 = select i1 %176, i32 %.2.i5.i, i32 %175
  %178 = icmp sgt i32 0, %177
  %179 = select i1 %178, i32 0, i32 %177
  %180 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %181 = load i8*, i8** %180, align 4, !tbaa !22
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit [
    i32 11, label %182
    i32 8, label %201
    i32 10, label %213
    i32 7, label %297
    i32 9, label %312
  ]

; <label>:182                                     ; preds = %wrapI.exit6.i
  %183 = shl nsw i32 %179, 2
  %184 = getelementptr inbounds i8, i8* %181, i32 %183
  %185 = bitcast i8* %184 to <4 x i8>*
  %186 = load <4 x i8>, <4 x i8>* %185, align 4, !tbaa !19
  %187 = uitofp <4 x i8> %186 to <4 x float>
  %188 = shl nsw i32 %174, 2
  %189 = getelementptr inbounds i8, i8* %181, i32 %188
  %190 = bitcast i8* %189 to <4 x i8>*
  %191 = load <4 x i8>, <4 x i8>* %190, align 4, !tbaa !19
  %192 = uitofp <4 x i8> %191 to <4 x float>
  %193 = insertelement <4 x float> undef, float %138, i32 0
  %194 = shufflevector <4 x float> %193, <4 x float> undef, <4 x i32> zeroinitializer
  %195 = fmul <4 x float> %194, %187
  %196 = insertelement <4 x float> undef, float %frac.0.i, i32 0
  %197 = shufflevector <4 x float> %196, <4 x float> undef, <4 x i32> zeroinitializer
  %198 = fmul <4 x float> %197, %192
  %199 = fadd <4 x float> %195, %198
  %200 = fmul <4 x float> %199, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:201                                     ; preds = %wrapI.exit6.i
  %202 = getelementptr inbounds i8, i8* %181, i32 %179
  %203 = load i8, i8* %202, align 1, !tbaa !19
  %204 = uitofp i8 %203 to float
  %205 = getelementptr inbounds i8, i8* %181, i32 %174
  %206 = load i8, i8* %205, align 1, !tbaa !19
  %207 = uitofp i8 %206 to float
  %208 = fmul float %138, %204
  %209 = fmul float %frac.0.i, %207
  %210 = fadd float %208, %209
  %211 = fmul float %210, 0x3F70101020000000
  %212 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %211, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:213                                     ; preds = %wrapI.exit6.i
  %214 = icmp eq i32 %15, 13
  br i1 %214, label %215, label %252

; <label>:215                                     ; preds = %213
  %216 = bitcast i8* %181 to i16*
  %217 = load i16, i16* %216, align 2, !tbaa !70
  %218 = zext i16 %217 to i32
  %219 = lshr i32 %218, 11
  %220 = shl nuw nsw i32 %219, 3
  %221 = lshr i32 %218, 13
  %222 = or i32 %220, %221
  %223 = uitofp i32 %222 to float
  %224 = insertelement <3 x float> undef, float %223, i32 0
  %225 = lshr i32 %218, 5
  %226 = and i32 %225, 63
  %227 = shl nuw nsw i32 %226, 2
  %228 = lshr i32 %226, 4
  %229 = or i32 %227, %228
  %230 = uitofp i32 %229 to float
  %231 = insertelement <3 x float> %224, float %230, i32 1
  %232 = and i32 %218, 31
  %233 = shl nuw nsw i32 %232, 3
  %234 = lshr i32 %232, 2
  %235 = or i32 %233, %234
  %236 = uitofp i32 %235 to float
  %237 = insertelement <3 x float> %231, float %236, i32 2
  %238 = insertelement <3 x float> undef, float %138, i32 0
  %239 = shufflevector <3 x float> %238, <3 x float> undef, <3 x i32> zeroinitializer
  %240 = fmul <3 x float> %239, %237
  %241 = insertelement <3 x float> undef, float %frac.0.i, i32 0
  %242 = shufflevector <3 x float> %241, <3 x float> undef, <3 x i32> zeroinitializer
  %243 = fmul <3 x float> %242, %237
  %244 = fadd <3 x float> %240, %243
  %245 = fmul <3 x float> %244, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %246 = extractelement <3 x float> %245, i32 0
  %247 = insertelement <4 x float> undef, float %246, i32 0
  %248 = insertelement <4 x float> %247, float %246, i32 1
  %249 = extractelement <3 x float> %245, i32 2
  %250 = insertelement <4 x float> %248, float %249, i32 2
  %251 = insertelement <4 x float> %250, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:252                                     ; preds = %213
  %253 = shl nsw i32 %179, 2
  %254 = getelementptr inbounds i8, i8* %181, i32 %253
  %255 = load i8, i8* %254, align 1, !tbaa !19
  %256 = uitofp i8 %255 to float
  %257 = insertelement <3 x float> undef, float %256, i32 0
  %258 = or i32 %253, 1
  %259 = getelementptr inbounds i8, i8* %181, i32 %258
  %260 = load i8, i8* %259, align 1, !tbaa !19
  %261 = uitofp i8 %260 to float
  %262 = insertelement <3 x float> %257, float %261, i32 1
  %263 = or i32 %253, 2
  %264 = getelementptr inbounds i8, i8* %181, i32 %263
  %265 = load i8, i8* %264, align 1, !tbaa !19
  %266 = uitofp i8 %265 to float
  %267 = insertelement <3 x float> %262, float %266, i32 2
  %268 = shl nsw i32 %174, 2
  %269 = getelementptr inbounds i8, i8* %181, i32 %268
  %270 = load i8, i8* %269, align 1, !tbaa !19
  %271 = uitofp i8 %270 to float
  %272 = insertelement <3 x float> undef, float %271, i32 0
  %273 = or i32 %268, 1
  %274 = getelementptr inbounds i8, i8* %181, i32 %273
  %275 = load i8, i8* %274, align 1, !tbaa !19
  %276 = uitofp i8 %275 to float
  %277 = insertelement <3 x float> %272, float %276, i32 1
  %278 = or i32 %268, 2
  %279 = getelementptr inbounds i8, i8* %181, i32 %278
  %280 = load i8, i8* %279, align 1, !tbaa !19
  %281 = uitofp i8 %280 to float
  %282 = insertelement <3 x float> %277, float %281, i32 2
  %283 = insertelement <3 x float> undef, float %138, i32 0
  %284 = shufflevector <3 x float> %283, <3 x float> undef, <3 x i32> zeroinitializer
  %285 = fmul <3 x float> %284, %267
  %286 = insertelement <3 x float> undef, float %frac.0.i, i32 0
  %287 = shufflevector <3 x float> %286, <3 x float> undef, <3 x i32> zeroinitializer
  %288 = fmul <3 x float> %287, %282
  %289 = fadd <3 x float> %285, %288
  %290 = fmul <3 x float> %289, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %291 = extractelement <3 x float> %290, i32 0
  %292 = insertelement <4 x float> undef, float %291, i32 0
  %293 = insertelement <4 x float> %292, float %291, i32 1
  %294 = extractelement <3 x float> %290, i32 2
  %295 = insertelement <4 x float> %293, float %294, i32 2
  %296 = insertelement <4 x float> %295, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:297                                     ; preds = %wrapI.exit6.i
  %298 = getelementptr inbounds i8, i8* %181, i32 %179
  %299 = load i8, i8* %298, align 1, !tbaa !19
  %300 = uitofp i8 %299 to float
  %301 = getelementptr inbounds i8, i8* %181, i32 %174
  %302 = load i8, i8* %301, align 1, !tbaa !19
  %303 = uitofp i8 %302 to float
  %304 = fmul float %138, %300
  %305 = fmul float %frac.0.i, %303
  %306 = fadd float %304, %305
  %307 = fmul float %306, 0x3F70101020000000
  %308 = insertelement <4 x float> undef, float %307, i32 0
  %309 = insertelement <4 x float> %308, float %307, i32 1
  %310 = insertelement <4 x float> %309, float %307, i32 2
  %311 = insertelement <4 x float> %310, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

; <label>:312                                     ; preds = %wrapI.exit6.i
  %313 = shl nsw i32 %179, 1
  %314 = getelementptr inbounds i8, i8* %181, i32 %313
  %315 = load i8, i8* %314, align 1, !tbaa !19
  %316 = uitofp i8 %315 to float
  %317 = insertelement <2 x float> undef, float %316, i32 0
  %318 = or i32 %313, 1
  %319 = getelementptr inbounds i8, i8* %181, i32 %318
  %320 = load i8, i8* %319, align 1, !tbaa !19
  %321 = uitofp i8 %320 to float
  %322 = insertelement <2 x float> %317, float %321, i32 1
  %323 = shl nsw i32 %174, 1
  %324 = getelementptr inbounds i8, i8* %181, i32 %323
  %325 = load i8, i8* %324, align 1, !tbaa !19
  %326 = uitofp i8 %325 to float
  %327 = insertelement <2 x float> undef, float %326, i32 0
  %328 = or i32 %323, 1
  %329 = getelementptr inbounds i8, i8* %181, i32 %328
  %330 = load i8, i8* %329, align 1, !tbaa !19
  %331 = uitofp i8 %330 to float
  %332 = insertelement <2 x float> %327, float %331, i32 1
  %333 = shufflevector <2 x float> %140, <2 x float> undef, <2 x i32> zeroinitializer
  %334 = fmul <2 x float> %333, %322
  %335 = shufflevector <2 x float> %140, <2 x float> undef, <2 x i32> <i32 1, i32 1>
  %336 = fmul <2 x float> %335, %332
  %337 = fadd <2 x float> %334, %336
  %338 = fmul <2 x float> %337, <float 0x3F70101020000000, float 0x3F70101020000000>
  %339 = extractelement <2 x float> %338, i32 0
  %340 = insertelement <4 x float> undef, float %339, i32 0
  %341 = insertelement <4 x float> %340, float %339, i32 1
  %342 = insertelement <4 x float> %341, float %339, i32 2
  %343 = extractelement <2 x float> %338, i32 1
  %344 = insertelement <4 x float> %342, float %343, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit: ; preds = %wrapI.exit6.i, %182, %201, %215, %252, %297, %312
  %.0.i.i = phi <4 x float> [ %344, %312 ], [ %311, %297 ], [ %251, %215 ], [ %296, %252 ], [ %212, %201 ], [ %200, %182 ], [ zeroinitializer, %wrapI.exit6.i ]
  br label %_Z8rsSample13rs_allocation10rs_samplerff.exit

_Z8rsSample13rs_allocation10rs_samplerff.exit:    ; preds = %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit, %0
  %.0.i = phi <4 x float> [ %122, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit ], [ %.0.i.i, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valuefj.exit ], [ zeroinitializer, %0 ]
  ret <4 x float> %.0.i
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z8rsSample13rs_allocation10rs_samplerDv2_ff([1 x i32] %a.coerce, [1 x i32] %s.coerce, <2 x float> %uv, float %lod) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = extractvalue [1 x i32] %s.coerce, 0
  %3 = inttoptr i32 %1 to %struct.Allocation*
  %4 = inttoptr i32 %2 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 0
  %6 = load i8*, i8** %5, align 4, !tbaa !22
  %7 = getelementptr inbounds i8, i8* %6, i32 36
  %8 = bitcast i8* %7 to i8**
  %9 = load i8*, i8** %8, align 4, !tbaa !22
  %10 = getelementptr inbounds i8, i8* %9, i32 36
  %11 = getelementptr inbounds i8, i8* %9, i32 40
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12, align 4, !tbaa !19
  %14 = bitcast i8* %10 to i32*
  %15 = load i32, i32* %14, align 4, !tbaa !19
  %16 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 1
  %17 = load i32, i32* %16, align 4, !tbaa !19
  %18 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 0
  %19 = load i32, i32* %18, align 4, !tbaa !19
  %20 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 2
  %21 = load i32, i32* %20, align 4, !tbaa !19
  %22 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 3
  %23 = load i32, i32* %22, align 4, !tbaa !19
  %24 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 1
  %25 = load i32, i32* %24, align 4, !tbaa !21
  %26 = and i32 %25, 2
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %2207, label %28

; <label>:28                                      ; preds = %0
  %29 = fcmp ugt float %lod, 0.000000e+00
  br i1 %29, label %634, label %30

; <label>:30                                      ; preds = %28
  %31 = icmp eq i32 %19, 0
  br i1 %31, label %32, label %164

; <label>:32                                      ; preds = %30
  %33 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %34 = load i32, i32* %33, align 4, !tbaa !21
  %35 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %36 = load i32, i32* %35, align 4, !tbaa !21
  %37 = sitofp i32 %34 to float
  %38 = insertelement <2 x float> undef, float %37, i32 0
  %39 = sitofp i32 %36 to float
  %40 = insertelement <2 x float> %38, float %39, i32 1
  %41 = fmul <2 x float> %40, %uv
  %42 = fptosi <2 x float> %41 to <2 x i32>
  %43 = extractelement <2 x i32> %42, i32 0
  switch i32 %21, label %wrapI.exit.i [
    i32 3, label %.thread.i.i
    i32 6, label %47
  ]

.thread.i.i:                                      ; preds = %32
  %44 = srem i32 %43, %34
  %45 = icmp slt i32 %44, 0
  %46 = select i1 %45, i32 %34, i32 0
  %..i.i = add nsw i32 %46, %44
  br label %wrapI.exit.i

; <label>:47                                      ; preds = %32
  %48 = shl nsw i32 %34, 1
  %49 = srem i32 %43, %48
  %50 = icmp slt i32 %49, 0
  %51 = select i1 %50, i32 %48, i32 0
  %.3.i.i = add nsw i32 %51, %49
  %52 = icmp slt i32 %.3.i.i, %34
  %53 = sub nsw i32 %48, %.3.i.i
  %.3..i.i = select i1 %52, i32 %.3.i.i, i32 %53
  br label %wrapI.exit.i

wrapI.exit.i:                                     ; preds = %47, %.thread.i.i, %32
  %.2.i.i = phi i32 [ %.3..i.i, %47 ], [ %..i.i, %.thread.i.i ], [ %43, %32 ]
  %54 = add nsw i32 %34, -1
  %55 = icmp slt i32 %.2.i.i, %54
  %56 = select i1 %55, i32 %.2.i.i, i32 %54
  %57 = icmp sgt i32 0, %56
  %58 = select i1 %57, i32 0, i32 %56
  %59 = extractelement <2 x i32> %42, i32 1
  switch i32 %23, label %wrapI.exit7.i [
    i32 3, label %.thread.i3.i
    i32 6, label %63
  ]

.thread.i3.i:                                     ; preds = %wrapI.exit.i
  %60 = srem i32 %59, %36
  %61 = icmp slt i32 %60, 0
  %62 = select i1 %61, i32 %36, i32 0
  %..i2.i = add nsw i32 %62, %60
  br label %wrapI.exit7.i

; <label>:63                                      ; preds = %wrapI.exit.i
  %64 = shl nsw i32 %36, 1
  %65 = srem i32 %59, %64
  %66 = icmp slt i32 %65, 0
  %67 = select i1 %66, i32 %64, i32 0
  %.3.i4.i = add nsw i32 %67, %65
  %68 = icmp slt i32 %.3.i4.i, %36
  %69 = sub nsw i32 %64, %.3.i4.i
  %.3..i5.i = select i1 %68, i32 %.3.i4.i, i32 %69
  br label %wrapI.exit7.i

wrapI.exit7.i:                                    ; preds = %63, %.thread.i3.i, %wrapI.exit.i
  %.2.i6.i = phi i32 [ %.3..i5.i, %63 ], [ %..i2.i, %.thread.i3.i ], [ %59, %wrapI.exit.i ]
  %70 = add nsw i32 %36, -1
  %71 = icmp slt i32 %.2.i6.i, %70
  %72 = select i1 %71, i32 %.2.i6.i, i32 %70
  %73 = icmp sgt i32 0, %72
  %74 = select i1 %73, i32 0, i32 %72
  %alloc.idx.i = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %alloc.idx.val.i = load i8*, i8** %alloc.idx.i, align 4, !tbaa !22
  %alloc.idx1.i = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %alloc.idx1.val.i = load i32, i32* %alloc.idx1.i, align 4, !tbaa !21
  switch i32 %13, label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit [
    i32 11, label %75
    i32 8, label %97
    i32 9, label %103
    i32 10, label %118
  ]

; <label>:75                                      ; preds = %wrapI.exit7.i
  %76 = mul i32 %alloc.idx1.val.i, %74
  %77 = shl nsw i32 %58, 2
  %.sum.i.i.i = add i32 %76, %77
  %78 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i.i.i
  %79 = load i8, i8* %78, align 1, !tbaa !19
  %80 = uitofp i8 %79 to float
  %81 = insertelement <4 x float> undef, float %80, i32 0
  %82 = or i32 %77, 1
  %.sum1.i.i.i = add i32 %76, %82
  %83 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum1.i.i.i
  %84 = load i8, i8* %83, align 1, !tbaa !19
  %85 = uitofp i8 %84 to float
  %86 = insertelement <4 x float> %81, float %85, i32 1
  %87 = or i32 %77, 2
  %.sum2.i.i.i = add i32 %76, %87
  %88 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum2.i.i.i
  %89 = load i8, i8* %88, align 1, !tbaa !19
  %90 = uitofp i8 %89 to float
  %91 = insertelement <4 x float> %86, float %90, i32 2
  %92 = or i32 %77, 3
  %.sum3.i.i.i = add i32 %76, %92
  %93 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum3.i.i.i
  %94 = load i8, i8* %93, align 1, !tbaa !19
  %95 = uitofp i8 %94 to float
  %96 = insertelement <4 x float> %91, float %95, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:97                                      ; preds = %wrapI.exit7.i
  %98 = mul i32 %alloc.idx1.val.i, %74
  %.sum.i6.i.i = add i32 %98, %58
  %99 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i6.i.i
  %100 = load i8, i8* %99, align 1, !tbaa !19
  %101 = uitofp i8 %100 to float
  %102 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %101, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:103                                     ; preds = %wrapI.exit7.i
  %104 = mul i32 %alloc.idx1.val.i, %74
  %105 = shl nsw i32 %58, 1
  %.sum.i4.i.i = add i32 %104, %105
  %106 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i4.i.i
  %107 = load i8, i8* %106, align 1, !tbaa !19
  %108 = uitofp i8 %107 to float
  %109 = insertelement <2 x float> undef, float %108, i32 0
  %110 = or i32 %105, 1
  %.sum1.i5.i.i = add i32 %104, %110
  %111 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum1.i5.i.i
  %112 = load i8, i8* %111, align 1, !tbaa !19
  %113 = uitofp i8 %112 to float
  %114 = insertelement <2 x float> %109, float %113, i32 1
  %115 = shufflevector <2 x float> %114, <2 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 1>
  %116 = shufflevector <2 x float> %114, <2 x float> undef, <4 x i32> <i32 0, i32 0, i32 undef, i32 undef>
  %117 = shufflevector <4 x float> %115, <4 x float> %116, <4 x i32> <i32 4, i32 5, i32 2, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:118                                     ; preds = %wrapI.exit7.i
  %119 = icmp eq i32 %15, 13
  %120 = mul i32 %alloc.idx1.val.i, %74
  br i1 %119, label %121, label %146

; <label>:121                                     ; preds = %118
  %122 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %120
  %123 = bitcast i8* %122 to i16*
  %124 = load i16, i16* %123, align 2, !tbaa !70
  %125 = zext i16 %124 to i32
  %126 = lshr i32 %125, 11
  %127 = shl nuw nsw i32 %126, 3
  %128 = lshr i32 %125, 13
  %129 = or i32 %127, %128
  %130 = uitofp i32 %129 to float
  %131 = insertelement <4 x float> undef, float %130, i32 0
  %132 = lshr i32 %125, 5
  %133 = and i32 %132, 63
  %134 = shl nuw nsw i32 %133, 2
  %135 = lshr i32 %133, 4
  %136 = or i32 %134, %135
  %137 = uitofp i32 %136 to float
  %138 = insertelement <4 x float> %131, float %137, i32 1
  %139 = and i32 %125, 31
  %140 = shl nuw nsw i32 %139, 3
  %141 = lshr i32 %139, 2
  %142 = or i32 %140, %141
  %143 = uitofp i32 %142 to float
  %144 = insertelement <4 x float> %138, float %143, i32 2
  %145 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %144, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:146                                     ; preds = %118
  %147 = shl nsw i32 %58, 2
  %.sum.i1.i.i = add i32 %120, %147
  %148 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i1.i.i
  %149 = load i8, i8* %148, align 1, !tbaa !19
  %150 = uitofp i8 %149 to float
  %151 = insertelement <4 x float> undef, float %150, i32 0
  %152 = or i32 %147, 1
  %.sum1.i2.i.i = add i32 %120, %152
  %153 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum1.i2.i.i
  %154 = load i8, i8* %153, align 1, !tbaa !19
  %155 = uitofp i8 %154 to float
  %156 = insertelement <4 x float> %151, float %155, i32 1
  %157 = or i32 %147, 2
  %.sum2.i3.i.i = add i32 %120, %157
  %158 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum2.i3.i.i
  %159 = load i8, i8* %158, align 1, !tbaa !19
  %160 = uitofp i8 %159 to float
  %161 = insertelement <4 x float> %156, float %160, i32 2
  %162 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %161, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit: ; preds = %wrapI.exit7.i, %75, %97, %103, %121, %146
  %result.0.i.i = phi <4 x float> [ <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 2.550000e+02>, %wrapI.exit7.i ], [ %145, %121 ], [ %162, %146 ], [ %117, %103 ], [ %102, %97 ], [ %96, %75 ]
  %163 = fmul <4 x float> %result.0.i.i, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %2207

; <label>:164                                     ; preds = %30
  %165 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %166 = load i32, i32* %165, align 4, !tbaa !21
  %167 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %168 = load i32, i32* %167, align 4, !tbaa !21
  %169 = extractelement <2 x float> %uv, i32 0
  %170 = sitofp i32 %166 to float
  %171 = fmul float %169, %170
  %172 = extractelement <2 x float> %uv, i32 1
  %173 = sitofp i32 %168 to float
  %174 = fmul float %172, %173
  %175 = fptosi float %171 to i32
  %176 = fptosi float %174 to i32
  %177 = sitofp i32 %175 to float
  %178 = fsub float %171, %177
  %179 = sitofp i32 %176 to float
  %180 = fsub float %174, %179
  %181 = fcmp olt float %178, 5.000000e-01
  br i1 %181, label %182, label %185

; <label>:182                                     ; preds = %164
  %183 = add nsw i32 %175, -1
  %184 = fadd float %178, 5.000000e-01
  br label %187

; <label>:185                                     ; preds = %164
  %186 = fadd float %178, -5.000000e-01
  br label %187

; <label>:187                                     ; preds = %185, %182
  %fracU.0.i191 = phi float [ %184, %182 ], [ %186, %185 ]
  %iPixelU.0.i192 = phi i32 [ %183, %182 ], [ %175, %185 ]
  %188 = fcmp olt float %180, 5.000000e-01
  br i1 %188, label %189, label %192

; <label>:189                                     ; preds = %187
  %190 = add nsw i32 %176, -1
  %191 = fadd float %180, 5.000000e-01
  br label %194

; <label>:192                                     ; preds = %187
  %193 = fadd float %180, -5.000000e-01
  br label %194

; <label>:194                                     ; preds = %192, %189
  %fracV.0.i193 = phi float [ %191, %189 ], [ %193, %192 ]
  %iPixelV.0.i194 = phi i32 [ %190, %189 ], [ %176, %192 ]
  %195 = fsub float 1.000000e+00, %fracU.0.i191
  %196 = fsub float 1.000000e+00, %fracV.0.i193
  %197 = fmul float %195, %196
  %198 = fmul float %fracU.0.i191, %196
  %199 = fmul float %195, %fracV.0.i193
  %200 = fmul float %fracU.0.i191, %fracV.0.i193
  %201 = add nsw i32 %iPixelU.0.i192, 1
  switch i32 %21, label %wrapI.exit.i200 [
    i32 3, label %.thread.i.i196
    i32 6, label %205
  ]

.thread.i.i196:                                   ; preds = %194
  %202 = srem i32 %201, %166
  %203 = icmp slt i32 %202, 0
  %204 = select i1 %203, i32 %166, i32 0
  %..i.i195 = add nsw i32 %204, %202
  br label %wrapI.exit.i200

; <label>:205                                     ; preds = %194
  %206 = shl nsw i32 %166, 1
  %207 = srem i32 %201, %206
  %208 = icmp slt i32 %207, 0
  %209 = select i1 %208, i32 %206, i32 0
  %.3.i.i197 = add nsw i32 %209, %207
  %210 = icmp slt i32 %.3.i.i197, %166
  %211 = sub nsw i32 %206, %.3.i.i197
  %.3..i.i198 = select i1 %210, i32 %.3.i.i197, i32 %211
  br label %wrapI.exit.i200

wrapI.exit.i200:                                  ; preds = %205, %.thread.i.i196, %194
  %.2.i.i199 = phi i32 [ %.3..i.i198, %205 ], [ %..i.i195, %.thread.i.i196 ], [ %201, %194 ]
  %212 = add nsw i32 %166, -1
  %213 = icmp slt i32 %.2.i.i199, %212
  %214 = select i1 %213, i32 %.2.i.i199, i32 %212
  %215 = icmp sgt i32 0, %214
  %216 = select i1 %215, i32 0, i32 %214
  %217 = add nsw i32 %iPixelV.0.i194, 1
  switch i32 %23, label %wrapI.exit6.i206 [
    i32 3, label %.thread.i2.i202
    i32 6, label %221
  ]

.thread.i2.i202:                                  ; preds = %wrapI.exit.i200
  %218 = srem i32 %217, %168
  %219 = icmp slt i32 %218, 0
  %220 = select i1 %219, i32 %168, i32 0
  %..i1.i201 = add nsw i32 %220, %218
  br label %wrapI.exit6.i206

; <label>:221                                     ; preds = %wrapI.exit.i200
  %222 = shl nsw i32 %168, 1
  %223 = srem i32 %217, %222
  %224 = icmp slt i32 %223, 0
  %225 = select i1 %224, i32 %222, i32 0
  %.3.i3.i203 = add nsw i32 %225, %223
  %226 = icmp slt i32 %.3.i3.i203, %168
  %227 = sub nsw i32 %222, %.3.i3.i203
  %.3..i4.i204 = select i1 %226, i32 %.3.i3.i203, i32 %227
  br label %wrapI.exit6.i206

wrapI.exit6.i206:                                 ; preds = %221, %.thread.i2.i202, %wrapI.exit.i200
  %.2.i5.i205 = phi i32 [ %.3..i4.i204, %221 ], [ %..i1.i201, %.thread.i2.i202 ], [ %217, %wrapI.exit.i200 ]
  %228 = add nsw i32 %168, -1
  %229 = icmp slt i32 %.2.i5.i205, %228
  %230 = select i1 %229, i32 %.2.i5.i205, i32 %228
  %231 = icmp sgt i32 0, %230
  %232 = select i1 %231, i32 0, i32 %230
  switch i32 %21, label %wrapI.exit12.i212 [
    i32 3, label %.thread.i8.i208
    i32 6, label %236
  ]

.thread.i8.i208:                                  ; preds = %wrapI.exit6.i206
  %233 = srem i32 %iPixelU.0.i192, %166
  %234 = icmp slt i32 %233, 0
  %235 = select i1 %234, i32 %166, i32 0
  %..i7.i207 = add nsw i32 %235, %233
  br label %wrapI.exit12.i212

; <label>:236                                     ; preds = %wrapI.exit6.i206
  %237 = shl nsw i32 %166, 1
  %238 = srem i32 %iPixelU.0.i192, %237
  %239 = icmp slt i32 %238, 0
  %240 = select i1 %239, i32 %237, i32 0
  %.3.i9.i209 = add nsw i32 %240, %238
  %241 = icmp slt i32 %.3.i9.i209, %166
  %242 = sub nsw i32 %237, %.3.i9.i209
  %.3..i10.i210 = select i1 %241, i32 %.3.i9.i209, i32 %242
  br label %wrapI.exit12.i212

wrapI.exit12.i212:                                ; preds = %236, %.thread.i8.i208, %wrapI.exit6.i206
  %.2.i11.i211 = phi i32 [ %.3..i10.i210, %236 ], [ %..i7.i207, %.thread.i8.i208 ], [ %iPixelU.0.i192, %wrapI.exit6.i206 ]
  %243 = icmp slt i32 %.2.i11.i211, %212
  %244 = select i1 %243, i32 %.2.i11.i211, i32 %212
  %245 = icmp sgt i32 0, %244
  %246 = select i1 %245, i32 0, i32 %244
  switch i32 %23, label %wrapI.exit18.i218 [
    i32 3, label %.thread.i14.i214
    i32 6, label %250
  ]

.thread.i14.i214:                                 ; preds = %wrapI.exit12.i212
  %247 = srem i32 %iPixelV.0.i194, %168
  %248 = icmp slt i32 %247, 0
  %249 = select i1 %248, i32 %168, i32 0
  %..i13.i213 = add nsw i32 %249, %247
  br label %wrapI.exit18.i218

; <label>:250                                     ; preds = %wrapI.exit12.i212
  %251 = shl nsw i32 %168, 1
  %252 = srem i32 %iPixelV.0.i194, %251
  %253 = icmp slt i32 %252, 0
  %254 = select i1 %253, i32 %251, i32 0
  %.3.i15.i215 = add nsw i32 %254, %252
  %255 = icmp slt i32 %.3.i15.i215, %168
  %256 = sub nsw i32 %251, %.3.i15.i215
  %.3..i16.i216 = select i1 %255, i32 %.3.i15.i215, i32 %256
  br label %wrapI.exit18.i218

wrapI.exit18.i218:                                ; preds = %250, %.thread.i14.i214, %wrapI.exit12.i212
  %.2.i17.i217 = phi i32 [ %.3..i16.i216, %250 ], [ %..i13.i213, %.thread.i14.i214 ], [ %iPixelV.0.i194, %wrapI.exit12.i212 ]
  %257 = icmp slt i32 %.2.i17.i217, %228
  %258 = select i1 %257, i32 %.2.i17.i217, i32 %228
  %259 = icmp sgt i32 0, %258
  %260 = select i1 %259, i32 0, i32 %258
  %261 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %262 = load i8*, i8** %261, align 4, !tbaa !22
  %263 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %264 = load i32, i32* %263, align 4, !tbaa !21
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268 [
    i32 11, label %265
    i32 8, label %356
    i32 9, label %380
    i32 10, label %441
    i32 7, label %607
  ]

; <label>:265                                     ; preds = %wrapI.exit18.i218
  %266 = mul i32 %264, %260
  %267 = shl nsw i32 %246, 2
  %.sum.i.i.i.i219 = add i32 %266, %267
  %268 = getelementptr inbounds i8, i8* %262, i32 %.sum.i.i.i.i219
  %269 = load i8, i8* %268, align 1, !tbaa !19
  %270 = uitofp i8 %269 to float
  %271 = insertelement <4 x float> undef, float %270, i32 0
  %272 = or i32 %267, 1
  %.sum1.i.i.i.i220 = add i32 %266, %272
  %273 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i.i.i.i220
  %274 = load i8, i8* %273, align 1, !tbaa !19
  %275 = uitofp i8 %274 to float
  %276 = insertelement <4 x float> %271, float %275, i32 1
  %277 = or i32 %267, 2
  %.sum2.i.i.i.i221 = add i32 %266, %277
  %278 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i.i.i.i221
  %279 = load i8, i8* %278, align 1, !tbaa !19
  %280 = uitofp i8 %279 to float
  %281 = insertelement <4 x float> %276, float %280, i32 2
  %282 = or i32 %267, 3
  %.sum3.i.i.i.i222 = add i32 %266, %282
  %283 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i.i.i.i222
  %284 = load i8, i8* %283, align 1, !tbaa !19
  %285 = uitofp i8 %284 to float
  %286 = insertelement <4 x float> %281, float %285, i32 3
  %287 = shl nsw i32 %216, 2
  %.sum.i9.i.i.i223 = add i32 %266, %287
  %288 = getelementptr inbounds i8, i8* %262, i32 %.sum.i9.i.i.i223
  %289 = load i8, i8* %288, align 1, !tbaa !19
  %290 = uitofp i8 %289 to float
  %291 = insertelement <4 x float> undef, float %290, i32 0
  %292 = or i32 %287, 1
  %.sum1.i10.i.i.i224 = add i32 %266, %292
  %293 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i10.i.i.i224
  %294 = load i8, i8* %293, align 1, !tbaa !19
  %295 = uitofp i8 %294 to float
  %296 = insertelement <4 x float> %291, float %295, i32 1
  %297 = or i32 %287, 2
  %.sum2.i11.i.i.i225 = add i32 %266, %297
  %298 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i11.i.i.i225
  %299 = load i8, i8* %298, align 1, !tbaa !19
  %300 = uitofp i8 %299 to float
  %301 = insertelement <4 x float> %296, float %300, i32 2
  %302 = or i32 %287, 3
  %.sum3.i12.i.i.i226 = add i32 %266, %302
  %303 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i12.i.i.i226
  %304 = load i8, i8* %303, align 1, !tbaa !19
  %305 = uitofp i8 %304 to float
  %306 = insertelement <4 x float> %301, float %305, i32 3
  %307 = mul i32 %264, %232
  %.sum.i5.i.i.i227 = add i32 %307, %267
  %308 = getelementptr inbounds i8, i8* %262, i32 %.sum.i5.i.i.i227
  %309 = load i8, i8* %308, align 1, !tbaa !19
  %310 = uitofp i8 %309 to float
  %311 = insertelement <4 x float> undef, float %310, i32 0
  %.sum1.i6.i.i.i228 = add i32 %307, %272
  %312 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i6.i.i.i228
  %313 = load i8, i8* %312, align 1, !tbaa !19
  %314 = uitofp i8 %313 to float
  %315 = insertelement <4 x float> %311, float %314, i32 1
  %.sum2.i7.i.i.i229 = add i32 %307, %277
  %316 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i7.i.i.i229
  %317 = load i8, i8* %316, align 1, !tbaa !19
  %318 = uitofp i8 %317 to float
  %319 = insertelement <4 x float> %315, float %318, i32 2
  %.sum3.i8.i.i.i230 = add i32 %307, %282
  %320 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i8.i.i.i230
  %321 = load i8, i8* %320, align 1, !tbaa !19
  %322 = uitofp i8 %321 to float
  %323 = insertelement <4 x float> %319, float %322, i32 3
  %.sum.i1.i.i.i231 = add i32 %307, %287
  %324 = getelementptr inbounds i8, i8* %262, i32 %.sum.i1.i.i.i231
  %325 = load i8, i8* %324, align 1, !tbaa !19
  %326 = uitofp i8 %325 to float
  %327 = insertelement <4 x float> undef, float %326, i32 0
  %.sum1.i2.i.i.i232 = add i32 %307, %292
  %328 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i2.i.i.i232
  %329 = load i8, i8* %328, align 1, !tbaa !19
  %330 = uitofp i8 %329 to float
  %331 = insertelement <4 x float> %327, float %330, i32 1
  %.sum2.i3.i.i.i233 = add i32 %307, %297
  %332 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i3.i.i.i233
  %333 = load i8, i8* %332, align 1, !tbaa !19
  %334 = uitofp i8 %333 to float
  %335 = insertelement <4 x float> %331, float %334, i32 2
  %.sum3.i4.i.i.i234 = add i32 %307, %302
  %336 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i4.i.i.i234
  %337 = load i8, i8* %336, align 1, !tbaa !19
  %338 = uitofp i8 %337 to float
  %339 = insertelement <4 x float> %335, float %338, i32 3
  %340 = insertelement <4 x float> undef, float %197, i32 0
  %341 = shufflevector <4 x float> %340, <4 x float> undef, <4 x i32> zeroinitializer
  %342 = fmul <4 x float> %341, %286
  %343 = insertelement <4 x float> undef, float %198, i32 0
  %344 = shufflevector <4 x float> %343, <4 x float> undef, <4 x i32> zeroinitializer
  %345 = fmul <4 x float> %344, %306
  %346 = fadd <4 x float> %342, %345
  %347 = insertelement <4 x float> undef, float %199, i32 0
  %348 = shufflevector <4 x float> %347, <4 x float> undef, <4 x i32> zeroinitializer
  %349 = fmul <4 x float> %348, %323
  %350 = fadd <4 x float> %346, %349
  %351 = insertelement <4 x float> undef, float %200, i32 0
  %352 = shufflevector <4 x float> %351, <4 x float> undef, <4 x i32> zeroinitializer
  %353 = fmul <4 x float> %352, %339
  %354 = fadd <4 x float> %350, %353
  %355 = fmul <4 x float> %354, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268

; <label>:356                                     ; preds = %wrapI.exit18.i218
  %357 = mul i32 %264, %260
  %.sum.i.i26.i.i235 = add i32 %357, %246
  %358 = getelementptr inbounds i8, i8* %262, i32 %.sum.i.i26.i.i235
  %359 = load i8, i8* %358, align 1, !tbaa !19
  %360 = uitofp i8 %359 to float
  %.sum.i3.i27.i.i236 = add i32 %357, %216
  %361 = getelementptr inbounds i8, i8* %262, i32 %.sum.i3.i27.i.i236
  %362 = load i8, i8* %361, align 1, !tbaa !19
  %363 = uitofp i8 %362 to float
  %364 = mul i32 %264, %232
  %.sum.i2.i28.i.i237 = add i32 %364, %246
  %365 = getelementptr inbounds i8, i8* %262, i32 %.sum.i2.i28.i.i237
  %366 = load i8, i8* %365, align 1, !tbaa !19
  %367 = uitofp i8 %366 to float
  %.sum.i1.i29.i.i238 = add i32 %364, %216
  %368 = getelementptr inbounds i8, i8* %262, i32 %.sum.i1.i29.i.i238
  %369 = load i8, i8* %368, align 1, !tbaa !19
  %370 = uitofp i8 %369 to float
  %371 = fmul float %197, %360
  %372 = fmul float %198, %363
  %373 = fadd float %371, %372
  %374 = fmul float %199, %367
  %375 = fadd float %373, %374
  %376 = fmul float %200, %370
  %377 = fadd float %375, %376
  %378 = fmul float %377, 0x3F70101020000000
  %379 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %378, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268

; <label>:380                                     ; preds = %wrapI.exit18.i218
  %381 = mul i32 %264, %260
  %382 = shl nsw i32 %246, 1
  %.sum.i.i19.i.i239 = add i32 %381, %382
  %383 = getelementptr inbounds i8, i8* %262, i32 %.sum.i.i19.i.i239
  %384 = load i8, i8* %383, align 1, !tbaa !19
  %385 = uitofp i8 %384 to float
  %386 = insertelement <2 x float> undef, float %385, i32 0
  %387 = or i32 %382, 1
  %.sum1.i.i20.i.i240 = add i32 %381, %387
  %388 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i.i20.i.i240
  %389 = load i8, i8* %388, align 1, !tbaa !19
  %390 = uitofp i8 %389 to float
  %391 = insertelement <2 x float> %386, float %390, i32 1
  %392 = shl nsw i32 %216, 1
  %.sum.i5.i21.i.i241 = add i32 %381, %392
  %393 = getelementptr inbounds i8, i8* %262, i32 %.sum.i5.i21.i.i241
  %394 = load i8, i8* %393, align 1, !tbaa !19
  %395 = uitofp i8 %394 to float
  %396 = insertelement <2 x float> undef, float %395, i32 0
  %397 = or i32 %392, 1
  %.sum1.i6.i22.i.i242 = add i32 %381, %397
  %398 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i6.i22.i.i242
  %399 = load i8, i8* %398, align 1, !tbaa !19
  %400 = uitofp i8 %399 to float
  %401 = insertelement <2 x float> %396, float %400, i32 1
  %402 = mul i32 %264, %232
  %.sum.i3.i23.i.i243 = add i32 %402, %382
  %403 = getelementptr inbounds i8, i8* %262, i32 %.sum.i3.i23.i.i243
  %404 = load i8, i8* %403, align 1, !tbaa !19
  %405 = uitofp i8 %404 to float
  %406 = insertelement <2 x float> undef, float %405, i32 0
  %.sum1.i4.i.i.i244 = add i32 %402, %387
  %407 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i4.i.i.i244
  %408 = load i8, i8* %407, align 1, !tbaa !19
  %409 = uitofp i8 %408 to float
  %410 = insertelement <2 x float> %406, float %409, i32 1
  %.sum.i1.i24.i.i245 = add i32 %402, %392
  %411 = getelementptr inbounds i8, i8* %262, i32 %.sum.i1.i24.i.i245
  %412 = load i8, i8* %411, align 1, !tbaa !19
  %413 = uitofp i8 %412 to float
  %414 = insertelement <2 x float> undef, float %413, i32 0
  %.sum1.i2.i25.i.i246 = add i32 %402, %397
  %415 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i2.i25.i.i246
  %416 = load i8, i8* %415, align 1, !tbaa !19
  %417 = uitofp i8 %416 to float
  %418 = insertelement <2 x float> %414, float %417, i32 1
  %419 = insertelement <2 x float> undef, float %197, i32 0
  %420 = shufflevector <2 x float> %419, <2 x float> undef, <2 x i32> zeroinitializer
  %421 = fmul <2 x float> %420, %391
  %422 = insertelement <2 x float> undef, float %198, i32 0
  %423 = shufflevector <2 x float> %422, <2 x float> undef, <2 x i32> zeroinitializer
  %424 = fmul <2 x float> %423, %401
  %425 = fadd <2 x float> %421, %424
  %426 = insertelement <2 x float> undef, float %199, i32 0
  %427 = shufflevector <2 x float> %426, <2 x float> undef, <2 x i32> zeroinitializer
  %428 = fmul <2 x float> %427, %410
  %429 = fadd <2 x float> %425, %428
  %430 = insertelement <2 x float> undef, float %200, i32 0
  %431 = shufflevector <2 x float> %430, <2 x float> undef, <2 x i32> zeroinitializer
  %432 = fmul <2 x float> %431, %418
  %433 = fadd <2 x float> %429, %432
  %434 = fmul <2 x float> %433, <float 0x3F70101020000000, float 0x3F70101020000000>
  %435 = extractelement <2 x float> %434, i32 0
  %436 = insertelement <4 x float> undef, float %435, i32 0
  %437 = insertelement <4 x float> %436, float %435, i32 1
  %438 = insertelement <4 x float> %437, float %435, i32 2
  %439 = extractelement <2 x float> %434, i32 1
  %440 = insertelement <4 x float> %438, float %439, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268

; <label>:441                                     ; preds = %wrapI.exit18.i218
  %442 = icmp eq i32 %15, 13
  %443 = mul i32 %264, %260
  br i1 %442, label %444, label %510

; <label>:444                                     ; preds = %441
  %445 = getelementptr inbounds i8, i8* %262, i32 %443
  %446 = bitcast i8* %445 to i16*
  %447 = load i16, i16* %446, align 2, !tbaa !70
  %448 = zext i16 %447 to i32
  %449 = lshr i32 %448, 11
  %450 = shl nuw nsw i32 %449, 3
  %451 = lshr i32 %448, 13
  %452 = or i32 %450, %451
  %453 = uitofp i32 %452 to float
  %454 = insertelement <3 x float> undef, float %453, i32 0
  %455 = lshr i32 %448, 5
  %456 = and i32 %455, 63
  %457 = shl nuw nsw i32 %456, 2
  %458 = lshr i32 %456, 4
  %459 = or i32 %457, %458
  %460 = uitofp i32 %459 to float
  %461 = insertelement <3 x float> %454, float %460, i32 1
  %462 = and i32 %448, 31
  %463 = shl nuw nsw i32 %462, 3
  %464 = lshr i32 %462, 2
  %465 = or i32 %463, %464
  %466 = uitofp i32 %465 to float
  %467 = insertelement <3 x float> %461, float %466, i32 2
  %468 = mul i32 %264, %232
  %469 = getelementptr inbounds i8, i8* %262, i32 %468
  %470 = bitcast i8* %469 to i16*
  %471 = load i16, i16* %470, align 2, !tbaa !70
  %472 = zext i16 %471 to i32
  %473 = lshr i32 %472, 11
  %474 = shl nuw nsw i32 %473, 3
  %475 = lshr i32 %472, 13
  %476 = or i32 %474, %475
  %477 = uitofp i32 %476 to float
  %478 = insertelement <3 x float> undef, float %477, i32 0
  %479 = lshr i32 %472, 5
  %480 = and i32 %479, 63
  %481 = shl nuw nsw i32 %480, 2
  %482 = lshr i32 %480, 4
  %483 = or i32 %481, %482
  %484 = uitofp i32 %483 to float
  %485 = insertelement <3 x float> %478, float %484, i32 1
  %486 = and i32 %472, 31
  %487 = shl nuw nsw i32 %486, 3
  %488 = lshr i32 %486, 2
  %489 = or i32 %487, %488
  %490 = uitofp i32 %489 to float
  %491 = insertelement <3 x float> %485, float %490, i32 2
  %492 = insertelement <3 x float> undef, float %197, i32 0
  %493 = shufflevector <3 x float> %492, <3 x float> undef, <3 x i32> zeroinitializer
  %494 = fmul <3 x float> %493, %467
  %495 = insertelement <3 x float> undef, float %198, i32 0
  %496 = shufflevector <3 x float> %495, <3 x float> undef, <3 x i32> zeroinitializer
  %497 = fmul <3 x float> %496, %467
  %498 = fadd <3 x float> %494, %497
  %499 = insertelement <3 x float> undef, float %199, i32 0
  %500 = shufflevector <3 x float> %499, <3 x float> undef, <3 x i32> zeroinitializer
  %501 = fmul <3 x float> %500, %491
  %502 = fadd <3 x float> %498, %501
  %503 = insertelement <3 x float> undef, float %200, i32 0
  %504 = shufflevector <3 x float> %503, <3 x float> undef, <3 x i32> zeroinitializer
  %505 = fmul <3 x float> %504, %491
  %506 = fadd <3 x float> %505, %502
  %507 = fmul <3 x float> %506, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %508 = shufflevector <3 x float> %507, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %509 = insertelement <4 x float> %508, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268

; <label>:510                                     ; preds = %441
  %511 = shl nsw i32 %246, 2
  %.sum.i.i3.i.i247 = add i32 %443, %511
  %512 = getelementptr inbounds i8, i8* %262, i32 %.sum.i.i3.i.i247
  %513 = load i8, i8* %512, align 1, !tbaa !19
  %514 = uitofp i8 %513 to float
  %515 = insertelement <4 x float> undef, float %514, i32 0
  %516 = or i32 %511, 1
  %.sum1.i.i4.i.i248 = add i32 %443, %516
  %517 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i.i4.i.i248
  %518 = load i8, i8* %517, align 1, !tbaa !19
  %519 = uitofp i8 %518 to float
  %520 = insertelement <4 x float> %515, float %519, i32 1
  %521 = or i32 %511, 2
  %.sum2.i.i5.i.i249 = add i32 %443, %521
  %522 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i.i5.i.i249
  %523 = load i8, i8* %522, align 1, !tbaa !19
  %524 = uitofp i8 %523 to float
  %525 = insertelement <4 x float> %520, float %524, i32 2
  %526 = or i32 %511, 3
  %.sum3.i.i6.i.i250 = add i32 %443, %526
  %527 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i.i6.i.i250
  %528 = load i8, i8* %527, align 1, !tbaa !19
  %529 = uitofp i8 %528 to float
  %530 = insertelement <4 x float> %525, float %529, i32 3
  %531 = shl nsw i32 %216, 2
  %.sum.i9.i7.i.i251 = add i32 %443, %531
  %532 = getelementptr inbounds i8, i8* %262, i32 %.sum.i9.i7.i.i251
  %533 = load i8, i8* %532, align 1, !tbaa !19
  %534 = uitofp i8 %533 to float
  %535 = insertelement <4 x float> undef, float %534, i32 0
  %536 = or i32 %531, 1
  %.sum1.i10.i8.i.i252 = add i32 %443, %536
  %537 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i10.i8.i.i252
  %538 = load i8, i8* %537, align 1, !tbaa !19
  %539 = uitofp i8 %538 to float
  %540 = insertelement <4 x float> %535, float %539, i32 1
  %541 = or i32 %531, 2
  %.sum2.i11.i9.i.i253 = add i32 %443, %541
  %542 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i11.i9.i.i253
  %543 = load i8, i8* %542, align 1, !tbaa !19
  %544 = uitofp i8 %543 to float
  %545 = insertelement <4 x float> %540, float %544, i32 2
  %546 = or i32 %531, 3
  %.sum3.i12.i10.i.i254 = add i32 %443, %546
  %547 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i12.i10.i.i254
  %548 = load i8, i8* %547, align 1, !tbaa !19
  %549 = uitofp i8 %548 to float
  %550 = insertelement <4 x float> %545, float %549, i32 3
  %551 = mul i32 %264, %232
  %.sum.i5.i11.i.i255 = add i32 %551, %511
  %552 = getelementptr inbounds i8, i8* %262, i32 %.sum.i5.i11.i.i255
  %553 = load i8, i8* %552, align 1, !tbaa !19
  %554 = uitofp i8 %553 to float
  %555 = insertelement <4 x float> undef, float %554, i32 0
  %.sum1.i6.i12.i.i256 = add i32 %551, %516
  %556 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i6.i12.i.i256
  %557 = load i8, i8* %556, align 1, !tbaa !19
  %558 = uitofp i8 %557 to float
  %559 = insertelement <4 x float> %555, float %558, i32 1
  %.sum2.i7.i13.i.i257 = add i32 %551, %521
  %560 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i7.i13.i.i257
  %561 = load i8, i8* %560, align 1, !tbaa !19
  %562 = uitofp i8 %561 to float
  %563 = insertelement <4 x float> %559, float %562, i32 2
  %.sum3.i8.i14.i.i258 = add i32 %551, %526
  %564 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i8.i14.i.i258
  %565 = load i8, i8* %564, align 1, !tbaa !19
  %566 = uitofp i8 %565 to float
  %567 = insertelement <4 x float> %563, float %566, i32 3
  %.sum.i1.i15.i.i259 = add i32 %551, %531
  %568 = getelementptr inbounds i8, i8* %262, i32 %.sum.i1.i15.i.i259
  %569 = load i8, i8* %568, align 1, !tbaa !19
  %570 = uitofp i8 %569 to float
  %571 = insertelement <4 x float> undef, float %570, i32 0
  %.sum1.i2.i16.i.i260 = add i32 %551, %536
  %572 = getelementptr inbounds i8, i8* %262, i32 %.sum1.i2.i16.i.i260
  %573 = load i8, i8* %572, align 1, !tbaa !19
  %574 = uitofp i8 %573 to float
  %575 = insertelement <4 x float> %571, float %574, i32 1
  %.sum2.i3.i17.i.i261 = add i32 %551, %541
  %576 = getelementptr inbounds i8, i8* %262, i32 %.sum2.i3.i17.i.i261
  %577 = load i8, i8* %576, align 1, !tbaa !19
  %578 = uitofp i8 %577 to float
  %579 = insertelement <4 x float> %575, float %578, i32 2
  %.sum3.i4.i18.i.i262 = add i32 %551, %546
  %580 = getelementptr inbounds i8, i8* %262, i32 %.sum3.i4.i18.i.i262
  %581 = load i8, i8* %580, align 1, !tbaa !19
  %582 = uitofp i8 %581 to float
  %583 = insertelement <4 x float> %579, float %582, i32 3
  %584 = insertelement <4 x float> undef, float %197, i32 0
  %585 = shufflevector <4 x float> %584, <4 x float> undef, <4 x i32> zeroinitializer
  %586 = fmul <4 x float> %585, %530
  %587 = insertelement <4 x float> undef, float %198, i32 0
  %588 = shufflevector <4 x float> %587, <4 x float> undef, <4 x i32> zeroinitializer
  %589 = fmul <4 x float> %588, %550
  %590 = fadd <4 x float> %586, %589
  %591 = insertelement <4 x float> undef, float %199, i32 0
  %592 = shufflevector <4 x float> %591, <4 x float> undef, <4 x i32> zeroinitializer
  %593 = fmul <4 x float> %592, %567
  %594 = fadd <4 x float> %590, %593
  %595 = insertelement <4 x float> undef, float %200, i32 0
  %596 = shufflevector <4 x float> %595, <4 x float> undef, <4 x i32> zeroinitializer
  %597 = fmul <4 x float> %596, %583
  %598 = fadd <4 x float> %594, %597
  %599 = fmul <4 x float> %598, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %600 = extractelement <4 x float> %599, i32 0
  %601 = insertelement <4 x float> undef, float %600, i32 0
  %602 = extractelement <4 x float> %599, i32 1
  %603 = insertelement <4 x float> %601, float %602, i32 1
  %604 = extractelement <4 x float> %599, i32 2
  %605 = insertelement <4 x float> %603, float %604, i32 2
  %606 = insertelement <4 x float> %605, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268

; <label>:607                                     ; preds = %wrapI.exit18.i218
  %608 = mul i32 %264, %260
  %.sum.i.i1.i.i263 = add i32 %608, %246
  %609 = getelementptr inbounds i8, i8* %262, i32 %.sum.i.i1.i.i263
  %610 = load i8, i8* %609, align 1, !tbaa !19
  %611 = uitofp i8 %610 to float
  %.sum.i3.i.i.i264 = add i32 %608, %216
  %612 = getelementptr inbounds i8, i8* %262, i32 %.sum.i3.i.i.i264
  %613 = load i8, i8* %612, align 1, !tbaa !19
  %614 = uitofp i8 %613 to float
  %615 = mul i32 %264, %232
  %.sum.i2.i.i.i265 = add i32 %615, %246
  %616 = getelementptr inbounds i8, i8* %262, i32 %.sum.i2.i.i.i265
  %617 = load i8, i8* %616, align 1, !tbaa !19
  %618 = uitofp i8 %617 to float
  %.sum.i1.i2.i.i266 = add i32 %615, %216
  %619 = getelementptr inbounds i8, i8* %262, i32 %.sum.i1.i2.i.i266
  %620 = load i8, i8* %619, align 1, !tbaa !19
  %621 = uitofp i8 %620 to float
  %622 = fmul float %197, %611
  %623 = fmul float %198, %614
  %624 = fadd float %622, %623
  %625 = fmul float %199, %618
  %626 = fadd float %624, %625
  %627 = fmul float %200, %621
  %628 = fadd float %626, %627
  %629 = fmul float %628, 0x3F70101020000000
  %630 = insertelement <4 x float> undef, float %629, i32 0
  %631 = insertelement <4 x float> %630, float %629, i32 1
  %632 = insertelement <4 x float> %631, float %629, i32 2
  %633 = insertelement <4 x float> %632, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268: ; preds = %wrapI.exit18.i218, %265, %356, %380, %444, %510, %607
  %.0.i.i267 = phi <4 x float> [ %633, %607 ], [ %509, %444 ], [ %606, %510 ], [ %440, %380 ], [ %379, %356 ], [ %355, %265 ], [ zeroinitializer, %wrapI.exit18.i218 ]
  br label %2207

; <label>:634                                     ; preds = %28
  switch i32 %17, label %2075 [
    i32 5, label %635
    i32 2, label %1114
  ]

; <label>:635                                     ; preds = %634
  %636 = getelementptr inbounds i8, i8* %6, i32 68
  %637 = bitcast i8* %636 to i32*
  %638 = load i32, i32* %637, align 4, !tbaa !21
  %639 = add i32 %638, -1
  %640 = uitofp i32 %639 to float
  %641 = fcmp olt float %lod, %640
  %642 = select i1 %641, float %lod, float %640
  %643 = tail call float @_Z5roundf(float %642) #14
  %644 = fptoui float %643 to i32
  %645 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %644, i32 2
  %646 = load i32, i32* %645, align 4, !tbaa !21
  %647 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %644, i32 3
  %648 = load i32, i32* %647, align 4, !tbaa !21
  %649 = extractelement <2 x float> %uv, i32 0
  %650 = sitofp i32 %646 to float
  %651 = fmul float %649, %650
  %652 = extractelement <2 x float> %uv, i32 1
  %653 = sitofp i32 %648 to float
  %654 = fmul float %652, %653
  %655 = fptosi float %651 to i32
  %656 = fptosi float %654 to i32
  %657 = sitofp i32 %655 to float
  %658 = fsub float %651, %657
  %659 = sitofp i32 %656 to float
  %660 = fsub float %654, %659
  %661 = fcmp olt float %658, 5.000000e-01
  br i1 %661, label %662, label %665

; <label>:662                                     ; preds = %635
  %663 = add nsw i32 %655, -1
  %664 = fadd float %658, 5.000000e-01
  br label %667

; <label>:665                                     ; preds = %635
  %666 = fadd float %658, -5.000000e-01
  br label %667

; <label>:667                                     ; preds = %665, %662
  %fracU.0.i113 = phi float [ %664, %662 ], [ %666, %665 ]
  %iPixelU.0.i114 = phi i32 [ %663, %662 ], [ %655, %665 ]
  %668 = fcmp olt float %660, 5.000000e-01
  br i1 %668, label %669, label %672

; <label>:669                                     ; preds = %667
  %670 = add nsw i32 %656, -1
  %671 = fadd float %660, 5.000000e-01
  br label %674

; <label>:672                                     ; preds = %667
  %673 = fadd float %660, -5.000000e-01
  br label %674

; <label>:674                                     ; preds = %672, %669
  %fracV.0.i115 = phi float [ %671, %669 ], [ %673, %672 ]
  %iPixelV.0.i116 = phi i32 [ %670, %669 ], [ %656, %672 ]
  %675 = fsub float 1.000000e+00, %fracU.0.i113
  %676 = fsub float 1.000000e+00, %fracV.0.i115
  %677 = fmul float %675, %676
  %678 = fmul float %fracU.0.i113, %676
  %679 = fmul float %675, %fracV.0.i115
  %680 = fmul float %fracU.0.i113, %fracV.0.i115
  %681 = add nsw i32 %iPixelU.0.i114, 1
  switch i32 %21, label %wrapI.exit.i122 [
    i32 3, label %.thread.i.i118
    i32 6, label %685
  ]

.thread.i.i118:                                   ; preds = %674
  %682 = srem i32 %681, %646
  %683 = icmp slt i32 %682, 0
  %684 = select i1 %683, i32 %646, i32 0
  %..i.i117 = add nsw i32 %684, %682
  br label %wrapI.exit.i122

; <label>:685                                     ; preds = %674
  %686 = shl nsw i32 %646, 1
  %687 = srem i32 %681, %686
  %688 = icmp slt i32 %687, 0
  %689 = select i1 %688, i32 %686, i32 0
  %.3.i.i119 = add nsw i32 %689, %687
  %690 = icmp slt i32 %.3.i.i119, %646
  %691 = sub nsw i32 %686, %.3.i.i119
  %.3..i.i120 = select i1 %690, i32 %.3.i.i119, i32 %691
  br label %wrapI.exit.i122

wrapI.exit.i122:                                  ; preds = %685, %.thread.i.i118, %674
  %.2.i.i121 = phi i32 [ %.3..i.i120, %685 ], [ %..i.i117, %.thread.i.i118 ], [ %681, %674 ]
  %692 = add nsw i32 %646, -1
  %693 = icmp slt i32 %.2.i.i121, %692
  %694 = select i1 %693, i32 %.2.i.i121, i32 %692
  %695 = icmp sgt i32 0, %694
  %696 = select i1 %695, i32 0, i32 %694
  %697 = add nsw i32 %iPixelV.0.i116, 1
  switch i32 %23, label %wrapI.exit6.i128 [
    i32 3, label %.thread.i2.i124
    i32 6, label %701
  ]

.thread.i2.i124:                                  ; preds = %wrapI.exit.i122
  %698 = srem i32 %697, %648
  %699 = icmp slt i32 %698, 0
  %700 = select i1 %699, i32 %648, i32 0
  %..i1.i123 = add nsw i32 %700, %698
  br label %wrapI.exit6.i128

; <label>:701                                     ; preds = %wrapI.exit.i122
  %702 = shl nsw i32 %648, 1
  %703 = srem i32 %697, %702
  %704 = icmp slt i32 %703, 0
  %705 = select i1 %704, i32 %702, i32 0
  %.3.i3.i125 = add nsw i32 %705, %703
  %706 = icmp slt i32 %.3.i3.i125, %648
  %707 = sub nsw i32 %702, %.3.i3.i125
  %.3..i4.i126 = select i1 %706, i32 %.3.i3.i125, i32 %707
  br label %wrapI.exit6.i128

wrapI.exit6.i128:                                 ; preds = %701, %.thread.i2.i124, %wrapI.exit.i122
  %.2.i5.i127 = phi i32 [ %.3..i4.i126, %701 ], [ %..i1.i123, %.thread.i2.i124 ], [ %697, %wrapI.exit.i122 ]
  %708 = add nsw i32 %648, -1
  %709 = icmp slt i32 %.2.i5.i127, %708
  %710 = select i1 %709, i32 %.2.i5.i127, i32 %708
  %711 = icmp sgt i32 0, %710
  %712 = select i1 %711, i32 0, i32 %710
  switch i32 %21, label %wrapI.exit12.i134 [
    i32 3, label %.thread.i8.i130
    i32 6, label %716
  ]

.thread.i8.i130:                                  ; preds = %wrapI.exit6.i128
  %713 = srem i32 %iPixelU.0.i114, %646
  %714 = icmp slt i32 %713, 0
  %715 = select i1 %714, i32 %646, i32 0
  %..i7.i129 = add nsw i32 %715, %713
  br label %wrapI.exit12.i134

; <label>:716                                     ; preds = %wrapI.exit6.i128
  %717 = shl nsw i32 %646, 1
  %718 = srem i32 %iPixelU.0.i114, %717
  %719 = icmp slt i32 %718, 0
  %720 = select i1 %719, i32 %717, i32 0
  %.3.i9.i131 = add nsw i32 %720, %718
  %721 = icmp slt i32 %.3.i9.i131, %646
  %722 = sub nsw i32 %717, %.3.i9.i131
  %.3..i10.i132 = select i1 %721, i32 %.3.i9.i131, i32 %722
  br label %wrapI.exit12.i134

wrapI.exit12.i134:                                ; preds = %716, %.thread.i8.i130, %wrapI.exit6.i128
  %.2.i11.i133 = phi i32 [ %.3..i10.i132, %716 ], [ %..i7.i129, %.thread.i8.i130 ], [ %iPixelU.0.i114, %wrapI.exit6.i128 ]
  %723 = icmp slt i32 %.2.i11.i133, %692
  %724 = select i1 %723, i32 %.2.i11.i133, i32 %692
  %725 = icmp sgt i32 0, %724
  %726 = select i1 %725, i32 0, i32 %724
  switch i32 %23, label %wrapI.exit18.i140 [
    i32 3, label %.thread.i14.i136
    i32 6, label %730
  ]

.thread.i14.i136:                                 ; preds = %wrapI.exit12.i134
  %727 = srem i32 %iPixelV.0.i116, %648
  %728 = icmp slt i32 %727, 0
  %729 = select i1 %728, i32 %648, i32 0
  %..i13.i135 = add nsw i32 %729, %727
  br label %wrapI.exit18.i140

; <label>:730                                     ; preds = %wrapI.exit12.i134
  %731 = shl nsw i32 %648, 1
  %732 = srem i32 %iPixelV.0.i116, %731
  %733 = icmp slt i32 %732, 0
  %734 = select i1 %733, i32 %731, i32 0
  %.3.i15.i137 = add nsw i32 %734, %732
  %735 = icmp slt i32 %.3.i15.i137, %648
  %736 = sub nsw i32 %731, %.3.i15.i137
  %.3..i16.i138 = select i1 %735, i32 %.3.i15.i137, i32 %736
  br label %wrapI.exit18.i140

wrapI.exit18.i140:                                ; preds = %730, %.thread.i14.i136, %wrapI.exit12.i134
  %.2.i17.i139 = phi i32 [ %.3..i16.i138, %730 ], [ %..i13.i135, %.thread.i14.i136 ], [ %iPixelV.0.i116, %wrapI.exit12.i134 ]
  %737 = icmp slt i32 %.2.i17.i139, %708
  %738 = select i1 %737, i32 %.2.i17.i139, i32 %708
  %739 = icmp sgt i32 0, %738
  %740 = select i1 %739, i32 0, i32 %738
  %741 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %644, i32 0
  %742 = load i8*, i8** %741, align 4, !tbaa !22
  %743 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %644, i32 1
  %744 = load i32, i32* %743, align 4, !tbaa !21
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190 [
    i32 11, label %745
    i32 8, label %836
    i32 9, label %860
    i32 10, label %921
    i32 7, label %1087
  ]

; <label>:745                                     ; preds = %wrapI.exit18.i140
  %746 = mul i32 %744, %740
  %747 = shl nsw i32 %726, 2
  %.sum.i.i.i.i141 = add i32 %746, %747
  %748 = getelementptr inbounds i8, i8* %742, i32 %.sum.i.i.i.i141
  %749 = load i8, i8* %748, align 1, !tbaa !19
  %750 = uitofp i8 %749 to float
  %751 = insertelement <4 x float> undef, float %750, i32 0
  %752 = or i32 %747, 1
  %.sum1.i.i.i.i142 = add i32 %746, %752
  %753 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i.i.i.i142
  %754 = load i8, i8* %753, align 1, !tbaa !19
  %755 = uitofp i8 %754 to float
  %756 = insertelement <4 x float> %751, float %755, i32 1
  %757 = or i32 %747, 2
  %.sum2.i.i.i.i143 = add i32 %746, %757
  %758 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i.i.i.i143
  %759 = load i8, i8* %758, align 1, !tbaa !19
  %760 = uitofp i8 %759 to float
  %761 = insertelement <4 x float> %756, float %760, i32 2
  %762 = or i32 %747, 3
  %.sum3.i.i.i.i144 = add i32 %746, %762
  %763 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i.i.i.i144
  %764 = load i8, i8* %763, align 1, !tbaa !19
  %765 = uitofp i8 %764 to float
  %766 = insertelement <4 x float> %761, float %765, i32 3
  %767 = shl nsw i32 %696, 2
  %.sum.i9.i.i.i145 = add i32 %746, %767
  %768 = getelementptr inbounds i8, i8* %742, i32 %.sum.i9.i.i.i145
  %769 = load i8, i8* %768, align 1, !tbaa !19
  %770 = uitofp i8 %769 to float
  %771 = insertelement <4 x float> undef, float %770, i32 0
  %772 = or i32 %767, 1
  %.sum1.i10.i.i.i146 = add i32 %746, %772
  %773 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i10.i.i.i146
  %774 = load i8, i8* %773, align 1, !tbaa !19
  %775 = uitofp i8 %774 to float
  %776 = insertelement <4 x float> %771, float %775, i32 1
  %777 = or i32 %767, 2
  %.sum2.i11.i.i.i147 = add i32 %746, %777
  %778 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i11.i.i.i147
  %779 = load i8, i8* %778, align 1, !tbaa !19
  %780 = uitofp i8 %779 to float
  %781 = insertelement <4 x float> %776, float %780, i32 2
  %782 = or i32 %767, 3
  %.sum3.i12.i.i.i148 = add i32 %746, %782
  %783 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i12.i.i.i148
  %784 = load i8, i8* %783, align 1, !tbaa !19
  %785 = uitofp i8 %784 to float
  %786 = insertelement <4 x float> %781, float %785, i32 3
  %787 = mul i32 %744, %712
  %.sum.i5.i.i.i149 = add i32 %787, %747
  %788 = getelementptr inbounds i8, i8* %742, i32 %.sum.i5.i.i.i149
  %789 = load i8, i8* %788, align 1, !tbaa !19
  %790 = uitofp i8 %789 to float
  %791 = insertelement <4 x float> undef, float %790, i32 0
  %.sum1.i6.i.i.i150 = add i32 %787, %752
  %792 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i6.i.i.i150
  %793 = load i8, i8* %792, align 1, !tbaa !19
  %794 = uitofp i8 %793 to float
  %795 = insertelement <4 x float> %791, float %794, i32 1
  %.sum2.i7.i.i.i151 = add i32 %787, %757
  %796 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i7.i.i.i151
  %797 = load i8, i8* %796, align 1, !tbaa !19
  %798 = uitofp i8 %797 to float
  %799 = insertelement <4 x float> %795, float %798, i32 2
  %.sum3.i8.i.i.i152 = add i32 %787, %762
  %800 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i8.i.i.i152
  %801 = load i8, i8* %800, align 1, !tbaa !19
  %802 = uitofp i8 %801 to float
  %803 = insertelement <4 x float> %799, float %802, i32 3
  %.sum.i1.i.i.i153 = add i32 %787, %767
  %804 = getelementptr inbounds i8, i8* %742, i32 %.sum.i1.i.i.i153
  %805 = load i8, i8* %804, align 1, !tbaa !19
  %806 = uitofp i8 %805 to float
  %807 = insertelement <4 x float> undef, float %806, i32 0
  %.sum1.i2.i.i.i154 = add i32 %787, %772
  %808 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i2.i.i.i154
  %809 = load i8, i8* %808, align 1, !tbaa !19
  %810 = uitofp i8 %809 to float
  %811 = insertelement <4 x float> %807, float %810, i32 1
  %.sum2.i3.i.i.i155 = add i32 %787, %777
  %812 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i3.i.i.i155
  %813 = load i8, i8* %812, align 1, !tbaa !19
  %814 = uitofp i8 %813 to float
  %815 = insertelement <4 x float> %811, float %814, i32 2
  %.sum3.i4.i.i.i156 = add i32 %787, %782
  %816 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i4.i.i.i156
  %817 = load i8, i8* %816, align 1, !tbaa !19
  %818 = uitofp i8 %817 to float
  %819 = insertelement <4 x float> %815, float %818, i32 3
  %820 = insertelement <4 x float> undef, float %677, i32 0
  %821 = shufflevector <4 x float> %820, <4 x float> undef, <4 x i32> zeroinitializer
  %822 = fmul <4 x float> %821, %766
  %823 = insertelement <4 x float> undef, float %678, i32 0
  %824 = shufflevector <4 x float> %823, <4 x float> undef, <4 x i32> zeroinitializer
  %825 = fmul <4 x float> %824, %786
  %826 = fadd <4 x float> %822, %825
  %827 = insertelement <4 x float> undef, float %679, i32 0
  %828 = shufflevector <4 x float> %827, <4 x float> undef, <4 x i32> zeroinitializer
  %829 = fmul <4 x float> %828, %803
  %830 = fadd <4 x float> %826, %829
  %831 = insertelement <4 x float> undef, float %680, i32 0
  %832 = shufflevector <4 x float> %831, <4 x float> undef, <4 x i32> zeroinitializer
  %833 = fmul <4 x float> %832, %819
  %834 = fadd <4 x float> %830, %833
  %835 = fmul <4 x float> %834, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190

; <label>:836                                     ; preds = %wrapI.exit18.i140
  %837 = mul i32 %744, %740
  %.sum.i.i26.i.i157 = add i32 %837, %726
  %838 = getelementptr inbounds i8, i8* %742, i32 %.sum.i.i26.i.i157
  %839 = load i8, i8* %838, align 1, !tbaa !19
  %840 = uitofp i8 %839 to float
  %.sum.i3.i27.i.i158 = add i32 %837, %696
  %841 = getelementptr inbounds i8, i8* %742, i32 %.sum.i3.i27.i.i158
  %842 = load i8, i8* %841, align 1, !tbaa !19
  %843 = uitofp i8 %842 to float
  %844 = mul i32 %744, %712
  %.sum.i2.i28.i.i159 = add i32 %844, %726
  %845 = getelementptr inbounds i8, i8* %742, i32 %.sum.i2.i28.i.i159
  %846 = load i8, i8* %845, align 1, !tbaa !19
  %847 = uitofp i8 %846 to float
  %.sum.i1.i29.i.i160 = add i32 %844, %696
  %848 = getelementptr inbounds i8, i8* %742, i32 %.sum.i1.i29.i.i160
  %849 = load i8, i8* %848, align 1, !tbaa !19
  %850 = uitofp i8 %849 to float
  %851 = fmul float %677, %840
  %852 = fmul float %678, %843
  %853 = fadd float %851, %852
  %854 = fmul float %679, %847
  %855 = fadd float %853, %854
  %856 = fmul float %680, %850
  %857 = fadd float %855, %856
  %858 = fmul float %857, 0x3F70101020000000
  %859 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %858, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190

; <label>:860                                     ; preds = %wrapI.exit18.i140
  %861 = mul i32 %744, %740
  %862 = shl nsw i32 %726, 1
  %.sum.i.i19.i.i161 = add i32 %861, %862
  %863 = getelementptr inbounds i8, i8* %742, i32 %.sum.i.i19.i.i161
  %864 = load i8, i8* %863, align 1, !tbaa !19
  %865 = uitofp i8 %864 to float
  %866 = insertelement <2 x float> undef, float %865, i32 0
  %867 = or i32 %862, 1
  %.sum1.i.i20.i.i162 = add i32 %861, %867
  %868 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i.i20.i.i162
  %869 = load i8, i8* %868, align 1, !tbaa !19
  %870 = uitofp i8 %869 to float
  %871 = insertelement <2 x float> %866, float %870, i32 1
  %872 = shl nsw i32 %696, 1
  %.sum.i5.i21.i.i163 = add i32 %861, %872
  %873 = getelementptr inbounds i8, i8* %742, i32 %.sum.i5.i21.i.i163
  %874 = load i8, i8* %873, align 1, !tbaa !19
  %875 = uitofp i8 %874 to float
  %876 = insertelement <2 x float> undef, float %875, i32 0
  %877 = or i32 %872, 1
  %.sum1.i6.i22.i.i164 = add i32 %861, %877
  %878 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i6.i22.i.i164
  %879 = load i8, i8* %878, align 1, !tbaa !19
  %880 = uitofp i8 %879 to float
  %881 = insertelement <2 x float> %876, float %880, i32 1
  %882 = mul i32 %744, %712
  %.sum.i3.i23.i.i165 = add i32 %882, %862
  %883 = getelementptr inbounds i8, i8* %742, i32 %.sum.i3.i23.i.i165
  %884 = load i8, i8* %883, align 1, !tbaa !19
  %885 = uitofp i8 %884 to float
  %886 = insertelement <2 x float> undef, float %885, i32 0
  %.sum1.i4.i.i.i166 = add i32 %882, %867
  %887 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i4.i.i.i166
  %888 = load i8, i8* %887, align 1, !tbaa !19
  %889 = uitofp i8 %888 to float
  %890 = insertelement <2 x float> %886, float %889, i32 1
  %.sum.i1.i24.i.i167 = add i32 %882, %872
  %891 = getelementptr inbounds i8, i8* %742, i32 %.sum.i1.i24.i.i167
  %892 = load i8, i8* %891, align 1, !tbaa !19
  %893 = uitofp i8 %892 to float
  %894 = insertelement <2 x float> undef, float %893, i32 0
  %.sum1.i2.i25.i.i168 = add i32 %882, %877
  %895 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i2.i25.i.i168
  %896 = load i8, i8* %895, align 1, !tbaa !19
  %897 = uitofp i8 %896 to float
  %898 = insertelement <2 x float> %894, float %897, i32 1
  %899 = insertelement <2 x float> undef, float %677, i32 0
  %900 = shufflevector <2 x float> %899, <2 x float> undef, <2 x i32> zeroinitializer
  %901 = fmul <2 x float> %900, %871
  %902 = insertelement <2 x float> undef, float %678, i32 0
  %903 = shufflevector <2 x float> %902, <2 x float> undef, <2 x i32> zeroinitializer
  %904 = fmul <2 x float> %903, %881
  %905 = fadd <2 x float> %901, %904
  %906 = insertelement <2 x float> undef, float %679, i32 0
  %907 = shufflevector <2 x float> %906, <2 x float> undef, <2 x i32> zeroinitializer
  %908 = fmul <2 x float> %907, %890
  %909 = fadd <2 x float> %905, %908
  %910 = insertelement <2 x float> undef, float %680, i32 0
  %911 = shufflevector <2 x float> %910, <2 x float> undef, <2 x i32> zeroinitializer
  %912 = fmul <2 x float> %911, %898
  %913 = fadd <2 x float> %909, %912
  %914 = fmul <2 x float> %913, <float 0x3F70101020000000, float 0x3F70101020000000>
  %915 = extractelement <2 x float> %914, i32 0
  %916 = insertelement <4 x float> undef, float %915, i32 0
  %917 = insertelement <4 x float> %916, float %915, i32 1
  %918 = insertelement <4 x float> %917, float %915, i32 2
  %919 = extractelement <2 x float> %914, i32 1
  %920 = insertelement <4 x float> %918, float %919, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190

; <label>:921                                     ; preds = %wrapI.exit18.i140
  %922 = icmp eq i32 %15, 13
  %923 = mul i32 %744, %740
  br i1 %922, label %924, label %990

; <label>:924                                     ; preds = %921
  %925 = getelementptr inbounds i8, i8* %742, i32 %923
  %926 = bitcast i8* %925 to i16*
  %927 = load i16, i16* %926, align 2, !tbaa !70
  %928 = zext i16 %927 to i32
  %929 = lshr i32 %928, 11
  %930 = shl nuw nsw i32 %929, 3
  %931 = lshr i32 %928, 13
  %932 = or i32 %930, %931
  %933 = uitofp i32 %932 to float
  %934 = insertelement <3 x float> undef, float %933, i32 0
  %935 = lshr i32 %928, 5
  %936 = and i32 %935, 63
  %937 = shl nuw nsw i32 %936, 2
  %938 = lshr i32 %936, 4
  %939 = or i32 %937, %938
  %940 = uitofp i32 %939 to float
  %941 = insertelement <3 x float> %934, float %940, i32 1
  %942 = and i32 %928, 31
  %943 = shl nuw nsw i32 %942, 3
  %944 = lshr i32 %942, 2
  %945 = or i32 %943, %944
  %946 = uitofp i32 %945 to float
  %947 = insertelement <3 x float> %941, float %946, i32 2
  %948 = mul i32 %744, %712
  %949 = getelementptr inbounds i8, i8* %742, i32 %948
  %950 = bitcast i8* %949 to i16*
  %951 = load i16, i16* %950, align 2, !tbaa !70
  %952 = zext i16 %951 to i32
  %953 = lshr i32 %952, 11
  %954 = shl nuw nsw i32 %953, 3
  %955 = lshr i32 %952, 13
  %956 = or i32 %954, %955
  %957 = uitofp i32 %956 to float
  %958 = insertelement <3 x float> undef, float %957, i32 0
  %959 = lshr i32 %952, 5
  %960 = and i32 %959, 63
  %961 = shl nuw nsw i32 %960, 2
  %962 = lshr i32 %960, 4
  %963 = or i32 %961, %962
  %964 = uitofp i32 %963 to float
  %965 = insertelement <3 x float> %958, float %964, i32 1
  %966 = and i32 %952, 31
  %967 = shl nuw nsw i32 %966, 3
  %968 = lshr i32 %966, 2
  %969 = or i32 %967, %968
  %970 = uitofp i32 %969 to float
  %971 = insertelement <3 x float> %965, float %970, i32 2
  %972 = insertelement <3 x float> undef, float %677, i32 0
  %973 = shufflevector <3 x float> %972, <3 x float> undef, <3 x i32> zeroinitializer
  %974 = fmul <3 x float> %973, %947
  %975 = insertelement <3 x float> undef, float %678, i32 0
  %976 = shufflevector <3 x float> %975, <3 x float> undef, <3 x i32> zeroinitializer
  %977 = fmul <3 x float> %976, %947
  %978 = fadd <3 x float> %974, %977
  %979 = insertelement <3 x float> undef, float %679, i32 0
  %980 = shufflevector <3 x float> %979, <3 x float> undef, <3 x i32> zeroinitializer
  %981 = fmul <3 x float> %980, %971
  %982 = fadd <3 x float> %978, %981
  %983 = insertelement <3 x float> undef, float %680, i32 0
  %984 = shufflevector <3 x float> %983, <3 x float> undef, <3 x i32> zeroinitializer
  %985 = fmul <3 x float> %984, %971
  %986 = fadd <3 x float> %985, %982
  %987 = fmul <3 x float> %986, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %988 = shufflevector <3 x float> %987, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %989 = insertelement <4 x float> %988, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190

; <label>:990                                     ; preds = %921
  %991 = shl nsw i32 %726, 2
  %.sum.i.i3.i.i169 = add i32 %923, %991
  %992 = getelementptr inbounds i8, i8* %742, i32 %.sum.i.i3.i.i169
  %993 = load i8, i8* %992, align 1, !tbaa !19
  %994 = uitofp i8 %993 to float
  %995 = insertelement <4 x float> undef, float %994, i32 0
  %996 = or i32 %991, 1
  %.sum1.i.i4.i.i170 = add i32 %923, %996
  %997 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i.i4.i.i170
  %998 = load i8, i8* %997, align 1, !tbaa !19
  %999 = uitofp i8 %998 to float
  %1000 = insertelement <4 x float> %995, float %999, i32 1
  %1001 = or i32 %991, 2
  %.sum2.i.i5.i.i171 = add i32 %923, %1001
  %1002 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i.i5.i.i171
  %1003 = load i8, i8* %1002, align 1, !tbaa !19
  %1004 = uitofp i8 %1003 to float
  %1005 = insertelement <4 x float> %1000, float %1004, i32 2
  %1006 = or i32 %991, 3
  %.sum3.i.i6.i.i172 = add i32 %923, %1006
  %1007 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i.i6.i.i172
  %1008 = load i8, i8* %1007, align 1, !tbaa !19
  %1009 = uitofp i8 %1008 to float
  %1010 = insertelement <4 x float> %1005, float %1009, i32 3
  %1011 = shl nsw i32 %696, 2
  %.sum.i9.i7.i.i173 = add i32 %923, %1011
  %1012 = getelementptr inbounds i8, i8* %742, i32 %.sum.i9.i7.i.i173
  %1013 = load i8, i8* %1012, align 1, !tbaa !19
  %1014 = uitofp i8 %1013 to float
  %1015 = insertelement <4 x float> undef, float %1014, i32 0
  %1016 = or i32 %1011, 1
  %.sum1.i10.i8.i.i174 = add i32 %923, %1016
  %1017 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i10.i8.i.i174
  %1018 = load i8, i8* %1017, align 1, !tbaa !19
  %1019 = uitofp i8 %1018 to float
  %1020 = insertelement <4 x float> %1015, float %1019, i32 1
  %1021 = or i32 %1011, 2
  %.sum2.i11.i9.i.i175 = add i32 %923, %1021
  %1022 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i11.i9.i.i175
  %1023 = load i8, i8* %1022, align 1, !tbaa !19
  %1024 = uitofp i8 %1023 to float
  %1025 = insertelement <4 x float> %1020, float %1024, i32 2
  %1026 = or i32 %1011, 3
  %.sum3.i12.i10.i.i176 = add i32 %923, %1026
  %1027 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i12.i10.i.i176
  %1028 = load i8, i8* %1027, align 1, !tbaa !19
  %1029 = uitofp i8 %1028 to float
  %1030 = insertelement <4 x float> %1025, float %1029, i32 3
  %1031 = mul i32 %744, %712
  %.sum.i5.i11.i.i177 = add i32 %1031, %991
  %1032 = getelementptr inbounds i8, i8* %742, i32 %.sum.i5.i11.i.i177
  %1033 = load i8, i8* %1032, align 1, !tbaa !19
  %1034 = uitofp i8 %1033 to float
  %1035 = insertelement <4 x float> undef, float %1034, i32 0
  %.sum1.i6.i12.i.i178 = add i32 %1031, %996
  %1036 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i6.i12.i.i178
  %1037 = load i8, i8* %1036, align 1, !tbaa !19
  %1038 = uitofp i8 %1037 to float
  %1039 = insertelement <4 x float> %1035, float %1038, i32 1
  %.sum2.i7.i13.i.i179 = add i32 %1031, %1001
  %1040 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i7.i13.i.i179
  %1041 = load i8, i8* %1040, align 1, !tbaa !19
  %1042 = uitofp i8 %1041 to float
  %1043 = insertelement <4 x float> %1039, float %1042, i32 2
  %.sum3.i8.i14.i.i180 = add i32 %1031, %1006
  %1044 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i8.i14.i.i180
  %1045 = load i8, i8* %1044, align 1, !tbaa !19
  %1046 = uitofp i8 %1045 to float
  %1047 = insertelement <4 x float> %1043, float %1046, i32 3
  %.sum.i1.i15.i.i181 = add i32 %1031, %1011
  %1048 = getelementptr inbounds i8, i8* %742, i32 %.sum.i1.i15.i.i181
  %1049 = load i8, i8* %1048, align 1, !tbaa !19
  %1050 = uitofp i8 %1049 to float
  %1051 = insertelement <4 x float> undef, float %1050, i32 0
  %.sum1.i2.i16.i.i182 = add i32 %1031, %1016
  %1052 = getelementptr inbounds i8, i8* %742, i32 %.sum1.i2.i16.i.i182
  %1053 = load i8, i8* %1052, align 1, !tbaa !19
  %1054 = uitofp i8 %1053 to float
  %1055 = insertelement <4 x float> %1051, float %1054, i32 1
  %.sum2.i3.i17.i.i183 = add i32 %1031, %1021
  %1056 = getelementptr inbounds i8, i8* %742, i32 %.sum2.i3.i17.i.i183
  %1057 = load i8, i8* %1056, align 1, !tbaa !19
  %1058 = uitofp i8 %1057 to float
  %1059 = insertelement <4 x float> %1055, float %1058, i32 2
  %.sum3.i4.i18.i.i184 = add i32 %1031, %1026
  %1060 = getelementptr inbounds i8, i8* %742, i32 %.sum3.i4.i18.i.i184
  %1061 = load i8, i8* %1060, align 1, !tbaa !19
  %1062 = uitofp i8 %1061 to float
  %1063 = insertelement <4 x float> %1059, float %1062, i32 3
  %1064 = insertelement <4 x float> undef, float %677, i32 0
  %1065 = shufflevector <4 x float> %1064, <4 x float> undef, <4 x i32> zeroinitializer
  %1066 = fmul <4 x float> %1065, %1010
  %1067 = insertelement <4 x float> undef, float %678, i32 0
  %1068 = shufflevector <4 x float> %1067, <4 x float> undef, <4 x i32> zeroinitializer
  %1069 = fmul <4 x float> %1068, %1030
  %1070 = fadd <4 x float> %1066, %1069
  %1071 = insertelement <4 x float> undef, float %679, i32 0
  %1072 = shufflevector <4 x float> %1071, <4 x float> undef, <4 x i32> zeroinitializer
  %1073 = fmul <4 x float> %1072, %1047
  %1074 = fadd <4 x float> %1070, %1073
  %1075 = insertelement <4 x float> undef, float %680, i32 0
  %1076 = shufflevector <4 x float> %1075, <4 x float> undef, <4 x i32> zeroinitializer
  %1077 = fmul <4 x float> %1076, %1063
  %1078 = fadd <4 x float> %1074, %1077
  %1079 = fmul <4 x float> %1078, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %1080 = extractelement <4 x float> %1079, i32 0
  %1081 = insertelement <4 x float> undef, float %1080, i32 0
  %1082 = extractelement <4 x float> %1079, i32 1
  %1083 = insertelement <4 x float> %1081, float %1082, i32 1
  %1084 = extractelement <4 x float> %1079, i32 2
  %1085 = insertelement <4 x float> %1083, float %1084, i32 2
  %1086 = insertelement <4 x float> %1085, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190

; <label>:1087                                    ; preds = %wrapI.exit18.i140
  %1088 = mul i32 %744, %740
  %.sum.i.i1.i.i185 = add i32 %1088, %726
  %1089 = getelementptr inbounds i8, i8* %742, i32 %.sum.i.i1.i.i185
  %1090 = load i8, i8* %1089, align 1, !tbaa !19
  %1091 = uitofp i8 %1090 to float
  %.sum.i3.i.i.i186 = add i32 %1088, %696
  %1092 = getelementptr inbounds i8, i8* %742, i32 %.sum.i3.i.i.i186
  %1093 = load i8, i8* %1092, align 1, !tbaa !19
  %1094 = uitofp i8 %1093 to float
  %1095 = mul i32 %744, %712
  %.sum.i2.i.i.i187 = add i32 %1095, %726
  %1096 = getelementptr inbounds i8, i8* %742, i32 %.sum.i2.i.i.i187
  %1097 = load i8, i8* %1096, align 1, !tbaa !19
  %1098 = uitofp i8 %1097 to float
  %.sum.i1.i2.i.i188 = add i32 %1095, %696
  %1099 = getelementptr inbounds i8, i8* %742, i32 %.sum.i1.i2.i.i188
  %1100 = load i8, i8* %1099, align 1, !tbaa !19
  %1101 = uitofp i8 %1100 to float
  %1102 = fmul float %677, %1091
  %1103 = fmul float %678, %1094
  %1104 = fadd float %1102, %1103
  %1105 = fmul float %679, %1098
  %1106 = fadd float %1104, %1105
  %1107 = fmul float %680, %1101
  %1108 = fadd float %1106, %1107
  %1109 = fmul float %1108, 0x3F70101020000000
  %1110 = insertelement <4 x float> undef, float %1109, i32 0
  %1111 = insertelement <4 x float> %1110, float %1109, i32 1
  %1112 = insertelement <4 x float> %1111, float %1109, i32 2
  %1113 = insertelement <4 x float> %1112, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190: ; preds = %wrapI.exit18.i140, %745, %836, %860, %924, %990, %1087
  %.0.i.i189 = phi <4 x float> [ %1113, %1087 ], [ %989, %924 ], [ %1086, %990 ], [ %920, %860 ], [ %859, %836 ], [ %835, %745 ], [ zeroinitializer, %wrapI.exit18.i140 ]
  br label %2207

; <label>:1114                                    ; preds = %634
  %1115 = tail call float @_Z5floorf(float %lod) #14
  %1116 = fptoui float %1115 to i32
  %1117 = tail call float @_Z4ceilf(float %lod) #14
  %1118 = fptoui float %1117 to i32
  %1119 = getelementptr inbounds i8, i8* %6, i32 68
  %1120 = bitcast i8* %1119 to i32*
  %1121 = load i32, i32* %1120, align 4, !tbaa !21
  %1122 = add i32 %1121, -1
  %1123 = icmp ult i32 %1116, %1122
  %1124 = select i1 %1123, i32 %1116, i32 %1122
  %1125 = icmp ult i32 %1118, %1122
  %1126 = select i1 %1125, i32 %1118, i32 %1122
  %1127 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1124, i32 2
  %1128 = load i32, i32* %1127, align 4, !tbaa !21
  %1129 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1124, i32 3
  %1130 = load i32, i32* %1129, align 4, !tbaa !21
  %1131 = extractelement <2 x float> %uv, i32 0
  %1132 = sitofp i32 %1128 to float
  %1133 = fmul float %1131, %1132
  %1134 = extractelement <2 x float> %uv, i32 1
  %1135 = sitofp i32 %1130 to float
  %1136 = fmul float %1134, %1135
  %1137 = fptosi float %1133 to i32
  %1138 = fptosi float %1136 to i32
  %1139 = sitofp i32 %1137 to float
  %1140 = fsub float %1133, %1139
  %1141 = sitofp i32 %1138 to float
  %1142 = fsub float %1136, %1141
  %1143 = fcmp olt float %1140, 5.000000e-01
  br i1 %1143, label %1144, label %1147

; <label>:1144                                    ; preds = %1114
  %1145 = add nsw i32 %1137, -1
  %1146 = fadd float %1140, 5.000000e-01
  br label %1149

; <label>:1147                                    ; preds = %1114
  %1148 = fadd float %1140, -5.000000e-01
  br label %1149

; <label>:1149                                    ; preds = %1147, %1144
  %fracU.0.i35 = phi float [ %1146, %1144 ], [ %1148, %1147 ]
  %iPixelU.0.i36 = phi i32 [ %1145, %1144 ], [ %1137, %1147 ]
  %1150 = fcmp olt float %1142, 5.000000e-01
  br i1 %1150, label %1151, label %1154

; <label>:1151                                    ; preds = %1149
  %1152 = add nsw i32 %1138, -1
  %1153 = fadd float %1142, 5.000000e-01
  br label %1156

; <label>:1154                                    ; preds = %1149
  %1155 = fadd float %1142, -5.000000e-01
  br label %1156

; <label>:1156                                    ; preds = %1154, %1151
  %fracV.0.i37 = phi float [ %1153, %1151 ], [ %1155, %1154 ]
  %iPixelV.0.i38 = phi i32 [ %1152, %1151 ], [ %1138, %1154 ]
  %1157 = fsub float 1.000000e+00, %fracU.0.i35
  %1158 = fsub float 1.000000e+00, %fracV.0.i37
  %1159 = fmul float %1157, %1158
  %1160 = fmul float %fracU.0.i35, %1158
  %1161 = fmul float %1157, %fracV.0.i37
  %1162 = fmul float %fracU.0.i35, %fracV.0.i37
  %1163 = add nsw i32 %iPixelU.0.i36, 1
  switch i32 %21, label %wrapI.exit.i44 [
    i32 3, label %.thread.i.i40
    i32 6, label %1167
  ]

.thread.i.i40:                                    ; preds = %1156
  %1164 = srem i32 %1163, %1128
  %1165 = icmp slt i32 %1164, 0
  %1166 = select i1 %1165, i32 %1128, i32 0
  %..i.i39 = add nsw i32 %1166, %1164
  br label %wrapI.exit.i44

; <label>:1167                                    ; preds = %1156
  %1168 = shl nsw i32 %1128, 1
  %1169 = srem i32 %1163, %1168
  %1170 = icmp slt i32 %1169, 0
  %1171 = select i1 %1170, i32 %1168, i32 0
  %.3.i.i41 = add nsw i32 %1171, %1169
  %1172 = icmp slt i32 %.3.i.i41, %1128
  %1173 = sub nsw i32 %1168, %.3.i.i41
  %.3..i.i42 = select i1 %1172, i32 %.3.i.i41, i32 %1173
  br label %wrapI.exit.i44

wrapI.exit.i44:                                   ; preds = %1167, %.thread.i.i40, %1156
  %.2.i.i43 = phi i32 [ %.3..i.i42, %1167 ], [ %..i.i39, %.thread.i.i40 ], [ %1163, %1156 ]
  %1174 = add nsw i32 %1128, -1
  %1175 = icmp slt i32 %.2.i.i43, %1174
  %1176 = select i1 %1175, i32 %.2.i.i43, i32 %1174
  %1177 = icmp sgt i32 0, %1176
  %1178 = select i1 %1177, i32 0, i32 %1176
  %1179 = add nsw i32 %iPixelV.0.i38, 1
  switch i32 %23, label %wrapI.exit6.i50 [
    i32 3, label %.thread.i2.i46
    i32 6, label %1183
  ]

.thread.i2.i46:                                   ; preds = %wrapI.exit.i44
  %1180 = srem i32 %1179, %1130
  %1181 = icmp slt i32 %1180, 0
  %1182 = select i1 %1181, i32 %1130, i32 0
  %..i1.i45 = add nsw i32 %1182, %1180
  br label %wrapI.exit6.i50

; <label>:1183                                    ; preds = %wrapI.exit.i44
  %1184 = shl nsw i32 %1130, 1
  %1185 = srem i32 %1179, %1184
  %1186 = icmp slt i32 %1185, 0
  %1187 = select i1 %1186, i32 %1184, i32 0
  %.3.i3.i47 = add nsw i32 %1187, %1185
  %1188 = icmp slt i32 %.3.i3.i47, %1130
  %1189 = sub nsw i32 %1184, %.3.i3.i47
  %.3..i4.i48 = select i1 %1188, i32 %.3.i3.i47, i32 %1189
  br label %wrapI.exit6.i50

wrapI.exit6.i50:                                  ; preds = %1183, %.thread.i2.i46, %wrapI.exit.i44
  %.2.i5.i49 = phi i32 [ %.3..i4.i48, %1183 ], [ %..i1.i45, %.thread.i2.i46 ], [ %1179, %wrapI.exit.i44 ]
  %1190 = add nsw i32 %1130, -1
  %1191 = icmp slt i32 %.2.i5.i49, %1190
  %1192 = select i1 %1191, i32 %.2.i5.i49, i32 %1190
  %1193 = icmp sgt i32 0, %1192
  %1194 = select i1 %1193, i32 0, i32 %1192
  switch i32 %21, label %wrapI.exit12.i56 [
    i32 3, label %.thread.i8.i52
    i32 6, label %1198
  ]

.thread.i8.i52:                                   ; preds = %wrapI.exit6.i50
  %1195 = srem i32 %iPixelU.0.i36, %1128
  %1196 = icmp slt i32 %1195, 0
  %1197 = select i1 %1196, i32 %1128, i32 0
  %..i7.i51 = add nsw i32 %1197, %1195
  br label %wrapI.exit12.i56

; <label>:1198                                    ; preds = %wrapI.exit6.i50
  %1199 = shl nsw i32 %1128, 1
  %1200 = srem i32 %iPixelU.0.i36, %1199
  %1201 = icmp slt i32 %1200, 0
  %1202 = select i1 %1201, i32 %1199, i32 0
  %.3.i9.i53 = add nsw i32 %1202, %1200
  %1203 = icmp slt i32 %.3.i9.i53, %1128
  %1204 = sub nsw i32 %1199, %.3.i9.i53
  %.3..i10.i54 = select i1 %1203, i32 %.3.i9.i53, i32 %1204
  br label %wrapI.exit12.i56

wrapI.exit12.i56:                                 ; preds = %1198, %.thread.i8.i52, %wrapI.exit6.i50
  %.2.i11.i55 = phi i32 [ %.3..i10.i54, %1198 ], [ %..i7.i51, %.thread.i8.i52 ], [ %iPixelU.0.i36, %wrapI.exit6.i50 ]
  %1205 = icmp slt i32 %.2.i11.i55, %1174
  %1206 = select i1 %1205, i32 %.2.i11.i55, i32 %1174
  %1207 = icmp sgt i32 0, %1206
  %1208 = select i1 %1207, i32 0, i32 %1206
  switch i32 %23, label %wrapI.exit18.i62 [
    i32 3, label %.thread.i14.i58
    i32 6, label %1212
  ]

.thread.i14.i58:                                  ; preds = %wrapI.exit12.i56
  %1209 = srem i32 %iPixelV.0.i38, %1130
  %1210 = icmp slt i32 %1209, 0
  %1211 = select i1 %1210, i32 %1130, i32 0
  %..i13.i57 = add nsw i32 %1211, %1209
  br label %wrapI.exit18.i62

; <label>:1212                                    ; preds = %wrapI.exit12.i56
  %1213 = shl nsw i32 %1130, 1
  %1214 = srem i32 %iPixelV.0.i38, %1213
  %1215 = icmp slt i32 %1214, 0
  %1216 = select i1 %1215, i32 %1213, i32 0
  %.3.i15.i59 = add nsw i32 %1216, %1214
  %1217 = icmp slt i32 %.3.i15.i59, %1130
  %1218 = sub nsw i32 %1213, %.3.i15.i59
  %.3..i16.i60 = select i1 %1217, i32 %.3.i15.i59, i32 %1218
  br label %wrapI.exit18.i62

wrapI.exit18.i62:                                 ; preds = %1212, %.thread.i14.i58, %wrapI.exit12.i56
  %.2.i17.i61 = phi i32 [ %.3..i16.i60, %1212 ], [ %..i13.i57, %.thread.i14.i58 ], [ %iPixelV.0.i38, %wrapI.exit12.i56 ]
  %1219 = icmp slt i32 %.2.i17.i61, %1190
  %1220 = select i1 %1219, i32 %.2.i17.i61, i32 %1190
  %1221 = icmp sgt i32 0, %1220
  %1222 = select i1 %1221, i32 0, i32 %1220
  %1223 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1124, i32 0
  %1224 = load i8*, i8** %1223, align 4, !tbaa !22
  %1225 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1124, i32 1
  %1226 = load i32, i32* %1225, align 4, !tbaa !21
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112 [
    i32 11, label %1227
    i32 8, label %1318
    i32 9, label %1342
    i32 10, label %1403
    i32 7, label %1569
  ]

; <label>:1227                                    ; preds = %wrapI.exit18.i62
  %1228 = mul i32 %1226, %1222
  %1229 = shl nsw i32 %1208, 2
  %.sum.i.i.i.i63 = add i32 %1228, %1229
  %1230 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i.i.i.i63
  %1231 = load i8, i8* %1230, align 1, !tbaa !19
  %1232 = uitofp i8 %1231 to float
  %1233 = insertelement <4 x float> undef, float %1232, i32 0
  %1234 = or i32 %1229, 1
  %.sum1.i.i.i.i64 = add i32 %1228, %1234
  %1235 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i.i.i.i64
  %1236 = load i8, i8* %1235, align 1, !tbaa !19
  %1237 = uitofp i8 %1236 to float
  %1238 = insertelement <4 x float> %1233, float %1237, i32 1
  %1239 = or i32 %1229, 2
  %.sum2.i.i.i.i65 = add i32 %1228, %1239
  %1240 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i.i.i.i65
  %1241 = load i8, i8* %1240, align 1, !tbaa !19
  %1242 = uitofp i8 %1241 to float
  %1243 = insertelement <4 x float> %1238, float %1242, i32 2
  %1244 = or i32 %1229, 3
  %.sum3.i.i.i.i66 = add i32 %1228, %1244
  %1245 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i.i.i.i66
  %1246 = load i8, i8* %1245, align 1, !tbaa !19
  %1247 = uitofp i8 %1246 to float
  %1248 = insertelement <4 x float> %1243, float %1247, i32 3
  %1249 = shl nsw i32 %1178, 2
  %.sum.i9.i.i.i67 = add i32 %1228, %1249
  %1250 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i9.i.i.i67
  %1251 = load i8, i8* %1250, align 1, !tbaa !19
  %1252 = uitofp i8 %1251 to float
  %1253 = insertelement <4 x float> undef, float %1252, i32 0
  %1254 = or i32 %1249, 1
  %.sum1.i10.i.i.i68 = add i32 %1228, %1254
  %1255 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i10.i.i.i68
  %1256 = load i8, i8* %1255, align 1, !tbaa !19
  %1257 = uitofp i8 %1256 to float
  %1258 = insertelement <4 x float> %1253, float %1257, i32 1
  %1259 = or i32 %1249, 2
  %.sum2.i11.i.i.i69 = add i32 %1228, %1259
  %1260 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i11.i.i.i69
  %1261 = load i8, i8* %1260, align 1, !tbaa !19
  %1262 = uitofp i8 %1261 to float
  %1263 = insertelement <4 x float> %1258, float %1262, i32 2
  %1264 = or i32 %1249, 3
  %.sum3.i12.i.i.i70 = add i32 %1228, %1264
  %1265 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i12.i.i.i70
  %1266 = load i8, i8* %1265, align 1, !tbaa !19
  %1267 = uitofp i8 %1266 to float
  %1268 = insertelement <4 x float> %1263, float %1267, i32 3
  %1269 = mul i32 %1226, %1194
  %.sum.i5.i.i.i71 = add i32 %1269, %1229
  %1270 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i5.i.i.i71
  %1271 = load i8, i8* %1270, align 1, !tbaa !19
  %1272 = uitofp i8 %1271 to float
  %1273 = insertelement <4 x float> undef, float %1272, i32 0
  %.sum1.i6.i.i.i72 = add i32 %1269, %1234
  %1274 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i6.i.i.i72
  %1275 = load i8, i8* %1274, align 1, !tbaa !19
  %1276 = uitofp i8 %1275 to float
  %1277 = insertelement <4 x float> %1273, float %1276, i32 1
  %.sum2.i7.i.i.i73 = add i32 %1269, %1239
  %1278 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i7.i.i.i73
  %1279 = load i8, i8* %1278, align 1, !tbaa !19
  %1280 = uitofp i8 %1279 to float
  %1281 = insertelement <4 x float> %1277, float %1280, i32 2
  %.sum3.i8.i.i.i74 = add i32 %1269, %1244
  %1282 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i8.i.i.i74
  %1283 = load i8, i8* %1282, align 1, !tbaa !19
  %1284 = uitofp i8 %1283 to float
  %1285 = insertelement <4 x float> %1281, float %1284, i32 3
  %.sum.i1.i.i.i75 = add i32 %1269, %1249
  %1286 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i1.i.i.i75
  %1287 = load i8, i8* %1286, align 1, !tbaa !19
  %1288 = uitofp i8 %1287 to float
  %1289 = insertelement <4 x float> undef, float %1288, i32 0
  %.sum1.i2.i.i.i76 = add i32 %1269, %1254
  %1290 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i2.i.i.i76
  %1291 = load i8, i8* %1290, align 1, !tbaa !19
  %1292 = uitofp i8 %1291 to float
  %1293 = insertelement <4 x float> %1289, float %1292, i32 1
  %.sum2.i3.i.i.i77 = add i32 %1269, %1259
  %1294 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i3.i.i.i77
  %1295 = load i8, i8* %1294, align 1, !tbaa !19
  %1296 = uitofp i8 %1295 to float
  %1297 = insertelement <4 x float> %1293, float %1296, i32 2
  %.sum3.i4.i.i.i78 = add i32 %1269, %1264
  %1298 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i4.i.i.i78
  %1299 = load i8, i8* %1298, align 1, !tbaa !19
  %1300 = uitofp i8 %1299 to float
  %1301 = insertelement <4 x float> %1297, float %1300, i32 3
  %1302 = insertelement <4 x float> undef, float %1159, i32 0
  %1303 = shufflevector <4 x float> %1302, <4 x float> undef, <4 x i32> zeroinitializer
  %1304 = fmul <4 x float> %1303, %1248
  %1305 = insertelement <4 x float> undef, float %1160, i32 0
  %1306 = shufflevector <4 x float> %1305, <4 x float> undef, <4 x i32> zeroinitializer
  %1307 = fmul <4 x float> %1306, %1268
  %1308 = fadd <4 x float> %1304, %1307
  %1309 = insertelement <4 x float> undef, float %1161, i32 0
  %1310 = shufflevector <4 x float> %1309, <4 x float> undef, <4 x i32> zeroinitializer
  %1311 = fmul <4 x float> %1310, %1285
  %1312 = fadd <4 x float> %1308, %1311
  %1313 = insertelement <4 x float> undef, float %1162, i32 0
  %1314 = shufflevector <4 x float> %1313, <4 x float> undef, <4 x i32> zeroinitializer
  %1315 = fmul <4 x float> %1314, %1301
  %1316 = fadd <4 x float> %1312, %1315
  %1317 = fmul <4 x float> %1316, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112

; <label>:1318                                    ; preds = %wrapI.exit18.i62
  %1319 = mul i32 %1226, %1222
  %.sum.i.i26.i.i79 = add i32 %1319, %1208
  %1320 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i.i26.i.i79
  %1321 = load i8, i8* %1320, align 1, !tbaa !19
  %1322 = uitofp i8 %1321 to float
  %.sum.i3.i27.i.i80 = add i32 %1319, %1178
  %1323 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i3.i27.i.i80
  %1324 = load i8, i8* %1323, align 1, !tbaa !19
  %1325 = uitofp i8 %1324 to float
  %1326 = mul i32 %1226, %1194
  %.sum.i2.i28.i.i81 = add i32 %1326, %1208
  %1327 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i2.i28.i.i81
  %1328 = load i8, i8* %1327, align 1, !tbaa !19
  %1329 = uitofp i8 %1328 to float
  %.sum.i1.i29.i.i82 = add i32 %1326, %1178
  %1330 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i1.i29.i.i82
  %1331 = load i8, i8* %1330, align 1, !tbaa !19
  %1332 = uitofp i8 %1331 to float
  %1333 = fmul float %1159, %1322
  %1334 = fmul float %1160, %1325
  %1335 = fadd float %1333, %1334
  %1336 = fmul float %1161, %1329
  %1337 = fadd float %1335, %1336
  %1338 = fmul float %1162, %1332
  %1339 = fadd float %1337, %1338
  %1340 = fmul float %1339, 0x3F70101020000000
  %1341 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %1340, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112

; <label>:1342                                    ; preds = %wrapI.exit18.i62
  %1343 = mul i32 %1226, %1222
  %1344 = shl nsw i32 %1208, 1
  %.sum.i.i19.i.i83 = add i32 %1343, %1344
  %1345 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i.i19.i.i83
  %1346 = load i8, i8* %1345, align 1, !tbaa !19
  %1347 = uitofp i8 %1346 to float
  %1348 = insertelement <2 x float> undef, float %1347, i32 0
  %1349 = or i32 %1344, 1
  %.sum1.i.i20.i.i84 = add i32 %1343, %1349
  %1350 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i.i20.i.i84
  %1351 = load i8, i8* %1350, align 1, !tbaa !19
  %1352 = uitofp i8 %1351 to float
  %1353 = insertelement <2 x float> %1348, float %1352, i32 1
  %1354 = shl nsw i32 %1178, 1
  %.sum.i5.i21.i.i85 = add i32 %1343, %1354
  %1355 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i5.i21.i.i85
  %1356 = load i8, i8* %1355, align 1, !tbaa !19
  %1357 = uitofp i8 %1356 to float
  %1358 = insertelement <2 x float> undef, float %1357, i32 0
  %1359 = or i32 %1354, 1
  %.sum1.i6.i22.i.i86 = add i32 %1343, %1359
  %1360 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i6.i22.i.i86
  %1361 = load i8, i8* %1360, align 1, !tbaa !19
  %1362 = uitofp i8 %1361 to float
  %1363 = insertelement <2 x float> %1358, float %1362, i32 1
  %1364 = mul i32 %1226, %1194
  %.sum.i3.i23.i.i87 = add i32 %1364, %1344
  %1365 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i3.i23.i.i87
  %1366 = load i8, i8* %1365, align 1, !tbaa !19
  %1367 = uitofp i8 %1366 to float
  %1368 = insertelement <2 x float> undef, float %1367, i32 0
  %.sum1.i4.i.i.i88 = add i32 %1364, %1349
  %1369 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i4.i.i.i88
  %1370 = load i8, i8* %1369, align 1, !tbaa !19
  %1371 = uitofp i8 %1370 to float
  %1372 = insertelement <2 x float> %1368, float %1371, i32 1
  %.sum.i1.i24.i.i89 = add i32 %1364, %1354
  %1373 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i1.i24.i.i89
  %1374 = load i8, i8* %1373, align 1, !tbaa !19
  %1375 = uitofp i8 %1374 to float
  %1376 = insertelement <2 x float> undef, float %1375, i32 0
  %.sum1.i2.i25.i.i90 = add i32 %1364, %1359
  %1377 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i2.i25.i.i90
  %1378 = load i8, i8* %1377, align 1, !tbaa !19
  %1379 = uitofp i8 %1378 to float
  %1380 = insertelement <2 x float> %1376, float %1379, i32 1
  %1381 = insertelement <2 x float> undef, float %1159, i32 0
  %1382 = shufflevector <2 x float> %1381, <2 x float> undef, <2 x i32> zeroinitializer
  %1383 = fmul <2 x float> %1382, %1353
  %1384 = insertelement <2 x float> undef, float %1160, i32 0
  %1385 = shufflevector <2 x float> %1384, <2 x float> undef, <2 x i32> zeroinitializer
  %1386 = fmul <2 x float> %1385, %1363
  %1387 = fadd <2 x float> %1383, %1386
  %1388 = insertelement <2 x float> undef, float %1161, i32 0
  %1389 = shufflevector <2 x float> %1388, <2 x float> undef, <2 x i32> zeroinitializer
  %1390 = fmul <2 x float> %1389, %1372
  %1391 = fadd <2 x float> %1387, %1390
  %1392 = insertelement <2 x float> undef, float %1162, i32 0
  %1393 = shufflevector <2 x float> %1392, <2 x float> undef, <2 x i32> zeroinitializer
  %1394 = fmul <2 x float> %1393, %1380
  %1395 = fadd <2 x float> %1391, %1394
  %1396 = fmul <2 x float> %1395, <float 0x3F70101020000000, float 0x3F70101020000000>
  %1397 = extractelement <2 x float> %1396, i32 0
  %1398 = insertelement <4 x float> undef, float %1397, i32 0
  %1399 = insertelement <4 x float> %1398, float %1397, i32 1
  %1400 = insertelement <4 x float> %1399, float %1397, i32 2
  %1401 = extractelement <2 x float> %1396, i32 1
  %1402 = insertelement <4 x float> %1400, float %1401, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112

; <label>:1403                                    ; preds = %wrapI.exit18.i62
  %1404 = icmp eq i32 %15, 13
  %1405 = mul i32 %1226, %1222
  br i1 %1404, label %1406, label %1472

; <label>:1406                                    ; preds = %1403
  %1407 = getelementptr inbounds i8, i8* %1224, i32 %1405
  %1408 = bitcast i8* %1407 to i16*
  %1409 = load i16, i16* %1408, align 2, !tbaa !70
  %1410 = zext i16 %1409 to i32
  %1411 = lshr i32 %1410, 11
  %1412 = shl nuw nsw i32 %1411, 3
  %1413 = lshr i32 %1410, 13
  %1414 = or i32 %1412, %1413
  %1415 = uitofp i32 %1414 to float
  %1416 = insertelement <3 x float> undef, float %1415, i32 0
  %1417 = lshr i32 %1410, 5
  %1418 = and i32 %1417, 63
  %1419 = shl nuw nsw i32 %1418, 2
  %1420 = lshr i32 %1418, 4
  %1421 = or i32 %1419, %1420
  %1422 = uitofp i32 %1421 to float
  %1423 = insertelement <3 x float> %1416, float %1422, i32 1
  %1424 = and i32 %1410, 31
  %1425 = shl nuw nsw i32 %1424, 3
  %1426 = lshr i32 %1424, 2
  %1427 = or i32 %1425, %1426
  %1428 = uitofp i32 %1427 to float
  %1429 = insertelement <3 x float> %1423, float %1428, i32 2
  %1430 = mul i32 %1226, %1194
  %1431 = getelementptr inbounds i8, i8* %1224, i32 %1430
  %1432 = bitcast i8* %1431 to i16*
  %1433 = load i16, i16* %1432, align 2, !tbaa !70
  %1434 = zext i16 %1433 to i32
  %1435 = lshr i32 %1434, 11
  %1436 = shl nuw nsw i32 %1435, 3
  %1437 = lshr i32 %1434, 13
  %1438 = or i32 %1436, %1437
  %1439 = uitofp i32 %1438 to float
  %1440 = insertelement <3 x float> undef, float %1439, i32 0
  %1441 = lshr i32 %1434, 5
  %1442 = and i32 %1441, 63
  %1443 = shl nuw nsw i32 %1442, 2
  %1444 = lshr i32 %1442, 4
  %1445 = or i32 %1443, %1444
  %1446 = uitofp i32 %1445 to float
  %1447 = insertelement <3 x float> %1440, float %1446, i32 1
  %1448 = and i32 %1434, 31
  %1449 = shl nuw nsw i32 %1448, 3
  %1450 = lshr i32 %1448, 2
  %1451 = or i32 %1449, %1450
  %1452 = uitofp i32 %1451 to float
  %1453 = insertelement <3 x float> %1447, float %1452, i32 2
  %1454 = insertelement <3 x float> undef, float %1159, i32 0
  %1455 = shufflevector <3 x float> %1454, <3 x float> undef, <3 x i32> zeroinitializer
  %1456 = fmul <3 x float> %1455, %1429
  %1457 = insertelement <3 x float> undef, float %1160, i32 0
  %1458 = shufflevector <3 x float> %1457, <3 x float> undef, <3 x i32> zeroinitializer
  %1459 = fmul <3 x float> %1458, %1429
  %1460 = fadd <3 x float> %1456, %1459
  %1461 = insertelement <3 x float> undef, float %1161, i32 0
  %1462 = shufflevector <3 x float> %1461, <3 x float> undef, <3 x i32> zeroinitializer
  %1463 = fmul <3 x float> %1462, %1453
  %1464 = fadd <3 x float> %1460, %1463
  %1465 = insertelement <3 x float> undef, float %1162, i32 0
  %1466 = shufflevector <3 x float> %1465, <3 x float> undef, <3 x i32> zeroinitializer
  %1467 = fmul <3 x float> %1466, %1453
  %1468 = fadd <3 x float> %1467, %1464
  %1469 = fmul <3 x float> %1468, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %1470 = shufflevector <3 x float> %1469, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %1471 = insertelement <4 x float> %1470, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112

; <label>:1472                                    ; preds = %1403
  %1473 = shl nsw i32 %1208, 2
  %.sum.i.i3.i.i91 = add i32 %1405, %1473
  %1474 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i.i3.i.i91
  %1475 = load i8, i8* %1474, align 1, !tbaa !19
  %1476 = uitofp i8 %1475 to float
  %1477 = insertelement <4 x float> undef, float %1476, i32 0
  %1478 = or i32 %1473, 1
  %.sum1.i.i4.i.i92 = add i32 %1405, %1478
  %1479 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i.i4.i.i92
  %1480 = load i8, i8* %1479, align 1, !tbaa !19
  %1481 = uitofp i8 %1480 to float
  %1482 = insertelement <4 x float> %1477, float %1481, i32 1
  %1483 = or i32 %1473, 2
  %.sum2.i.i5.i.i93 = add i32 %1405, %1483
  %1484 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i.i5.i.i93
  %1485 = load i8, i8* %1484, align 1, !tbaa !19
  %1486 = uitofp i8 %1485 to float
  %1487 = insertelement <4 x float> %1482, float %1486, i32 2
  %1488 = or i32 %1473, 3
  %.sum3.i.i6.i.i94 = add i32 %1405, %1488
  %1489 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i.i6.i.i94
  %1490 = load i8, i8* %1489, align 1, !tbaa !19
  %1491 = uitofp i8 %1490 to float
  %1492 = insertelement <4 x float> %1487, float %1491, i32 3
  %1493 = shl nsw i32 %1178, 2
  %.sum.i9.i7.i.i95 = add i32 %1405, %1493
  %1494 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i9.i7.i.i95
  %1495 = load i8, i8* %1494, align 1, !tbaa !19
  %1496 = uitofp i8 %1495 to float
  %1497 = insertelement <4 x float> undef, float %1496, i32 0
  %1498 = or i32 %1493, 1
  %.sum1.i10.i8.i.i96 = add i32 %1405, %1498
  %1499 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i10.i8.i.i96
  %1500 = load i8, i8* %1499, align 1, !tbaa !19
  %1501 = uitofp i8 %1500 to float
  %1502 = insertelement <4 x float> %1497, float %1501, i32 1
  %1503 = or i32 %1493, 2
  %.sum2.i11.i9.i.i97 = add i32 %1405, %1503
  %1504 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i11.i9.i.i97
  %1505 = load i8, i8* %1504, align 1, !tbaa !19
  %1506 = uitofp i8 %1505 to float
  %1507 = insertelement <4 x float> %1502, float %1506, i32 2
  %1508 = or i32 %1493, 3
  %.sum3.i12.i10.i.i98 = add i32 %1405, %1508
  %1509 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i12.i10.i.i98
  %1510 = load i8, i8* %1509, align 1, !tbaa !19
  %1511 = uitofp i8 %1510 to float
  %1512 = insertelement <4 x float> %1507, float %1511, i32 3
  %1513 = mul i32 %1226, %1194
  %.sum.i5.i11.i.i99 = add i32 %1513, %1473
  %1514 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i5.i11.i.i99
  %1515 = load i8, i8* %1514, align 1, !tbaa !19
  %1516 = uitofp i8 %1515 to float
  %1517 = insertelement <4 x float> undef, float %1516, i32 0
  %.sum1.i6.i12.i.i100 = add i32 %1513, %1478
  %1518 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i6.i12.i.i100
  %1519 = load i8, i8* %1518, align 1, !tbaa !19
  %1520 = uitofp i8 %1519 to float
  %1521 = insertelement <4 x float> %1517, float %1520, i32 1
  %.sum2.i7.i13.i.i101 = add i32 %1513, %1483
  %1522 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i7.i13.i.i101
  %1523 = load i8, i8* %1522, align 1, !tbaa !19
  %1524 = uitofp i8 %1523 to float
  %1525 = insertelement <4 x float> %1521, float %1524, i32 2
  %.sum3.i8.i14.i.i102 = add i32 %1513, %1488
  %1526 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i8.i14.i.i102
  %1527 = load i8, i8* %1526, align 1, !tbaa !19
  %1528 = uitofp i8 %1527 to float
  %1529 = insertelement <4 x float> %1525, float %1528, i32 3
  %.sum.i1.i15.i.i103 = add i32 %1513, %1493
  %1530 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i1.i15.i.i103
  %1531 = load i8, i8* %1530, align 1, !tbaa !19
  %1532 = uitofp i8 %1531 to float
  %1533 = insertelement <4 x float> undef, float %1532, i32 0
  %.sum1.i2.i16.i.i104 = add i32 %1513, %1498
  %1534 = getelementptr inbounds i8, i8* %1224, i32 %.sum1.i2.i16.i.i104
  %1535 = load i8, i8* %1534, align 1, !tbaa !19
  %1536 = uitofp i8 %1535 to float
  %1537 = insertelement <4 x float> %1533, float %1536, i32 1
  %.sum2.i3.i17.i.i105 = add i32 %1513, %1503
  %1538 = getelementptr inbounds i8, i8* %1224, i32 %.sum2.i3.i17.i.i105
  %1539 = load i8, i8* %1538, align 1, !tbaa !19
  %1540 = uitofp i8 %1539 to float
  %1541 = insertelement <4 x float> %1537, float %1540, i32 2
  %.sum3.i4.i18.i.i106 = add i32 %1513, %1508
  %1542 = getelementptr inbounds i8, i8* %1224, i32 %.sum3.i4.i18.i.i106
  %1543 = load i8, i8* %1542, align 1, !tbaa !19
  %1544 = uitofp i8 %1543 to float
  %1545 = insertelement <4 x float> %1541, float %1544, i32 3
  %1546 = insertelement <4 x float> undef, float %1159, i32 0
  %1547 = shufflevector <4 x float> %1546, <4 x float> undef, <4 x i32> zeroinitializer
  %1548 = fmul <4 x float> %1547, %1492
  %1549 = insertelement <4 x float> undef, float %1160, i32 0
  %1550 = shufflevector <4 x float> %1549, <4 x float> undef, <4 x i32> zeroinitializer
  %1551 = fmul <4 x float> %1550, %1512
  %1552 = fadd <4 x float> %1548, %1551
  %1553 = insertelement <4 x float> undef, float %1161, i32 0
  %1554 = shufflevector <4 x float> %1553, <4 x float> undef, <4 x i32> zeroinitializer
  %1555 = fmul <4 x float> %1554, %1529
  %1556 = fadd <4 x float> %1552, %1555
  %1557 = insertelement <4 x float> undef, float %1162, i32 0
  %1558 = shufflevector <4 x float> %1557, <4 x float> undef, <4 x i32> zeroinitializer
  %1559 = fmul <4 x float> %1558, %1545
  %1560 = fadd <4 x float> %1556, %1559
  %1561 = fmul <4 x float> %1560, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %1562 = extractelement <4 x float> %1561, i32 0
  %1563 = insertelement <4 x float> undef, float %1562, i32 0
  %1564 = extractelement <4 x float> %1561, i32 1
  %1565 = insertelement <4 x float> %1563, float %1564, i32 1
  %1566 = extractelement <4 x float> %1561, i32 2
  %1567 = insertelement <4 x float> %1565, float %1566, i32 2
  %1568 = insertelement <4 x float> %1567, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112

; <label>:1569                                    ; preds = %wrapI.exit18.i62
  %1570 = mul i32 %1226, %1222
  %.sum.i.i1.i.i107 = add i32 %1570, %1208
  %1571 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i.i1.i.i107
  %1572 = load i8, i8* %1571, align 1, !tbaa !19
  %1573 = uitofp i8 %1572 to float
  %.sum.i3.i.i.i108 = add i32 %1570, %1178
  %1574 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i3.i.i.i108
  %1575 = load i8, i8* %1574, align 1, !tbaa !19
  %1576 = uitofp i8 %1575 to float
  %1577 = mul i32 %1226, %1194
  %.sum.i2.i.i.i109 = add i32 %1577, %1208
  %1578 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i2.i.i.i109
  %1579 = load i8, i8* %1578, align 1, !tbaa !19
  %1580 = uitofp i8 %1579 to float
  %.sum.i1.i2.i.i110 = add i32 %1577, %1178
  %1581 = getelementptr inbounds i8, i8* %1224, i32 %.sum.i1.i2.i.i110
  %1582 = load i8, i8* %1581, align 1, !tbaa !19
  %1583 = uitofp i8 %1582 to float
  %1584 = fmul float %1159, %1573
  %1585 = fmul float %1160, %1576
  %1586 = fadd float %1584, %1585
  %1587 = fmul float %1161, %1580
  %1588 = fadd float %1586, %1587
  %1589 = fmul float %1162, %1583
  %1590 = fadd float %1588, %1589
  %1591 = fmul float %1590, 0x3F70101020000000
  %1592 = insertelement <4 x float> undef, float %1591, i32 0
  %1593 = insertelement <4 x float> %1592, float %1591, i32 1
  %1594 = insertelement <4 x float> %1593, float %1591, i32 2
  %1595 = insertelement <4 x float> %1594, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112: ; preds = %wrapI.exit18.i62, %1227, %1318, %1342, %1406, %1472, %1569
  %.0.i.i111 = phi <4 x float> [ %1595, %1569 ], [ %1471, %1406 ], [ %1568, %1472 ], [ %1402, %1342 ], [ %1341, %1318 ], [ %1317, %1227 ], [ zeroinitializer, %wrapI.exit18.i62 ]
  %1596 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1126, i32 2
  %1597 = load i32, i32* %1596, align 4, !tbaa !21
  %1598 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1126, i32 3
  %1599 = load i32, i32* %1598, align 4, !tbaa !21
  %1600 = extractelement <2 x float> %uv, i32 0
  %1601 = sitofp i32 %1597 to float
  %1602 = fmul float %1600, %1601
  %1603 = extractelement <2 x float> %uv, i32 1
  %1604 = sitofp i32 %1599 to float
  %1605 = fmul float %1603, %1604
  %1606 = fptosi float %1602 to i32
  %1607 = fptosi float %1605 to i32
  %1608 = sitofp i32 %1606 to float
  %1609 = fsub float %1602, %1608
  %1610 = sitofp i32 %1607 to float
  %1611 = fsub float %1605, %1610
  %1612 = fcmp olt float %1609, 5.000000e-01
  br i1 %1612, label %1613, label %1616

; <label>:1613                                    ; preds = %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112
  %1614 = add nsw i32 %1606, -1
  %1615 = fadd float %1609, 5.000000e-01
  br label %1618

; <label>:1616                                    ; preds = %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit112
  %1617 = fadd float %1609, -5.000000e-01
  br label %1618

; <label>:1618                                    ; preds = %1616, %1613
  %fracU.0.i = phi float [ %1615, %1613 ], [ %1617, %1616 ]
  %iPixelU.0.i = phi i32 [ %1614, %1613 ], [ %1606, %1616 ]
  %1619 = fcmp olt float %1611, 5.000000e-01
  br i1 %1619, label %1620, label %1623

; <label>:1620                                    ; preds = %1618
  %1621 = add nsw i32 %1607, -1
  %1622 = fadd float %1611, 5.000000e-01
  br label %1625

; <label>:1623                                    ; preds = %1618
  %1624 = fadd float %1611, -5.000000e-01
  br label %1625

; <label>:1625                                    ; preds = %1623, %1620
  %fracV.0.i = phi float [ %1622, %1620 ], [ %1624, %1623 ]
  %iPixelV.0.i = phi i32 [ %1621, %1620 ], [ %1607, %1623 ]
  %1626 = fsub float 1.000000e+00, %fracU.0.i
  %1627 = fsub float 1.000000e+00, %fracV.0.i
  %1628 = fmul float %1626, %1627
  %1629 = fmul float %fracU.0.i, %1627
  %1630 = fmul float %1626, %fracV.0.i
  %1631 = fmul float %fracU.0.i, %fracV.0.i
  %1632 = add nsw i32 %iPixelU.0.i, 1
  switch i32 %21, label %wrapI.exit.i34 [
    i32 3, label %.thread.i.i30
    i32 6, label %1636
  ]

.thread.i.i30:                                    ; preds = %1625
  %1633 = srem i32 %1632, %1597
  %1634 = icmp slt i32 %1633, 0
  %1635 = select i1 %1634, i32 %1597, i32 0
  %..i.i29 = add nsw i32 %1635, %1633
  br label %wrapI.exit.i34

; <label>:1636                                    ; preds = %1625
  %1637 = shl nsw i32 %1597, 1
  %1638 = srem i32 %1632, %1637
  %1639 = icmp slt i32 %1638, 0
  %1640 = select i1 %1639, i32 %1637, i32 0
  %.3.i.i31 = add nsw i32 %1640, %1638
  %1641 = icmp slt i32 %.3.i.i31, %1597
  %1642 = sub nsw i32 %1637, %.3.i.i31
  %.3..i.i32 = select i1 %1641, i32 %.3.i.i31, i32 %1642
  br label %wrapI.exit.i34

wrapI.exit.i34:                                   ; preds = %1636, %.thread.i.i30, %1625
  %.2.i.i33 = phi i32 [ %.3..i.i32, %1636 ], [ %..i.i29, %.thread.i.i30 ], [ %1632, %1625 ]
  %1643 = add nsw i32 %1597, -1
  %1644 = icmp slt i32 %.2.i.i33, %1643
  %1645 = select i1 %1644, i32 %.2.i.i33, i32 %1643
  %1646 = icmp sgt i32 0, %1645
  %1647 = select i1 %1646, i32 0, i32 %1645
  %1648 = add nsw i32 %iPixelV.0.i, 1
  switch i32 %23, label %wrapI.exit6.i [
    i32 3, label %.thread.i2.i
    i32 6, label %1652
  ]

.thread.i2.i:                                     ; preds = %wrapI.exit.i34
  %1649 = srem i32 %1648, %1599
  %1650 = icmp slt i32 %1649, 0
  %1651 = select i1 %1650, i32 %1599, i32 0
  %..i1.i = add nsw i32 %1651, %1649
  br label %wrapI.exit6.i

; <label>:1652                                    ; preds = %wrapI.exit.i34
  %1653 = shl nsw i32 %1599, 1
  %1654 = srem i32 %1648, %1653
  %1655 = icmp slt i32 %1654, 0
  %1656 = select i1 %1655, i32 %1653, i32 0
  %.3.i3.i = add nsw i32 %1656, %1654
  %1657 = icmp slt i32 %.3.i3.i, %1599
  %1658 = sub nsw i32 %1653, %.3.i3.i
  %.3..i4.i = select i1 %1657, i32 %.3.i3.i, i32 %1658
  br label %wrapI.exit6.i

wrapI.exit6.i:                                    ; preds = %1652, %.thread.i2.i, %wrapI.exit.i34
  %.2.i5.i = phi i32 [ %.3..i4.i, %1652 ], [ %..i1.i, %.thread.i2.i ], [ %1648, %wrapI.exit.i34 ]
  %1659 = add nsw i32 %1599, -1
  %1660 = icmp slt i32 %.2.i5.i, %1659
  %1661 = select i1 %1660, i32 %.2.i5.i, i32 %1659
  %1662 = icmp sgt i32 0, %1661
  %1663 = select i1 %1662, i32 0, i32 %1661
  switch i32 %21, label %wrapI.exit12.i [
    i32 3, label %.thread.i8.i
    i32 6, label %1667
  ]

.thread.i8.i:                                     ; preds = %wrapI.exit6.i
  %1664 = srem i32 %iPixelU.0.i, %1597
  %1665 = icmp slt i32 %1664, 0
  %1666 = select i1 %1665, i32 %1597, i32 0
  %..i7.i = add nsw i32 %1666, %1664
  br label %wrapI.exit12.i

; <label>:1667                                    ; preds = %wrapI.exit6.i
  %1668 = shl nsw i32 %1597, 1
  %1669 = srem i32 %iPixelU.0.i, %1668
  %1670 = icmp slt i32 %1669, 0
  %1671 = select i1 %1670, i32 %1668, i32 0
  %.3.i9.i = add nsw i32 %1671, %1669
  %1672 = icmp slt i32 %.3.i9.i, %1597
  %1673 = sub nsw i32 %1668, %.3.i9.i
  %.3..i10.i = select i1 %1672, i32 %.3.i9.i, i32 %1673
  br label %wrapI.exit12.i

wrapI.exit12.i:                                   ; preds = %1667, %.thread.i8.i, %wrapI.exit6.i
  %.2.i11.i = phi i32 [ %.3..i10.i, %1667 ], [ %..i7.i, %.thread.i8.i ], [ %iPixelU.0.i, %wrapI.exit6.i ]
  %1674 = icmp slt i32 %.2.i11.i, %1643
  %1675 = select i1 %1674, i32 %.2.i11.i, i32 %1643
  %1676 = icmp sgt i32 0, %1675
  %1677 = select i1 %1676, i32 0, i32 %1675
  switch i32 %23, label %wrapI.exit18.i [
    i32 3, label %.thread.i14.i
    i32 6, label %1681
  ]

.thread.i14.i:                                    ; preds = %wrapI.exit12.i
  %1678 = srem i32 %iPixelV.0.i, %1599
  %1679 = icmp slt i32 %1678, 0
  %1680 = select i1 %1679, i32 %1599, i32 0
  %..i13.i = add nsw i32 %1680, %1678
  br label %wrapI.exit18.i

; <label>:1681                                    ; preds = %wrapI.exit12.i
  %1682 = shl nsw i32 %1599, 1
  %1683 = srem i32 %iPixelV.0.i, %1682
  %1684 = icmp slt i32 %1683, 0
  %1685 = select i1 %1684, i32 %1682, i32 0
  %.3.i15.i = add nsw i32 %1685, %1683
  %1686 = icmp slt i32 %.3.i15.i, %1599
  %1687 = sub nsw i32 %1682, %.3.i15.i
  %.3..i16.i = select i1 %1686, i32 %.3.i15.i, i32 %1687
  br label %wrapI.exit18.i

wrapI.exit18.i:                                   ; preds = %1681, %.thread.i14.i, %wrapI.exit12.i
  %.2.i17.i = phi i32 [ %.3..i16.i, %1681 ], [ %..i13.i, %.thread.i14.i ], [ %iPixelV.0.i, %wrapI.exit12.i ]
  %1688 = icmp slt i32 %.2.i17.i, %1659
  %1689 = select i1 %1688, i32 %.2.i17.i, i32 %1659
  %1690 = icmp sgt i32 0, %1689
  %1691 = select i1 %1690, i32 0, i32 %1689
  %1692 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1126, i32 0
  %1693 = load i8*, i8** %1692, align 4, !tbaa !22
  %1694 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 %1126, i32 1
  %1695 = load i32, i32* %1694, align 4, !tbaa !21
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit [
    i32 11, label %1696
    i32 8, label %1787
    i32 9, label %1811
    i32 10, label %1872
    i32 7, label %2038
  ]

; <label>:1696                                    ; preds = %wrapI.exit18.i
  %1697 = mul i32 %1695, %1691
  %1698 = shl nsw i32 %1677, 2
  %.sum.i.i.i.i = add i32 %1697, %1698
  %1699 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i.i.i.i
  %1700 = load i8, i8* %1699, align 1, !tbaa !19
  %1701 = uitofp i8 %1700 to float
  %1702 = insertelement <4 x float> undef, float %1701, i32 0
  %1703 = or i32 %1698, 1
  %.sum1.i.i.i.i = add i32 %1697, %1703
  %1704 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i.i.i.i
  %1705 = load i8, i8* %1704, align 1, !tbaa !19
  %1706 = uitofp i8 %1705 to float
  %1707 = insertelement <4 x float> %1702, float %1706, i32 1
  %1708 = or i32 %1698, 2
  %.sum2.i.i.i.i = add i32 %1697, %1708
  %1709 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i.i.i.i
  %1710 = load i8, i8* %1709, align 1, !tbaa !19
  %1711 = uitofp i8 %1710 to float
  %1712 = insertelement <4 x float> %1707, float %1711, i32 2
  %1713 = or i32 %1698, 3
  %.sum3.i.i.i.i = add i32 %1697, %1713
  %1714 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i.i.i.i
  %1715 = load i8, i8* %1714, align 1, !tbaa !19
  %1716 = uitofp i8 %1715 to float
  %1717 = insertelement <4 x float> %1712, float %1716, i32 3
  %1718 = shl nsw i32 %1647, 2
  %.sum.i9.i.i.i = add i32 %1697, %1718
  %1719 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i9.i.i.i
  %1720 = load i8, i8* %1719, align 1, !tbaa !19
  %1721 = uitofp i8 %1720 to float
  %1722 = insertelement <4 x float> undef, float %1721, i32 0
  %1723 = or i32 %1718, 1
  %.sum1.i10.i.i.i = add i32 %1697, %1723
  %1724 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i10.i.i.i
  %1725 = load i8, i8* %1724, align 1, !tbaa !19
  %1726 = uitofp i8 %1725 to float
  %1727 = insertelement <4 x float> %1722, float %1726, i32 1
  %1728 = or i32 %1718, 2
  %.sum2.i11.i.i.i = add i32 %1697, %1728
  %1729 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i11.i.i.i
  %1730 = load i8, i8* %1729, align 1, !tbaa !19
  %1731 = uitofp i8 %1730 to float
  %1732 = insertelement <4 x float> %1727, float %1731, i32 2
  %1733 = or i32 %1718, 3
  %.sum3.i12.i.i.i = add i32 %1697, %1733
  %1734 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i12.i.i.i
  %1735 = load i8, i8* %1734, align 1, !tbaa !19
  %1736 = uitofp i8 %1735 to float
  %1737 = insertelement <4 x float> %1732, float %1736, i32 3
  %1738 = mul i32 %1695, %1663
  %.sum.i5.i.i.i = add i32 %1738, %1698
  %1739 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i5.i.i.i
  %1740 = load i8, i8* %1739, align 1, !tbaa !19
  %1741 = uitofp i8 %1740 to float
  %1742 = insertelement <4 x float> undef, float %1741, i32 0
  %.sum1.i6.i.i.i = add i32 %1738, %1703
  %1743 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i6.i.i.i
  %1744 = load i8, i8* %1743, align 1, !tbaa !19
  %1745 = uitofp i8 %1744 to float
  %1746 = insertelement <4 x float> %1742, float %1745, i32 1
  %.sum2.i7.i.i.i = add i32 %1738, %1708
  %1747 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i7.i.i.i
  %1748 = load i8, i8* %1747, align 1, !tbaa !19
  %1749 = uitofp i8 %1748 to float
  %1750 = insertelement <4 x float> %1746, float %1749, i32 2
  %.sum3.i8.i.i.i = add i32 %1738, %1713
  %1751 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i8.i.i.i
  %1752 = load i8, i8* %1751, align 1, !tbaa !19
  %1753 = uitofp i8 %1752 to float
  %1754 = insertelement <4 x float> %1750, float %1753, i32 3
  %.sum.i1.i.i.i = add i32 %1738, %1718
  %1755 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i1.i.i.i
  %1756 = load i8, i8* %1755, align 1, !tbaa !19
  %1757 = uitofp i8 %1756 to float
  %1758 = insertelement <4 x float> undef, float %1757, i32 0
  %.sum1.i2.i.i.i = add i32 %1738, %1723
  %1759 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i2.i.i.i
  %1760 = load i8, i8* %1759, align 1, !tbaa !19
  %1761 = uitofp i8 %1760 to float
  %1762 = insertelement <4 x float> %1758, float %1761, i32 1
  %.sum2.i3.i.i.i = add i32 %1738, %1728
  %1763 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i3.i.i.i
  %1764 = load i8, i8* %1763, align 1, !tbaa !19
  %1765 = uitofp i8 %1764 to float
  %1766 = insertelement <4 x float> %1762, float %1765, i32 2
  %.sum3.i4.i.i.i = add i32 %1738, %1733
  %1767 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i4.i.i.i
  %1768 = load i8, i8* %1767, align 1, !tbaa !19
  %1769 = uitofp i8 %1768 to float
  %1770 = insertelement <4 x float> %1766, float %1769, i32 3
  %1771 = insertelement <4 x float> undef, float %1628, i32 0
  %1772 = shufflevector <4 x float> %1771, <4 x float> undef, <4 x i32> zeroinitializer
  %1773 = fmul <4 x float> %1772, %1717
  %1774 = insertelement <4 x float> undef, float %1629, i32 0
  %1775 = shufflevector <4 x float> %1774, <4 x float> undef, <4 x i32> zeroinitializer
  %1776 = fmul <4 x float> %1775, %1737
  %1777 = fadd <4 x float> %1773, %1776
  %1778 = insertelement <4 x float> undef, float %1630, i32 0
  %1779 = shufflevector <4 x float> %1778, <4 x float> undef, <4 x i32> zeroinitializer
  %1780 = fmul <4 x float> %1779, %1754
  %1781 = fadd <4 x float> %1777, %1780
  %1782 = insertelement <4 x float> undef, float %1631, i32 0
  %1783 = shufflevector <4 x float> %1782, <4 x float> undef, <4 x i32> zeroinitializer
  %1784 = fmul <4 x float> %1783, %1770
  %1785 = fadd <4 x float> %1781, %1784
  %1786 = fmul <4 x float> %1785, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:1787                                    ; preds = %wrapI.exit18.i
  %1788 = mul i32 %1695, %1691
  %.sum.i.i26.i.i = add i32 %1788, %1677
  %1789 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i.i26.i.i
  %1790 = load i8, i8* %1789, align 1, !tbaa !19
  %1791 = uitofp i8 %1790 to float
  %.sum.i3.i27.i.i = add i32 %1788, %1647
  %1792 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i3.i27.i.i
  %1793 = load i8, i8* %1792, align 1, !tbaa !19
  %1794 = uitofp i8 %1793 to float
  %1795 = mul i32 %1695, %1663
  %.sum.i2.i28.i.i = add i32 %1795, %1677
  %1796 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i2.i28.i.i
  %1797 = load i8, i8* %1796, align 1, !tbaa !19
  %1798 = uitofp i8 %1797 to float
  %.sum.i1.i29.i.i = add i32 %1795, %1647
  %1799 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i1.i29.i.i
  %1800 = load i8, i8* %1799, align 1, !tbaa !19
  %1801 = uitofp i8 %1800 to float
  %1802 = fmul float %1628, %1791
  %1803 = fmul float %1629, %1794
  %1804 = fadd float %1802, %1803
  %1805 = fmul float %1630, %1798
  %1806 = fadd float %1804, %1805
  %1807 = fmul float %1631, %1801
  %1808 = fadd float %1806, %1807
  %1809 = fmul float %1808, 0x3F70101020000000
  %1810 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %1809, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:1811                                    ; preds = %wrapI.exit18.i
  %1812 = mul i32 %1695, %1691
  %1813 = shl nsw i32 %1677, 1
  %.sum.i.i19.i.i = add i32 %1812, %1813
  %1814 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i.i19.i.i
  %1815 = load i8, i8* %1814, align 1, !tbaa !19
  %1816 = uitofp i8 %1815 to float
  %1817 = insertelement <2 x float> undef, float %1816, i32 0
  %1818 = or i32 %1813, 1
  %.sum1.i.i20.i.i = add i32 %1812, %1818
  %1819 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i.i20.i.i
  %1820 = load i8, i8* %1819, align 1, !tbaa !19
  %1821 = uitofp i8 %1820 to float
  %1822 = insertelement <2 x float> %1817, float %1821, i32 1
  %1823 = shl nsw i32 %1647, 1
  %.sum.i5.i21.i.i = add i32 %1812, %1823
  %1824 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i5.i21.i.i
  %1825 = load i8, i8* %1824, align 1, !tbaa !19
  %1826 = uitofp i8 %1825 to float
  %1827 = insertelement <2 x float> undef, float %1826, i32 0
  %1828 = or i32 %1823, 1
  %.sum1.i6.i22.i.i = add i32 %1812, %1828
  %1829 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i6.i22.i.i
  %1830 = load i8, i8* %1829, align 1, !tbaa !19
  %1831 = uitofp i8 %1830 to float
  %1832 = insertelement <2 x float> %1827, float %1831, i32 1
  %1833 = mul i32 %1695, %1663
  %.sum.i3.i23.i.i = add i32 %1833, %1813
  %1834 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i3.i23.i.i
  %1835 = load i8, i8* %1834, align 1, !tbaa !19
  %1836 = uitofp i8 %1835 to float
  %1837 = insertelement <2 x float> undef, float %1836, i32 0
  %.sum1.i4.i.i.i = add i32 %1833, %1818
  %1838 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i4.i.i.i
  %1839 = load i8, i8* %1838, align 1, !tbaa !19
  %1840 = uitofp i8 %1839 to float
  %1841 = insertelement <2 x float> %1837, float %1840, i32 1
  %.sum.i1.i24.i.i = add i32 %1833, %1823
  %1842 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i1.i24.i.i
  %1843 = load i8, i8* %1842, align 1, !tbaa !19
  %1844 = uitofp i8 %1843 to float
  %1845 = insertelement <2 x float> undef, float %1844, i32 0
  %.sum1.i2.i25.i.i = add i32 %1833, %1828
  %1846 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i2.i25.i.i
  %1847 = load i8, i8* %1846, align 1, !tbaa !19
  %1848 = uitofp i8 %1847 to float
  %1849 = insertelement <2 x float> %1845, float %1848, i32 1
  %1850 = insertelement <2 x float> undef, float %1628, i32 0
  %1851 = shufflevector <2 x float> %1850, <2 x float> undef, <2 x i32> zeroinitializer
  %1852 = fmul <2 x float> %1851, %1822
  %1853 = insertelement <2 x float> undef, float %1629, i32 0
  %1854 = shufflevector <2 x float> %1853, <2 x float> undef, <2 x i32> zeroinitializer
  %1855 = fmul <2 x float> %1854, %1832
  %1856 = fadd <2 x float> %1852, %1855
  %1857 = insertelement <2 x float> undef, float %1630, i32 0
  %1858 = shufflevector <2 x float> %1857, <2 x float> undef, <2 x i32> zeroinitializer
  %1859 = fmul <2 x float> %1858, %1841
  %1860 = fadd <2 x float> %1856, %1859
  %1861 = insertelement <2 x float> undef, float %1631, i32 0
  %1862 = shufflevector <2 x float> %1861, <2 x float> undef, <2 x i32> zeroinitializer
  %1863 = fmul <2 x float> %1862, %1849
  %1864 = fadd <2 x float> %1860, %1863
  %1865 = fmul <2 x float> %1864, <float 0x3F70101020000000, float 0x3F70101020000000>
  %1866 = extractelement <2 x float> %1865, i32 0
  %1867 = insertelement <4 x float> undef, float %1866, i32 0
  %1868 = insertelement <4 x float> %1867, float %1866, i32 1
  %1869 = insertelement <4 x float> %1868, float %1866, i32 2
  %1870 = extractelement <2 x float> %1865, i32 1
  %1871 = insertelement <4 x float> %1869, float %1870, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:1872                                    ; preds = %wrapI.exit18.i
  %1873 = icmp eq i32 %15, 13
  %1874 = mul i32 %1695, %1691
  br i1 %1873, label %1875, label %1941

; <label>:1875                                    ; preds = %1872
  %1876 = getelementptr inbounds i8, i8* %1693, i32 %1874
  %1877 = bitcast i8* %1876 to i16*
  %1878 = load i16, i16* %1877, align 2, !tbaa !70
  %1879 = zext i16 %1878 to i32
  %1880 = lshr i32 %1879, 11
  %1881 = shl nuw nsw i32 %1880, 3
  %1882 = lshr i32 %1879, 13
  %1883 = or i32 %1881, %1882
  %1884 = uitofp i32 %1883 to float
  %1885 = insertelement <3 x float> undef, float %1884, i32 0
  %1886 = lshr i32 %1879, 5
  %1887 = and i32 %1886, 63
  %1888 = shl nuw nsw i32 %1887, 2
  %1889 = lshr i32 %1887, 4
  %1890 = or i32 %1888, %1889
  %1891 = uitofp i32 %1890 to float
  %1892 = insertelement <3 x float> %1885, float %1891, i32 1
  %1893 = and i32 %1879, 31
  %1894 = shl nuw nsw i32 %1893, 3
  %1895 = lshr i32 %1893, 2
  %1896 = or i32 %1894, %1895
  %1897 = uitofp i32 %1896 to float
  %1898 = insertelement <3 x float> %1892, float %1897, i32 2
  %1899 = mul i32 %1695, %1663
  %1900 = getelementptr inbounds i8, i8* %1693, i32 %1899
  %1901 = bitcast i8* %1900 to i16*
  %1902 = load i16, i16* %1901, align 2, !tbaa !70
  %1903 = zext i16 %1902 to i32
  %1904 = lshr i32 %1903, 11
  %1905 = shl nuw nsw i32 %1904, 3
  %1906 = lshr i32 %1903, 13
  %1907 = or i32 %1905, %1906
  %1908 = uitofp i32 %1907 to float
  %1909 = insertelement <3 x float> undef, float %1908, i32 0
  %1910 = lshr i32 %1903, 5
  %1911 = and i32 %1910, 63
  %1912 = shl nuw nsw i32 %1911, 2
  %1913 = lshr i32 %1911, 4
  %1914 = or i32 %1912, %1913
  %1915 = uitofp i32 %1914 to float
  %1916 = insertelement <3 x float> %1909, float %1915, i32 1
  %1917 = and i32 %1903, 31
  %1918 = shl nuw nsw i32 %1917, 3
  %1919 = lshr i32 %1917, 2
  %1920 = or i32 %1918, %1919
  %1921 = uitofp i32 %1920 to float
  %1922 = insertelement <3 x float> %1916, float %1921, i32 2
  %1923 = insertelement <3 x float> undef, float %1628, i32 0
  %1924 = shufflevector <3 x float> %1923, <3 x float> undef, <3 x i32> zeroinitializer
  %1925 = fmul <3 x float> %1924, %1898
  %1926 = insertelement <3 x float> undef, float %1629, i32 0
  %1927 = shufflevector <3 x float> %1926, <3 x float> undef, <3 x i32> zeroinitializer
  %1928 = fmul <3 x float> %1927, %1898
  %1929 = fadd <3 x float> %1925, %1928
  %1930 = insertelement <3 x float> undef, float %1630, i32 0
  %1931 = shufflevector <3 x float> %1930, <3 x float> undef, <3 x i32> zeroinitializer
  %1932 = fmul <3 x float> %1931, %1922
  %1933 = fadd <3 x float> %1929, %1932
  %1934 = insertelement <3 x float> undef, float %1631, i32 0
  %1935 = shufflevector <3 x float> %1934, <3 x float> undef, <3 x i32> zeroinitializer
  %1936 = fmul <3 x float> %1935, %1922
  %1937 = fadd <3 x float> %1936, %1933
  %1938 = fmul <3 x float> %1937, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %1939 = shufflevector <3 x float> %1938, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %1940 = insertelement <4 x float> %1939, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:1941                                    ; preds = %1872
  %1942 = shl nsw i32 %1677, 2
  %.sum.i.i3.i.i = add i32 %1874, %1942
  %1943 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i.i3.i.i
  %1944 = load i8, i8* %1943, align 1, !tbaa !19
  %1945 = uitofp i8 %1944 to float
  %1946 = insertelement <4 x float> undef, float %1945, i32 0
  %1947 = or i32 %1942, 1
  %.sum1.i.i4.i.i = add i32 %1874, %1947
  %1948 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i.i4.i.i
  %1949 = load i8, i8* %1948, align 1, !tbaa !19
  %1950 = uitofp i8 %1949 to float
  %1951 = insertelement <4 x float> %1946, float %1950, i32 1
  %1952 = or i32 %1942, 2
  %.sum2.i.i5.i.i = add i32 %1874, %1952
  %1953 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i.i5.i.i
  %1954 = load i8, i8* %1953, align 1, !tbaa !19
  %1955 = uitofp i8 %1954 to float
  %1956 = insertelement <4 x float> %1951, float %1955, i32 2
  %1957 = or i32 %1942, 3
  %.sum3.i.i6.i.i = add i32 %1874, %1957
  %1958 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i.i6.i.i
  %1959 = load i8, i8* %1958, align 1, !tbaa !19
  %1960 = uitofp i8 %1959 to float
  %1961 = insertelement <4 x float> %1956, float %1960, i32 3
  %1962 = shl nsw i32 %1647, 2
  %.sum.i9.i7.i.i = add i32 %1874, %1962
  %1963 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i9.i7.i.i
  %1964 = load i8, i8* %1963, align 1, !tbaa !19
  %1965 = uitofp i8 %1964 to float
  %1966 = insertelement <4 x float> undef, float %1965, i32 0
  %1967 = or i32 %1962, 1
  %.sum1.i10.i8.i.i = add i32 %1874, %1967
  %1968 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i10.i8.i.i
  %1969 = load i8, i8* %1968, align 1, !tbaa !19
  %1970 = uitofp i8 %1969 to float
  %1971 = insertelement <4 x float> %1966, float %1970, i32 1
  %1972 = or i32 %1962, 2
  %.sum2.i11.i9.i.i = add i32 %1874, %1972
  %1973 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i11.i9.i.i
  %1974 = load i8, i8* %1973, align 1, !tbaa !19
  %1975 = uitofp i8 %1974 to float
  %1976 = insertelement <4 x float> %1971, float %1975, i32 2
  %1977 = or i32 %1962, 3
  %.sum3.i12.i10.i.i = add i32 %1874, %1977
  %1978 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i12.i10.i.i
  %1979 = load i8, i8* %1978, align 1, !tbaa !19
  %1980 = uitofp i8 %1979 to float
  %1981 = insertelement <4 x float> %1976, float %1980, i32 3
  %1982 = mul i32 %1695, %1663
  %.sum.i5.i11.i.i = add i32 %1982, %1942
  %1983 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i5.i11.i.i
  %1984 = load i8, i8* %1983, align 1, !tbaa !19
  %1985 = uitofp i8 %1984 to float
  %1986 = insertelement <4 x float> undef, float %1985, i32 0
  %.sum1.i6.i12.i.i = add i32 %1982, %1947
  %1987 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i6.i12.i.i
  %1988 = load i8, i8* %1987, align 1, !tbaa !19
  %1989 = uitofp i8 %1988 to float
  %1990 = insertelement <4 x float> %1986, float %1989, i32 1
  %.sum2.i7.i13.i.i = add i32 %1982, %1952
  %1991 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i7.i13.i.i
  %1992 = load i8, i8* %1991, align 1, !tbaa !19
  %1993 = uitofp i8 %1992 to float
  %1994 = insertelement <4 x float> %1990, float %1993, i32 2
  %.sum3.i8.i14.i.i = add i32 %1982, %1957
  %1995 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i8.i14.i.i
  %1996 = load i8, i8* %1995, align 1, !tbaa !19
  %1997 = uitofp i8 %1996 to float
  %1998 = insertelement <4 x float> %1994, float %1997, i32 3
  %.sum.i1.i15.i.i = add i32 %1982, %1962
  %1999 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i1.i15.i.i
  %2000 = load i8, i8* %1999, align 1, !tbaa !19
  %2001 = uitofp i8 %2000 to float
  %2002 = insertelement <4 x float> undef, float %2001, i32 0
  %.sum1.i2.i16.i.i = add i32 %1982, %1967
  %2003 = getelementptr inbounds i8, i8* %1693, i32 %.sum1.i2.i16.i.i
  %2004 = load i8, i8* %2003, align 1, !tbaa !19
  %2005 = uitofp i8 %2004 to float
  %2006 = insertelement <4 x float> %2002, float %2005, i32 1
  %.sum2.i3.i17.i.i = add i32 %1982, %1972
  %2007 = getelementptr inbounds i8, i8* %1693, i32 %.sum2.i3.i17.i.i
  %2008 = load i8, i8* %2007, align 1, !tbaa !19
  %2009 = uitofp i8 %2008 to float
  %2010 = insertelement <4 x float> %2006, float %2009, i32 2
  %.sum3.i4.i18.i.i = add i32 %1982, %1977
  %2011 = getelementptr inbounds i8, i8* %1693, i32 %.sum3.i4.i18.i.i
  %2012 = load i8, i8* %2011, align 1, !tbaa !19
  %2013 = uitofp i8 %2012 to float
  %2014 = insertelement <4 x float> %2010, float %2013, i32 3
  %2015 = insertelement <4 x float> undef, float %1628, i32 0
  %2016 = shufflevector <4 x float> %2015, <4 x float> undef, <4 x i32> zeroinitializer
  %2017 = fmul <4 x float> %2016, %1961
  %2018 = insertelement <4 x float> undef, float %1629, i32 0
  %2019 = shufflevector <4 x float> %2018, <4 x float> undef, <4 x i32> zeroinitializer
  %2020 = fmul <4 x float> %2019, %1981
  %2021 = fadd <4 x float> %2017, %2020
  %2022 = insertelement <4 x float> undef, float %1630, i32 0
  %2023 = shufflevector <4 x float> %2022, <4 x float> undef, <4 x i32> zeroinitializer
  %2024 = fmul <4 x float> %2023, %1998
  %2025 = fadd <4 x float> %2021, %2024
  %2026 = insertelement <4 x float> undef, float %1631, i32 0
  %2027 = shufflevector <4 x float> %2026, <4 x float> undef, <4 x i32> zeroinitializer
  %2028 = fmul <4 x float> %2027, %2014
  %2029 = fadd <4 x float> %2025, %2028
  %2030 = fmul <4 x float> %2029, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %2031 = extractelement <4 x float> %2030, i32 0
  %2032 = insertelement <4 x float> undef, float %2031, i32 0
  %2033 = extractelement <4 x float> %2030, i32 1
  %2034 = insertelement <4 x float> %2032, float %2033, i32 1
  %2035 = extractelement <4 x float> %2030, i32 2
  %2036 = insertelement <4 x float> %2034, float %2035, i32 2
  %2037 = insertelement <4 x float> %2036, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:2038                                    ; preds = %wrapI.exit18.i
  %2039 = mul i32 %1695, %1691
  %.sum.i.i1.i.i = add i32 %2039, %1677
  %2040 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i.i1.i.i
  %2041 = load i8, i8* %2040, align 1, !tbaa !19
  %2042 = uitofp i8 %2041 to float
  %.sum.i3.i.i.i = add i32 %2039, %1647
  %2043 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i3.i.i.i
  %2044 = load i8, i8* %2043, align 1, !tbaa !19
  %2045 = uitofp i8 %2044 to float
  %2046 = mul i32 %1695, %1663
  %.sum.i2.i.i.i = add i32 %2046, %1677
  %2047 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i2.i.i.i
  %2048 = load i8, i8* %2047, align 1, !tbaa !19
  %2049 = uitofp i8 %2048 to float
  %.sum.i1.i2.i.i = add i32 %2046, %1647
  %2050 = getelementptr inbounds i8, i8* %1693, i32 %.sum.i1.i2.i.i
  %2051 = load i8, i8* %2050, align 1, !tbaa !19
  %2052 = uitofp i8 %2051 to float
  %2053 = fmul float %1628, %2042
  %2054 = fmul float %1629, %2045
  %2055 = fadd float %2053, %2054
  %2056 = fmul float %1630, %2049
  %2057 = fadd float %2055, %2056
  %2058 = fmul float %1631, %2052
  %2059 = fadd float %2057, %2058
  %2060 = fmul float %2059, 0x3F70101020000000
  %2061 = insertelement <4 x float> undef, float %2060, i32 0
  %2062 = insertelement <4 x float> %2061, float %2060, i32 1
  %2063 = insertelement <4 x float> %2062, float %2060, i32 2
  %2064 = insertelement <4 x float> %2063, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit: ; preds = %wrapI.exit18.i, %1696, %1787, %1811, %1875, %1941, %2038
  %.0.i.i = phi <4 x float> [ %2064, %2038 ], [ %1940, %1875 ], [ %2037, %1941 ], [ %1871, %1811 ], [ %1810, %1787 ], [ %1786, %1696 ], [ zeroinitializer, %wrapI.exit18.i ]
  %2065 = uitofp i32 %1124 to float
  %2066 = fsub float %lod, %2065
  %2067 = fsub float 1.000000e+00, %2066
  %2068 = insertelement <4 x float> undef, float %2067, i32 0
  %2069 = shufflevector <4 x float> %2068, <4 x float> undef, <4 x i32> zeroinitializer
  %2070 = fmul <4 x float> %.0.i.i111, %2069
  %2071 = insertelement <4 x float> undef, float %2066, i32 0
  %2072 = shufflevector <4 x float> %2071, <4 x float> undef, <4 x i32> zeroinitializer
  %2073 = fmul <4 x float> %.0.i.i, %2072
  %2074 = fadd <4 x float> %2073, %2070
  br label %2207

; <label>:2075                                    ; preds = %634
  %2076 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %2077 = load i32, i32* %2076, align 4, !tbaa !21
  %2078 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %2079 = load i32, i32* %2078, align 4, !tbaa !21
  %2080 = sitofp i32 %2077 to float
  %2081 = insertelement <2 x float> undef, float %2080, i32 0
  %2082 = sitofp i32 %2079 to float
  %2083 = insertelement <2 x float> %2081, float %2082, i32 1
  %2084 = fmul <2 x float> %2083, %uv
  %2085 = fptosi <2 x float> %2084 to <2 x i32>
  %2086 = extractelement <2 x i32> %2085, i32 0
  switch i32 %21, label %wrapI.exit.i6 [
    i32 3, label %.thread.i.i2
    i32 6, label %2090
  ]

.thread.i.i2:                                     ; preds = %2075
  %2087 = srem i32 %2086, %2077
  %2088 = icmp slt i32 %2087, 0
  %2089 = select i1 %2088, i32 %2077, i32 0
  %..i.i1 = add nsw i32 %2089, %2087
  br label %wrapI.exit.i6

; <label>:2090                                    ; preds = %2075
  %2091 = shl nsw i32 %2077, 1
  %2092 = srem i32 %2086, %2091
  %2093 = icmp slt i32 %2092, 0
  %2094 = select i1 %2093, i32 %2091, i32 0
  %.3.i.i3 = add nsw i32 %2094, %2092
  %2095 = icmp slt i32 %.3.i.i3, %2077
  %2096 = sub nsw i32 %2091, %.3.i.i3
  %.3..i.i4 = select i1 %2095, i32 %.3.i.i3, i32 %2096
  br label %wrapI.exit.i6

wrapI.exit.i6:                                    ; preds = %2090, %.thread.i.i2, %2075
  %.2.i.i5 = phi i32 [ %.3..i.i4, %2090 ], [ %..i.i1, %.thread.i.i2 ], [ %2086, %2075 ]
  %2097 = add nsw i32 %2077, -1
  %2098 = icmp slt i32 %.2.i.i5, %2097
  %2099 = select i1 %2098, i32 %.2.i.i5, i32 %2097
  %2100 = icmp sgt i32 0, %2099
  %2101 = select i1 %2100, i32 0, i32 %2099
  %2102 = extractelement <2 x i32> %2085, i32 1
  switch i32 %23, label %wrapI.exit7.i16 [
    i32 3, label %.thread.i3.i8
    i32 6, label %2106
  ]

.thread.i3.i8:                                    ; preds = %wrapI.exit.i6
  %2103 = srem i32 %2102, %2079
  %2104 = icmp slt i32 %2103, 0
  %2105 = select i1 %2104, i32 %2079, i32 0
  %..i2.i7 = add nsw i32 %2105, %2103
  br label %wrapI.exit7.i16

; <label>:2106                                    ; preds = %wrapI.exit.i6
  %2107 = shl nsw i32 %2079, 1
  %2108 = srem i32 %2102, %2107
  %2109 = icmp slt i32 %2108, 0
  %2110 = select i1 %2109, i32 %2107, i32 0
  %.3.i4.i9 = add nsw i32 %2110, %2108
  %2111 = icmp slt i32 %.3.i4.i9, %2079
  %2112 = sub nsw i32 %2107, %.3.i4.i9
  %.3..i5.i10 = select i1 %2111, i32 %.3.i4.i9, i32 %2112
  br label %wrapI.exit7.i16

wrapI.exit7.i16:                                  ; preds = %2106, %.thread.i3.i8, %wrapI.exit.i6
  %.2.i6.i11 = phi i32 [ %.3..i5.i10, %2106 ], [ %..i2.i7, %.thread.i3.i8 ], [ %2102, %wrapI.exit.i6 ]
  %2113 = add nsw i32 %2079, -1
  %2114 = icmp slt i32 %.2.i6.i11, %2113
  %2115 = select i1 %2114, i32 %.2.i6.i11, i32 %2113
  %2116 = icmp sgt i32 0, %2115
  %2117 = select i1 %2116, i32 0, i32 %2115
  %alloc.idx.i12 = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %alloc.idx.val.i13 = load i8*, i8** %alloc.idx.i12, align 4, !tbaa !22
  %alloc.idx1.i14 = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %alloc.idx1.val.i15 = load i32, i32* %alloc.idx1.i14, align 4, !tbaa !21
  switch i32 %13, label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28 [
    i32 11, label %2118
    i32 8, label %2140
    i32 9, label %2146
    i32 10, label %2161
  ]

; <label>:2118                                    ; preds = %wrapI.exit7.i16
  %2119 = mul i32 %alloc.idx1.val.i15, %2117
  %2120 = shl nsw i32 %2101, 2
  %.sum.i.i.i17 = add i32 %2119, %2120
  %2121 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum.i.i.i17
  %2122 = load i8, i8* %2121, align 1, !tbaa !19
  %2123 = uitofp i8 %2122 to float
  %2124 = insertelement <4 x float> undef, float %2123, i32 0
  %2125 = or i32 %2120, 1
  %.sum1.i.i.i18 = add i32 %2119, %2125
  %2126 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum1.i.i.i18
  %2127 = load i8, i8* %2126, align 1, !tbaa !19
  %2128 = uitofp i8 %2127 to float
  %2129 = insertelement <4 x float> %2124, float %2128, i32 1
  %2130 = or i32 %2120, 2
  %.sum2.i.i.i19 = add i32 %2119, %2130
  %2131 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum2.i.i.i19
  %2132 = load i8, i8* %2131, align 1, !tbaa !19
  %2133 = uitofp i8 %2132 to float
  %2134 = insertelement <4 x float> %2129, float %2133, i32 2
  %2135 = or i32 %2120, 3
  %.sum3.i.i.i20 = add i32 %2119, %2135
  %2136 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum3.i.i.i20
  %2137 = load i8, i8* %2136, align 1, !tbaa !19
  %2138 = uitofp i8 %2137 to float
  %2139 = insertelement <4 x float> %2134, float %2138, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28

; <label>:2140                                    ; preds = %wrapI.exit7.i16
  %2141 = mul i32 %alloc.idx1.val.i15, %2117
  %.sum.i6.i.i21 = add i32 %2141, %2101
  %2142 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum.i6.i.i21
  %2143 = load i8, i8* %2142, align 1, !tbaa !19
  %2144 = uitofp i8 %2143 to float
  %2145 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %2144, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28

; <label>:2146                                    ; preds = %wrapI.exit7.i16
  %2147 = mul i32 %alloc.idx1.val.i15, %2117
  %2148 = shl nsw i32 %2101, 1
  %.sum.i4.i.i22 = add i32 %2147, %2148
  %2149 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum.i4.i.i22
  %2150 = load i8, i8* %2149, align 1, !tbaa !19
  %2151 = uitofp i8 %2150 to float
  %2152 = insertelement <2 x float> undef, float %2151, i32 0
  %2153 = or i32 %2148, 1
  %.sum1.i5.i.i23 = add i32 %2147, %2153
  %2154 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum1.i5.i.i23
  %2155 = load i8, i8* %2154, align 1, !tbaa !19
  %2156 = uitofp i8 %2155 to float
  %2157 = insertelement <2 x float> %2152, float %2156, i32 1
  %2158 = shufflevector <2 x float> %2157, <2 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 1>
  %2159 = shufflevector <2 x float> %2157, <2 x float> undef, <4 x i32> <i32 0, i32 0, i32 undef, i32 undef>
  %2160 = shufflevector <4 x float> %2158, <4 x float> %2159, <4 x i32> <i32 4, i32 5, i32 2, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28

; <label>:2161                                    ; preds = %wrapI.exit7.i16
  %2162 = icmp eq i32 %15, 13
  %2163 = mul i32 %alloc.idx1.val.i15, %2117
  br i1 %2162, label %2164, label %2189

; <label>:2164                                    ; preds = %2161
  %2165 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %2163
  %2166 = bitcast i8* %2165 to i16*
  %2167 = load i16, i16* %2166, align 2, !tbaa !70
  %2168 = zext i16 %2167 to i32
  %2169 = lshr i32 %2168, 11
  %2170 = shl nuw nsw i32 %2169, 3
  %2171 = lshr i32 %2168, 13
  %2172 = or i32 %2170, %2171
  %2173 = uitofp i32 %2172 to float
  %2174 = insertelement <4 x float> undef, float %2173, i32 0
  %2175 = lshr i32 %2168, 5
  %2176 = and i32 %2175, 63
  %2177 = shl nuw nsw i32 %2176, 2
  %2178 = lshr i32 %2176, 4
  %2179 = or i32 %2177, %2178
  %2180 = uitofp i32 %2179 to float
  %2181 = insertelement <4 x float> %2174, float %2180, i32 1
  %2182 = and i32 %2168, 31
  %2183 = shl nuw nsw i32 %2182, 3
  %2184 = lshr i32 %2182, 2
  %2185 = or i32 %2183, %2184
  %2186 = uitofp i32 %2185 to float
  %2187 = insertelement <4 x float> %2181, float %2186, i32 2
  %2188 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %2187, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28

; <label>:2189                                    ; preds = %2161
  %2190 = shl nsw i32 %2101, 2
  %.sum.i1.i.i24 = add i32 %2163, %2190
  %2191 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum.i1.i.i24
  %2192 = load i8, i8* %2191, align 1, !tbaa !19
  %2193 = uitofp i8 %2192 to float
  %2194 = insertelement <4 x float> undef, float %2193, i32 0
  %2195 = or i32 %2190, 1
  %.sum1.i2.i.i25 = add i32 %2163, %2195
  %2196 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum1.i2.i.i25
  %2197 = load i8, i8* %2196, align 1, !tbaa !19
  %2198 = uitofp i8 %2197 to float
  %2199 = insertelement <4 x float> %2194, float %2198, i32 1
  %2200 = or i32 %2190, 2
  %.sum2.i3.i.i26 = add i32 %2163, %2200
  %2201 = getelementptr inbounds i8, i8* %alloc.idx.val.i13, i32 %.sum2.i3.i.i26
  %2202 = load i8, i8* %2201, align 1, !tbaa !19
  %2203 = uitofp i8 %2202 to float
  %2204 = insertelement <4 x float> %2199, float %2203, i32 2
  %2205 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %2204, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28

_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28: ; preds = %wrapI.exit7.i16, %2118, %2140, %2146, %2164, %2189
  %result.0.i.i27 = phi <4 x float> [ <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 2.550000e+02>, %wrapI.exit7.i16 ], [ %2188, %2164 ], [ %2205, %2189 ], [ %2160, %2146 ], [ %2145, %2140 ], [ %2139, %2118 ]
  %2206 = fmul <4 x float> %result.0.i.i27, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %2207

; <label>:2207                                    ; preds = %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit, %0
  %.0 = phi <4 x float> [ %163, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit ], [ %.0.i.i267, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit268 ], [ %.0.i.i189, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit190 ], [ %2074, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit ], [ %2206, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit28 ], [ zeroinitializer, %0 ]
  ret <4 x float> %.0
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z8rsSample13rs_allocation10rs_samplerDv2_f([1 x i32] %a.coerce, [1 x i32] %s.coerce, <2 x float> %uv) #4 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = extractvalue [1 x i32] %s.coerce, 0
  %3 = inttoptr i32 %1 to %struct.Allocation*
  %4 = inttoptr i32 %2 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 0
  %6 = load i8*, i8** %5, align 4, !tbaa !22
  %7 = getelementptr inbounds i8, i8* %6, i32 36
  %8 = bitcast i8* %7 to i8**
  %9 = load i8*, i8** %8, align 4, !tbaa !22
  %10 = getelementptr inbounds i8, i8* %9, i32 36
  %11 = getelementptr inbounds i8, i8* %9, i32 40
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12, align 4, !tbaa !19
  %14 = bitcast i8* %10 to i32*
  %15 = load i32, i32* %14, align 4, !tbaa !19
  %16 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 2
  %17 = load i32, i32* %16, align 4, !tbaa !19
  %18 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 3
  %19 = load i32, i32* %18, align 4, !tbaa !19
  %20 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 1, i32 1
  %21 = load i32, i32* %20, align 4, !tbaa !21
  %22 = and i32 %21, 2
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %630, label %24

; <label>:24                                      ; preds = %0
  %25 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 0
  %26 = load i32, i32* %25, align 4, !tbaa !19
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %160

; <label>:28                                      ; preds = %24
  %29 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %30 = load i32, i32* %29, align 4, !tbaa !21
  %31 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %32 = load i32, i32* %31, align 4, !tbaa !21
  %33 = sitofp i32 %30 to float
  %34 = insertelement <2 x float> undef, float %33, i32 0
  %35 = sitofp i32 %32 to float
  %36 = insertelement <2 x float> %34, float %35, i32 1
  %37 = fmul <2 x float> %36, %uv
  %38 = fptosi <2 x float> %37 to <2 x i32>
  %39 = extractelement <2 x i32> %38, i32 0
  switch i32 %17, label %wrapI.exit.i [
    i32 3, label %.thread.i.i
    i32 6, label %43
  ]

.thread.i.i:                                      ; preds = %28
  %40 = srem i32 %39, %30
  %41 = icmp slt i32 %40, 0
  %42 = select i1 %41, i32 %30, i32 0
  %..i.i = add nsw i32 %42, %40
  br label %wrapI.exit.i

; <label>:43                                      ; preds = %28
  %44 = shl nsw i32 %30, 1
  %45 = srem i32 %39, %44
  %46 = icmp slt i32 %45, 0
  %47 = select i1 %46, i32 %44, i32 0
  %.3.i.i = add nsw i32 %47, %45
  %48 = icmp slt i32 %.3.i.i, %30
  %49 = sub nsw i32 %44, %.3.i.i
  %.3..i.i = select i1 %48, i32 %.3.i.i, i32 %49
  br label %wrapI.exit.i

wrapI.exit.i:                                     ; preds = %43, %.thread.i.i, %28
  %.2.i.i = phi i32 [ %.3..i.i, %43 ], [ %..i.i, %.thread.i.i ], [ %39, %28 ]
  %50 = add nsw i32 %30, -1
  %51 = icmp slt i32 %.2.i.i, %50
  %52 = select i1 %51, i32 %.2.i.i, i32 %50
  %53 = icmp sgt i32 0, %52
  %54 = select i1 %53, i32 0, i32 %52
  %55 = extractelement <2 x i32> %38, i32 1
  switch i32 %19, label %wrapI.exit7.i [
    i32 3, label %.thread.i3.i
    i32 6, label %59
  ]

.thread.i3.i:                                     ; preds = %wrapI.exit.i
  %56 = srem i32 %55, %32
  %57 = icmp slt i32 %56, 0
  %58 = select i1 %57, i32 %32, i32 0
  %..i2.i = add nsw i32 %58, %56
  br label %wrapI.exit7.i

; <label>:59                                      ; preds = %wrapI.exit.i
  %60 = shl nsw i32 %32, 1
  %61 = srem i32 %55, %60
  %62 = icmp slt i32 %61, 0
  %63 = select i1 %62, i32 %60, i32 0
  %.3.i4.i = add nsw i32 %63, %61
  %64 = icmp slt i32 %.3.i4.i, %32
  %65 = sub nsw i32 %60, %.3.i4.i
  %.3..i5.i = select i1 %64, i32 %.3.i4.i, i32 %65
  br label %wrapI.exit7.i

wrapI.exit7.i:                                    ; preds = %59, %.thread.i3.i, %wrapI.exit.i
  %.2.i6.i = phi i32 [ %.3..i5.i, %59 ], [ %..i2.i, %.thread.i3.i ], [ %55, %wrapI.exit.i ]
  %66 = add nsw i32 %32, -1
  %67 = icmp slt i32 %.2.i6.i, %66
  %68 = select i1 %67, i32 %.2.i6.i, i32 %66
  %69 = icmp sgt i32 0, %68
  %70 = select i1 %69, i32 0, i32 %68
  %alloc.idx.i = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %alloc.idx.val.i = load i8*, i8** %alloc.idx.i, align 4, !tbaa !22
  %alloc.idx1.i = getelementptr %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %alloc.idx1.val.i = load i32, i32* %alloc.idx1.i, align 4, !tbaa !21
  switch i32 %13, label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit [
    i32 11, label %71
    i32 8, label %93
    i32 9, label %99
    i32 10, label %114
  ]

; <label>:71                                      ; preds = %wrapI.exit7.i
  %72 = mul i32 %alloc.idx1.val.i, %70
  %73 = shl nsw i32 %54, 2
  %.sum.i.i.i = add i32 %72, %73
  %74 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i.i.i
  %75 = load i8, i8* %74, align 1, !tbaa !19
  %76 = uitofp i8 %75 to float
  %77 = insertelement <4 x float> undef, float %76, i32 0
  %78 = or i32 %73, 1
  %.sum1.i.i.i = add i32 %72, %78
  %79 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum1.i.i.i
  %80 = load i8, i8* %79, align 1, !tbaa !19
  %81 = uitofp i8 %80 to float
  %82 = insertelement <4 x float> %77, float %81, i32 1
  %83 = or i32 %73, 2
  %.sum2.i.i.i = add i32 %72, %83
  %84 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum2.i.i.i
  %85 = load i8, i8* %84, align 1, !tbaa !19
  %86 = uitofp i8 %85 to float
  %87 = insertelement <4 x float> %82, float %86, i32 2
  %88 = or i32 %73, 3
  %.sum3.i.i.i = add i32 %72, %88
  %89 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum3.i.i.i
  %90 = load i8, i8* %89, align 1, !tbaa !19
  %91 = uitofp i8 %90 to float
  %92 = insertelement <4 x float> %87, float %91, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:93                                      ; preds = %wrapI.exit7.i
  %94 = mul i32 %alloc.idx1.val.i, %70
  %.sum.i6.i.i = add i32 %94, %54
  %95 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i6.i.i
  %96 = load i8, i8* %95, align 1, !tbaa !19
  %97 = uitofp i8 %96 to float
  %98 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %97, i32 3
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:99                                      ; preds = %wrapI.exit7.i
  %100 = mul i32 %alloc.idx1.val.i, %70
  %101 = shl nsw i32 %54, 1
  %.sum.i4.i.i = add i32 %100, %101
  %102 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i4.i.i
  %103 = load i8, i8* %102, align 1, !tbaa !19
  %104 = uitofp i8 %103 to float
  %105 = insertelement <2 x float> undef, float %104, i32 0
  %106 = or i32 %101, 1
  %.sum1.i5.i.i = add i32 %100, %106
  %107 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum1.i5.i.i
  %108 = load i8, i8* %107, align 1, !tbaa !19
  %109 = uitofp i8 %108 to float
  %110 = insertelement <2 x float> %105, float %109, i32 1
  %111 = shufflevector <2 x float> %110, <2 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 1>
  %112 = shufflevector <2 x float> %110, <2 x float> undef, <4 x i32> <i32 0, i32 0, i32 undef, i32 undef>
  %113 = shufflevector <4 x float> %111, <4 x float> %112, <4 x i32> <i32 4, i32 5, i32 2, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:114                                     ; preds = %wrapI.exit7.i
  %115 = icmp eq i32 %15, 13
  %116 = mul i32 %alloc.idx1.val.i, %70
  br i1 %115, label %117, label %142

; <label>:117                                     ; preds = %114
  %118 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %116
  %119 = bitcast i8* %118 to i16*
  %120 = load i16, i16* %119, align 2, !tbaa !70
  %121 = zext i16 %120 to i32
  %122 = lshr i32 %121, 11
  %123 = shl nuw nsw i32 %122, 3
  %124 = lshr i32 %121, 13
  %125 = or i32 %123, %124
  %126 = uitofp i32 %125 to float
  %127 = insertelement <4 x float> undef, float %126, i32 0
  %128 = lshr i32 %121, 5
  %129 = and i32 %128, 63
  %130 = shl nuw nsw i32 %129, 2
  %131 = lshr i32 %129, 4
  %132 = or i32 %130, %131
  %133 = uitofp i32 %132 to float
  %134 = insertelement <4 x float> %127, float %133, i32 1
  %135 = and i32 %121, 31
  %136 = shl nuw nsw i32 %135, 3
  %137 = lshr i32 %135, 2
  %138 = or i32 %136, %137
  %139 = uitofp i32 %138 to float
  %140 = insertelement <4 x float> %134, float %139, i32 2
  %141 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %140, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:142                                     ; preds = %114
  %143 = shl nsw i32 %54, 2
  %.sum.i1.i.i = add i32 %116, %143
  %144 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum.i1.i.i
  %145 = load i8, i8* %144, align 1, !tbaa !19
  %146 = uitofp i8 %145 to float
  %147 = insertelement <4 x float> undef, float %146, i32 0
  %148 = or i32 %143, 1
  %.sum1.i2.i.i = add i32 %116, %148
  %149 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum1.i2.i.i
  %150 = load i8, i8* %149, align 1, !tbaa !19
  %151 = uitofp i8 %150 to float
  %152 = insertelement <4 x float> %147, float %151, i32 1
  %153 = or i32 %143, 2
  %.sum2.i3.i.i = add i32 %116, %153
  %154 = getelementptr inbounds i8, i8* %alloc.idx.val.i, i32 %.sum2.i3.i.i
  %155 = load i8, i8* %154, align 1, !tbaa !19
  %156 = uitofp i8 %155 to float
  %157 = insertelement <4 x float> %152, float %156, i32 2
  %158 = shufflevector <4 x float> <float undef, float undef, float undef, float 2.550000e+02>, <4 x float> %157, <4 x i32> <i32 4, i32 5, i32 6, i32 3>
  br label %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit: ; preds = %wrapI.exit7.i, %71, %93, %99, %117, %142
  %result.0.i.i = phi <4 x float> [ <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 2.550000e+02>, %wrapI.exit7.i ], [ %141, %117 ], [ %158, %142 ], [ %113, %99 ], [ %98, %93 ], [ %92, %71 ]
  %159 = fmul <4 x float> %result.0.i.i, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %630

; <label>:160                                     ; preds = %24
  %161 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 2
  %162 = load i32, i32* %161, align 4, !tbaa !21
  %163 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %164 = load i32, i32* %163, align 4, !tbaa !21
  %165 = extractelement <2 x float> %uv, i32 0
  %166 = sitofp i32 %162 to float
  %167 = fmul float %165, %166
  %168 = extractelement <2 x float> %uv, i32 1
  %169 = sitofp i32 %164 to float
  %170 = fmul float %168, %169
  %171 = fptosi float %167 to i32
  %172 = fptosi float %170 to i32
  %173 = sitofp i32 %171 to float
  %174 = fsub float %167, %173
  %175 = sitofp i32 %172 to float
  %176 = fsub float %170, %175
  %177 = fcmp olt float %174, 5.000000e-01
  br i1 %177, label %178, label %181

; <label>:178                                     ; preds = %160
  %179 = add nsw i32 %171, -1
  %180 = fadd float %174, 5.000000e-01
  br label %183

; <label>:181                                     ; preds = %160
  %182 = fadd float %174, -5.000000e-01
  br label %183

; <label>:183                                     ; preds = %181, %178
  %fracU.0.i = phi float [ %180, %178 ], [ %182, %181 ]
  %iPixelU.0.i = phi i32 [ %179, %178 ], [ %171, %181 ]
  %184 = fcmp olt float %176, 5.000000e-01
  br i1 %184, label %185, label %188

; <label>:185                                     ; preds = %183
  %186 = add nsw i32 %172, -1
  %187 = fadd float %176, 5.000000e-01
  br label %190

; <label>:188                                     ; preds = %183
  %189 = fadd float %176, -5.000000e-01
  br label %190

; <label>:190                                     ; preds = %188, %185
  %fracV.0.i = phi float [ %187, %185 ], [ %189, %188 ]
  %iPixelV.0.i = phi i32 [ %186, %185 ], [ %172, %188 ]
  %191 = fsub float 1.000000e+00, %fracU.0.i
  %192 = fsub float 1.000000e+00, %fracV.0.i
  %193 = fmul float %191, %192
  %194 = fmul float %fracU.0.i, %192
  %195 = fmul float %191, %fracV.0.i
  %196 = fmul float %fracU.0.i, %fracV.0.i
  %197 = add nsw i32 %iPixelU.0.i, 1
  switch i32 %17, label %wrapI.exit.i6 [
    i32 3, label %.thread.i.i2
    i32 6, label %201
  ]

.thread.i.i2:                                     ; preds = %190
  %198 = srem i32 %197, %162
  %199 = icmp slt i32 %198, 0
  %200 = select i1 %199, i32 %162, i32 0
  %..i.i1 = add nsw i32 %200, %198
  br label %wrapI.exit.i6

; <label>:201                                     ; preds = %190
  %202 = shl nsw i32 %162, 1
  %203 = srem i32 %197, %202
  %204 = icmp slt i32 %203, 0
  %205 = select i1 %204, i32 %202, i32 0
  %.3.i.i3 = add nsw i32 %205, %203
  %206 = icmp slt i32 %.3.i.i3, %162
  %207 = sub nsw i32 %202, %.3.i.i3
  %.3..i.i4 = select i1 %206, i32 %.3.i.i3, i32 %207
  br label %wrapI.exit.i6

wrapI.exit.i6:                                    ; preds = %201, %.thread.i.i2, %190
  %.2.i.i5 = phi i32 [ %.3..i.i4, %201 ], [ %..i.i1, %.thread.i.i2 ], [ %197, %190 ]
  %208 = add nsw i32 %162, -1
  %209 = icmp slt i32 %.2.i.i5, %208
  %210 = select i1 %209, i32 %.2.i.i5, i32 %208
  %211 = icmp sgt i32 0, %210
  %212 = select i1 %211, i32 0, i32 %210
  %213 = add nsw i32 %iPixelV.0.i, 1
  switch i32 %19, label %wrapI.exit6.i [
    i32 3, label %.thread.i2.i
    i32 6, label %217
  ]

.thread.i2.i:                                     ; preds = %wrapI.exit.i6
  %214 = srem i32 %213, %164
  %215 = icmp slt i32 %214, 0
  %216 = select i1 %215, i32 %164, i32 0
  %..i1.i = add nsw i32 %216, %214
  br label %wrapI.exit6.i

; <label>:217                                     ; preds = %wrapI.exit.i6
  %218 = shl nsw i32 %164, 1
  %219 = srem i32 %213, %218
  %220 = icmp slt i32 %219, 0
  %221 = select i1 %220, i32 %218, i32 0
  %.3.i3.i = add nsw i32 %221, %219
  %222 = icmp slt i32 %.3.i3.i, %164
  %223 = sub nsw i32 %218, %.3.i3.i
  %.3..i4.i = select i1 %222, i32 %.3.i3.i, i32 %223
  br label %wrapI.exit6.i

wrapI.exit6.i:                                    ; preds = %217, %.thread.i2.i, %wrapI.exit.i6
  %.2.i5.i = phi i32 [ %.3..i4.i, %217 ], [ %..i1.i, %.thread.i2.i ], [ %213, %wrapI.exit.i6 ]
  %224 = add nsw i32 %164, -1
  %225 = icmp slt i32 %.2.i5.i, %224
  %226 = select i1 %225, i32 %.2.i5.i, i32 %224
  %227 = icmp sgt i32 0, %226
  %228 = select i1 %227, i32 0, i32 %226
  switch i32 %17, label %wrapI.exit12.i [
    i32 3, label %.thread.i8.i
    i32 6, label %232
  ]

.thread.i8.i:                                     ; preds = %wrapI.exit6.i
  %229 = srem i32 %iPixelU.0.i, %162
  %230 = icmp slt i32 %229, 0
  %231 = select i1 %230, i32 %162, i32 0
  %..i7.i = add nsw i32 %231, %229
  br label %wrapI.exit12.i

; <label>:232                                     ; preds = %wrapI.exit6.i
  %233 = shl nsw i32 %162, 1
  %234 = srem i32 %iPixelU.0.i, %233
  %235 = icmp slt i32 %234, 0
  %236 = select i1 %235, i32 %233, i32 0
  %.3.i9.i = add nsw i32 %236, %234
  %237 = icmp slt i32 %.3.i9.i, %162
  %238 = sub nsw i32 %233, %.3.i9.i
  %.3..i10.i = select i1 %237, i32 %.3.i9.i, i32 %238
  br label %wrapI.exit12.i

wrapI.exit12.i:                                   ; preds = %232, %.thread.i8.i, %wrapI.exit6.i
  %.2.i11.i = phi i32 [ %.3..i10.i, %232 ], [ %..i7.i, %.thread.i8.i ], [ %iPixelU.0.i, %wrapI.exit6.i ]
  %239 = icmp slt i32 %.2.i11.i, %208
  %240 = select i1 %239, i32 %.2.i11.i, i32 %208
  %241 = icmp sgt i32 0, %240
  %242 = select i1 %241, i32 0, i32 %240
  switch i32 %19, label %wrapI.exit18.i [
    i32 3, label %.thread.i14.i
    i32 6, label %246
  ]

.thread.i14.i:                                    ; preds = %wrapI.exit12.i
  %243 = srem i32 %iPixelV.0.i, %164
  %244 = icmp slt i32 %243, 0
  %245 = select i1 %244, i32 %164, i32 0
  %..i13.i = add nsw i32 %245, %243
  br label %wrapI.exit18.i

; <label>:246                                     ; preds = %wrapI.exit12.i
  %247 = shl nsw i32 %164, 1
  %248 = srem i32 %iPixelV.0.i, %247
  %249 = icmp slt i32 %248, 0
  %250 = select i1 %249, i32 %247, i32 0
  %.3.i15.i = add nsw i32 %250, %248
  %251 = icmp slt i32 %.3.i15.i, %164
  %252 = sub nsw i32 %247, %.3.i15.i
  %.3..i16.i = select i1 %251, i32 %.3.i15.i, i32 %252
  br label %wrapI.exit18.i

wrapI.exit18.i:                                   ; preds = %246, %.thread.i14.i, %wrapI.exit12.i
  %.2.i17.i = phi i32 [ %.3..i16.i, %246 ], [ %..i13.i, %.thread.i14.i ], [ %iPixelV.0.i, %wrapI.exit12.i ]
  %253 = icmp slt i32 %.2.i17.i, %224
  %254 = select i1 %253, i32 %.2.i17.i, i32 %224
  %255 = icmp sgt i32 0, %254
  %256 = select i1 %255, i32 0, i32 %254
  %257 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %258 = load i8*, i8** %257, align 4, !tbaa !22
  %259 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %3, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %260 = load i32, i32* %259, align 4, !tbaa !21
  switch i32 %13, label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit [
    i32 11, label %261
    i32 8, label %352
    i32 9, label %376
    i32 10, label %437
    i32 7, label %603
  ]

; <label>:261                                     ; preds = %wrapI.exit18.i
  %262 = mul i32 %260, %256
  %263 = shl nsw i32 %242, 2
  %.sum.i.i.i.i = add i32 %262, %263
  %264 = getelementptr inbounds i8, i8* %258, i32 %.sum.i.i.i.i
  %265 = load i8, i8* %264, align 1, !tbaa !19
  %266 = uitofp i8 %265 to float
  %267 = insertelement <4 x float> undef, float %266, i32 0
  %268 = or i32 %263, 1
  %.sum1.i.i.i.i = add i32 %262, %268
  %269 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i.i.i.i
  %270 = load i8, i8* %269, align 1, !tbaa !19
  %271 = uitofp i8 %270 to float
  %272 = insertelement <4 x float> %267, float %271, i32 1
  %273 = or i32 %263, 2
  %.sum2.i.i.i.i = add i32 %262, %273
  %274 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i.i.i.i
  %275 = load i8, i8* %274, align 1, !tbaa !19
  %276 = uitofp i8 %275 to float
  %277 = insertelement <4 x float> %272, float %276, i32 2
  %278 = or i32 %263, 3
  %.sum3.i.i.i.i = add i32 %262, %278
  %279 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i.i.i.i
  %280 = load i8, i8* %279, align 1, !tbaa !19
  %281 = uitofp i8 %280 to float
  %282 = insertelement <4 x float> %277, float %281, i32 3
  %283 = shl nsw i32 %212, 2
  %.sum.i9.i.i.i = add i32 %262, %283
  %284 = getelementptr inbounds i8, i8* %258, i32 %.sum.i9.i.i.i
  %285 = load i8, i8* %284, align 1, !tbaa !19
  %286 = uitofp i8 %285 to float
  %287 = insertelement <4 x float> undef, float %286, i32 0
  %288 = or i32 %283, 1
  %.sum1.i10.i.i.i = add i32 %262, %288
  %289 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i10.i.i.i
  %290 = load i8, i8* %289, align 1, !tbaa !19
  %291 = uitofp i8 %290 to float
  %292 = insertelement <4 x float> %287, float %291, i32 1
  %293 = or i32 %283, 2
  %.sum2.i11.i.i.i = add i32 %262, %293
  %294 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i11.i.i.i
  %295 = load i8, i8* %294, align 1, !tbaa !19
  %296 = uitofp i8 %295 to float
  %297 = insertelement <4 x float> %292, float %296, i32 2
  %298 = or i32 %283, 3
  %.sum3.i12.i.i.i = add i32 %262, %298
  %299 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i12.i.i.i
  %300 = load i8, i8* %299, align 1, !tbaa !19
  %301 = uitofp i8 %300 to float
  %302 = insertelement <4 x float> %297, float %301, i32 3
  %303 = mul i32 %260, %228
  %.sum.i5.i.i.i = add i32 %303, %263
  %304 = getelementptr inbounds i8, i8* %258, i32 %.sum.i5.i.i.i
  %305 = load i8, i8* %304, align 1, !tbaa !19
  %306 = uitofp i8 %305 to float
  %307 = insertelement <4 x float> undef, float %306, i32 0
  %.sum1.i6.i.i.i = add i32 %303, %268
  %308 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i6.i.i.i
  %309 = load i8, i8* %308, align 1, !tbaa !19
  %310 = uitofp i8 %309 to float
  %311 = insertelement <4 x float> %307, float %310, i32 1
  %.sum2.i7.i.i.i = add i32 %303, %273
  %312 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i7.i.i.i
  %313 = load i8, i8* %312, align 1, !tbaa !19
  %314 = uitofp i8 %313 to float
  %315 = insertelement <4 x float> %311, float %314, i32 2
  %.sum3.i8.i.i.i = add i32 %303, %278
  %316 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i8.i.i.i
  %317 = load i8, i8* %316, align 1, !tbaa !19
  %318 = uitofp i8 %317 to float
  %319 = insertelement <4 x float> %315, float %318, i32 3
  %.sum.i1.i.i.i = add i32 %303, %283
  %320 = getelementptr inbounds i8, i8* %258, i32 %.sum.i1.i.i.i
  %321 = load i8, i8* %320, align 1, !tbaa !19
  %322 = uitofp i8 %321 to float
  %323 = insertelement <4 x float> undef, float %322, i32 0
  %.sum1.i2.i.i.i = add i32 %303, %288
  %324 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i2.i.i.i
  %325 = load i8, i8* %324, align 1, !tbaa !19
  %326 = uitofp i8 %325 to float
  %327 = insertelement <4 x float> %323, float %326, i32 1
  %.sum2.i3.i.i.i = add i32 %303, %293
  %328 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i3.i.i.i
  %329 = load i8, i8* %328, align 1, !tbaa !19
  %330 = uitofp i8 %329 to float
  %331 = insertelement <4 x float> %327, float %330, i32 2
  %.sum3.i4.i.i.i = add i32 %303, %298
  %332 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i4.i.i.i
  %333 = load i8, i8* %332, align 1, !tbaa !19
  %334 = uitofp i8 %333 to float
  %335 = insertelement <4 x float> %331, float %334, i32 3
  %336 = insertelement <4 x float> undef, float %193, i32 0
  %337 = shufflevector <4 x float> %336, <4 x float> undef, <4 x i32> zeroinitializer
  %338 = fmul <4 x float> %337, %282
  %339 = insertelement <4 x float> undef, float %194, i32 0
  %340 = shufflevector <4 x float> %339, <4 x float> undef, <4 x i32> zeroinitializer
  %341 = fmul <4 x float> %340, %302
  %342 = fadd <4 x float> %338, %341
  %343 = insertelement <4 x float> undef, float %195, i32 0
  %344 = shufflevector <4 x float> %343, <4 x float> undef, <4 x i32> zeroinitializer
  %345 = fmul <4 x float> %344, %319
  %346 = fadd <4 x float> %342, %345
  %347 = insertelement <4 x float> undef, float %196, i32 0
  %348 = shufflevector <4 x float> %347, <4 x float> undef, <4 x i32> zeroinitializer
  %349 = fmul <4 x float> %348, %335
  %350 = fadd <4 x float> %346, %349
  %351 = fmul <4 x float> %350, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:352                                     ; preds = %wrapI.exit18.i
  %353 = mul i32 %260, %256
  %.sum.i.i26.i.i = add i32 %353, %242
  %354 = getelementptr inbounds i8, i8* %258, i32 %.sum.i.i26.i.i
  %355 = load i8, i8* %354, align 1, !tbaa !19
  %356 = uitofp i8 %355 to float
  %.sum.i3.i27.i.i = add i32 %353, %212
  %357 = getelementptr inbounds i8, i8* %258, i32 %.sum.i3.i27.i.i
  %358 = load i8, i8* %357, align 1, !tbaa !19
  %359 = uitofp i8 %358 to float
  %360 = mul i32 %260, %228
  %.sum.i2.i28.i.i = add i32 %360, %242
  %361 = getelementptr inbounds i8, i8* %258, i32 %.sum.i2.i28.i.i
  %362 = load i8, i8* %361, align 1, !tbaa !19
  %363 = uitofp i8 %362 to float
  %.sum.i1.i29.i.i = add i32 %360, %212
  %364 = getelementptr inbounds i8, i8* %258, i32 %.sum.i1.i29.i.i
  %365 = load i8, i8* %364, align 1, !tbaa !19
  %366 = uitofp i8 %365 to float
  %367 = fmul float %193, %356
  %368 = fmul float %194, %359
  %369 = fadd float %367, %368
  %370 = fmul float %195, %363
  %371 = fadd float %369, %370
  %372 = fmul float %196, %366
  %373 = fadd float %371, %372
  %374 = fmul float %373, 0x3F70101020000000
  %375 = insertelement <4 x float> <float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float undef>, float %374, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:376                                     ; preds = %wrapI.exit18.i
  %377 = mul i32 %260, %256
  %378 = shl nsw i32 %242, 1
  %.sum.i.i19.i.i = add i32 %377, %378
  %379 = getelementptr inbounds i8, i8* %258, i32 %.sum.i.i19.i.i
  %380 = load i8, i8* %379, align 1, !tbaa !19
  %381 = uitofp i8 %380 to float
  %382 = insertelement <2 x float> undef, float %381, i32 0
  %383 = or i32 %378, 1
  %.sum1.i.i20.i.i = add i32 %377, %383
  %384 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i.i20.i.i
  %385 = load i8, i8* %384, align 1, !tbaa !19
  %386 = uitofp i8 %385 to float
  %387 = insertelement <2 x float> %382, float %386, i32 1
  %388 = shl nsw i32 %212, 1
  %.sum.i5.i21.i.i = add i32 %377, %388
  %389 = getelementptr inbounds i8, i8* %258, i32 %.sum.i5.i21.i.i
  %390 = load i8, i8* %389, align 1, !tbaa !19
  %391 = uitofp i8 %390 to float
  %392 = insertelement <2 x float> undef, float %391, i32 0
  %393 = or i32 %388, 1
  %.sum1.i6.i22.i.i = add i32 %377, %393
  %394 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i6.i22.i.i
  %395 = load i8, i8* %394, align 1, !tbaa !19
  %396 = uitofp i8 %395 to float
  %397 = insertelement <2 x float> %392, float %396, i32 1
  %398 = mul i32 %260, %228
  %.sum.i3.i23.i.i = add i32 %398, %378
  %399 = getelementptr inbounds i8, i8* %258, i32 %.sum.i3.i23.i.i
  %400 = load i8, i8* %399, align 1, !tbaa !19
  %401 = uitofp i8 %400 to float
  %402 = insertelement <2 x float> undef, float %401, i32 0
  %.sum1.i4.i.i.i = add i32 %398, %383
  %403 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i4.i.i.i
  %404 = load i8, i8* %403, align 1, !tbaa !19
  %405 = uitofp i8 %404 to float
  %406 = insertelement <2 x float> %402, float %405, i32 1
  %.sum.i1.i24.i.i = add i32 %398, %388
  %407 = getelementptr inbounds i8, i8* %258, i32 %.sum.i1.i24.i.i
  %408 = load i8, i8* %407, align 1, !tbaa !19
  %409 = uitofp i8 %408 to float
  %410 = insertelement <2 x float> undef, float %409, i32 0
  %.sum1.i2.i25.i.i = add i32 %398, %393
  %411 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i2.i25.i.i
  %412 = load i8, i8* %411, align 1, !tbaa !19
  %413 = uitofp i8 %412 to float
  %414 = insertelement <2 x float> %410, float %413, i32 1
  %415 = insertelement <2 x float> undef, float %193, i32 0
  %416 = shufflevector <2 x float> %415, <2 x float> undef, <2 x i32> zeroinitializer
  %417 = fmul <2 x float> %416, %387
  %418 = insertelement <2 x float> undef, float %194, i32 0
  %419 = shufflevector <2 x float> %418, <2 x float> undef, <2 x i32> zeroinitializer
  %420 = fmul <2 x float> %419, %397
  %421 = fadd <2 x float> %417, %420
  %422 = insertelement <2 x float> undef, float %195, i32 0
  %423 = shufflevector <2 x float> %422, <2 x float> undef, <2 x i32> zeroinitializer
  %424 = fmul <2 x float> %423, %406
  %425 = fadd <2 x float> %421, %424
  %426 = insertelement <2 x float> undef, float %196, i32 0
  %427 = shufflevector <2 x float> %426, <2 x float> undef, <2 x i32> zeroinitializer
  %428 = fmul <2 x float> %427, %414
  %429 = fadd <2 x float> %425, %428
  %430 = fmul <2 x float> %429, <float 0x3F70101020000000, float 0x3F70101020000000>
  %431 = extractelement <2 x float> %430, i32 0
  %432 = insertelement <4 x float> undef, float %431, i32 0
  %433 = insertelement <4 x float> %432, float %431, i32 1
  %434 = insertelement <4 x float> %433, float %431, i32 2
  %435 = extractelement <2 x float> %430, i32 1
  %436 = insertelement <4 x float> %434, float %435, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:437                                     ; preds = %wrapI.exit18.i
  %438 = icmp eq i32 %15, 13
  %439 = mul i32 %260, %256
  br i1 %438, label %440, label %506

; <label>:440                                     ; preds = %437
  %441 = getelementptr inbounds i8, i8* %258, i32 %439
  %442 = bitcast i8* %441 to i16*
  %443 = load i16, i16* %442, align 2, !tbaa !70
  %444 = zext i16 %443 to i32
  %445 = lshr i32 %444, 11
  %446 = shl nuw nsw i32 %445, 3
  %447 = lshr i32 %444, 13
  %448 = or i32 %446, %447
  %449 = uitofp i32 %448 to float
  %450 = insertelement <3 x float> undef, float %449, i32 0
  %451 = lshr i32 %444, 5
  %452 = and i32 %451, 63
  %453 = shl nuw nsw i32 %452, 2
  %454 = lshr i32 %452, 4
  %455 = or i32 %453, %454
  %456 = uitofp i32 %455 to float
  %457 = insertelement <3 x float> %450, float %456, i32 1
  %458 = and i32 %444, 31
  %459 = shl nuw nsw i32 %458, 3
  %460 = lshr i32 %458, 2
  %461 = or i32 %459, %460
  %462 = uitofp i32 %461 to float
  %463 = insertelement <3 x float> %457, float %462, i32 2
  %464 = mul i32 %260, %228
  %465 = getelementptr inbounds i8, i8* %258, i32 %464
  %466 = bitcast i8* %465 to i16*
  %467 = load i16, i16* %466, align 2, !tbaa !70
  %468 = zext i16 %467 to i32
  %469 = lshr i32 %468, 11
  %470 = shl nuw nsw i32 %469, 3
  %471 = lshr i32 %468, 13
  %472 = or i32 %470, %471
  %473 = uitofp i32 %472 to float
  %474 = insertelement <3 x float> undef, float %473, i32 0
  %475 = lshr i32 %468, 5
  %476 = and i32 %475, 63
  %477 = shl nuw nsw i32 %476, 2
  %478 = lshr i32 %476, 4
  %479 = or i32 %477, %478
  %480 = uitofp i32 %479 to float
  %481 = insertelement <3 x float> %474, float %480, i32 1
  %482 = and i32 %468, 31
  %483 = shl nuw nsw i32 %482, 3
  %484 = lshr i32 %482, 2
  %485 = or i32 %483, %484
  %486 = uitofp i32 %485 to float
  %487 = insertelement <3 x float> %481, float %486, i32 2
  %488 = insertelement <3 x float> undef, float %193, i32 0
  %489 = shufflevector <3 x float> %488, <3 x float> undef, <3 x i32> zeroinitializer
  %490 = fmul <3 x float> %489, %463
  %491 = insertelement <3 x float> undef, float %194, i32 0
  %492 = shufflevector <3 x float> %491, <3 x float> undef, <3 x i32> zeroinitializer
  %493 = fmul <3 x float> %492, %463
  %494 = fadd <3 x float> %490, %493
  %495 = insertelement <3 x float> undef, float %195, i32 0
  %496 = shufflevector <3 x float> %495, <3 x float> undef, <3 x i32> zeroinitializer
  %497 = fmul <3 x float> %496, %487
  %498 = fadd <3 x float> %494, %497
  %499 = insertelement <3 x float> undef, float %196, i32 0
  %500 = shufflevector <3 x float> %499, <3 x float> undef, <3 x i32> zeroinitializer
  %501 = fmul <3 x float> %500, %487
  %502 = fadd <3 x float> %501, %498
  %503 = fmul <3 x float> %502, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %504 = shufflevector <3 x float> %503, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %505 = insertelement <4 x float> %504, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:506                                     ; preds = %437
  %507 = shl nsw i32 %242, 2
  %.sum.i.i3.i.i = add i32 %439, %507
  %508 = getelementptr inbounds i8, i8* %258, i32 %.sum.i.i3.i.i
  %509 = load i8, i8* %508, align 1, !tbaa !19
  %510 = uitofp i8 %509 to float
  %511 = insertelement <4 x float> undef, float %510, i32 0
  %512 = or i32 %507, 1
  %.sum1.i.i4.i.i = add i32 %439, %512
  %513 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i.i4.i.i
  %514 = load i8, i8* %513, align 1, !tbaa !19
  %515 = uitofp i8 %514 to float
  %516 = insertelement <4 x float> %511, float %515, i32 1
  %517 = or i32 %507, 2
  %.sum2.i.i5.i.i = add i32 %439, %517
  %518 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i.i5.i.i
  %519 = load i8, i8* %518, align 1, !tbaa !19
  %520 = uitofp i8 %519 to float
  %521 = insertelement <4 x float> %516, float %520, i32 2
  %522 = or i32 %507, 3
  %.sum3.i.i6.i.i = add i32 %439, %522
  %523 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i.i6.i.i
  %524 = load i8, i8* %523, align 1, !tbaa !19
  %525 = uitofp i8 %524 to float
  %526 = insertelement <4 x float> %521, float %525, i32 3
  %527 = shl nsw i32 %212, 2
  %.sum.i9.i7.i.i = add i32 %439, %527
  %528 = getelementptr inbounds i8, i8* %258, i32 %.sum.i9.i7.i.i
  %529 = load i8, i8* %528, align 1, !tbaa !19
  %530 = uitofp i8 %529 to float
  %531 = insertelement <4 x float> undef, float %530, i32 0
  %532 = or i32 %527, 1
  %.sum1.i10.i8.i.i = add i32 %439, %532
  %533 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i10.i8.i.i
  %534 = load i8, i8* %533, align 1, !tbaa !19
  %535 = uitofp i8 %534 to float
  %536 = insertelement <4 x float> %531, float %535, i32 1
  %537 = or i32 %527, 2
  %.sum2.i11.i9.i.i = add i32 %439, %537
  %538 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i11.i9.i.i
  %539 = load i8, i8* %538, align 1, !tbaa !19
  %540 = uitofp i8 %539 to float
  %541 = insertelement <4 x float> %536, float %540, i32 2
  %542 = or i32 %527, 3
  %.sum3.i12.i10.i.i = add i32 %439, %542
  %543 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i12.i10.i.i
  %544 = load i8, i8* %543, align 1, !tbaa !19
  %545 = uitofp i8 %544 to float
  %546 = insertelement <4 x float> %541, float %545, i32 3
  %547 = mul i32 %260, %228
  %.sum.i5.i11.i.i = add i32 %547, %507
  %548 = getelementptr inbounds i8, i8* %258, i32 %.sum.i5.i11.i.i
  %549 = load i8, i8* %548, align 1, !tbaa !19
  %550 = uitofp i8 %549 to float
  %551 = insertelement <4 x float> undef, float %550, i32 0
  %.sum1.i6.i12.i.i = add i32 %547, %512
  %552 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i6.i12.i.i
  %553 = load i8, i8* %552, align 1, !tbaa !19
  %554 = uitofp i8 %553 to float
  %555 = insertelement <4 x float> %551, float %554, i32 1
  %.sum2.i7.i13.i.i = add i32 %547, %517
  %556 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i7.i13.i.i
  %557 = load i8, i8* %556, align 1, !tbaa !19
  %558 = uitofp i8 %557 to float
  %559 = insertelement <4 x float> %555, float %558, i32 2
  %.sum3.i8.i14.i.i = add i32 %547, %522
  %560 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i8.i14.i.i
  %561 = load i8, i8* %560, align 1, !tbaa !19
  %562 = uitofp i8 %561 to float
  %563 = insertelement <4 x float> %559, float %562, i32 3
  %.sum.i1.i15.i.i = add i32 %547, %527
  %564 = getelementptr inbounds i8, i8* %258, i32 %.sum.i1.i15.i.i
  %565 = load i8, i8* %564, align 1, !tbaa !19
  %566 = uitofp i8 %565 to float
  %567 = insertelement <4 x float> undef, float %566, i32 0
  %.sum1.i2.i16.i.i = add i32 %547, %532
  %568 = getelementptr inbounds i8, i8* %258, i32 %.sum1.i2.i16.i.i
  %569 = load i8, i8* %568, align 1, !tbaa !19
  %570 = uitofp i8 %569 to float
  %571 = insertelement <4 x float> %567, float %570, i32 1
  %.sum2.i3.i17.i.i = add i32 %547, %537
  %572 = getelementptr inbounds i8, i8* %258, i32 %.sum2.i3.i17.i.i
  %573 = load i8, i8* %572, align 1, !tbaa !19
  %574 = uitofp i8 %573 to float
  %575 = insertelement <4 x float> %571, float %574, i32 2
  %.sum3.i4.i18.i.i = add i32 %547, %542
  %576 = getelementptr inbounds i8, i8* %258, i32 %.sum3.i4.i18.i.i
  %577 = load i8, i8* %576, align 1, !tbaa !19
  %578 = uitofp i8 %577 to float
  %579 = insertelement <4 x float> %575, float %578, i32 3
  %580 = insertelement <4 x float> undef, float %193, i32 0
  %581 = shufflevector <4 x float> %580, <4 x float> undef, <4 x i32> zeroinitializer
  %582 = fmul <4 x float> %581, %526
  %583 = insertelement <4 x float> undef, float %194, i32 0
  %584 = shufflevector <4 x float> %583, <4 x float> undef, <4 x i32> zeroinitializer
  %585 = fmul <4 x float> %584, %546
  %586 = fadd <4 x float> %582, %585
  %587 = insertelement <4 x float> undef, float %195, i32 0
  %588 = shufflevector <4 x float> %587, <4 x float> undef, <4 x i32> zeroinitializer
  %589 = fmul <4 x float> %588, %563
  %590 = fadd <4 x float> %586, %589
  %591 = insertelement <4 x float> undef, float %196, i32 0
  %592 = shufflevector <4 x float> %591, <4 x float> undef, <4 x i32> zeroinitializer
  %593 = fmul <4 x float> %592, %579
  %594 = fadd <4 x float> %590, %593
  %595 = fmul <4 x float> %594, <float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000, float 0x3F70101020000000>
  %596 = extractelement <4 x float> %595, i32 0
  %597 = insertelement <4 x float> undef, float %596, i32 0
  %598 = extractelement <4 x float> %595, i32 1
  %599 = insertelement <4 x float> %597, float %598, i32 1
  %600 = extractelement <4 x float> %595, i32 2
  %601 = insertelement <4 x float> %599, float %600, i32 2
  %602 = insertelement <4 x float> %601, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

; <label>:603                                     ; preds = %wrapI.exit18.i
  %604 = mul i32 %260, %256
  %.sum.i.i1.i.i = add i32 %604, %242
  %605 = getelementptr inbounds i8, i8* %258, i32 %.sum.i.i1.i.i
  %606 = load i8, i8* %605, align 1, !tbaa !19
  %607 = uitofp i8 %606 to float
  %.sum.i3.i.i.i = add i32 %604, %212
  %608 = getelementptr inbounds i8, i8* %258, i32 %.sum.i3.i.i.i
  %609 = load i8, i8* %608, align 1, !tbaa !19
  %610 = uitofp i8 %609 to float
  %611 = mul i32 %260, %228
  %.sum.i2.i.i.i = add i32 %611, %242
  %612 = getelementptr inbounds i8, i8* %258, i32 %.sum.i2.i.i.i
  %613 = load i8, i8* %612, align 1, !tbaa !19
  %614 = uitofp i8 %613 to float
  %.sum.i1.i2.i.i = add i32 %611, %212
  %615 = getelementptr inbounds i8, i8* %258, i32 %.sum.i1.i2.i.i
  %616 = load i8, i8* %615, align 1, !tbaa !19
  %617 = uitofp i8 %616 to float
  %618 = fmul float %193, %607
  %619 = fmul float %194, %610
  %620 = fadd float %618, %619
  %621 = fmul float %195, %614
  %622 = fadd float %620, %621
  %623 = fmul float %196, %617
  %624 = fadd float %622, %623
  %625 = fmul float %624, 0x3F70101020000000
  %626 = insertelement <4 x float> undef, float %625, i32 0
  %627 = insertelement <4 x float> %626, float %625, i32 1
  %628 = insertelement <4 x float> %627, float %625, i32 2
  %629 = insertelement <4 x float> %628, float 1.000000e+00, i32 3
  br label %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit

_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit: ; preds = %wrapI.exit18.i, %261, %352, %376, %440, %506, %603
  %.0.i.i = phi <4 x float> [ %629, %603 ], [ %505, %440 ], [ %602, %506 ], [ %436, %376 ], [ %375, %352 ], [ %351, %261 ], [ zeroinitializer, %wrapI.exit18.i ]
  br label %630

; <label>:630                                     ; preds = %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit, %0
  %.0 = phi <4 x float> [ %159, %_ZL23sample_LOD_NearestPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit ], [ %.0.i.i, %_ZL22sample_LOD_LinearPixelPK10Allocation12rs_data_kind12rs_data_type16rs_sampler_valueS4_Dv2_fj.exit ], [ zeroinitializer, %0 ]
  ret <4 x float> %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z24rsSamplerGetMinification10rs_sampler([1 x i32] %s.coerce) #4 {
  %1 = extractvalue [1 x i32] %s.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z25rsSamplerGetMagnification10rs_sampler([1 x i32] %s.coerce) #4 {
  %1 = extractvalue [1 x i32] %s.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 0
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z17rsSamplerGetWrapS10rs_sampler([1 x i32] %s.coerce) #4 {
  %1 = extractvalue [1 x i32] %s.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 2
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define i32 @_Z17rsSamplerGetWrapT10rs_sampler([1 x i32] %s.coerce) #4 {
  %1 = extractvalue [1 x i32] %s.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 3
  %6 = load i32, i32* %5, align 4, !tbaa !19
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi i32 [ %6, %3 ], [ 100, %0 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
define float @_Z22rsSamplerGetAnisotropy10rs_sampler([1 x i32] %s.coerce) #4 {
  %1 = extractvalue [1 x i32] %s.coerce, 0
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %7, label %3

; <label>:3                                       ; preds = %0
  %4 = inttoptr i32 %1 to %struct.Sampler*
  %5 = getelementptr inbounds %struct.Sampler, %struct.Sampler* %4, i32 0, i32 1, i32 1, i32 5
  %6 = load float, float* %5, align 4, !tbaa !18
  br label %7

; <label>:7                                       ; preds = %3, %0
  %.0 = phi float [ %6, %3 ], [ 0.000000e+00, %0 ]
  ret float %.0
}

; Function Attrs: nounwind readnone
define double @_Z5clampddd(double %amount, double %low, double %high) #7 {
  %1 = fcmp olt double %amount, %low
  br i1 %1, label %5, label %2

; <label>:2                                       ; preds = %0
  %3 = fcmp ogt double %amount, %high
  %4 = select i1 %3, double %high, double %amount
  br label %5

; <label>:5                                       ; preds = %2, %0
  %6 = phi double [ %4, %2 ], [ %low, %0 ]
  ret double %6
}

; Function Attrs: nounwind readnone
define <2 x double> @_Z5clampDv2_dS_S_(<2 x double> %amount, <2 x double> %low, <2 x double> %high) #7 {
  %1 = extractelement <2 x double> %amount, i32 0
  %2 = extractelement <2 x double> %low, i32 0
  %3 = fcmp olt double %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x double> %high, i32 0
  %6 = fcmp ogt double %1, %5
  %.sink = select i1 %6, <2 x double> %high, <2 x double> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <2 x double> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x double> %amount, i32 1
  %9 = extractelement <2 x double> %low, i32 1
  %10 = fcmp olt double %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x double> %high, i32 1
  %13 = fcmp ogt double %8, %12
  %.sink1 = select i1 %13, <2 x double> %high, <2 x double> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <2 x double> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x double> %.sink.sink, <2 x double> %.sink1.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x double> %15
}

; Function Attrs: nounwind
define void @_Z5clampDv3_dS_S_(<3 x double>* noalias nocapture sret %agg.result, <3 x double> %amount, <3 x double> %low, <3 x double> %high) #5 {
  %1 = extractelement <3 x double> %amount, i32 0
  %2 = extractelement <3 x double> %low, i32 0
  %3 = fcmp olt double %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x double> %high, i32 0
  %6 = fcmp ogt double %1, %5
  %.sink = select i1 %6, <3 x double> %high, <3 x double> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <3 x double> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x double> %amount, i32 1
  %9 = extractelement <3 x double> %low, i32 1
  %10 = fcmp olt double %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x double> %high, i32 1
  %13 = fcmp ogt double %8, %12
  %.sink1 = select i1 %13, <3 x double> %high, <3 x double> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <3 x double> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x double> %.sink.sink, <3 x double> %.sink1.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x double> %amount, i32 2
  %17 = extractelement <3 x double> %low, i32 2
  %18 = fcmp olt double %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x double> %high, i32 2
  %21 = fcmp ogt double %16, %20
  %.sink2 = select i1 %21, <3 x double> %high, <3 x double> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <3 x double> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x double> %15, <3 x double> %.sink2.sink, <3 x i32> <i32 0, i32 1, i32 5>
  %24 = shufflevector <3 x double> %23, <3 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %25 = bitcast <3 x double>* %agg.result to <4 x double>*
  store <4 x double> %24, <4 x double>* %25, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z5clampDv4_dS_S_(<4 x double>* noalias nocapture sret %agg.result, <4 x double> %amount, <4 x double> %low, <4 x double> %high) #5 {
  %1 = extractelement <4 x double> %amount, i32 0
  %2 = extractelement <4 x double> %low, i32 0
  %3 = fcmp olt double %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x double> %high, i32 0
  %6 = fcmp ogt double %1, %5
  %.sink = select i1 %6, <4 x double> %high, <4 x double> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <4 x double> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x double> %amount, i32 1
  %9 = extractelement <4 x double> %low, i32 1
  %10 = fcmp olt double %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x double> %high, i32 1
  %13 = fcmp ogt double %8, %12
  %.sink1 = select i1 %13, <4 x double> %high, <4 x double> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <4 x double> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x double> %.sink.sink, <4 x double> %.sink1.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x double> %amount, i32 2
  %17 = extractelement <4 x double> %low, i32 2
  %18 = fcmp olt double %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x double> %high, i32 2
  %21 = fcmp ogt double %16, %20
  %.sink2 = select i1 %21, <4 x double> %high, <4 x double> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <4 x double> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x double> %15, <4 x double> %.sink2.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x double> %amount, i32 3
  %25 = extractelement <4 x double> %low, i32 3
  %26 = fcmp olt double %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x double> %high, i32 3
  %29 = fcmp ogt double %24, %28
  %.sink3 = select i1 %29, <4 x double> %high, <4 x double> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink3.sink = phi <4 x double> [ %.sink3, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x double> %23, <4 x double> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  store <4 x double> %31, <4 x double>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define <2 x double> @_Z5clampDv2_ddd(<2 x double> %amount, double %low, double %high) #7 {
  %1 = extractelement <2 x double> %amount, i32 0
  %2 = fcmp olt double %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = fcmp ogt double %1, %high
  %high. = select i1 %4, double %high, double %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi double [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <2 x double> undef, double %6, i32 0
  %8 = extractelement <2 x double> %amount, i32 1
  %9 = fcmp olt double %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = fcmp ogt double %8, %high
  %high.1 = select i1 %11, double %high, double %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi double [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <2 x double> %7, double %13, i32 1
  ret <2 x double> %14
}

; Function Attrs: nounwind
define void @_Z5clampDv3_ddd(<3 x double>* noalias nocapture sret %agg.result, <3 x double> %amount, double %low, double %high) #5 {
  %1 = extractelement <3 x double> %amount, i32 0
  %2 = fcmp olt double %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = fcmp ogt double %1, %high
  %high. = select i1 %4, double %high, double %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi double [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x double> undef, double %6, i32 0
  %8 = extractelement <3 x double> %amount, i32 1
  %9 = fcmp olt double %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = fcmp ogt double %8, %high
  %high.1 = select i1 %11, double %high, double %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi double [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x double> %7, double %13, i32 1
  %15 = extractelement <3 x double> %amount, i32 2
  %16 = fcmp olt double %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = fcmp ogt double %15, %high
  %high.2 = select i1 %18, double %high, double %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi double [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x double> %14, double %20, i32 2
  %22 = bitcast <3 x double>* %agg.result to <4 x double>*
  store <4 x double> %21, <4 x double>* %22, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z5clampDv4_ddd(<4 x double>* noalias nocapture sret %agg.result, <4 x double> %amount, double %low, double %high) #5 {
  %1 = extractelement <4 x double> %amount, i32 0
  %2 = fcmp olt double %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = fcmp ogt double %1, %high
  %high. = select i1 %4, double %high, double %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi double [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x double> undef, double %6, i32 0
  %8 = extractelement <4 x double> %amount, i32 1
  %9 = fcmp olt double %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = fcmp ogt double %8, %high
  %high.1 = select i1 %11, double %high, double %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi double [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x double> %7, double %13, i32 1
  %15 = extractelement <4 x double> %amount, i32 2
  %16 = fcmp olt double %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = fcmp ogt double %15, %high
  %high.2 = select i1 %18, double %high, double %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi double [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x double> %14, double %20, i32 2
  %22 = extractelement <4 x double> %amount, i32 3
  %23 = fcmp olt double %22, %low
  br i1 %23, label %26, label %24

; <label>:24                                      ; preds = %19
  %25 = fcmp ogt double %22, %high
  %high.3 = select i1 %25, double %high, double %22
  br label %26

; <label>:26                                      ; preds = %24, %19
  %27 = phi double [ %low, %19 ], [ %high.3, %24 ]
  %28 = insertelement <4 x double> %21, double %27, i32 3
  store <4 x double> %28, <4 x double>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define signext i8 @_Z5clampccc(i8 signext %amount, i8 signext %low, i8 signext %high) #7 {
  %1 = icmp slt i8 %amount, %low
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp sgt i8 %amount, %high
  %.sink = select i1 %3, i8 %high, i8 %amount
  br label %4

; <label>:4                                       ; preds = %2, %0
  %.sink.sink = phi i8 [ %.sink, %2 ], [ %low, %0 ]
  ret i8 %.sink.sink
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z5clampDv2_cS_S_(<2 x i8> %amount, <2 x i8> %low, <2 x i8> %high) #7 {
  %1 = extractelement <2 x i8> %amount, i32 0
  %2 = extractelement <2 x i8> %low, i32 0
  %3 = icmp slt i8 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i8> %high, i32 0
  %6 = icmp sgt i8 %1, %5
  %.sink1 = select i1 %6, <2 x i8> %high, <2 x i8> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <2 x i8> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i8> %amount, i32 1
  %9 = extractelement <2 x i8> %low, i32 1
  %10 = icmp slt i8 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i8> %high, i32 1
  %13 = icmp sgt i8 %8, %12
  %.sink2 = select i1 %13, <2 x i8> %high, <2 x i8> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <2 x i8> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i8> %.sink1.sink, <2 x i8> %.sink2.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i8> %15
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z5clampDv3_cS_S_(<3 x i8> %amount, <3 x i8> %low, <3 x i8> %high) #7 {
  %1 = extractelement <3 x i8> %amount, i32 0
  %2 = extractelement <3 x i8> %low, i32 0
  %3 = icmp slt i8 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i8> %high, i32 0
  %6 = icmp sgt i8 %1, %5
  %.sink1 = select i1 %6, <3 x i8> %high, <3 x i8> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <3 x i8> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i8> %amount, i32 1
  %9 = extractelement <3 x i8> %low, i32 1
  %10 = icmp slt i8 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i8> %high, i32 1
  %13 = icmp sgt i8 %8, %12
  %.sink2 = select i1 %13, <3 x i8> %high, <3 x i8> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <3 x i8> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i8> %.sink1.sink, <3 x i8> %.sink2.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i8> %amount, i32 2
  %17 = extractelement <3 x i8> %low, i32 2
  %18 = icmp slt i8 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i8> %high, i32 2
  %21 = icmp sgt i8 %16, %20
  %.sink3 = select i1 %21, <3 x i8> %high, <3 x i8> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <3 x i8> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i8> %15, <3 x i8> %.sink3.sink, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i8> %23
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z5clampDv4_cS_S_(<4 x i8> %amount, <4 x i8> %low, <4 x i8> %high) #7 {
  %1 = extractelement <4 x i8> %amount, i32 0
  %2 = extractelement <4 x i8> %low, i32 0
  %3 = icmp slt i8 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i8> %high, i32 0
  %6 = icmp sgt i8 %1, %5
  %.sink1 = select i1 %6, <4 x i8> %high, <4 x i8> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <4 x i8> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i8> %amount, i32 1
  %9 = extractelement <4 x i8> %low, i32 1
  %10 = icmp slt i8 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i8> %high, i32 1
  %13 = icmp sgt i8 %8, %12
  %.sink2 = select i1 %13, <4 x i8> %high, <4 x i8> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <4 x i8> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i8> %.sink1.sink, <4 x i8> %.sink2.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i8> %amount, i32 2
  %17 = extractelement <4 x i8> %low, i32 2
  %18 = icmp slt i8 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i8> %high, i32 2
  %21 = icmp sgt i8 %16, %20
  %.sink3 = select i1 %21, <4 x i8> %high, <4 x i8> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <4 x i8> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i8> %15, <4 x i8> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i8> %amount, i32 3
  %25 = extractelement <4 x i8> %low, i32 3
  %26 = icmp slt i8 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i8> %high, i32 3
  %29 = icmp sgt i8 %24, %28
  %.sink4 = select i1 %29, <4 x i8> %high, <4 x i8> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink4.sink = phi <4 x i8> [ %.sink4, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i8> %23, <4 x i8> %.sink4.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i8> %31
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z5clampDv2_ccc(<2 x i8> %amount, i8 signext %low, i8 signext %high) #7 {
  %1 = extractelement <2 x i8> %amount, i32 0
  %2 = icmp slt i8 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i8 %1, %high
  %high. = select i1 %4, i8 %high, i8 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i8 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <2 x i8> undef, i8 %.sink.sink, i32 0
  %7 = extractelement <2 x i8> %amount, i32 1
  %8 = icmp slt i8 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp sgt i8 %7, %high
  %high.2 = select i1 %10, i8 %high, i8 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i8 [ %low, %5 ], [ %high.2, %9 ]
  %12 = insertelement <2 x i8> %6, i8 %.sink1.sink, i32 1
  ret <2 x i8> %12
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z5clampDv3_ccc(<3 x i8> %amount, i8 signext %low, i8 signext %high) #7 {
  %1 = extractelement <3 x i8> %amount, i32 0
  %2 = icmp slt i8 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i8 %1, %high
  %high. = select i1 %4, i8 %high, i8 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i8 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <3 x i8> undef, i8 %.sink.sink, i32 0
  %7 = extractelement <3 x i8> %amount, i32 1
  %8 = icmp slt i8 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp sgt i8 %7, %high
  %high.3 = select i1 %10, i8 %high, i8 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i8 [ %low, %5 ], [ %high.3, %9 ]
  %12 = insertelement <3 x i8> %6, i8 %.sink1.sink, i32 1
  %13 = extractelement <3 x i8> %amount, i32 2
  %14 = icmp slt i8 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp sgt i8 %13, %high
  %high.4 = select i1 %16, i8 %high, i8 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i8 [ %low, %11 ], [ %high.4, %15 ]
  %18 = insertelement <3 x i8> %12, i8 %.sink2.sink, i32 2
  ret <3 x i8> %18
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z5clampDv4_ccc(<4 x i8> %amount, i8 signext %low, i8 signext %high) #7 {
  %1 = extractelement <4 x i8> %amount, i32 0
  %2 = icmp slt i8 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i8 %1, %high
  %high. = select i1 %4, i8 %high, i8 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i8 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <4 x i8> undef, i8 %.sink.sink, i32 0
  %7 = extractelement <4 x i8> %amount, i32 1
  %8 = icmp slt i8 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp sgt i8 %7, %high
  %high.4 = select i1 %10, i8 %high, i8 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i8 [ %low, %5 ], [ %high.4, %9 ]
  %12 = insertelement <4 x i8> %6, i8 %.sink1.sink, i32 1
  %13 = extractelement <4 x i8> %amount, i32 2
  %14 = icmp slt i8 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp sgt i8 %13, %high
  %high.5 = select i1 %16, i8 %high, i8 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i8 [ %low, %11 ], [ %high.5, %15 ]
  %18 = insertelement <4 x i8> %12, i8 %.sink2.sink, i32 2
  %19 = extractelement <4 x i8> %amount, i32 3
  %20 = icmp slt i8 %19, %low
  br i1 %20, label %23, label %21

; <label>:21                                      ; preds = %17
  %22 = icmp sgt i8 %19, %high
  %high.6 = select i1 %22, i8 %high, i8 %19
  br label %23

; <label>:23                                      ; preds = %21, %17
  %.sink3.sink = phi i8 [ %low, %17 ], [ %high.6, %21 ]
  %24 = insertelement <4 x i8> %18, i8 %.sink3.sink, i32 3
  ret <4 x i8> %24
}

; Function Attrs: nounwind readnone
define zeroext i8 @_Z5clamphhh(i8 zeroext %amount, i8 zeroext %low, i8 zeroext %high) #7 {
  %1 = icmp ult i8 %amount, %low
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp ugt i8 %amount, %high
  %.sink = select i1 %3, i8 %high, i8 %amount
  br label %4

; <label>:4                                       ; preds = %2, %0
  %.sink.sink = phi i8 [ %.sink, %2 ], [ %low, %0 ]
  ret i8 %.sink.sink
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z5clampDv2_hS_S_(<2 x i8> %amount, <2 x i8> %low, <2 x i8> %high) #7 {
  %1 = extractelement <2 x i8> %amount, i32 0
  %2 = extractelement <2 x i8> %low, i32 0
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i8> %high, i32 0
  %6 = icmp ugt i8 %1, %5
  %.sink1 = select i1 %6, <2 x i8> %high, <2 x i8> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <2 x i8> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i8> %amount, i32 1
  %9 = extractelement <2 x i8> %low, i32 1
  %10 = icmp ult i8 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i8> %high, i32 1
  %13 = icmp ugt i8 %8, %12
  %.sink2 = select i1 %13, <2 x i8> %high, <2 x i8> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <2 x i8> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i8> %.sink1.sink, <2 x i8> %.sink2.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i8> %15
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z5clampDv3_hS_S_(<3 x i8> %amount, <3 x i8> %low, <3 x i8> %high) #7 {
  %1 = extractelement <3 x i8> %amount, i32 0
  %2 = extractelement <3 x i8> %low, i32 0
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i8> %high, i32 0
  %6 = icmp ugt i8 %1, %5
  %.sink1 = select i1 %6, <3 x i8> %high, <3 x i8> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <3 x i8> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i8> %amount, i32 1
  %9 = extractelement <3 x i8> %low, i32 1
  %10 = icmp ult i8 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i8> %high, i32 1
  %13 = icmp ugt i8 %8, %12
  %.sink2 = select i1 %13, <3 x i8> %high, <3 x i8> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <3 x i8> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i8> %.sink1.sink, <3 x i8> %.sink2.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i8> %amount, i32 2
  %17 = extractelement <3 x i8> %low, i32 2
  %18 = icmp ult i8 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i8> %high, i32 2
  %21 = icmp ugt i8 %16, %20
  %.sink3 = select i1 %21, <3 x i8> %high, <3 x i8> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <3 x i8> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i8> %15, <3 x i8> %.sink3.sink, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i8> %23
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z5clampDv4_hS_S_(<4 x i8> %amount, <4 x i8> %low, <4 x i8> %high) #7 {
  %1 = extractelement <4 x i8> %amount, i32 0
  %2 = extractelement <4 x i8> %low, i32 0
  %3 = icmp ult i8 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i8> %high, i32 0
  %6 = icmp ugt i8 %1, %5
  %.sink1 = select i1 %6, <4 x i8> %high, <4 x i8> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <4 x i8> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i8> %amount, i32 1
  %9 = extractelement <4 x i8> %low, i32 1
  %10 = icmp ult i8 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i8> %high, i32 1
  %13 = icmp ugt i8 %8, %12
  %.sink2 = select i1 %13, <4 x i8> %high, <4 x i8> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <4 x i8> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i8> %.sink1.sink, <4 x i8> %.sink2.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i8> %amount, i32 2
  %17 = extractelement <4 x i8> %low, i32 2
  %18 = icmp ult i8 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i8> %high, i32 2
  %21 = icmp ugt i8 %16, %20
  %.sink3 = select i1 %21, <4 x i8> %high, <4 x i8> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <4 x i8> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i8> %15, <4 x i8> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i8> %amount, i32 3
  %25 = extractelement <4 x i8> %low, i32 3
  %26 = icmp ult i8 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i8> %high, i32 3
  %29 = icmp ugt i8 %24, %28
  %.sink4 = select i1 %29, <4 x i8> %high, <4 x i8> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink4.sink = phi <4 x i8> [ %.sink4, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i8> %23, <4 x i8> %.sink4.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i8> %31
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z5clampDv2_hhh(<2 x i8> %amount, i8 zeroext %low, i8 zeroext %high) #7 {
  %1 = extractelement <2 x i8> %amount, i32 0
  %2 = icmp ult i8 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i8 %1, %high
  %high. = select i1 %4, i8 %high, i8 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i8 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <2 x i8> undef, i8 %.sink.sink, i32 0
  %7 = extractelement <2 x i8> %amount, i32 1
  %8 = icmp ult i8 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp ugt i8 %7, %high
  %high.2 = select i1 %10, i8 %high, i8 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i8 [ %low, %5 ], [ %high.2, %9 ]
  %12 = insertelement <2 x i8> %6, i8 %.sink1.sink, i32 1
  ret <2 x i8> %12
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z5clampDv3_hhh(<3 x i8> %amount, i8 zeroext %low, i8 zeroext %high) #7 {
  %1 = extractelement <3 x i8> %amount, i32 0
  %2 = icmp ult i8 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i8 %1, %high
  %high. = select i1 %4, i8 %high, i8 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i8 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <3 x i8> undef, i8 %.sink.sink, i32 0
  %7 = extractelement <3 x i8> %amount, i32 1
  %8 = icmp ult i8 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp ugt i8 %7, %high
  %high.3 = select i1 %10, i8 %high, i8 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i8 [ %low, %5 ], [ %high.3, %9 ]
  %12 = insertelement <3 x i8> %6, i8 %.sink1.sink, i32 1
  %13 = extractelement <3 x i8> %amount, i32 2
  %14 = icmp ult i8 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp ugt i8 %13, %high
  %high.4 = select i1 %16, i8 %high, i8 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i8 [ %low, %11 ], [ %high.4, %15 ]
  %18 = insertelement <3 x i8> %12, i8 %.sink2.sink, i32 2
  ret <3 x i8> %18
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z5clampDv4_hhh(<4 x i8> %amount, i8 zeroext %low, i8 zeroext %high) #7 {
  %1 = extractelement <4 x i8> %amount, i32 0
  %2 = icmp ult i8 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i8 %1, %high
  %high. = select i1 %4, i8 %high, i8 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i8 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <4 x i8> undef, i8 %.sink.sink, i32 0
  %7 = extractelement <4 x i8> %amount, i32 1
  %8 = icmp ult i8 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp ugt i8 %7, %high
  %high.4 = select i1 %10, i8 %high, i8 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i8 [ %low, %5 ], [ %high.4, %9 ]
  %12 = insertelement <4 x i8> %6, i8 %.sink1.sink, i32 1
  %13 = extractelement <4 x i8> %amount, i32 2
  %14 = icmp ult i8 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp ugt i8 %13, %high
  %high.5 = select i1 %16, i8 %high, i8 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i8 [ %low, %11 ], [ %high.5, %15 ]
  %18 = insertelement <4 x i8> %12, i8 %.sink2.sink, i32 2
  %19 = extractelement <4 x i8> %amount, i32 3
  %20 = icmp ult i8 %19, %low
  br i1 %20, label %23, label %21

; <label>:21                                      ; preds = %17
  %22 = icmp ugt i8 %19, %high
  %high.6 = select i1 %22, i8 %high, i8 %19
  br label %23

; <label>:23                                      ; preds = %21, %17
  %.sink3.sink = phi i8 [ %low, %17 ], [ %high.6, %21 ]
  %24 = insertelement <4 x i8> %18, i8 %.sink3.sink, i32 3
  ret <4 x i8> %24
}

; Function Attrs: nounwind readnone
define signext i16 @_Z5clampsss(i16 signext %amount, i16 signext %low, i16 signext %high) #7 {
  %1 = icmp slt i16 %amount, %low
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp sgt i16 %amount, %high
  %.sink = select i1 %3, i16 %high, i16 %amount
  br label %4

; <label>:4                                       ; preds = %2, %0
  %.sink.sink = phi i16 [ %.sink, %2 ], [ %low, %0 ]
  ret i16 %.sink.sink
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z5clampDv2_sS_S_(<2 x i16> %amount, <2 x i16> %low, <2 x i16> %high) #7 {
  %1 = extractelement <2 x i16> %amount, i32 0
  %2 = extractelement <2 x i16> %low, i32 0
  %3 = icmp slt i16 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i16> %high, i32 0
  %6 = icmp sgt i16 %1, %5
  %.sink1 = select i1 %6, <2 x i16> %high, <2 x i16> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <2 x i16> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i16> %amount, i32 1
  %9 = extractelement <2 x i16> %low, i32 1
  %10 = icmp slt i16 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i16> %high, i32 1
  %13 = icmp sgt i16 %8, %12
  %.sink2 = select i1 %13, <2 x i16> %high, <2 x i16> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <2 x i16> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i16> %.sink1.sink, <2 x i16> %.sink2.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i16> %15
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z5clampDv3_sS_S_(<3 x i16> %amount, <3 x i16> %low, <3 x i16> %high) #7 {
  %1 = extractelement <3 x i16> %amount, i32 0
  %2 = extractelement <3 x i16> %low, i32 0
  %3 = icmp slt i16 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i16> %high, i32 0
  %6 = icmp sgt i16 %1, %5
  %.sink1 = select i1 %6, <3 x i16> %high, <3 x i16> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <3 x i16> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i16> %amount, i32 1
  %9 = extractelement <3 x i16> %low, i32 1
  %10 = icmp slt i16 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i16> %high, i32 1
  %13 = icmp sgt i16 %8, %12
  %.sink2 = select i1 %13, <3 x i16> %high, <3 x i16> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <3 x i16> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i16> %.sink1.sink, <3 x i16> %.sink2.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i16> %amount, i32 2
  %17 = extractelement <3 x i16> %low, i32 2
  %18 = icmp slt i16 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i16> %high, i32 2
  %21 = icmp sgt i16 %16, %20
  %.sink3 = select i1 %21, <3 x i16> %high, <3 x i16> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <3 x i16> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i16> %15, <3 x i16> %.sink3.sink, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i16> %23
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z5clampDv4_sS_S_(<4 x i16> %amount, <4 x i16> %low, <4 x i16> %high) #7 {
  %1 = extractelement <4 x i16> %amount, i32 0
  %2 = extractelement <4 x i16> %low, i32 0
  %3 = icmp slt i16 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i16> %high, i32 0
  %6 = icmp sgt i16 %1, %5
  %.sink1 = select i1 %6, <4 x i16> %high, <4 x i16> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <4 x i16> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i16> %amount, i32 1
  %9 = extractelement <4 x i16> %low, i32 1
  %10 = icmp slt i16 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i16> %high, i32 1
  %13 = icmp sgt i16 %8, %12
  %.sink2 = select i1 %13, <4 x i16> %high, <4 x i16> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <4 x i16> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i16> %.sink1.sink, <4 x i16> %.sink2.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i16> %amount, i32 2
  %17 = extractelement <4 x i16> %low, i32 2
  %18 = icmp slt i16 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i16> %high, i32 2
  %21 = icmp sgt i16 %16, %20
  %.sink3 = select i1 %21, <4 x i16> %high, <4 x i16> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <4 x i16> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i16> %15, <4 x i16> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i16> %amount, i32 3
  %25 = extractelement <4 x i16> %low, i32 3
  %26 = icmp slt i16 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i16> %high, i32 3
  %29 = icmp sgt i16 %24, %28
  %.sink4 = select i1 %29, <4 x i16> %high, <4 x i16> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink4.sink = phi <4 x i16> [ %.sink4, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i16> %23, <4 x i16> %.sink4.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i16> %31
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z5clampDv2_sss(<2 x i16> %amount, i16 signext %low, i16 signext %high) #7 {
  %1 = extractelement <2 x i16> %amount, i32 0
  %2 = icmp slt i16 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i16 %1, %high
  %high. = select i1 %4, i16 %high, i16 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i16 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <2 x i16> undef, i16 %.sink.sink, i32 0
  %7 = extractelement <2 x i16> %amount, i32 1
  %8 = icmp slt i16 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp sgt i16 %7, %high
  %high.2 = select i1 %10, i16 %high, i16 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i16 [ %low, %5 ], [ %high.2, %9 ]
  %12 = insertelement <2 x i16> %6, i16 %.sink1.sink, i32 1
  ret <2 x i16> %12
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z5clampDv3_sss(<3 x i16> %amount, i16 signext %low, i16 signext %high) #7 {
  %1 = extractelement <3 x i16> %amount, i32 0
  %2 = icmp slt i16 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i16 %1, %high
  %high. = select i1 %4, i16 %high, i16 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i16 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <3 x i16> undef, i16 %.sink.sink, i32 0
  %7 = extractelement <3 x i16> %amount, i32 1
  %8 = icmp slt i16 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp sgt i16 %7, %high
  %high.3 = select i1 %10, i16 %high, i16 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i16 [ %low, %5 ], [ %high.3, %9 ]
  %12 = insertelement <3 x i16> %6, i16 %.sink1.sink, i32 1
  %13 = extractelement <3 x i16> %amount, i32 2
  %14 = icmp slt i16 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp sgt i16 %13, %high
  %high.4 = select i1 %16, i16 %high, i16 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i16 [ %low, %11 ], [ %high.4, %15 ]
  %18 = insertelement <3 x i16> %12, i16 %.sink2.sink, i32 2
  ret <3 x i16> %18
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z5clampDv4_sss(<4 x i16> %amount, i16 signext %low, i16 signext %high) #7 {
  %1 = extractelement <4 x i16> %amount, i32 0
  %2 = icmp slt i16 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i16 %1, %high
  %high. = select i1 %4, i16 %high, i16 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i16 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <4 x i16> undef, i16 %.sink.sink, i32 0
  %7 = extractelement <4 x i16> %amount, i32 1
  %8 = icmp slt i16 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp sgt i16 %7, %high
  %high.4 = select i1 %10, i16 %high, i16 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i16 [ %low, %5 ], [ %high.4, %9 ]
  %12 = insertelement <4 x i16> %6, i16 %.sink1.sink, i32 1
  %13 = extractelement <4 x i16> %amount, i32 2
  %14 = icmp slt i16 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp sgt i16 %13, %high
  %high.5 = select i1 %16, i16 %high, i16 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i16 [ %low, %11 ], [ %high.5, %15 ]
  %18 = insertelement <4 x i16> %12, i16 %.sink2.sink, i32 2
  %19 = extractelement <4 x i16> %amount, i32 3
  %20 = icmp slt i16 %19, %low
  br i1 %20, label %23, label %21

; <label>:21                                      ; preds = %17
  %22 = icmp sgt i16 %19, %high
  %high.6 = select i1 %22, i16 %high, i16 %19
  br label %23

; <label>:23                                      ; preds = %21, %17
  %.sink3.sink = phi i16 [ %low, %17 ], [ %high.6, %21 ]
  %24 = insertelement <4 x i16> %18, i16 %.sink3.sink, i32 3
  ret <4 x i16> %24
}

; Function Attrs: nounwind readnone
define zeroext i16 @_Z5clampttt(i16 zeroext %amount, i16 zeroext %low, i16 zeroext %high) #7 {
  %1 = icmp ult i16 %amount, %low
  br i1 %1, label %4, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp ugt i16 %amount, %high
  %.sink = select i1 %3, i16 %high, i16 %amount
  br label %4

; <label>:4                                       ; preds = %2, %0
  %.sink.sink = phi i16 [ %.sink, %2 ], [ %low, %0 ]
  ret i16 %.sink.sink
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z5clampDv2_tS_S_(<2 x i16> %amount, <2 x i16> %low, <2 x i16> %high) #7 {
  %1 = extractelement <2 x i16> %amount, i32 0
  %2 = extractelement <2 x i16> %low, i32 0
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i16> %high, i32 0
  %6 = icmp ugt i16 %1, %5
  %.sink1 = select i1 %6, <2 x i16> %high, <2 x i16> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <2 x i16> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i16> %amount, i32 1
  %9 = extractelement <2 x i16> %low, i32 1
  %10 = icmp ult i16 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i16> %high, i32 1
  %13 = icmp ugt i16 %8, %12
  %.sink2 = select i1 %13, <2 x i16> %high, <2 x i16> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <2 x i16> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i16> %.sink1.sink, <2 x i16> %.sink2.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i16> %15
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z5clampDv3_tS_S_(<3 x i16> %amount, <3 x i16> %low, <3 x i16> %high) #7 {
  %1 = extractelement <3 x i16> %amount, i32 0
  %2 = extractelement <3 x i16> %low, i32 0
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i16> %high, i32 0
  %6 = icmp ugt i16 %1, %5
  %.sink1 = select i1 %6, <3 x i16> %high, <3 x i16> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <3 x i16> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i16> %amount, i32 1
  %9 = extractelement <3 x i16> %low, i32 1
  %10 = icmp ult i16 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i16> %high, i32 1
  %13 = icmp ugt i16 %8, %12
  %.sink2 = select i1 %13, <3 x i16> %high, <3 x i16> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <3 x i16> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i16> %.sink1.sink, <3 x i16> %.sink2.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i16> %amount, i32 2
  %17 = extractelement <3 x i16> %low, i32 2
  %18 = icmp ult i16 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i16> %high, i32 2
  %21 = icmp ugt i16 %16, %20
  %.sink3 = select i1 %21, <3 x i16> %high, <3 x i16> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <3 x i16> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i16> %15, <3 x i16> %.sink3.sink, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i16> %23
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z5clampDv4_tS_S_(<4 x i16> %amount, <4 x i16> %low, <4 x i16> %high) #7 {
  %1 = extractelement <4 x i16> %amount, i32 0
  %2 = extractelement <4 x i16> %low, i32 0
  %3 = icmp ult i16 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i16> %high, i32 0
  %6 = icmp ugt i16 %1, %5
  %.sink1 = select i1 %6, <4 x i16> %high, <4 x i16> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink1.sink = phi <4 x i16> [ %.sink1, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i16> %amount, i32 1
  %9 = extractelement <4 x i16> %low, i32 1
  %10 = icmp ult i16 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i16> %high, i32 1
  %13 = icmp ugt i16 %8, %12
  %.sink2 = select i1 %13, <4 x i16> %high, <4 x i16> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink2.sink = phi <4 x i16> [ %.sink2, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i16> %.sink1.sink, <4 x i16> %.sink2.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i16> %amount, i32 2
  %17 = extractelement <4 x i16> %low, i32 2
  %18 = icmp ult i16 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i16> %high, i32 2
  %21 = icmp ugt i16 %16, %20
  %.sink3 = select i1 %21, <4 x i16> %high, <4 x i16> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink3.sink = phi <4 x i16> [ %.sink3, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i16> %15, <4 x i16> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i16> %amount, i32 3
  %25 = extractelement <4 x i16> %low, i32 3
  %26 = icmp ult i16 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i16> %high, i32 3
  %29 = icmp ugt i16 %24, %28
  %.sink4 = select i1 %29, <4 x i16> %high, <4 x i16> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink4.sink = phi <4 x i16> [ %.sink4, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i16> %23, <4 x i16> %.sink4.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i16> %31
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z5clampDv2_ttt(<2 x i16> %amount, i16 zeroext %low, i16 zeroext %high) #7 {
  %1 = extractelement <2 x i16> %amount, i32 0
  %2 = icmp ult i16 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i16 %1, %high
  %high. = select i1 %4, i16 %high, i16 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i16 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <2 x i16> undef, i16 %.sink.sink, i32 0
  %7 = extractelement <2 x i16> %amount, i32 1
  %8 = icmp ult i16 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp ugt i16 %7, %high
  %high.2 = select i1 %10, i16 %high, i16 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i16 [ %low, %5 ], [ %high.2, %9 ]
  %12 = insertelement <2 x i16> %6, i16 %.sink1.sink, i32 1
  ret <2 x i16> %12
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z5clampDv3_ttt(<3 x i16> %amount, i16 zeroext %low, i16 zeroext %high) #7 {
  %1 = extractelement <3 x i16> %amount, i32 0
  %2 = icmp ult i16 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i16 %1, %high
  %high. = select i1 %4, i16 %high, i16 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i16 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <3 x i16> undef, i16 %.sink.sink, i32 0
  %7 = extractelement <3 x i16> %amount, i32 1
  %8 = icmp ult i16 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp ugt i16 %7, %high
  %high.3 = select i1 %10, i16 %high, i16 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i16 [ %low, %5 ], [ %high.3, %9 ]
  %12 = insertelement <3 x i16> %6, i16 %.sink1.sink, i32 1
  %13 = extractelement <3 x i16> %amount, i32 2
  %14 = icmp ult i16 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp ugt i16 %13, %high
  %high.4 = select i1 %16, i16 %high, i16 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i16 [ %low, %11 ], [ %high.4, %15 ]
  %18 = insertelement <3 x i16> %12, i16 %.sink2.sink, i32 2
  ret <3 x i16> %18
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z5clampDv4_ttt(<4 x i16> %amount, i16 zeroext %low, i16 zeroext %high) #7 {
  %1 = extractelement <4 x i16> %amount, i32 0
  %2 = icmp ult i16 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i16 %1, %high
  %high. = select i1 %4, i16 %high, i16 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %.sink.sink = phi i16 [ %low, %0 ], [ %high., %3 ]
  %6 = insertelement <4 x i16> undef, i16 %.sink.sink, i32 0
  %7 = extractelement <4 x i16> %amount, i32 1
  %8 = icmp ult i16 %7, %low
  br i1 %8, label %11, label %9

; <label>:9                                       ; preds = %5
  %10 = icmp ugt i16 %7, %high
  %high.4 = select i1 %10, i16 %high, i16 %7
  br label %11

; <label>:11                                      ; preds = %9, %5
  %.sink1.sink = phi i16 [ %low, %5 ], [ %high.4, %9 ]
  %12 = insertelement <4 x i16> %6, i16 %.sink1.sink, i32 1
  %13 = extractelement <4 x i16> %amount, i32 2
  %14 = icmp ult i16 %13, %low
  br i1 %14, label %17, label %15

; <label>:15                                      ; preds = %11
  %16 = icmp ugt i16 %13, %high
  %high.5 = select i1 %16, i16 %high, i16 %13
  br label %17

; <label>:17                                      ; preds = %15, %11
  %.sink2.sink = phi i16 [ %low, %11 ], [ %high.5, %15 ]
  %18 = insertelement <4 x i16> %12, i16 %.sink2.sink, i32 2
  %19 = extractelement <4 x i16> %amount, i32 3
  %20 = icmp ult i16 %19, %low
  br i1 %20, label %23, label %21

; <label>:21                                      ; preds = %17
  %22 = icmp ugt i16 %19, %high
  %high.6 = select i1 %22, i16 %high, i16 %19
  br label %23

; <label>:23                                      ; preds = %21, %17
  %.sink3.sink = phi i16 [ %low, %17 ], [ %high.6, %21 ]
  %24 = insertelement <4 x i16> %18, i16 %.sink3.sink, i32 3
  ret <4 x i16> %24
}

; Function Attrs: nounwind readnone
define i32 @_Z5clampiii(i32 %amount, i32 %low, i32 %high) #7 {
  %1 = icmp slt i32 %amount, %low
  br i1 %1, label %5, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp sgt i32 %amount, %high
  %4 = select i1 %3, i32 %high, i32 %amount
  br label %5

; <label>:5                                       ; preds = %2, %0
  %6 = phi i32 [ %4, %2 ], [ %low, %0 ]
  ret i32 %6
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z5clampDv2_iS_S_(<2 x i32> %amount, <2 x i32> %low, <2 x i32> %high) #7 {
  %1 = extractelement <2 x i32> %amount, i32 0
  %2 = extractelement <2 x i32> %low, i32 0
  %3 = icmp slt i32 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i32> %high, i32 0
  %6 = icmp sgt i32 %1, %5
  %.sink = select i1 %6, <2 x i32> %high, <2 x i32> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <2 x i32> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i32> %amount, i32 1
  %9 = extractelement <2 x i32> %low, i32 1
  %10 = icmp slt i32 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i32> %high, i32 1
  %13 = icmp sgt i32 %8, %12
  %.sink1 = select i1 %13, <2 x i32> %high, <2 x i32> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <2 x i32> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i32> %.sink.sink, <2 x i32> %.sink1.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i32> %15
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z5clampDv3_iS_S_(<3 x i32> %amount, <3 x i32> %low, <3 x i32> %high) #7 {
  %1 = extractelement <3 x i32> %amount, i32 0
  %2 = extractelement <3 x i32> %low, i32 0
  %3 = icmp slt i32 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i32> %high, i32 0
  %6 = icmp sgt i32 %1, %5
  %.sink = select i1 %6, <3 x i32> %high, <3 x i32> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <3 x i32> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i32> %amount, i32 1
  %9 = extractelement <3 x i32> %low, i32 1
  %10 = icmp slt i32 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i32> %high, i32 1
  %13 = icmp sgt i32 %8, %12
  %.sink1 = select i1 %13, <3 x i32> %high, <3 x i32> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <3 x i32> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i32> %.sink.sink, <3 x i32> %.sink1.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i32> %amount, i32 2
  %17 = extractelement <3 x i32> %low, i32 2
  %18 = icmp slt i32 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i32> %high, i32 2
  %21 = icmp sgt i32 %16, %20
  %.sink2 = select i1 %21, <3 x i32> %high, <3 x i32> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <3 x i32> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i32> %15, <3 x i32> %.sink2.sink, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i32> %23
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z5clampDv4_iS_S_(<4 x i32> %amount, <4 x i32> %low, <4 x i32> %high) #7 {
  %1 = extractelement <4 x i32> %amount, i32 0
  %2 = extractelement <4 x i32> %low, i32 0
  %3 = icmp slt i32 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i32> %high, i32 0
  %6 = icmp sgt i32 %1, %5
  %.sink = select i1 %6, <4 x i32> %high, <4 x i32> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <4 x i32> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i32> %amount, i32 1
  %9 = extractelement <4 x i32> %low, i32 1
  %10 = icmp slt i32 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i32> %high, i32 1
  %13 = icmp sgt i32 %8, %12
  %.sink1 = select i1 %13, <4 x i32> %high, <4 x i32> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <4 x i32> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i32> %.sink.sink, <4 x i32> %.sink1.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i32> %amount, i32 2
  %17 = extractelement <4 x i32> %low, i32 2
  %18 = icmp slt i32 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i32> %high, i32 2
  %21 = icmp sgt i32 %16, %20
  %.sink2 = select i1 %21, <4 x i32> %high, <4 x i32> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <4 x i32> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i32> %15, <4 x i32> %.sink2.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i32> %amount, i32 3
  %25 = extractelement <4 x i32> %low, i32 3
  %26 = icmp slt i32 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i32> %high, i32 3
  %29 = icmp sgt i32 %24, %28
  %.sink3 = select i1 %29, <4 x i32> %high, <4 x i32> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink3.sink = phi <4 x i32> [ %.sink3, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i32> %23, <4 x i32> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i32> %31
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z5clampDv2_iii(<2 x i32> %amount, i32 %low, i32 %high) #7 {
  %1 = extractelement <2 x i32> %amount, i32 0
  %2 = icmp slt i32 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i32 %1, %high
  %high. = select i1 %4, i32 %high, i32 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i32 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <2 x i32> undef, i32 %6, i32 0
  %8 = extractelement <2 x i32> %amount, i32 1
  %9 = icmp slt i32 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp sgt i32 %8, %high
  %high.1 = select i1 %11, i32 %high, i32 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i32 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <2 x i32> %7, i32 %13, i32 1
  ret <2 x i32> %14
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z5clampDv3_iii(<3 x i32> %amount, i32 %low, i32 %high) #7 {
  %1 = extractelement <3 x i32> %amount, i32 0
  %2 = icmp slt i32 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i32 %1, %high
  %high. = select i1 %4, i32 %high, i32 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i32 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <3 x i32> undef, i32 %6, i32 0
  %8 = extractelement <3 x i32> %amount, i32 1
  %9 = icmp slt i32 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp sgt i32 %8, %high
  %high.1 = select i1 %11, i32 %high, i32 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i32 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <3 x i32> %7, i32 %13, i32 1
  %15 = extractelement <3 x i32> %amount, i32 2
  %16 = icmp slt i32 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp sgt i32 %15, %high
  %high.2 = select i1 %18, i32 %high, i32 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i32 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <3 x i32> %14, i32 %20, i32 2
  ret <3 x i32> %21
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z5clampDv4_iii(<4 x i32> %amount, i32 %low, i32 %high) #7 {
  %1 = extractelement <4 x i32> %amount, i32 0
  %2 = icmp slt i32 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i32 %1, %high
  %high. = select i1 %4, i32 %high, i32 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i32 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x i32> undef, i32 %6, i32 0
  %8 = extractelement <4 x i32> %amount, i32 1
  %9 = icmp slt i32 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp sgt i32 %8, %high
  %high.1 = select i1 %11, i32 %high, i32 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i32 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x i32> %7, i32 %13, i32 1
  %15 = extractelement <4 x i32> %amount, i32 2
  %16 = icmp slt i32 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp sgt i32 %15, %high
  %high.2 = select i1 %18, i32 %high, i32 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i32 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x i32> %14, i32 %20, i32 2
  %22 = extractelement <4 x i32> %amount, i32 3
  %23 = icmp slt i32 %22, %low
  br i1 %23, label %26, label %24

; <label>:24                                      ; preds = %19
  %25 = icmp sgt i32 %22, %high
  %high.3 = select i1 %25, i32 %high, i32 %22
  br label %26

; <label>:26                                      ; preds = %24, %19
  %27 = phi i32 [ %low, %19 ], [ %high.3, %24 ]
  %28 = insertelement <4 x i32> %21, i32 %27, i32 3
  ret <4 x i32> %28
}

; Function Attrs: nounwind readnone
define i32 @_Z5clampjjj(i32 %amount, i32 %low, i32 %high) #7 {
  %1 = icmp ult i32 %amount, %low
  br i1 %1, label %5, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp ugt i32 %amount, %high
  %4 = select i1 %3, i32 %high, i32 %amount
  br label %5

; <label>:5                                       ; preds = %2, %0
  %6 = phi i32 [ %4, %2 ], [ %low, %0 ]
  ret i32 %6
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z5clampDv2_jS_S_(<2 x i32> %amount, <2 x i32> %low, <2 x i32> %high) #7 {
  %1 = extractelement <2 x i32> %amount, i32 0
  %2 = extractelement <2 x i32> %low, i32 0
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i32> %high, i32 0
  %6 = icmp ugt i32 %1, %5
  %.sink = select i1 %6, <2 x i32> %high, <2 x i32> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <2 x i32> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i32> %amount, i32 1
  %9 = extractelement <2 x i32> %low, i32 1
  %10 = icmp ult i32 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i32> %high, i32 1
  %13 = icmp ugt i32 %8, %12
  %.sink1 = select i1 %13, <2 x i32> %high, <2 x i32> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <2 x i32> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i32> %.sink.sink, <2 x i32> %.sink1.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i32> %15
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z5clampDv3_jS_S_(<3 x i32> %amount, <3 x i32> %low, <3 x i32> %high) #7 {
  %1 = extractelement <3 x i32> %amount, i32 0
  %2 = extractelement <3 x i32> %low, i32 0
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i32> %high, i32 0
  %6 = icmp ugt i32 %1, %5
  %.sink = select i1 %6, <3 x i32> %high, <3 x i32> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <3 x i32> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i32> %amount, i32 1
  %9 = extractelement <3 x i32> %low, i32 1
  %10 = icmp ult i32 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i32> %high, i32 1
  %13 = icmp ugt i32 %8, %12
  %.sink1 = select i1 %13, <3 x i32> %high, <3 x i32> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <3 x i32> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i32> %.sink.sink, <3 x i32> %.sink1.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i32> %amount, i32 2
  %17 = extractelement <3 x i32> %low, i32 2
  %18 = icmp ult i32 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i32> %high, i32 2
  %21 = icmp ugt i32 %16, %20
  %.sink2 = select i1 %21, <3 x i32> %high, <3 x i32> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <3 x i32> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i32> %15, <3 x i32> %.sink2.sink, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i32> %23
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z5clampDv4_jS_S_(<4 x i32> %amount, <4 x i32> %low, <4 x i32> %high) #7 {
  %1 = extractelement <4 x i32> %amount, i32 0
  %2 = extractelement <4 x i32> %low, i32 0
  %3 = icmp ult i32 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i32> %high, i32 0
  %6 = icmp ugt i32 %1, %5
  %.sink = select i1 %6, <4 x i32> %high, <4 x i32> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <4 x i32> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i32> %amount, i32 1
  %9 = extractelement <4 x i32> %low, i32 1
  %10 = icmp ult i32 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i32> %high, i32 1
  %13 = icmp ugt i32 %8, %12
  %.sink1 = select i1 %13, <4 x i32> %high, <4 x i32> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <4 x i32> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i32> %.sink.sink, <4 x i32> %.sink1.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i32> %amount, i32 2
  %17 = extractelement <4 x i32> %low, i32 2
  %18 = icmp ult i32 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i32> %high, i32 2
  %21 = icmp ugt i32 %16, %20
  %.sink2 = select i1 %21, <4 x i32> %high, <4 x i32> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <4 x i32> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i32> %15, <4 x i32> %.sink2.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i32> %amount, i32 3
  %25 = extractelement <4 x i32> %low, i32 3
  %26 = icmp ult i32 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i32> %high, i32 3
  %29 = icmp ugt i32 %24, %28
  %.sink3 = select i1 %29, <4 x i32> %high, <4 x i32> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink3.sink = phi <4 x i32> [ %.sink3, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i32> %23, <4 x i32> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i32> %31
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z5clampDv2_jjj(<2 x i32> %amount, i32 %low, i32 %high) #7 {
  %1 = extractelement <2 x i32> %amount, i32 0
  %2 = icmp ult i32 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i32 %1, %high
  %high. = select i1 %4, i32 %high, i32 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i32 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <2 x i32> undef, i32 %6, i32 0
  %8 = extractelement <2 x i32> %amount, i32 1
  %9 = icmp ult i32 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp ugt i32 %8, %high
  %high.1 = select i1 %11, i32 %high, i32 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i32 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <2 x i32> %7, i32 %13, i32 1
  ret <2 x i32> %14
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z5clampDv3_jjj(<3 x i32> %amount, i32 %low, i32 %high) #7 {
  %1 = extractelement <3 x i32> %amount, i32 0
  %2 = icmp ult i32 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i32 %1, %high
  %high. = select i1 %4, i32 %high, i32 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i32 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <3 x i32> undef, i32 %6, i32 0
  %8 = extractelement <3 x i32> %amount, i32 1
  %9 = icmp ult i32 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp ugt i32 %8, %high
  %high.1 = select i1 %11, i32 %high, i32 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i32 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <3 x i32> %7, i32 %13, i32 1
  %15 = extractelement <3 x i32> %amount, i32 2
  %16 = icmp ult i32 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp ugt i32 %15, %high
  %high.2 = select i1 %18, i32 %high, i32 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i32 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <3 x i32> %14, i32 %20, i32 2
  ret <3 x i32> %21
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z5clampDv4_jjj(<4 x i32> %amount, i32 %low, i32 %high) #7 {
  %1 = extractelement <4 x i32> %amount, i32 0
  %2 = icmp ult i32 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i32 %1, %high
  %high. = select i1 %4, i32 %high, i32 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i32 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x i32> undef, i32 %6, i32 0
  %8 = extractelement <4 x i32> %amount, i32 1
  %9 = icmp ult i32 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp ugt i32 %8, %high
  %high.1 = select i1 %11, i32 %high, i32 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i32 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x i32> %7, i32 %13, i32 1
  %15 = extractelement <4 x i32> %amount, i32 2
  %16 = icmp ult i32 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp ugt i32 %15, %high
  %high.2 = select i1 %18, i32 %high, i32 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i32 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x i32> %14, i32 %20, i32 2
  %22 = extractelement <4 x i32> %amount, i32 3
  %23 = icmp ult i32 %22, %low
  br i1 %23, label %26, label %24

; <label>:24                                      ; preds = %19
  %25 = icmp ugt i32 %22, %high
  %high.3 = select i1 %25, i32 %high, i32 %22
  br label %26

; <label>:26                                      ; preds = %24, %19
  %27 = phi i32 [ %low, %19 ], [ %high.3, %24 ]
  %28 = insertelement <4 x i32> %21, i32 %27, i32 3
  ret <4 x i32> %28
}

; Function Attrs: nounwind readnone
define i64 @_Z5clamplll(i64 %amount, i64 %low, i64 %high) #7 {
  %1 = icmp slt i64 %amount, %low
  br i1 %1, label %5, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp sgt i64 %amount, %high
  %4 = select i1 %3, i64 %high, i64 %amount
  br label %5

; <label>:5                                       ; preds = %2, %0
  %6 = phi i64 [ %4, %2 ], [ %low, %0 ]
  ret i64 %6
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z5clampDv2_lS_S_(<2 x i64> %amount, <2 x i64> %low, <2 x i64> %high) #7 {
  %1 = extractelement <2 x i64> %amount, i32 0
  %2 = extractelement <2 x i64> %low, i32 0
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i64> %high, i32 0
  %6 = icmp sgt i64 %1, %5
  %.sink = select i1 %6, <2 x i64> %high, <2 x i64> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <2 x i64> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i64> %amount, i32 1
  %9 = extractelement <2 x i64> %low, i32 1
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i64> %high, i32 1
  %13 = icmp sgt i64 %8, %12
  %.sink1 = select i1 %13, <2 x i64> %high, <2 x i64> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <2 x i64> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i64> %.sink.sink, <2 x i64> %.sink1.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i64> %15
}

; Function Attrs: nounwind
define void @_Z5clampDv3_lS_S_(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %amount, <3 x i64> %low, <3 x i64> %high) #5 {
  %1 = extractelement <3 x i64> %amount, i32 0
  %2 = extractelement <3 x i64> %low, i32 0
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i64> %high, i32 0
  %6 = icmp sgt i64 %1, %5
  %.sink = select i1 %6, <3 x i64> %high, <3 x i64> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <3 x i64> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i64> %amount, i32 1
  %9 = extractelement <3 x i64> %low, i32 1
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i64> %high, i32 1
  %13 = icmp sgt i64 %8, %12
  %.sink1 = select i1 %13, <3 x i64> %high, <3 x i64> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <3 x i64> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i64> %.sink.sink, <3 x i64> %.sink1.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i64> %amount, i32 2
  %17 = extractelement <3 x i64> %low, i32 2
  %18 = icmp slt i64 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i64> %high, i32 2
  %21 = icmp sgt i64 %16, %20
  %.sink2 = select i1 %21, <3 x i64> %high, <3 x i64> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <3 x i64> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i64> %15, <3 x i64> %.sink2.sink, <3 x i32> <i32 0, i32 1, i32 5>
  %24 = shufflevector <3 x i64> %23, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %25 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %24, <4 x i64>* %25, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z5clampDv4_lS_S_(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %amount, <4 x i64> %low, <4 x i64> %high) #5 {
  %1 = extractelement <4 x i64> %amount, i32 0
  %2 = extractelement <4 x i64> %low, i32 0
  %3 = icmp slt i64 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i64> %high, i32 0
  %6 = icmp sgt i64 %1, %5
  %.sink = select i1 %6, <4 x i64> %high, <4 x i64> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <4 x i64> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i64> %amount, i32 1
  %9 = extractelement <4 x i64> %low, i32 1
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i64> %high, i32 1
  %13 = icmp sgt i64 %8, %12
  %.sink1 = select i1 %13, <4 x i64> %high, <4 x i64> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <4 x i64> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i64> %.sink.sink, <4 x i64> %.sink1.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i64> %amount, i32 2
  %17 = extractelement <4 x i64> %low, i32 2
  %18 = icmp slt i64 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i64> %high, i32 2
  %21 = icmp sgt i64 %16, %20
  %.sink2 = select i1 %21, <4 x i64> %high, <4 x i64> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <4 x i64> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i64> %15, <4 x i64> %.sink2.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i64> %amount, i32 3
  %25 = extractelement <4 x i64> %low, i32 3
  %26 = icmp slt i64 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i64> %high, i32 3
  %29 = icmp sgt i64 %24, %28
  %.sink3 = select i1 %29, <4 x i64> %high, <4 x i64> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink3.sink = phi <4 x i64> [ %.sink3, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i64> %23, <4 x i64> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  store <4 x i64> %31, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z5clampDv2_lll(<2 x i64> %amount, i64 %low, i64 %high) #7 {
  %1 = extractelement <2 x i64> %amount, i32 0
  %2 = icmp slt i64 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i64 %1, %high
  %high. = select i1 %4, i64 %high, i64 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i64 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <2 x i64> undef, i64 %6, i32 0
  %8 = extractelement <2 x i64> %amount, i32 1
  %9 = icmp slt i64 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp sgt i64 %8, %high
  %high.1 = select i1 %11, i64 %high, i64 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i64 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <2 x i64> %7, i64 %13, i32 1
  ret <2 x i64> %14
}

; Function Attrs: nounwind
define void @_Z5clampDv3_lll(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %amount, i64 %low, i64 %high) #5 {
  %1 = extractelement <3 x i64> %amount, i32 0
  %2 = icmp slt i64 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i64 %1, %high
  %high. = select i1 %4, i64 %high, i64 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i64 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x i64> undef, i64 %6, i32 0
  %8 = extractelement <3 x i64> %amount, i32 1
  %9 = icmp slt i64 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp sgt i64 %8, %high
  %high.1 = select i1 %11, i64 %high, i64 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i64 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x i64> %7, i64 %13, i32 1
  %15 = extractelement <3 x i64> %amount, i32 2
  %16 = icmp slt i64 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp sgt i64 %15, %high
  %high.2 = select i1 %18, i64 %high, i64 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i64 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x i64> %14, i64 %20, i32 2
  %22 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %21, <4 x i64>* %22, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z5clampDv4_lll(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %amount, i64 %low, i64 %high) #5 {
  %1 = extractelement <4 x i64> %amount, i32 0
  %2 = icmp slt i64 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp sgt i64 %1, %high
  %high. = select i1 %4, i64 %high, i64 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i64 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x i64> undef, i64 %6, i32 0
  %8 = extractelement <4 x i64> %amount, i32 1
  %9 = icmp slt i64 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp sgt i64 %8, %high
  %high.1 = select i1 %11, i64 %high, i64 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i64 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x i64> %7, i64 %13, i32 1
  %15 = extractelement <4 x i64> %amount, i32 2
  %16 = icmp slt i64 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp sgt i64 %15, %high
  %high.2 = select i1 %18, i64 %high, i64 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i64 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x i64> %14, i64 %20, i32 2
  %22 = extractelement <4 x i64> %amount, i32 3
  %23 = icmp slt i64 %22, %low
  br i1 %23, label %26, label %24

; <label>:24                                      ; preds = %19
  %25 = icmp sgt i64 %22, %high
  %high.3 = select i1 %25, i64 %high, i64 %22
  br label %26

; <label>:26                                      ; preds = %24, %19
  %27 = phi i64 [ %low, %19 ], [ %high.3, %24 ]
  %28 = insertelement <4 x i64> %21, i64 %27, i32 3
  store <4 x i64> %28, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define i64 @_Z5clampyyy(i64 %amount, i64 %low, i64 %high) #7 {
  %1 = icmp ult i64 %amount, %low
  br i1 %1, label %5, label %2

; <label>:2                                       ; preds = %0
  %3 = icmp ugt i64 %amount, %high
  %4 = select i1 %3, i64 %high, i64 %amount
  br label %5

; <label>:5                                       ; preds = %2, %0
  %6 = phi i64 [ %4, %2 ], [ %low, %0 ]
  ret i64 %6
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z5clampDv2_yS_S_(<2 x i64> %amount, <2 x i64> %low, <2 x i64> %high) #7 {
  %1 = extractelement <2 x i64> %amount, i32 0
  %2 = extractelement <2 x i64> %low, i32 0
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <2 x i64> %high, i32 0
  %6 = icmp ugt i64 %1, %5
  %.sink = select i1 %6, <2 x i64> %high, <2 x i64> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <2 x i64> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <2 x i64> %amount, i32 1
  %9 = extractelement <2 x i64> %low, i32 1
  %10 = icmp ult i64 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <2 x i64> %high, i32 1
  %13 = icmp ugt i64 %8, %12
  %.sink1 = select i1 %13, <2 x i64> %high, <2 x i64> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <2 x i64> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <2 x i64> %.sink.sink, <2 x i64> %.sink1.sink, <2 x i32> <i32 0, i32 3>
  ret <2 x i64> %15
}

; Function Attrs: nounwind
define void @_Z5clampDv3_yS_S_(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %amount, <3 x i64> %low, <3 x i64> %high) #5 {
  %1 = extractelement <3 x i64> %amount, i32 0
  %2 = extractelement <3 x i64> %low, i32 0
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <3 x i64> %high, i32 0
  %6 = icmp ugt i64 %1, %5
  %.sink = select i1 %6, <3 x i64> %high, <3 x i64> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <3 x i64> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <3 x i64> %amount, i32 1
  %9 = extractelement <3 x i64> %low, i32 1
  %10 = icmp ult i64 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <3 x i64> %high, i32 1
  %13 = icmp ugt i64 %8, %12
  %.sink1 = select i1 %13, <3 x i64> %high, <3 x i64> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <3 x i64> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <3 x i64> %.sink.sink, <3 x i64> %.sink1.sink, <3 x i32> <i32 0, i32 4, i32 undef>
  %16 = extractelement <3 x i64> %amount, i32 2
  %17 = extractelement <3 x i64> %low, i32 2
  %18 = icmp ult i64 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <3 x i64> %high, i32 2
  %21 = icmp ugt i64 %16, %20
  %.sink2 = select i1 %21, <3 x i64> %high, <3 x i64> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <3 x i64> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <3 x i64> %15, <3 x i64> %.sink2.sink, <3 x i32> <i32 0, i32 1, i32 5>
  %24 = shufflevector <3 x i64> %23, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %25 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %24, <4 x i64>* %25, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z5clampDv4_yS_S_(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %amount, <4 x i64> %low, <4 x i64> %high) #5 {
  %1 = extractelement <4 x i64> %amount, i32 0
  %2 = extractelement <4 x i64> %low, i32 0
  %3 = icmp ult i64 %1, %2
  br i1 %3, label %7, label %4

; <label>:4                                       ; preds = %0
  %5 = extractelement <4 x i64> %high, i32 0
  %6 = icmp ugt i64 %1, %5
  %.sink = select i1 %6, <4 x i64> %high, <4 x i64> %amount
  br label %7

; <label>:7                                       ; preds = %4, %0
  %.sink.sink = phi <4 x i64> [ %.sink, %4 ], [ %low, %0 ]
  %8 = extractelement <4 x i64> %amount, i32 1
  %9 = extractelement <4 x i64> %low, i32 1
  %10 = icmp ult i64 %8, %9
  br i1 %10, label %14, label %11

; <label>:11                                      ; preds = %7
  %12 = extractelement <4 x i64> %high, i32 1
  %13 = icmp ugt i64 %8, %12
  %.sink1 = select i1 %13, <4 x i64> %high, <4 x i64> %amount
  br label %14

; <label>:14                                      ; preds = %11, %7
  %.sink1.sink = phi <4 x i64> [ %.sink1, %11 ], [ %low, %7 ]
  %15 = shufflevector <4 x i64> %.sink.sink, <4 x i64> %.sink1.sink, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %16 = extractelement <4 x i64> %amount, i32 2
  %17 = extractelement <4 x i64> %low, i32 2
  %18 = icmp ult i64 %16, %17
  br i1 %18, label %22, label %19

; <label>:19                                      ; preds = %14
  %20 = extractelement <4 x i64> %high, i32 2
  %21 = icmp ugt i64 %16, %20
  %.sink2 = select i1 %21, <4 x i64> %high, <4 x i64> %amount
  br label %22

; <label>:22                                      ; preds = %19, %14
  %.sink2.sink = phi <4 x i64> [ %.sink2, %19 ], [ %low, %14 ]
  %23 = shufflevector <4 x i64> %15, <4 x i64> %.sink2.sink, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %24 = extractelement <4 x i64> %amount, i32 3
  %25 = extractelement <4 x i64> %low, i32 3
  %26 = icmp ult i64 %24, %25
  br i1 %26, label %30, label %27

; <label>:27                                      ; preds = %22
  %28 = extractelement <4 x i64> %high, i32 3
  %29 = icmp ugt i64 %24, %28
  %.sink3 = select i1 %29, <4 x i64> %high, <4 x i64> %amount
  br label %30

; <label>:30                                      ; preds = %27, %22
  %.sink3.sink = phi <4 x i64> [ %.sink3, %27 ], [ %low, %22 ]
  %31 = shufflevector <4 x i64> %23, <4 x i64> %.sink3.sink, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  store <4 x i64> %31, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z5clampDv2_yyy(<2 x i64> %amount, i64 %low, i64 %high) #7 {
  %1 = extractelement <2 x i64> %amount, i32 0
  %2 = icmp ult i64 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i64 %1, %high
  %high. = select i1 %4, i64 %high, i64 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i64 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <2 x i64> undef, i64 %6, i32 0
  %8 = extractelement <2 x i64> %amount, i32 1
  %9 = icmp ult i64 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp ugt i64 %8, %high
  %high.1 = select i1 %11, i64 %high, i64 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i64 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <2 x i64> %7, i64 %13, i32 1
  ret <2 x i64> %14
}

; Function Attrs: nounwind
define void @_Z5clampDv3_yyy(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %amount, i64 %low, i64 %high) #5 {
  %1 = extractelement <3 x i64> %amount, i32 0
  %2 = icmp ult i64 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i64 %1, %high
  %high. = select i1 %4, i64 %high, i64 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i64 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x i64> undef, i64 %6, i32 0
  %8 = extractelement <3 x i64> %amount, i32 1
  %9 = icmp ult i64 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp ugt i64 %8, %high
  %high.1 = select i1 %11, i64 %high, i64 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i64 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x i64> %7, i64 %13, i32 1
  %15 = extractelement <3 x i64> %amount, i32 2
  %16 = icmp ult i64 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp ugt i64 %15, %high
  %high.2 = select i1 %18, i64 %high, i64 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i64 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x i64> %14, i64 %20, i32 2
  %22 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %21, <4 x i64>* %22, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z5clampDv4_yyy(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %amount, i64 %low, i64 %high) #5 {
  %1 = extractelement <4 x i64> %amount, i32 0
  %2 = icmp ult i64 %1, %low
  br i1 %2, label %5, label %3

; <label>:3                                       ; preds = %0
  %4 = icmp ugt i64 %1, %high
  %high. = select i1 %4, i64 %high, i64 %1
  br label %5

; <label>:5                                       ; preds = %3, %0
  %6 = phi i64 [ %low, %0 ], [ %high., %3 ]
  %7 = insertelement <4 x i64> undef, i64 %6, i32 0
  %8 = extractelement <4 x i64> %amount, i32 1
  %9 = icmp ult i64 %8, %low
  br i1 %9, label %12, label %10

; <label>:10                                      ; preds = %5
  %11 = icmp ugt i64 %8, %high
  %high.1 = select i1 %11, i64 %high, i64 %8
  br label %12

; <label>:12                                      ; preds = %10, %5
  %13 = phi i64 [ %low, %5 ], [ %high.1, %10 ]
  %14 = insertelement <4 x i64> %7, i64 %13, i32 1
  %15 = extractelement <4 x i64> %amount, i32 2
  %16 = icmp ult i64 %15, %low
  br i1 %16, label %19, label %17

; <label>:17                                      ; preds = %12
  %18 = icmp ugt i64 %15, %high
  %high.2 = select i1 %18, i64 %high, i64 %15
  br label %19

; <label>:19                                      ; preds = %17, %12
  %20 = phi i64 [ %low, %12 ], [ %high.2, %17 ]
  %21 = insertelement <4 x i64> %14, i64 %20, i32 2
  %22 = extractelement <4 x i64> %amount, i32 3
  %23 = icmp ult i64 %22, %low
  br i1 %23, label %26, label %24

; <label>:24                                      ; preds = %19
  %25 = icmp ugt i64 %22, %high
  %high.3 = select i1 %25, i64 %high, i64 %22
  br label %26

; <label>:26                                      ; preds = %24, %19
  %27 = phi i64 [ %low, %19 ], [ %high.3, %24 ]
  %28 = insertelement <4 x i64> %21, i64 %27, i32 3
  store <4 x i64> %28, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define float @_Z4fmaxff(float %v1, float %v2) #7 {
  %1 = fcmp ogt float %v1, %v2
  %2 = select i1 %1, float %v1, float %v2
  ret float %2
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4fmaxDv2_fS_(<2 x float> %v1, <2 x float> %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = fcmp ogt float %1, %2
  %.sink = select i1 %3, <2 x float> %v1, <2 x float> %v2
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = extractelement <2 x float> %v2, i32 1
  %6 = fcmp ogt float %4, %5
  %.sink1 = select i1 %6, <2 x float> %v1, <2 x float> %v2
  %7 = shufflevector <2 x float> %.sink, <2 x float> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4fmaxDv3_fS_(<3 x float> %v1, <3 x float> %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = fcmp ogt float %1, %2
  %.sink = select i1 %3, <3 x float> %v1, <3 x float> %v2
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = extractelement <3 x float> %v2, i32 1
  %6 = fcmp ogt float %4, %5
  %.sink1 = select i1 %6, <3 x float> %v1, <3 x float> %v2
  %7 = shufflevector <3 x float> %.sink, <3 x float> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = extractelement <3 x float> %v2, i32 2
  %10 = fcmp ogt float %8, %9
  %.sink2 = select i1 %10, <3 x float> %v1, <3 x float> %v2
  %11 = shufflevector <3 x float> %7, <3 x float> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x float> %11
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4fmaxDv4_fS_(<4 x float> %v1, <4 x float> %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = fcmp ogt float %1, %2
  %.sink = select i1 %3, <4 x float> %v1, <4 x float> %v2
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = extractelement <4 x float> %v2, i32 1
  %6 = fcmp ogt float %4, %5
  %.sink1 = select i1 %6, <4 x float> %v1, <4 x float> %v2
  %7 = shufflevector <4 x float> %.sink, <4 x float> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = extractelement <4 x float> %v2, i32 2
  %10 = fcmp ogt float %8, %9
  %.sink2 = select i1 %10, <4 x float> %v1, <4 x float> %v2
  %11 = shufflevector <4 x float> %7, <4 x float> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x float> %v1, i32 3
  %13 = extractelement <4 x float> %v2, i32 3
  %14 = fcmp ogt float %12, %13
  %.sink3 = select i1 %14, <4 x float> %v1, <4 x float> %v2
  %15 = shufflevector <4 x float> %11, <4 x float> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x float> %15
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4fmaxDv2_ff(<2 x float> %v1, float %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = fcmp ogt float %1, %v2
  %.v2 = select i1 %2, float %1, float %v2
  %3 = insertelement <2 x float> undef, float %.v2, i32 0
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = fcmp ogt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <2 x float> %3, float %6, i32 1
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4fmaxDv3_ff(<3 x float> %v1, float %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = fcmp ogt float %1, %v2
  %.v2 = select i1 %2, float %1, float %v2
  %3 = insertelement <3 x float> undef, float %.v2, i32 0
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = fcmp ogt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <3 x float> %3, float %6, i32 1
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = fcmp ogt float %8, %v2
  %.v21 = select i1 %9, float %8, float %v2
  %10 = insertelement <3 x float> %7, float %.v21, i32 2
  ret <3 x float> %10
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4fmaxDv4_ff(<4 x float> %v1, float %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = fcmp ogt float %1, %v2
  %.v2 = select i1 %2, float %1, float %v2
  %3 = insertelement <4 x float> undef, float %.v2, i32 0
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = fcmp ogt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <4 x float> %3, float %6, i32 1
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = fcmp ogt float %8, %v2
  %.v21 = select i1 %9, float %8, float %v2
  %10 = insertelement <4 x float> %7, float %.v21, i32 2
  %11 = extractelement <4 x float> %v1, i32 3
  %12 = fcmp ogt float %11, %v2
  %13 = select i1 %12, float %11, float %v2
  %14 = insertelement <4 x float> %10, float %13, i32 3
  ret <4 x float> %14
}

; Function Attrs: nounwind readnone
define float @_Z4fminff(float %v1, float %v2) #7 {
  %1 = fcmp olt float %v1, %v2
  %2 = select i1 %1, float %v1, float %v2
  ret float %2
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4fminDv2_fS_(<2 x float> %v1, <2 x float> %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = fcmp olt float %1, %2
  %.sink = select i1 %3, <2 x float> %v1, <2 x float> %v2
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = extractelement <2 x float> %v2, i32 1
  %6 = fcmp olt float %4, %5
  %.sink1 = select i1 %6, <2 x float> %v1, <2 x float> %v2
  %7 = shufflevector <2 x float> %.sink, <2 x float> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4fminDv3_fS_(<3 x float> %v1, <3 x float> %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = fcmp olt float %1, %2
  %.sink = select i1 %3, <3 x float> %v1, <3 x float> %v2
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = extractelement <3 x float> %v2, i32 1
  %6 = fcmp olt float %4, %5
  %.sink1 = select i1 %6, <3 x float> %v1, <3 x float> %v2
  %7 = shufflevector <3 x float> %.sink, <3 x float> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = extractelement <3 x float> %v2, i32 2
  %10 = fcmp olt float %8, %9
  %.sink2 = select i1 %10, <3 x float> %v1, <3 x float> %v2
  %11 = shufflevector <3 x float> %7, <3 x float> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x float> %11
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4fminDv4_fS_(<4 x float> %v1, <4 x float> %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = fcmp olt float %1, %2
  %.sink = select i1 %3, <4 x float> %v1, <4 x float> %v2
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = extractelement <4 x float> %v2, i32 1
  %6 = fcmp olt float %4, %5
  %.sink1 = select i1 %6, <4 x float> %v1, <4 x float> %v2
  %7 = shufflevector <4 x float> %.sink, <4 x float> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = extractelement <4 x float> %v2, i32 2
  %10 = fcmp olt float %8, %9
  %.sink2 = select i1 %10, <4 x float> %v1, <4 x float> %v2
  %11 = shufflevector <4 x float> %7, <4 x float> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x float> %v1, i32 3
  %13 = extractelement <4 x float> %v2, i32 3
  %14 = fcmp olt float %12, %13
  %.sink3 = select i1 %14, <4 x float> %v1, <4 x float> %v2
  %15 = shufflevector <4 x float> %11, <4 x float> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x float> %15
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z4fminDv2_ff(<2 x float> %v1, float %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = fcmp olt float %1, %v2
  %.v2 = select i1 %2, float %1, float %v2
  %3 = insertelement <2 x float> undef, float %.v2, i32 0
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = fcmp olt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <2 x float> %3, float %6, i32 1
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z4fminDv3_ff(<3 x float> %v1, float %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = fcmp olt float %1, %v2
  %.v2 = select i1 %2, float %1, float %v2
  %3 = insertelement <3 x float> undef, float %.v2, i32 0
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = fcmp olt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <3 x float> %3, float %6, i32 1
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = fcmp olt float %8, %v2
  %.v21 = select i1 %9, float %8, float %v2
  %10 = insertelement <3 x float> %7, float %.v21, i32 2
  ret <3 x float> %10
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z4fminDv4_ff(<4 x float> %v1, float %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = fcmp olt float %1, %v2
  %.v2 = select i1 %2, float %1, float %v2
  %3 = insertelement <4 x float> undef, float %.v2, i32 0
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = fcmp olt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <4 x float> %3, float %6, i32 1
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = fcmp olt float %8, %v2
  %.v21 = select i1 %9, float %8, float %v2
  %10 = insertelement <4 x float> %7, float %.v21, i32 2
  %11 = extractelement <4 x float> %v1, i32 3
  %12 = fcmp olt float %11, %v2
  %13 = select i1 %12, float %11, float %v2
  %14 = insertelement <4 x float> %10, float %13, i32 3
  ret <4 x float> %14
}

; Function Attrs: nounwind readnone
define signext i8 @_Z3maxcc(i8 signext %v1, i8 signext %v2) #7 {
  %1 = icmp sgt i8 %v1, %v2
  %.sink = select i1 %1, i8 %v1, i8 %v2
  ret i8 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z3maxDv2_cS_(<2 x i8> %v1, <2 x i8> %v2) #7 {
  %1 = extractelement <2 x i8> %v1, i32 0
  %2 = extractelement <2 x i8> %v2, i32 0
  %3 = icmp sgt i8 %1, %2
  %.sink1 = select i1 %3, <2 x i8> %v1, <2 x i8> %v2
  %4 = extractelement <2 x i8> %v1, i32 1
  %5 = extractelement <2 x i8> %v2, i32 1
  %6 = icmp sgt i8 %4, %5
  %.sink2 = select i1 %6, <2 x i8> %v1, <2 x i8> %v2
  %7 = shufflevector <2 x i8> %.sink1, <2 x i8> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i8> %7
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z3maxDv3_cS_(<3 x i8> %v1, <3 x i8> %v2) #7 {
  %1 = extractelement <3 x i8> %v1, i32 0
  %2 = extractelement <3 x i8> %v2, i32 0
  %3 = icmp sgt i8 %1, %2
  %.sink1 = select i1 %3, <3 x i8> %v1, <3 x i8> %v2
  %4 = extractelement <3 x i8> %v1, i32 1
  %5 = extractelement <3 x i8> %v2, i32 1
  %6 = icmp sgt i8 %4, %5
  %.sink2 = select i1 %6, <3 x i8> %v1, <3 x i8> %v2
  %7 = shufflevector <3 x i8> %.sink1, <3 x i8> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i8> %v1, i32 2
  %9 = extractelement <3 x i8> %v2, i32 2
  %10 = icmp sgt i8 %8, %9
  %.sink3 = select i1 %10, <3 x i8> %v1, <3 x i8> %v2
  %11 = shufflevector <3 x i8> %7, <3 x i8> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i8> %11
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z3maxDv4_cS_(<4 x i8> %v1, <4 x i8> %v2) #7 {
  %1 = extractelement <4 x i8> %v1, i32 0
  %2 = extractelement <4 x i8> %v2, i32 0
  %3 = icmp sgt i8 %1, %2
  %.sink1 = select i1 %3, <4 x i8> %v1, <4 x i8> %v2
  %4 = extractelement <4 x i8> %v1, i32 1
  %5 = extractelement <4 x i8> %v2, i32 1
  %6 = icmp sgt i8 %4, %5
  %.sink2 = select i1 %6, <4 x i8> %v1, <4 x i8> %v2
  %7 = shufflevector <4 x i8> %.sink1, <4 x i8> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i8> %v1, i32 2
  %9 = extractelement <4 x i8> %v2, i32 2
  %10 = icmp sgt i8 %8, %9
  %.sink3 = select i1 %10, <4 x i8> %v1, <4 x i8> %v2
  %11 = shufflevector <4 x i8> %7, <4 x i8> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i8> %v1, i32 3
  %13 = extractelement <4 x i8> %v2, i32 3
  %14 = icmp sgt i8 %12, %13
  %.sink4 = select i1 %14, <4 x i8> %v1, <4 x i8> %v2
  %15 = shufflevector <4 x i8> %11, <4 x i8> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i8> %15
}

; Function Attrs: nounwind readnone
define signext i16 @_Z3maxss(i16 signext %v1, i16 signext %v2) #7 {
  %1 = icmp sgt i16 %v1, %v2
  %.sink = select i1 %1, i16 %v1, i16 %v2
  ret i16 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z3maxDv2_sS_(<2 x i16> %v1, <2 x i16> %v2) #7 {
  %1 = extractelement <2 x i16> %v1, i32 0
  %2 = extractelement <2 x i16> %v2, i32 0
  %3 = icmp sgt i16 %1, %2
  %.sink1 = select i1 %3, <2 x i16> %v1, <2 x i16> %v2
  %4 = extractelement <2 x i16> %v1, i32 1
  %5 = extractelement <2 x i16> %v2, i32 1
  %6 = icmp sgt i16 %4, %5
  %.sink2 = select i1 %6, <2 x i16> %v1, <2 x i16> %v2
  %7 = shufflevector <2 x i16> %.sink1, <2 x i16> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i16> %7
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z3maxDv3_sS_(<3 x i16> %v1, <3 x i16> %v2) #7 {
  %1 = extractelement <3 x i16> %v1, i32 0
  %2 = extractelement <3 x i16> %v2, i32 0
  %3 = icmp sgt i16 %1, %2
  %.sink1 = select i1 %3, <3 x i16> %v1, <3 x i16> %v2
  %4 = extractelement <3 x i16> %v1, i32 1
  %5 = extractelement <3 x i16> %v2, i32 1
  %6 = icmp sgt i16 %4, %5
  %.sink2 = select i1 %6, <3 x i16> %v1, <3 x i16> %v2
  %7 = shufflevector <3 x i16> %.sink1, <3 x i16> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i16> %v1, i32 2
  %9 = extractelement <3 x i16> %v2, i32 2
  %10 = icmp sgt i16 %8, %9
  %.sink3 = select i1 %10, <3 x i16> %v1, <3 x i16> %v2
  %11 = shufflevector <3 x i16> %7, <3 x i16> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i16> %11
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z3maxDv4_sS_(<4 x i16> %v1, <4 x i16> %v2) #7 {
  %1 = extractelement <4 x i16> %v1, i32 0
  %2 = extractelement <4 x i16> %v2, i32 0
  %3 = icmp sgt i16 %1, %2
  %.sink1 = select i1 %3, <4 x i16> %v1, <4 x i16> %v2
  %4 = extractelement <4 x i16> %v1, i32 1
  %5 = extractelement <4 x i16> %v2, i32 1
  %6 = icmp sgt i16 %4, %5
  %.sink2 = select i1 %6, <4 x i16> %v1, <4 x i16> %v2
  %7 = shufflevector <4 x i16> %.sink1, <4 x i16> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i16> %v1, i32 2
  %9 = extractelement <4 x i16> %v2, i32 2
  %10 = icmp sgt i16 %8, %9
  %.sink3 = select i1 %10, <4 x i16> %v1, <4 x i16> %v2
  %11 = shufflevector <4 x i16> %7, <4 x i16> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i16> %v1, i32 3
  %13 = extractelement <4 x i16> %v2, i32 3
  %14 = icmp sgt i16 %12, %13
  %.sink4 = select i1 %14, <4 x i16> %v1, <4 x i16> %v2
  %15 = shufflevector <4 x i16> %11, <4 x i16> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i16> %15
}

; Function Attrs: nounwind readnone
define i32 @_Z3maxii(i32 %v1, i32 %v2) #7 {
  %1 = icmp sgt i32 %v1, %v2
  %2 = select i1 %1, i32 %v1, i32 %v2
  ret i32 %2
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z3maxDv2_iS_(<2 x i32> %v1, <2 x i32> %v2) #7 {
  %1 = extractelement <2 x i32> %v1, i32 0
  %2 = extractelement <2 x i32> %v2, i32 0
  %3 = icmp sgt i32 %1, %2
  %.sink = select i1 %3, <2 x i32> %v1, <2 x i32> %v2
  %4 = extractelement <2 x i32> %v1, i32 1
  %5 = extractelement <2 x i32> %v2, i32 1
  %6 = icmp sgt i32 %4, %5
  %.sink1 = select i1 %6, <2 x i32> %v1, <2 x i32> %v2
  %7 = shufflevector <2 x i32> %.sink, <2 x i32> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i32> %7
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z3maxDv3_iS_(<3 x i32> %v1, <3 x i32> %v2) #7 {
  %1 = extractelement <3 x i32> %v1, i32 0
  %2 = extractelement <3 x i32> %v2, i32 0
  %3 = icmp sgt i32 %1, %2
  %.sink = select i1 %3, <3 x i32> %v1, <3 x i32> %v2
  %4 = extractelement <3 x i32> %v1, i32 1
  %5 = extractelement <3 x i32> %v2, i32 1
  %6 = icmp sgt i32 %4, %5
  %.sink1 = select i1 %6, <3 x i32> %v1, <3 x i32> %v2
  %7 = shufflevector <3 x i32> %.sink, <3 x i32> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i32> %v1, i32 2
  %9 = extractelement <3 x i32> %v2, i32 2
  %10 = icmp sgt i32 %8, %9
  %.sink2 = select i1 %10, <3 x i32> %v1, <3 x i32> %v2
  %11 = shufflevector <3 x i32> %7, <3 x i32> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i32> %11
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z3maxDv4_iS_(<4 x i32> %v1, <4 x i32> %v2) #7 {
  %1 = extractelement <4 x i32> %v1, i32 0
  %2 = extractelement <4 x i32> %v2, i32 0
  %3 = icmp sgt i32 %1, %2
  %.sink = select i1 %3, <4 x i32> %v1, <4 x i32> %v2
  %4 = extractelement <4 x i32> %v1, i32 1
  %5 = extractelement <4 x i32> %v2, i32 1
  %6 = icmp sgt i32 %4, %5
  %.sink1 = select i1 %6, <4 x i32> %v1, <4 x i32> %v2
  %7 = shufflevector <4 x i32> %.sink, <4 x i32> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i32> %v1, i32 2
  %9 = extractelement <4 x i32> %v2, i32 2
  %10 = icmp sgt i32 %8, %9
  %.sink2 = select i1 %10, <4 x i32> %v1, <4 x i32> %v2
  %11 = shufflevector <4 x i32> %7, <4 x i32> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i32> %v1, i32 3
  %13 = extractelement <4 x i32> %v2, i32 3
  %14 = icmp sgt i32 %12, %13
  %.sink3 = select i1 %14, <4 x i32> %v1, <4 x i32> %v2
  %15 = shufflevector <4 x i32> %11, <4 x i32> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i32> %15
}

; Function Attrs: nounwind readnone
define i64 @_Z3maxxx(i64 %v1, i64 %v2) #7 {
  %1 = icmp sgt i64 %v1, %v2
  %2 = select i1 %1, i64 %v1, i64 %v2
  ret i64 %2
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z3maxDv2_lS_(<2 x i64> %v1, <2 x i64> %v2) #7 {
  %1 = extractelement <2 x i64> %v1, i32 0
  %2 = extractelement <2 x i64> %v2, i32 0
  %3 = icmp sgt i64 %1, %2
  %.sink = select i1 %3, <2 x i64> %v1, <2 x i64> %v2
  %4 = extractelement <2 x i64> %v1, i32 1
  %5 = extractelement <2 x i64> %v2, i32 1
  %6 = icmp sgt i64 %4, %5
  %.sink1 = select i1 %6, <2 x i64> %v1, <2 x i64> %v2
  %7 = shufflevector <2 x i64> %.sink, <2 x i64> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i64> %7
}

; Function Attrs: nounwind
define void @_Z3maxDv3_lS_(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %v1, <3 x i64> %v2) #5 {
  %1 = extractelement <3 x i64> %v1, i32 0
  %2 = extractelement <3 x i64> %v2, i32 0
  %3 = icmp sgt i64 %1, %2
  %.sink = select i1 %3, <3 x i64> %v1, <3 x i64> %v2
  %4 = extractelement <3 x i64> %v1, i32 1
  %5 = extractelement <3 x i64> %v2, i32 1
  %6 = icmp sgt i64 %4, %5
  %.sink1 = select i1 %6, <3 x i64> %v1, <3 x i64> %v2
  %7 = shufflevector <3 x i64> %.sink, <3 x i64> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i64> %v1, i32 2
  %9 = extractelement <3 x i64> %v2, i32 2
  %10 = icmp sgt i64 %8, %9
  %.sink2 = select i1 %10, <3 x i64> %v1, <3 x i64> %v2
  %11 = shufflevector <3 x i64> %7, <3 x i64> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  %12 = shufflevector <3 x i64> %11, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %13 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z3maxDv4_lS_(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %v1, <4 x i64> %v2) #5 {
  %1 = extractelement <4 x i64> %v1, i32 0
  %2 = extractelement <4 x i64> %v2, i32 0
  %3 = icmp sgt i64 %1, %2
  %.sink = select i1 %3, <4 x i64> %v1, <4 x i64> %v2
  %4 = extractelement <4 x i64> %v1, i32 1
  %5 = extractelement <4 x i64> %v2, i32 1
  %6 = icmp sgt i64 %4, %5
  %.sink1 = select i1 %6, <4 x i64> %v1, <4 x i64> %v2
  %7 = shufflevector <4 x i64> %.sink, <4 x i64> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i64> %v1, i32 2
  %9 = extractelement <4 x i64> %v2, i32 2
  %10 = icmp sgt i64 %8, %9
  %.sink2 = select i1 %10, <4 x i64> %v1, <4 x i64> %v2
  %11 = shufflevector <4 x i64> %7, <4 x i64> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i64> %v1, i32 3
  %13 = extractelement <4 x i64> %v2, i32 3
  %14 = icmp sgt i64 %12, %13
  %.sink3 = select i1 %14, <4 x i64> %v1, <4 x i64> %v2
  %15 = shufflevector <4 x i64> %11, <4 x i64> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  store <4 x i64> %15, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define zeroext i8 @_Z3maxhh(i8 zeroext %v1, i8 zeroext %v2) #7 {
  %1 = icmp ugt i8 %v1, %v2
  %.sink = select i1 %1, i8 %v1, i8 %v2
  ret i8 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z3maxDv2_hS_(<2 x i8> %v1, <2 x i8> %v2) #7 {
  %1 = extractelement <2 x i8> %v1, i32 0
  %2 = extractelement <2 x i8> %v2, i32 0
  %3 = icmp ugt i8 %1, %2
  %.sink1 = select i1 %3, <2 x i8> %v1, <2 x i8> %v2
  %4 = extractelement <2 x i8> %v1, i32 1
  %5 = extractelement <2 x i8> %v2, i32 1
  %6 = icmp ugt i8 %4, %5
  %.sink2 = select i1 %6, <2 x i8> %v1, <2 x i8> %v2
  %7 = shufflevector <2 x i8> %.sink1, <2 x i8> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i8> %7
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z3maxDv3_hS_(<3 x i8> %v1, <3 x i8> %v2) #7 {
  %1 = extractelement <3 x i8> %v1, i32 0
  %2 = extractelement <3 x i8> %v2, i32 0
  %3 = icmp ugt i8 %1, %2
  %.sink1 = select i1 %3, <3 x i8> %v1, <3 x i8> %v2
  %4 = extractelement <3 x i8> %v1, i32 1
  %5 = extractelement <3 x i8> %v2, i32 1
  %6 = icmp ugt i8 %4, %5
  %.sink2 = select i1 %6, <3 x i8> %v1, <3 x i8> %v2
  %7 = shufflevector <3 x i8> %.sink1, <3 x i8> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i8> %v1, i32 2
  %9 = extractelement <3 x i8> %v2, i32 2
  %10 = icmp ugt i8 %8, %9
  %.sink3 = select i1 %10, <3 x i8> %v1, <3 x i8> %v2
  %11 = shufflevector <3 x i8> %7, <3 x i8> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i8> %11
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z3maxDv4_hS_(<4 x i8> %v1, <4 x i8> %v2) #7 {
  %1 = extractelement <4 x i8> %v1, i32 0
  %2 = extractelement <4 x i8> %v2, i32 0
  %3 = icmp ugt i8 %1, %2
  %.sink1 = select i1 %3, <4 x i8> %v1, <4 x i8> %v2
  %4 = extractelement <4 x i8> %v1, i32 1
  %5 = extractelement <4 x i8> %v2, i32 1
  %6 = icmp ugt i8 %4, %5
  %.sink2 = select i1 %6, <4 x i8> %v1, <4 x i8> %v2
  %7 = shufflevector <4 x i8> %.sink1, <4 x i8> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i8> %v1, i32 2
  %9 = extractelement <4 x i8> %v2, i32 2
  %10 = icmp ugt i8 %8, %9
  %.sink3 = select i1 %10, <4 x i8> %v1, <4 x i8> %v2
  %11 = shufflevector <4 x i8> %7, <4 x i8> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i8> %v1, i32 3
  %13 = extractelement <4 x i8> %v2, i32 3
  %14 = icmp ugt i8 %12, %13
  %.sink4 = select i1 %14, <4 x i8> %v1, <4 x i8> %v2
  %15 = shufflevector <4 x i8> %11, <4 x i8> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i8> %15
}

; Function Attrs: nounwind readnone
define zeroext i16 @_Z3maxtt(i16 zeroext %v1, i16 zeroext %v2) #7 {
  %1 = icmp ugt i16 %v1, %v2
  %.sink = select i1 %1, i16 %v1, i16 %v2
  ret i16 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z3maxDv2_tS_(<2 x i16> %v1, <2 x i16> %v2) #7 {
  %1 = extractelement <2 x i16> %v1, i32 0
  %2 = extractelement <2 x i16> %v2, i32 0
  %3 = icmp ugt i16 %1, %2
  %.sink1 = select i1 %3, <2 x i16> %v1, <2 x i16> %v2
  %4 = extractelement <2 x i16> %v1, i32 1
  %5 = extractelement <2 x i16> %v2, i32 1
  %6 = icmp ugt i16 %4, %5
  %.sink2 = select i1 %6, <2 x i16> %v1, <2 x i16> %v2
  %7 = shufflevector <2 x i16> %.sink1, <2 x i16> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i16> %7
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z3maxDv3_tS_(<3 x i16> %v1, <3 x i16> %v2) #7 {
  %1 = extractelement <3 x i16> %v1, i32 0
  %2 = extractelement <3 x i16> %v2, i32 0
  %3 = icmp ugt i16 %1, %2
  %.sink1 = select i1 %3, <3 x i16> %v1, <3 x i16> %v2
  %4 = extractelement <3 x i16> %v1, i32 1
  %5 = extractelement <3 x i16> %v2, i32 1
  %6 = icmp ugt i16 %4, %5
  %.sink2 = select i1 %6, <3 x i16> %v1, <3 x i16> %v2
  %7 = shufflevector <3 x i16> %.sink1, <3 x i16> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i16> %v1, i32 2
  %9 = extractelement <3 x i16> %v2, i32 2
  %10 = icmp ugt i16 %8, %9
  %.sink3 = select i1 %10, <3 x i16> %v1, <3 x i16> %v2
  %11 = shufflevector <3 x i16> %7, <3 x i16> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i16> %11
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z3maxDv4_tS_(<4 x i16> %v1, <4 x i16> %v2) #7 {
  %1 = extractelement <4 x i16> %v1, i32 0
  %2 = extractelement <4 x i16> %v2, i32 0
  %3 = icmp ugt i16 %1, %2
  %.sink1 = select i1 %3, <4 x i16> %v1, <4 x i16> %v2
  %4 = extractelement <4 x i16> %v1, i32 1
  %5 = extractelement <4 x i16> %v2, i32 1
  %6 = icmp ugt i16 %4, %5
  %.sink2 = select i1 %6, <4 x i16> %v1, <4 x i16> %v2
  %7 = shufflevector <4 x i16> %.sink1, <4 x i16> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i16> %v1, i32 2
  %9 = extractelement <4 x i16> %v2, i32 2
  %10 = icmp ugt i16 %8, %9
  %.sink3 = select i1 %10, <4 x i16> %v1, <4 x i16> %v2
  %11 = shufflevector <4 x i16> %7, <4 x i16> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i16> %v1, i32 3
  %13 = extractelement <4 x i16> %v2, i32 3
  %14 = icmp ugt i16 %12, %13
  %.sink4 = select i1 %14, <4 x i16> %v1, <4 x i16> %v2
  %15 = shufflevector <4 x i16> %11, <4 x i16> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i16> %15
}

; Function Attrs: nounwind readnone
define i32 @_Z3maxjj(i32 %v1, i32 %v2) #7 {
  %1 = icmp ugt i32 %v1, %v2
  %2 = select i1 %1, i32 %v1, i32 %v2
  ret i32 %2
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z3maxDv2_jS_(<2 x i32> %v1, <2 x i32> %v2) #7 {
  %1 = extractelement <2 x i32> %v1, i32 0
  %2 = extractelement <2 x i32> %v2, i32 0
  %3 = icmp ugt i32 %1, %2
  %.sink = select i1 %3, <2 x i32> %v1, <2 x i32> %v2
  %4 = extractelement <2 x i32> %v1, i32 1
  %5 = extractelement <2 x i32> %v2, i32 1
  %6 = icmp ugt i32 %4, %5
  %.sink1 = select i1 %6, <2 x i32> %v1, <2 x i32> %v2
  %7 = shufflevector <2 x i32> %.sink, <2 x i32> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i32> %7
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z3maxDv3_jS_(<3 x i32> %v1, <3 x i32> %v2) #7 {
  %1 = extractelement <3 x i32> %v1, i32 0
  %2 = extractelement <3 x i32> %v2, i32 0
  %3 = icmp ugt i32 %1, %2
  %.sink = select i1 %3, <3 x i32> %v1, <3 x i32> %v2
  %4 = extractelement <3 x i32> %v1, i32 1
  %5 = extractelement <3 x i32> %v2, i32 1
  %6 = icmp ugt i32 %4, %5
  %.sink1 = select i1 %6, <3 x i32> %v1, <3 x i32> %v2
  %7 = shufflevector <3 x i32> %.sink, <3 x i32> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i32> %v1, i32 2
  %9 = extractelement <3 x i32> %v2, i32 2
  %10 = icmp ugt i32 %8, %9
  %.sink2 = select i1 %10, <3 x i32> %v1, <3 x i32> %v2
  %11 = shufflevector <3 x i32> %7, <3 x i32> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i32> %11
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z3maxDv4_jS_(<4 x i32> %v1, <4 x i32> %v2) #7 {
  %1 = extractelement <4 x i32> %v1, i32 0
  %2 = extractelement <4 x i32> %v2, i32 0
  %3 = icmp ugt i32 %1, %2
  %.sink = select i1 %3, <4 x i32> %v1, <4 x i32> %v2
  %4 = extractelement <4 x i32> %v1, i32 1
  %5 = extractelement <4 x i32> %v2, i32 1
  %6 = icmp ugt i32 %4, %5
  %.sink1 = select i1 %6, <4 x i32> %v1, <4 x i32> %v2
  %7 = shufflevector <4 x i32> %.sink, <4 x i32> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i32> %v1, i32 2
  %9 = extractelement <4 x i32> %v2, i32 2
  %10 = icmp ugt i32 %8, %9
  %.sink2 = select i1 %10, <4 x i32> %v1, <4 x i32> %v2
  %11 = shufflevector <4 x i32> %7, <4 x i32> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i32> %v1, i32 3
  %13 = extractelement <4 x i32> %v2, i32 3
  %14 = icmp ugt i32 %12, %13
  %.sink3 = select i1 %14, <4 x i32> %v1, <4 x i32> %v2
  %15 = shufflevector <4 x i32> %11, <4 x i32> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i32> %15
}

; Function Attrs: nounwind readnone
define i64 @_Z3maxyy(i64 %v1, i64 %v2) #7 {
  %1 = icmp ugt i64 %v1, %v2
  %2 = select i1 %1, i64 %v1, i64 %v2
  ret i64 %2
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z3maxDv2_yS_(<2 x i64> %v1, <2 x i64> %v2) #7 {
  %1 = extractelement <2 x i64> %v1, i32 0
  %2 = extractelement <2 x i64> %v2, i32 0
  %3 = icmp ugt i64 %1, %2
  %.sink = select i1 %3, <2 x i64> %v1, <2 x i64> %v2
  %4 = extractelement <2 x i64> %v1, i32 1
  %5 = extractelement <2 x i64> %v2, i32 1
  %6 = icmp ugt i64 %4, %5
  %.sink1 = select i1 %6, <2 x i64> %v1, <2 x i64> %v2
  %7 = shufflevector <2 x i64> %.sink, <2 x i64> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i64> %7
}

; Function Attrs: nounwind
define void @_Z3maxDv3_yS_(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %v1, <3 x i64> %v2) #5 {
  %1 = extractelement <3 x i64> %v1, i32 0
  %2 = extractelement <3 x i64> %v2, i32 0
  %3 = icmp ugt i64 %1, %2
  %.sink = select i1 %3, <3 x i64> %v1, <3 x i64> %v2
  %4 = extractelement <3 x i64> %v1, i32 1
  %5 = extractelement <3 x i64> %v2, i32 1
  %6 = icmp ugt i64 %4, %5
  %.sink1 = select i1 %6, <3 x i64> %v1, <3 x i64> %v2
  %7 = shufflevector <3 x i64> %.sink, <3 x i64> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i64> %v1, i32 2
  %9 = extractelement <3 x i64> %v2, i32 2
  %10 = icmp ugt i64 %8, %9
  %.sink2 = select i1 %10, <3 x i64> %v1, <3 x i64> %v2
  %11 = shufflevector <3 x i64> %7, <3 x i64> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  %12 = shufflevector <3 x i64> %11, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %13 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z3maxDv4_yS_(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %v1, <4 x i64> %v2) #5 {
  %1 = extractelement <4 x i64> %v1, i32 0
  %2 = extractelement <4 x i64> %v2, i32 0
  %3 = icmp ugt i64 %1, %2
  %.sink = select i1 %3, <4 x i64> %v1, <4 x i64> %v2
  %4 = extractelement <4 x i64> %v1, i32 1
  %5 = extractelement <4 x i64> %v2, i32 1
  %6 = icmp ugt i64 %4, %5
  %.sink1 = select i1 %6, <4 x i64> %v1, <4 x i64> %v2
  %7 = shufflevector <4 x i64> %.sink, <4 x i64> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i64> %v1, i32 2
  %9 = extractelement <4 x i64> %v2, i32 2
  %10 = icmp ugt i64 %8, %9
  %.sink2 = select i1 %10, <4 x i64> %v1, <4 x i64> %v2
  %11 = shufflevector <4 x i64> %7, <4 x i64> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i64> %v1, i32 3
  %13 = extractelement <4 x i64> %v2, i32 3
  %14 = icmp ugt i64 %12, %13
  %.sink3 = select i1 %14, <4 x i64> %v1, <4 x i64> %v2
  %15 = shufflevector <4 x i64> %11, <4 x i64> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  store <4 x i64> %15, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define float @_Z3maxff(float %v1, float %v2) #7 {
  %1 = fcmp ogt float %v1, %v2
  %2 = select i1 %1, float %v1, float %v2
  ret float %2
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z3maxDv2_fS_(<2 x float> %v1, <2 x float> %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = fcmp ogt float %1, %2
  %.sink.i = select i1 %3, <2 x float> %v1, <2 x float> %v2
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = extractelement <2 x float> %v2, i32 1
  %6 = fcmp ogt float %4, %5
  %.sink1.i = select i1 %6, <2 x float> %v1, <2 x float> %v2
  %7 = shufflevector <2 x float> %.sink.i, <2 x float> %.sink1.i, <2 x i32> <i32 0, i32 3>
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z3maxDv2_ff(<2 x float> %v1, float %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = fcmp ogt float %1, %v2
  %.v2.i = select i1 %2, float %1, float %v2
  %3 = insertelement <2 x float> undef, float %.v2.i, i32 0
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = fcmp ogt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <2 x float> %3, float %6, i32 1
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z3maxDv3_fS_(<3 x float> %v1, <3 x float> %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = fcmp ogt float %1, %2
  %.sink.i = select i1 %3, <3 x float> %v1, <3 x float> %v2
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = extractelement <3 x float> %v2, i32 1
  %6 = fcmp ogt float %4, %5
  %.sink1.i = select i1 %6, <3 x float> %v1, <3 x float> %v2
  %7 = shufflevector <3 x float> %.sink.i, <3 x float> %.sink1.i, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = extractelement <3 x float> %v2, i32 2
  %10 = fcmp ogt float %8, %9
  %.sink2.i = select i1 %10, <3 x float> %v1, <3 x float> %v2
  %11 = shufflevector <3 x float> %7, <3 x float> %.sink2.i, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x float> %11
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z3maxDv3_ff(<3 x float> %v1, float %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = fcmp ogt float %1, %v2
  %.v2.i = select i1 %2, float %1, float %v2
  %3 = insertelement <3 x float> undef, float %.v2.i, i32 0
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = fcmp ogt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <3 x float> %3, float %6, i32 1
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = fcmp ogt float %8, %v2
  %.v21.i = select i1 %9, float %8, float %v2
  %10 = insertelement <3 x float> %7, float %.v21.i, i32 2
  ret <3 x float> %10
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z3maxDv4_fS_(<4 x float> %v1, <4 x float> %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = fcmp ogt float %1, %2
  %.sink.i = select i1 %3, <4 x float> %v1, <4 x float> %v2
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = extractelement <4 x float> %v2, i32 1
  %6 = fcmp ogt float %4, %5
  %.sink1.i = select i1 %6, <4 x float> %v1, <4 x float> %v2
  %7 = shufflevector <4 x float> %.sink.i, <4 x float> %.sink1.i, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = extractelement <4 x float> %v2, i32 2
  %10 = fcmp ogt float %8, %9
  %.sink2.i = select i1 %10, <4 x float> %v1, <4 x float> %v2
  %11 = shufflevector <4 x float> %7, <4 x float> %.sink2.i, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x float> %v1, i32 3
  %13 = extractelement <4 x float> %v2, i32 3
  %14 = fcmp ogt float %12, %13
  %.sink3.i = select i1 %14, <4 x float> %v1, <4 x float> %v2
  %15 = shufflevector <4 x float> %11, <4 x float> %.sink3.i, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x float> %15
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z3maxDv4_ff(<4 x float> %v1, float %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = fcmp ogt float %1, %v2
  %.v2.i = select i1 %2, float %1, float %v2
  %3 = insertelement <4 x float> undef, float %.v2.i, i32 0
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = fcmp ogt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <4 x float> %3, float %6, i32 1
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = fcmp ogt float %8, %v2
  %.v21.i = select i1 %9, float %8, float %v2
  %10 = insertelement <4 x float> %7, float %.v21.i, i32 2
  %11 = extractelement <4 x float> %v1, i32 3
  %12 = fcmp ogt float %11, %v2
  %13 = select i1 %12, float %11, float %v2
  %14 = insertelement <4 x float> %10, float %13, i32 3
  ret <4 x float> %14
}

; Function Attrs: nounwind readnone
define signext i8 @_Z3mincc(i8 signext %v1, i8 signext %v2) #7 {
  %1 = icmp slt i8 %v1, %v2
  %.sink = select i1 %1, i8 %v1, i8 %v2
  ret i8 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z3minDv2_cS_(<2 x i8> %v1, <2 x i8> %v2) #7 {
  %1 = extractelement <2 x i8> %v1, i32 0
  %2 = extractelement <2 x i8> %v2, i32 0
  %3 = icmp slt i8 %1, %2
  %.sink1 = select i1 %3, <2 x i8> %v1, <2 x i8> %v2
  %4 = extractelement <2 x i8> %v1, i32 1
  %5 = extractelement <2 x i8> %v2, i32 1
  %6 = icmp slt i8 %4, %5
  %.sink2 = select i1 %6, <2 x i8> %v1, <2 x i8> %v2
  %7 = shufflevector <2 x i8> %.sink1, <2 x i8> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i8> %7
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z3minDv3_cS_(<3 x i8> %v1, <3 x i8> %v2) #7 {
  %1 = extractelement <3 x i8> %v1, i32 0
  %2 = extractelement <3 x i8> %v2, i32 0
  %3 = icmp slt i8 %1, %2
  %.sink1 = select i1 %3, <3 x i8> %v1, <3 x i8> %v2
  %4 = extractelement <3 x i8> %v1, i32 1
  %5 = extractelement <3 x i8> %v2, i32 1
  %6 = icmp slt i8 %4, %5
  %.sink2 = select i1 %6, <3 x i8> %v1, <3 x i8> %v2
  %7 = shufflevector <3 x i8> %.sink1, <3 x i8> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i8> %v1, i32 2
  %9 = extractelement <3 x i8> %v2, i32 2
  %10 = icmp slt i8 %8, %9
  %.sink3 = select i1 %10, <3 x i8> %v1, <3 x i8> %v2
  %11 = shufflevector <3 x i8> %7, <3 x i8> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i8> %11
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z3minDv4_cS_(<4 x i8> %v1, <4 x i8> %v2) #7 {
  %1 = extractelement <4 x i8> %v1, i32 0
  %2 = extractelement <4 x i8> %v2, i32 0
  %3 = icmp slt i8 %1, %2
  %.sink1 = select i1 %3, <4 x i8> %v1, <4 x i8> %v2
  %4 = extractelement <4 x i8> %v1, i32 1
  %5 = extractelement <4 x i8> %v2, i32 1
  %6 = icmp slt i8 %4, %5
  %.sink2 = select i1 %6, <4 x i8> %v1, <4 x i8> %v2
  %7 = shufflevector <4 x i8> %.sink1, <4 x i8> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i8> %v1, i32 2
  %9 = extractelement <4 x i8> %v2, i32 2
  %10 = icmp slt i8 %8, %9
  %.sink3 = select i1 %10, <4 x i8> %v1, <4 x i8> %v2
  %11 = shufflevector <4 x i8> %7, <4 x i8> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i8> %v1, i32 3
  %13 = extractelement <4 x i8> %v2, i32 3
  %14 = icmp slt i8 %12, %13
  %.sink4 = select i1 %14, <4 x i8> %v1, <4 x i8> %v2
  %15 = shufflevector <4 x i8> %11, <4 x i8> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i8> %15
}

; Function Attrs: nounwind readnone
define signext i16 @_Z3minss(i16 signext %v1, i16 signext %v2) #7 {
  %1 = icmp slt i16 %v1, %v2
  %.sink = select i1 %1, i16 %v1, i16 %v2
  ret i16 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z3minDv2_sS_(<2 x i16> %v1, <2 x i16> %v2) #7 {
  %1 = extractelement <2 x i16> %v1, i32 0
  %2 = extractelement <2 x i16> %v2, i32 0
  %3 = icmp slt i16 %1, %2
  %.sink1 = select i1 %3, <2 x i16> %v1, <2 x i16> %v2
  %4 = extractelement <2 x i16> %v1, i32 1
  %5 = extractelement <2 x i16> %v2, i32 1
  %6 = icmp slt i16 %4, %5
  %.sink2 = select i1 %6, <2 x i16> %v1, <2 x i16> %v2
  %7 = shufflevector <2 x i16> %.sink1, <2 x i16> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i16> %7
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z3minDv3_sS_(<3 x i16> %v1, <3 x i16> %v2) #7 {
  %1 = extractelement <3 x i16> %v1, i32 0
  %2 = extractelement <3 x i16> %v2, i32 0
  %3 = icmp slt i16 %1, %2
  %.sink1 = select i1 %3, <3 x i16> %v1, <3 x i16> %v2
  %4 = extractelement <3 x i16> %v1, i32 1
  %5 = extractelement <3 x i16> %v2, i32 1
  %6 = icmp slt i16 %4, %5
  %.sink2 = select i1 %6, <3 x i16> %v1, <3 x i16> %v2
  %7 = shufflevector <3 x i16> %.sink1, <3 x i16> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i16> %v1, i32 2
  %9 = extractelement <3 x i16> %v2, i32 2
  %10 = icmp slt i16 %8, %9
  %.sink3 = select i1 %10, <3 x i16> %v1, <3 x i16> %v2
  %11 = shufflevector <3 x i16> %7, <3 x i16> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i16> %11
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z3minDv4_sS_(<4 x i16> %v1, <4 x i16> %v2) #7 {
  %1 = extractelement <4 x i16> %v1, i32 0
  %2 = extractelement <4 x i16> %v2, i32 0
  %3 = icmp slt i16 %1, %2
  %.sink1 = select i1 %3, <4 x i16> %v1, <4 x i16> %v2
  %4 = extractelement <4 x i16> %v1, i32 1
  %5 = extractelement <4 x i16> %v2, i32 1
  %6 = icmp slt i16 %4, %5
  %.sink2 = select i1 %6, <4 x i16> %v1, <4 x i16> %v2
  %7 = shufflevector <4 x i16> %.sink1, <4 x i16> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i16> %v1, i32 2
  %9 = extractelement <4 x i16> %v2, i32 2
  %10 = icmp slt i16 %8, %9
  %.sink3 = select i1 %10, <4 x i16> %v1, <4 x i16> %v2
  %11 = shufflevector <4 x i16> %7, <4 x i16> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i16> %v1, i32 3
  %13 = extractelement <4 x i16> %v2, i32 3
  %14 = icmp slt i16 %12, %13
  %.sink4 = select i1 %14, <4 x i16> %v1, <4 x i16> %v2
  %15 = shufflevector <4 x i16> %11, <4 x i16> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i16> %15
}

; Function Attrs: nounwind readnone
define i32 @_Z3minii(i32 %v1, i32 %v2) #7 {
  %1 = icmp slt i32 %v1, %v2
  %2 = select i1 %1, i32 %v1, i32 %v2
  ret i32 %2
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z3minDv2_iS_(<2 x i32> %v1, <2 x i32> %v2) #7 {
  %1 = extractelement <2 x i32> %v1, i32 0
  %2 = extractelement <2 x i32> %v2, i32 0
  %3 = icmp slt i32 %1, %2
  %.sink = select i1 %3, <2 x i32> %v1, <2 x i32> %v2
  %4 = extractelement <2 x i32> %v1, i32 1
  %5 = extractelement <2 x i32> %v2, i32 1
  %6 = icmp slt i32 %4, %5
  %.sink1 = select i1 %6, <2 x i32> %v1, <2 x i32> %v2
  %7 = shufflevector <2 x i32> %.sink, <2 x i32> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i32> %7
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z3minDv3_iS_(<3 x i32> %v1, <3 x i32> %v2) #7 {
  %1 = extractelement <3 x i32> %v1, i32 0
  %2 = extractelement <3 x i32> %v2, i32 0
  %3 = icmp slt i32 %1, %2
  %.sink = select i1 %3, <3 x i32> %v1, <3 x i32> %v2
  %4 = extractelement <3 x i32> %v1, i32 1
  %5 = extractelement <3 x i32> %v2, i32 1
  %6 = icmp slt i32 %4, %5
  %.sink1 = select i1 %6, <3 x i32> %v1, <3 x i32> %v2
  %7 = shufflevector <3 x i32> %.sink, <3 x i32> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i32> %v1, i32 2
  %9 = extractelement <3 x i32> %v2, i32 2
  %10 = icmp slt i32 %8, %9
  %.sink2 = select i1 %10, <3 x i32> %v1, <3 x i32> %v2
  %11 = shufflevector <3 x i32> %7, <3 x i32> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i32> %11
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z3minDv4_iS_(<4 x i32> %v1, <4 x i32> %v2) #7 {
  %1 = extractelement <4 x i32> %v1, i32 0
  %2 = extractelement <4 x i32> %v2, i32 0
  %3 = icmp slt i32 %1, %2
  %.sink = select i1 %3, <4 x i32> %v1, <4 x i32> %v2
  %4 = extractelement <4 x i32> %v1, i32 1
  %5 = extractelement <4 x i32> %v2, i32 1
  %6 = icmp slt i32 %4, %5
  %.sink1 = select i1 %6, <4 x i32> %v1, <4 x i32> %v2
  %7 = shufflevector <4 x i32> %.sink, <4 x i32> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i32> %v1, i32 2
  %9 = extractelement <4 x i32> %v2, i32 2
  %10 = icmp slt i32 %8, %9
  %.sink2 = select i1 %10, <4 x i32> %v1, <4 x i32> %v2
  %11 = shufflevector <4 x i32> %7, <4 x i32> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i32> %v1, i32 3
  %13 = extractelement <4 x i32> %v2, i32 3
  %14 = icmp slt i32 %12, %13
  %.sink3 = select i1 %14, <4 x i32> %v1, <4 x i32> %v2
  %15 = shufflevector <4 x i32> %11, <4 x i32> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i32> %15
}

; Function Attrs: nounwind readnone
define i64 @_Z3minxx(i64 %v1, i64 %v2) #7 {
  %1 = icmp slt i64 %v1, %v2
  %2 = select i1 %1, i64 %v1, i64 %v2
  ret i64 %2
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z3minDv2_lS_(<2 x i64> %v1, <2 x i64> %v2) #7 {
  %1 = extractelement <2 x i64> %v1, i32 0
  %2 = extractelement <2 x i64> %v2, i32 0
  %3 = icmp slt i64 %1, %2
  %.sink = select i1 %3, <2 x i64> %v1, <2 x i64> %v2
  %4 = extractelement <2 x i64> %v1, i32 1
  %5 = extractelement <2 x i64> %v2, i32 1
  %6 = icmp slt i64 %4, %5
  %.sink1 = select i1 %6, <2 x i64> %v1, <2 x i64> %v2
  %7 = shufflevector <2 x i64> %.sink, <2 x i64> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i64> %7
}

; Function Attrs: nounwind
define void @_Z3minDv3_lS_(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %v1, <3 x i64> %v2) #5 {
  %1 = extractelement <3 x i64> %v1, i32 0
  %2 = extractelement <3 x i64> %v2, i32 0
  %3 = icmp slt i64 %1, %2
  %.sink = select i1 %3, <3 x i64> %v1, <3 x i64> %v2
  %4 = extractelement <3 x i64> %v1, i32 1
  %5 = extractelement <3 x i64> %v2, i32 1
  %6 = icmp slt i64 %4, %5
  %.sink1 = select i1 %6, <3 x i64> %v1, <3 x i64> %v2
  %7 = shufflevector <3 x i64> %.sink, <3 x i64> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i64> %v1, i32 2
  %9 = extractelement <3 x i64> %v2, i32 2
  %10 = icmp slt i64 %8, %9
  %.sink2 = select i1 %10, <3 x i64> %v1, <3 x i64> %v2
  %11 = shufflevector <3 x i64> %7, <3 x i64> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  %12 = shufflevector <3 x i64> %11, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %13 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z3minDv4_lS_(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %v1, <4 x i64> %v2) #5 {
  %1 = extractelement <4 x i64> %v1, i32 0
  %2 = extractelement <4 x i64> %v2, i32 0
  %3 = icmp slt i64 %1, %2
  %.sink = select i1 %3, <4 x i64> %v1, <4 x i64> %v2
  %4 = extractelement <4 x i64> %v1, i32 1
  %5 = extractelement <4 x i64> %v2, i32 1
  %6 = icmp slt i64 %4, %5
  %.sink1 = select i1 %6, <4 x i64> %v1, <4 x i64> %v2
  %7 = shufflevector <4 x i64> %.sink, <4 x i64> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i64> %v1, i32 2
  %9 = extractelement <4 x i64> %v2, i32 2
  %10 = icmp slt i64 %8, %9
  %.sink2 = select i1 %10, <4 x i64> %v1, <4 x i64> %v2
  %11 = shufflevector <4 x i64> %7, <4 x i64> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i64> %v1, i32 3
  %13 = extractelement <4 x i64> %v2, i32 3
  %14 = icmp slt i64 %12, %13
  %.sink3 = select i1 %14, <4 x i64> %v1, <4 x i64> %v2
  %15 = shufflevector <4 x i64> %11, <4 x i64> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  store <4 x i64> %15, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define zeroext i8 @_Z3minhh(i8 zeroext %v1, i8 zeroext %v2) #7 {
  %1 = icmp ult i8 %v1, %v2
  %.sink = select i1 %1, i8 %v1, i8 %v2
  ret i8 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i8> @_Z3minDv2_hS_(<2 x i8> %v1, <2 x i8> %v2) #7 {
  %1 = extractelement <2 x i8> %v1, i32 0
  %2 = extractelement <2 x i8> %v2, i32 0
  %3 = icmp ult i8 %1, %2
  %.sink1 = select i1 %3, <2 x i8> %v1, <2 x i8> %v2
  %4 = extractelement <2 x i8> %v1, i32 1
  %5 = extractelement <2 x i8> %v2, i32 1
  %6 = icmp ult i8 %4, %5
  %.sink2 = select i1 %6, <2 x i8> %v1, <2 x i8> %v2
  %7 = shufflevector <2 x i8> %.sink1, <2 x i8> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i8> %7
}

; Function Attrs: nounwind readnone
define <3 x i8> @_Z3minDv3_hS_(<3 x i8> %v1, <3 x i8> %v2) #7 {
  %1 = extractelement <3 x i8> %v1, i32 0
  %2 = extractelement <3 x i8> %v2, i32 0
  %3 = icmp ult i8 %1, %2
  %.sink1 = select i1 %3, <3 x i8> %v1, <3 x i8> %v2
  %4 = extractelement <3 x i8> %v1, i32 1
  %5 = extractelement <3 x i8> %v2, i32 1
  %6 = icmp ult i8 %4, %5
  %.sink2 = select i1 %6, <3 x i8> %v1, <3 x i8> %v2
  %7 = shufflevector <3 x i8> %.sink1, <3 x i8> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i8> %v1, i32 2
  %9 = extractelement <3 x i8> %v2, i32 2
  %10 = icmp ult i8 %8, %9
  %.sink3 = select i1 %10, <3 x i8> %v1, <3 x i8> %v2
  %11 = shufflevector <3 x i8> %7, <3 x i8> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i8> %11
}

; Function Attrs: nounwind readnone
define <4 x i8> @_Z3minDv4_hS_(<4 x i8> %v1, <4 x i8> %v2) #7 {
  %1 = extractelement <4 x i8> %v1, i32 0
  %2 = extractelement <4 x i8> %v2, i32 0
  %3 = icmp ult i8 %1, %2
  %.sink1 = select i1 %3, <4 x i8> %v1, <4 x i8> %v2
  %4 = extractelement <4 x i8> %v1, i32 1
  %5 = extractelement <4 x i8> %v2, i32 1
  %6 = icmp ult i8 %4, %5
  %.sink2 = select i1 %6, <4 x i8> %v1, <4 x i8> %v2
  %7 = shufflevector <4 x i8> %.sink1, <4 x i8> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i8> %v1, i32 2
  %9 = extractelement <4 x i8> %v2, i32 2
  %10 = icmp ult i8 %8, %9
  %.sink3 = select i1 %10, <4 x i8> %v1, <4 x i8> %v2
  %11 = shufflevector <4 x i8> %7, <4 x i8> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i8> %v1, i32 3
  %13 = extractelement <4 x i8> %v2, i32 3
  %14 = icmp ult i8 %12, %13
  %.sink4 = select i1 %14, <4 x i8> %v1, <4 x i8> %v2
  %15 = shufflevector <4 x i8> %11, <4 x i8> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i8> %15
}

; Function Attrs: nounwind readnone
define zeroext i16 @_Z3mintt(i16 zeroext %v1, i16 zeroext %v2) #7 {
  %1 = icmp ult i16 %v1, %v2
  %.sink = select i1 %1, i16 %v1, i16 %v2
  ret i16 %.sink
}

; Function Attrs: nounwind readnone
define <2 x i16> @_Z3minDv2_tS_(<2 x i16> %v1, <2 x i16> %v2) #7 {
  %1 = extractelement <2 x i16> %v1, i32 0
  %2 = extractelement <2 x i16> %v2, i32 0
  %3 = icmp ult i16 %1, %2
  %.sink1 = select i1 %3, <2 x i16> %v1, <2 x i16> %v2
  %4 = extractelement <2 x i16> %v1, i32 1
  %5 = extractelement <2 x i16> %v2, i32 1
  %6 = icmp ult i16 %4, %5
  %.sink2 = select i1 %6, <2 x i16> %v1, <2 x i16> %v2
  %7 = shufflevector <2 x i16> %.sink1, <2 x i16> %.sink2, <2 x i32> <i32 0, i32 3>
  ret <2 x i16> %7
}

; Function Attrs: nounwind readnone
define <3 x i16> @_Z3minDv3_tS_(<3 x i16> %v1, <3 x i16> %v2) #7 {
  %1 = extractelement <3 x i16> %v1, i32 0
  %2 = extractelement <3 x i16> %v2, i32 0
  %3 = icmp ult i16 %1, %2
  %.sink1 = select i1 %3, <3 x i16> %v1, <3 x i16> %v2
  %4 = extractelement <3 x i16> %v1, i32 1
  %5 = extractelement <3 x i16> %v2, i32 1
  %6 = icmp ult i16 %4, %5
  %.sink2 = select i1 %6, <3 x i16> %v1, <3 x i16> %v2
  %7 = shufflevector <3 x i16> %.sink1, <3 x i16> %.sink2, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i16> %v1, i32 2
  %9 = extractelement <3 x i16> %v2, i32 2
  %10 = icmp ult i16 %8, %9
  %.sink3 = select i1 %10, <3 x i16> %v1, <3 x i16> %v2
  %11 = shufflevector <3 x i16> %7, <3 x i16> %.sink3, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i16> %11
}

; Function Attrs: nounwind readnone
define <4 x i16> @_Z3minDv4_tS_(<4 x i16> %v1, <4 x i16> %v2) #7 {
  %1 = extractelement <4 x i16> %v1, i32 0
  %2 = extractelement <4 x i16> %v2, i32 0
  %3 = icmp ult i16 %1, %2
  %.sink1 = select i1 %3, <4 x i16> %v1, <4 x i16> %v2
  %4 = extractelement <4 x i16> %v1, i32 1
  %5 = extractelement <4 x i16> %v2, i32 1
  %6 = icmp ult i16 %4, %5
  %.sink2 = select i1 %6, <4 x i16> %v1, <4 x i16> %v2
  %7 = shufflevector <4 x i16> %.sink1, <4 x i16> %.sink2, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i16> %v1, i32 2
  %9 = extractelement <4 x i16> %v2, i32 2
  %10 = icmp ult i16 %8, %9
  %.sink3 = select i1 %10, <4 x i16> %v1, <4 x i16> %v2
  %11 = shufflevector <4 x i16> %7, <4 x i16> %.sink3, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i16> %v1, i32 3
  %13 = extractelement <4 x i16> %v2, i32 3
  %14 = icmp ult i16 %12, %13
  %.sink4 = select i1 %14, <4 x i16> %v1, <4 x i16> %v2
  %15 = shufflevector <4 x i16> %11, <4 x i16> %.sink4, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i16> %15
}

; Function Attrs: nounwind readnone
define i32 @_Z3minjj(i32 %v1, i32 %v2) #7 {
  %1 = icmp ult i32 %v1, %v2
  %2 = select i1 %1, i32 %v1, i32 %v2
  ret i32 %2
}

; Function Attrs: nounwind readnone
define <2 x i32> @_Z3minDv2_jS_(<2 x i32> %v1, <2 x i32> %v2) #7 {
  %1 = extractelement <2 x i32> %v1, i32 0
  %2 = extractelement <2 x i32> %v2, i32 0
  %3 = icmp ult i32 %1, %2
  %.sink = select i1 %3, <2 x i32> %v1, <2 x i32> %v2
  %4 = extractelement <2 x i32> %v1, i32 1
  %5 = extractelement <2 x i32> %v2, i32 1
  %6 = icmp ult i32 %4, %5
  %.sink1 = select i1 %6, <2 x i32> %v1, <2 x i32> %v2
  %7 = shufflevector <2 x i32> %.sink, <2 x i32> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i32> %7
}

; Function Attrs: nounwind readnone
define <3 x i32> @_Z3minDv3_jS_(<3 x i32> %v1, <3 x i32> %v2) #7 {
  %1 = extractelement <3 x i32> %v1, i32 0
  %2 = extractelement <3 x i32> %v2, i32 0
  %3 = icmp ult i32 %1, %2
  %.sink = select i1 %3, <3 x i32> %v1, <3 x i32> %v2
  %4 = extractelement <3 x i32> %v1, i32 1
  %5 = extractelement <3 x i32> %v2, i32 1
  %6 = icmp ult i32 %4, %5
  %.sink1 = select i1 %6, <3 x i32> %v1, <3 x i32> %v2
  %7 = shufflevector <3 x i32> %.sink, <3 x i32> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i32> %v1, i32 2
  %9 = extractelement <3 x i32> %v2, i32 2
  %10 = icmp ult i32 %8, %9
  %.sink2 = select i1 %10, <3 x i32> %v1, <3 x i32> %v2
  %11 = shufflevector <3 x i32> %7, <3 x i32> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x i32> %11
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z3minDv4_jS_(<4 x i32> %v1, <4 x i32> %v2) #7 {
  %1 = extractelement <4 x i32> %v1, i32 0
  %2 = extractelement <4 x i32> %v2, i32 0
  %3 = icmp ult i32 %1, %2
  %.sink = select i1 %3, <4 x i32> %v1, <4 x i32> %v2
  %4 = extractelement <4 x i32> %v1, i32 1
  %5 = extractelement <4 x i32> %v2, i32 1
  %6 = icmp ult i32 %4, %5
  %.sink1 = select i1 %6, <4 x i32> %v1, <4 x i32> %v2
  %7 = shufflevector <4 x i32> %.sink, <4 x i32> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i32> %v1, i32 2
  %9 = extractelement <4 x i32> %v2, i32 2
  %10 = icmp ult i32 %8, %9
  %.sink2 = select i1 %10, <4 x i32> %v1, <4 x i32> %v2
  %11 = shufflevector <4 x i32> %7, <4 x i32> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i32> %v1, i32 3
  %13 = extractelement <4 x i32> %v2, i32 3
  %14 = icmp ult i32 %12, %13
  %.sink3 = select i1 %14, <4 x i32> %v1, <4 x i32> %v2
  %15 = shufflevector <4 x i32> %11, <4 x i32> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x i32> %15
}

; Function Attrs: nounwind readnone
define i64 @_Z3minyy(i64 %v1, i64 %v2) #7 {
  %1 = icmp ult i64 %v1, %v2
  %2 = select i1 %1, i64 %v1, i64 %v2
  ret i64 %2
}

; Function Attrs: nounwind readnone
define <2 x i64> @_Z3minDv2_yS_(<2 x i64> %v1, <2 x i64> %v2) #7 {
  %1 = extractelement <2 x i64> %v1, i32 0
  %2 = extractelement <2 x i64> %v2, i32 0
  %3 = icmp ult i64 %1, %2
  %.sink = select i1 %3, <2 x i64> %v1, <2 x i64> %v2
  %4 = extractelement <2 x i64> %v1, i32 1
  %5 = extractelement <2 x i64> %v2, i32 1
  %6 = icmp ult i64 %4, %5
  %.sink1 = select i1 %6, <2 x i64> %v1, <2 x i64> %v2
  %7 = shufflevector <2 x i64> %.sink, <2 x i64> %.sink1, <2 x i32> <i32 0, i32 3>
  ret <2 x i64> %7
}

; Function Attrs: nounwind
define void @_Z3minDv3_yS_(<3 x i64>* noalias nocapture sret %agg.result, <3 x i64> %v1, <3 x i64> %v2) #5 {
  %1 = extractelement <3 x i64> %v1, i32 0
  %2 = extractelement <3 x i64> %v2, i32 0
  %3 = icmp ult i64 %1, %2
  %.sink = select i1 %3, <3 x i64> %v1, <3 x i64> %v2
  %4 = extractelement <3 x i64> %v1, i32 1
  %5 = extractelement <3 x i64> %v2, i32 1
  %6 = icmp ult i64 %4, %5
  %.sink1 = select i1 %6, <3 x i64> %v1, <3 x i64> %v2
  %7 = shufflevector <3 x i64> %.sink, <3 x i64> %.sink1, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x i64> %v1, i32 2
  %9 = extractelement <3 x i64> %v2, i32 2
  %10 = icmp ult i64 %8, %9
  %.sink2 = select i1 %10, <3 x i64> %v1, <3 x i64> %v2
  %11 = shufflevector <3 x i64> %7, <3 x i64> %.sink2, <3 x i32> <i32 0, i32 1, i32 5>
  %12 = shufflevector <3 x i64> %11, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %13 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %12, <4 x i64>* %13, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind
define void @_Z3minDv4_yS_(<4 x i64>* noalias nocapture sret %agg.result, <4 x i64> %v1, <4 x i64> %v2) #5 {
  %1 = extractelement <4 x i64> %v1, i32 0
  %2 = extractelement <4 x i64> %v2, i32 0
  %3 = icmp ult i64 %1, %2
  %.sink = select i1 %3, <4 x i64> %v1, <4 x i64> %v2
  %4 = extractelement <4 x i64> %v1, i32 1
  %5 = extractelement <4 x i64> %v2, i32 1
  %6 = icmp ult i64 %4, %5
  %.sink1 = select i1 %6, <4 x i64> %v1, <4 x i64> %v2
  %7 = shufflevector <4 x i64> %.sink, <4 x i64> %.sink1, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x i64> %v1, i32 2
  %9 = extractelement <4 x i64> %v2, i32 2
  %10 = icmp ult i64 %8, %9
  %.sink2 = select i1 %10, <4 x i64> %v1, <4 x i64> %v2
  %11 = shufflevector <4 x i64> %7, <4 x i64> %.sink2, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x i64> %v1, i32 3
  %13 = extractelement <4 x i64> %v2, i32 3
  %14 = icmp ult i64 %12, %13
  %.sink3 = select i1 %14, <4 x i64> %v1, <4 x i64> %v2
  %15 = shufflevector <4 x i64> %11, <4 x i64> %.sink3, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  store <4 x i64> %15, <4 x i64>* %agg.result, align 32, !tbaa !19
  ret void
}

; Function Attrs: nounwind readnone
define float @_Z3minff(float %v1, float %v2) #7 {
  %1 = fcmp olt float %v1, %v2
  %2 = select i1 %1, float %v1, float %v2
  ret float %2
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z3minDv2_fS_(<2 x float> %v1, <2 x float> %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = extractelement <2 x float> %v2, i32 0
  %3 = fcmp olt float %1, %2
  %.sink.i = select i1 %3, <2 x float> %v1, <2 x float> %v2
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = extractelement <2 x float> %v2, i32 1
  %6 = fcmp olt float %4, %5
  %.sink1.i = select i1 %6, <2 x float> %v1, <2 x float> %v2
  %7 = shufflevector <2 x float> %.sink.i, <2 x float> %.sink1.i, <2 x i32> <i32 0, i32 3>
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z3minDv2_ff(<2 x float> %v1, float %v2) #7 {
  %1 = extractelement <2 x float> %v1, i32 0
  %2 = fcmp olt float %1, %v2
  %.v2.i = select i1 %2, float %1, float %v2
  %3 = insertelement <2 x float> undef, float %.v2.i, i32 0
  %4 = extractelement <2 x float> %v1, i32 1
  %5 = fcmp olt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <2 x float> %3, float %6, i32 1
  ret <2 x float> %7
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z3minDv3_fS_(<3 x float> %v1, <3 x float> %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = extractelement <3 x float> %v2, i32 0
  %3 = fcmp olt float %1, %2
  %.sink.i = select i1 %3, <3 x float> %v1, <3 x float> %v2
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = extractelement <3 x float> %v2, i32 1
  %6 = fcmp olt float %4, %5
  %.sink1.i = select i1 %6, <3 x float> %v1, <3 x float> %v2
  %7 = shufflevector <3 x float> %.sink.i, <3 x float> %.sink1.i, <3 x i32> <i32 0, i32 4, i32 undef>
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = extractelement <3 x float> %v2, i32 2
  %10 = fcmp olt float %8, %9
  %.sink2.i = select i1 %10, <3 x float> %v1, <3 x float> %v2
  %11 = shufflevector <3 x float> %7, <3 x float> %.sink2.i, <3 x i32> <i32 0, i32 1, i32 5>
  ret <3 x float> %11
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z3minDv3_ff(<3 x float> %v1, float %v2) #7 {
  %1 = extractelement <3 x float> %v1, i32 0
  %2 = fcmp olt float %1, %v2
  %.v2.i = select i1 %2, float %1, float %v2
  %3 = insertelement <3 x float> undef, float %.v2.i, i32 0
  %4 = extractelement <3 x float> %v1, i32 1
  %5 = fcmp olt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <3 x float> %3, float %6, i32 1
  %8 = extractelement <3 x float> %v1, i32 2
  %9 = fcmp olt float %8, %v2
  %.v21.i = select i1 %9, float %8, float %v2
  %10 = insertelement <3 x float> %7, float %.v21.i, i32 2
  ret <3 x float> %10
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z3minDv4_fS_(<4 x float> %v1, <4 x float> %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = extractelement <4 x float> %v2, i32 0
  %3 = fcmp olt float %1, %2
  %.sink.i = select i1 %3, <4 x float> %v1, <4 x float> %v2
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = extractelement <4 x float> %v2, i32 1
  %6 = fcmp olt float %4, %5
  %.sink1.i = select i1 %6, <4 x float> %v1, <4 x float> %v2
  %7 = shufflevector <4 x float> %.sink.i, <4 x float> %.sink1.i, <4 x i32> <i32 0, i32 5, i32 undef, i32 undef>
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = extractelement <4 x float> %v2, i32 2
  %10 = fcmp olt float %8, %9
  %.sink2.i = select i1 %10, <4 x float> %v1, <4 x float> %v2
  %11 = shufflevector <4 x float> %7, <4 x float> %.sink2.i, <4 x i32> <i32 0, i32 1, i32 6, i32 undef>
  %12 = extractelement <4 x float> %v1, i32 3
  %13 = extractelement <4 x float> %v2, i32 3
  %14 = fcmp olt float %12, %13
  %.sink3.i = select i1 %14, <4 x float> %v1, <4 x float> %v2
  %15 = shufflevector <4 x float> %11, <4 x float> %.sink3.i, <4 x i32> <i32 0, i32 1, i32 2, i32 7>
  ret <4 x float> %15
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z3minDv4_ff(<4 x float> %v1, float %v2) #7 {
  %1 = extractelement <4 x float> %v1, i32 0
  %2 = fcmp olt float %1, %v2
  %.v2.i = select i1 %2, float %1, float %v2
  %3 = insertelement <4 x float> undef, float %.v2.i, i32 0
  %4 = extractelement <4 x float> %v1, i32 1
  %5 = fcmp olt float %4, %v2
  %6 = select i1 %5, float %4, float %v2
  %7 = insertelement <4 x float> %3, float %6, i32 1
  %8 = extractelement <4 x float> %v1, i32 2
  %9 = fcmp olt float %8, %v2
  %.v21.i = select i1 %9, float %8, float %v2
  %10 = insertelement <4 x float> %7, float %.v21.i, i32 2
  %11 = extractelement <4 x float> %v1, i32 3
  %12 = fcmp olt float %11, %v2
  %13 = select i1 %12, float %11, float %v2
  %14 = insertelement <4 x float> %10, float %13, i32 3
  ret <4 x float> %14
}

; Function Attrs: nounwind
define <4 x i8> @_Z18rsYuvToRGBA_uchar4hhh(i8 zeroext %y, i8 zeroext %u, i8 zeroext %v) #5 {
  %1 = zext i8 %y to i32
  %2 = zext i8 %u to i32
  %3 = zext i8 %v to i32
  %4 = shl nuw nsw i32 %1, 16
  %sext = add i32 %4, -1048576
  %5 = ashr exact i32 %sext, 16
  %6 = mul nsw i32 %5, 298
  %7 = shl nuw nsw i32 %3, 16
  %sext1 = add i32 %7, -8388608
  %8 = ashr exact i32 %sext1, 16
  %9 = mul nsw i32 %8, 409
  %10 = add i32 %6, 128
  %11 = add i32 %10, %9
  %12 = lshr i32 %11, 8
  %13 = trunc i32 %12 to i16
  %14 = shl nuw nsw i32 %2, 16
  %sext2 = add i32 %14, -8388608
  %15 = ashr exact i32 %sext2, 16
  %16 = mul i32 %15, -100
  %17 = mul i32 %8, -208
  %18 = add i32 %10, %16
  %19 = add i32 %18, %17
  %20 = lshr i32 %19, 8
  %21 = trunc i32 %20 to i16
  %22 = mul nsw i32 %15, 516
  %23 = add i32 %10, %22
  %24 = lshr i32 %23, 8
  %25 = trunc i32 %24 to i16
  %26 = icmp slt i16 %13, 255
  %27 = select i1 %26, i16 %13, i16 255
  %28 = icmp sgt i16 %27, 0
  %29 = select i1 %28, i16 %27, i16 0
  %30 = insertelement <4 x i16> <i16 undef, i16 undef, i16 undef, i16 255>, i16 %29, i32 0
  %31 = icmp slt i16 %21, 255
  %32 = select i1 %31, i16 %21, i16 255
  %33 = icmp sgt i16 %32, 0
  %34 = select i1 %33, i16 %32, i16 0
  %35 = insertelement <4 x i16> %30, i16 %34, i32 1
  %36 = icmp slt i16 %25, 255
  %37 = select i1 %36, i16 %25, i16 255
  %38 = icmp sgt i16 %37, 0
  %39 = select i1 %38, i16 %37, i16 0
  %40 = insertelement <4 x i16> %35, i16 %39, i32 2
  %41 = trunc <4 x i16> %40 to <4 x i8>
  ret <4 x i8> %41
}

; Function Attrs: nounwind
define <4 x float> @_Z18rsYuvToRGBA_float4hhh(i8 zeroext %y, i8 zeroext %u, i8 zeroext %v) #5 {
  %1 = uitofp i8 %y to float
  %2 = fmul float %1, 0x3F70101020000000
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = shufflevector <4 x float> %3, <4 x float> undef, <4 x i32> zeroinitializer
  %5 = uitofp i8 %u to float
  %6 = fadd float %5, -1.280000e+02
  %7 = insertelement <4 x float> undef, float %6, i32 0
  %8 = shufflevector <4 x float> %7, <4 x float> undef, <4 x i32> zeroinitializer
  %9 = uitofp i8 %v to float
  %10 = fadd float %9, -1.280000e+02
  %11 = insertelement <4 x float> undef, float %10, i32 0
  %12 = shufflevector <4 x float> %11, <4 x float> undef, <4 x i32> zeroinitializer
  %13 = fmul <4 x float> %8, <float 0.000000e+00, float 0xBF592FB6E0000000, float 0x3F80392F00000000, float 0.000000e+00>
  %14 = fadd <4 x float> %4, %13
  %15 = fmul <4 x float> %12, <float 0x3F79BFA320000000, float 0xBF6A2EA9A0000000, float 0.000000e+00, float 0.000000e+00>
  %16 = fadd <4 x float> %14, %15
  %17 = tail call <4 x float> @_Z5clampDv4_fff(<4 x float> %16, float 0.000000e+00, float 1.000000e+00) #12
  ret <4 x float> %17
}

; Function Attrs: nounwind readnone
define float @_Z10half_recipf(float %v) #7 {
  %1 = fdiv float 1.000000e+00, %v
  ret float %1
}

; Function Attrs: nounwind readnone
define <2 x float> @_Z10half_recipDv2_f(<2 x float> %v) #7 {
  ret <2 x float> undef
}

; Function Attrs: nounwind readnone
define <3 x float> @_Z10half_recipDv3_f(<3 x float> %v) #7 {
  ret <3 x float> undef
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z10half_recipDv4_f(<4 x float> %v) #7 {
  ret <4 x float> undef
}

; Function Attrs: nounwind
define float @_Z9half_sqrtf(float %v) #5 {
  %1 = tail call float @_Z4sqrtf(float %v) #12
  ret float %1
}

; Function Attrs: nounwind
define <2 x float> @_Z9half_sqrtDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = insertelement <2 x float> undef, float %2, i32 0
  %4 = extractelement <2 x float> %v, i32 1
  %5 = tail call float @_Z4sqrtf(float %4) #12
  %6 = insertelement <2 x float> %3, float %5, i32 1
  ret <2 x float> %6
}

; Function Attrs: nounwind
define <3 x float> @_Z9half_sqrtDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = insertelement <3 x float> undef, float %2, i32 0
  %4 = extractelement <3 x float> %v, i32 1
  %5 = tail call float @_Z4sqrtf(float %4) #12
  %6 = insertelement <3 x float> %3, float %5, i32 1
  %7 = extractelement <3 x float> %v, i32 2
  %8 = tail call float @_Z4sqrtf(float %7) #12
  %9 = insertelement <3 x float> %6, float %8, i32 2
  ret <3 x float> %9
}

; Function Attrs: nounwind
define <4 x float> @_Z9half_sqrtDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = insertelement <4 x float> undef, float %2, i32 0
  %4 = extractelement <4 x float> %v, i32 1
  %5 = tail call float @_Z4sqrtf(float %4) #12
  %6 = insertelement <4 x float> %3, float %5, i32 1
  %7 = extractelement <4 x float> %v, i32 2
  %8 = tail call float @_Z4sqrtf(float %7) #12
  %9 = insertelement <4 x float> %6, float %8, i32 2
  %10 = extractelement <4 x float> %v, i32 3
  %11 = tail call float @_Z4sqrtf(float %10) #12
  %12 = insertelement <4 x float> %9, float %11, i32 3
  ret <4 x float> %12
}

; Function Attrs: nounwind
define float @_Z10half_rsqrtf(float %v) #5 {
  %1 = tail call float @_Z4sqrtf(float %v) #12
  %2 = fdiv float 1.000000e+00, %1
  ret float %2
}

; Function Attrs: nounwind
define <2 x float> @_Z10half_rsqrtDv2_f(<2 x float> %v) #5 {
  %1 = extractelement <2 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = fdiv float 1.000000e+00, %2
  %4 = insertelement <2 x float> undef, float %3, i32 0
  %5 = extractelement <2 x float> %v, i32 1
  %6 = tail call float @_Z4sqrtf(float %5) #12
  %7 = fdiv float 1.000000e+00, %6
  %8 = insertelement <2 x float> %4, float %7, i32 1
  ret <2 x float> %8
}

; Function Attrs: nounwind
define <3 x float> @_Z10half_rsqrtDv3_f(<3 x float> %v) #5 {
  %1 = extractelement <3 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = fdiv float 1.000000e+00, %2
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <3 x float> %v, i32 1
  %6 = tail call float @_Z4sqrtf(float %5) #12
  %7 = fdiv float 1.000000e+00, %6
  %8 = insertelement <3 x float> %4, float %7, i32 1
  %9 = extractelement <3 x float> %v, i32 2
  %10 = tail call float @_Z4sqrtf(float %9) #12
  %11 = fdiv float 1.000000e+00, %10
  %12 = insertelement <3 x float> %8, float %11, i32 2
  ret <3 x float> %12
}

; Function Attrs: nounwind
define <4 x float> @_Z10half_rsqrtDv4_f(<4 x float> %v) #5 {
  %1 = extractelement <4 x float> %v, i32 0
  %2 = tail call float @_Z4sqrtf(float %1) #12
  %3 = fdiv float 1.000000e+00, %2
  %4 = insertelement <4 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %v, i32 1
  %6 = tail call float @_Z4sqrtf(float %5) #12
  %7 = fdiv float 1.000000e+00, %6
  %8 = insertelement <4 x float> %4, float %7, i32 1
  %9 = extractelement <4 x float> %v, i32 2
  %10 = tail call float @_Z4sqrtf(float %9) #12
  %11 = fdiv float 1.000000e+00, %10
  %12 = insertelement <4 x float> %8, float %11, i32 2
  %13 = extractelement <4 x float> %v, i32 3
  %14 = tail call float @_Z4sqrtf(float %13) #12
  %15 = fdiv float 1.000000e+00, %14
  %16 = insertelement <4 x float> %12, float %15, i32 3
  ret <4 x float> %16
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z16rsMatrixMultiplyPK12rs_matrix4x4Dv4_f(%struct.rs_matrix4x4* nocapture %m, <4 x float> %in) #4 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <4 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <4 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = extractelement <4 x float> %in, i32 2
  %13 = fmul float %12, %11
  %14 = fadd float %9, %13
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  %16 = load float, float* %15, align 4, !tbaa !18
  %17 = extractelement <4 x float> %in, i32 3
  %18 = fmul float %17, %16
  %19 = fadd float %14, %18
  %20 = insertelement <4 x float> undef, float %19, i32 0
  %21 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  %22 = load float, float* %21, align 4, !tbaa !18
  %23 = fmul float %3, %22
  %24 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  %25 = load float, float* %24, align 4, !tbaa !18
  %26 = fmul float %7, %25
  %27 = fadd float %23, %26
  %28 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = fmul float %12, %29
  %31 = fadd float %27, %30
  %32 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  %33 = load float, float* %32, align 4, !tbaa !18
  %34 = fmul float %17, %33
  %35 = fadd float %31, %34
  %36 = insertelement <4 x float> %20, float %35, i32 1
  %37 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  %38 = load float, float* %37, align 4, !tbaa !18
  %39 = fmul float %3, %38
  %40 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  %41 = load float, float* %40, align 4, !tbaa !18
  %42 = fmul float %7, %41
  %43 = fadd float %39, %42
  %44 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  %45 = load float, float* %44, align 4, !tbaa !18
  %46 = fmul float %12, %45
  %47 = fadd float %43, %46
  %48 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  %49 = load float, float* %48, align 4, !tbaa !18
  %50 = fmul float %17, %49
  %51 = fadd float %47, %50
  %52 = insertelement <4 x float> %36, float %51, i32 2
  %53 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  %54 = load float, float* %53, align 4, !tbaa !18
  %55 = fmul float %3, %54
  %56 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  %57 = load float, float* %56, align 4, !tbaa !18
  %58 = fmul float %7, %57
  %59 = fadd float %55, %58
  %60 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  %61 = load float, float* %60, align 4, !tbaa !18
  %62 = fmul float %12, %61
  %63 = fadd float %59, %62
  %64 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  %65 = load float, float* %64, align 4, !tbaa !18
  %66 = fmul float %17, %65
  %67 = fadd float %63, %66
  %68 = insertelement <4 x float> %52, float %67, i32 3
  ret <4 x float> %68
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z16rsMatrixMultiplyPK12rs_matrix4x4Dv3_f(%struct.rs_matrix4x4* nocapture %m, <3 x float> %in) #4 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <3 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <3 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 8
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = extractelement <3 x float> %in, i32 2
  %13 = fmul float %12, %11
  %14 = fadd float %9, %13
  %15 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  %16 = load float, float* %15, align 4, !tbaa !18
  %17 = fadd float %16, %14
  %18 = insertelement <4 x float> undef, float %17, i32 0
  %19 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = fmul float %3, %20
  %22 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = fmul float %7, %23
  %25 = fadd float %21, %24
  %26 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 9
  %27 = load float, float* %26, align 4, !tbaa !18
  %28 = fmul float %12, %27
  %29 = fadd float %25, %28
  %30 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  %31 = load float, float* %30, align 4, !tbaa !18
  %32 = fadd float %31, %29
  %33 = insertelement <4 x float> %18, float %32, i32 1
  %34 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  %35 = load float, float* %34, align 4, !tbaa !18
  %36 = fmul float %3, %35
  %37 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  %38 = load float, float* %37, align 4, !tbaa !18
  %39 = fmul float %7, %38
  %40 = fadd float %36, %39
  %41 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 10
  %42 = load float, float* %41, align 4, !tbaa !18
  %43 = fmul float %12, %42
  %44 = fadd float %40, %43
  %45 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  %46 = load float, float* %45, align 4, !tbaa !18
  %47 = fadd float %46, %44
  %48 = insertelement <4 x float> %33, float %47, i32 2
  %49 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  %50 = load float, float* %49, align 4, !tbaa !18
  %51 = fmul float %3, %50
  %52 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  %53 = load float, float* %52, align 4, !tbaa !18
  %54 = fmul float %7, %53
  %55 = fadd float %51, %54
  %56 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 11
  %57 = load float, float* %56, align 4, !tbaa !18
  %58 = fmul float %12, %57
  %59 = fadd float %55, %58
  %60 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  %61 = load float, float* %60, align 4, !tbaa !18
  %62 = fadd float %61, %59
  %63 = insertelement <4 x float> %48, float %62, i32 3
  ret <4 x float> %63
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z16rsMatrixMultiplyPK12rs_matrix4x4Dv2_f(%struct.rs_matrix4x4* nocapture %m, <2 x float> %in) #4 {
  %1 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <2 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 4
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <2 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 12
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = fadd float %11, %9
  %13 = insertelement <4 x float> undef, float %12, i32 0
  %14 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 1
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = fmul float %3, %15
  %17 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 5
  %18 = load float, float* %17, align 4, !tbaa !18
  %19 = fmul float %7, %18
  %20 = fadd float %16, %19
  %21 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 13
  %22 = load float, float* %21, align 4, !tbaa !18
  %23 = fadd float %22, %20
  %24 = insertelement <4 x float> %13, float %23, i32 1
  %25 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 2
  %26 = load float, float* %25, align 4, !tbaa !18
  %27 = fmul float %3, %26
  %28 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 6
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = fmul float %7, %29
  %31 = fadd float %27, %30
  %32 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 14
  %33 = load float, float* %32, align 4, !tbaa !18
  %34 = fadd float %33, %31
  %35 = insertelement <4 x float> %24, float %34, i32 2
  %36 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 3
  %37 = load float, float* %36, align 4, !tbaa !18
  %38 = fmul float %3, %37
  %39 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 7
  %40 = load float, float* %39, align 4, !tbaa !18
  %41 = fmul float %7, %40
  %42 = fadd float %38, %41
  %43 = getelementptr inbounds %struct.rs_matrix4x4, %struct.rs_matrix4x4* %m, i32 0, i32 0, i32 15
  %44 = load float, float* %43, align 4, !tbaa !18
  %45 = fadd float %44, %42
  %46 = insertelement <4 x float> %35, float %45, i32 3
  ret <4 x float> %46
}

; Function Attrs: nounwind readonly
define <3 x float> @_Z16rsMatrixMultiplyPK12rs_matrix3x3Dv3_f(%struct.rs_matrix3x3* nocapture %m, <3 x float> %in) #4 {
  %1 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <3 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 3
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <3 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 6
  %11 = load float, float* %10, align 4, !tbaa !18
  %12 = extractelement <3 x float> %in, i32 2
  %13 = fmul float %12, %11
  %14 = fadd float %9, %13
  %15 = insertelement <3 x float> undef, float %14, i32 0
  %16 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 1
  %17 = load float, float* %16, align 4, !tbaa !18
  %18 = fmul float %3, %17
  %19 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 4
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = fmul float %7, %20
  %22 = fadd float %18, %21
  %23 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 7
  %24 = load float, float* %23, align 4, !tbaa !18
  %25 = fmul float %12, %24
  %26 = fadd float %22, %25
  %27 = insertelement <3 x float> %15, float %26, i32 1
  %28 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 2
  %29 = load float, float* %28, align 4, !tbaa !18
  %30 = fmul float %3, %29
  %31 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 5
  %32 = load float, float* %31, align 4, !tbaa !18
  %33 = fmul float %7, %32
  %34 = fadd float %30, %33
  %35 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 8
  %36 = load float, float* %35, align 4, !tbaa !18
  %37 = fmul float %12, %36
  %38 = fadd float %34, %37
  %39 = insertelement <3 x float> %27, float %38, i32 2
  ret <3 x float> %39
}

; Function Attrs: nounwind readonly
define <3 x float> @_Z16rsMatrixMultiplyPK12rs_matrix3x3Dv2_f(%struct.rs_matrix3x3* nocapture %m, <2 x float> %in) #4 {
  %1 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 0
  %2 = load float, float* %1, align 4, !tbaa !18
  %3 = extractelement <2 x float> %in, i32 0
  %4 = fmul float %3, %2
  %5 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 3
  %6 = load float, float* %5, align 4, !tbaa !18
  %7 = extractelement <2 x float> %in, i32 1
  %8 = fmul float %7, %6
  %9 = fadd float %4, %8
  %10 = insertelement <3 x float> undef, float %9, i32 0
  %11 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 1
  %12 = load float, float* %11, align 4, !tbaa !18
  %13 = fmul float %3, %12
  %14 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 4
  %15 = load float, float* %14, align 4, !tbaa !18
  %16 = fmul float %7, %15
  %17 = fadd float %13, %16
  %18 = insertelement <3 x float> %10, float %17, i32 1
  %19 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 2
  %20 = load float, float* %19, align 4, !tbaa !18
  %21 = fmul float %3, %20
  %22 = getelementptr inbounds %struct.rs_matrix3x3, %struct.rs_matrix3x3* %m, i32 0, i32 0, i32 5
  %23 = load float, float* %22, align 4, !tbaa !18
  %24 = fmul float %7, %23
  %25 = fadd float %21, %24
  %26 = insertelement <3 x float> %18, float %25, i32 2
  ret <3 x float> %26
}

; Function Attrs: nounwind
define <4 x i8> @_Z17rsPackColorTo8888fff(float %r, float %g, float %b) #5 {
  %1 = fmul float %r, 2.550000e+02
  %2 = fadd float %1, 5.000000e-01
  %3 = tail call float @_Z5clampfff(float %2, float 0.000000e+00, float 2.550000e+02) #12
  %4 = fptoui float %3 to i8
  %5 = insertelement <4 x i8> undef, i8 %4, i32 0
  %6 = fmul float %g, 2.550000e+02
  %7 = fadd float %6, 5.000000e-01
  %8 = tail call float @_Z5clampfff(float %7, float 0.000000e+00, float 2.550000e+02) #12
  %9 = fptoui float %8 to i8
  %10 = insertelement <4 x i8> %5, i8 %9, i32 1
  %11 = fmul float %b, 2.550000e+02
  %12 = fadd float %11, 5.000000e-01
  %13 = tail call float @_Z5clampfff(float %12, float 0.000000e+00, float 2.550000e+02) #12
  %14 = fptoui float %13 to i8
  %15 = insertelement <4 x i8> %10, i8 %14, i32 2
  %16 = insertelement <4 x i8> %15, i8 -1, i32 3
  ret <4 x i8> %16
}

; Function Attrs: nounwind
define <4 x i8> @_Z17rsPackColorTo8888ffff(float %r, float %g, float %b, float %a) #5 {
  %1 = fmul float %r, 2.550000e+02
  %2 = fadd float %1, 5.000000e-01
  %3 = tail call float @_Z5clampfff(float %2, float 0.000000e+00, float 2.550000e+02) #12
  %4 = fptoui float %3 to i8
  %5 = insertelement <4 x i8> undef, i8 %4, i32 0
  %6 = fmul float %g, 2.550000e+02
  %7 = fadd float %6, 5.000000e-01
  %8 = tail call float @_Z5clampfff(float %7, float 0.000000e+00, float 2.550000e+02) #12
  %9 = fptoui float %8 to i8
  %10 = insertelement <4 x i8> %5, i8 %9, i32 1
  %11 = fmul float %b, 2.550000e+02
  %12 = fadd float %11, 5.000000e-01
  %13 = tail call float @_Z5clampfff(float %12, float 0.000000e+00, float 2.550000e+02) #12
  %14 = fptoui float %13 to i8
  %15 = insertelement <4 x i8> %10, i8 %14, i32 2
  %16 = fmul float %a, 2.550000e+02
  %17 = fadd float %16, 5.000000e-01
  %18 = tail call float @_Z5clampfff(float %17, float 0.000000e+00, float 2.550000e+02) #12
  %19 = fptoui float %18 to i8
  %20 = insertelement <4 x i8> %15, i8 %19, i32 3
  ret <4 x i8> %20
}

; Function Attrs: nounwind
define <4 x i8> @_Z17rsPackColorTo8888Dv3_f(<3 x float> %color) #5 {
  %1 = fmul <3 x float> %color, <float 2.550000e+02, float 2.550000e+02, float 2.550000e+02>
  %2 = fadd <3 x float> %1, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %3 = tail call <3 x float> @_Z5clampDv3_fff(<3 x float> %2, float 0.000000e+00, float 2.550000e+02) #12
  %4 = extractelement <3 x float> %3, i32 0
  %5 = fptoui float %4 to i8
  %6 = insertelement <4 x i8> undef, i8 %5, i32 0
  %7 = extractelement <3 x float> %3, i32 1
  %8 = fptoui float %7 to i8
  %9 = insertelement <4 x i8> %6, i8 %8, i32 1
  %10 = extractelement <3 x float> %3, i32 2
  %11 = fptoui float %10 to i8
  %12 = insertelement <4 x i8> %9, i8 %11, i32 2
  %13 = insertelement <4 x i8> %12, i8 -1, i32 3
  ret <4 x i8> %13
}

; Function Attrs: nounwind
define <4 x i8> @_Z17rsPackColorTo8888Dv4_f(<4 x float> %color) #5 {
  %1 = fmul <4 x float> %color, <float 2.550000e+02, float 2.550000e+02, float 2.550000e+02, float 2.550000e+02>
  %2 = fadd <4 x float> %1, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %3 = tail call <4 x float> @_Z5clampDv4_fff(<4 x float> %2, float 0.000000e+00, float 2.550000e+02) #12
  %4 = extractelement <4 x float> %3, i32 0
  %5 = fptoui float %4 to i8
  %6 = insertelement <4 x i8> undef, i8 %5, i32 0
  %7 = extractelement <4 x float> %3, i32 1
  %8 = fptoui float %7 to i8
  %9 = insertelement <4 x i8> %6, i8 %8, i32 1
  %10 = extractelement <4 x float> %3, i32 2
  %11 = fptoui float %10 to i8
  %12 = insertelement <4 x i8> %9, i8 %11, i32 2
  %13 = extractelement <4 x float> %3, i32 3
  %14 = fptoui float %13 to i8
  %15 = insertelement <4 x i8> %12, i8 %14, i32 3
  ret <4 x i8> %15
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z14convert_float2Dv2_h(<2 x i8> %in) #0 {
  %1 = uitofp <2 x i8> %in to <2 x float>
  ret <2 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z14convert_float3Dv3_h(<3 x i8> %in) #0 {
  %1 = uitofp <3 x i8> %in to <3 x float>
  ret <3 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z14convert_float4Dv4_h(<4 x i8> %in) #0 {
  %1 = uitofp <4 x i8> %in to <4 x float>
  ret <4 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z14convert_float2Dv2_c(<2 x i8> %in) #0 {
  %1 = sitofp <2 x i8> %in to <2 x float>
  ret <2 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z14convert_float3Dv3_c(<3 x i8> %in) #0 {
  %1 = sitofp <3 x i8> %in to <3 x float>
  ret <3 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z14convert_float4Dv4_c(<4 x i8> %in) #0 {
  %1 = sitofp <4 x i8> %in to <4 x float>
  ret <4 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z14convert_float2Dv2_t(<2 x i16> %in) #0 {
  %1 = uitofp <2 x i16> %in to <2 x float>
  ret <2 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z14convert_float3Dv3_t(<3 x i16> %in) #0 {
  %1 = uitofp <3 x i16> %in to <3 x float>
  ret <3 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z14convert_float4Dv4_t(<4 x i16> %in) #0 {
  %1 = uitofp <4 x i16> %in to <4 x float>
  ret <4 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z14convert_float2Dv2_s(<2 x i16> %in) #0 {
  %1 = sitofp <2 x i16> %in to <2 x float>
  ret <2 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z14convert_float3Dv3_s(<3 x i16> %in) #0 {
  %1 = sitofp <3 x i16> %in to <3 x float>
  ret <3 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z14convert_float4Dv4_s(<4 x i16> %in) #0 {
  %1 = sitofp <4 x i16> %in to <4 x float>
  ret <4 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z14convert_float2Dv2_j(<2 x i32> %in) #0 {
  %1 = uitofp <2 x i32> %in to <2 x float>
  ret <2 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z14convert_float3Dv3_j(<3 x i32> %in) #0 {
  %1 = uitofp <3 x i32> %in to <3 x float>
  ret <3 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z14convert_float4Dv4_j(<4 x i32> %in) #0 {
  %1 = uitofp <4 x i32> %in to <4 x float>
  ret <4 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z14convert_float2Dv2_i(<2 x i32> %in) #0 {
  %1 = sitofp <2 x i32> %in to <2 x float>
  ret <2 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z14convert_float3Dv3_i(<3 x i32> %in) #0 {
  %1 = sitofp <3 x i32> %in to <3 x float>
  ret <3 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z14convert_float4Dv4_i(<4 x i32> %in) #0 {
  %1 = sitofp <4 x i32> %in to <4 x float>
  ret <4 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z14convert_float2Dv2_f(<2 x float> %in) #0 {
  ret <2 x float> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z14convert_float3Dv3_f(<3 x float> %in) #0 {
  ret <3 x float> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z14convert_float4Dv4_f(<4 x float> %in) #0 {
  ret <4 x float> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z13convert_char4Dv4_f(<4 x float> %in) #0 {
  %1 = fptosi <4 x float> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z13convert_char3Dv3_f(<3 x float> %in) #0 {
  %1 = fptosi <3 x float> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z13convert_char2Dv2_f(<2 x float> %in) #0 {
  %1 = fptosi <2 x float> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z13convert_char4Dv4_h(<4 x i8> %in) #0 {
  ret <4 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z13convert_char3Dv3_h(<3 x i8> %in) #0 {
  ret <3 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z13convert_char2Dv2_h(<2 x i8> %in) #0 {
  ret <2 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z13convert_char4Dv4_c(<4 x i8> %in) #0 {
  ret <4 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z13convert_char3Dv3_c(<3 x i8> %in) #0 {
  ret <3 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z13convert_char2Dv2_c(<2 x i8> %in) #0 {
  ret <2 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z13convert_char4Dv4_t(<4 x i16> %in) #0 {
  %1 = trunc <4 x i16> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z13convert_char3Dv3_t(<3 x i16> %in) #0 {
  %1 = trunc <3 x i16> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z13convert_char2Dv2_t(<2 x i16> %in) #0 {
  %1 = trunc <2 x i16> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z13convert_char4Dv4_s(<4 x i16> %in) #0 {
  %1 = trunc <4 x i16> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z13convert_char3Dv3_s(<3 x i16> %in) #0 {
  %1 = trunc <3 x i16> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z13convert_char2Dv2_s(<2 x i16> %in) #0 {
  %1 = trunc <2 x i16> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z13convert_char4Dv4_j(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z13convert_char3Dv3_j(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z13convert_char2Dv2_j(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z13convert_char4Dv4_i(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z13convert_char3Dv3_i(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z13convert_char2Dv2_i(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z14convert_uchar4Dv4_f(<4 x float> %in) #0 {
  %1 = fptoui <4 x float> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z14convert_uchar3Dv3_f(<3 x float> %in) #0 {
  %1 = fptoui <3 x float> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z14convert_uchar2Dv2_f(<2 x float> %in) #0 {
  %1 = fptoui <2 x float> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z14convert_uchar4Dv4_h(<4 x i8> %in) #0 {
  ret <4 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z14convert_uchar3Dv3_h(<3 x i8> %in) #0 {
  ret <3 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z14convert_uchar2Dv2_h(<2 x i8> %in) #0 {
  ret <2 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z14convert_uchar4Dv4_c(<4 x i8> %in) #0 {
  ret <4 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z14convert_uchar3Dv3_c(<3 x i8> %in) #0 {
  ret <3 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z14convert_uchar2Dv2_c(<2 x i8> %in) #0 {
  ret <2 x i8> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z14convert_uchar4Dv4_t(<4 x i16> %in) #0 {
  %1 = trunc <4 x i16> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z14convert_uchar3Dv3_t(<3 x i16> %in) #0 {
  %1 = trunc <3 x i16> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z14convert_uchar2Dv2_t(<2 x i16> %in) #0 {
  %1 = trunc <2 x i16> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z14convert_uchar4Dv4_s(<4 x i16> %in) #0 {
  %1 = trunc <4 x i16> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z14convert_uchar3Dv3_s(<3 x i16> %in) #0 {
  %1 = trunc <3 x i16> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z14convert_uchar2Dv2_s(<2 x i16> %in) #0 {
  %1 = trunc <2 x i16> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z14convert_uchar4Dv4_j(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z14convert_uchar3Dv3_j(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z14convert_uchar2Dv2_j(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i8> @_Z14convert_uchar4Dv4_i(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i8>
  ret <4 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i8> @_Z14convert_uchar3Dv3_i(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i8>
  ret <3 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i8> @_Z14convert_uchar2Dv2_i(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i8>
  ret <2 x i8> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z14convert_short4Dv4_f(<4 x float> %in) #0 {
  %1 = fptosi <4 x float> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z14convert_short3Dv3_f(<3 x float> %in) #0 {
  %1 = fptosi <3 x float> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z14convert_short2Dv2_f(<2 x float> %in) #0 {
  %1 = fptosi <2 x float> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z14convert_short4Dv4_h(<4 x i8> %in) #0 {
  %1 = zext <4 x i8> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z14convert_short3Dv3_h(<3 x i8> %in) #0 {
  %1 = zext <3 x i8> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z14convert_short2Dv2_h(<2 x i8> %in) #0 {
  %1 = zext <2 x i8> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z14convert_short4Dv4_c(<4 x i8> %in) #0 {
  %1 = sext <4 x i8> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z14convert_short3Dv3_c(<3 x i8> %in) #0 {
  %1 = sext <3 x i8> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z14convert_short2Dv2_c(<2 x i8> %in) #0 {
  %1 = sext <2 x i8> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z14convert_short4Dv4_t(<4 x i16> %in) #0 {
  ret <4 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z14convert_short3Dv3_t(<3 x i16> %in) #0 {
  ret <3 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z14convert_short2Dv2_t(<2 x i16> %in) #0 {
  ret <2 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z14convert_short4Dv4_s(<4 x i16> %in) #0 {
  ret <4 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z14convert_short3Dv3_s(<3 x i16> %in) #0 {
  ret <3 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z14convert_short2Dv2_s(<2 x i16> %in) #0 {
  ret <2 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z14convert_short4Dv4_j(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z14convert_short3Dv3_j(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z14convert_short2Dv2_j(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z14convert_short4Dv4_i(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z14convert_short3Dv3_i(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z14convert_short2Dv2_i(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z15convert_ushort4Dv4_f(<4 x float> %in) #0 {
  %1 = fptoui <4 x float> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z15convert_ushort3Dv3_f(<3 x float> %in) #0 {
  %1 = fptoui <3 x float> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z15convert_ushort2Dv2_f(<2 x float> %in) #0 {
  %1 = fptoui <2 x float> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z15convert_ushort4Dv4_h(<4 x i8> %in) #0 {
  %1 = zext <4 x i8> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z15convert_ushort3Dv3_h(<3 x i8> %in) #0 {
  %1 = zext <3 x i8> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z15convert_ushort2Dv2_h(<2 x i8> %in) #0 {
  %1 = zext <2 x i8> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z15convert_ushort4Dv4_c(<4 x i8> %in) #0 {
  %1 = zext <4 x i8> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z15convert_ushort3Dv3_c(<3 x i8> %in) #0 {
  %1 = zext <3 x i8> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z15convert_ushort2Dv2_c(<2 x i8> %in) #0 {
  %1 = zext <2 x i8> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z15convert_ushort4Dv4_t(<4 x i16> %in) #0 {
  ret <4 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z15convert_ushort3Dv3_t(<3 x i16> %in) #0 {
  ret <3 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z15convert_ushort2Dv2_t(<2 x i16> %in) #0 {
  ret <2 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z15convert_ushort4Dv4_s(<4 x i16> %in) #0 {
  ret <4 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z15convert_ushort3Dv3_s(<3 x i16> %in) #0 {
  ret <3 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z15convert_ushort2Dv2_s(<2 x i16> %in) #0 {
  ret <2 x i16> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z15convert_ushort4Dv4_j(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z15convert_ushort3Dv3_j(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z15convert_ushort2Dv2_j(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i16> @_Z15convert_ushort4Dv4_i(<4 x i32> %in) #0 {
  %1 = trunc <4 x i32> %in to <4 x i16>
  ret <4 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i16> @_Z15convert_ushort3Dv3_i(<3 x i32> %in) #0 {
  %1 = trunc <3 x i32> %in to <3 x i16>
  ret <3 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i16> @_Z15convert_ushort2Dv2_i(<2 x i32> %in) #0 {
  %1 = trunc <2 x i32> %in to <2 x i16>
  ret <2 x i16> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z12convert_int4Dv4_f(<4 x float> %in) #0 {
  %1 = fptosi <4 x float> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z12convert_int3Dv3_f(<3 x float> %in) #0 {
  %1 = fptosi <3 x float> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z12convert_int2Dv2_f(<2 x float> %in) #0 {
  %1 = fptosi <2 x float> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z12convert_int4Dv4_h(<4 x i8> %in) #0 {
  %1 = zext <4 x i8> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z12convert_int3Dv3_h(<3 x i8> %in) #0 {
  %1 = zext <3 x i8> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z12convert_int2Dv2_h(<2 x i8> %in) #0 {
  %1 = zext <2 x i8> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z12convert_int4Dv4_c(<4 x i8> %in) #0 {
  %1 = sext <4 x i8> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z12convert_int3Dv3_c(<3 x i8> %in) #0 {
  %1 = sext <3 x i8> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z12convert_int2Dv2_c(<2 x i8> %in) #0 {
  %1 = sext <2 x i8> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z12convert_int4Dv4_t(<4 x i16> %in) #0 {
  %1 = zext <4 x i16> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z12convert_int3Dv3_t(<3 x i16> %in) #0 {
  %1 = zext <3 x i16> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z12convert_int2Dv2_t(<2 x i16> %in) #0 {
  %1 = zext <2 x i16> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z12convert_int4Dv4_s(<4 x i16> %in) #0 {
  %1 = sext <4 x i16> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z12convert_int3Dv3_s(<3 x i16> %in) #0 {
  %1 = sext <3 x i16> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z12convert_int2Dv2_s(<2 x i16> %in) #0 {
  %1 = sext <2 x i16> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z12convert_int4Dv4_j(<4 x i32> %in) #0 {
  ret <4 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z12convert_int3Dv3_j(<3 x i32> %in) #0 {
  ret <3 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z12convert_int2Dv2_j(<2 x i32> %in) #0 {
  ret <2 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z12convert_int4Dv4_i(<4 x i32> %in) #0 {
  ret <4 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z12convert_int3Dv3_i(<3 x i32> %in) #0 {
  ret <3 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z12convert_int2Dv2_i(<2 x i32> %in) #0 {
  ret <2 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z13convert_uint4Dv4_f(<4 x float> %in) #0 {
  %1 = fptoui <4 x float> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z13convert_uint3Dv3_f(<3 x float> %in) #0 {
  %1 = fptoui <3 x float> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z13convert_uint2Dv2_f(<2 x float> %in) #0 {
  %1 = fptoui <2 x float> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z13convert_uint4Dv4_h(<4 x i8> %in) #0 {
  %1 = zext <4 x i8> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z13convert_uint3Dv3_h(<3 x i8> %in) #0 {
  %1 = zext <3 x i8> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z13convert_uint2Dv2_h(<2 x i8> %in) #0 {
  %1 = zext <2 x i8> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z13convert_uint4Dv4_c(<4 x i8> %in) #0 {
  %1 = zext <4 x i8> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z13convert_uint3Dv3_c(<3 x i8> %in) #0 {
  %1 = zext <3 x i8> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z13convert_uint2Dv2_c(<2 x i8> %in) #0 {
  %1 = zext <2 x i8> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z13convert_uint4Dv4_t(<4 x i16> %in) #0 {
  %1 = zext <4 x i16> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z13convert_uint3Dv3_t(<3 x i16> %in) #0 {
  %1 = zext <3 x i16> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z13convert_uint2Dv2_t(<2 x i16> %in) #0 {
  %1 = zext <2 x i16> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z13convert_uint4Dv4_s(<4 x i16> %in) #0 {
  %1 = zext <4 x i16> %in to <4 x i32>
  ret <4 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z13convert_uint3Dv3_s(<3 x i16> %in) #0 {
  %1 = zext <3 x i16> %in to <3 x i32>
  ret <3 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z13convert_uint2Dv2_s(<2 x i16> %in) #0 {
  %1 = zext <2 x i16> %in to <2 x i32>
  ret <2 x i32> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z13convert_uint4Dv4_j(<4 x i32> %in) #0 {
  ret <4 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z13convert_uint3Dv3_j(<3 x i32> %in) #0 {
  ret <3 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z13convert_uint2Dv2_j(<2 x i32> %in) #0 {
  ret <2 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x i32> @_Z13convert_uint4Dv4_i(<4 x i32> %in) #0 {
  ret <4 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x i32> @_Z13convert_uint3Dv3_i(<3 x i32> %in) #0 {
  ret <3 x i32> %in
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x i32> @_Z13convert_uint2Dv2_i(<2 x i32> %in) #0 {
  ret <2 x i32> %in
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_char([1 x i32] %a.coerce, i8 signext %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i = add i32 %9, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %10 = add i32 %tmp1.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  store i8 %val, i8* %11, align 1, !tbaa !27
  ret void
}

; Function Attrs: nounwind readonly
define signext i8 @rsGetElementAtImpl_char([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i = add i32 %9, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %10 = add i32 %tmp1.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  %12 = load i8, i8* %11, align 1, !tbaa !27
  ret i8 %12
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_char2([1 x i32] %a.coerce, <2 x i8> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %13, align 2, !tbaa !30
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i8> @rsGetElementAtImpl_char2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  %14 = load <2 x i8>, <2 x i8>* %13, align 2, !tbaa !30
  ret <2 x i8> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_char3([1 x i32] %a.coerce, <3 x i8> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %13, <4 x i8>* %14, align 4, !tbaa !31
  ret void
}

; Function Attrs: nounwind readonly
define <3 x i8> @rsGetElementAtImpl_char3([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !31
  %15 = shufflevector <4 x i8> %14, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %15
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_char4([1 x i32] %a.coerce, <4 x i8> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %13, align 4, !tbaa !32
  ret void
}

; Function Attrs: nounwind readonly
define <4 x i8> @rsGetElementAtImpl_char4([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !32
  ret <4 x i8> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uchar([1 x i32] %a.coerce, i8 zeroext %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i = add i32 %9, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %10 = add i32 %tmp1.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  store i8 %val, i8* %11, align 1, !tbaa !33
  ret void
}

; Function Attrs: nounwind readonly
define zeroext i8 @rsGetElementAtImpl_uchar([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %8, %z
  %tmp.i = add i32 %9, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %10 = add i32 %tmp1.i, %x
  %11 = getelementptr inbounds i8, i8* %4, i32 %10
  %12 = load i8, i8* %11, align 1, !tbaa !33
  ret i8 %12
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uchar2([1 x i32] %a.coerce, <2 x i8> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  store <2 x i8> %val, <2 x i8>* %13, align 2, !tbaa !34
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i8> @rsGetElementAtImpl_uchar2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i8>*
  %14 = load <2 x i8>, <2 x i8>* %13, align 2, !tbaa !34
  ret <2 x i8> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uchar3([1 x i32] %a.coerce, <3 x i8> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i8> %val, <3 x i8> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %13, <4 x i8>* %14, align 4, !tbaa !35
  ret void
}

; Function Attrs: nounwind readonly
define <3 x i8> @rsGetElementAtImpl_uchar3([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !35
  %15 = shufflevector <4 x i8> %14, <4 x i8> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i8> %15
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uchar4([1 x i32] %a.coerce, <4 x i8> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  store <4 x i8> %val, <4 x i8>* %13, align 4, !tbaa !36
  ret void
}

; Function Attrs: nounwind readonly
define <4 x i8> @rsGetElementAtImpl_uchar4([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i8>*
  %14 = load <4 x i8>, <4 x i8>* %13, align 4, !tbaa !36
  ret <4 x i8> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_short([1 x i32] %a.coerce, i16 signext %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  store i16 %val, i16* %13, align 2, !tbaa !37
  ret void
}

; Function Attrs: nounwind readonly
define signext i16 @rsGetElementAtImpl_short([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  %14 = load i16, i16* %13, align 2, !tbaa !37
  ret i16 %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_short2([1 x i32] %a.coerce, <2 x i16> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %13, align 4, !tbaa !38
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i16> @rsGetElementAtImpl_short2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  %14 = load <2 x i16>, <2 x i16>* %13, align 4, !tbaa !38
  ret <2 x i16> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_short3([1 x i32] %a.coerce, <3 x i16> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %13, <4 x i16>* %14, align 8, !tbaa !39
  ret void
}

; Function Attrs: nounwind readonly
define <3 x i16> @rsGetElementAtImpl_short3([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !39
  %15 = shufflevector <4 x i16> %14, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %15
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_short4([1 x i32] %a.coerce, <4 x i16> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %13, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind readonly
define <4 x i16> @rsGetElementAtImpl_short4([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !40
  ret <4 x i16> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ushort([1 x i32] %a.coerce, i16 zeroext %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  store i16 %val, i16* %13, align 2, !tbaa !41
  ret void
}

; Function Attrs: nounwind readonly
define zeroext i16 @rsGetElementAtImpl_ushort([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 2
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i16*
  %14 = load i16, i16* %13, align 2, !tbaa !41
  ret i16 %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ushort2([1 x i32] %a.coerce, <2 x i16> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  store <2 x i16> %val, <2 x i16>* %13, align 4, !tbaa !42
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i16> @rsGetElementAtImpl_ushort2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i16>*
  %14 = load <2 x i16>, <2 x i16>* %13, align 4, !tbaa !42
  ret <2 x i16> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ushort3([1 x i32] %a.coerce, <3 x i16> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i16> %val, <3 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %13, <4 x i16>* %14, align 8, !tbaa !43
  ret void
}

; Function Attrs: nounwind readonly
define <3 x i16> @rsGetElementAtImpl_ushort3([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !43
  %15 = shufflevector <4 x i16> %14, <4 x i16> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i16> %15
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ushort4([1 x i32] %a.coerce, <4 x i16> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  store <4 x i16> %val, <4 x i16>* %13, align 8, !tbaa !44
  ret void
}

; Function Attrs: nounwind readonly
define <4 x i16> @rsGetElementAtImpl_ushort4([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i16>*
  %14 = load <4 x i16>, <4 x i16>* %13, align 8, !tbaa !44
  ret <4 x i16> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_int([1 x i32] %a.coerce, i32 %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  store i32 %val, i32* %13, align 4, !tbaa !45
  ret void
}

; Function Attrs: nounwind readonly
define i32 @rsGetElementAtImpl_int([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13, align 4, !tbaa !45
  ret i32 %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_int2([1 x i32] %a.coerce, <2 x i32> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %13, align 8, !tbaa !46
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i32> @rsGetElementAtImpl_int2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  %14 = load <2 x i32>, <2 x i32>* %13, align 8, !tbaa !46
  ret <2 x i32> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_int3([1 x i32] %a.coerce, <3 x i32> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %13, <4 x i32>* %14, align 16, !tbaa !47
  ret void
}

; Function Attrs: nounwind readonly
define <3 x i32> @rsGetElementAtImpl_int3([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 8, !tbaa !47
  %15 = shufflevector <4 x i32> %14, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %15
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_int4([1 x i32] %a.coerce, <4 x i32> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %13, align 16, !tbaa !48
  ret void
}

; Function Attrs: nounwind readonly
define <4 x i32> @rsGetElementAtImpl_int4([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 16, !tbaa !48
  ret <4 x i32> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uint([1 x i32] %a.coerce, i32 %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  store i32 %val, i32* %13, align 4, !tbaa !49
  ret void
}

; Function Attrs: nounwind readonly
define i32 @rsGetElementAtImpl_uint([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13, align 4, !tbaa !49
  ret i32 %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uint2([1 x i32] %a.coerce, <2 x i32> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  store <2 x i32> %val, <2 x i32>* %13, align 8, !tbaa !50
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i32> @rsGetElementAtImpl_uint2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i32>*
  %14 = load <2 x i32>, <2 x i32>* %13, align 8, !tbaa !50
  ret <2 x i32> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uint3([1 x i32] %a.coerce, <3 x i32> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i32> %val, <3 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %13, <4 x i32>* %14, align 16, !tbaa !51
  ret void
}

; Function Attrs: nounwind readonly
define <3 x i32> @rsGetElementAtImpl_uint3([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 8, !tbaa !51
  %15 = shufflevector <4 x i32> %14, <4 x i32> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x i32> %15
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_uint4([1 x i32] %a.coerce, <4 x i32> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  store <4 x i32> %val, <4 x i32>* %13, align 16, !tbaa !52
  ret void
}

; Function Attrs: nounwind readonly
define <4 x i32> @rsGetElementAtImpl_uint4([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i32>*
  %14 = load <4 x i32>, <4 x i32>* %13, align 16, !tbaa !52
  ret <4 x i32> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_long([1 x i32] %a.coerce, i64 %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  store i64 %val, i64* %13, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind readonly
define i64 @rsGetElementAtImpl_long([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !53
  ret i64 %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_long2([1 x i32] %a.coerce, <2 x i64> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %13, align 16, !tbaa !54
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i64> @rsGetElementAtImpl_long2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  %14 = load <2 x i64>, <2 x i64>* %13, align 16, !tbaa !54
  ret <2 x i64> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_long3([1 x i32] %a.coerce, <3 x i64> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %13, <4 x i64>* %14, align 32, !tbaa !55
  ret void
}

; Function Attrs: nounwind
define void @rsGetElementAtImpl_long3(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  %14 = load <4 x i64>, <4 x i64>* %13, align 32
  %15 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %14, <4 x i64>* %15, align 32, !tbaa !55
  ret void
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_long4([1 x i32] %a.coerce, <4 x i64> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %13, align 32, !tbaa !56
  ret void
}

; Function Attrs: nounwind
define void @rsGetElementAtImpl_long4(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  %14 = load <4 x i64>, <4 x i64>* %13, align 32, !tbaa !28
  store <4 x i64> %14, <4 x i64>* %agg.result, align 32, !tbaa !56
  ret void
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ulong([1 x i32] %a.coerce, i64 %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  store i64 %val, i64* %13, align 8, !tbaa !57
  ret void
}

; Function Attrs: nounwind readonly
define i64 @rsGetElementAtImpl_ulong([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !57
  ret i64 %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ulong2([1 x i32] %a.coerce, <2 x i64> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  store <2 x i64> %val, <2 x i64>* %13, align 16, !tbaa !58
  ret void
}

; Function Attrs: nounwind readonly
define <2 x i64> @rsGetElementAtImpl_ulong2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x i64>*
  %14 = load <2 x i64>, <2 x i64>* %13, align 16, !tbaa !58
  ret <2 x i64> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ulong3([1 x i32] %a.coerce, <3 x i64> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x i64> %val, <3 x i64> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %13, <4 x i64>* %14, align 32, !tbaa !59
  ret void
}

; Function Attrs: nounwind
define void @rsGetElementAtImpl_ulong3(<3 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  %14 = load <4 x i64>, <4 x i64>* %13, align 32
  %15 = bitcast <3 x i64>* %agg.result to <4 x i64>*
  store <4 x i64> %14, <4 x i64>* %15, align 32, !tbaa !59
  ret void
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_ulong4([1 x i32] %a.coerce, <4 x i64> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  store <4 x i64> %val, <4 x i64>* %13, align 32, !tbaa !60
  ret void
}

; Function Attrs: nounwind
define void @rsGetElementAtImpl_ulong4(<4 x i64>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x i64>*
  %14 = load <4 x i64>, <4 x i64>* %13, align 32, !tbaa !28
  store <4 x i64> %14, <4 x i64>* %agg.result, align 32, !tbaa !60
  ret void
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_float([1 x i32] %a.coerce, float %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to float*
  store float %val, float* %13, align 4, !tbaa !61
  ret void
}

; Function Attrs: nounwind readonly
define float @rsGetElementAtImpl_float([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 4
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to float*
  %14 = load float, float* %13, align 4, !tbaa !61
  ret float %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_float2([1 x i32] %a.coerce, <2 x float> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x float>*
  store <2 x float> %val, <2 x float>* %13, align 8, !tbaa !62
  ret void
}

; Function Attrs: nounwind readonly
define <2 x float> @rsGetElementAtImpl_float2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x float>*
  %14 = load <2 x float>, <2 x float>* %13, align 8, !tbaa !62
  ret <2 x float> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_float3([1 x i32] %a.coerce, <3 x float> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x float> %val, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x float>*
  store <4 x float> %13, <4 x float>* %14, align 16, !tbaa !63
  ret void
}

; Function Attrs: nounwind readonly
define <3 x float> @rsGetElementAtImpl_float3([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x float>*
  %14 = load <4 x float>, <4 x float>* %13, align 8, !tbaa !63
  %15 = shufflevector <4 x float> %14, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %15
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_float4([1 x i32] %a.coerce, <4 x float> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x float>*
  store <4 x float> %val, <4 x float>* %13, align 16, !tbaa !64
  ret void
}

; Function Attrs: nounwind readonly
define <4 x float> @rsGetElementAtImpl_float4([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x float>*
  %14 = load <4 x float>, <4 x float>* %13, align 16, !tbaa !64
  ret <4 x float> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_double([1 x i32] %a.coerce, double %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to double*
  store double %val, double* %13, align 8, !tbaa !65
  ret void
}

; Function Attrs: nounwind readonly
define double @rsGetElementAtImpl_double([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 8
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to double*
  %14 = load double, double* %13, align 8, !tbaa !65
  ret double %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_double2([1 x i32] %a.coerce, <2 x double> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x double>*
  store <2 x double> %val, <2 x double>* %13, align 16, !tbaa !66
  ret void
}

; Function Attrs: nounwind readonly
define <2 x double> @rsGetElementAtImpl_double2([1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #10 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 16
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <2 x double>*
  %14 = load <2 x double>, <2 x double>* %13, align 16, !tbaa !66
  ret <2 x double> %14
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_double3([1 x i32] %a.coerce, <3 x double> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = shufflevector <3 x double> %val, <3 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 undef>
  %14 = bitcast i8* %12 to <4 x double>*
  store <4 x double> %13, <4 x double>* %14, align 32, !tbaa !67
  ret void
}

; Function Attrs: nounwind
define void @rsGetElementAtImpl_double3(<3 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x double>*
  %14 = load <4 x double>, <4 x double>* %13, align 32
  %15 = bitcast <3 x double>* %agg.result to <4 x double>*
  store <4 x double> %14, <4 x double>* %15, align 32, !tbaa !67
  ret void
}

; Function Attrs: nounwind
define void @rsSetElementAtImpl_double4([1 x i32] %a.coerce, <4 x double> %val, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x double>*
  store <4 x double> %val, <4 x double>* %13, align 32, !tbaa !68
  ret void
}

; Function Attrs: nounwind
define void @rsGetElementAtImpl_double4(<4 x double>* noalias nocapture sret %agg.result, [1 x i32] %a.coerce, i32 %x, i32 %y, i32 %z) #9 {
  %1 = extractvalue [1 x i32] %a.coerce, 0
  %2 = inttoptr i32 %1 to %struct.Allocation*
  %3 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 0
  %4 = load i8*, i8** %3, align 4, !tbaa !22
  %5 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !21
  %7 = getelementptr inbounds %struct.Allocation, %struct.Allocation* %2, i32 0, i32 1, i32 2, i32 0, i32 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = mul i32 %x, 32
  %10 = mul i32 %8, %z
  %tmp.i = add i32 %10, %y
  %tmp1.i = mul i32 %tmp.i, %6
  %11 = add i32 %tmp1.i, %9
  %12 = getelementptr inbounds i8, i8* %4, i32 %11
  %13 = bitcast i8* %12 to <4 x double>*
  %14 = load <4 x double>, <4 x double>* %13, align 32, !tbaa !28
  store <4 x double> %14, <4 x double>* %agg.result, align 32, !tbaa !68
  ret void
}

; Function Attrs: nounwind readonly
define float @_Z7rsClampfff(float %value, float %low, float %high) #11 {
  %1 = fcmp olt float %value, %high
  %2 = select i1 %1, float %value, float %high
  %3 = fcmp ogt float %2, %low
  %4 = select i1 %3, float %2, float %low
  ret float %4
}

; Function Attrs: nounwind readonly
define signext i8 @_Z7rsClampccc(i8 signext %value, i8 signext %low, i8 signext %high) #11 {
  %1 = icmp slt i8 %value, %high
  %2 = select i1 %1, i8 %value, i8 %high
  %3 = icmp sgt i8 %2, %low
  %4 = select i1 %3, i8 %2, i8 %low
  ret i8 %4
}

; Function Attrs: nounwind readonly
define zeroext i8 @_Z7rsClamphhh(i8 zeroext %value, i8 zeroext %low, i8 zeroext %high) #11 {
  %1 = icmp ult i8 %value, %high
  %2 = select i1 %1, i8 %value, i8 %high
  %3 = icmp ugt i8 %2, %low
  %4 = select i1 %3, i8 %2, i8 %low
  ret i8 %4
}

; Function Attrs: nounwind readonly
define signext i16 @_Z7rsClampsss(i16 signext %value, i16 signext %low, i16 signext %high) #11 {
  %1 = icmp slt i16 %value, %high
  %2 = select i1 %1, i16 %value, i16 %high
  %3 = icmp sgt i16 %2, %low
  %4 = select i1 %3, i16 %2, i16 %low
  ret i16 %4
}

; Function Attrs: nounwind readonly
define zeroext i16 @_Z7rsClampttt(i16 zeroext %value, i16 zeroext %low, i16 zeroext %high) #11 {
  %1 = icmp ult i16 %value, %high
  %2 = select i1 %1, i16 %value, i16 %high
  %3 = icmp ugt i16 %2, %low
  %4 = select i1 %3, i16 %2, i16 %low
  ret i16 %4
}

; Function Attrs: nounwind readonly
define i32 @_Z7rsClampiii(i32 %value, i32 %low, i32 %high) #11 {
  %1 = icmp slt i32 %value, %high
  %2 = select i1 %1, i32 %value, i32 %high
  %3 = icmp sgt i32 %2, %low
  %4 = select i1 %3, i32 %2, i32 %low
  ret i32 %4
}

; Function Attrs: nounwind readonly
define i32 @_Z7rsClampjjj(i32 %value, i32 %low, i32 %high) #11 {
  %1 = icmp ult i32 %value, %high
  %2 = select i1 %1, i32 %value, i32 %high
  %3 = icmp ugt i32 %2, %low
  %4 = select i1 %3, i32 %2, i32 %low
  ret i32 %4
}

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.min.ps(<4 x float>, <4 x float>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.max.ps(<4 x float>, <4 x float>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.min.ss(<4 x float>, <4 x float>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.max.ss(<4 x float>, <4 x float>) #8

; Function Attrs: nounwind readonly
declare float @llvm.sqrt.f32(float) #11

; Function Attrs: nounwind readonly
declare <2 x float> @llvm.sqrt.v2f32(<2 x float>) #11

; Function Attrs: nounwind readonly
declare <3 x float> @llvm.sqrt.v3f32(<3 x float>) #11

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.sqrt.v4f32(<4 x float>) #11

; Function Attrs: nounwind readonly
declare float @llvm.exp.f32(float) #11

; Function Attrs: nounwind readonly
declare float @llvm.pow.f32(float, float) #11

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z5clampDv4_fS_S_(<4 x float> %in, <4 x float> %low, <4 x float> %high) #0 {
  %1 = tail call <4 x float> @llvm.x86.sse.min.ps(<4 x float> %in, <4 x float> %high) #8
  %2 = tail call <4 x float> @llvm.x86.sse.max.ps(<4 x float> %1, <4 x float> %low) #8
  ret <4 x float> %2
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z5clampDv3_fS_S_(<3 x float> %in, <3 x float> %low, <3 x float> %high) #0 {
  %1 = shufflevector <3 x float> %in, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <3 x float> %low, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = shufflevector <3 x float> %high, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = tail call <4 x float> @_Z5clampDv4_fS_S_(<4 x float> %1, <4 x float> %2, <4 x float> %3) #8
  %5 = shufflevector <4 x float> %4, <4 x float> undef, <3 x i32> <i32 0, i32 1, i32 2>
  ret <3 x float> %5
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z5clampDv2_fS_S_(<2 x float> %in, <2 x float> %low, <2 x float> %high) #0 {
  %1 = shufflevector <2 x float> %in, <2 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <2 x float> %low, <2 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = shufflevector <2 x float> %high, <2 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = tail call <4 x float> @_Z5clampDv4_fS_S_(<4 x float> %1, <4 x float> %2, <4 x float> %3) #8
  %5 = shufflevector <4 x float> %4, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  ret <2 x float> %5
}

; Function Attrs: alwaysinline nounwind readnone
define float @_Z5clampfff(float %in, float %low, float %high) #0 {
  %1 = insertelement <4 x float> undef, float %in, i32 0
  %2 = insertelement <4 x float> undef, float %low, i32 0
  %3 = insertelement <4 x float> undef, float %high, i32 0
  %4 = tail call <4 x float> @llvm.x86.sse.min.ss(<4 x float> %1, <4 x float> %3) #8
  %5 = tail call <4 x float> @llvm.x86.sse.max.ss(<4 x float> %4, <4 x float> %2) #8
  %6 = extractelement <4 x float> %5, i32 0
  ret float %6
}

; Function Attrs: nounwind readonly
define <4 x float> @_Z5clampDv4_fff(<4 x float> %in, float %low, float %high) #11 {
  %1 = insertelement <4 x float> undef, float %low, i32 0
  %2 = insertelement <4 x float> %1, float %low, i32 1
  %3 = insertelement <4 x float> %2, float %low, i32 2
  %4 = insertelement <4 x float> %3, float %low, i32 3
  %5 = insertelement <4 x float> undef, float %high, i32 0
  %6 = insertelement <4 x float> %5, float %high, i32 1
  %7 = insertelement <4 x float> %6, float %high, i32 2
  %8 = insertelement <4 x float> %7, float %high, i32 3
  %9 = tail call <4 x float> @_Z5clampDv4_fS_S_(<4 x float> %in, <4 x float> %4, <4 x float> %8) #8
  ret <4 x float> %9
}

; Function Attrs: nounwind readonly
define <3 x float> @_Z5clampDv3_fff(<3 x float> %in, float %low, float %high) #11 {
  %1 = insertelement <3 x float> undef, float %low, i32 0
  %2 = insertelement <3 x float> %1, float %low, i32 1
  %3 = insertelement <3 x float> %2, float %low, i32 2
  %4 = insertelement <3 x float> undef, float %high, i32 0
  %5 = insertelement <3 x float> %4, float %high, i32 1
  %6 = insertelement <3 x float> %5, float %high, i32 2
  %7 = tail call <3 x float> @_Z5clampDv3_fS_S_(<3 x float> %in, <3 x float> %3, <3 x float> %6) #8
  ret <3 x float> %7
}

; Function Attrs: nounwind readonly
define <2 x float> @_Z5clampDv2_fff(<2 x float> %in, float %low, float %high) #11 {
  %1 = insertelement <2 x float> undef, float %low, i32 0
  %2 = insertelement <2 x float> %1, float %low, i32 1
  %3 = insertelement <2 x float> undef, float %high, i32 0
  %4 = insertelement <2 x float> %3, float %high, i32 1
  %5 = tail call <2 x float> @_Z5clampDv2_fS_S_(<2 x float> %in, <2 x float> %2, <2 x float> %4) #8
  ret <2 x float> %5
}

; Function Attrs: alwaysinline nounwind readnone
define float @_Z4sqrtf(float %in) #0 {
  %1 = tail call float @llvm.sqrt.f32(float %in) #8
  ret float %1
}

; Function Attrs: alwaysinline nounwind readnone
define <2 x float> @_Z4sqrtDv2_f(<2 x float> %in) #0 {
  %1 = tail call <2 x float> @llvm.sqrt.v2f32(<2 x float> %in) #8
  ret <2 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <3 x float> @_Z4sqrtDv3_f(<3 x float> %in) #0 {
  %1 = tail call <3 x float> @llvm.sqrt.v3f32(<3 x float> %in) #8
  ret <3 x float> %1
}

; Function Attrs: alwaysinline nounwind readnone
define <4 x float> @_Z4sqrtDv4_f(<4 x float> %in) #0 {
  %1 = tail call <4 x float> @llvm.sqrt.v4f32(<4 x float> %in) #8
  ret <4 x float> %1
}

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.psll.dq(<2 x i64>, i32) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float>, <4 x float>) #8

; Function Attrs: nounwind readnone
define float @_Z3dotDv4_fS_(<4 x float> %lhs, <4 x float> %rhs) #8 {
  %1 = fmul <4 x float> %lhs, %rhs
  %2 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %1, <4 x float> %1) #8
  %3 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %2, <4 x float> %2) #8
  %4 = extractelement <4 x float> %3, i32 0
  ret float %4
}

; Function Attrs: nounwind readnone
define float @_Z3dotDv3_fS_(<3 x float> %lhs, <3 x float> %rhs) #8 {
  %1 = fmul <3 x float> %lhs, %rhs
  %2 = shufflevector <3 x float> %1, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = bitcast <4 x float> %2 to <2 x i64>
  %4 = tail call <2 x i64> @llvm.x86.sse2.psll.dq(<2 x i64> %3, i32 32)
  %5 = bitcast <2 x i64> %4 to <4 x float>
  %6 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %5, <4 x float> %5) #8
  %7 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %6, <4 x float> %6) #8
  %8 = extractelement <4 x float> %7, i32 0
  ret float %8
}

; Function Attrs: nounwind readnone
define float @_Z3dotDv2_fS_(<2 x float> %lhs, <2 x float> %rhs) #8 {
  %1 = fmul <2 x float> %lhs, %rhs
  %2 = shufflevector <2 x float> %1, <2 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %2, <4 x float> %2) #8
  %4 = extractelement <4 x float> %3, i32 0
  ret float %4
}

; Function Attrs: nounwind readnone
define float @_Z3dotff(float %lhs, float %rhs) #8 {
  %1 = fmul float %lhs, %rhs
  ret float %1
}

; Function Attrs: alwaysinline nounwind readnone
define float @_Z6lengthDv4_f(<4 x float> %in) #0 {
  %1 = fmul <4 x float> %in, %in
  %2 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %1, <4 x float> %1) #8
  %3 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %2, <4 x float> %2) #8
  %4 = extractelement <4 x float> %3, i32 0
  %5 = tail call float @llvm.sqrt.f32(float %4) #8
  ret float %5
}

; Function Attrs: alwaysinline nounwind readnone
define float @_Z6lengthDv3_f(<3 x float> %in) #0 {
  %1 = fmul <3 x float> %in, %in
  %2 = shufflevector <3 x float> %1, <3 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = bitcast <4 x float> %2 to <2 x i64>
  %4 = tail call <2 x i64> @llvm.x86.sse2.psll.dq(<2 x i64> %3, i32 32)
  %5 = bitcast <2 x i64> %4 to <4 x float>
  %6 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %5, <4 x float> %5) #8
  %7 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %6, <4 x float> %6) #8
  %8 = extractelement <4 x float> %7, i32 0
  %9 = tail call float @llvm.sqrt.f32(float %8) #8
  ret float %9
}

; Function Attrs: alwaysinline nounwind readnone
define float @_Z6lengthDv2_f(<2 x float> %in) #0 {
  %1 = fmul <2 x float> %in, %in
  %2 = shufflevector <2 x float> %1, <2 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float> %2, <4 x float> %2) #8
  %4 = extractelement <4 x float> %3, i32 0
  %5 = tail call float @llvm.sqrt.f32(float %4) #8
  ret float %5
}

; Function Attrs: alwaysinline nounwind readnone
define float @_Z6lengthf(float %in) #0 {
  ret float %in
}

; Function Attrs: nounwind readnone
define <4 x float> @_Z8shuffle2Dv4_fS_Dv4_j(<4 x float> %x, <4 x float> %y, <4 x i32> %mask) #8 {
entry:
  %and = and <4 x i32> %mask, <i32 7, i32 7, i32 7, i32 7>
  %and.i.i = and <4 x i32> %mask, <i32 3, i32 3, i32 3, i32 3>
  %0 = bitcast <4 x i32> %and.i.i to <16 x i8>
  %1 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %0, <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i = bitcast <16 x i8> %1 to <8 x i16>
  %shl.i.i = shl <8 x i16> %astype1.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i = bitcast <8 x i16> %shl.i.i to <16 x i8>
  %2 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %3 = bitcast <4 x float> %x to <16 x i8>
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %3, <16 x i8> %2) #2
  %astype1.i = bitcast <16 x i8> %4 to <4 x float>
  %5 = bitcast <4 x float> %y to <16 x i8>
  %6 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %5, <16 x i8> %2) #2
  %astype1.i9 = bitcast <16 x i8> %6 to <4 x float>
  %cmp = icmp ult <4 x i32> %and, <i32 4, i32 4, i32 4, i32 4>
  %sext = sext <4 x i1> %cmp to <4 x i32>
  %7 = icmp slt <4 x i32> %sext, zeroinitializer
  %8 = select <4 x i1> %7, <4 x float> %astype1.i, <4 x float> %astype1.i9
  ret <4 x float> %8
}

; Function Attrs: nounwind readnone
define <4 x i32> @_Z8shuffle2Dv4_iS_Dv4_j(<4 x i32> %x, <4 x i32> %y, <4 x i32> %mask) #8 {
entry:
  %and = and <4 x i32> %mask, <i32 7, i32 7, i32 7, i32 7>
  %and.i.i = and <4 x i32> %mask, <i32 3, i32 3, i32 3, i32 3>
  %0 = bitcast <4 x i32> %and.i.i to <16 x i8>
  %1 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %0, <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i = bitcast <16 x i8> %1 to <8 x i16>
  %shl.i.i = shl <8 x i16> %astype1.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i = bitcast <8 x i16> %shl.i.i to <16 x i8>
  %2 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %3 = bitcast <4 x i32> %x to <16 x i8>
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %3, <16 x i8> %2) #2
  %astype7.i.i = bitcast <16 x i8> %4 to <4 x i32>
  %5 = bitcast <4 x i32> %y to <16 x i8>
  %6 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %5, <16 x i8> %2) #2
  %astype7.i.i9 = bitcast <16 x i8> %6 to <4 x i32>
  %cmp = icmp ult <4 x i32> %and, <i32 4, i32 4, i32 4, i32 4>
  %sext = sext <4 x i1> %cmp to <4 x i32>
  %7 = icmp slt <4 x i32> %sext, zeroinitializer
  %8 = select <4 x i1> %7, <4 x i32> %astype7.i.i, <4 x i32> %astype7.i.i9
  ret <4 x i32> %8
}

; Function Attrs: nounwind readnone
define <16 x i8> @_Z8shuffle2Dv16_cS_Dv16_h(<16 x i8> %x, <16 x i8> %y, <16 x i8> %mask) #8 {
entry:
  %and = and <16 x i8> %mask, <i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31, i8 31>
  %and.i.i = and <16 x i8> %mask, <i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15, i8 15>
  %0 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %x, <16 x i8> %and.i.i) #2
  %1 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %y, <16 x i8> %and.i.i) #2
  %cmp = icmp ult <16 x i8> %and, <i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16, i8 16>
  %sext = sext <16 x i1> %cmp to <16 x i8>
  %2 = icmp slt <16 x i8> %sext, zeroinitializer
  %3 = select <16 x i1> %2, <16 x i8> %0, <16 x i8> %1
  ret <16 x i8> %3
}

; Function Attrs: nounwind readnone
define <8 x i16> @_Z8shuffle2Dv8_sS_Dv8_t(<8 x i16> %x, <8 x i16> %y, <8 x i16> %mask) #8 {
entry:
  %and = and <8 x i16> %mask, <i16 15, i16 15, i16 15, i16 15, i16 15, i16 15, i16 15, i16 15>
  %and.i.i = and <8 x i16> %mask, <i16 7, i16 7, i16 7, i16 7, i16 7, i16 7, i16 7, i16 7>
  %0 = bitcast <8 x i16> %and.i.i to <16 x i8>
  %1 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %0, <16 x i8> <i8 0, i8 0, i8 2, i8 2, i8 4, i8 4, i8 6, i8 6, i8 8, i8 8, i8 10, i8 10, i8 12, i8 12, i8 14, i8 14>) #2
  %astype.i.i = bitcast <16 x i8> %1 to <8 x i16>
  %shl.i.i = shl <8 x i16> %astype.i.i, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %astype1.i.i = bitcast <8 x i16> %shl.i.i to <16 x i8>
  %2 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype1.i.i, <16 x i8> <i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1>) #2
  %3 = bitcast <8 x i16> %x to <16 x i8>
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %3, <16 x i8> %2) #2
  %astype5.i.i = bitcast <16 x i8> %4 to <8 x i16>
  %5 = bitcast <8 x i16> %y to <16 x i8>
  %6 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %5, <16 x i8> %2) #2
  %astype5.i.i9 = bitcast <16 x i8> %6 to <8 x i16>
  %cmp = icmp ult <8 x i16> %and, <i16 8, i16 8, i16 8, i16 8, i16 8, i16 8, i16 8, i16 8>
  %sext = sext <8 x i1> %cmp to <8 x i16>
  %7 = icmp slt <8 x i16> %sext, zeroinitializer
  %8 = select <8 x i1> %7, <8 x i16> %astype5.i.i, <8 x i16> %astype5.i.i9
  ret <8 x i16> %8
}

; Function Attrs: nounwind
define void @_Z8vstore16Dv16_cjPc(<16 x i8> %data, i32 %offset, i8* nocapture %p) #2 {
entry:
  %mul = shl i32 %offset, 4
  %add.ptr = getelementptr i8, i8* %p, i32 %mul
  %data.addr.0.add.ptr.cast = bitcast i8* %add.ptr to <16 x i8>*
  store <16 x i8> %data, <16 x i8>* %data.addr.0.add.ptr.cast, align 1
  ret void
}

; Function Attrs: nounwind readonly
define <16 x i8> @_Z7vload16jPKc(i32 %offset, i8* nocapture %p) #11 {
entry:
  %mul = shl i32 %offset, 4
  %add.ptr = getelementptr i8, i8* %p, i32 %mul
  %res.0.add.ptr.cast = bitcast i8* %add.ptr to <16 x i8>*
  %res.0.copyload = load <16 x i8>, <16 x i8>* %res.0.add.ptr.cast, align 1
  ret <16 x i8> %res.0.copyload
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_load_transpose_char4x4(<4 x i8>* %pLoadAdd, <4 x i8>* nocapture %xOut, <4 x i8>* nocapture %yOut, <4 x i8>* nocapture %zOut, <4 x i8>* nocapture %wOut) #1 {
entry:
  %0 = getelementptr inbounds <4 x i8>, <4 x i8>* %pLoadAdd, i32 0, i32 0
  %res.0.add.ptr.cast.i = bitcast i8* %0 to <16 x i8>*
  %res.0.copyload.i = load <16 x i8>, <16 x i8>* %res.0.add.ptr.cast.i, align 1
  %1 = shufflevector <16 x i8> %res.0.copyload.i, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %1, <4 x i8>* %xOut, align 4, !tbaa !19
  %2 = bitcast <16 x i8> %res.0.copyload.i to <2 x i64>
  %3 = tail call <2 x i64> @llvm.x86.sse2.psrl.dq(<2 x i64> %2, i32 8) #2
  %astype.i = bitcast <2 x i64> %3 to <16 x i8>
  %4 = shufflevector <16 x i8> %astype.i, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %4, <4 x i8>* %yOut, align 4, !tbaa !19
  %5 = tail call <2 x i64> @llvm.x86.sse2.psrl.dq(<2 x i64> %3, i32 8) #2
  %astype2.i = bitcast <2 x i64> %5 to <16 x i8>
  %6 = shufflevector <16 x i8> %astype2.i, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %6, <4 x i8>* %zOut, align 4, !tbaa !19
  %7 = tail call <2 x i64> @llvm.x86.sse2.psrl.dq(<2 x i64> %5, i32 8) #2
  %astype4.i = bitcast <2 x i64> %7 to <16 x i8>
  %8 = shufflevector <16 x i8> %astype4.i, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %8, <4 x i8>* %wOut, align 4, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_store_char4x4(<4 x i8>* %pStoreAdd, <4 x i8> %xIn, <4 x i8> %yIn, <4 x i8> %zIn, <4 x i8> %wIn) #1 {
entry:
  %0 = shufflevector <4 x i8> %xIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = shufflevector <4 x i8> %yIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %2 = shufflevector <4 x i8> %zIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %3 = shufflevector <4 x i8> %wIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %0, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %1, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %6 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %4, <16 x i8> %5
  %astype.i = bitcast <16 x i8> %6 to <8 x i16>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %8 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %3, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %9 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %7, <16 x i8> %8
  %astype2.i = bitcast <16 x i8> %9 to <8 x i16>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<8 x i16> <i16 0, i16 0, i16 1, i16 1, i16 2, i16 2, i16 3, i16 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 2, i8 2, i8 4, i8 4, i8 6, i8 6, i8 8, i8 8, i8 10, i8 10, i8 12, i8 12, i8 14, i8 14>) #2
  %astype.i.i.i = bitcast <16 x i8> %10 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype.i.i.i, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %astype1.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %11 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype1.i.i.i, <16 x i8> <i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1>) #2
  %12 = bitcast <8 x i16> %astype.i to <16 x i8>
  %13 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %12, <16 x i8> %11) #2
  %astype5.i.i.i = bitcast <16 x i8> %13 to <8 x i16>
  %14 = bitcast <8 x i16> %astype2.i to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %14, <16 x i8> %11) #2
  %astype5.i.i9.i = bitcast <16 x i8> %15 to <8 x i16>
  %16 = select <8 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <8 x i16> %astype5.i.i.i, <8 x i16> %astype5.i.i9.i
  %astype4.i = bitcast <8 x i16> %16 to <16 x i8>
  %17 = getelementptr inbounds <4 x i8>, <4 x i8>* %pStoreAdd, i32 0, i32 0
  %data.addr.0.add.ptr.cast.i = bitcast i8* %17 to <16 x i8>*
  store <16 x i8> %astype4.i, <16 x i8>* %data.addr.0.add.ptr.cast.i, align 1
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_scatter_char4x4(<4 x i8>* nocapture %pStoreAdd0, <4 x i8>* nocapture %pStoreAdd1, <4 x i8>* nocapture %pStoreAdd2, <4 x i8>* nocapture %pStoreAdd3, <4 x i8> %xIn, <4 x i8> %yIn, <4 x i8> %zIn, <4 x i8> %wIn) #1 {
entry:
  %0 = shufflevector <4 x i8> %xIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = shufflevector <4 x i8> %yIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %2 = shufflevector <4 x i8> %zIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %3 = shufflevector <4 x i8> %wIn, <4 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %0, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %1, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %6 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %4, <16 x i8> %5
  %astype.i = bitcast <16 x i8> %6 to <8 x i16>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %8 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %3, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %9 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %7, <16 x i8> %8
  %astype2.i = bitcast <16 x i8> %9 to <8 x i16>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<8 x i16> <i16 0, i16 0, i16 1, i16 1, i16 2, i16 2, i16 3, i16 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 2, i8 2, i8 4, i8 4, i8 6, i8 6, i8 8, i8 8, i8 10, i8 10, i8 12, i8 12, i8 14, i8 14>) #2
  %astype.i.i.i = bitcast <16 x i8> %10 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype.i.i.i, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %astype1.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %11 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype1.i.i.i, <16 x i8> <i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1>) #2
  %12 = bitcast <8 x i16> %astype.i to <16 x i8>
  %13 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %12, <16 x i8> %11) #2
  %astype5.i.i.i = bitcast <16 x i8> %13 to <8 x i16>
  %14 = bitcast <8 x i16> %astype2.i to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %14, <16 x i8> %11) #2
  %astype5.i.i9.i = bitcast <16 x i8> %15 to <8 x i16>
  %16 = select <8 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <8 x i16> %astype5.i.i.i, <8 x i16> %astype5.i.i9.i
  %17 = bitcast <8 x i16> %16 to <4 x i32>
  %18 = extractelement <4 x i32> %17, i32 0
  %19 = bitcast <4 x i8>* %pStoreAdd0 to i32*
  store i32 %18, i32* %19, align 4, !tbaa !21
  %20 = extractelement <4 x i32> %17, i32 1
  %21 = bitcast <4 x i8>* %pStoreAdd1 to i32*
  store i32 %20, i32* %21, align 4, !tbaa !21
  %22 = extractelement <4 x i32> %17, i32 2
  %23 = bitcast <4 x i8>* %pStoreAdd2 to i32*
  store i32 %22, i32* %23, align 4, !tbaa !21
  %24 = extractelement <4 x i32> %17, i32 3
  %25 = bitcast <4 x i8>* %pStoreAdd3 to i32*
  store i32 %24, i32* %25, align 4, !tbaa !21
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_load_transpose_char4x8(<4 x i8>* %pLoadAdd, <8 x i8>* nocapture %xOut, <8 x i8>* nocapture %yOut, <8 x i8>* nocapture %zOut, <8 x i8>* nocapture %wOut) #1 {
entry:
  %0 = getelementptr inbounds <4 x i8>, <4 x i8>* %pLoadAdd, i32 0, i32 0
  %res.0.add.ptr.cast.i = bitcast i8* %0 to <16 x i8>*
  %res.0.copyload.i = load <16 x i8>, <16 x i8>* %res.0.add.ptr.cast.i, align 1
  %add.ptr.i = getelementptr i8, i8* %0, i32 16
  %res.0.add.ptr.cast.i6 = bitcast i8* %add.ptr.i to <16 x i8>*
  %res.0.copyload.i7 = load <16 x i8>, <16 x i8>* %res.0.add.ptr.cast.i6, align 1
  %1 = shufflevector <16 x i8> %res.0.copyload.i, <16 x i8> undef, <16 x i32> <i32 0, i32 4, i32 8, i32 12, i32 1, i32 5, i32 9, i32 13, i32 2, i32 6, i32 10, i32 14, i32 3, i32 7, i32 11, i32 15>
  %2 = shufflevector <16 x i8> %res.0.copyload.i7, <16 x i8> undef, <16 x i32> <i32 0, i32 4, i32 8, i32 12, i32 1, i32 5, i32 9, i32 13, i32 2, i32 6, i32 10, i32 14, i32 3, i32 7, i32 11, i32 15>
  %astype.i.i = bitcast <16 x i8> %1 to <4 x i32>
  %astype1.i.i = bitcast <16 x i8> %2 to <4 x i32>
  %3 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %3 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %4 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %5 = bitcast <4 x i32> %astype.i.i to <16 x i8>
  %6 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %5, <16 x i8> %4) #2
  %astype7.i.i.i4 = bitcast <16 x i8> %6 to <4 x i32>
  %7 = bitcast <4 x i32> %astype1.i.i to <16 x i8>
  %8 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %7, <16 x i8> %4) #2
  %astype7.i.i9.i5 = bitcast <16 x i8> %8 to <4 x i32>
  %9 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i4, <4 x i32> %astype7.i.i9.i5
  %astype2.i.i = bitcast <4 x i32> %9 to <16 x i8>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %10 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %11 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %12 = bitcast <4 x i32> %astype.i.i to <16 x i8>
  %13 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %12, <16 x i8> %11) #2
  %astype7.i.i.i = bitcast <16 x i8> %13 to <4 x i32>
  %14 = bitcast <4 x i32> %astype1.i.i to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %14, <16 x i8> %11) #2
  %astype7.i.i9.i = bitcast <16 x i8> %15 to <4 x i32>
  %16 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i, <4 x i32> %astype7.i.i9.i
  %astype6.i.i = bitcast <4 x i32> %16 to <16 x i8>
  %17 = shufflevector <16 x i8> %astype2.i.i, <16 x i8> undef, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i8> %17, <8 x i8>* %xOut, align 8, !tbaa !19
  %18 = shufflevector <16 x i8> %astype2.i.i, <16 x i8> undef, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  store <8 x i8> %18, <8 x i8>* %yOut, align 8, !tbaa !19
  %19 = shufflevector <16 x i8> %astype6.i.i, <16 x i8> undef, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i8> %19, <8 x i8>* %zOut, align 8, !tbaa !19
  %20 = shufflevector <16 x i8> %astype6.i.i, <16 x i8> undef, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  store <8 x i8> %20, <8 x i8>* %wOut, align 8, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_store_char4x8(<4 x i8>* %pStoreAdd, <8 x i8> %xIn, <8 x i8> %yIn, <8 x i8> %zIn, <8 x i8> %wIn) #1 {
entry:
  %0 = shufflevector <8 x i8> %xIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = shufflevector <8 x i8> %yIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %2 = shufflevector <8 x i8> %zIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %3 = shufflevector <8 x i8> %wIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %0, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %1, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %6 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %4, <16 x i8> %5
  %astype.i.i = bitcast <16 x i8> %6 to <8 x i16>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %8 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %3, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %9 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %7, <16 x i8> %8
  %astype2.i.i = bitcast <16 x i8> %9 to <8 x i16>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<8 x i16> <i16 0, i16 0, i16 1, i16 1, i16 2, i16 2, i16 3, i16 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 2, i8 2, i8 4, i8 4, i8 6, i8 6, i8 8, i8 8, i8 10, i8 10, i8 12, i8 12, i8 14, i8 14>) #2
  %astype.i.i.i2 = bitcast <16 x i8> %10 to <8 x i16>
  %shl.i.i.i3 = shl <8 x i16> %astype.i.i.i2, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %astype1.i.i.i4 = bitcast <8 x i16> %shl.i.i.i3 to <16 x i8>
  %11 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype1.i.i.i4, <16 x i8> <i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1>) #2
  %12 = bitcast <8 x i16> %astype.i.i to <16 x i8>
  %13 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %12, <16 x i8> %11) #2
  %astype5.i.i.i5 = bitcast <16 x i8> %13 to <8 x i16>
  %14 = bitcast <8 x i16> %astype2.i.i to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %14, <16 x i8> %11) #2
  %astype5.i.i9.i6 = bitcast <16 x i8> %15 to <8 x i16>
  %16 = select <8 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <8 x i16> %astype5.i.i.i5, <8 x i16> %astype5.i.i9.i6
  %astype4.i.i = bitcast <8 x i16> %16 to <16 x i8>
  %17 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<8 x i16> <i16 4, i16 4, i16 5, i16 5, i16 6, i16 6, i16 7, i16 7> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 2, i8 2, i8 4, i8 4, i8 6, i8 6, i8 8, i8 8, i8 10, i8 10, i8 12, i8 12, i8 14, i8 14>) #2
  %astype.i.i.i = bitcast <16 x i8> %17 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype.i.i.i, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %astype1.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %18 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype1.i.i.i, <16 x i8> <i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1>) #2
  %19 = bitcast <8 x i16> %astype.i.i to <16 x i8>
  %20 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %19, <16 x i8> %18) #2
  %astype5.i.i.i = bitcast <16 x i8> %20 to <8 x i16>
  %21 = bitcast <8 x i16> %astype2.i.i to <16 x i8>
  %22 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %21, <16 x i8> %18) #2
  %astype5.i.i9.i = bitcast <16 x i8> %22 to <8 x i16>
  %23 = select <8 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <8 x i16> %astype5.i.i.i, <8 x i16> %astype5.i.i9.i
  %astype6.i.i = bitcast <8 x i16> %23 to <16 x i8>
  %24 = getelementptr inbounds <4 x i8>, <4 x i8>* %pStoreAdd, i32 0, i32 0
  %data.addr.0.add.ptr.cast.i1 = bitcast i8* %24 to <16 x i8>*
  store <16 x i8> %astype4.i.i, <16 x i8>* %data.addr.0.add.ptr.cast.i1, align 1
  %add.ptr.i = getelementptr i8, i8* %24, i32 16
  %data.addr.0.add.ptr.cast.i = bitcast i8* %add.ptr.i to <16 x i8>*
  store <16 x i8> %astype6.i.i, <16 x i8>* %data.addr.0.add.ptr.cast.i, align 1
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_scatter_char4x8(<4 x i8>* nocapture %pStoreAdd0, <4 x i8>* nocapture %pStoreAdd1, <4 x i8>* nocapture %pStoreAdd2, <4 x i8>* nocapture %pStoreAdd3, <4 x i8>* nocapture %pStoreAdd4, <4 x i8>* nocapture %pStoreAdd5, <4 x i8>* nocapture %pStoreAdd6, <4 x i8>* nocapture %pStoreAdd7, <8 x i8> %xIn, <8 x i8> %yIn, <8 x i8> %zIn, <8 x i8> %wIn) #1 {
entry:
  %0 = shufflevector <8 x i8> %xIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %1 = shufflevector <8 x i8> %yIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %2 = shufflevector <8 x i8> %zIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %3 = shufflevector <8 x i8> %wIn, <8 x i8> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %0, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %1, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %6 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %4, <16 x i8> %5
  %astype.i.i = bitcast <16 x i8> %6 to <8 x i16>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %8 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %3, <16 x i8> <i8 0, i8 0, i8 1, i8 1, i8 2, i8 2, i8 3, i8 3, i8 4, i8 4, i8 5, i8 5, i8 6, i8 6, i8 7, i8 7>) #2
  %9 = select <16 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <16 x i8> %7, <16 x i8> %8
  %astype2.i.i = bitcast <16 x i8> %9 to <8 x i16>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<8 x i16> <i16 0, i16 0, i16 1, i16 1, i16 2, i16 2, i16 3, i16 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 2, i8 2, i8 4, i8 4, i8 6, i8 6, i8 8, i8 8, i8 10, i8 10, i8 12, i8 12, i8 14, i8 14>) #2
  %astype.i.i.i1 = bitcast <16 x i8> %10 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype.i.i.i1, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %astype1.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %11 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype1.i.i.i3, <16 x i8> <i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1>) #2
  %12 = bitcast <8 x i16> %astype.i.i to <16 x i8>
  %13 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %12, <16 x i8> %11) #2
  %astype5.i.i.i4 = bitcast <16 x i8> %13 to <8 x i16>
  %14 = bitcast <8 x i16> %astype2.i.i to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %14, <16 x i8> %11) #2
  %astype5.i.i9.i5 = bitcast <16 x i8> %15 to <8 x i16>
  %16 = select <8 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <8 x i16> %astype5.i.i.i4, <8 x i16> %astype5.i.i9.i5
  %17 = bitcast <8 x i16> %16 to <4 x i32>
  %18 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<8 x i16> <i16 4, i16 4, i16 5, i16 5, i16 6, i16 6, i16 7, i16 7> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 2, i8 2, i8 4, i8 4, i8 6, i8 6, i8 8, i8 8, i8 10, i8 10, i8 12, i8 12, i8 14, i8 14>) #2
  %astype.i.i.i = bitcast <16 x i8> %18 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype.i.i.i, <i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1, i16 1>
  %astype1.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype1.i.i.i, <16 x i8> <i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1, i8 0, i8 1>) #2
  %20 = bitcast <8 x i16> %astype.i.i to <16 x i8>
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %20, <16 x i8> %19) #2
  %astype5.i.i.i = bitcast <16 x i8> %21 to <8 x i16>
  %22 = bitcast <8 x i16> %astype2.i.i to <16 x i8>
  %23 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %22, <16 x i8> %19) #2
  %astype5.i.i9.i = bitcast <16 x i8> %23 to <8 x i16>
  %24 = select <8 x i1> <i1 true, i1 false, i1 true, i1 false, i1 true, i1 false, i1 true, i1 false>, <8 x i16> %astype5.i.i.i, <8 x i16> %astype5.i.i9.i
  %25 = bitcast <8 x i16> %24 to <4 x i32>
  %26 = extractelement <4 x i32> %17, i32 0
  %27 = bitcast <4 x i8>* %pStoreAdd0 to i32*
  store i32 %26, i32* %27, align 4, !tbaa !21
  %28 = extractelement <4 x i32> %17, i32 1
  %29 = bitcast <4 x i8>* %pStoreAdd1 to i32*
  store i32 %28, i32* %29, align 4, !tbaa !21
  %30 = extractelement <4 x i32> %17, i32 2
  %31 = bitcast <4 x i8>* %pStoreAdd2 to i32*
  store i32 %30, i32* %31, align 4, !tbaa !21
  %32 = extractelement <4 x i32> %17, i32 3
  %33 = bitcast <4 x i8>* %pStoreAdd3 to i32*
  store i32 %32, i32* %33, align 4, !tbaa !21
  %34 = extractelement <4 x i32> %25, i32 0
  %35 = bitcast <4 x i8>* %pStoreAdd4 to i32*
  store i32 %34, i32* %35, align 4, !tbaa !21
  %36 = extractelement <4 x i32> %25, i32 1
  %37 = bitcast <4 x i8>* %pStoreAdd5 to i32*
  store i32 %36, i32* %37, align 4, !tbaa !21
  %38 = extractelement <4 x i32> %25, i32 2
  %39 = bitcast <4 x i8>* %pStoreAdd6 to i32*
  store i32 %38, i32* %39, align 4, !tbaa !21
  %40 = extractelement <4 x i32> %25, i32 3
  %41 = bitcast <4 x i8>* %pStoreAdd7 to i32*
  store i32 %40, i32* %41, align 4, !tbaa !21
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_load_transpose_int4x4(<4 x i32>* nocapture %pLoadAdd, <4 x i32>* nocapture %xOut, <4 x i32>* nocapture %yOut, <4 x i32>* nocapture %zOut, <4 x i32>* nocapture %wOut) #1 {
entry:
  %0 = load <4 x i32>, <4 x i32>* %pLoadAdd, align 16, !tbaa !19
  %arrayidx1.i = getelementptr <4 x i32>, <4 x i32>* %pLoadAdd, i32 1
  %1 = load <4 x i32>, <4 x i32>* %arrayidx1.i, align 16, !tbaa !19
  %arrayidx2.i = getelementptr <4 x i32>, <4 x i32>* %pLoadAdd, i32 2
  %2 = load <4 x i32>, <4 x i32>* %arrayidx2.i, align 16, !tbaa !19
  %arrayidx3.i = getelementptr <4 x i32>, <4 x i32>* %pLoadAdd, i32 3
  %3 = load <4 x i32>, <4 x i32>* %arrayidx3.i, align 16, !tbaa !19
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %4 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %6 = bitcast <4 x i32> %0 to <16 x i8>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %6, <16 x i8> %5) #2
  %astype7.i.i.i = bitcast <16 x i8> %7 to <4 x i32>
  %8 = bitcast <4 x i32> %2 to <16 x i8>
  %9 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %8, <16 x i8> %5) #2
  %astype7.i.i9.i = bitcast <16 x i8> %9 to <4 x i32>
  %10 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i, <4 x i32> %astype7.i.i9.i
  %11 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %11 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %13 = bitcast <4 x i32> %0 to <16 x i8>
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %13, <16 x i8> %12) #2
  %astype7.i.i.i34 = bitcast <16 x i8> %14 to <4 x i32>
  %15 = bitcast <4 x i32> %2 to <16 x i8>
  %16 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %15, <16 x i8> %12) #2
  %astype7.i.i9.i35 = bitcast <16 x i8> %16 to <4 x i32>
  %17 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i34, <4 x i32> %astype7.i.i9.i35
  %18 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %18 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %20 = bitcast <4 x i32> %1 to <16 x i8>
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %20, <16 x i8> %19) #2
  %astype7.i.i.i29 = bitcast <16 x i8> %21 to <4 x i32>
  %22 = bitcast <4 x i32> %3 to <16 x i8>
  %23 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %22, <16 x i8> %19) #2
  %astype7.i.i9.i30 = bitcast <16 x i8> %23 to <4 x i32>
  %24 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i29, <4 x i32> %astype7.i.i9.i30
  %25 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %25 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %27 = bitcast <4 x i32> %1 to <16 x i8>
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %27, <16 x i8> %26) #2
  %astype7.i.i.i24 = bitcast <16 x i8> %28 to <4 x i32>
  %29 = bitcast <4 x i32> %3 to <16 x i8>
  %30 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %29, <16 x i8> %26) #2
  %astype7.i.i9.i25 = bitcast <16 x i8> %30 to <4 x i32>
  %31 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i24, <4 x i32> %astype7.i.i9.i25
  %32 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %32 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %34 = bitcast <4 x i32> %10 to <16 x i8>
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %34, <16 x i8> %33) #2
  %astype7.i.i.i19 = bitcast <16 x i8> %35 to <4 x i32>
  %36 = bitcast <4 x i32> %24 to <16 x i8>
  %37 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %36, <16 x i8> %33) #2
  %astype7.i.i9.i20 = bitcast <16 x i8> %37 to <4 x i32>
  %38 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i19, <4 x i32> %astype7.i.i9.i20
  store <4 x i32> %38, <4 x i32>* %xOut, align 16, !tbaa !19
  %39 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %39 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %41 = bitcast <4 x i32> %10 to <16 x i8>
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %41, <16 x i8> %40) #2
  %astype7.i.i.i14 = bitcast <16 x i8> %42 to <4 x i32>
  %43 = bitcast <4 x i32> %24 to <16 x i8>
  %44 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %43, <16 x i8> %40) #2
  %astype7.i.i9.i15 = bitcast <16 x i8> %44 to <4 x i32>
  %45 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i14, <4 x i32> %astype7.i.i9.i15
  store <4 x i32> %45, <4 x i32>* %yOut, align 16, !tbaa !19
  %46 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %46 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %48 = bitcast <4 x i32> %17 to <16 x i8>
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %48, <16 x i8> %47) #2
  %astype7.i.i.i9 = bitcast <16 x i8> %49 to <4 x i32>
  %50 = bitcast <4 x i32> %31 to <16 x i8>
  %51 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %50, <16 x i8> %47) #2
  %astype7.i.i9.i10 = bitcast <16 x i8> %51 to <4 x i32>
  %52 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i9, <4 x i32> %astype7.i.i9.i10
  store <4 x i32> %52, <4 x i32>* %zOut, align 16, !tbaa !19
  %53 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %53 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %55 = bitcast <4 x i32> %17 to <16 x i8>
  %56 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %55, <16 x i8> %54) #2
  %astype7.i.i.i4 = bitcast <16 x i8> %56 to <4 x i32>
  %57 = bitcast <4 x i32> %31 to <16 x i8>
  %58 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %57, <16 x i8> %54) #2
  %astype7.i.i9.i5 = bitcast <16 x i8> %58 to <4 x i32>
  %59 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i4, <4 x i32> %astype7.i.i9.i5
  store <4 x i32> %59, <4 x i32>* %wOut, align 16, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_store_int4x4(<4 x i32>* nocapture %pStoreAdd, <4 x i32> %xIn, <4 x i32> %yIn, <4 x i32> %zIn, <4 x i32> %wIn) #1 {
entry:
  %arrayidx1.i = getelementptr <4 x i32>, <4 x i32>* %pStoreAdd, i32 1
  %arrayidx2.i = getelementptr <4 x i32>, <4 x i32>* %pStoreAdd, i32 2
  %arrayidx3.i = getelementptr <4 x i32>, <4 x i32>* %pStoreAdd, i32 3
  %0 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %0 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %1 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %2 = bitcast <4 x i32> %xIn to <16 x i8>
  %3 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> %1) #2
  %astype7.i.i.i = bitcast <16 x i8> %3 to <4 x i32>
  %4 = bitcast <4 x i32> %zIn to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %4, <16 x i8> %1) #2
  %astype7.i.i9.i = bitcast <16 x i8> %5 to <4 x i32>
  %6 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i, <4 x i32> %astype7.i.i9.i
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %7 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %8 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %9 = bitcast <4 x i32> %xIn to <16 x i8>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %9, <16 x i8> %8) #2
  %astype7.i.i.i34 = bitcast <16 x i8> %10 to <4 x i32>
  %11 = bitcast <4 x i32> %zIn to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %11, <16 x i8> %8) #2
  %astype7.i.i9.i35 = bitcast <16 x i8> %12 to <4 x i32>
  %13 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i34, <4 x i32> %astype7.i.i9.i35
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %14 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %16 = bitcast <4 x i32> %yIn to <16 x i8>
  %17 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %16, <16 x i8> %15) #2
  %astype7.i.i.i29 = bitcast <16 x i8> %17 to <4 x i32>
  %18 = bitcast <4 x i32> %wIn to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %18, <16 x i8> %15) #2
  %astype7.i.i9.i30 = bitcast <16 x i8> %19 to <4 x i32>
  %20 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i29, <4 x i32> %astype7.i.i9.i30
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %21 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %22 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %23 = bitcast <4 x i32> %yIn to <16 x i8>
  %24 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %23, <16 x i8> %22) #2
  %astype7.i.i.i24 = bitcast <16 x i8> %24 to <4 x i32>
  %25 = bitcast <4 x i32> %wIn to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %25, <16 x i8> %22) #2
  %astype7.i.i9.i25 = bitcast <16 x i8> %26 to <4 x i32>
  %27 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i24, <4 x i32> %astype7.i.i9.i25
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %28 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %29 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %30 = bitcast <4 x i32> %6 to <16 x i8>
  %31 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %30, <16 x i8> %29) #2
  %astype7.i.i.i19 = bitcast <16 x i8> %31 to <4 x i32>
  %32 = bitcast <4 x i32> %20 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %32, <16 x i8> %29) #2
  %astype7.i.i9.i20 = bitcast <16 x i8> %33 to <4 x i32>
  %34 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i19, <4 x i32> %astype7.i.i9.i20
  store <4 x i32> %34, <4 x i32>* %pStoreAdd, align 16, !tbaa !19
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %35 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %36 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %37 = bitcast <4 x i32> %6 to <16 x i8>
  %38 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %37, <16 x i8> %36) #2
  %astype7.i.i.i14 = bitcast <16 x i8> %38 to <4 x i32>
  %39 = bitcast <4 x i32> %20 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %39, <16 x i8> %36) #2
  %astype7.i.i9.i15 = bitcast <16 x i8> %40 to <4 x i32>
  %41 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i14, <4 x i32> %astype7.i.i9.i15
  store <4 x i32> %41, <4 x i32>* %arrayidx1.i, align 16, !tbaa !19
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %42 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %43 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %44 = bitcast <4 x i32> %13 to <16 x i8>
  %45 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %44, <16 x i8> %43) #2
  %astype7.i.i.i9 = bitcast <16 x i8> %45 to <4 x i32>
  %46 = bitcast <4 x i32> %27 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %46, <16 x i8> %43) #2
  %astype7.i.i9.i10 = bitcast <16 x i8> %47 to <4 x i32>
  %48 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i9, <4 x i32> %astype7.i.i9.i10
  store <4 x i32> %48, <4 x i32>* %arrayidx2.i, align 16, !tbaa !19
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %49 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %50 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %51 = bitcast <4 x i32> %13 to <16 x i8>
  %52 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %51, <16 x i8> %50) #2
  %astype7.i.i.i4 = bitcast <16 x i8> %52 to <4 x i32>
  %53 = bitcast <4 x i32> %27 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %53, <16 x i8> %50) #2
  %astype7.i.i9.i5 = bitcast <16 x i8> %54 to <4 x i32>
  %55 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i4, <4 x i32> %astype7.i.i9.i5
  store <4 x i32> %55, <4 x i32>* %arrayidx3.i, align 16, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_gather_transpose_int4x4(<4 x i32>* nocapture %pLoadAdd0, <4 x i32>* nocapture %pLoadAdd1, <4 x i32>* nocapture %pLoadAdd2, <4 x i32>* nocapture %pLoadAdd3, <4 x i32>* nocapture %xOut, <4 x i32>* nocapture %yOut, <4 x i32>* nocapture %zOut, <4 x i32>* nocapture %wOut) #1 {
entry:
  %0 = load <4 x i32>, <4 x i32>* %pLoadAdd0, align 16, !tbaa !19
  %1 = load <4 x i32>, <4 x i32>* %pLoadAdd1, align 16, !tbaa !19
  %2 = load <4 x i32>, <4 x i32>* %pLoadAdd2, align 16, !tbaa !19
  %3 = load <4 x i32>, <4 x i32>* %pLoadAdd3, align 16, !tbaa !19
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %4 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %6 = bitcast <4 x i32> %0 to <16 x i8>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %6, <16 x i8> %5) #2
  %astype7.i.i.i = bitcast <16 x i8> %7 to <4 x i32>
  %8 = bitcast <4 x i32> %2 to <16 x i8>
  %9 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %8, <16 x i8> %5) #2
  %astype7.i.i9.i = bitcast <16 x i8> %9 to <4 x i32>
  %10 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i, <4 x i32> %astype7.i.i9.i
  %11 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %11 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %13 = bitcast <4 x i32> %0 to <16 x i8>
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %13, <16 x i8> %12) #2
  %astype7.i.i.i34 = bitcast <16 x i8> %14 to <4 x i32>
  %15 = bitcast <4 x i32> %2 to <16 x i8>
  %16 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %15, <16 x i8> %12) #2
  %astype7.i.i9.i35 = bitcast <16 x i8> %16 to <4 x i32>
  %17 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i34, <4 x i32> %astype7.i.i9.i35
  %18 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %18 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %20 = bitcast <4 x i32> %1 to <16 x i8>
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %20, <16 x i8> %19) #2
  %astype7.i.i.i29 = bitcast <16 x i8> %21 to <4 x i32>
  %22 = bitcast <4 x i32> %3 to <16 x i8>
  %23 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %22, <16 x i8> %19) #2
  %astype7.i.i9.i30 = bitcast <16 x i8> %23 to <4 x i32>
  %24 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i29, <4 x i32> %astype7.i.i9.i30
  %25 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %25 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %27 = bitcast <4 x i32> %1 to <16 x i8>
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %27, <16 x i8> %26) #2
  %astype7.i.i.i24 = bitcast <16 x i8> %28 to <4 x i32>
  %29 = bitcast <4 x i32> %3 to <16 x i8>
  %30 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %29, <16 x i8> %26) #2
  %astype7.i.i9.i25 = bitcast <16 x i8> %30 to <4 x i32>
  %31 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i24, <4 x i32> %astype7.i.i9.i25
  %32 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %32 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %34 = bitcast <4 x i32> %10 to <16 x i8>
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %34, <16 x i8> %33) #2
  %astype7.i.i.i19 = bitcast <16 x i8> %35 to <4 x i32>
  %36 = bitcast <4 x i32> %24 to <16 x i8>
  %37 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %36, <16 x i8> %33) #2
  %astype7.i.i9.i20 = bitcast <16 x i8> %37 to <4 x i32>
  %38 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i19, <4 x i32> %astype7.i.i9.i20
  store <4 x i32> %38, <4 x i32>* %xOut, align 16, !tbaa !19
  %39 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %39 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %41 = bitcast <4 x i32> %10 to <16 x i8>
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %41, <16 x i8> %40) #2
  %astype7.i.i.i14 = bitcast <16 x i8> %42 to <4 x i32>
  %43 = bitcast <4 x i32> %24 to <16 x i8>
  %44 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %43, <16 x i8> %40) #2
  %astype7.i.i9.i15 = bitcast <16 x i8> %44 to <4 x i32>
  %45 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i14, <4 x i32> %astype7.i.i9.i15
  store <4 x i32> %45, <4 x i32>* %yOut, align 16, !tbaa !19
  %46 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %46 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %48 = bitcast <4 x i32> %17 to <16 x i8>
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %48, <16 x i8> %47) #2
  %astype7.i.i.i9 = bitcast <16 x i8> %49 to <4 x i32>
  %50 = bitcast <4 x i32> %31 to <16 x i8>
  %51 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %50, <16 x i8> %47) #2
  %astype7.i.i9.i10 = bitcast <16 x i8> %51 to <4 x i32>
  %52 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i9, <4 x i32> %astype7.i.i9.i10
  store <4 x i32> %52, <4 x i32>* %zOut, align 16, !tbaa !19
  %53 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %53 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %55 = bitcast <4 x i32> %17 to <16 x i8>
  %56 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %55, <16 x i8> %54) #2
  %astype7.i.i.i4 = bitcast <16 x i8> %56 to <4 x i32>
  %57 = bitcast <4 x i32> %31 to <16 x i8>
  %58 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %57, <16 x i8> %54) #2
  %astype7.i.i9.i5 = bitcast <16 x i8> %58 to <4 x i32>
  %59 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i4, <4 x i32> %astype7.i.i9.i5
  store <4 x i32> %59, <4 x i32>* %wOut, align 16, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_scatter_int4x4(<4 x i32>* nocapture %pStoreAdd0, <4 x i32>* nocapture %pStoreAdd1, <4 x i32>* nocapture %pStoreAdd2, <4 x i32>* nocapture %pStoreAdd3, <4 x i32> %xIn, <4 x i32> %yIn, <4 x i32> %zIn, <4 x i32> %wIn) #1 {
entry:
  %0 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %0 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %1 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %2 = bitcast <4 x i32> %xIn to <16 x i8>
  %3 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> %1) #2
  %astype7.i.i.i = bitcast <16 x i8> %3 to <4 x i32>
  %4 = bitcast <4 x i32> %zIn to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %4, <16 x i8> %1) #2
  %astype7.i.i9.i = bitcast <16 x i8> %5 to <4 x i32>
  %6 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i, <4 x i32> %astype7.i.i9.i
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %7 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %8 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %9 = bitcast <4 x i32> %xIn to <16 x i8>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %9, <16 x i8> %8) #2
  %astype7.i.i.i34 = bitcast <16 x i8> %10 to <4 x i32>
  %11 = bitcast <4 x i32> %zIn to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %11, <16 x i8> %8) #2
  %astype7.i.i9.i35 = bitcast <16 x i8> %12 to <4 x i32>
  %13 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i34, <4 x i32> %astype7.i.i9.i35
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %14 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %16 = bitcast <4 x i32> %yIn to <16 x i8>
  %17 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %16, <16 x i8> %15) #2
  %astype7.i.i.i29 = bitcast <16 x i8> %17 to <4 x i32>
  %18 = bitcast <4 x i32> %wIn to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %18, <16 x i8> %15) #2
  %astype7.i.i9.i30 = bitcast <16 x i8> %19 to <4 x i32>
  %20 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i29, <4 x i32> %astype7.i.i9.i30
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %21 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %22 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %23 = bitcast <4 x i32> %yIn to <16 x i8>
  %24 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %23, <16 x i8> %22) #2
  %astype7.i.i.i24 = bitcast <16 x i8> %24 to <4 x i32>
  %25 = bitcast <4 x i32> %wIn to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %25, <16 x i8> %22) #2
  %astype7.i.i9.i25 = bitcast <16 x i8> %26 to <4 x i32>
  %27 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i24, <4 x i32> %astype7.i.i9.i25
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %28 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %29 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %30 = bitcast <4 x i32> %6 to <16 x i8>
  %31 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %30, <16 x i8> %29) #2
  %astype7.i.i.i19 = bitcast <16 x i8> %31 to <4 x i32>
  %32 = bitcast <4 x i32> %20 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %32, <16 x i8> %29) #2
  %astype7.i.i9.i20 = bitcast <16 x i8> %33 to <4 x i32>
  %34 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i19, <4 x i32> %astype7.i.i9.i20
  store <4 x i32> %34, <4 x i32>* %pStoreAdd0, align 16, !tbaa !19
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %35 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %36 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %37 = bitcast <4 x i32> %6 to <16 x i8>
  %38 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %37, <16 x i8> %36) #2
  %astype7.i.i.i14 = bitcast <16 x i8> %38 to <4 x i32>
  %39 = bitcast <4 x i32> %20 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %39, <16 x i8> %36) #2
  %astype7.i.i9.i15 = bitcast <16 x i8> %40 to <4 x i32>
  %41 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i14, <4 x i32> %astype7.i.i9.i15
  store <4 x i32> %41, <4 x i32>* %pStoreAdd1, align 16, !tbaa !19
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %42 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %43 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %44 = bitcast <4 x i32> %13 to <16 x i8>
  %45 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %44, <16 x i8> %43) #2
  %astype7.i.i.i9 = bitcast <16 x i8> %45 to <4 x i32>
  %46 = bitcast <4 x i32> %27 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %46, <16 x i8> %43) #2
  %astype7.i.i9.i10 = bitcast <16 x i8> %47 to <4 x i32>
  %48 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i9, <4 x i32> %astype7.i.i9.i10
  store <4 x i32> %48, <4 x i32>* %pStoreAdd2, align 16, !tbaa !19
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %49 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %50 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %51 = bitcast <4 x i32> %13 to <16 x i8>
  %52 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %51, <16 x i8> %50) #2
  %astype7.i.i.i4 = bitcast <16 x i8> %52 to <4 x i32>
  %53 = bitcast <4 x i32> %27 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %53, <16 x i8> %50) #2
  %astype7.i.i9.i5 = bitcast <16 x i8> %54 to <4 x i32>
  %55 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i4, <4 x i32> %astype7.i.i9.i5
  store <4 x i32> %55, <4 x i32>* %pStoreAdd3, align 16, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_load_transpose_float4x4(<4 x float>* nocapture %pLoadAdd, <4 x float>* nocapture %xOut, <4 x float>* nocapture %yOut, <4 x float>* nocapture %zOut, <4 x float>* nocapture %wOut) #1 {
entry:
  %0 = load <4 x float>, <4 x float>* %pLoadAdd, align 16, !tbaa !19
  %arrayidx1.i = getelementptr <4 x float>, <4 x float>* %pLoadAdd, i32 1
  %1 = load <4 x float>, <4 x float>* %arrayidx1.i, align 16, !tbaa !19
  %arrayidx2.i = getelementptr <4 x float>, <4 x float>* %pLoadAdd, i32 2
  %2 = load <4 x float>, <4 x float>* %arrayidx2.i, align 16, !tbaa !19
  %arrayidx3.i = getelementptr <4 x float>, <4 x float>* %pLoadAdd, i32 3
  %3 = load <4 x float>, <4 x float>* %arrayidx3.i, align 16, !tbaa !19
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %4 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %6 = bitcast <4 x float> %0 to <16 x i8>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %6, <16 x i8> %5) #2
  %astype1.i.i = bitcast <16 x i8> %7 to <4 x float>
  %8 = bitcast <4 x float> %2 to <16 x i8>
  %9 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %8, <16 x i8> %5) #2
  %astype1.i9.i = bitcast <16 x i8> %9 to <4 x float>
  %10 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i, <4 x float> %astype1.i9.i
  %11 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %11 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %13 = bitcast <4 x float> %0 to <16 x i8>
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %13, <16 x i8> %12) #2
  %astype1.i.i34 = bitcast <16 x i8> %14 to <4 x float>
  %15 = bitcast <4 x float> %2 to <16 x i8>
  %16 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %15, <16 x i8> %12) #2
  %astype1.i9.i35 = bitcast <16 x i8> %16 to <4 x float>
  %17 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i34, <4 x float> %astype1.i9.i35
  %18 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %18 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %20 = bitcast <4 x float> %1 to <16 x i8>
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %20, <16 x i8> %19) #2
  %astype1.i.i29 = bitcast <16 x i8> %21 to <4 x float>
  %22 = bitcast <4 x float> %3 to <16 x i8>
  %23 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %22, <16 x i8> %19) #2
  %astype1.i9.i30 = bitcast <16 x i8> %23 to <4 x float>
  %24 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i29, <4 x float> %astype1.i9.i30
  %25 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %25 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %27 = bitcast <4 x float> %1 to <16 x i8>
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %27, <16 x i8> %26) #2
  %astype1.i.i24 = bitcast <16 x i8> %28 to <4 x float>
  %29 = bitcast <4 x float> %3 to <16 x i8>
  %30 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %29, <16 x i8> %26) #2
  %astype1.i9.i25 = bitcast <16 x i8> %30 to <4 x float>
  %31 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i24, <4 x float> %astype1.i9.i25
  %32 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %32 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %34 = bitcast <4 x float> %10 to <16 x i8>
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %34, <16 x i8> %33) #2
  %astype1.i.i19 = bitcast <16 x i8> %35 to <4 x float>
  %36 = bitcast <4 x float> %24 to <16 x i8>
  %37 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %36, <16 x i8> %33) #2
  %astype1.i9.i20 = bitcast <16 x i8> %37 to <4 x float>
  %38 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i19, <4 x float> %astype1.i9.i20
  store <4 x float> %38, <4 x float>* %xOut, align 16, !tbaa !19
  %39 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %39 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %41 = bitcast <4 x float> %10 to <16 x i8>
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %41, <16 x i8> %40) #2
  %astype1.i.i14 = bitcast <16 x i8> %42 to <4 x float>
  %43 = bitcast <4 x float> %24 to <16 x i8>
  %44 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %43, <16 x i8> %40) #2
  %astype1.i9.i15 = bitcast <16 x i8> %44 to <4 x float>
  %45 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i14, <4 x float> %astype1.i9.i15
  store <4 x float> %45, <4 x float>* %yOut, align 16, !tbaa !19
  %46 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %46 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %48 = bitcast <4 x float> %17 to <16 x i8>
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %48, <16 x i8> %47) #2
  %astype1.i.i9 = bitcast <16 x i8> %49 to <4 x float>
  %50 = bitcast <4 x float> %31 to <16 x i8>
  %51 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %50, <16 x i8> %47) #2
  %astype1.i9.i10 = bitcast <16 x i8> %51 to <4 x float>
  %52 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i9, <4 x float> %astype1.i9.i10
  store <4 x float> %52, <4 x float>* %zOut, align 16, !tbaa !19
  %53 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %53 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %55 = bitcast <4 x float> %17 to <16 x i8>
  %56 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %55, <16 x i8> %54) #2
  %astype1.i.i4 = bitcast <16 x i8> %56 to <4 x float>
  %57 = bitcast <4 x float> %31 to <16 x i8>
  %58 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %57, <16 x i8> %54) #2
  %astype1.i9.i5 = bitcast <16 x i8> %58 to <4 x float>
  %59 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i4, <4 x float> %astype1.i9.i5
  store <4 x float> %59, <4 x float>* %wOut, align 16, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_store_float4x4(<4 x float>* nocapture %pStoreAdd, <4 x float> %xIn, <4 x float> %yIn, <4 x float> %zIn, <4 x float> %wIn) #1 {
entry:
  %arrayidx1.i = getelementptr <4 x float>, <4 x float>* %pStoreAdd, i32 1
  %arrayidx2.i = getelementptr <4 x float>, <4 x float>* %pStoreAdd, i32 2
  %arrayidx3.i = getelementptr <4 x float>, <4 x float>* %pStoreAdd, i32 3
  %0 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %0 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %1 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %2 = bitcast <4 x float> %xIn to <16 x i8>
  %3 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> %1) #2
  %astype1.i.i = bitcast <16 x i8> %3 to <4 x float>
  %4 = bitcast <4 x float> %zIn to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %4, <16 x i8> %1) #2
  %astype1.i9.i = bitcast <16 x i8> %5 to <4 x float>
  %6 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i, <4 x float> %astype1.i9.i
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %7 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %8 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %9 = bitcast <4 x float> %xIn to <16 x i8>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %9, <16 x i8> %8) #2
  %astype1.i.i34 = bitcast <16 x i8> %10 to <4 x float>
  %11 = bitcast <4 x float> %zIn to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %11, <16 x i8> %8) #2
  %astype1.i9.i35 = bitcast <16 x i8> %12 to <4 x float>
  %13 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i34, <4 x float> %astype1.i9.i35
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %14 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %16 = bitcast <4 x float> %yIn to <16 x i8>
  %17 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %16, <16 x i8> %15) #2
  %astype1.i.i29 = bitcast <16 x i8> %17 to <4 x float>
  %18 = bitcast <4 x float> %wIn to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %18, <16 x i8> %15) #2
  %astype1.i9.i30 = bitcast <16 x i8> %19 to <4 x float>
  %20 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i29, <4 x float> %astype1.i9.i30
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %21 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %22 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %23 = bitcast <4 x float> %yIn to <16 x i8>
  %24 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %23, <16 x i8> %22) #2
  %astype1.i.i24 = bitcast <16 x i8> %24 to <4 x float>
  %25 = bitcast <4 x float> %wIn to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %25, <16 x i8> %22) #2
  %astype1.i9.i25 = bitcast <16 x i8> %26 to <4 x float>
  %27 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i24, <4 x float> %astype1.i9.i25
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %28 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %29 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %30 = bitcast <4 x float> %6 to <16 x i8>
  %31 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %30, <16 x i8> %29) #2
  %astype1.i.i19 = bitcast <16 x i8> %31 to <4 x float>
  %32 = bitcast <4 x float> %20 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %32, <16 x i8> %29) #2
  %astype1.i9.i20 = bitcast <16 x i8> %33 to <4 x float>
  %34 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i19, <4 x float> %astype1.i9.i20
  store <4 x float> %34, <4 x float>* %pStoreAdd, align 16, !tbaa !19
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %35 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %36 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %37 = bitcast <4 x float> %6 to <16 x i8>
  %38 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %37, <16 x i8> %36) #2
  %astype1.i.i14 = bitcast <16 x i8> %38 to <4 x float>
  %39 = bitcast <4 x float> %20 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %39, <16 x i8> %36) #2
  %astype1.i9.i15 = bitcast <16 x i8> %40 to <4 x float>
  %41 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i14, <4 x float> %astype1.i9.i15
  store <4 x float> %41, <4 x float>* %arrayidx1.i, align 16, !tbaa !19
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %42 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %43 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %44 = bitcast <4 x float> %13 to <16 x i8>
  %45 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %44, <16 x i8> %43) #2
  %astype1.i.i9 = bitcast <16 x i8> %45 to <4 x float>
  %46 = bitcast <4 x float> %27 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %46, <16 x i8> %43) #2
  %astype1.i9.i10 = bitcast <16 x i8> %47 to <4 x float>
  %48 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i9, <4 x float> %astype1.i9.i10
  store <4 x float> %48, <4 x float>* %arrayidx2.i, align 16, !tbaa !19
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %49 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %50 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %51 = bitcast <4 x float> %13 to <16 x i8>
  %52 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %51, <16 x i8> %50) #2
  %astype1.i.i4 = bitcast <16 x i8> %52 to <4 x float>
  %53 = bitcast <4 x float> %27 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %53, <16 x i8> %50) #2
  %astype1.i9.i5 = bitcast <16 x i8> %54 to <4 x float>
  %55 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i4, <4 x float> %astype1.i9.i5
  store <4 x float> %55, <4 x float>* %arrayidx3.i, align 16, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_gather_transpose_float4x4(<4 x float>* nocapture %pLoadAdd0, <4 x float>* nocapture %pLoadAdd1, <4 x float>* nocapture %pLoadAdd2, <4 x float>* nocapture %pLoadAdd3, <4 x float>* nocapture %xOut, <4 x float>* nocapture %yOut, <4 x float>* nocapture %zOut, <4 x float>* nocapture %wOut) #1 {
entry:
  %0 = load <4 x float>, <4 x float>* %pLoadAdd0, align 16, !tbaa !19
  %1 = load <4 x float>, <4 x float>* %pLoadAdd1, align 16, !tbaa !19
  %2 = load <4 x float>, <4 x float>* %pLoadAdd2, align 16, !tbaa !19
  %3 = load <4 x float>, <4 x float>* %pLoadAdd3, align 16, !tbaa !19
  %4 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %4 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %6 = bitcast <4 x float> %0 to <16 x i8>
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %6, <16 x i8> %5) #2
  %astype1.i.i = bitcast <16 x i8> %7 to <4 x float>
  %8 = bitcast <4 x float> %2 to <16 x i8>
  %9 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %8, <16 x i8> %5) #2
  %astype1.i9.i = bitcast <16 x i8> %9 to <4 x float>
  %10 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i, <4 x float> %astype1.i9.i
  %11 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %11 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %13 = bitcast <4 x float> %0 to <16 x i8>
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %13, <16 x i8> %12) #2
  %astype1.i.i34 = bitcast <16 x i8> %14 to <4 x float>
  %15 = bitcast <4 x float> %2 to <16 x i8>
  %16 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %15, <16 x i8> %12) #2
  %astype1.i9.i35 = bitcast <16 x i8> %16 to <4 x float>
  %17 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i34, <4 x float> %astype1.i9.i35
  %18 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %18 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %20 = bitcast <4 x float> %1 to <16 x i8>
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %20, <16 x i8> %19) #2
  %astype1.i.i29 = bitcast <16 x i8> %21 to <4 x float>
  %22 = bitcast <4 x float> %3 to <16 x i8>
  %23 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %22, <16 x i8> %19) #2
  %astype1.i9.i30 = bitcast <16 x i8> %23 to <4 x float>
  %24 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i29, <4 x float> %astype1.i9.i30
  %25 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %25 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %27 = bitcast <4 x float> %1 to <16 x i8>
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %27, <16 x i8> %26) #2
  %astype1.i.i24 = bitcast <16 x i8> %28 to <4 x float>
  %29 = bitcast <4 x float> %3 to <16 x i8>
  %30 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %29, <16 x i8> %26) #2
  %astype1.i9.i25 = bitcast <16 x i8> %30 to <4 x float>
  %31 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i24, <4 x float> %astype1.i9.i25
  %32 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %32 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %34 = bitcast <4 x float> %10 to <16 x i8>
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %34, <16 x i8> %33) #2
  %astype1.i.i19 = bitcast <16 x i8> %35 to <4 x float>
  %36 = bitcast <4 x float> %24 to <16 x i8>
  %37 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %36, <16 x i8> %33) #2
  %astype1.i9.i20 = bitcast <16 x i8> %37 to <4 x float>
  %38 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i19, <4 x float> %astype1.i9.i20
  store <4 x float> %38, <4 x float>* %xOut, align 16, !tbaa !19
  %39 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %39 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %41 = bitcast <4 x float> %10 to <16 x i8>
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %41, <16 x i8> %40) #2
  %astype1.i.i14 = bitcast <16 x i8> %42 to <4 x float>
  %43 = bitcast <4 x float> %24 to <16 x i8>
  %44 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %43, <16 x i8> %40) #2
  %astype1.i9.i15 = bitcast <16 x i8> %44 to <4 x float>
  %45 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i14, <4 x float> %astype1.i9.i15
  store <4 x float> %45, <4 x float>* %yOut, align 16, !tbaa !19
  %46 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %46 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %48 = bitcast <4 x float> %17 to <16 x i8>
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %48, <16 x i8> %47) #2
  %astype1.i.i9 = bitcast <16 x i8> %49 to <4 x float>
  %50 = bitcast <4 x float> %31 to <16 x i8>
  %51 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %50, <16 x i8> %47) #2
  %astype1.i9.i10 = bitcast <16 x i8> %51 to <4 x float>
  %52 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i9, <4 x float> %astype1.i9.i10
  store <4 x float> %52, <4 x float>* %zOut, align 16, !tbaa !19
  %53 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %53 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %55 = bitcast <4 x float> %17 to <16 x i8>
  %56 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %55, <16 x i8> %54) #2
  %astype1.i.i4 = bitcast <16 x i8> %56 to <4 x float>
  %57 = bitcast <4 x float> %31 to <16 x i8>
  %58 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %57, <16 x i8> %54) #2
  %astype1.i9.i5 = bitcast <16 x i8> %58 to <4 x float>
  %59 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i4, <4 x float> %astype1.i9.i5
  store <4 x float> %59, <4 x float>* %wOut, align 16, !tbaa !19
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_transpose_scatter_float4x4(<4 x float>* nocapture %pStoreAdd0, <4 x float>* nocapture %pStoreAdd1, <4 x float>* nocapture %pStoreAdd2, <4 x float>* nocapture %pStoreAdd3, <4 x float> %xIn, <4 x float> %yIn, <4 x float> %zIn, <4 x float> %wIn) #1 {
entry:
  %0 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %0 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %1 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %2 = bitcast <4 x float> %xIn to <16 x i8>
  %3 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %2, <16 x i8> %1) #2
  %astype1.i.i = bitcast <16 x i8> %3 to <4 x float>
  %4 = bitcast <4 x float> %zIn to <16 x i8>
  %5 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %4, <16 x i8> %1) #2
  %astype1.i9.i = bitcast <16 x i8> %5 to <4 x float>
  %6 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i, <4 x float> %astype1.i9.i
  %7 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i31 = bitcast <16 x i8> %7 to <8 x i16>
  %shl.i.i.i32 = shl <8 x i16> %astype1.i.i.i31, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i33 = bitcast <8 x i16> %shl.i.i.i32 to <16 x i8>
  %8 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i33, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %9 = bitcast <4 x float> %xIn to <16 x i8>
  %10 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %9, <16 x i8> %8) #2
  %astype1.i.i34 = bitcast <16 x i8> %10 to <4 x float>
  %11 = bitcast <4 x float> %zIn to <16 x i8>
  %12 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %11, <16 x i8> %8) #2
  %astype1.i9.i35 = bitcast <16 x i8> %12 to <4 x float>
  %13 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i34, <4 x float> %astype1.i9.i35
  %14 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i26 = bitcast <16 x i8> %14 to <8 x i16>
  %shl.i.i.i27 = shl <8 x i16> %astype1.i.i.i26, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i28 = bitcast <8 x i16> %shl.i.i.i27 to <16 x i8>
  %15 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i28, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %16 = bitcast <4 x float> %yIn to <16 x i8>
  %17 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %16, <16 x i8> %15) #2
  %astype1.i.i29 = bitcast <16 x i8> %17 to <4 x float>
  %18 = bitcast <4 x float> %wIn to <16 x i8>
  %19 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %18, <16 x i8> %15) #2
  %astype1.i9.i30 = bitcast <16 x i8> %19 to <4 x float>
  %20 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i29, <4 x float> %astype1.i9.i30
  %21 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i21 = bitcast <16 x i8> %21 to <8 x i16>
  %shl.i.i.i22 = shl <8 x i16> %astype1.i.i.i21, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i23 = bitcast <8 x i16> %shl.i.i.i22 to <16 x i8>
  %22 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i23, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %23 = bitcast <4 x float> %yIn to <16 x i8>
  %24 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %23, <16 x i8> %22) #2
  %astype1.i.i24 = bitcast <16 x i8> %24 to <4 x float>
  %25 = bitcast <4 x float> %wIn to <16 x i8>
  %26 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %25, <16 x i8> %22) #2
  %astype1.i9.i25 = bitcast <16 x i8> %26 to <4 x float>
  %27 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i24, <4 x float> %astype1.i9.i25
  %28 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i16 = bitcast <16 x i8> %28 to <8 x i16>
  %shl.i.i.i17 = shl <8 x i16> %astype1.i.i.i16, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i18 = bitcast <8 x i16> %shl.i.i.i17 to <16 x i8>
  %29 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i18, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %30 = bitcast <4 x float> %6 to <16 x i8>
  %31 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %30, <16 x i8> %29) #2
  %astype1.i.i19 = bitcast <16 x i8> %31 to <4 x float>
  %32 = bitcast <4 x float> %20 to <16 x i8>
  %33 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %32, <16 x i8> %29) #2
  %astype1.i9.i20 = bitcast <16 x i8> %33 to <4 x float>
  %34 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i19, <4 x float> %astype1.i9.i20
  store <4 x float> %34, <4 x float>* %pStoreAdd0, align 16, !tbaa !19
  %35 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i11 = bitcast <16 x i8> %35 to <8 x i16>
  %shl.i.i.i12 = shl <8 x i16> %astype1.i.i.i11, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i13 = bitcast <8 x i16> %shl.i.i.i12 to <16 x i8>
  %36 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i13, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %37 = bitcast <4 x float> %6 to <16 x i8>
  %38 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %37, <16 x i8> %36) #2
  %astype1.i.i14 = bitcast <16 x i8> %38 to <4 x float>
  %39 = bitcast <4 x float> %20 to <16 x i8>
  %40 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %39, <16 x i8> %36) #2
  %astype1.i9.i15 = bitcast <16 x i8> %40 to <4 x float>
  %41 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i14, <4 x float> %astype1.i9.i15
  store <4 x float> %41, <4 x float>* %pStoreAdd1, align 16, !tbaa !19
  %42 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i6 = bitcast <16 x i8> %42 to <8 x i16>
  %shl.i.i.i7 = shl <8 x i16> %astype1.i.i.i6, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i8 = bitcast <8 x i16> %shl.i.i.i7 to <16 x i8>
  %43 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i8, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %44 = bitcast <4 x float> %13 to <16 x i8>
  %45 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %44, <16 x i8> %43) #2
  %astype1.i.i9 = bitcast <16 x i8> %45 to <4 x float>
  %46 = bitcast <4 x float> %27 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %46, <16 x i8> %43) #2
  %astype1.i9.i10 = bitcast <16 x i8> %47 to <4 x float>
  %48 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i9, <4 x float> %astype1.i9.i10
  store <4 x float> %48, <4 x float>* %pStoreAdd2, align 16, !tbaa !19
  %49 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %49 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %50 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %51 = bitcast <4 x float> %13 to <16 x i8>
  %52 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %51, <16 x i8> %50) #2
  %astype1.i.i4 = bitcast <16 x i8> %52 to <4 x float>
  %53 = bitcast <4 x float> %27 to <16 x i8>
  %54 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %53, <16 x i8> %50) #2
  %astype1.i9.i5 = bitcast <16 x i8> %54 to <4 x float>
  %55 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x float> %astype1.i.i4, <4 x float> %astype1.i9.i5
  store <4 x float> %55, <4 x float>* %pStoreAdd3, align 16, !tbaa !19
  ret void
}

define i1 @__ocl_allOne(i1 %pred) {
entry:
  ret i1 %pred
}

define i1 @__ocl_allOne_v2(<2 x i1> %pred) {
entry:
  %elem0 = extractelement <2 x i1> %pred, i32 0
  %elem1 = extractelement <2 x i1> %pred, i32 1
  %res = and i1 %elem0, %elem1
  ret i1 %res
}

define i1 @__ocl_allOne_v4(<4 x i1> %pred) {
entry:
  %elem0 = extractelement <4 x i1> %pred, i32 0
  %elem1 = extractelement <4 x i1> %pred, i32 1
  %elem2 = extractelement <4 x i1> %pred, i32 2
  %elem3 = extractelement <4 x i1> %pred, i32 3
  %res1 = and i1 %elem0, %elem1
  %res2 = and i1 %elem2, %elem3
  %res = and i1 %res1, %res2
  ret i1 %res
}

define i1 @__ocl_allOne_v8(<8 x i1> %pred) {
entry:
  %elem0 = extractelement <8 x i1> %pred, i32 0
  %elem1 = extractelement <8 x i1> %pred, i32 1
  %elem2 = extractelement <8 x i1> %pred, i32 2
  %elem3 = extractelement <8 x i1> %pred, i32 3
  %elem4 = extractelement <8 x i1> %pred, i32 4
  %elem5 = extractelement <8 x i1> %pred, i32 5
  %elem6 = extractelement <8 x i1> %pred, i32 6
  %elem7 = extractelement <8 x i1> %pred, i32 7
  %res1 = and i1 %elem0, %elem1
  %res2 = and i1 %elem2, %elem3
  %res3 = and i1 %elem4, %elem5
  %res4 = and i1 %elem6, %elem7
  %res5 = and i1 %res1, %res2
  %res6 = and i1 %res3, %res4
  %res = and i1 %res5, %res6
  ret i1 %res
}

define i1 @__ocl_allOne_v16(<16 x i1> %pred) {
entry:
  %elem0 = extractelement <16 x i1> %pred, i32 0
  %elem1 = extractelement <16 x i1> %pred, i32 1
  %elem2 = extractelement <16 x i1> %pred, i32 2
  %elem3 = extractelement <16 x i1> %pred, i32 3
  %elem4 = extractelement <16 x i1> %pred, i32 4
  %elem5 = extractelement <16 x i1> %pred, i32 5
  %elem6 = extractelement <16 x i1> %pred, i32 6
  %elem7 = extractelement <16 x i1> %pred, i32 7
  %elem8 = extractelement <16 x i1> %pred, i32 8
  %elem9 = extractelement <16 x i1> %pred, i32 9
  %elem10 = extractelement <16 x i1> %pred, i32 10
  %elem11 = extractelement <16 x i1> %pred, i32 11
  %elem12 = extractelement <16 x i1> %pred, i32 12
  %elem13 = extractelement <16 x i1> %pred, i32 13
  %elem14 = extractelement <16 x i1> %pred, i32 14
  %elem15 = extractelement <16 x i1> %pred, i32 15
  %res1 = and i1 %elem0, %elem1
  %res2 = and i1 %elem2, %elem3
  %res3 = and i1 %elem4, %elem5
  %res4 = and i1 %elem6, %elem7
  %res5 = and i1 %elem8, %elem9
  %res6 = and i1 %elem10, %elem11
  %res7 = and i1 %elem12, %elem13
  %res8 = and i1 %elem14, %elem15
  %res9 = and i1 %res1, %res2
  %res10 = and i1 %res3, %res4
  %res11 = and i1 %res5, %res6
  %res12 = and i1 %res7, %res8
  %res13 = and i1 %res9, %res10
  %res14 = and i1 %res11, %res12
  %res = and i1 %res13, %res14
  ret i1 %res
}

define i1 @__ocl_allZero(i1 %t) {
entry:
  %pred = xor i1 %t, true
  ret i1 %pred
}

define i1 @__ocl_allZero_v2(<2 x i1> %t) {
entry:
  %pred = xor <2 x i1> %t, <i1 true, i1 true>
  %elem0 = extractelement <2 x i1> %pred, i32 0
  %elem1 = extractelement <2 x i1> %pred, i32 1
  %res = and i1 %elem0, %elem1
  ret i1 %res
}

define i1 @__ocl_allZero_v4(<4 x i1> %t) {
entry:
  %pred = xor <4 x i1> %t, <i1 true, i1 true, i1 true, i1 true>
  %elem0 = extractelement <4 x i1> %pred, i32 0
  %elem1 = extractelement <4 x i1> %pred, i32 1
  %elem2 = extractelement <4 x i1> %pred, i32 2
  %elem3 = extractelement <4 x i1> %pred, i32 3
  %res1 = and i1 %elem0, %elem1
  %res2 = and i1 %elem2, %elem3
  %res = and i1 %res1, %res2
  ret i1 %res
}

define i1 @__ocl_allZero_v8(<8 x i1> %t) {
entry:
  %pred = xor <8 x i1> %t, <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>
  %elem0 = extractelement <8 x i1> %pred, i32 0
  %elem1 = extractelement <8 x i1> %pred, i32 1
  %elem2 = extractelement <8 x i1> %pred, i32 2
  %elem3 = extractelement <8 x i1> %pred, i32 3
  %elem4 = extractelement <8 x i1> %pred, i32 4
  %elem5 = extractelement <8 x i1> %pred, i32 5
  %elem6 = extractelement <8 x i1> %pred, i32 6
  %elem7 = extractelement <8 x i1> %pred, i32 7
  %res1 = and i1 %elem0, %elem1
  %res2 = and i1 %elem2, %elem3
  %res3 = and i1 %elem4, %elem5
  %res4 = and i1 %elem6, %elem7
  %res5 = and i1 %res1, %res2
  %res6 = and i1 %res3, %res4
  %res = and i1 %res5, %res6
  ret i1 %res
}

define i1 @__ocl_allZero_v16(<16 x i1> %t) {
entry:
  %pred = xor <16 x i1> %t, <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>
  %elem0 = extractelement <16 x i1> %pred, i32 0
  %elem1 = extractelement <16 x i1> %pred, i32 1
  %elem2 = extractelement <16 x i1> %pred, i32 2
  %elem3 = extractelement <16 x i1> %pred, i32 3
  %elem4 = extractelement <16 x i1> %pred, i32 4
  %elem5 = extractelement <16 x i1> %pred, i32 5
  %elem6 = extractelement <16 x i1> %pred, i32 6
  %elem7 = extractelement <16 x i1> %pred, i32 7
  %elem8 = extractelement <16 x i1> %pred, i32 8
  %elem9 = extractelement <16 x i1> %pred, i32 9
  %elem10 = extractelement <16 x i1> %pred, i32 10
  %elem11 = extractelement <16 x i1> %pred, i32 11
  %elem12 = extractelement <16 x i1> %pred, i32 12
  %elem13 = extractelement <16 x i1> %pred, i32 13
  %elem14 = extractelement <16 x i1> %pred, i32 14
  %elem15 = extractelement <16 x i1> %pred, i32 15
  %res1 = and i1 %elem0, %elem1
  %res2 = and i1 %elem2, %elem3
  %res3 = and i1 %elem4, %elem5
  %res4 = and i1 %elem6, %elem7
  %res5 = and i1 %elem8, %elem9
  %res6 = and i1 %elem10, %elem11
  %res7 = and i1 %elem12, %elem13
  %res8 = and i1 %elem14, %elem15
  %res9 = and i1 %res1, %res2
  %res10 = and i1 %res3, %res4
  %res11 = and i1 %res5, %res6
  %res12 = and i1 %res7, %res8
  %res13 = and i1 %res9, %res10
  %res14 = and i1 %res11, %res12
  %res = and i1 %res13, %res14
  ret i1 %res
}

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.psrl.dq(<2 x i64>, i32) #8

; Function Attrs: nounwind
declare void @llvm.x86.sse.sfence() #2

; Function Attrs: nounwind
declare void @llvm.x86.sse.storeu.ps(i8*, <4 x float>) #2

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse2.psrli.d(<4 x i32>, i32) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.cmp.ps(<4 x float>, <4 x float>, i8) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse2.cmp.pd(<2 x double>, <2 x double>, i8) #8

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.psrli.q(<2 x i64>, i32) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse2.pslli.d(<4 x i32>, i32) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.psubus.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.psubs.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.psubus.b(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.psubs.b(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse2.sqrt.pd(<2 x double>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind
declare void @llvm.x86.sse2.lfence() #2

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.sqrt.ps(<4 x float>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.rsqrt.ps(<4 x float>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.rsqrt.ss(<4 x float>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse.rcp.ps(<4 x float>) #8

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse2.pmulu.dq(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.pmulhu.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.pmulh.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse2.min.pd(<2 x double>, <2 x double>) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse41.pminud(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse41.pminsd(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse41.pminuw(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.pmins.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.pminu.b(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse41.pminsb(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse2.max.pd(<2 x double>, <2 x double>) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse41.pmaxud(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse41.pmaxsd(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse41.pmaxuw(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.pmaxs.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.pmaxu.b(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse41.pmaxsb(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <2 x i64> @llvm.x86.sse41.pmuldq(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse41.blendvpd(<2 x double>, <2 x double>, <2 x double>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse41.blendvps(<4 x float>, <4 x float>, <4 x float>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse41.pblendvb(<16 x i8>, <16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare i32 @llvm.x86.sse2.movmsk.pd(<2 x double>) #8

; Function Attrs: nounwind readnone
declare i32 @llvm.x86.sse.movmsk.ps(<4 x float>) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse3.hadd.pd(<2 x double>, <2 x double>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.packuswb.128(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse41.packusdw(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.packsswb.128(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse2.cvttpd2dq(<2 x double>) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.sse2.cvttps2dq(<4 x float>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.packssdw.128(<4 x i32>, <4 x i32>) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse2.cvtps2pd(<4 x float>) #8

; Function Attrs: nounwind readnone
declare <2 x double> @llvm.x86.sse2.cvtdq2pd(<4 x i32>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse2.cvtpd2ps(<2 x double>) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse2.cvtdq2ps(<4 x i32>) #8

; Function Attrs: nounwind
declare void @llvm.x86.sse2.mfence() #2

; Function Attrs: nounwind readnone
declare i32 @llvm.x86.sse2.pmovmskb.128(<16 x i8>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.paddus.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.sse2.padds.w(<8 x i16>, <8 x i16>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.sse2.padds.b(<16 x i8>, <16 x i8>) #8

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.x86.ssse3.pabs.d.128(<4 x i32>) #8

; Function Attrs: nounwind readnone
declare <8 x i16> @llvm.x86.ssse3.pabs.w.128(<8 x i16>) #8

; Function Attrs: nounwind readnone
declare <16 x i8> @llvm.x86.ssse3.pabs.b.128(<16 x i8>) #8

; Function Attrs: nounwind readnone
declare { i8, i1 } @llvm.uadd.with.overflow.i8(i8, i8) #8

; Function Attrs: nounwind readnone
declare { i16, i1 } @llvm.uadd.with.overflow.i16(i16, i16) #8

; Function Attrs: nounwind readnone
declare { i32, i1 } @llvm.uadd.with.overflow.i32(i32, i32) #8

; Function Attrs: nounwind readnone
declare { i64, i1 } @llvm.uadd.with.overflow.i64(i64, i64) #8

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.x86.sse41.blendps(<4 x float>, <4 x float>, i32) #8

; Function Attrs: alwaysinline nounwind
define void @__ocl_gather_transpose_char4x8(<4 x i8>* nocapture %pLoadAdd0, <4 x i8>* nocapture %pLoadAdd1, <4 x i8>* nocapture %pLoadAdd2, <4 x i8>* nocapture %pLoadAdd3, <4 x i8>* nocapture %pLoadAdd4, <4 x i8>* nocapture %pLoadAdd5, <4 x i8>* nocapture %pLoadAdd6, <4 x i8>* nocapture %pLoadAdd7, <8 x i8>* nocapture %xOut, <8 x i8>* nocapture %yOut, <8 x i8>* nocapture %zOut, <8 x i8>* nocapture %wOut) #1 {
entry:
  %0 = load <4 x i8>, <4 x i8>* %pLoadAdd1, align 4
  %1 = bitcast <4 x i8> %0 to i32
  %2 = insertelement <4 x i32> undef, i32 %1, i32 0
  %splat.i = shufflevector <4 x i32> %2, <4 x i32> undef, <4 x i32> zeroinitializer
  %3 = load <4 x i8>, <4 x i8>* %pLoadAdd2, align 4
  %4 = bitcast <4 x i8> %3 to i32
  %5 = insertelement <4 x i32> undef, i32 %4, i32 0
  %splat1.i = shufflevector <4 x i32> %5, <4 x i32> undef, <4 x i32> zeroinitializer
  %6 = load <4 x i8>, <4 x i8>* %pLoadAdd3, align 4
  %7 = bitcast <4 x i8> %6 to i32
  %8 = insertelement <4 x i32> undef, i32 %7, i32 0
  %splat2.i = shufflevector <4 x i32> %8, <4 x i32> undef, <4 x i32> zeroinitializer
  %9 = load <4 x i8>, <4 x i8>* %pLoadAdd5, align 4
  %10 = bitcast <4 x i8> %9 to i32
  %11 = insertelement <4 x i32> undef, i32 %10, i32 0
  %splat3.i = shufflevector <4 x i32> %11, <4 x i32> undef, <4 x i32> zeroinitializer
  %12 = load <4 x i8>, <4 x i8>* %pLoadAdd6, align 4
  %13 = bitcast <4 x i8> %12 to i32
  %14 = insertelement <4 x i32> undef, i32 %13, i32 0
  %splat4.i = shufflevector <4 x i32> %14, <4 x i32> undef, <4 x i32> zeroinitializer
  %15 = load <4 x i8>, <4 x i8>* %pLoadAdd7, align 4
  %16 = bitcast <4 x i8> %15 to i32
  %17 = insertelement <4 x i32> undef, i32 %16, i32 0
  %splat5.i = shufflevector <4 x i32> %17, <4 x i32> undef, <4 x i32> zeroinitializer
  %18 = load <4 x i8>, <4 x i8>* %pLoadAdd0, align 4
  %19 = bitcast <4 x i8> %18 to i32
  %20 = insertelement <4 x i32> undef, i32 %19, i32 0
  %21 = bitcast <4 x i32> %20 to <4 x float>
  %22 = bitcast <4 x i32> %splat.i to <4 x float>
  %23 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %21, <4 x float> %22, i32 2) #2
  %24 = bitcast <4 x i32> %splat1.i to <4 x float>
  %25 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %23, <4 x float> %24, i32 4) #2
  %26 = bitcast <4 x i32> %splat2.i to <4 x float>
  %27 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %25, <4 x float> %26, i32 8) #2
  %28 = load <4 x i8>, <4 x i8>* %pLoadAdd4, align 4
  %29 = bitcast <4 x i8> %28 to i32
  %30 = insertelement <4 x i32> undef, i32 %29, i32 0
  %31 = bitcast <4 x i32> %30 to <4 x float>
  %32 = bitcast <4 x i32> %splat3.i to <4 x float>
  %33 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %31, <4 x float> %32, i32 2) #2
  %34 = bitcast <4 x i32> %splat4.i to <4 x float>
  %35 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %33, <4 x float> %34, i32 4) #2
  %36 = bitcast <4 x i32> %splat5.i to <4 x float>
  %37 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %35, <4 x float> %36, i32 8) #2
  %astype21.i = bitcast <4 x float> %27 to <16 x i8>
  %astype22.i = bitcast <4 x float> %37 to <16 x i8>
  %38 = shufflevector <16 x i8> %astype21.i, <16 x i8> undef, <16 x i32> <i32 0, i32 4, i32 8, i32 12, i32 1, i32 5, i32 9, i32 13, i32 2, i32 6, i32 10, i32 14, i32 3, i32 7, i32 11, i32 15>
  %39 = shufflevector <16 x i8> %astype22.i, <16 x i8> undef, <16 x i32> <i32 0, i32 4, i32 8, i32 12, i32 1, i32 5, i32 9, i32 13, i32 2, i32 6, i32 10, i32 14, i32 3, i32 7, i32 11, i32 15>
  %astype.i.i = bitcast <16 x i8> %38 to <4 x i32>
  %astype1.i.i = bitcast <16 x i8> %39 to <4 x i32>
  %40 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 0, i32 0, i32 1, i32 1> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i = bitcast <16 x i8> %40 to <8 x i16>
  %shl.i.i.i = shl <8 x i16> %astype1.i.i.i, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i = bitcast <8 x i16> %shl.i.i.i to <16 x i8>
  %41 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %42 = bitcast <4 x i32> %astype.i.i to <16 x i8>
  %43 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %42, <16 x i8> %41) #2
  %astype7.i.i.i = bitcast <16 x i8> %43 to <4 x i32>
  %44 = bitcast <4 x i32> %astype1.i.i to <16 x i8>
  %45 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %44, <16 x i8> %41) #2
  %astype7.i.i9.i = bitcast <16 x i8> %45 to <4 x i32>
  %46 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i, <4 x i32> %astype7.i.i9.i
  %astype2.i.i = bitcast <4 x i32> %46 to <16 x i8>
  %47 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> bitcast (<4 x i32> <i32 2, i32 2, i32 3, i32 3> to <16 x i8>), <16 x i8> <i8 0, i8 0, i8 0, i8 0, i8 4, i8 4, i8 4, i8 4, i8 8, i8 8, i8 8, i8 8, i8 12, i8 12, i8 12, i8 12>) #2
  %astype1.i.i.i1 = bitcast <16 x i8> %47 to <8 x i16>
  %shl.i.i.i2 = shl <8 x i16> %astype1.i.i.i1, <i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2, i16 2>
  %astype3.i.i.i3 = bitcast <8 x i16> %shl.i.i.i2 to <16 x i8>
  %48 = tail call <16 x i8> @llvm.x86.sse2.paddus.b(<16 x i8> %astype3.i.i.i3, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3, i8 0, i8 1, i8 2, i8 3>) #2
  %49 = bitcast <4 x i32> %astype.i.i to <16 x i8>
  %50 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %49, <16 x i8> %48) #2
  %astype7.i.i.i4 = bitcast <16 x i8> %50 to <4 x i32>
  %51 = bitcast <4 x i32> %astype1.i.i to <16 x i8>
  %52 = tail call <16 x i8> @llvm.x86.ssse3.pshuf.b.128(<16 x i8> %51, <16 x i8> %48) #2
  %astype7.i.i9.i5 = bitcast <16 x i8> %52 to <4 x i32>
  %53 = select <4 x i1> <i1 true, i1 false, i1 true, i1 false>, <4 x i32> %astype7.i.i.i4, <4 x i32> %astype7.i.i9.i5
  %astype6.i.i = bitcast <4 x i32> %53 to <16 x i8>
  %54 = shufflevector <16 x i8> %astype2.i.i, <16 x i8> undef, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i8> %54, <8 x i8>* %xOut, align 8
  %55 = shufflevector <16 x i8> %astype2.i.i, <16 x i8> undef, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  store <8 x i8> %55, <8 x i8>* %yOut, align 8
  %56 = shufflevector <16 x i8> %astype6.i.i, <16 x i8> undef, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i8> %56, <8 x i8>* %zOut, align 8
  %57 = shufflevector <16 x i8> %astype6.i.i, <16 x i8> undef, <8 x i32> <i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15>
  store <8 x i8> %57, <8 x i8>* %wOut, align 8
  ret void
}

; Function Attrs: alwaysinline nounwind
define void @__ocl_gather_transpose_char4x4(<4 x i8>* nocapture %pLoadAdd0, <4 x i8>* nocapture %pLoadAdd1, <4 x i8>* nocapture %pLoadAdd2, <4 x i8>* nocapture %pLoadAdd3, <4 x i8>* nocapture %xOut, <4 x i8>* nocapture %yOut, <4 x i8>* nocapture %zOut, <4 x i8>* nocapture %wOut) #1 {
entry:
  %0 = load <4 x i8>, <4 x i8>* %pLoadAdd1, align 4
  %1 = bitcast <4 x i8> %0 to i32
  %2 = insertelement <4 x i32> undef, i32 %1, i32 0
  %splat = shufflevector <4 x i32> %2, <4 x i32> undef, <4 x i32> zeroinitializer
  %3 = load <4 x i8>, <4 x i8>* %pLoadAdd2, align 4
  %4 = bitcast <4 x i8> %3 to i32
  %5 = insertelement <4 x i32> undef, i32 %4, i32 0
  %splat1 = shufflevector <4 x i32> %5, <4 x i32> undef, <4 x i32> zeroinitializer
  %6 = load <4 x i8>, <4 x i8>* %pLoadAdd3, align 4
  %7 = bitcast <4 x i8> %6 to i32
  %8 = insertelement <4 x i32> undef, i32 %7, i32 0
  %splat2 = shufflevector <4 x i32> %8, <4 x i32> undef, <4 x i32> zeroinitializer
  %9 = load <4 x i8>, <4 x i8>* %pLoadAdd0, align 4
  %10 = bitcast <4 x i8> %9 to i32
  %11 = insertelement <4 x i32> undef, i32 %10, i32 0
  %12 = bitcast <4 x i32> %11 to <4 x float>
  %13 = bitcast <4 x i32> %splat to <4 x float>
  %14 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %12, <4 x float> %13, i32 2)
  %15 = bitcast <4 x i32> %splat1 to <4 x float>
  %16 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %14, <4 x float> %15, i32 4)
  %17 = bitcast <4 x i32> %splat2 to <4 x float>
  %18 = tail call <4 x float> @llvm.x86.sse41.blendps(<4 x float> %16, <4 x float> %17, i32 8)
  %astype9 = bitcast <4 x float> %18 to <16 x i8>
  %19 = shufflevector <16 x i8> %astype9, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %19, <4 x i8>* %xOut, align 4
  %20 = bitcast <4 x float> %18 to <2 x i64>
  %21 = tail call <2 x i64> @llvm.x86.sse2.psrl.dq(<2 x i64> %20, i32 8) #2
  %astype.i = bitcast <2 x i64> %21 to <16 x i8>
  %22 = shufflevector <16 x i8> %astype.i, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %22, <4 x i8>* %yOut, align 4
  %23 = tail call <2 x i64> @llvm.x86.sse2.psrl.dq(<2 x i64> %21, i32 8) #2
  %astype2.i = bitcast <2 x i64> %23 to <16 x i8>
  %24 = shufflevector <16 x i8> %astype2.i, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %24, <4 x i8>* %zOut, align 4
  %25 = tail call <2 x i64> @llvm.x86.sse2.psrl.dq(<2 x i64> %23, i32 8) #2
  %astype4.i = bitcast <2 x i64> %25 to <16 x i8>
  %26 = shufflevector <16 x i8> %astype4.i, <16 x i8> undef, <4 x i32> <i32 0, i32 4, i32 8, i32 12>
  store <4 x i8> %26, <4 x i8>* %wOut, align 4
  ret void
}

declare <4 x float> @_Z5clampDv4_fS_S_.clone(<4 x float>, <4 x float>, <4 x float>)

declare <3 x float> @_Z5clampDv3_fS_S_.clone(<3 x float>, <3 x float>, <3 x float>)

declare <2 x float> @_Z5clampDv2_fS_S_.clone(<2 x float>, <2 x float>, <2 x float>)

declare float @_Z5clampfff.clone(float, float, float)

declare <4 x float> @_Z5clampDv4_fff.clone(<4 x float>, float, float)

declare <3 x float> @_Z5clampDv3_fff.clone(<3 x float>, float, float)

declare float @_Z4acosf.clone(float)

declare float @_Z5acoshf.clone(float)

declare float @_Z4asinf.clone(float)

declare float @_Z5asinhf.clone(float)

declare float @_Z4atanf.clone(float)

declare float @_Z5atan2ff.clone(float, float)

declare float @_Z5atanhf.clone(float)

declare float @_Z4cbrtf.clone(float)

declare float @_Z4ceilf.clone(float)

declare float @_Z8copysignff.clone(float, float)

declare float @_Z3cosf.clone(float)

declare float @_Z4coshf.clone(float)

declare float @_Z4erfcf.clone(float)

declare float @_Z3erff.clone(float)

declare float @_Z3expf.clone(float)

declare float @_Z4exp2f.clone(float)

declare float @_Z5expm1f.clone(float)

declare float @_Z4fdimff.clone(float, float)

declare float @_Z5floorf.clone(float)

declare float @_Z3fmafff.clone(float, float, float)

declare float @_Z4fmodff.clone(float, float)

declare float @_Z5frexpfPi.clone(float, i32*)

declare float @_Z5hypotff.clone(float, float)

declare i32 @_Z5ilogbf.clone(float)

declare float @_Z5ldexpfi.clone(float, i32)

declare float @_Z6lgammaf.clone(float)

declare float @_Z6lgammafPi.clone(float, i32*)

declare float @_Z3logf.clone(float)

declare float @_Z5log10f.clone(float)

declare float @_Z5log1pf.clone(float)

declare float @_Z4logbf.clone(float)

declare float @_Z4modffPf.clone(float, float*)

declare float @_Z9nextafterff.clone(float, float)

declare float @_Z3powff.clone(float, float)

declare float @_Z9remainderff.clone(float, float)

declare float @_Z6remquoffPi.clone(float, float, i32*)

declare float @_Z4rintf.clone(float)

declare float @_Z5rootnfi.clone(float, i32)

declare float @_Z5roundf.clone(float)

declare float @_Z3sinf.clone(float)

declare float @_Z4sinhf.clone(float)

declare float @_Z3tanf.clone(float)

declare float @_Z4tanhf.clone(float)

declare float @_Z6tgammaf.clone(float)

declare float @_Z5truncf.clone(float)

declare float @_Z9half_sqrtf.clone(float)

declare float @_Z10half_rsqrtf.clone(float)

declare float @_Z4sqrtf.clone(float)

define i32 @cmpxchg.mock(i32*, i32, i32) {
  %4 = cmpxchg i32* %0, i32 %1, i32 %2 seq_cst seq_cst
  %5 = extractvalue { i32, i1 } %4, 0
  ret i32 %5
}

attributes #0 = { alwaysinline nounwind readnone }
attributes #1 = { alwaysinline nounwind }
attributes #2 = { nounwind }
attributes #3 = { alwaysinline }
attributes #4 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readnone }
attributes #9 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { nounwind readonly }
attributes #12 = { nobuiltin nounwind }
attributes #13 = { nobuiltin }
attributes #14 = { nobuiltin nounwind readnone }

!\23pragma = !{!0, !1}
!\23rs_export_var = !{!2, !3, !4, !5, !6}
!\23rs_object_slots = !{!7, !8}
!\23rs_export_foreach_name = !{!9, !10, !11}
!\23rs_export_foreach = !{!12, !13, !14}
!rs.indexed.kernels = !{!15, !16}
!opencl.build.options = !{!17}

!0 = !{!"version", !"1"}
!1 = !{!"java_package_name", !"com.android.rs.test"}
!2 = !{!"pHList", !"*int"}
!3 = !{!"allocPList", !"20"}
!4 = !{!"allocPos", !"20"}
!5 = !{!"particleRadius", !"1"}
!6 = !{!"gridSize", !"5"}
!7 = !{!"1"}
!8 = !{!"2"}
!9 = !{!"root"}
!10 = !{!"list_reset"}
!11 = !{!"list_create"}
!12 = !{!"0"}
!13 = !{!"42"}
!14 = !{!"43"}
!15 = !{void (i32*, i32)* @list_reset.wrapper.indexed}
!16 = !{void (<4 x float>*, i32*, i32)* @list_create.wrapper.indexed}
!17 = !{!"-cl-std=CL1.2"}
!18 = !{!"float", !19}
!19 = !{!"omnipotent char", !20}
!20 = !{!"Simple C/C++ TBAA"}
!21 = !{!"int", !19}
!22 = !{!"any pointer", !19}
!23 = !{!"_Bool", !19}
!24 = !{i8 0, i8 2}
!25 = !{!25, !26}
!26 = !{!"llvm.vectorizer.width", i32 1}
!27 = !{!"char", !28}
!28 = !{!"allocation", !29}
!29 = !{!"RenderScript TBAA"}
!30 = !{!"char2", !28}
!31 = !{!"char3", !28}
!32 = !{!"char4", !28}
!33 = !{!"uchar", !28}
!34 = !{!"uchar2", !28}
!35 = !{!"uchar3", !28}
!36 = !{!"uchar4", !28}
!37 = !{!"short", !28}
!38 = !{!"short2", !28}
!39 = !{!"short3", !28}
!40 = !{!"short4", !28}
!41 = !{!"ushort", !28}
!42 = !{!"ushort2", !28}
!43 = !{!"ushort3", !28}
!44 = !{!"ushort4", !28}
!45 = !{!"int", !28}
!46 = !{!"int2", !28}
!47 = !{!"int3", !28}
!48 = !{!"int4", !28}
!49 = !{!"uint", !28}
!50 = !{!"uint2", !28}
!51 = !{!"uint3", !28}
!52 = !{!"uint4", !28}
!53 = !{!"long", !28}
!54 = !{!"long2", !28}
!55 = !{!"long3", !28}
!56 = !{!"long4", !28}
!57 = !{!"ulong", !28}
!58 = !{!"ulong2", !28}
!59 = !{!"ulong3", !28}
!60 = !{!"ulong4", !28}
!61 = !{!"float", !28}
!62 = !{!"float2", !28}
!63 = !{!"float3", !28}
!64 = !{!"float4", !28}
!65 = !{!"double", !28}
!66 = !{!"double2", !28}
!67 = !{!"double3", !28}
!68 = !{!"double4", !28}
!69 = !{!69, !26}
!70 = !{!"short", !19}
