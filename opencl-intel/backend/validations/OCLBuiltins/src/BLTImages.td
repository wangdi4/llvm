// vim:ts=2:sw=2:et:

include "ref-opencl-builtin.td"
include "BLTRef.td"

def image3d: OclType<"image3d_t", "image3d_t", 1, 0, 0>;
def sampler_t : OclType<"sampler_t", "sampler_t", 1, 0, 0>;


let Types = [ v4f32, v4i32 ],
    Attrs = [CONSTFUNC, OVERLOADABLE] in {
def read_imagef_2d  : REF_OclBuiltin<"read_imagef",  (outs f32gentype:$ret), (ins image2d:$image, sampler_t:$sampler, gentype2:$coord), [], [], TemplateAttr< [OclBuiltinAttr<"u_float">] > >;
def read_imagei_2d  : REF_OclBuiltin<"read_imagei",  (outs i32gentype:$ret), (ins image2d:$image, sampler_t:$sampler, gentype2:$coord), [], [], TemplateAttr< [OclBuiltinAttr<"u_int32_t">] > >;
def read_imageui_2d  : REF_OclBuiltin<"read_imageui",  (outs u32gentype:$ret), (ins image2d:$image, sampler_t:$sampler, gentype2:$coord), [], [], TemplateAttr< [OclBuiltinAttr<"u_uint32_t">] > >;
def read_imagef_3d  : REF_OclBuiltin<"read_imagef",  (outs f32gentype:$ret), (ins image3d:$image, sampler_t:$sampler, gentype4:$coord), [], [], TemplateAttr< [OclBuiltinAttr<"u_float">] > >;
def read_imagei_3d  : REF_OclBuiltin<"read_imagei",  (outs i32gentype:$ret), (ins image3d:$image, sampler_t:$sampler, gentype4:$coord), [], [], TemplateAttr< [OclBuiltinAttr<"u_int32_t">] > >;
def read_imageui_3d  : REF_OclBuiltin<"read_imageui",  (outs u32gentype:$ret), (ins image3d:$image, sampler_t:$sampler, gentype4:$coord), [], [], TemplateAttr< [OclBuiltinAttr<"u_uint32_t">] > >;
}

let Types = [ v4i32 ],
    Attrs = [CONSTFUNC, OVERLOADABLE] in {
def write_imagef  : REF_OclBuiltin<"write_imagef",  (outs), (ins image2d:$image, gentype2:$coord, f32gentype:$color), [], [], TemplateAttr< [] > >;
def write_imagei  : REF_OclBuiltin<"write_imagei",  (outs), (ins image2d:$image, gentype2:$coord, i32gentype:$color), [], [], TemplateAttr< [] > >;
def write_imageui  : REF_OclBuiltin<"write_imageui",  (outs), (ins image2d:$image, gentype2:$coord, u32gentype:$color), [], [], TemplateAttr< [] > >;
}

let Types = [ v1i32 ],
    Attrs = [CONSTFUNC, OVERLOADABLE] in {
def get_image_width_2d  : REF_OclBuiltin<"get_image_width",  (outs gentype:$ret), (ins image2d:$image), [], [], TemplateAttr< [] > >;
def get_image_width_3d  : REF_OclBuiltin<"get_image_width",  (outs gentype:$ret), (ins image3d:$image), [], [], TemplateAttr< [] > >;
def get_image_height_2d  : REF_OclBuiltin<"get_image_height",  (outs gentype:$ret), (ins image2d:$image), [], [], TemplateAttr< [] > >;
def get_image_height_3d  : REF_OclBuiltin<"get_image_height",  (outs gentype:$ret), (ins image3d:$image), [], [], TemplateAttr< [] > >;
def get_image_depth : REF_OclBuiltin<"get_image_depth",  (outs gentype:$ret), (ins image3d:$image), [], [], TemplateAttr< [] > >;
def get_image_channel_data_type_2d : REF_OclBuiltin<"get_image_channel_data_type",  (outs gentype:$ret), (ins image2d:$image), [], [], TemplateAttr< [] > >;
def get_image_channel_data_type_3d : REF_OclBuiltin<"get_image_channel_data_type",  (outs gentype:$ret), (ins image3d:$image), [], [], TemplateAttr< [] > >;
def get_image_channel_order_2d : REF_OclBuiltin<"get_image_channel_order",  (outs gentype:$ret), (ins image2d:$image), [], [], TemplateAttr< [] > >;
def get_image_channel_order_3d : REF_OclBuiltin<"get_image_channel_order",  (outs gentype:$ret), (ins image3d:$image), [], [], TemplateAttr< [] > >;
def get_image_dim_2d : REF_OclBuiltin<"get_image_dim",  (outs gentype2:$ret), (ins image2d:$image), [], [], TemplateAttr< [] > >;
def get_image_dim_3d : REF_OclBuiltin<"get_image_dim",  (outs gentype4:$ret), (ins image3d:$image), [], [], TemplateAttr< [] > >;
}

class Generic {
  code Prolog = [{
/*****************************************************************************\

Copyright (c) Intel Corporation (2013).

INTEL MAKES NO WARRANTY OF ANY KIND REGARDING THE CODE.  THIS CODE IS
LICENSED ON AN "AS IS" BASIS AND INTEL WILL NOT PROVIDE ANY SUPPORT,
ASSISTANCE, INSTALLATION, TRAINING OR OTHER SERVICES.  INTEL DOES NOT
PROVIDE ANY UPDATES, ENHANCEMENTS OR EXTENSIONS.  INTEL SPECIFICALLY
DISCLAIMS ANY WARRANTY OF MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR ANY
PARTICULAR PURPOSE, OR ANY OTHER WARRANTY.  Intel disclaims all liability,
including liability for infringement of any proprietary rights, relating to
use of the code. No license, express or implied, by estoppels or otherwise,
to any intellectual property rights is granted herein.

File Name:  BLTImages.cpp

\*****************************************************************************/
#define DEBUG_TYPE "OpenCLReferenceRunner"


// debug macros
#include <llvm/Type.h>
#include <llvm/Support/raw_ostream.h>
#include "llvm/Support/Debug.h"

#include "Helpers.h"
#include "BLTImages.h"

// !!!! HACK 
// Do not move #include "CL/cl.h" before including <math.h> since on VS2008 it generates
// Removing annoying ‘ceil’ : attributes not present on previous declaration warning C4985
#include "cl_types.h"
#include "CL/cl.h"


using namespace llvm;
using std::string;
using std::vector;
using namespace Validation::OCLBuiltins;

#ifndef BUILTINS_API
   #if defined(_WIN32)
      #define BUILTINS_API __declspec(dllexport)
   #else
      #define BUILTINS_API
   #endif
#endif

extern "C" {
BUILTINS_API void initOCLBuiltinsImages() {return;}
  }];
  
  code Epilog = [{
}
namespace Validation {
namespace OCLBuiltins {
// convert from Intel OpenCL enums with CLK_ prefix to CL_ prefix
cl_channel_order ConvertChannelOrderFromIntelOCLToCL(const cl_channel_order& val )
{
    cl_channel_order ret;
    switch (val)
    {
    case CLK_R:          ret = CL_R; break;
    // todo: add CL_Rx
    //case OpenCL_Rx:         ret = CL_Rx; throw; break;
    case CLK_A:          ret = CL_A; break;
    case CLK_INTENSITY:  ret = CL_INTENSITY; break;
    case CLK_LUMINANCE:  ret = CL_LUMINANCE; break;
    case CLK_RG:         ret = CL_RG; break;
    // todo: add CL_RGx
    //case OpenCL_RGx:        ret = CL_RGx; throw; break;
    case CLK_RA:         ret = CL_RA; break;
    case CLK_RGB:        ret = CL_RGB; break;
    // todo: add CL_RGBx
    //case OpenCL_RGBx:       ret = CL_RGBx; throw; break;
    case CLK_RGBA:       ret = CL_RGBA; break;
    case CLK_ARGB:       ret = CL_ARGB; break;
    case CLK_BGRA:       ret = CL_BGRA; break;
    default: throw Exception::InvalidArgument("ConvertChannelOrderFromIntelOCLToCL:: Unknown Image pixel data type");
    }
    return ret;
}

// convert from Intel OpenCL enums with CLK_ prefix to CL_ prefix
cl_channel_type ConvertChannelDataTypeFromIntelOCLToCL(const cl_channel_type& val )
{
    cl_channel_type ret;
    switch (val)
    {
    case CLK_SNORM_INT8:         ret = CL_SNORM_INT8; break;
    case CLK_SNORM_INT16:        ret = CL_SNORM_INT16; break;
    case CLK_UNORM_INT8:         ret = CL_UNORM_INT8; break;
    case CLK_UNORM_INT16:        ret = CL_UNORM_INT16; break;
    case CLK_UNORM_SHORT_565:    ret = CL_UNORM_SHORT_565; break;
    case CLK_UNORM_SHORT_555:    ret = CL_UNORM_SHORT_555; break;
    case CLK_UNORM_INT_101010:   ret = CL_UNORM_INT_101010; break;
    case CLK_SIGNED_INT8:        ret = CL_SIGNED_INT8; break;
    case CLK_SIGNED_INT16:       ret = CL_SIGNED_INT16; break;
    case CLK_SIGNED_INT32:       ret = CL_SIGNED_INT32; break;
    case CLK_UNSIGNED_INT8:      ret = CL_UNSIGNED_INT8; break;
    case CLK_UNSIGNED_INT16:     ret = CL_UNSIGNED_INT16; break;
    case CLK_UNSIGNED_INT32:     ret = CL_UNSIGNED_INT32; break;
    case CLK_HALF_FLOAT:         ret = CL_HALF_FLOAT; break;
    case CLK_FLOAT:              ret = CL_FLOAT; break;
    default: throw Exception::InvalidArgument("ConvertChannelDataTypeFromIntelOCLToCL:: Unknown Image channel data type");
    }
    return ret;
}

Conformance::image_descriptor CreateConfImageDesc(const cl_mem_obj_descriptor& in_Desc, 
                                                         cl_image_format& out_ImageFmt)
{
    Conformance::image_descriptor retDesc;
    const bool Is2D = (in_Desc.dim_count == 2);
    const bool Is3D = (in_Desc.dim_count == 3);
    
    retDesc.width = (size_t) in_Desc.dimensions.dim[0];
    retDesc.height = (size_t) ((Is2D || Is3D)? in_Desc.dimensions.dim[1] : 0);
    retDesc.depth = (size_t) (Is3D ? in_Desc.dimensions.dim[2] : 0);
    retDesc.rowPitch = (size_t) in_Desc.pitch[0];
    retDesc.slicePitch = (size_t) (Is3D ? in_Desc.pitch[1] : 0);

    // TODO: to add array support when runtime 1.2 will be ready
    if(Is2D) 
        retDesc.type = CL_MEM_OBJECT_IMAGE2D;
    if(Is3D) 
        retDesc.type = CL_MEM_OBJECT_IMAGE3D;

    retDesc.arraySize = 0;
    
    out_ImageFmt.image_channel_data_type = 
        ConvertChannelDataTypeFromIntelOCLToCL(in_Desc.format.image_channel_data_type);
    out_ImageFmt.image_channel_order = 
        ConvertChannelOrderFromIntelOCLToCL(in_Desc.format.image_channel_order);
    retDesc.format = &out_ImageFmt;
    return retDesc;
}

Conformance::image_sampler_data CreateSamplerData(const uint32_t& in_sampler)
{
    Conformance::image_sampler_data retSampler;
    cl_addressing_mode dst_adr;
    switch(in_sampler & __ADDRESS_MASK)
    {
    case CL_DEV_SAMPLER_ADDRESS_NONE:
        dst_adr = CL_ADDRESS_NONE; break;
    case CL_DEV_SAMPLER_ADDRESS_CLAMP:
        dst_adr = CL_ADDRESS_CLAMP; break;
    case CL_DEV_SAMPLER_ADDRESS_CLAMP_TO_EDGE:
        dst_adr = CL_ADDRESS_CLAMP_TO_EDGE; break;
    case CL_DEV_SAMPLER_ADDRESS_REPEAT:
        dst_adr = CL_ADDRESS_REPEAT; break;
    case CL_DEV_SAMPLER_ADDRESS_MIRRORED_REPEAT:
        dst_adr = CL_ADDRESS_MIRRORED_REPEAT; break;
    default:
        throw Exception::InvalidArgument("Not supported sampler addressing mode");
        break;
    }
    
    cl_filter_mode dst_filt;
    switch(in_sampler & __FILTER_MASK)
    {
    case CL_DEV_SAMPLER_FILTER_NEAREST:
        dst_filt = CL_FILTER_NEAREST; break;
    case CL_DEV_SAMPLER_FILTER_LINEAR:
        dst_filt = CL_FILTER_LINEAR; break;
    default:
        throw Exception::InvalidArgument("Not supported sampler filter type");
    }

    retSampler.addressing_mode = dst_adr;
    retSampler.filter_mode = dst_filt;
    retSampler.normalized_coords = (in_sampler & __NORMALIZED_MASK);
    return retSampler;
}

GenericValue lle_X_get_image_dim2(FunctionType *FT,
                                  const std::vector<GenericValue> &Args) 
{

    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;
    const uint32_t width = (uint32_t)memobj->dimensions.dim[0];
    const uint32_t height = (uint32_t)memobj->dimensions.dim[1];
    
    gv.AggregateVal.resize(2);
    gv.AggregateVal[0].IntVal = APInt(32, width);
    gv.AggregateVal[1].IntVal = APInt(32, height);

    return gv;
}

GenericValue lle_X_get_image_width(FunctionType *FT,
                                   const std::vector<GenericValue> &Args) 
{

    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;
    const uint32_t width = (uint32_t)memobj->dimensions.dim[0];
    gv.IntVal = APInt(32, width);
    return gv;
}

GenericValue lle_X_get_image_height(FunctionType *FT,
                                    const std::vector<GenericValue> &Args) 
{

    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;
    const uint32_t height = (uint32_t)memobj->dimensions.dim[1];
    gv.IntVal = APInt(32, height);
    return gv;
}

GenericValue lle_X_get_image_depth(FunctionType *FT,
                                    const std::vector<GenericValue> &Args) 
{

    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;
    const uint32_t depth = (uint32_t)memobj->dimensions.dim[2];
    gv.IntVal = APInt(32, depth);
    return gv;
}

GenericValue lle_X_get_image_dim3(FunctionType *FT,
                                  const std::vector<GenericValue> &Args) 
{

    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;
    const uint32_t width = (uint32_t)memobj->dimensions.dim[0];
    const uint32_t height = (uint32_t)memobj->dimensions.dim[1];
    const uint32_t depth = (uint32_t)memobj->dimensions.dim[2];
    
    gv.AggregateVal.resize(4);
    gv.AggregateVal[0].IntVal = APInt(32, width);
    gv.AggregateVal[1].IntVal = APInt(32, height);
    gv.AggregateVal[2].IntVal = APInt(32, depth);
    gv.AggregateVal[3].IntVal = APInt(32, 0);

    return gv;
}

GenericValue lle_X_get_image_channel_data_type(FunctionType *FT,
                                  const std::vector<GenericValue> &Args) 
{
    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;
    const int32_t image_channel_data_type = memobj->format.image_channel_data_type;
    gv.IntVal = APInt( 32, image_channel_data_type );
    return gv;
}

GenericValue lle_X_get_image_channel_order(FunctionType *FT,
                                               const std::vector<GenericValue> &Args) 
{
    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;
    const int32_t image_channel_order = memobj->format.image_channel_order;
    gv.IntVal = APInt( 32, image_channel_order );
    return gv;
}

llvm::GenericValue lle_X_write_image( llvm::FunctionType *FT, 
                                     const std::vector<llvm::GenericValue> &Args )
{
    GenericValue gv;
    cl_mem_obj_descriptor * memobj = (cl_mem_obj_descriptor *)Args[0].PointerVal;

    const int32_t dimCnt = memobj->dim_count;
    
    cl_image_format im_fmt;
    Conformance::image_descriptor desc = CreateConfImageDesc(*memobj, im_fmt);

    // coordinates
    const GenericValue& CoordGV = Args[1];
    const int32_t u = getVal<uint32_t, 4>(CoordGV, 0);
    const int32_t v = (dimCnt > 1) ? getVal<uint32_t, 4>(CoordGV, 1) : 0;
    const int32_t w = (dimCnt > 2) ? getVal<uint32_t, 4>(CoordGV, 2) : 0;

    // datatype of pixel 
    const GenericValue& PixelGV = Args[2];
    const llvm::Type::TypeID PixelTy= FT->getParamType(2)->getContainedType(0)->getTypeID();

    if (PixelTy == llvm::Type::FloatTyID)
    {   // pixel data type is float
        float val[4] = 
                       {PixelGV.AggregateVal[0].FloatVal, 
                        PixelGV.AggregateVal[1].FloatVal,
                        PixelGV.AggregateVal[2].FloatVal, 
                        PixelGV.AggregateVal[3].FloatVal };
        write_image_pixel_float(memobj->pData, &desc, u, v, w, val);    
    }
    else if(PixelTy == llvm::Type::IntegerTyID && CoordGV.AggregateVal[0].IntVal.isSignedIntN(32))
    {   // pixel is signed int
        int32_t val[4] = 
        {   (int32_t)PixelGV.AggregateVal[0].IntVal.getSExtValue(), 
            (int32_t)PixelGV.AggregateVal[1].IntVal.getSExtValue(),
            (int32_t)PixelGV.AggregateVal[2].IntVal.getSExtValue(), 
            (int32_t)PixelGV.AggregateVal[3].IntVal.getSExtValue()};

        write_image_pixel_int(memobj->pData, &desc, u, v, w, val);    
    }
    else if(PixelTy == llvm::Type::IntegerTyID && !CoordGV.AggregateVal[0].IntVal.isSignedIntN(32))
    {   // pixel is unsigned int
        uint32_t val[4] = 
        {   (uint32_t)PixelGV.AggregateVal[0].IntVal.getZExtValue(), 
            (uint32_t)PixelGV.AggregateVal[1].IntVal.getZExtValue(),
            (uint32_t)PixelGV.AggregateVal[2].IntVal.getZExtValue(), 
            (uint32_t)PixelGV.AggregateVal[3].IntVal.getZExtValue()};
        write_image_pixel_uint(memobj->pData, &desc, u, v, w, val);    
    }
    else throw Exception::InvalidArgument("lle_X_write_image::Invalid data type of pixel data");

    return gv;

}
}
}
  }];
  
}
  def inc : Generic;
