// INTEL CONFIDENTIAL
//
// Copyright 2011-2018 Intel Corporation.
//
// This software and the related documents are Intel copyrighted materials, and
// your use of them is governed by the express license under which they were
// provided to you (License). Unless the License provides otherwise, you may not
// use, modify, copy, publish, distribute, disclose or transmit this software or
// the related documents without Intel's prior written permission.
//
// This software and the related documents are provided as is, with no express
// or implied warranties, other than those that are expressly stated in the
// License.

#include "OpenCLFactory.h"

#include "RunResult.h"
#include "OpenCLProgram.h"
#include "OpenCLCPUBackendRunner.h"
#include "OpenCLReferenceRunner.h"
#include "OpenCLRunConfiguration.h"
#include "OpenCLBackendWrapper.h"
#include "OpenCLComparator.h"

#define DEBUG_TYPE "OpenCLFactory"
// debug macros
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

using namespace Validation;
using std::string;

OpenCLFactory::OpenCLFactory(void)
{
}

OpenCLFactory::~OpenCLFactory(void)
{
}

IProgram * OpenCLFactory::CreateProgram(IProgramConfiguration* programConfig,
                                        IRunConfiguration* runConfig)
{
    OpenCLProgramConfiguration* pOCLProgramConfig = static_cast<OpenCLProgramConfiguration*>(programConfig);
    const BERunOptions* pBERunConfig = static_cast<const BERunOptions*>(runConfig->GetBackendRunnerConfiguration());
    std::string arch = pBERunConfig->GetValue<std::string>(RC_BR_CPU_ARCHITECTURE,std::string(""));

    return new OpenCLProgram(pOCLProgramConfig, arch);
}

IProgramConfiguration * OpenCLFactory::CreateProgramConfiguration(const string& configFile, const string& baseDir)
{
    return new OpenCLProgramConfiguration(configFile, baseDir);
}

IRunConfiguration * OpenCLFactory::CreateRunConfiguration()
{
    return new OpenCLRunConfiguration();
}

IProgramRunner * OpenCLFactory::CreateProgramRunner(const IRunComponentConfiguration* pRunConfiguration)
{
    const BERunOptions *runConfig = static_cast<const BERunOptions*>(pRunConfiguration);
    return new OpenCLCPUBackendRunner(*runConfig);
}

IProgramRunner * OpenCLFactory::CreateReferenceRunner(const IRunComponentConfiguration* pRunConfiguration)
{
    return new OpenCLReferenceRunner(static_cast<const ReferenceRunOptions*>(pRunConfiguration)->GetValue<bool>(RC_REF_USE_NEAT, false));
}

IRunResultComparator* OpenCLFactory::CreateComparator(IProgramConfiguration* pProgramConfiguration,
                                                      IRunConfiguration* pRunConfiguration)
{
    return new OpenCLComparator(static_cast<OpenCLProgramConfiguration*>(pProgramConfiguration),
        static_cast<const ComparatorRunOptions*>(pRunConfiguration->GetComparatorConfiguration()),
        static_cast<const ReferenceRunOptions*>(pRunConfiguration->GetReferenceRunnerConfiguration())
        );
}

