// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: debugservermessages.proto

#ifndef PROTOBUF_debugservermessages_2eproto__INCLUDED
#define PROTOBUF_debugservermessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace debugservermessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_debugservermessages_2eproto();
void protobuf_AssignDesc_debugservermessages_2eproto();
void protobuf_ShutdownFile_debugservermessages_2eproto();

class ClientToServerMessage;
class ClientToServerMessage_StartSessionMsg;
class ClientToServerMessage_RunMsg;
class ClientToServerMessage_GetMemoryRangeMsg;
class ServerToClientMessage;
class ServerToClientMessage_CmdErrorMsg;
class ServerToClientMessage_StartSessionAckMsg;
class ServerToClientMessage_VarInfo;
class ServerToClientMessage_StackFrameInfo;
class ServerToClientMessage_BPHitMsg;
class ServerToClientMessage_StackTraceInfoMsg;
class ServerToClientMessage_MemoryRangeInfoMsg;
class LineInfo;
class VarTypeDescriptor;
class VarTypeBasic;
class VarTypePointer;
class VarTypeArray;
class VarTypeEnum;
class VarTypeEnum_EnumEntry;
class VarTypeStruct;
class VarTypeStruct_StructMember;
class VarTypeVector;
class VarTypeTypedef;

enum ClientToServerMessage_Type {
  ClientToServerMessage_Type_START_SESSION = 1,
  ClientToServerMessage_Type_RUN = 2,
  ClientToServerMessage_Type_SINGLE_STEP_IN = 3,
  ClientToServerMessage_Type_SINGLE_STEP_OVER = 4,
  ClientToServerMessage_Type_SINGLE_STEP_OUT = 5,
  ClientToServerMessage_Type_GET_STACK_TRACE = 21,
  ClientToServerMessage_Type_GET_MEMORY_RANGE = 22,
  ClientToServerMessage_Type_BAD_MSG_TEST = 99
};
bool ClientToServerMessage_Type_IsValid(int value);
const ClientToServerMessage_Type ClientToServerMessage_Type_Type_MIN = ClientToServerMessage_Type_START_SESSION;
const ClientToServerMessage_Type ClientToServerMessage_Type_Type_MAX = ClientToServerMessage_Type_BAD_MSG_TEST;
const int ClientToServerMessage_Type_Type_ARRAYSIZE = ClientToServerMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientToServerMessage_Type_descriptor();
inline const ::std::string& ClientToServerMessage_Type_Name(ClientToServerMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientToServerMessage_Type_descriptor(), value);
}
inline bool ClientToServerMessage_Type_Parse(
    const ::std::string& name, ClientToServerMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientToServerMessage_Type>(
    ClientToServerMessage_Type_descriptor(), name, value);
}
enum ServerToClientMessage_Type {
  ServerToClientMessage_Type_CMD_ERROR = 1,
  ServerToClientMessage_Type_START_SESSION_ACK = 2,
  ServerToClientMessage_Type_BP_HIT = 3,
  ServerToClientMessage_Type_STACK_TRACE_INFO = 4,
  ServerToClientMessage_Type_MEMORY_RANGE_INFO = 5
};
bool ServerToClientMessage_Type_IsValid(int value);
const ServerToClientMessage_Type ServerToClientMessage_Type_Type_MIN = ServerToClientMessage_Type_CMD_ERROR;
const ServerToClientMessage_Type ServerToClientMessage_Type_Type_MAX = ServerToClientMessage_Type_MEMORY_RANGE_INFO;
const int ServerToClientMessage_Type_Type_ARRAYSIZE = ServerToClientMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerToClientMessage_Type_descriptor();
inline const ::std::string& ServerToClientMessage_Type_Name(ServerToClientMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerToClientMessage_Type_descriptor(), value);
}
inline bool ServerToClientMessage_Type_Parse(
    const ::std::string& name, ServerToClientMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerToClientMessage_Type>(
    ServerToClientMessage_Type_descriptor(), name, value);
}
enum VarTypeDescriptor_Tag {
  VarTypeDescriptor_Tag_BASIC = 0,
  VarTypeDescriptor_Tag_POINTER = 1,
  VarTypeDescriptor_Tag_ARRAY = 2,
  VarTypeDescriptor_Tag_VECTOR = 3,
  VarTypeDescriptor_Tag_TYPEDEF = 4,
  VarTypeDescriptor_Tag_ENUM = 5,
  VarTypeDescriptor_Tag_STRUCT = 6,
  VarTypeDescriptor_Tag_UNKNOWN = 99
};
bool VarTypeDescriptor_Tag_IsValid(int value);
const VarTypeDescriptor_Tag VarTypeDescriptor_Tag_Tag_MIN = VarTypeDescriptor_Tag_BASIC;
const VarTypeDescriptor_Tag VarTypeDescriptor_Tag_Tag_MAX = VarTypeDescriptor_Tag_UNKNOWN;
const int VarTypeDescriptor_Tag_Tag_ARRAYSIZE = VarTypeDescriptor_Tag_Tag_MAX + 1;

const ::google::protobuf::EnumDescriptor* VarTypeDescriptor_Tag_descriptor();
inline const ::std::string& VarTypeDescriptor_Tag_Name(VarTypeDescriptor_Tag value) {
  return ::google::protobuf::internal::NameOfEnum(
    VarTypeDescriptor_Tag_descriptor(), value);
}
inline bool VarTypeDescriptor_Tag_Parse(
    const ::std::string& name, VarTypeDescriptor_Tag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VarTypeDescriptor_Tag>(
    VarTypeDescriptor_Tag_descriptor(), name, value);
}
enum VarTypeBasic_Tag {
  VarTypeBasic_Tag_BOOLEAN = 0,
  VarTypeBasic_Tag_FLOAT = 1,
  VarTypeBasic_Tag_SIGNED = 2,
  VarTypeBasic_Tag_SIGNED_CHAR = 3,
  VarTypeBasic_Tag_UNSIGNED = 4,
  VarTypeBasic_Tag_UNSIGNED_CHAR = 5,
  VarTypeBasic_Tag_UNKNOWN = 99
};
bool VarTypeBasic_Tag_IsValid(int value);
const VarTypeBasic_Tag VarTypeBasic_Tag_Tag_MIN = VarTypeBasic_Tag_BOOLEAN;
const VarTypeBasic_Tag VarTypeBasic_Tag_Tag_MAX = VarTypeBasic_Tag_UNKNOWN;
const int VarTypeBasic_Tag_Tag_ARRAYSIZE = VarTypeBasic_Tag_Tag_MAX + 1;

const ::google::protobuf::EnumDescriptor* VarTypeBasic_Tag_descriptor();
inline const ::std::string& VarTypeBasic_Tag_Name(VarTypeBasic_Tag value) {
  return ::google::protobuf::internal::NameOfEnum(
    VarTypeBasic_Tag_descriptor(), value);
}
inline bool VarTypeBasic_Tag_Parse(
    const ::std::string& name, VarTypeBasic_Tag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VarTypeBasic_Tag>(
    VarTypeBasic_Tag_descriptor(), name, value);
}
// ===================================================================

class ClientToServerMessage_StartSessionMsg : public ::google::protobuf::Message {
 public:
  ClientToServerMessage_StartSessionMsg();
  virtual ~ClientToServerMessage_StartSessionMsg();
  
  ClientToServerMessage_StartSessionMsg(const ClientToServerMessage_StartSessionMsg& from);
  
  inline ClientToServerMessage_StartSessionMsg& operator=(const ClientToServerMessage_StartSessionMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage_StartSessionMsg& default_instance();
  
  void Swap(ClientToServerMessage_StartSessionMsg* other);
  
  // implements Message ----------------------------------------------
  
  ClientToServerMessage_StartSessionMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientToServerMessage_StartSessionMsg& from);
  void MergeFrom(const ClientToServerMessage_StartSessionMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 global_id_x = 1;
  inline bool has_global_id_x() const;
  inline void clear_global_id_x();
  static const int kGlobalIdXFieldNumber = 1;
  inline ::google::protobuf::uint32 global_id_x() const;
  inline void set_global_id_x(::google::protobuf::uint32 value);
  
  // required uint32 global_id_y = 2;
  inline bool has_global_id_y() const;
  inline void clear_global_id_y();
  static const int kGlobalIdYFieldNumber = 2;
  inline ::google::protobuf::uint32 global_id_y() const;
  inline void set_global_id_y(::google::protobuf::uint32 value);
  
  // required uint32 global_id_z = 3;
  inline bool has_global_id_z() const;
  inline void clear_global_id_z();
  static const int kGlobalIdZFieldNumber = 3;
  inline ::google::protobuf::uint32 global_id_z() const;
  inline void set_global_id_z(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage.StartSessionMsg)
 private:
  inline void set_has_global_id_x();
  inline void clear_has_global_id_x();
  inline void set_has_global_id_y();
  inline void clear_has_global_id_y();
  inline void set_has_global_id_z();
  inline void clear_has_global_id_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 global_id_x_;
  ::google::protobuf::uint32 global_id_y_;
  ::google::protobuf::uint32 global_id_z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ClientToServerMessage_StartSessionMsg* default_instance_;
};
// -------------------------------------------------------------------

class ClientToServerMessage_RunMsg : public ::google::protobuf::Message {
 public:
  ClientToServerMessage_RunMsg();
  virtual ~ClientToServerMessage_RunMsg();
  
  ClientToServerMessage_RunMsg(const ClientToServerMessage_RunMsg& from);
  
  inline ClientToServerMessage_RunMsg& operator=(const ClientToServerMessage_RunMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage_RunMsg& default_instance();
  
  void Swap(ClientToServerMessage_RunMsg* other);
  
  // implements Message ----------------------------------------------
  
  ClientToServerMessage_RunMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientToServerMessage_RunMsg& from);
  void MergeFrom(const ClientToServerMessage_RunMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // repeated .debugservermessages.LineInfo breakpoints = 2;
  inline int breakpoints_size() const;
  inline void clear_breakpoints();
  static const int kBreakpointsFieldNumber = 2;
  inline const ::debugservermessages::LineInfo& breakpoints(int index) const;
  inline ::debugservermessages::LineInfo* mutable_breakpoints(int index);
  inline ::debugservermessages::LineInfo* add_breakpoints();
  inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >&
      breakpoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >*
      mutable_breakpoints();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage.RunMsg)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* info_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo > breakpoints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ClientToServerMessage_RunMsg* default_instance_;
};
// -------------------------------------------------------------------

class ClientToServerMessage_GetMemoryRangeMsg : public ::google::protobuf::Message {
 public:
  ClientToServerMessage_GetMemoryRangeMsg();
  virtual ~ClientToServerMessage_GetMemoryRangeMsg();
  
  ClientToServerMessage_GetMemoryRangeMsg(const ClientToServerMessage_GetMemoryRangeMsg& from);
  
  inline ClientToServerMessage_GetMemoryRangeMsg& operator=(const ClientToServerMessage_GetMemoryRangeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage_GetMemoryRangeMsg& default_instance();
  
  void Swap(ClientToServerMessage_GetMemoryRangeMsg* other);
  
  // implements Message ----------------------------------------------
  
  ClientToServerMessage_GetMemoryRangeMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientToServerMessage_GetMemoryRangeMsg& from);
  void MergeFrom(const ClientToServerMessage_GetMemoryRangeMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 start_addr = 1;
  inline bool has_start_addr() const;
  inline void clear_start_addr();
  static const int kStartAddrFieldNumber = 1;
  inline ::google::protobuf::uint64 start_addr() const;
  inline void set_start_addr(::google::protobuf::uint64 value);
  
  // required uint64 end_addr = 2;
  inline bool has_end_addr() const;
  inline void clear_end_addr();
  static const int kEndAddrFieldNumber = 2;
  inline ::google::protobuf::uint64 end_addr() const;
  inline void set_end_addr(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage.GetMemoryRangeMsg)
 private:
  inline void set_has_start_addr();
  inline void clear_has_start_addr();
  inline void set_has_end_addr();
  inline void clear_has_end_addr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 start_addr_;
  ::google::protobuf::uint64 end_addr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ClientToServerMessage_GetMemoryRangeMsg* default_instance_;
};
// -------------------------------------------------------------------

class ClientToServerMessage : public ::google::protobuf::Message {
 public:
  ClientToServerMessage();
  virtual ~ClientToServerMessage();
  
  ClientToServerMessage(const ClientToServerMessage& from);
  
  inline ClientToServerMessage& operator=(const ClientToServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage& default_instance();
  
  void Swap(ClientToServerMessage* other);
  
  // implements Message ----------------------------------------------
  
  ClientToServerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientToServerMessage& from);
  void MergeFrom(const ClientToServerMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientToServerMessage_StartSessionMsg StartSessionMsg;
  typedef ClientToServerMessage_RunMsg RunMsg;
  typedef ClientToServerMessage_GetMemoryRangeMsg GetMemoryRangeMsg;
  
  typedef ClientToServerMessage_Type Type;
  static const Type START_SESSION = ClientToServerMessage_Type_START_SESSION;
  static const Type RUN = ClientToServerMessage_Type_RUN;
  static const Type SINGLE_STEP_IN = ClientToServerMessage_Type_SINGLE_STEP_IN;
  static const Type SINGLE_STEP_OVER = ClientToServerMessage_Type_SINGLE_STEP_OVER;
  static const Type SINGLE_STEP_OUT = ClientToServerMessage_Type_SINGLE_STEP_OUT;
  static const Type GET_STACK_TRACE = ClientToServerMessage_Type_GET_STACK_TRACE;
  static const Type GET_MEMORY_RANGE = ClientToServerMessage_Type_GET_MEMORY_RANGE;
  static const Type BAD_MSG_TEST = ClientToServerMessage_Type_BAD_MSG_TEST;
  static inline bool Type_IsValid(int value) {
    return ClientToServerMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientToServerMessage_Type_Type_MIN;
  static const Type Type_MAX =
    ClientToServerMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientToServerMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ClientToServerMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ClientToServerMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ClientToServerMessage_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .debugservermessages.ClientToServerMessage.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::debugservermessages::ClientToServerMessage_Type type() const;
  inline void set_type(::debugservermessages::ClientToServerMessage_Type value);
  
  // optional .debugservermessages.ClientToServerMessage.StartSessionMsg start_session_msg = 20;
  inline bool has_start_session_msg() const;
  inline void clear_start_session_msg();
  static const int kStartSessionMsgFieldNumber = 20;
  inline const ::debugservermessages::ClientToServerMessage_StartSessionMsg& start_session_msg() const;
  inline ::debugservermessages::ClientToServerMessage_StartSessionMsg* mutable_start_session_msg();
  inline ::debugservermessages::ClientToServerMessage_StartSessionMsg* release_start_session_msg();
  
  // optional .debugservermessages.ClientToServerMessage.RunMsg run_msg = 21;
  inline bool has_run_msg() const;
  inline void clear_run_msg();
  static const int kRunMsgFieldNumber = 21;
  inline const ::debugservermessages::ClientToServerMessage_RunMsg& run_msg() const;
  inline ::debugservermessages::ClientToServerMessage_RunMsg* mutable_run_msg();
  inline ::debugservermessages::ClientToServerMessage_RunMsg* release_run_msg();
  
  // optional .debugservermessages.ClientToServerMessage.GetMemoryRangeMsg get_memory_range_msg = 31;
  inline bool has_get_memory_range_msg() const;
  inline void clear_get_memory_range_msg();
  static const int kGetMemoryRangeMsgFieldNumber = 31;
  inline const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg& get_memory_range_msg() const;
  inline ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* mutable_get_memory_range_msg();
  inline ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* release_get_memory_range_msg();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_start_session_msg();
  inline void clear_has_start_session_msg();
  inline void set_has_run_msg();
  inline void clear_has_run_msg();
  inline void set_has_get_memory_range_msg();
  inline void clear_has_get_memory_range_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::debugservermessages::ClientToServerMessage_StartSessionMsg* start_session_msg_;
  ::debugservermessages::ClientToServerMessage_RunMsg* run_msg_;
  ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* get_memory_range_msg_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ClientToServerMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage_CmdErrorMsg : public ::google::protobuf::Message {
 public:
  ServerToClientMessage_CmdErrorMsg();
  virtual ~ServerToClientMessage_CmdErrorMsg();
  
  ServerToClientMessage_CmdErrorMsg(const ServerToClientMessage_CmdErrorMsg& from);
  
  inline ServerToClientMessage_CmdErrorMsg& operator=(const ServerToClientMessage_CmdErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_CmdErrorMsg& default_instance();
  
  void Swap(ServerToClientMessage_CmdErrorMsg* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage_CmdErrorMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage_CmdErrorMsg& from);
  void MergeFrom(const ServerToClientMessage_CmdErrorMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string description = 1;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 1;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.CmdErrorMsg)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* description_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage_CmdErrorMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage_StartSessionAckMsg : public ::google::protobuf::Message {
 public:
  ServerToClientMessage_StartSessionAckMsg();
  virtual ~ServerToClientMessage_StartSessionAckMsg();
  
  ServerToClientMessage_StartSessionAckMsg(const ServerToClientMessage_StartSessionAckMsg& from);
  
  inline ServerToClientMessage_StartSessionAckMsg& operator=(const ServerToClientMessage_StartSessionAckMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_StartSessionAckMsg& default_instance();
  
  void Swap(ServerToClientMessage_StartSessionAckMsg* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage_StartSessionAckMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage_StartSessionAckMsg& from);
  void MergeFrom(const ServerToClientMessage_StartSessionAckMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 sizeof_size_t = 1;
  inline bool has_sizeof_size_t() const;
  inline void clear_sizeof_size_t();
  static const int kSizeofSizeTFieldNumber = 1;
  inline ::google::protobuf::uint32 sizeof_size_t() const;
  inline void set_sizeof_size_t(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.StartSessionAckMsg)
 private:
  inline void set_has_sizeof_size_t();
  inline void clear_has_sizeof_size_t();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 sizeof_size_t_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage_StartSessionAckMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage_VarInfo : public ::google::protobuf::Message {
 public:
  ServerToClientMessage_VarInfo();
  virtual ~ServerToClientMessage_VarInfo();
  
  ServerToClientMessage_VarInfo(const ServerToClientMessage_VarInfo& from);
  
  inline ServerToClientMessage_VarInfo& operator=(const ServerToClientMessage_VarInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_VarInfo& default_instance();
  
  void Swap(ServerToClientMessage_VarInfo* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage_VarInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage_VarInfo& from);
  void MergeFrom(const ServerToClientMessage_VarInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // required uint64 address = 4;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 4;
  inline ::google::protobuf::uint64 address() const;
  inline void set_address(::google::protobuf::uint64 value);
  
  // required .debugservermessages.VarTypeDescriptor type_descriptor = 5;
  inline bool has_type_descriptor() const;
  inline void clear_type_descriptor();
  static const int kTypeDescriptorFieldNumber = 5;
  inline const ::debugservermessages::VarTypeDescriptor& type_descriptor() const;
  inline ::debugservermessages::VarTypeDescriptor* mutable_type_descriptor();
  inline ::debugservermessages::VarTypeDescriptor* release_type_descriptor();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.VarInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_type_descriptor();
  inline void clear_has_type_descriptor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  ::std::string* type_;
  ::google::protobuf::uint64 address_;
  ::debugservermessages::VarTypeDescriptor* type_descriptor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage_VarInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage_StackFrameInfo : public ::google::protobuf::Message {
 public:
  ServerToClientMessage_StackFrameInfo();
  virtual ~ServerToClientMessage_StackFrameInfo();
  
  ServerToClientMessage_StackFrameInfo(const ServerToClientMessage_StackFrameInfo& from);
  
  inline ServerToClientMessage_StackFrameInfo& operator=(const ServerToClientMessage_StackFrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_StackFrameInfo& default_instance();
  
  void Swap(ServerToClientMessage_StackFrameInfo* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage_StackFrameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage_StackFrameInfo& from);
  void MergeFrom(const ServerToClientMessage_StackFrameInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string func_name = 1;
  inline bool has_func_name() const;
  inline void clear_func_name();
  static const int kFuncNameFieldNumber = 1;
  inline const ::std::string& func_name() const;
  inline void set_func_name(const ::std::string& value);
  inline void set_func_name(const char* value);
  inline void set_func_name(const char* value, size_t size);
  inline ::std::string* mutable_func_name();
  inline ::std::string* release_func_name();
  
  // required .debugservermessages.LineInfo call_line = 2;
  inline bool has_call_line() const;
  inline void clear_call_line();
  static const int kCallLineFieldNumber = 2;
  inline const ::debugservermessages::LineInfo& call_line() const;
  inline ::debugservermessages::LineInfo* mutable_call_line();
  inline ::debugservermessages::LineInfo* release_call_line();
  
  // repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 3;
  inline int vars_size() const;
  inline void clear_vars();
  static const int kVarsFieldNumber = 3;
  inline const ::debugservermessages::ServerToClientMessage_VarInfo& vars(int index) const;
  inline ::debugservermessages::ServerToClientMessage_VarInfo* mutable_vars(int index);
  inline ::debugservermessages::ServerToClientMessage_VarInfo* add_vars();
  inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
      vars() const;
  inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
      mutable_vars();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.StackFrameInfo)
 private:
  inline void set_has_func_name();
  inline void clear_has_func_name();
  inline void set_has_call_line();
  inline void clear_has_call_line();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* func_name_;
  ::debugservermessages::LineInfo* call_line_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo > vars_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage_StackFrameInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage_BPHitMsg : public ::google::protobuf::Message {
 public:
  ServerToClientMessage_BPHitMsg();
  virtual ~ServerToClientMessage_BPHitMsg();
  
  ServerToClientMessage_BPHitMsg(const ServerToClientMessage_BPHitMsg& from);
  
  inline ServerToClientMessage_BPHitMsg& operator=(const ServerToClientMessage_BPHitMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_BPHitMsg& default_instance();
  
  void Swap(ServerToClientMessage_BPHitMsg* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage_BPHitMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage_BPHitMsg& from);
  void MergeFrom(const ServerToClientMessage_BPHitMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .debugservermessages.LineInfo breakpoint = 1;
  inline bool has_breakpoint() const;
  inline void clear_breakpoint();
  static const int kBreakpointFieldNumber = 1;
  inline const ::debugservermessages::LineInfo& breakpoint() const;
  inline ::debugservermessages::LineInfo* mutable_breakpoint();
  inline ::debugservermessages::LineInfo* release_breakpoint();
  
  // repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 2;
  inline int vars_size() const;
  inline void clear_vars();
  static const int kVarsFieldNumber = 2;
  inline const ::debugservermessages::ServerToClientMessage_VarInfo& vars(int index) const;
  inline ::debugservermessages::ServerToClientMessage_VarInfo* mutable_vars(int index);
  inline ::debugservermessages::ServerToClientMessage_VarInfo* add_vars();
  inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
      vars() const;
  inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
      mutable_vars();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.BPHitMsg)
 private:
  inline void set_has_breakpoint();
  inline void clear_has_breakpoint();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::debugservermessages::LineInfo* breakpoint_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo > vars_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage_BPHitMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage_StackTraceInfoMsg : public ::google::protobuf::Message {
 public:
  ServerToClientMessage_StackTraceInfoMsg();
  virtual ~ServerToClientMessage_StackTraceInfoMsg();
  
  ServerToClientMessage_StackTraceInfoMsg(const ServerToClientMessage_StackTraceInfoMsg& from);
  
  inline ServerToClientMessage_StackTraceInfoMsg& operator=(const ServerToClientMessage_StackTraceInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_StackTraceInfoMsg& default_instance();
  
  void Swap(ServerToClientMessage_StackTraceInfoMsg* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage_StackTraceInfoMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage_StackTraceInfoMsg& from);
  void MergeFrom(const ServerToClientMessage_StackTraceInfoMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .debugservermessages.ServerToClientMessage.StackFrameInfo frames = 1;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 1;
  inline const ::debugservermessages::ServerToClientMessage_StackFrameInfo& frames(int index) const;
  inline ::debugservermessages::ServerToClientMessage_StackFrameInfo* mutable_frames(int index);
  inline ::debugservermessages::ServerToClientMessage_StackFrameInfo* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >*
      mutable_frames();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.StackTraceInfoMsg)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo > frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage_StackTraceInfoMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage_MemoryRangeInfoMsg : public ::google::protobuf::Message {
 public:
  ServerToClientMessage_MemoryRangeInfoMsg();
  virtual ~ServerToClientMessage_MemoryRangeInfoMsg();
  
  ServerToClientMessage_MemoryRangeInfoMsg(const ServerToClientMessage_MemoryRangeInfoMsg& from);
  
  inline ServerToClientMessage_MemoryRangeInfoMsg& operator=(const ServerToClientMessage_MemoryRangeInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_MemoryRangeInfoMsg& default_instance();
  
  void Swap(ServerToClientMessage_MemoryRangeInfoMsg* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage_MemoryRangeInfoMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage_MemoryRangeInfoMsg& from);
  void MergeFrom(const ServerToClientMessage_MemoryRangeInfoMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes buf = 1;
  inline bool has_buf() const;
  inline void clear_buf();
  static const int kBufFieldNumber = 1;
  inline const ::std::string& buf() const;
  inline void set_buf(const ::std::string& value);
  inline void set_buf(const char* value);
  inline void set_buf(const void* value, size_t size);
  inline ::std::string* mutable_buf();
  inline ::std::string* release_buf();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg)
 private:
  inline void set_has_buf();
  inline void clear_has_buf();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* buf_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage_MemoryRangeInfoMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClientMessage : public ::google::protobuf::Message {
 public:
  ServerToClientMessage();
  virtual ~ServerToClientMessage();
  
  ServerToClientMessage(const ServerToClientMessage& from);
  
  inline ServerToClientMessage& operator=(const ServerToClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage& default_instance();
  
  void Swap(ServerToClientMessage* other);
  
  // implements Message ----------------------------------------------
  
  ServerToClientMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClientMessage& from);
  void MergeFrom(const ServerToClientMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ServerToClientMessage_CmdErrorMsg CmdErrorMsg;
  typedef ServerToClientMessage_StartSessionAckMsg StartSessionAckMsg;
  typedef ServerToClientMessage_VarInfo VarInfo;
  typedef ServerToClientMessage_StackFrameInfo StackFrameInfo;
  typedef ServerToClientMessage_BPHitMsg BPHitMsg;
  typedef ServerToClientMessage_StackTraceInfoMsg StackTraceInfoMsg;
  typedef ServerToClientMessage_MemoryRangeInfoMsg MemoryRangeInfoMsg;
  
  typedef ServerToClientMessage_Type Type;
  static const Type CMD_ERROR = ServerToClientMessage_Type_CMD_ERROR;
  static const Type START_SESSION_ACK = ServerToClientMessage_Type_START_SESSION_ACK;
  static const Type BP_HIT = ServerToClientMessage_Type_BP_HIT;
  static const Type STACK_TRACE_INFO = ServerToClientMessage_Type_STACK_TRACE_INFO;
  static const Type MEMORY_RANGE_INFO = ServerToClientMessage_Type_MEMORY_RANGE_INFO;
  static inline bool Type_IsValid(int value) {
    return ServerToClientMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ServerToClientMessage_Type_Type_MIN;
  static const Type Type_MAX =
    ServerToClientMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ServerToClientMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ServerToClientMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ServerToClientMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ServerToClientMessage_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .debugservermessages.ServerToClientMessage.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::debugservermessages::ServerToClientMessage_Type type() const;
  inline void set_type(::debugservermessages::ServerToClientMessage_Type value);
  
  // optional .debugservermessages.ServerToClientMessage.CmdErrorMsg cmd_error_msg = 21;
  inline bool has_cmd_error_msg() const;
  inline void clear_cmd_error_msg();
  static const int kCmdErrorMsgFieldNumber = 21;
  inline const ::debugservermessages::ServerToClientMessage_CmdErrorMsg& cmd_error_msg() const;
  inline ::debugservermessages::ServerToClientMessage_CmdErrorMsg* mutable_cmd_error_msg();
  inline ::debugservermessages::ServerToClientMessage_CmdErrorMsg* release_cmd_error_msg();
  
  // optional .debugservermessages.ServerToClientMessage.StartSessionAckMsg start_session_ack_msg = 22;
  inline bool has_start_session_ack_msg() const;
  inline void clear_start_session_ack_msg();
  static const int kStartSessionAckMsgFieldNumber = 22;
  inline const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg& start_session_ack_msg() const;
  inline ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* mutable_start_session_ack_msg();
  inline ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* release_start_session_ack_msg();
  
  // optional .debugservermessages.ServerToClientMessage.BPHitMsg bphit_msg = 31;
  inline bool has_bphit_msg() const;
  inline void clear_bphit_msg();
  static const int kBphitMsgFieldNumber = 31;
  inline const ::debugservermessages::ServerToClientMessage_BPHitMsg& bphit_msg() const;
  inline ::debugservermessages::ServerToClientMessage_BPHitMsg* mutable_bphit_msg();
  inline ::debugservermessages::ServerToClientMessage_BPHitMsg* release_bphit_msg();
  
  // optional .debugservermessages.ServerToClientMessage.StackTraceInfoMsg stack_trace_info_msg = 41;
  inline bool has_stack_trace_info_msg() const;
  inline void clear_stack_trace_info_msg();
  static const int kStackTraceInfoMsgFieldNumber = 41;
  inline const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg& stack_trace_info_msg() const;
  inline ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* mutable_stack_trace_info_msg();
  inline ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* release_stack_trace_info_msg();
  
  // optional .debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg memory_range_info_msg = 51;
  inline bool has_memory_range_info_msg() const;
  inline void clear_memory_range_info_msg();
  static const int kMemoryRangeInfoMsgFieldNumber = 51;
  inline const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg& memory_range_info_msg() const;
  inline ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* mutable_memory_range_info_msg();
  inline ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* release_memory_range_info_msg();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cmd_error_msg();
  inline void clear_has_cmd_error_msg();
  inline void set_has_start_session_ack_msg();
  inline void clear_has_start_session_ack_msg();
  inline void set_has_bphit_msg();
  inline void clear_has_bphit_msg();
  inline void set_has_stack_trace_info_msg();
  inline void clear_has_stack_trace_info_msg();
  inline void set_has_memory_range_info_msg();
  inline void clear_has_memory_range_info_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::debugservermessages::ServerToClientMessage_CmdErrorMsg* cmd_error_msg_;
  ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* start_session_ack_msg_;
  ::debugservermessages::ServerToClientMessage_BPHitMsg* bphit_msg_;
  ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* stack_trace_info_msg_;
  ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* memory_range_info_msg_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static ServerToClientMessage* default_instance_;
};
// -------------------------------------------------------------------

class LineInfo : public ::google::protobuf::Message {
 public:
  LineInfo();
  virtual ~LineInfo();
  
  LineInfo(const LineInfo& from);
  
  inline LineInfo& operator=(const LineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LineInfo& default_instance();
  
  void Swap(LineInfo* other);
  
  // implements Message ----------------------------------------------
  
  LineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineInfo& from);
  void MergeFrom(const LineInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file = 1;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  
  // required uint32 lineno = 2;
  inline bool has_lineno() const;
  inline void clear_lineno();
  static const int kLinenoFieldNumber = 2;
  inline ::google::protobuf::uint32 lineno() const;
  inline void set_lineno(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:debugservermessages.LineInfo)
 private:
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_lineno();
  inline void clear_has_lineno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* file_;
  ::google::protobuf::uint32 lineno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static LineInfo* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeDescriptor : public ::google::protobuf::Message {
 public:
  VarTypeDescriptor();
  virtual ~VarTypeDescriptor();
  
  VarTypeDescriptor(const VarTypeDescriptor& from);
  
  inline VarTypeDescriptor& operator=(const VarTypeDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeDescriptor& default_instance();
  
  void Swap(VarTypeDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeDescriptor& from);
  void MergeFrom(const VarTypeDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VarTypeDescriptor_Tag Tag;
  static const Tag BASIC = VarTypeDescriptor_Tag_BASIC;
  static const Tag POINTER = VarTypeDescriptor_Tag_POINTER;
  static const Tag ARRAY = VarTypeDescriptor_Tag_ARRAY;
  static const Tag VECTOR = VarTypeDescriptor_Tag_VECTOR;
  static const Tag TYPEDEF = VarTypeDescriptor_Tag_TYPEDEF;
  static const Tag ENUM = VarTypeDescriptor_Tag_ENUM;
  static const Tag STRUCT = VarTypeDescriptor_Tag_STRUCT;
  static const Tag UNKNOWN = VarTypeDescriptor_Tag_UNKNOWN;
  static inline bool Tag_IsValid(int value) {
    return VarTypeDescriptor_Tag_IsValid(value);
  }
  static const Tag Tag_MIN =
    VarTypeDescriptor_Tag_Tag_MIN;
  static const Tag Tag_MAX =
    VarTypeDescriptor_Tag_Tag_MAX;
  static const int Tag_ARRAYSIZE =
    VarTypeDescriptor_Tag_Tag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Tag_descriptor() {
    return VarTypeDescriptor_Tag_descriptor();
  }
  static inline const ::std::string& Tag_Name(Tag value) {
    return VarTypeDescriptor_Tag_Name(value);
  }
  static inline bool Tag_Parse(const ::std::string& name,
      Tag* value) {
    return VarTypeDescriptor_Tag_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .debugservermessages.VarTypeDescriptor.Tag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline ::debugservermessages::VarTypeDescriptor_Tag tag() const;
  inline void set_tag(::debugservermessages::VarTypeDescriptor_Tag value);
  
  // optional .debugservermessages.VarTypeBasic type_basic = 11;
  inline bool has_type_basic() const;
  inline void clear_type_basic();
  static const int kTypeBasicFieldNumber = 11;
  inline const ::debugservermessages::VarTypeBasic& type_basic() const;
  inline ::debugservermessages::VarTypeBasic* mutable_type_basic();
  inline ::debugservermessages::VarTypeBasic* release_type_basic();
  
  // optional .debugservermessages.VarTypePointer type_pointer = 12;
  inline bool has_type_pointer() const;
  inline void clear_type_pointer();
  static const int kTypePointerFieldNumber = 12;
  inline const ::debugservermessages::VarTypePointer& type_pointer() const;
  inline ::debugservermessages::VarTypePointer* mutable_type_pointer();
  inline ::debugservermessages::VarTypePointer* release_type_pointer();
  
  // optional .debugservermessages.VarTypeArray type_array = 13;
  inline bool has_type_array() const;
  inline void clear_type_array();
  static const int kTypeArrayFieldNumber = 13;
  inline const ::debugservermessages::VarTypeArray& type_array() const;
  inline ::debugservermessages::VarTypeArray* mutable_type_array();
  inline ::debugservermessages::VarTypeArray* release_type_array();
  
  // optional .debugservermessages.VarTypeVector type_vector = 14;
  inline bool has_type_vector() const;
  inline void clear_type_vector();
  static const int kTypeVectorFieldNumber = 14;
  inline const ::debugservermessages::VarTypeVector& type_vector() const;
  inline ::debugservermessages::VarTypeVector* mutable_type_vector();
  inline ::debugservermessages::VarTypeVector* release_type_vector();
  
  // optional .debugservermessages.VarTypeTypedef type_typedef = 15;
  inline bool has_type_typedef() const;
  inline void clear_type_typedef();
  static const int kTypeTypedefFieldNumber = 15;
  inline const ::debugservermessages::VarTypeTypedef& type_typedef() const;
  inline ::debugservermessages::VarTypeTypedef* mutable_type_typedef();
  inline ::debugservermessages::VarTypeTypedef* release_type_typedef();
  
  // optional .debugservermessages.VarTypeEnum type_enum = 16;
  inline bool has_type_enum() const;
  inline void clear_type_enum();
  static const int kTypeEnumFieldNumber = 16;
  inline const ::debugservermessages::VarTypeEnum& type_enum() const;
  inline ::debugservermessages::VarTypeEnum* mutable_type_enum();
  inline ::debugservermessages::VarTypeEnum* release_type_enum();
  
  // optional .debugservermessages.VarTypeStruct type_struct = 17;
  inline bool has_type_struct() const;
  inline void clear_type_struct();
  static const int kTypeStructFieldNumber = 17;
  inline const ::debugservermessages::VarTypeStruct& type_struct() const;
  inline ::debugservermessages::VarTypeStruct* mutable_type_struct();
  inline ::debugservermessages::VarTypeStruct* release_type_struct();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeDescriptor)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_type_basic();
  inline void clear_has_type_basic();
  inline void set_has_type_pointer();
  inline void clear_has_type_pointer();
  inline void set_has_type_array();
  inline void clear_has_type_array();
  inline void set_has_type_vector();
  inline void clear_has_type_vector();
  inline void set_has_type_typedef();
  inline void clear_has_type_typedef();
  inline void set_has_type_enum();
  inline void clear_has_type_enum();
  inline void set_has_type_struct();
  inline void clear_has_type_struct();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::debugservermessages::VarTypeBasic* type_basic_;
  ::debugservermessages::VarTypePointer* type_pointer_;
  ::debugservermessages::VarTypeArray* type_array_;
  ::debugservermessages::VarTypeVector* type_vector_;
  ::debugservermessages::VarTypeTypedef* type_typedef_;
  ::debugservermessages::VarTypeEnum* type_enum_;
  ::debugservermessages::VarTypeStruct* type_struct_;
  int tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeBasic : public ::google::protobuf::Message {
 public:
  VarTypeBasic();
  virtual ~VarTypeBasic();
  
  VarTypeBasic(const VarTypeBasic& from);
  
  inline VarTypeBasic& operator=(const VarTypeBasic& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeBasic& default_instance();
  
  void Swap(VarTypeBasic* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeBasic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeBasic& from);
  void MergeFrom(const VarTypeBasic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VarTypeBasic_Tag Tag;
  static const Tag BOOLEAN = VarTypeBasic_Tag_BOOLEAN;
  static const Tag FLOAT = VarTypeBasic_Tag_FLOAT;
  static const Tag SIGNED = VarTypeBasic_Tag_SIGNED;
  static const Tag SIGNED_CHAR = VarTypeBasic_Tag_SIGNED_CHAR;
  static const Tag UNSIGNED = VarTypeBasic_Tag_UNSIGNED;
  static const Tag UNSIGNED_CHAR = VarTypeBasic_Tag_UNSIGNED_CHAR;
  static const Tag UNKNOWN = VarTypeBasic_Tag_UNKNOWN;
  static inline bool Tag_IsValid(int value) {
    return VarTypeBasic_Tag_IsValid(value);
  }
  static const Tag Tag_MIN =
    VarTypeBasic_Tag_Tag_MIN;
  static const Tag Tag_MAX =
    VarTypeBasic_Tag_Tag_MAX;
  static const int Tag_ARRAYSIZE =
    VarTypeBasic_Tag_Tag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Tag_descriptor() {
    return VarTypeBasic_Tag_descriptor();
  }
  static inline const ::std::string& Tag_Name(Tag value) {
    return VarTypeBasic_Tag_Name(value);
  }
  static inline bool Tag_Parse(const ::std::string& name,
      Tag* value) {
    return VarTypeBasic_Tag_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .debugservermessages.VarTypeBasic.Tag tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline ::debugservermessages::VarTypeBasic_Tag tag() const;
  inline void set_tag(::debugservermessages::VarTypeBasic_Tag value);
  
  // required uint64 size_nbits = 2;
  inline bool has_size_nbits() const;
  inline void clear_size_nbits();
  static const int kSizeNbitsFieldNumber = 2;
  inline ::google::protobuf::uint64 size_nbits() const;
  inline void set_size_nbits(::google::protobuf::uint64 value);
  
  // required string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeBasic)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_size_nbits();
  inline void clear_has_size_nbits();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 size_nbits_;
  ::std::string* name_;
  int tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeBasic* default_instance_;
};
// -------------------------------------------------------------------

class VarTypePointer : public ::google::protobuf::Message {
 public:
  VarTypePointer();
  virtual ~VarTypePointer();
  
  VarTypePointer(const VarTypePointer& from);
  
  inline VarTypePointer& operator=(const VarTypePointer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypePointer& default_instance();
  
  void Swap(VarTypePointer* other);
  
  // implements Message ----------------------------------------------
  
  VarTypePointer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypePointer& from);
  void MergeFrom(const VarTypePointer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .debugservermessages.VarTypeDescriptor pointee = 1;
  inline bool has_pointee() const;
  inline void clear_pointee();
  static const int kPointeeFieldNumber = 1;
  inline const ::debugservermessages::VarTypeDescriptor& pointee() const;
  inline ::debugservermessages::VarTypeDescriptor* mutable_pointee();
  inline ::debugservermessages::VarTypeDescriptor* release_pointee();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypePointer)
 private:
  inline void set_has_pointee();
  inline void clear_has_pointee();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::debugservermessages::VarTypeDescriptor* pointee_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypePointer* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeArray : public ::google::protobuf::Message {
 public:
  VarTypeArray();
  virtual ~VarTypeArray();
  
  VarTypeArray(const VarTypeArray& from);
  
  inline VarTypeArray& operator=(const VarTypeArray& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeArray& default_instance();
  
  void Swap(VarTypeArray* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeArray& from);
  void MergeFrom(const VarTypeArray& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .debugservermessages.VarTypeDescriptor element = 1;
  inline bool has_element() const;
  inline void clear_element();
  static const int kElementFieldNumber = 1;
  inline const ::debugservermessages::VarTypeDescriptor& element() const;
  inline ::debugservermessages::VarTypeDescriptor* mutable_element();
  inline ::debugservermessages::VarTypeDescriptor* release_element();
  
  // repeated uint64 dimensions = 2;
  inline int dimensions_size() const;
  inline void clear_dimensions();
  static const int kDimensionsFieldNumber = 2;
  inline ::google::protobuf::uint64 dimensions(int index) const;
  inline void set_dimensions(int index, ::google::protobuf::uint64 value);
  inline void add_dimensions(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      dimensions() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_dimensions();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeArray)
 private:
  inline void set_has_element();
  inline void clear_has_element();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::debugservermessages::VarTypeDescriptor* element_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > dimensions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeArray* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeEnum_EnumEntry : public ::google::protobuf::Message {
 public:
  VarTypeEnum_EnumEntry();
  virtual ~VarTypeEnum_EnumEntry();
  
  VarTypeEnum_EnumEntry(const VarTypeEnum_EnumEntry& from);
  
  inline VarTypeEnum_EnumEntry& operator=(const VarTypeEnum_EnumEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeEnum_EnumEntry& default_instance();
  
  void Swap(VarTypeEnum_EnumEntry* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeEnum_EnumEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeEnum_EnumEntry& from);
  void MergeFrom(const VarTypeEnum_EnumEntry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required uint64 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint64 value() const;
  inline void set_value(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeEnum.EnumEntry)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint64 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeEnum_EnumEntry* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeEnum : public ::google::protobuf::Message {
 public:
  VarTypeEnum();
  virtual ~VarTypeEnum();
  
  VarTypeEnum(const VarTypeEnum& from);
  
  inline VarTypeEnum& operator=(const VarTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeEnum& default_instance();
  
  void Swap(VarTypeEnum* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeEnum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeEnum& from);
  void MergeFrom(const VarTypeEnum& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VarTypeEnum_EnumEntry EnumEntry;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .debugservermessages.VarTypeEnum.EnumEntry entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::debugservermessages::VarTypeEnum_EnumEntry& entries(int index) const;
  inline ::debugservermessages::VarTypeEnum_EnumEntry* mutable_entries(int index);
  inline ::debugservermessages::VarTypeEnum_EnumEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >*
      mutable_entries();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeEnum)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry > entries_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeEnum* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeStruct_StructMember : public ::google::protobuf::Message {
 public:
  VarTypeStruct_StructMember();
  virtual ~VarTypeStruct_StructMember();
  
  VarTypeStruct_StructMember(const VarTypeStruct_StructMember& from);
  
  inline VarTypeStruct_StructMember& operator=(const VarTypeStruct_StructMember& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeStruct_StructMember& default_instance();
  
  void Swap(VarTypeStruct_StructMember* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeStruct_StructMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeStruct_StructMember& from);
  void MergeFrom(const VarTypeStruct_StructMember& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required uint64 size_nbits = 2;
  inline bool has_size_nbits() const;
  inline void clear_size_nbits();
  static const int kSizeNbitsFieldNumber = 2;
  inline ::google::protobuf::uint64 size_nbits() const;
  inline void set_size_nbits(::google::protobuf::uint64 value);
  
  // required uint64 align_nbits = 3;
  inline bool has_align_nbits() const;
  inline void clear_align_nbits();
  static const int kAlignNbitsFieldNumber = 3;
  inline ::google::protobuf::uint64 align_nbits() const;
  inline void set_align_nbits(::google::protobuf::uint64 value);
  
  // required uint64 offset_nbits = 4;
  inline bool has_offset_nbits() const;
  inline void clear_offset_nbits();
  static const int kOffsetNbitsFieldNumber = 4;
  inline ::google::protobuf::uint64 offset_nbits() const;
  inline void set_offset_nbits(::google::protobuf::uint64 value);
  
  // required .debugservermessages.VarTypeDescriptor type = 20;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 20;
  inline const ::debugservermessages::VarTypeDescriptor& type() const;
  inline ::debugservermessages::VarTypeDescriptor* mutable_type();
  inline ::debugservermessages::VarTypeDescriptor* release_type();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeStruct.StructMember)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_size_nbits();
  inline void clear_has_size_nbits();
  inline void set_has_align_nbits();
  inline void clear_has_align_nbits();
  inline void set_has_offset_nbits();
  inline void clear_has_offset_nbits();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint64 size_nbits_;
  ::google::protobuf::uint64 align_nbits_;
  ::google::protobuf::uint64 offset_nbits_;
  ::debugservermessages::VarTypeDescriptor* type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeStruct_StructMember* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeStruct : public ::google::protobuf::Message {
 public:
  VarTypeStruct();
  virtual ~VarTypeStruct();
  
  VarTypeStruct(const VarTypeStruct& from);
  
  inline VarTypeStruct& operator=(const VarTypeStruct& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeStruct& default_instance();
  
  void Swap(VarTypeStruct* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeStruct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeStruct& from);
  void MergeFrom(const VarTypeStruct& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VarTypeStruct_StructMember StructMember;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .debugservermessages.VarTypeStruct.StructMember members = 2;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::debugservermessages::VarTypeStruct_StructMember& members(int index) const;
  inline ::debugservermessages::VarTypeStruct_StructMember* mutable_members(int index);
  inline ::debugservermessages::VarTypeStruct_StructMember* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >*
      mutable_members();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeStruct)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember > members_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeStruct* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeVector : public ::google::protobuf::Message {
 public:
  VarTypeVector();
  virtual ~VarTypeVector();
  
  VarTypeVector(const VarTypeVector& from);
  
  inline VarTypeVector& operator=(const VarTypeVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeVector& default_instance();
  
  void Swap(VarTypeVector* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeVector& from);
  void MergeFrom(const VarTypeVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeVector)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeVector* default_instance_;
};
// -------------------------------------------------------------------

class VarTypeTypedef : public ::google::protobuf::Message {
 public:
  VarTypeTypedef();
  virtual ~VarTypeTypedef();
  
  VarTypeTypedef(const VarTypeTypedef& from);
  
  inline VarTypeTypedef& operator=(const VarTypeTypedef& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeTypedef& default_instance();
  
  void Swap(VarTypeTypedef* other);
  
  // implements Message ----------------------------------------------
  
  VarTypeTypedef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarTypeTypedef& from);
  void MergeFrom(const VarTypeTypedef& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .debugservermessages.VarTypeDescriptor original_type = 2;
  inline bool has_original_type() const;
  inline void clear_original_type();
  static const int kOriginalTypeFieldNumber = 2;
  inline const ::debugservermessages::VarTypeDescriptor& original_type() const;
  inline ::debugservermessages::VarTypeDescriptor* mutable_original_type();
  inline ::debugservermessages::VarTypeDescriptor* release_original_type();
  
  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeTypedef)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_original_type();
  inline void clear_has_original_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::debugservermessages::VarTypeDescriptor* original_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_debugservermessages_2eproto();
  friend void protobuf_AssignDesc_debugservermessages_2eproto();
  friend void protobuf_ShutdownFile_debugservermessages_2eproto();
  
  void InitAsDefaultInstance();
  static VarTypeTypedef* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientToServerMessage_StartSessionMsg

// required uint32 global_id_x = 1;
inline bool ClientToServerMessage_StartSessionMsg::has_global_id_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage_StartSessionMsg::set_has_global_id_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_has_global_id_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_global_id_x() {
  global_id_x_ = 0u;
  clear_has_global_id_x();
}
inline ::google::protobuf::uint32 ClientToServerMessage_StartSessionMsg::global_id_x() const {
  return global_id_x_;
}
inline void ClientToServerMessage_StartSessionMsg::set_global_id_x(::google::protobuf::uint32 value) {
  set_has_global_id_x();
  global_id_x_ = value;
}

// required uint32 global_id_y = 2;
inline bool ClientToServerMessage_StartSessionMsg::has_global_id_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage_StartSessionMsg::set_has_global_id_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_has_global_id_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_global_id_y() {
  global_id_y_ = 0u;
  clear_has_global_id_y();
}
inline ::google::protobuf::uint32 ClientToServerMessage_StartSessionMsg::global_id_y() const {
  return global_id_y_;
}
inline void ClientToServerMessage_StartSessionMsg::set_global_id_y(::google::protobuf::uint32 value) {
  set_has_global_id_y();
  global_id_y_ = value;
}

// required uint32 global_id_z = 3;
inline bool ClientToServerMessage_StartSessionMsg::has_global_id_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerMessage_StartSessionMsg::set_has_global_id_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_has_global_id_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_global_id_z() {
  global_id_z_ = 0u;
  clear_has_global_id_z();
}
inline ::google::protobuf::uint32 ClientToServerMessage_StartSessionMsg::global_id_z() const {
  return global_id_z_;
}
inline void ClientToServerMessage_StartSessionMsg::set_global_id_z(::google::protobuf::uint32 value) {
  set_has_global_id_z();
  global_id_z_ = value;
}

// -------------------------------------------------------------------

// ClientToServerMessage_RunMsg

// required string info = 1;
inline bool ClientToServerMessage_RunMsg::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage_RunMsg::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage_RunMsg::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage_RunMsg::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& ClientToServerMessage_RunMsg::info() const {
  return *info_;
}
inline void ClientToServerMessage_RunMsg::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ClientToServerMessage_RunMsg::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ClientToServerMessage_RunMsg::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerMessage_RunMsg::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* ClientToServerMessage_RunMsg::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .debugservermessages.LineInfo breakpoints = 2;
inline int ClientToServerMessage_RunMsg::breakpoints_size() const {
  return breakpoints_.size();
}
inline void ClientToServerMessage_RunMsg::clear_breakpoints() {
  breakpoints_.Clear();
}
inline const ::debugservermessages::LineInfo& ClientToServerMessage_RunMsg::breakpoints(int index) const {
  return breakpoints_.Get(index);
}
inline ::debugservermessages::LineInfo* ClientToServerMessage_RunMsg::mutable_breakpoints(int index) {
  return breakpoints_.Mutable(index);
}
inline ::debugservermessages::LineInfo* ClientToServerMessage_RunMsg::add_breakpoints() {
  return breakpoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >&
ClientToServerMessage_RunMsg::breakpoints() const {
  return breakpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >*
ClientToServerMessage_RunMsg::mutable_breakpoints() {
  return &breakpoints_;
}

// -------------------------------------------------------------------

// ClientToServerMessage_GetMemoryRangeMsg

// required uint64 start_addr = 1;
inline bool ClientToServerMessage_GetMemoryRangeMsg::has_start_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_has_start_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_has_start_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_start_addr() {
  start_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_start_addr();
}
inline ::google::protobuf::uint64 ClientToServerMessage_GetMemoryRangeMsg::start_addr() const {
  return start_addr_;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_start_addr(::google::protobuf::uint64 value) {
  set_has_start_addr();
  start_addr_ = value;
}

// required uint64 end_addr = 2;
inline bool ClientToServerMessage_GetMemoryRangeMsg::has_end_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_has_end_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_has_end_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_end_addr() {
  end_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_end_addr();
}
inline ::google::protobuf::uint64 ClientToServerMessage_GetMemoryRangeMsg::end_addr() const {
  return end_addr_;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_end_addr(::google::protobuf::uint64 value) {
  set_has_end_addr();
  end_addr_ = value;
}

// -------------------------------------------------------------------

// ClientToServerMessage

// required .debugservermessages.ClientToServerMessage.Type type = 1;
inline bool ClientToServerMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::debugservermessages::ClientToServerMessage_Type ClientToServerMessage::type() const {
  return static_cast< ::debugservermessages::ClientToServerMessage_Type >(type_);
}
inline void ClientToServerMessage::set_type(::debugservermessages::ClientToServerMessage_Type value) {
  GOOGLE_DCHECK(::debugservermessages::ClientToServerMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .debugservermessages.ClientToServerMessage.StartSessionMsg start_session_msg = 20;
inline bool ClientToServerMessage::has_start_session_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage::set_has_start_session_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerMessage::clear_has_start_session_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerMessage::clear_start_session_msg() {
  if (start_session_msg_ != nullptr) start_session_msg_->::debugservermessages::ClientToServerMessage_StartSessionMsg::Clear();
  clear_has_start_session_msg();
}
inline const ::debugservermessages::ClientToServerMessage_StartSessionMsg& ClientToServerMessage::start_session_msg() const {
  return start_session_msg_ != nullptr ? *start_session_msg_ : *default_instance_->start_session_msg_;
}
inline ::debugservermessages::ClientToServerMessage_StartSessionMsg* ClientToServerMessage::mutable_start_session_msg() {
  set_has_start_session_msg();
  if (start_session_msg_ == nullptr) start_session_msg_ = new ::debugservermessages::ClientToServerMessage_StartSessionMsg;
  return start_session_msg_;
}
inline ::debugservermessages::ClientToServerMessage_StartSessionMsg* ClientToServerMessage::release_start_session_msg() {
  clear_has_start_session_msg();
  ::debugservermessages::ClientToServerMessage_StartSessionMsg* temp = start_session_msg_;
  start_session_msg_ = nullptr;
  return temp;
}

// optional .debugservermessages.ClientToServerMessage.RunMsg run_msg = 21;
inline bool ClientToServerMessage::has_run_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerMessage::set_has_run_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToServerMessage::clear_has_run_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToServerMessage::clear_run_msg() {
  if (run_msg_ != nullptr) run_msg_->::debugservermessages::ClientToServerMessage_RunMsg::Clear();
  clear_has_run_msg();
}
inline const ::debugservermessages::ClientToServerMessage_RunMsg& ClientToServerMessage::run_msg() const {
  return run_msg_ != nullptr ? *run_msg_ : *default_instance_->run_msg_;
}
inline ::debugservermessages::ClientToServerMessage_RunMsg* ClientToServerMessage::mutable_run_msg() {
  set_has_run_msg();
  if (run_msg_ == nullptr) run_msg_ = new ::debugservermessages::ClientToServerMessage_RunMsg;
  return run_msg_;
}
inline ::debugservermessages::ClientToServerMessage_RunMsg* ClientToServerMessage::release_run_msg() {
  clear_has_run_msg();
  ::debugservermessages::ClientToServerMessage_RunMsg* temp = run_msg_;
  run_msg_ = nullptr;
  return temp;
}

// optional .debugservermessages.ClientToServerMessage.GetMemoryRangeMsg get_memory_range_msg = 31;
inline bool ClientToServerMessage::has_get_memory_range_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientToServerMessage::set_has_get_memory_range_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientToServerMessage::clear_has_get_memory_range_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientToServerMessage::clear_get_memory_range_msg() {
  if (get_memory_range_msg_ != nullptr) get_memory_range_msg_->::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg::Clear();
  clear_has_get_memory_range_msg();
}
inline const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg& ClientToServerMessage::get_memory_range_msg() const {
  return get_memory_range_msg_ != nullptr ? *get_memory_range_msg_ : *default_instance_->get_memory_range_msg_;
}
inline ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* ClientToServerMessage::mutable_get_memory_range_msg() {
  set_has_get_memory_range_msg();
  if (get_memory_range_msg_ == nullptr) get_memory_range_msg_ = new ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg;
  return get_memory_range_msg_;
}
inline ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* ClientToServerMessage::release_get_memory_range_msg() {
  clear_has_get_memory_range_msg();
  ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* temp = get_memory_range_msg_;
  get_memory_range_msg_ = nullptr;
  return temp;
}

// -------------------------------------------------------------------

// ServerToClientMessage_CmdErrorMsg

// required string description = 1;
inline bool ServerToClientMessage_CmdErrorMsg::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_CmdErrorMsg::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_CmdErrorMsg::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_CmdErrorMsg::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ServerToClientMessage_CmdErrorMsg::description() const {
  return *description_;
}
inline void ServerToClientMessage_CmdErrorMsg::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ServerToClientMessage_CmdErrorMsg::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ServerToClientMessage_CmdErrorMsg::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerToClientMessage_CmdErrorMsg::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ServerToClientMessage_CmdErrorMsg::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServerToClientMessage_StartSessionAckMsg

// required uint32 sizeof_size_t = 1;
inline bool ServerToClientMessage_StartSessionAckMsg::has_sizeof_size_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_StartSessionAckMsg::set_has_sizeof_size_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_StartSessionAckMsg::clear_has_sizeof_size_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_StartSessionAckMsg::clear_sizeof_size_t() {
  sizeof_size_t_ = 0u;
  clear_has_sizeof_size_t();
}
inline ::google::protobuf::uint32 ServerToClientMessage_StartSessionAckMsg::sizeof_size_t() const {
  return sizeof_size_t_;
}
inline void ServerToClientMessage_StartSessionAckMsg::set_sizeof_size_t(::google::protobuf::uint32 value) {
  set_has_sizeof_size_t();
  sizeof_size_t_ = value;
}

// -------------------------------------------------------------------

// ServerToClientMessage_VarInfo

// required string name = 1;
inline bool ServerToClientMessage_VarInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_VarInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_VarInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ServerToClientMessage_VarInfo::name() const {
  return *name_;
}
inline void ServerToClientMessage_VarInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerToClientMessage_VarInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerToClientMessage_VarInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerToClientMessage_VarInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ServerToClientMessage_VarInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool ServerToClientMessage_VarInfo::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerToClientMessage_VarInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerToClientMessage_VarInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ServerToClientMessage_VarInfo::value() const {
  return *value_;
}
inline void ServerToClientMessage_VarInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ServerToClientMessage_VarInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ServerToClientMessage_VarInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerToClientMessage_VarInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ServerToClientMessage_VarInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string type = 3;
inline bool ServerToClientMessage_VarInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerToClientMessage_VarInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerToClientMessage_VarInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ServerToClientMessage_VarInfo::type() const {
  return *type_;
}
inline void ServerToClientMessage_VarInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ServerToClientMessage_VarInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ServerToClientMessage_VarInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerToClientMessage_VarInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ServerToClientMessage_VarInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 address = 4;
inline bool ServerToClientMessage_VarInfo::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerToClientMessage_VarInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerToClientMessage_VarInfo::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 ServerToClientMessage_VarInfo::address() const {
  return address_;
}
inline void ServerToClientMessage_VarInfo::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
}

// required .debugservermessages.VarTypeDescriptor type_descriptor = 5;
inline bool ServerToClientMessage_VarInfo::has_type_descriptor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_type_descriptor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerToClientMessage_VarInfo::clear_has_type_descriptor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerToClientMessage_VarInfo::clear_type_descriptor() {
  if (type_descriptor_ != nullptr) type_descriptor_->::debugservermessages::VarTypeDescriptor::Clear();
  clear_has_type_descriptor();
}
inline const ::debugservermessages::VarTypeDescriptor& ServerToClientMessage_VarInfo::type_descriptor() const {
  return type_descriptor_ != nullptr ? *type_descriptor_ : *default_instance_->type_descriptor_;
}
inline ::debugservermessages::VarTypeDescriptor* ServerToClientMessage_VarInfo::mutable_type_descriptor() {
  set_has_type_descriptor();
  if (type_descriptor_ == nullptr) type_descriptor_ = new ::debugservermessages::VarTypeDescriptor;
  return type_descriptor_;
}
inline ::debugservermessages::VarTypeDescriptor* ServerToClientMessage_VarInfo::release_type_descriptor() {
  clear_has_type_descriptor();
  ::debugservermessages::VarTypeDescriptor* temp = type_descriptor_;
  type_descriptor_ = nullptr;
  return temp;
}

// -------------------------------------------------------------------

// ServerToClientMessage_StackFrameInfo

// required string func_name = 1;
inline bool ServerToClientMessage_StackFrameInfo::has_func_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_StackFrameInfo::set_has_func_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_has_func_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_func_name() {
  if (func_name_ != &::google::protobuf::internal::kEmptyString) {
    func_name_->clear();
  }
  clear_has_func_name();
}
inline const ::std::string& ServerToClientMessage_StackFrameInfo::func_name() const {
  return *func_name_;
}
inline void ServerToClientMessage_StackFrameInfo::set_func_name(const ::std::string& value) {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  func_name_->assign(value);
}
inline void ServerToClientMessage_StackFrameInfo::set_func_name(const char* value) {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  func_name_->assign(value);
}
inline void ServerToClientMessage_StackFrameInfo::set_func_name(const char* value, size_t size) {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  func_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerToClientMessage_StackFrameInfo::mutable_func_name() {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  return func_name_;
}
inline ::std::string* ServerToClientMessage_StackFrameInfo::release_func_name() {
  clear_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = func_name_;
    func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .debugservermessages.LineInfo call_line = 2;
inline bool ServerToClientMessage_StackFrameInfo::has_call_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClientMessage_StackFrameInfo::set_has_call_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_has_call_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_call_line() {
  if (call_line_ != nullptr) call_line_->::debugservermessages::LineInfo::Clear();
  clear_has_call_line();
}
inline const ::debugservermessages::LineInfo& ServerToClientMessage_StackFrameInfo::call_line() const {
  return call_line_ != nullptr ? *call_line_ : *default_instance_->call_line_;
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_StackFrameInfo::mutable_call_line() {
  set_has_call_line();
  if (call_line_ == nullptr) call_line_ = new ::debugservermessages::LineInfo;
  return call_line_;
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_StackFrameInfo::release_call_line() {
  clear_has_call_line();
  ::debugservermessages::LineInfo* temp = call_line_;
  call_line_ = nullptr;
  return temp;
}

// repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 3;
inline int ServerToClientMessage_StackFrameInfo::vars_size() const {
  return vars_.size();
}
inline void ServerToClientMessage_StackFrameInfo::clear_vars() {
  vars_.Clear();
}
inline const ::debugservermessages::ServerToClientMessage_VarInfo& ServerToClientMessage_StackFrameInfo::vars(int index) const {
  return vars_.Get(index);
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_StackFrameInfo::mutable_vars(int index) {
  return vars_.Mutable(index);
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_StackFrameInfo::add_vars() {
  return vars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
ServerToClientMessage_StackFrameInfo::vars() const {
  return vars_;
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
ServerToClientMessage_StackFrameInfo::mutable_vars() {
  return &vars_;
}

// -------------------------------------------------------------------

// ServerToClientMessage_BPHitMsg

// required .debugservermessages.LineInfo breakpoint = 1;
inline bool ServerToClientMessage_BPHitMsg::has_breakpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_BPHitMsg::set_has_breakpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_BPHitMsg::clear_has_breakpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_BPHitMsg::clear_breakpoint() {
  if (breakpoint_ != nullptr) breakpoint_->::debugservermessages::LineInfo::Clear();
  clear_has_breakpoint();
}
inline const ::debugservermessages::LineInfo& ServerToClientMessage_BPHitMsg::breakpoint() const {
  return breakpoint_ != nullptr ? *breakpoint_ : *default_instance_->breakpoint_;
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_BPHitMsg::mutable_breakpoint() {
  set_has_breakpoint();
  if (breakpoint_ == nullptr) breakpoint_ = new ::debugservermessages::LineInfo;
  return breakpoint_;
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_BPHitMsg::release_breakpoint() {
  clear_has_breakpoint();
  ::debugservermessages::LineInfo* temp = breakpoint_;
  breakpoint_ = nullptr;
  return temp;
}

// repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 2;
inline int ServerToClientMessage_BPHitMsg::vars_size() const {
  return vars_.size();
}
inline void ServerToClientMessage_BPHitMsg::clear_vars() {
  vars_.Clear();
}
inline const ::debugservermessages::ServerToClientMessage_VarInfo& ServerToClientMessage_BPHitMsg::vars(int index) const {
  return vars_.Get(index);
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_BPHitMsg::mutable_vars(int index) {
  return vars_.Mutable(index);
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_BPHitMsg::add_vars() {
  return vars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
ServerToClientMessage_BPHitMsg::vars() const {
  return vars_;
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
ServerToClientMessage_BPHitMsg::mutable_vars() {
  return &vars_;
}

// -------------------------------------------------------------------

// ServerToClientMessage_StackTraceInfoMsg

// repeated .debugservermessages.ServerToClientMessage.StackFrameInfo frames = 1;
inline int ServerToClientMessage_StackTraceInfoMsg::frames_size() const {
  return frames_.size();
}
inline void ServerToClientMessage_StackTraceInfoMsg::clear_frames() {
  frames_.Clear();
}
inline const ::debugservermessages::ServerToClientMessage_StackFrameInfo& ServerToClientMessage_StackTraceInfoMsg::frames(int index) const {
  return frames_.Get(index);
}
inline ::debugservermessages::ServerToClientMessage_StackFrameInfo* ServerToClientMessage_StackTraceInfoMsg::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::debugservermessages::ServerToClientMessage_StackFrameInfo* ServerToClientMessage_StackTraceInfoMsg::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >&
ServerToClientMessage_StackTraceInfoMsg::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >*
ServerToClientMessage_StackTraceInfoMsg::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// ServerToClientMessage_MemoryRangeInfoMsg

// required bytes buf = 1;
inline bool ServerToClientMessage_MemoryRangeInfoMsg::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_has_buf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::clear_has_buf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::clear_buf() {
  if (buf_ != &::google::protobuf::internal::kEmptyString) {
    buf_->clear();
  }
  clear_has_buf();
}
inline const ::std::string& ServerToClientMessage_MemoryRangeInfoMsg::buf() const {
  return *buf_;
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_buf(const ::std::string& value) {
  set_has_buf();
  if (buf_ == &::google::protobuf::internal::kEmptyString) {
    buf_ = new ::std::string;
  }
  buf_->assign(value);
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_buf(const char* value) {
  set_has_buf();
  if (buf_ == &::google::protobuf::internal::kEmptyString) {
    buf_ = new ::std::string;
  }
  buf_->assign(value);
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_buf(const void* value, size_t size) {
  set_has_buf();
  if (buf_ == &::google::protobuf::internal::kEmptyString) {
    buf_ = new ::std::string;
  }
  buf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerToClientMessage_MemoryRangeInfoMsg::mutable_buf() {
  set_has_buf();
  if (buf_ == &::google::protobuf::internal::kEmptyString) {
    buf_ = new ::std::string;
  }
  return buf_;
}
inline ::std::string* ServerToClientMessage_MemoryRangeInfoMsg::release_buf() {
  clear_has_buf();
  if (buf_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = buf_;
    buf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServerToClientMessage

// required .debugservermessages.ServerToClientMessage.Type type = 1;
inline bool ServerToClientMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::debugservermessages::ServerToClientMessage_Type ServerToClientMessage::type() const {
  return static_cast< ::debugservermessages::ServerToClientMessage_Type >(type_);
}
inline void ServerToClientMessage::set_type(::debugservermessages::ServerToClientMessage_Type value) {
  GOOGLE_DCHECK(::debugservermessages::ServerToClientMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .debugservermessages.ServerToClientMessage.CmdErrorMsg cmd_error_msg = 21;
inline bool ServerToClientMessage::has_cmd_error_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClientMessage::set_has_cmd_error_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerToClientMessage::clear_has_cmd_error_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerToClientMessage::clear_cmd_error_msg() {
  if (cmd_error_msg_ != nullptr) cmd_error_msg_->::debugservermessages::ServerToClientMessage_CmdErrorMsg::Clear();
  clear_has_cmd_error_msg();
}
inline const ::debugservermessages::ServerToClientMessage_CmdErrorMsg& ServerToClientMessage::cmd_error_msg() const {
  return cmd_error_msg_ != nullptr ? *cmd_error_msg_ : *default_instance_->cmd_error_msg_;
}
inline ::debugservermessages::ServerToClientMessage_CmdErrorMsg* ServerToClientMessage::mutable_cmd_error_msg() {
  set_has_cmd_error_msg();
  if (cmd_error_msg_ == nullptr) cmd_error_msg_ = new ::debugservermessages::ServerToClientMessage_CmdErrorMsg;
  return cmd_error_msg_;
}
inline ::debugservermessages::ServerToClientMessage_CmdErrorMsg* ServerToClientMessage::release_cmd_error_msg() {
  clear_has_cmd_error_msg();
  ::debugservermessages::ServerToClientMessage_CmdErrorMsg* temp = cmd_error_msg_;
  cmd_error_msg_ = nullptr;
  return temp;
}

// optional .debugservermessages.ServerToClientMessage.StartSessionAckMsg start_session_ack_msg = 22;
inline bool ServerToClientMessage::has_start_session_ack_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerToClientMessage::set_has_start_session_ack_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerToClientMessage::clear_has_start_session_ack_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerToClientMessage::clear_start_session_ack_msg() {
  if (start_session_ack_msg_ != nullptr) start_session_ack_msg_->::debugservermessages::ServerToClientMessage_StartSessionAckMsg::Clear();
  clear_has_start_session_ack_msg();
}
inline const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg& ServerToClientMessage::start_session_ack_msg() const {
  return start_session_ack_msg_ != nullptr ? *start_session_ack_msg_ : *default_instance_->start_session_ack_msg_;
}
inline ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* ServerToClientMessage::mutable_start_session_ack_msg() {
  set_has_start_session_ack_msg();
  if (start_session_ack_msg_ == nullptr) start_session_ack_msg_ = new ::debugservermessages::ServerToClientMessage_StartSessionAckMsg;
  return start_session_ack_msg_;
}
inline ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* ServerToClientMessage::release_start_session_ack_msg() {
  clear_has_start_session_ack_msg();
  ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* temp = start_session_ack_msg_;
  start_session_ack_msg_ = nullptr;
  return temp;
}

// optional .debugservermessages.ServerToClientMessage.BPHitMsg bphit_msg = 31;
inline bool ServerToClientMessage::has_bphit_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerToClientMessage::set_has_bphit_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerToClientMessage::clear_has_bphit_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerToClientMessage::clear_bphit_msg() {
  if (bphit_msg_ != nullptr) bphit_msg_->::debugservermessages::ServerToClientMessage_BPHitMsg::Clear();
  clear_has_bphit_msg();
}
inline const ::debugservermessages::ServerToClientMessage_BPHitMsg& ServerToClientMessage::bphit_msg() const {
  return bphit_msg_ != nullptr ? *bphit_msg_ : *default_instance_->bphit_msg_;
}
inline ::debugservermessages::ServerToClientMessage_BPHitMsg* ServerToClientMessage::mutable_bphit_msg() {
  set_has_bphit_msg();
  if (bphit_msg_ == nullptr) bphit_msg_ = new ::debugservermessages::ServerToClientMessage_BPHitMsg;
  return bphit_msg_;
}
inline ::debugservermessages::ServerToClientMessage_BPHitMsg* ServerToClientMessage::release_bphit_msg() {
  clear_has_bphit_msg();
  ::debugservermessages::ServerToClientMessage_BPHitMsg* temp = bphit_msg_;
  bphit_msg_ = nullptr;
  return temp;
}

// optional .debugservermessages.ServerToClientMessage.StackTraceInfoMsg stack_trace_info_msg = 41;
inline bool ServerToClientMessage::has_stack_trace_info_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerToClientMessage::set_has_stack_trace_info_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerToClientMessage::clear_has_stack_trace_info_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerToClientMessage::clear_stack_trace_info_msg() {
  if (stack_trace_info_msg_ != nullptr) stack_trace_info_msg_->::debugservermessages::ServerToClientMessage_StackTraceInfoMsg::Clear();
  clear_has_stack_trace_info_msg();
}
inline const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg& ServerToClientMessage::stack_trace_info_msg() const {
  return stack_trace_info_msg_ != nullptr ? *stack_trace_info_msg_ : *default_instance_->stack_trace_info_msg_;
}
inline ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* ServerToClientMessage::mutable_stack_trace_info_msg() {
  set_has_stack_trace_info_msg();
  if (stack_trace_info_msg_ == nullptr) stack_trace_info_msg_ = new ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg;
  return stack_trace_info_msg_;
}
inline ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* ServerToClientMessage::release_stack_trace_info_msg() {
  clear_has_stack_trace_info_msg();
  ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* temp = stack_trace_info_msg_;
  stack_trace_info_msg_ = nullptr;
  return temp;
}

// optional .debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg memory_range_info_msg = 51;
inline bool ServerToClientMessage::has_memory_range_info_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerToClientMessage::set_has_memory_range_info_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerToClientMessage::clear_has_memory_range_info_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerToClientMessage::clear_memory_range_info_msg() {
  if (memory_range_info_msg_ != nullptr) memory_range_info_msg_->::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg::Clear();
  clear_has_memory_range_info_msg();
}
inline const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg& ServerToClientMessage::memory_range_info_msg() const {
  return memory_range_info_msg_ != nullptr ? *memory_range_info_msg_ : *default_instance_->memory_range_info_msg_;
}
inline ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* ServerToClientMessage::mutable_memory_range_info_msg() {
  set_has_memory_range_info_msg();
  if (memory_range_info_msg_ == nullptr) memory_range_info_msg_ = new ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg;
  return memory_range_info_msg_;
}
inline ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* ServerToClientMessage::release_memory_range_info_msg() {
  clear_has_memory_range_info_msg();
  ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* temp = memory_range_info_msg_;
  memory_range_info_msg_ = nullptr;
  return temp;
}

// -------------------------------------------------------------------

// LineInfo

// required string file = 1;
inline bool LineInfo::has_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineInfo::set_has_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineInfo::clear_has_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineInfo::clear_file() {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& LineInfo::file() const {
  return *file_;
}
inline void LineInfo::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void LineInfo::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void LineInfo::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LineInfo::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  return file_;
}
inline ::std::string* LineInfo::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 lineno = 2;
inline bool LineInfo::has_lineno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineInfo::set_has_lineno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineInfo::clear_has_lineno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineInfo::clear_lineno() {
  lineno_ = 0u;
  clear_has_lineno();
}
inline ::google::protobuf::uint32 LineInfo::lineno() const {
  return lineno_;
}
inline void LineInfo::set_lineno(::google::protobuf::uint32 value) {
  set_has_lineno();
  lineno_ = value;
}

// -------------------------------------------------------------------

// VarTypeDescriptor

// required .debugservermessages.VarTypeDescriptor.Tag tag = 1;
inline bool VarTypeDescriptor::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeDescriptor::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeDescriptor::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeDescriptor::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::debugservermessages::VarTypeDescriptor_Tag VarTypeDescriptor::tag() const {
  return static_cast< ::debugservermessages::VarTypeDescriptor_Tag >(tag_);
}
inline void VarTypeDescriptor::set_tag(::debugservermessages::VarTypeDescriptor_Tag value) {
  GOOGLE_DCHECK(::debugservermessages::VarTypeDescriptor_Tag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// optional .debugservermessages.VarTypeBasic type_basic = 11;
inline bool VarTypeDescriptor::has_type_basic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeDescriptor::set_has_type_basic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeDescriptor::clear_has_type_basic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeDescriptor::clear_type_basic() {
  if (type_basic_ != nullptr) type_basic_->::debugservermessages::VarTypeBasic::Clear();
  clear_has_type_basic();
}
inline const ::debugservermessages::VarTypeBasic& VarTypeDescriptor::type_basic() const {
  return type_basic_ != nullptr ? *type_basic_ : *default_instance_->type_basic_;
}
inline ::debugservermessages::VarTypeBasic* VarTypeDescriptor::mutable_type_basic() {
  set_has_type_basic();
  if (type_basic_ == nullptr) type_basic_ = new ::debugservermessages::VarTypeBasic;
  return type_basic_;
}
inline ::debugservermessages::VarTypeBasic* VarTypeDescriptor::release_type_basic() {
  clear_has_type_basic();
  ::debugservermessages::VarTypeBasic* temp = type_basic_;
  type_basic_ = nullptr;
  return temp;
}

// optional .debugservermessages.VarTypePointer type_pointer = 12;
inline bool VarTypeDescriptor::has_type_pointer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarTypeDescriptor::set_has_type_pointer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarTypeDescriptor::clear_has_type_pointer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarTypeDescriptor::clear_type_pointer() {
  if (type_pointer_ != nullptr) type_pointer_->::debugservermessages::VarTypePointer::Clear();
  clear_has_type_pointer();
}
inline const ::debugservermessages::VarTypePointer& VarTypeDescriptor::type_pointer() const {
  return type_pointer_ != nullptr ? *type_pointer_ : *default_instance_->type_pointer_;
}
inline ::debugservermessages::VarTypePointer* VarTypeDescriptor::mutable_type_pointer() {
  set_has_type_pointer();
  if (type_pointer_ == nullptr) type_pointer_ = new ::debugservermessages::VarTypePointer;
  return type_pointer_;
}
inline ::debugservermessages::VarTypePointer* VarTypeDescriptor::release_type_pointer() {
  clear_has_type_pointer();
  ::debugservermessages::VarTypePointer* temp = type_pointer_;
  type_pointer_ = nullptr;
  return temp;
}

// optional .debugservermessages.VarTypeArray type_array = 13;
inline bool VarTypeDescriptor::has_type_array() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VarTypeDescriptor::set_has_type_array() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VarTypeDescriptor::clear_has_type_array() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VarTypeDescriptor::clear_type_array() {
  if (type_array_ != nullptr) type_array_->::debugservermessages::VarTypeArray::Clear();
  clear_has_type_array();
}
inline const ::debugservermessages::VarTypeArray& VarTypeDescriptor::type_array() const {
  return type_array_ != nullptr ? *type_array_ : *default_instance_->type_array_;
}
inline ::debugservermessages::VarTypeArray* VarTypeDescriptor::mutable_type_array() {
  set_has_type_array();
  if (type_array_ == nullptr) type_array_ = new ::debugservermessages::VarTypeArray;
  return type_array_;
}
inline ::debugservermessages::VarTypeArray* VarTypeDescriptor::release_type_array() {
  clear_has_type_array();
  ::debugservermessages::VarTypeArray* temp = type_array_;
  type_array_ = nullptr;
  return temp;
}

// optional .debugservermessages.VarTypeVector type_vector = 14;
inline bool VarTypeDescriptor::has_type_vector() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VarTypeDescriptor::set_has_type_vector() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VarTypeDescriptor::clear_has_type_vector() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VarTypeDescriptor::clear_type_vector() {
  if (type_vector_ != nullptr) type_vector_->::debugservermessages::VarTypeVector::Clear();
  clear_has_type_vector();
}
inline const ::debugservermessages::VarTypeVector& VarTypeDescriptor::type_vector() const {
  return type_vector_ != nullptr ? *type_vector_ : *default_instance_->type_vector_;
}
inline ::debugservermessages::VarTypeVector* VarTypeDescriptor::mutable_type_vector() {
  set_has_type_vector();
  if (type_vector_ == nullptr) type_vector_ = new ::debugservermessages::VarTypeVector;
  return type_vector_;
}
inline ::debugservermessages::VarTypeVector* VarTypeDescriptor::release_type_vector() {
  clear_has_type_vector();
  ::debugservermessages::VarTypeVector* temp = type_vector_;
  type_vector_ = nullptr;
  return temp;
}

// optional .debugservermessages.VarTypeTypedef type_typedef = 15;
inline bool VarTypeDescriptor::has_type_typedef() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VarTypeDescriptor::set_has_type_typedef() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VarTypeDescriptor::clear_has_type_typedef() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VarTypeDescriptor::clear_type_typedef() {
  if (type_typedef_ != nullptr) type_typedef_->::debugservermessages::VarTypeTypedef::Clear();
  clear_has_type_typedef();
}
inline const ::debugservermessages::VarTypeTypedef& VarTypeDescriptor::type_typedef() const {
  return type_typedef_ != nullptr ? *type_typedef_ : *default_instance_->type_typedef_;
}
inline ::debugservermessages::VarTypeTypedef* VarTypeDescriptor::mutable_type_typedef() {
  set_has_type_typedef();
  if (type_typedef_ == nullptr) type_typedef_ = new ::debugservermessages::VarTypeTypedef;
  return type_typedef_;
}
inline ::debugservermessages::VarTypeTypedef* VarTypeDescriptor::release_type_typedef() {
  clear_has_type_typedef();
  ::debugservermessages::VarTypeTypedef* temp = type_typedef_;
  type_typedef_ = nullptr;
  return temp;
}

// optional .debugservermessages.VarTypeEnum type_enum = 16;
inline bool VarTypeDescriptor::has_type_enum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VarTypeDescriptor::set_has_type_enum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VarTypeDescriptor::clear_has_type_enum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VarTypeDescriptor::clear_type_enum() {
  if (type_enum_ != nullptr) type_enum_->::debugservermessages::VarTypeEnum::Clear();
  clear_has_type_enum();
}
inline const ::debugservermessages::VarTypeEnum& VarTypeDescriptor::type_enum() const {
  return type_enum_ != nullptr ? *type_enum_ : *default_instance_->type_enum_;
}
inline ::debugservermessages::VarTypeEnum* VarTypeDescriptor::mutable_type_enum() {
  set_has_type_enum();
  if (type_enum_ == nullptr) type_enum_ = new ::debugservermessages::VarTypeEnum;
  return type_enum_;
}
inline ::debugservermessages::VarTypeEnum* VarTypeDescriptor::release_type_enum() {
  clear_has_type_enum();
  ::debugservermessages::VarTypeEnum* temp = type_enum_;
  type_enum_ = nullptr;
  return temp;
}

// optional .debugservermessages.VarTypeStruct type_struct = 17;
inline bool VarTypeDescriptor::has_type_struct() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VarTypeDescriptor::set_has_type_struct() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VarTypeDescriptor::clear_has_type_struct() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VarTypeDescriptor::clear_type_struct() {
  if (type_struct_ != nullptr) type_struct_->::debugservermessages::VarTypeStruct::Clear();
  clear_has_type_struct();
}
inline const ::debugservermessages::VarTypeStruct& VarTypeDescriptor::type_struct() const {
  return type_struct_ != nullptr ? *type_struct_ : *default_instance_->type_struct_;
}
inline ::debugservermessages::VarTypeStruct* VarTypeDescriptor::mutable_type_struct() {
  set_has_type_struct();
  if (type_struct_ == nullptr) type_struct_ = new ::debugservermessages::VarTypeStruct;
  return type_struct_;
}
inline ::debugservermessages::VarTypeStruct* VarTypeDescriptor::release_type_struct() {
  clear_has_type_struct();
  ::debugservermessages::VarTypeStruct* temp = type_struct_;
  type_struct_ = nullptr;
  return temp;
}

// -------------------------------------------------------------------

// VarTypeBasic

// required .debugservermessages.VarTypeBasic.Tag tag = 1;
inline bool VarTypeBasic::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeBasic::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeBasic::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeBasic::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::debugservermessages::VarTypeBasic_Tag VarTypeBasic::tag() const {
  return static_cast< ::debugservermessages::VarTypeBasic_Tag >(tag_);
}
inline void VarTypeBasic::set_tag(::debugservermessages::VarTypeBasic_Tag value) {
  GOOGLE_DCHECK(::debugservermessages::VarTypeBasic_Tag_IsValid(value));
  set_has_tag();
  tag_ = value;
}

// required uint64 size_nbits = 2;
inline bool VarTypeBasic::has_size_nbits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeBasic::set_has_size_nbits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeBasic::clear_has_size_nbits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeBasic::clear_size_nbits() {
  size_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_size_nbits();
}
inline ::google::protobuf::uint64 VarTypeBasic::size_nbits() const {
  return size_nbits_;
}
inline void VarTypeBasic::set_size_nbits(::google::protobuf::uint64 value) {
  set_has_size_nbits();
  size_nbits_ = value;
}

// required string name = 20;
inline bool VarTypeBasic::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarTypeBasic::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarTypeBasic::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarTypeBasic::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VarTypeBasic::name() const {
  return *name_;
}
inline void VarTypeBasic::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeBasic::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeBasic::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VarTypeBasic::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VarTypeBasic::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// VarTypePointer

// required .debugservermessages.VarTypeDescriptor pointee = 1;
inline bool VarTypePointer::has_pointee() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypePointer::set_has_pointee() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypePointer::clear_has_pointee() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypePointer::clear_pointee() {
  if (pointee_ != nullptr) pointee_->::debugservermessages::VarTypeDescriptor::Clear();
  clear_has_pointee();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypePointer::pointee() const {
  return pointee_ != nullptr ? *pointee_ : *default_instance_->pointee_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypePointer::mutable_pointee() {
  set_has_pointee();
  if (pointee_ == nullptr) pointee_ = new ::debugservermessages::VarTypeDescriptor;
  return pointee_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypePointer::release_pointee() {
  clear_has_pointee();
  ::debugservermessages::VarTypeDescriptor* temp = pointee_;
  pointee_ = nullptr;
  return temp;
}

// -------------------------------------------------------------------

// VarTypeArray

// required .debugservermessages.VarTypeDescriptor element = 1;
inline bool VarTypeArray::has_element() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeArray::set_has_element() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeArray::clear_has_element() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeArray::clear_element() {
  if (element_ != nullptr) element_->::debugservermessages::VarTypeDescriptor::Clear();
  clear_has_element();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeArray::element() const {
  return element_ != nullptr ? *element_ : *default_instance_->element_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeArray::mutable_element() {
  set_has_element();
  if (element_ == nullptr) element_ = new ::debugservermessages::VarTypeDescriptor;
  return element_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeArray::release_element() {
  clear_has_element();
  ::debugservermessages::VarTypeDescriptor* temp = element_;
  element_ = nullptr;
  return temp;
}

// repeated uint64 dimensions = 2;
inline int VarTypeArray::dimensions_size() const {
  return dimensions_.size();
}
inline void VarTypeArray::clear_dimensions() {
  dimensions_.Clear();
}
inline ::google::protobuf::uint64 VarTypeArray::dimensions(int index) const {
  return dimensions_.Get(index);
}
inline void VarTypeArray::set_dimensions(int index, ::google::protobuf::uint64 value) {
  dimensions_.Set(index, value);
}
inline void VarTypeArray::add_dimensions(::google::protobuf::uint64 value) {
  dimensions_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
VarTypeArray::dimensions() const {
  return dimensions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
VarTypeArray::mutable_dimensions() {
  return &dimensions_;
}

// -------------------------------------------------------------------

// VarTypeEnum_EnumEntry

// required string name = 1;
inline bool VarTypeEnum_EnumEntry::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeEnum_EnumEntry::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeEnum_EnumEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeEnum_EnumEntry::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VarTypeEnum_EnumEntry::name() const {
  return *name_;
}
inline void VarTypeEnum_EnumEntry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeEnum_EnumEntry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeEnum_EnumEntry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VarTypeEnum_EnumEntry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VarTypeEnum_EnumEntry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 value = 2;
inline bool VarTypeEnum_EnumEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeEnum_EnumEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeEnum_EnumEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeEnum_EnumEntry::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 VarTypeEnum_EnumEntry::value() const {
  return value_;
}
inline void VarTypeEnum_EnumEntry::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// VarTypeEnum

// required string name = 1;
inline bool VarTypeEnum::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeEnum::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeEnum::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeEnum::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VarTypeEnum::name() const {
  return *name_;
}
inline void VarTypeEnum::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeEnum::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeEnum::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VarTypeEnum::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VarTypeEnum::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .debugservermessages.VarTypeEnum.EnumEntry entries = 2;
inline int VarTypeEnum::entries_size() const {
  return entries_.size();
}
inline void VarTypeEnum::clear_entries() {
  entries_.Clear();
}
inline const ::debugservermessages::VarTypeEnum_EnumEntry& VarTypeEnum::entries(int index) const {
  return entries_.Get(index);
}
inline ::debugservermessages::VarTypeEnum_EnumEntry* VarTypeEnum::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::debugservermessages::VarTypeEnum_EnumEntry* VarTypeEnum::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >&
VarTypeEnum::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >*
VarTypeEnum::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// VarTypeStruct_StructMember

// required string name = 1;
inline bool VarTypeStruct_StructMember::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeStruct_StructMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeStruct_StructMember::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VarTypeStruct_StructMember::name() const {
  return *name_;
}
inline void VarTypeStruct_StructMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeStruct_StructMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeStruct_StructMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VarTypeStruct_StructMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VarTypeStruct_StructMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 size_nbits = 2;
inline bool VarTypeStruct_StructMember::has_size_nbits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_size_nbits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeStruct_StructMember::clear_has_size_nbits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeStruct_StructMember::clear_size_nbits() {
  size_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_size_nbits();
}
inline ::google::protobuf::uint64 VarTypeStruct_StructMember::size_nbits() const {
  return size_nbits_;
}
inline void VarTypeStruct_StructMember::set_size_nbits(::google::protobuf::uint64 value) {
  set_has_size_nbits();
  size_nbits_ = value;
}

// required uint64 align_nbits = 3;
inline bool VarTypeStruct_StructMember::has_align_nbits() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_align_nbits() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarTypeStruct_StructMember::clear_has_align_nbits() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarTypeStruct_StructMember::clear_align_nbits() {
  align_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_align_nbits();
}
inline ::google::protobuf::uint64 VarTypeStruct_StructMember::align_nbits() const {
  return align_nbits_;
}
inline void VarTypeStruct_StructMember::set_align_nbits(::google::protobuf::uint64 value) {
  set_has_align_nbits();
  align_nbits_ = value;
}

// required uint64 offset_nbits = 4;
inline bool VarTypeStruct_StructMember::has_offset_nbits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_offset_nbits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VarTypeStruct_StructMember::clear_has_offset_nbits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VarTypeStruct_StructMember::clear_offset_nbits() {
  offset_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_offset_nbits();
}
inline ::google::protobuf::uint64 VarTypeStruct_StructMember::offset_nbits() const {
  return offset_nbits_;
}
inline void VarTypeStruct_StructMember::set_offset_nbits(::google::protobuf::uint64 value) {
  set_has_offset_nbits();
  offset_nbits_ = value;
}

// required .debugservermessages.VarTypeDescriptor type = 20;
inline bool VarTypeStruct_StructMember::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VarTypeStruct_StructMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VarTypeStruct_StructMember::clear_type() {
  if (type_ != nullptr) type_->::debugservermessages::VarTypeDescriptor::Clear();
  clear_has_type();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeStruct_StructMember::type() const {
  return type_ != nullptr ? *type_ : *default_instance_->type_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeStruct_StructMember::mutable_type() {
  set_has_type();
  if (type_ == nullptr) type_ = new ::debugservermessages::VarTypeDescriptor;
  return type_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeStruct_StructMember::release_type() {
  clear_has_type();
  ::debugservermessages::VarTypeDescriptor* temp = type_;
  type_ = nullptr;
  return temp;
}

// -------------------------------------------------------------------

// VarTypeStruct

// required string name = 1;
inline bool VarTypeStruct::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeStruct::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeStruct::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeStruct::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VarTypeStruct::name() const {
  return *name_;
}
inline void VarTypeStruct::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeStruct::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeStruct::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VarTypeStruct::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VarTypeStruct::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .debugservermessages.VarTypeStruct.StructMember members = 2;
inline int VarTypeStruct::members_size() const {
  return members_.size();
}
inline void VarTypeStruct::clear_members() {
  members_.Clear();
}
inline const ::debugservermessages::VarTypeStruct_StructMember& VarTypeStruct::members(int index) const {
  return members_.Get(index);
}
inline ::debugservermessages::VarTypeStruct_StructMember* VarTypeStruct::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::debugservermessages::VarTypeStruct_StructMember* VarTypeStruct::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >&
VarTypeStruct::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >*
VarTypeStruct::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// VarTypeVector

// required string name = 1;
inline bool VarTypeVector::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeVector::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeVector::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeVector::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VarTypeVector::name() const {
  return *name_;
}
inline void VarTypeVector::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeVector::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeVector::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VarTypeVector::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VarTypeVector::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// VarTypeTypedef

// required string name = 1;
inline bool VarTypeTypedef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeTypedef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeTypedef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeTypedef::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VarTypeTypedef::name() const {
  return *name_;
}
inline void VarTypeTypedef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeTypedef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VarTypeTypedef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VarTypeTypedef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VarTypeTypedef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return nullptr;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .debugservermessages.VarTypeDescriptor original_type = 2;
inline bool VarTypeTypedef::has_original_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeTypedef::set_has_original_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeTypedef::clear_has_original_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeTypedef::clear_original_type() {
  if (original_type_ != nullptr) original_type_->::debugservermessages::VarTypeDescriptor::Clear();
  clear_has_original_type();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeTypedef::original_type() const {
  return original_type_ != nullptr ? *original_type_ : *default_instance_->original_type_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeTypedef::mutable_original_type() {
  set_has_original_type();
  if (original_type_ == nullptr) original_type_ = new ::debugservermessages::VarTypeDescriptor;
  return original_type_;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeTypedef::release_original_type() {
  clear_has_original_type();
  ::debugservermessages::VarTypeDescriptor* temp = original_type_;
  original_type_ = nullptr;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace debugservermessages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::ClientToServerMessage_Type>() {
  return ::debugservermessages::ClientToServerMessage_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::ServerToClientMessage_Type>() {
  return ::debugservermessages::ServerToClientMessage_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::VarTypeDescriptor_Tag>() {
  return ::debugservermessages::VarTypeDescriptor_Tag_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::VarTypeBasic_Tag>() {
  return ::debugservermessages::VarTypeBasic_Tag_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_debugservermessages_2eproto__INCLUDED
