// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: debugservermessages.proto

#ifndef PROTOBUF_INCLUDED_debugservermessages_2eproto
#define PROTOBUF_INCLUDED_debugservermessages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_debugservermessages_2eproto 

namespace protobuf_debugservermessages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[23];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_debugservermessages_2eproto
namespace debugservermessages {
class ClientToServerMessage;
class ClientToServerMessageDefaultTypeInternal;
extern ClientToServerMessageDefaultTypeInternal _ClientToServerMessage_default_instance_;
class ClientToServerMessage_GetMemoryRangeMsg;
class ClientToServerMessage_GetMemoryRangeMsgDefaultTypeInternal;
extern ClientToServerMessage_GetMemoryRangeMsgDefaultTypeInternal _ClientToServerMessage_GetMemoryRangeMsg_default_instance_;
class ClientToServerMessage_RunMsg;
class ClientToServerMessage_RunMsgDefaultTypeInternal;
extern ClientToServerMessage_RunMsgDefaultTypeInternal _ClientToServerMessage_RunMsg_default_instance_;
class ClientToServerMessage_StartSessionMsg;
class ClientToServerMessage_StartSessionMsgDefaultTypeInternal;
extern ClientToServerMessage_StartSessionMsgDefaultTypeInternal _ClientToServerMessage_StartSessionMsg_default_instance_;
class LineInfo;
class LineInfoDefaultTypeInternal;
extern LineInfoDefaultTypeInternal _LineInfo_default_instance_;
class ServerToClientMessage;
class ServerToClientMessageDefaultTypeInternal;
extern ServerToClientMessageDefaultTypeInternal _ServerToClientMessage_default_instance_;
class ServerToClientMessage_BPHitMsg;
class ServerToClientMessage_BPHitMsgDefaultTypeInternal;
extern ServerToClientMessage_BPHitMsgDefaultTypeInternal _ServerToClientMessage_BPHitMsg_default_instance_;
class ServerToClientMessage_CmdErrorMsg;
class ServerToClientMessage_CmdErrorMsgDefaultTypeInternal;
extern ServerToClientMessage_CmdErrorMsgDefaultTypeInternal _ServerToClientMessage_CmdErrorMsg_default_instance_;
class ServerToClientMessage_MemoryRangeInfoMsg;
class ServerToClientMessage_MemoryRangeInfoMsgDefaultTypeInternal;
extern ServerToClientMessage_MemoryRangeInfoMsgDefaultTypeInternal _ServerToClientMessage_MemoryRangeInfoMsg_default_instance_;
class ServerToClientMessage_StackFrameInfo;
class ServerToClientMessage_StackFrameInfoDefaultTypeInternal;
extern ServerToClientMessage_StackFrameInfoDefaultTypeInternal _ServerToClientMessage_StackFrameInfo_default_instance_;
class ServerToClientMessage_StackTraceInfoMsg;
class ServerToClientMessage_StackTraceInfoMsgDefaultTypeInternal;
extern ServerToClientMessage_StackTraceInfoMsgDefaultTypeInternal _ServerToClientMessage_StackTraceInfoMsg_default_instance_;
class ServerToClientMessage_StartSessionAckMsg;
class ServerToClientMessage_StartSessionAckMsgDefaultTypeInternal;
extern ServerToClientMessage_StartSessionAckMsgDefaultTypeInternal _ServerToClientMessage_StartSessionAckMsg_default_instance_;
class ServerToClientMessage_VarInfo;
class ServerToClientMessage_VarInfoDefaultTypeInternal;
extern ServerToClientMessage_VarInfoDefaultTypeInternal _ServerToClientMessage_VarInfo_default_instance_;
class VarTypeArray;
class VarTypeArrayDefaultTypeInternal;
extern VarTypeArrayDefaultTypeInternal _VarTypeArray_default_instance_;
class VarTypeBasic;
class VarTypeBasicDefaultTypeInternal;
extern VarTypeBasicDefaultTypeInternal _VarTypeBasic_default_instance_;
class VarTypeDescriptor;
class VarTypeDescriptorDefaultTypeInternal;
extern VarTypeDescriptorDefaultTypeInternal _VarTypeDescriptor_default_instance_;
class VarTypeEnum;
class VarTypeEnumDefaultTypeInternal;
extern VarTypeEnumDefaultTypeInternal _VarTypeEnum_default_instance_;
class VarTypeEnum_EnumEntry;
class VarTypeEnum_EnumEntryDefaultTypeInternal;
extern VarTypeEnum_EnumEntryDefaultTypeInternal _VarTypeEnum_EnumEntry_default_instance_;
class VarTypePointer;
class VarTypePointerDefaultTypeInternal;
extern VarTypePointerDefaultTypeInternal _VarTypePointer_default_instance_;
class VarTypeStruct;
class VarTypeStructDefaultTypeInternal;
extern VarTypeStructDefaultTypeInternal _VarTypeStruct_default_instance_;
class VarTypeStruct_StructMember;
class VarTypeStruct_StructMemberDefaultTypeInternal;
extern VarTypeStruct_StructMemberDefaultTypeInternal _VarTypeStruct_StructMember_default_instance_;
class VarTypeTypedef;
class VarTypeTypedefDefaultTypeInternal;
extern VarTypeTypedefDefaultTypeInternal _VarTypeTypedef_default_instance_;
class VarTypeVector;
class VarTypeVectorDefaultTypeInternal;
extern VarTypeVectorDefaultTypeInternal _VarTypeVector_default_instance_;
}  // namespace debugservermessages
namespace google {
namespace protobuf {
template<> ::debugservermessages::ClientToServerMessage* Arena::CreateMaybeMessage<::debugservermessages::ClientToServerMessage>(Arena*);
template<> ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* Arena::CreateMaybeMessage<::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg>(Arena*);
template<> ::debugservermessages::ClientToServerMessage_RunMsg* Arena::CreateMaybeMessage<::debugservermessages::ClientToServerMessage_RunMsg>(Arena*);
template<> ::debugservermessages::ClientToServerMessage_StartSessionMsg* Arena::CreateMaybeMessage<::debugservermessages::ClientToServerMessage_StartSessionMsg>(Arena*);
template<> ::debugservermessages::LineInfo* Arena::CreateMaybeMessage<::debugservermessages::LineInfo>(Arena*);
template<> ::debugservermessages::ServerToClientMessage* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage>(Arena*);
template<> ::debugservermessages::ServerToClientMessage_BPHitMsg* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage_BPHitMsg>(Arena*);
template<> ::debugservermessages::ServerToClientMessage_CmdErrorMsg* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage_CmdErrorMsg>(Arena*);
template<> ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg>(Arena*);
template<> ::debugservermessages::ServerToClientMessage_StackFrameInfo* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage_StackFrameInfo>(Arena*);
template<> ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage_StackTraceInfoMsg>(Arena*);
template<> ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage_StartSessionAckMsg>(Arena*);
template<> ::debugservermessages::ServerToClientMessage_VarInfo* Arena::CreateMaybeMessage<::debugservermessages::ServerToClientMessage_VarInfo>(Arena*);
template<> ::debugservermessages::VarTypeArray* Arena::CreateMaybeMessage<::debugservermessages::VarTypeArray>(Arena*);
template<> ::debugservermessages::VarTypeBasic* Arena::CreateMaybeMessage<::debugservermessages::VarTypeBasic>(Arena*);
template<> ::debugservermessages::VarTypeDescriptor* Arena::CreateMaybeMessage<::debugservermessages::VarTypeDescriptor>(Arena*);
template<> ::debugservermessages::VarTypeEnum* Arena::CreateMaybeMessage<::debugservermessages::VarTypeEnum>(Arena*);
template<> ::debugservermessages::VarTypeEnum_EnumEntry* Arena::CreateMaybeMessage<::debugservermessages::VarTypeEnum_EnumEntry>(Arena*);
template<> ::debugservermessages::VarTypePointer* Arena::CreateMaybeMessage<::debugservermessages::VarTypePointer>(Arena*);
template<> ::debugservermessages::VarTypeStruct* Arena::CreateMaybeMessage<::debugservermessages::VarTypeStruct>(Arena*);
template<> ::debugservermessages::VarTypeStruct_StructMember* Arena::CreateMaybeMessage<::debugservermessages::VarTypeStruct_StructMember>(Arena*);
template<> ::debugservermessages::VarTypeTypedef* Arena::CreateMaybeMessage<::debugservermessages::VarTypeTypedef>(Arena*);
template<> ::debugservermessages::VarTypeVector* Arena::CreateMaybeMessage<::debugservermessages::VarTypeVector>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace debugservermessages {

enum ClientToServerMessage_Type {
  ClientToServerMessage_Type_START_SESSION = 1,
  ClientToServerMessage_Type_RUN = 2,
  ClientToServerMessage_Type_SINGLE_STEP_IN = 3,
  ClientToServerMessage_Type_SINGLE_STEP_OVER = 4,
  ClientToServerMessage_Type_SINGLE_STEP_OUT = 5,
  ClientToServerMessage_Type_GET_STACK_TRACE = 21,
  ClientToServerMessage_Type_GET_MEMORY_RANGE = 22,
  ClientToServerMessage_Type_BAD_MSG_TEST = 99
};
bool ClientToServerMessage_Type_IsValid(int value);
const ClientToServerMessage_Type ClientToServerMessage_Type_Type_MIN = ClientToServerMessage_Type_START_SESSION;
const ClientToServerMessage_Type ClientToServerMessage_Type_Type_MAX = ClientToServerMessage_Type_BAD_MSG_TEST;
const int ClientToServerMessage_Type_Type_ARRAYSIZE = ClientToServerMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientToServerMessage_Type_descriptor();
inline const ::std::string& ClientToServerMessage_Type_Name(ClientToServerMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientToServerMessage_Type_descriptor(), value);
}
inline bool ClientToServerMessage_Type_Parse(
    const ::std::string& name, ClientToServerMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientToServerMessage_Type>(
    ClientToServerMessage_Type_descriptor(), name, value);
}
enum ServerToClientMessage_Type {
  ServerToClientMessage_Type_CMD_ERROR = 1,
  ServerToClientMessage_Type_START_SESSION_ACK = 2,
  ServerToClientMessage_Type_BP_HIT = 3,
  ServerToClientMessage_Type_STACK_TRACE_INFO = 4,
  ServerToClientMessage_Type_MEMORY_RANGE_INFO = 5
};
bool ServerToClientMessage_Type_IsValid(int value);
const ServerToClientMessage_Type ServerToClientMessage_Type_Type_MIN = ServerToClientMessage_Type_CMD_ERROR;
const ServerToClientMessage_Type ServerToClientMessage_Type_Type_MAX = ServerToClientMessage_Type_MEMORY_RANGE_INFO;
const int ServerToClientMessage_Type_Type_ARRAYSIZE = ServerToClientMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerToClientMessage_Type_descriptor();
inline const ::std::string& ServerToClientMessage_Type_Name(ServerToClientMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerToClientMessage_Type_descriptor(), value);
}
inline bool ServerToClientMessage_Type_Parse(
    const ::std::string& name, ServerToClientMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerToClientMessage_Type>(
    ServerToClientMessage_Type_descriptor(), name, value);
}
enum VarTypeDescriptor_Tag {
  VarTypeDescriptor_Tag_BASIC = 0,
  VarTypeDescriptor_Tag_POINTER = 1,
  VarTypeDescriptor_Tag_ARRAY = 2,
  VarTypeDescriptor_Tag_VECTOR = 3,
  VarTypeDescriptor_Tag_TYPEDEF = 4,
  VarTypeDescriptor_Tag_ENUM = 5,
  VarTypeDescriptor_Tag_STRUCT = 6,
  VarTypeDescriptor_Tag_UNKNOWN = 99
};
bool VarTypeDescriptor_Tag_IsValid(int value);
const VarTypeDescriptor_Tag VarTypeDescriptor_Tag_Tag_MIN = VarTypeDescriptor_Tag_BASIC;
const VarTypeDescriptor_Tag VarTypeDescriptor_Tag_Tag_MAX = VarTypeDescriptor_Tag_UNKNOWN;
const int VarTypeDescriptor_Tag_Tag_ARRAYSIZE = VarTypeDescriptor_Tag_Tag_MAX + 1;

const ::google::protobuf::EnumDescriptor* VarTypeDescriptor_Tag_descriptor();
inline const ::std::string& VarTypeDescriptor_Tag_Name(VarTypeDescriptor_Tag value) {
  return ::google::protobuf::internal::NameOfEnum(
    VarTypeDescriptor_Tag_descriptor(), value);
}
inline bool VarTypeDescriptor_Tag_Parse(
    const ::std::string& name, VarTypeDescriptor_Tag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VarTypeDescriptor_Tag>(
    VarTypeDescriptor_Tag_descriptor(), name, value);
}
enum VarTypeBasic_Tag {
  VarTypeBasic_Tag_BOOLEAN = 0,
  VarTypeBasic_Tag_FLOAT = 1,
  VarTypeBasic_Tag_SIGNED = 2,
  VarTypeBasic_Tag_SIGNED_CHAR = 3,
  VarTypeBasic_Tag_UNSIGNED = 4,
  VarTypeBasic_Tag_UNSIGNED_CHAR = 5,
  VarTypeBasic_Tag_UNKNOWN = 99
};
bool VarTypeBasic_Tag_IsValid(int value);
const VarTypeBasic_Tag VarTypeBasic_Tag_Tag_MIN = VarTypeBasic_Tag_BOOLEAN;
const VarTypeBasic_Tag VarTypeBasic_Tag_Tag_MAX = VarTypeBasic_Tag_UNKNOWN;
const int VarTypeBasic_Tag_Tag_ARRAYSIZE = VarTypeBasic_Tag_Tag_MAX + 1;

const ::google::protobuf::EnumDescriptor* VarTypeBasic_Tag_descriptor();
inline const ::std::string& VarTypeBasic_Tag_Name(VarTypeBasic_Tag value) {
  return ::google::protobuf::internal::NameOfEnum(
    VarTypeBasic_Tag_descriptor(), value);
}
inline bool VarTypeBasic_Tag_Parse(
    const ::std::string& name, VarTypeBasic_Tag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VarTypeBasic_Tag>(
    VarTypeBasic_Tag_descriptor(), name, value);
}
// ===================================================================

class ClientToServerMessage_StartSessionMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ClientToServerMessage.StartSessionMsg) */ {
 public:
  ClientToServerMessage_StartSessionMsg();
  virtual ~ClientToServerMessage_StartSessionMsg();

  ClientToServerMessage_StartSessionMsg(const ClientToServerMessage_StartSessionMsg& from);

  inline ClientToServerMessage_StartSessionMsg& operator=(const ClientToServerMessage_StartSessionMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServerMessage_StartSessionMsg(ClientToServerMessage_StartSessionMsg&& from) noexcept
    : ClientToServerMessage_StartSessionMsg() {
    *this = ::std::move(from);
  }

  inline ClientToServerMessage_StartSessionMsg& operator=(ClientToServerMessage_StartSessionMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage_StartSessionMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServerMessage_StartSessionMsg* internal_default_instance() {
    return reinterpret_cast<const ClientToServerMessage_StartSessionMsg*>(
               &_ClientToServerMessage_StartSessionMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ClientToServerMessage_StartSessionMsg* other);
  friend void swap(ClientToServerMessage_StartSessionMsg& a, ClientToServerMessage_StartSessionMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServerMessage_StartSessionMsg* New() const final {
    return CreateMaybeMessage<ClientToServerMessage_StartSessionMsg>(NULL);
  }

  ClientToServerMessage_StartSessionMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServerMessage_StartSessionMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServerMessage_StartSessionMsg& from);
  void MergeFrom(const ClientToServerMessage_StartSessionMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServerMessage_StartSessionMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 global_id_x = 1;
  bool has_global_id_x() const;
  void clear_global_id_x();
  static const int kGlobalIdXFieldNumber = 1;
  ::google::protobuf::uint32 global_id_x() const;
  void set_global_id_x(::google::protobuf::uint32 value);

  // required uint32 global_id_y = 2;
  bool has_global_id_y() const;
  void clear_global_id_y();
  static const int kGlobalIdYFieldNumber = 2;
  ::google::protobuf::uint32 global_id_y() const;
  void set_global_id_y(::google::protobuf::uint32 value);

  // required uint32 global_id_z = 3;
  bool has_global_id_z() const;
  void clear_global_id_z();
  static const int kGlobalIdZFieldNumber = 3;
  ::google::protobuf::uint32 global_id_z() const;
  void set_global_id_z(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage.StartSessionMsg)
 private:
  void set_has_global_id_x();
  void clear_has_global_id_x();
  void set_has_global_id_y();
  void clear_has_global_id_y();
  void set_has_global_id_z();
  void clear_has_global_id_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 global_id_x_;
  ::google::protobuf::uint32 global_id_y_;
  ::google::protobuf::uint32 global_id_z_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServerMessage_RunMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ClientToServerMessage.RunMsg) */ {
 public:
  ClientToServerMessage_RunMsg();
  virtual ~ClientToServerMessage_RunMsg();

  ClientToServerMessage_RunMsg(const ClientToServerMessage_RunMsg& from);

  inline ClientToServerMessage_RunMsg& operator=(const ClientToServerMessage_RunMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServerMessage_RunMsg(ClientToServerMessage_RunMsg&& from) noexcept
    : ClientToServerMessage_RunMsg() {
    *this = ::std::move(from);
  }

  inline ClientToServerMessage_RunMsg& operator=(ClientToServerMessage_RunMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage_RunMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServerMessage_RunMsg* internal_default_instance() {
    return reinterpret_cast<const ClientToServerMessage_RunMsg*>(
               &_ClientToServerMessage_RunMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ClientToServerMessage_RunMsg* other);
  friend void swap(ClientToServerMessage_RunMsg& a, ClientToServerMessage_RunMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServerMessage_RunMsg* New() const final {
    return CreateMaybeMessage<ClientToServerMessage_RunMsg>(NULL);
  }

  ClientToServerMessage_RunMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServerMessage_RunMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServerMessage_RunMsg& from);
  void MergeFrom(const ClientToServerMessage_RunMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServerMessage_RunMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .debugservermessages.LineInfo breakpoints = 2;
  int breakpoints_size() const;
  void clear_breakpoints();
  static const int kBreakpointsFieldNumber = 2;
  ::debugservermessages::LineInfo* mutable_breakpoints(int index);
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >*
      mutable_breakpoints();
  const ::debugservermessages::LineInfo& breakpoints(int index) const;
  ::debugservermessages::LineInfo* add_breakpoints();
  const ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >&
      breakpoints() const;

  // required string info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage.RunMsg)
 private:
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo > breakpoints_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServerMessage_GetMemoryRangeMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ClientToServerMessage.GetMemoryRangeMsg) */ {
 public:
  ClientToServerMessage_GetMemoryRangeMsg();
  virtual ~ClientToServerMessage_GetMemoryRangeMsg();

  ClientToServerMessage_GetMemoryRangeMsg(const ClientToServerMessage_GetMemoryRangeMsg& from);

  inline ClientToServerMessage_GetMemoryRangeMsg& operator=(const ClientToServerMessage_GetMemoryRangeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServerMessage_GetMemoryRangeMsg(ClientToServerMessage_GetMemoryRangeMsg&& from) noexcept
    : ClientToServerMessage_GetMemoryRangeMsg() {
    *this = ::std::move(from);
  }

  inline ClientToServerMessage_GetMemoryRangeMsg& operator=(ClientToServerMessage_GetMemoryRangeMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage_GetMemoryRangeMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServerMessage_GetMemoryRangeMsg* internal_default_instance() {
    return reinterpret_cast<const ClientToServerMessage_GetMemoryRangeMsg*>(
               &_ClientToServerMessage_GetMemoryRangeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClientToServerMessage_GetMemoryRangeMsg* other);
  friend void swap(ClientToServerMessage_GetMemoryRangeMsg& a, ClientToServerMessage_GetMemoryRangeMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServerMessage_GetMemoryRangeMsg* New() const final {
    return CreateMaybeMessage<ClientToServerMessage_GetMemoryRangeMsg>(NULL);
  }

  ClientToServerMessage_GetMemoryRangeMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServerMessage_GetMemoryRangeMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServerMessage_GetMemoryRangeMsg& from);
  void MergeFrom(const ClientToServerMessage_GetMemoryRangeMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServerMessage_GetMemoryRangeMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 start_addr = 1;
  bool has_start_addr() const;
  void clear_start_addr();
  static const int kStartAddrFieldNumber = 1;
  ::google::protobuf::uint64 start_addr() const;
  void set_start_addr(::google::protobuf::uint64 value);

  // required uint64 end_addr = 2;
  bool has_end_addr() const;
  void clear_end_addr();
  static const int kEndAddrFieldNumber = 2;
  ::google::protobuf::uint64 end_addr() const;
  void set_end_addr(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage.GetMemoryRangeMsg)
 private:
  void set_has_start_addr();
  void clear_has_start_addr();
  void set_has_end_addr();
  void clear_has_end_addr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 start_addr_;
  ::google::protobuf::uint64 end_addr_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientToServerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ClientToServerMessage) */ {
 public:
  ClientToServerMessage();
  virtual ~ClientToServerMessage();

  ClientToServerMessage(const ClientToServerMessage& from);

  inline ClientToServerMessage& operator=(const ClientToServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientToServerMessage(ClientToServerMessage&& from) noexcept
    : ClientToServerMessage() {
    *this = ::std::move(from);
  }

  inline ClientToServerMessage& operator=(ClientToServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToServerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientToServerMessage* internal_default_instance() {
    return reinterpret_cast<const ClientToServerMessage*>(
               &_ClientToServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ClientToServerMessage* other);
  friend void swap(ClientToServerMessage& a, ClientToServerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientToServerMessage* New() const final {
    return CreateMaybeMessage<ClientToServerMessage>(NULL);
  }

  ClientToServerMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientToServerMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientToServerMessage& from);
  void MergeFrom(const ClientToServerMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToServerMessage_StartSessionMsg StartSessionMsg;
  typedef ClientToServerMessage_RunMsg RunMsg;
  typedef ClientToServerMessage_GetMemoryRangeMsg GetMemoryRangeMsg;

  typedef ClientToServerMessage_Type Type;
  static const Type START_SESSION =
    ClientToServerMessage_Type_START_SESSION;
  static const Type RUN =
    ClientToServerMessage_Type_RUN;
  static const Type SINGLE_STEP_IN =
    ClientToServerMessage_Type_SINGLE_STEP_IN;
  static const Type SINGLE_STEP_OVER =
    ClientToServerMessage_Type_SINGLE_STEP_OVER;
  static const Type SINGLE_STEP_OUT =
    ClientToServerMessage_Type_SINGLE_STEP_OUT;
  static const Type GET_STACK_TRACE =
    ClientToServerMessage_Type_GET_STACK_TRACE;
  static const Type GET_MEMORY_RANGE =
    ClientToServerMessage_Type_GET_MEMORY_RANGE;
  static const Type BAD_MSG_TEST =
    ClientToServerMessage_Type_BAD_MSG_TEST;
  static inline bool Type_IsValid(int value) {
    return ClientToServerMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientToServerMessage_Type_Type_MIN;
  static const Type Type_MAX =
    ClientToServerMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientToServerMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ClientToServerMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ClientToServerMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ClientToServerMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .debugservermessages.ClientToServerMessage.StartSessionMsg start_session_msg = 20;
  bool has_start_session_msg() const;
  void clear_start_session_msg();
  static const int kStartSessionMsgFieldNumber = 20;
  private:
  const ::debugservermessages::ClientToServerMessage_StartSessionMsg& _internal_start_session_msg() const;
  public:
  const ::debugservermessages::ClientToServerMessage_StartSessionMsg& start_session_msg() const;
  ::debugservermessages::ClientToServerMessage_StartSessionMsg* release_start_session_msg();
  ::debugservermessages::ClientToServerMessage_StartSessionMsg* mutable_start_session_msg();
  void set_allocated_start_session_msg(::debugservermessages::ClientToServerMessage_StartSessionMsg* start_session_msg);

  // optional .debugservermessages.ClientToServerMessage.RunMsg run_msg = 21;
  bool has_run_msg() const;
  void clear_run_msg();
  static const int kRunMsgFieldNumber = 21;
  private:
  const ::debugservermessages::ClientToServerMessage_RunMsg& _internal_run_msg() const;
  public:
  const ::debugservermessages::ClientToServerMessage_RunMsg& run_msg() const;
  ::debugservermessages::ClientToServerMessage_RunMsg* release_run_msg();
  ::debugservermessages::ClientToServerMessage_RunMsg* mutable_run_msg();
  void set_allocated_run_msg(::debugservermessages::ClientToServerMessage_RunMsg* run_msg);

  // optional .debugservermessages.ClientToServerMessage.GetMemoryRangeMsg get_memory_range_msg = 31;
  bool has_get_memory_range_msg() const;
  void clear_get_memory_range_msg();
  static const int kGetMemoryRangeMsgFieldNumber = 31;
  private:
  const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg& _internal_get_memory_range_msg() const;
  public:
  const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg& get_memory_range_msg() const;
  ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* release_get_memory_range_msg();
  ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* mutable_get_memory_range_msg();
  void set_allocated_get_memory_range_msg(::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* get_memory_range_msg);

  // required .debugservermessages.ClientToServerMessage.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::debugservermessages::ClientToServerMessage_Type type() const;
  void set_type(::debugservermessages::ClientToServerMessage_Type value);

  // @@protoc_insertion_point(class_scope:debugservermessages.ClientToServerMessage)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_start_session_msg();
  void clear_has_start_session_msg();
  void set_has_run_msg();
  void clear_has_run_msg();
  void set_has_get_memory_range_msg();
  void clear_has_get_memory_range_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::debugservermessages::ClientToServerMessage_StartSessionMsg* start_session_msg_;
  ::debugservermessages::ClientToServerMessage_RunMsg* run_msg_;
  ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* get_memory_range_msg_;
  int type_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage_CmdErrorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage.CmdErrorMsg) */ {
 public:
  ServerToClientMessage_CmdErrorMsg();
  virtual ~ServerToClientMessage_CmdErrorMsg();

  ServerToClientMessage_CmdErrorMsg(const ServerToClientMessage_CmdErrorMsg& from);

  inline ServerToClientMessage_CmdErrorMsg& operator=(const ServerToClientMessage_CmdErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage_CmdErrorMsg(ServerToClientMessage_CmdErrorMsg&& from) noexcept
    : ServerToClientMessage_CmdErrorMsg() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage_CmdErrorMsg& operator=(ServerToClientMessage_CmdErrorMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_CmdErrorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage_CmdErrorMsg* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage_CmdErrorMsg*>(
               &_ServerToClientMessage_CmdErrorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ServerToClientMessage_CmdErrorMsg* other);
  friend void swap(ServerToClientMessage_CmdErrorMsg& a, ServerToClientMessage_CmdErrorMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage_CmdErrorMsg* New() const final {
    return CreateMaybeMessage<ServerToClientMessage_CmdErrorMsg>(NULL);
  }

  ServerToClientMessage_CmdErrorMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage_CmdErrorMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage_CmdErrorMsg& from);
  void MergeFrom(const ServerToClientMessage_CmdErrorMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage_CmdErrorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string description = 1;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.CmdErrorMsg)
 private:
  void set_has_description();
  void clear_has_description();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage_StartSessionAckMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage.StartSessionAckMsg) */ {
 public:
  ServerToClientMessage_StartSessionAckMsg();
  virtual ~ServerToClientMessage_StartSessionAckMsg();

  ServerToClientMessage_StartSessionAckMsg(const ServerToClientMessage_StartSessionAckMsg& from);

  inline ServerToClientMessage_StartSessionAckMsg& operator=(const ServerToClientMessage_StartSessionAckMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage_StartSessionAckMsg(ServerToClientMessage_StartSessionAckMsg&& from) noexcept
    : ServerToClientMessage_StartSessionAckMsg() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage_StartSessionAckMsg& operator=(ServerToClientMessage_StartSessionAckMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_StartSessionAckMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage_StartSessionAckMsg* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage_StartSessionAckMsg*>(
               &_ServerToClientMessage_StartSessionAckMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ServerToClientMessage_StartSessionAckMsg* other);
  friend void swap(ServerToClientMessage_StartSessionAckMsg& a, ServerToClientMessage_StartSessionAckMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage_StartSessionAckMsg* New() const final {
    return CreateMaybeMessage<ServerToClientMessage_StartSessionAckMsg>(NULL);
  }

  ServerToClientMessage_StartSessionAckMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage_StartSessionAckMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage_StartSessionAckMsg& from);
  void MergeFrom(const ServerToClientMessage_StartSessionAckMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage_StartSessionAckMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sizeof_size_t = 1;
  bool has_sizeof_size_t() const;
  void clear_sizeof_size_t();
  static const int kSizeofSizeTFieldNumber = 1;
  ::google::protobuf::uint32 sizeof_size_t() const;
  void set_sizeof_size_t(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.StartSessionAckMsg)
 private:
  void set_has_sizeof_size_t();
  void clear_has_sizeof_size_t();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 sizeof_size_t_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage_VarInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage.VarInfo) */ {
 public:
  ServerToClientMessage_VarInfo();
  virtual ~ServerToClientMessage_VarInfo();

  ServerToClientMessage_VarInfo(const ServerToClientMessage_VarInfo& from);

  inline ServerToClientMessage_VarInfo& operator=(const ServerToClientMessage_VarInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage_VarInfo(ServerToClientMessage_VarInfo&& from) noexcept
    : ServerToClientMessage_VarInfo() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage_VarInfo& operator=(ServerToClientMessage_VarInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_VarInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage_VarInfo* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage_VarInfo*>(
               &_ServerToClientMessage_VarInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ServerToClientMessage_VarInfo* other);
  friend void swap(ServerToClientMessage_VarInfo& a, ServerToClientMessage_VarInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage_VarInfo* New() const final {
    return CreateMaybeMessage<ServerToClientMessage_VarInfo>(NULL);
  }

  ServerToClientMessage_VarInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage_VarInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage_VarInfo& from);
  void MergeFrom(const ServerToClientMessage_VarInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage_VarInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // required string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required .debugservermessages.VarTypeDescriptor type_descriptor = 5;
  bool has_type_descriptor() const;
  void clear_type_descriptor();
  static const int kTypeDescriptorFieldNumber = 5;
  private:
  const ::debugservermessages::VarTypeDescriptor& _internal_type_descriptor() const;
  public:
  const ::debugservermessages::VarTypeDescriptor& type_descriptor() const;
  ::debugservermessages::VarTypeDescriptor* release_type_descriptor();
  ::debugservermessages::VarTypeDescriptor* mutable_type_descriptor();
  void set_allocated_type_descriptor(::debugservermessages::VarTypeDescriptor* type_descriptor);

  // required uint64 address = 4;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 4;
  ::google::protobuf::uint64 address() const;
  void set_address(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.VarInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();
  void set_has_type();
  void clear_has_type();
  void set_has_address();
  void clear_has_address();
  void set_has_type_descriptor();
  void clear_has_type_descriptor();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::debugservermessages::VarTypeDescriptor* type_descriptor_;
  ::google::protobuf::uint64 address_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage_StackFrameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage.StackFrameInfo) */ {
 public:
  ServerToClientMessage_StackFrameInfo();
  virtual ~ServerToClientMessage_StackFrameInfo();

  ServerToClientMessage_StackFrameInfo(const ServerToClientMessage_StackFrameInfo& from);

  inline ServerToClientMessage_StackFrameInfo& operator=(const ServerToClientMessage_StackFrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage_StackFrameInfo(ServerToClientMessage_StackFrameInfo&& from) noexcept
    : ServerToClientMessage_StackFrameInfo() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage_StackFrameInfo& operator=(ServerToClientMessage_StackFrameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_StackFrameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage_StackFrameInfo* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage_StackFrameInfo*>(
               &_ServerToClientMessage_StackFrameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ServerToClientMessage_StackFrameInfo* other);
  friend void swap(ServerToClientMessage_StackFrameInfo& a, ServerToClientMessage_StackFrameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage_StackFrameInfo* New() const final {
    return CreateMaybeMessage<ServerToClientMessage_StackFrameInfo>(NULL);
  }

  ServerToClientMessage_StackFrameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage_StackFrameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage_StackFrameInfo& from);
  void MergeFrom(const ServerToClientMessage_StackFrameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage_StackFrameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 3;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 3;
  ::debugservermessages::ServerToClientMessage_VarInfo* mutable_vars(int index);
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
      mutable_vars();
  const ::debugservermessages::ServerToClientMessage_VarInfo& vars(int index) const;
  ::debugservermessages::ServerToClientMessage_VarInfo* add_vars();
  const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
      vars() const;

  // required string func_name = 1;
  bool has_func_name() const;
  void clear_func_name();
  static const int kFuncNameFieldNumber = 1;
  const ::std::string& func_name() const;
  void set_func_name(const ::std::string& value);
  #if LANG_CXX11
  void set_func_name(::std::string&& value);
  #endif
  void set_func_name(const char* value);
  void set_func_name(const char* value, size_t size);
  ::std::string* mutable_func_name();
  ::std::string* release_func_name();
  void set_allocated_func_name(::std::string* func_name);

  // required .debugservermessages.LineInfo call_line = 2;
  bool has_call_line() const;
  void clear_call_line();
  static const int kCallLineFieldNumber = 2;
  private:
  const ::debugservermessages::LineInfo& _internal_call_line() const;
  public:
  const ::debugservermessages::LineInfo& call_line() const;
  ::debugservermessages::LineInfo* release_call_line();
  ::debugservermessages::LineInfo* mutable_call_line();
  void set_allocated_call_line(::debugservermessages::LineInfo* call_line);

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.StackFrameInfo)
 private:
  void set_has_func_name();
  void clear_has_func_name();
  void set_has_call_line();
  void clear_has_call_line();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo > vars_;
  ::google::protobuf::internal::ArenaStringPtr func_name_;
  ::debugservermessages::LineInfo* call_line_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage_BPHitMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage.BPHitMsg) */ {
 public:
  ServerToClientMessage_BPHitMsg();
  virtual ~ServerToClientMessage_BPHitMsg();

  ServerToClientMessage_BPHitMsg(const ServerToClientMessage_BPHitMsg& from);

  inline ServerToClientMessage_BPHitMsg& operator=(const ServerToClientMessage_BPHitMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage_BPHitMsg(ServerToClientMessage_BPHitMsg&& from) noexcept
    : ServerToClientMessage_BPHitMsg() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage_BPHitMsg& operator=(ServerToClientMessage_BPHitMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_BPHitMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage_BPHitMsg* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage_BPHitMsg*>(
               &_ServerToClientMessage_BPHitMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ServerToClientMessage_BPHitMsg* other);
  friend void swap(ServerToClientMessage_BPHitMsg& a, ServerToClientMessage_BPHitMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage_BPHitMsg* New() const final {
    return CreateMaybeMessage<ServerToClientMessage_BPHitMsg>(NULL);
  }

  ServerToClientMessage_BPHitMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage_BPHitMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage_BPHitMsg& from);
  void MergeFrom(const ServerToClientMessage_BPHitMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage_BPHitMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 2;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 2;
  ::debugservermessages::ServerToClientMessage_VarInfo* mutable_vars(int index);
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
      mutable_vars();
  const ::debugservermessages::ServerToClientMessage_VarInfo& vars(int index) const;
  ::debugservermessages::ServerToClientMessage_VarInfo* add_vars();
  const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
      vars() const;

  // required .debugservermessages.LineInfo breakpoint = 1;
  bool has_breakpoint() const;
  void clear_breakpoint();
  static const int kBreakpointFieldNumber = 1;
  private:
  const ::debugservermessages::LineInfo& _internal_breakpoint() const;
  public:
  const ::debugservermessages::LineInfo& breakpoint() const;
  ::debugservermessages::LineInfo* release_breakpoint();
  ::debugservermessages::LineInfo* mutable_breakpoint();
  void set_allocated_breakpoint(::debugservermessages::LineInfo* breakpoint);

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.BPHitMsg)
 private:
  void set_has_breakpoint();
  void clear_has_breakpoint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo > vars_;
  ::debugservermessages::LineInfo* breakpoint_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage_StackTraceInfoMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage.StackTraceInfoMsg) */ {
 public:
  ServerToClientMessage_StackTraceInfoMsg();
  virtual ~ServerToClientMessage_StackTraceInfoMsg();

  ServerToClientMessage_StackTraceInfoMsg(const ServerToClientMessage_StackTraceInfoMsg& from);

  inline ServerToClientMessage_StackTraceInfoMsg& operator=(const ServerToClientMessage_StackTraceInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage_StackTraceInfoMsg(ServerToClientMessage_StackTraceInfoMsg&& from) noexcept
    : ServerToClientMessage_StackTraceInfoMsg() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage_StackTraceInfoMsg& operator=(ServerToClientMessage_StackTraceInfoMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_StackTraceInfoMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage_StackTraceInfoMsg* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage_StackTraceInfoMsg*>(
               &_ServerToClientMessage_StackTraceInfoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ServerToClientMessage_StackTraceInfoMsg* other);
  friend void swap(ServerToClientMessage_StackTraceInfoMsg& a, ServerToClientMessage_StackTraceInfoMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage_StackTraceInfoMsg* New() const final {
    return CreateMaybeMessage<ServerToClientMessage_StackTraceInfoMsg>(NULL);
  }

  ServerToClientMessage_StackTraceInfoMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage_StackTraceInfoMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage_StackTraceInfoMsg& from);
  void MergeFrom(const ServerToClientMessage_StackTraceInfoMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage_StackTraceInfoMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .debugservermessages.ServerToClientMessage.StackFrameInfo frames = 1;
  int frames_size() const;
  void clear_frames();
  static const int kFramesFieldNumber = 1;
  ::debugservermessages::ServerToClientMessage_StackFrameInfo* mutable_frames(int index);
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >*
      mutable_frames();
  const ::debugservermessages::ServerToClientMessage_StackFrameInfo& frames(int index) const;
  ::debugservermessages::ServerToClientMessage_StackFrameInfo* add_frames();
  const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >&
      frames() const;

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.StackTraceInfoMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo > frames_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage_MemoryRangeInfoMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg) */ {
 public:
  ServerToClientMessage_MemoryRangeInfoMsg();
  virtual ~ServerToClientMessage_MemoryRangeInfoMsg();

  ServerToClientMessage_MemoryRangeInfoMsg(const ServerToClientMessage_MemoryRangeInfoMsg& from);

  inline ServerToClientMessage_MemoryRangeInfoMsg& operator=(const ServerToClientMessage_MemoryRangeInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage_MemoryRangeInfoMsg(ServerToClientMessage_MemoryRangeInfoMsg&& from) noexcept
    : ServerToClientMessage_MemoryRangeInfoMsg() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage_MemoryRangeInfoMsg& operator=(ServerToClientMessage_MemoryRangeInfoMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage_MemoryRangeInfoMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage_MemoryRangeInfoMsg* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage_MemoryRangeInfoMsg*>(
               &_ServerToClientMessage_MemoryRangeInfoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ServerToClientMessage_MemoryRangeInfoMsg* other);
  friend void swap(ServerToClientMessage_MemoryRangeInfoMsg& a, ServerToClientMessage_MemoryRangeInfoMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage_MemoryRangeInfoMsg* New() const final {
    return CreateMaybeMessage<ServerToClientMessage_MemoryRangeInfoMsg>(NULL);
  }

  ServerToClientMessage_MemoryRangeInfoMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage_MemoryRangeInfoMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage_MemoryRangeInfoMsg& from);
  void MergeFrom(const ServerToClientMessage_MemoryRangeInfoMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage_MemoryRangeInfoMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes buf = 1;
  bool has_buf() const;
  void clear_buf();
  static const int kBufFieldNumber = 1;
  const ::std::string& buf() const;
  void set_buf(const ::std::string& value);
  #if LANG_CXX11
  void set_buf(::std::string&& value);
  #endif
  void set_buf(const char* value);
  void set_buf(const void* value, size_t size);
  ::std::string* mutable_buf();
  ::std::string* release_buf();
  void set_allocated_buf(::std::string* buf);

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg)
 private:
  void set_has_buf();
  void clear_has_buf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buf_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerToClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.ServerToClientMessage) */ {
 public:
  ServerToClientMessage();
  virtual ~ServerToClientMessage();

  ServerToClientMessage(const ServerToClientMessage& from);

  inline ServerToClientMessage& operator=(const ServerToClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClientMessage(ServerToClientMessage&& from) noexcept
    : ServerToClientMessage() {
    *this = ::std::move(from);
  }

  inline ServerToClientMessage& operator=(ServerToClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClientMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClientMessage* internal_default_instance() {
    return reinterpret_cast<const ServerToClientMessage*>(
               &_ServerToClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ServerToClientMessage* other);
  friend void swap(ServerToClientMessage& a, ServerToClientMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClientMessage* New() const final {
    return CreateMaybeMessage<ServerToClientMessage>(NULL);
  }

  ServerToClientMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerToClientMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerToClientMessage& from);
  void MergeFrom(const ServerToClientMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerToClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServerToClientMessage_CmdErrorMsg CmdErrorMsg;
  typedef ServerToClientMessage_StartSessionAckMsg StartSessionAckMsg;
  typedef ServerToClientMessage_VarInfo VarInfo;
  typedef ServerToClientMessage_StackFrameInfo StackFrameInfo;
  typedef ServerToClientMessage_BPHitMsg BPHitMsg;
  typedef ServerToClientMessage_StackTraceInfoMsg StackTraceInfoMsg;
  typedef ServerToClientMessage_MemoryRangeInfoMsg MemoryRangeInfoMsg;

  typedef ServerToClientMessage_Type Type;
  static const Type CMD_ERROR =
    ServerToClientMessage_Type_CMD_ERROR;
  static const Type START_SESSION_ACK =
    ServerToClientMessage_Type_START_SESSION_ACK;
  static const Type BP_HIT =
    ServerToClientMessage_Type_BP_HIT;
  static const Type STACK_TRACE_INFO =
    ServerToClientMessage_Type_STACK_TRACE_INFO;
  static const Type MEMORY_RANGE_INFO =
    ServerToClientMessage_Type_MEMORY_RANGE_INFO;
  static inline bool Type_IsValid(int value) {
    return ServerToClientMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ServerToClientMessage_Type_Type_MIN;
  static const Type Type_MAX =
    ServerToClientMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ServerToClientMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ServerToClientMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ServerToClientMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ServerToClientMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .debugservermessages.ServerToClientMessage.CmdErrorMsg cmd_error_msg = 21;
  bool has_cmd_error_msg() const;
  void clear_cmd_error_msg();
  static const int kCmdErrorMsgFieldNumber = 21;
  private:
  const ::debugservermessages::ServerToClientMessage_CmdErrorMsg& _internal_cmd_error_msg() const;
  public:
  const ::debugservermessages::ServerToClientMessage_CmdErrorMsg& cmd_error_msg() const;
  ::debugservermessages::ServerToClientMessage_CmdErrorMsg* release_cmd_error_msg();
  ::debugservermessages::ServerToClientMessage_CmdErrorMsg* mutable_cmd_error_msg();
  void set_allocated_cmd_error_msg(::debugservermessages::ServerToClientMessage_CmdErrorMsg* cmd_error_msg);

  // optional .debugservermessages.ServerToClientMessage.StartSessionAckMsg start_session_ack_msg = 22;
  bool has_start_session_ack_msg() const;
  void clear_start_session_ack_msg();
  static const int kStartSessionAckMsgFieldNumber = 22;
  private:
  const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg& _internal_start_session_ack_msg() const;
  public:
  const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg& start_session_ack_msg() const;
  ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* release_start_session_ack_msg();
  ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* mutable_start_session_ack_msg();
  void set_allocated_start_session_ack_msg(::debugservermessages::ServerToClientMessage_StartSessionAckMsg* start_session_ack_msg);

  // optional .debugservermessages.ServerToClientMessage.BPHitMsg bphit_msg = 31;
  bool has_bphit_msg() const;
  void clear_bphit_msg();
  static const int kBphitMsgFieldNumber = 31;
  private:
  const ::debugservermessages::ServerToClientMessage_BPHitMsg& _internal_bphit_msg() const;
  public:
  const ::debugservermessages::ServerToClientMessage_BPHitMsg& bphit_msg() const;
  ::debugservermessages::ServerToClientMessage_BPHitMsg* release_bphit_msg();
  ::debugservermessages::ServerToClientMessage_BPHitMsg* mutable_bphit_msg();
  void set_allocated_bphit_msg(::debugservermessages::ServerToClientMessage_BPHitMsg* bphit_msg);

  // optional .debugservermessages.ServerToClientMessage.StackTraceInfoMsg stack_trace_info_msg = 41;
  bool has_stack_trace_info_msg() const;
  void clear_stack_trace_info_msg();
  static const int kStackTraceInfoMsgFieldNumber = 41;
  private:
  const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg& _internal_stack_trace_info_msg() const;
  public:
  const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg& stack_trace_info_msg() const;
  ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* release_stack_trace_info_msg();
  ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* mutable_stack_trace_info_msg();
  void set_allocated_stack_trace_info_msg(::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* stack_trace_info_msg);

  // optional .debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg memory_range_info_msg = 51;
  bool has_memory_range_info_msg() const;
  void clear_memory_range_info_msg();
  static const int kMemoryRangeInfoMsgFieldNumber = 51;
  private:
  const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg& _internal_memory_range_info_msg() const;
  public:
  const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg& memory_range_info_msg() const;
  ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* release_memory_range_info_msg();
  ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* mutable_memory_range_info_msg();
  void set_allocated_memory_range_info_msg(::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* memory_range_info_msg);

  // required .debugservermessages.ServerToClientMessage.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::debugservermessages::ServerToClientMessage_Type type() const;
  void set_type(::debugservermessages::ServerToClientMessage_Type value);

  // @@protoc_insertion_point(class_scope:debugservermessages.ServerToClientMessage)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_cmd_error_msg();
  void clear_has_cmd_error_msg();
  void set_has_start_session_ack_msg();
  void clear_has_start_session_ack_msg();
  void set_has_bphit_msg();
  void clear_has_bphit_msg();
  void set_has_stack_trace_info_msg();
  void clear_has_stack_trace_info_msg();
  void set_has_memory_range_info_msg();
  void clear_has_memory_range_info_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::debugservermessages::ServerToClientMessage_CmdErrorMsg* cmd_error_msg_;
  ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* start_session_ack_msg_;
  ::debugservermessages::ServerToClientMessage_BPHitMsg* bphit_msg_;
  ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* stack_trace_info_msg_;
  ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* memory_range_info_msg_;
  int type_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LineInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.LineInfo) */ {
 public:
  LineInfo();
  virtual ~LineInfo();

  LineInfo(const LineInfo& from);

  inline LineInfo& operator=(const LineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LineInfo(LineInfo&& from) noexcept
    : LineInfo() {
    *this = ::std::move(from);
  }

  inline LineInfo& operator=(LineInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineInfo* internal_default_instance() {
    return reinterpret_cast<const LineInfo*>(
               &_LineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(LineInfo* other);
  friend void swap(LineInfo& a, LineInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LineInfo* New() const final {
    return CreateMaybeMessage<LineInfo>(NULL);
  }

  LineInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LineInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LineInfo& from);
  void MergeFrom(const LineInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file = 1;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 1;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // required uint32 lineno = 2;
  bool has_lineno() const;
  void clear_lineno();
  static const int kLinenoFieldNumber = 2;
  ::google::protobuf::uint32 lineno() const;
  void set_lineno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:debugservermessages.LineInfo)
 private:
  void set_has_file();
  void clear_has_file();
  void set_has_lineno();
  void clear_has_lineno();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  ::google::protobuf::uint32 lineno_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeDescriptor) */ {
 public:
  VarTypeDescriptor();
  virtual ~VarTypeDescriptor();

  VarTypeDescriptor(const VarTypeDescriptor& from);

  inline VarTypeDescriptor& operator=(const VarTypeDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeDescriptor(VarTypeDescriptor&& from) noexcept
    : VarTypeDescriptor() {
    *this = ::std::move(from);
  }

  inline VarTypeDescriptor& operator=(VarTypeDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeDescriptor* internal_default_instance() {
    return reinterpret_cast<const VarTypeDescriptor*>(
               &_VarTypeDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(VarTypeDescriptor* other);
  friend void swap(VarTypeDescriptor& a, VarTypeDescriptor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeDescriptor* New() const final {
    return CreateMaybeMessage<VarTypeDescriptor>(NULL);
  }

  VarTypeDescriptor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeDescriptor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeDescriptor& from);
  void MergeFrom(const VarTypeDescriptor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VarTypeDescriptor_Tag Tag;
  static const Tag BASIC =
    VarTypeDescriptor_Tag_BASIC;
  static const Tag POINTER =
    VarTypeDescriptor_Tag_POINTER;
  static const Tag ARRAY =
    VarTypeDescriptor_Tag_ARRAY;
  static const Tag VECTOR =
    VarTypeDescriptor_Tag_VECTOR;
  static const Tag TYPEDEF =
    VarTypeDescriptor_Tag_TYPEDEF;
  static const Tag ENUM =
    VarTypeDescriptor_Tag_ENUM;
  static const Tag STRUCT =
    VarTypeDescriptor_Tag_STRUCT;
  static const Tag UNKNOWN =
    VarTypeDescriptor_Tag_UNKNOWN;
  static inline bool Tag_IsValid(int value) {
    return VarTypeDescriptor_Tag_IsValid(value);
  }
  static const Tag Tag_MIN =
    VarTypeDescriptor_Tag_Tag_MIN;
  static const Tag Tag_MAX =
    VarTypeDescriptor_Tag_Tag_MAX;
  static const int Tag_ARRAYSIZE =
    VarTypeDescriptor_Tag_Tag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Tag_descriptor() {
    return VarTypeDescriptor_Tag_descriptor();
  }
  static inline const ::std::string& Tag_Name(Tag value) {
    return VarTypeDescriptor_Tag_Name(value);
  }
  static inline bool Tag_Parse(const ::std::string& name,
      Tag* value) {
    return VarTypeDescriptor_Tag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .debugservermessages.VarTypeBasic type_basic = 11;
  bool has_type_basic() const;
  void clear_type_basic();
  static const int kTypeBasicFieldNumber = 11;
  private:
  const ::debugservermessages::VarTypeBasic& _internal_type_basic() const;
  public:
  const ::debugservermessages::VarTypeBasic& type_basic() const;
  ::debugservermessages::VarTypeBasic* release_type_basic();
  ::debugservermessages::VarTypeBasic* mutable_type_basic();
  void set_allocated_type_basic(::debugservermessages::VarTypeBasic* type_basic);

  // optional .debugservermessages.VarTypePointer type_pointer = 12;
  bool has_type_pointer() const;
  void clear_type_pointer();
  static const int kTypePointerFieldNumber = 12;
  private:
  const ::debugservermessages::VarTypePointer& _internal_type_pointer() const;
  public:
  const ::debugservermessages::VarTypePointer& type_pointer() const;
  ::debugservermessages::VarTypePointer* release_type_pointer();
  ::debugservermessages::VarTypePointer* mutable_type_pointer();
  void set_allocated_type_pointer(::debugservermessages::VarTypePointer* type_pointer);

  // optional .debugservermessages.VarTypeArray type_array = 13;
  bool has_type_array() const;
  void clear_type_array();
  static const int kTypeArrayFieldNumber = 13;
  private:
  const ::debugservermessages::VarTypeArray& _internal_type_array() const;
  public:
  const ::debugservermessages::VarTypeArray& type_array() const;
  ::debugservermessages::VarTypeArray* release_type_array();
  ::debugservermessages::VarTypeArray* mutable_type_array();
  void set_allocated_type_array(::debugservermessages::VarTypeArray* type_array);

  // optional .debugservermessages.VarTypeVector type_vector = 14;
  bool has_type_vector() const;
  void clear_type_vector();
  static const int kTypeVectorFieldNumber = 14;
  private:
  const ::debugservermessages::VarTypeVector& _internal_type_vector() const;
  public:
  const ::debugservermessages::VarTypeVector& type_vector() const;
  ::debugservermessages::VarTypeVector* release_type_vector();
  ::debugservermessages::VarTypeVector* mutable_type_vector();
  void set_allocated_type_vector(::debugservermessages::VarTypeVector* type_vector);

  // optional .debugservermessages.VarTypeTypedef type_typedef = 15;
  bool has_type_typedef() const;
  void clear_type_typedef();
  static const int kTypeTypedefFieldNumber = 15;
  private:
  const ::debugservermessages::VarTypeTypedef& _internal_type_typedef() const;
  public:
  const ::debugservermessages::VarTypeTypedef& type_typedef() const;
  ::debugservermessages::VarTypeTypedef* release_type_typedef();
  ::debugservermessages::VarTypeTypedef* mutable_type_typedef();
  void set_allocated_type_typedef(::debugservermessages::VarTypeTypedef* type_typedef);

  // optional .debugservermessages.VarTypeEnum type_enum = 16;
  bool has_type_enum() const;
  void clear_type_enum();
  static const int kTypeEnumFieldNumber = 16;
  private:
  const ::debugservermessages::VarTypeEnum& _internal_type_enum() const;
  public:
  const ::debugservermessages::VarTypeEnum& type_enum() const;
  ::debugservermessages::VarTypeEnum* release_type_enum();
  ::debugservermessages::VarTypeEnum* mutable_type_enum();
  void set_allocated_type_enum(::debugservermessages::VarTypeEnum* type_enum);

  // optional .debugservermessages.VarTypeStruct type_struct = 17;
  bool has_type_struct() const;
  void clear_type_struct();
  static const int kTypeStructFieldNumber = 17;
  private:
  const ::debugservermessages::VarTypeStruct& _internal_type_struct() const;
  public:
  const ::debugservermessages::VarTypeStruct& type_struct() const;
  ::debugservermessages::VarTypeStruct* release_type_struct();
  ::debugservermessages::VarTypeStruct* mutable_type_struct();
  void set_allocated_type_struct(::debugservermessages::VarTypeStruct* type_struct);

  // required .debugservermessages.VarTypeDescriptor.Tag tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::debugservermessages::VarTypeDescriptor_Tag tag() const;
  void set_tag(::debugservermessages::VarTypeDescriptor_Tag value);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeDescriptor)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_type_basic();
  void clear_has_type_basic();
  void set_has_type_pointer();
  void clear_has_type_pointer();
  void set_has_type_array();
  void clear_has_type_array();
  void set_has_type_vector();
  void clear_has_type_vector();
  void set_has_type_typedef();
  void clear_has_type_typedef();
  void set_has_type_enum();
  void clear_has_type_enum();
  void set_has_type_struct();
  void clear_has_type_struct();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::debugservermessages::VarTypeBasic* type_basic_;
  ::debugservermessages::VarTypePointer* type_pointer_;
  ::debugservermessages::VarTypeArray* type_array_;
  ::debugservermessages::VarTypeVector* type_vector_;
  ::debugservermessages::VarTypeTypedef* type_typedef_;
  ::debugservermessages::VarTypeEnum* type_enum_;
  ::debugservermessages::VarTypeStruct* type_struct_;
  int tag_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeBasic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeBasic) */ {
 public:
  VarTypeBasic();
  virtual ~VarTypeBasic();

  VarTypeBasic(const VarTypeBasic& from);

  inline VarTypeBasic& operator=(const VarTypeBasic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeBasic(VarTypeBasic&& from) noexcept
    : VarTypeBasic() {
    *this = ::std::move(from);
  }

  inline VarTypeBasic& operator=(VarTypeBasic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeBasic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeBasic* internal_default_instance() {
    return reinterpret_cast<const VarTypeBasic*>(
               &_VarTypeBasic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(VarTypeBasic* other);
  friend void swap(VarTypeBasic& a, VarTypeBasic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeBasic* New() const final {
    return CreateMaybeMessage<VarTypeBasic>(NULL);
  }

  VarTypeBasic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeBasic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeBasic& from);
  void MergeFrom(const VarTypeBasic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeBasic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VarTypeBasic_Tag Tag;
  static const Tag BOOLEAN =
    VarTypeBasic_Tag_BOOLEAN;
  static const Tag FLOAT =
    VarTypeBasic_Tag_FLOAT;
  static const Tag SIGNED =
    VarTypeBasic_Tag_SIGNED;
  static const Tag SIGNED_CHAR =
    VarTypeBasic_Tag_SIGNED_CHAR;
  static const Tag UNSIGNED =
    VarTypeBasic_Tag_UNSIGNED;
  static const Tag UNSIGNED_CHAR =
    VarTypeBasic_Tag_UNSIGNED_CHAR;
  static const Tag UNKNOWN =
    VarTypeBasic_Tag_UNKNOWN;
  static inline bool Tag_IsValid(int value) {
    return VarTypeBasic_Tag_IsValid(value);
  }
  static const Tag Tag_MIN =
    VarTypeBasic_Tag_Tag_MIN;
  static const Tag Tag_MAX =
    VarTypeBasic_Tag_Tag_MAX;
  static const int Tag_ARRAYSIZE =
    VarTypeBasic_Tag_Tag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Tag_descriptor() {
    return VarTypeBasic_Tag_descriptor();
  }
  static inline const ::std::string& Tag_Name(Tag value) {
    return VarTypeBasic_Tag_Name(value);
  }
  static inline bool Tag_Parse(const ::std::string& name,
      Tag* value) {
    return VarTypeBasic_Tag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 20;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 20;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint64 size_nbits = 2;
  bool has_size_nbits() const;
  void clear_size_nbits();
  static const int kSizeNbitsFieldNumber = 2;
  ::google::protobuf::uint64 size_nbits() const;
  void set_size_nbits(::google::protobuf::uint64 value);

  // required .debugservermessages.VarTypeBasic.Tag tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::debugservermessages::VarTypeBasic_Tag tag() const;
  void set_tag(::debugservermessages::VarTypeBasic_Tag value);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeBasic)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_size_nbits();
  void clear_has_size_nbits();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 size_nbits_;
  int tag_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypePointer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypePointer) */ {
 public:
  VarTypePointer();
  virtual ~VarTypePointer();

  VarTypePointer(const VarTypePointer& from);

  inline VarTypePointer& operator=(const VarTypePointer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypePointer(VarTypePointer&& from) noexcept
    : VarTypePointer() {
    *this = ::std::move(from);
  }

  inline VarTypePointer& operator=(VarTypePointer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypePointer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypePointer* internal_default_instance() {
    return reinterpret_cast<const VarTypePointer*>(
               &_VarTypePointer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(VarTypePointer* other);
  friend void swap(VarTypePointer& a, VarTypePointer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypePointer* New() const final {
    return CreateMaybeMessage<VarTypePointer>(NULL);
  }

  VarTypePointer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypePointer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypePointer& from);
  void MergeFrom(const VarTypePointer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypePointer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .debugservermessages.VarTypeDescriptor pointee = 1;
  bool has_pointee() const;
  void clear_pointee();
  static const int kPointeeFieldNumber = 1;
  private:
  const ::debugservermessages::VarTypeDescriptor& _internal_pointee() const;
  public:
  const ::debugservermessages::VarTypeDescriptor& pointee() const;
  ::debugservermessages::VarTypeDescriptor* release_pointee();
  ::debugservermessages::VarTypeDescriptor* mutable_pointee();
  void set_allocated_pointee(::debugservermessages::VarTypeDescriptor* pointee);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypePointer)
 private:
  void set_has_pointee();
  void clear_has_pointee();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::debugservermessages::VarTypeDescriptor* pointee_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeArray) */ {
 public:
  VarTypeArray();
  virtual ~VarTypeArray();

  VarTypeArray(const VarTypeArray& from);

  inline VarTypeArray& operator=(const VarTypeArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeArray(VarTypeArray&& from) noexcept
    : VarTypeArray() {
    *this = ::std::move(from);
  }

  inline VarTypeArray& operator=(VarTypeArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeArray* internal_default_instance() {
    return reinterpret_cast<const VarTypeArray*>(
               &_VarTypeArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(VarTypeArray* other);
  friend void swap(VarTypeArray& a, VarTypeArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeArray* New() const final {
    return CreateMaybeMessage<VarTypeArray>(NULL);
  }

  VarTypeArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeArray& from);
  void MergeFrom(const VarTypeArray& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 dimensions = 2;
  int dimensions_size() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 2;
  ::google::protobuf::uint64 dimensions(int index) const;
  void set_dimensions(int index, ::google::protobuf::uint64 value);
  void add_dimensions(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      dimensions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_dimensions();

  // required .debugservermessages.VarTypeDescriptor element = 1;
  bool has_element() const;
  void clear_element();
  static const int kElementFieldNumber = 1;
  private:
  const ::debugservermessages::VarTypeDescriptor& _internal_element() const;
  public:
  const ::debugservermessages::VarTypeDescriptor& element() const;
  ::debugservermessages::VarTypeDescriptor* release_element();
  ::debugservermessages::VarTypeDescriptor* mutable_element();
  void set_allocated_element(::debugservermessages::VarTypeDescriptor* element);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeArray)
 private:
  void set_has_element();
  void clear_has_element();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > dimensions_;
  ::debugservermessages::VarTypeDescriptor* element_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeEnum_EnumEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeEnum.EnumEntry) */ {
 public:
  VarTypeEnum_EnumEntry();
  virtual ~VarTypeEnum_EnumEntry();

  VarTypeEnum_EnumEntry(const VarTypeEnum_EnumEntry& from);

  inline VarTypeEnum_EnumEntry& operator=(const VarTypeEnum_EnumEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeEnum_EnumEntry(VarTypeEnum_EnumEntry&& from) noexcept
    : VarTypeEnum_EnumEntry() {
    *this = ::std::move(from);
  }

  inline VarTypeEnum_EnumEntry& operator=(VarTypeEnum_EnumEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeEnum_EnumEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeEnum_EnumEntry* internal_default_instance() {
    return reinterpret_cast<const VarTypeEnum_EnumEntry*>(
               &_VarTypeEnum_EnumEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(VarTypeEnum_EnumEntry* other);
  friend void swap(VarTypeEnum_EnumEntry& a, VarTypeEnum_EnumEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeEnum_EnumEntry* New() const final {
    return CreateMaybeMessage<VarTypeEnum_EnumEntry>(NULL);
  }

  VarTypeEnum_EnumEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeEnum_EnumEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeEnum_EnumEntry& from);
  void MergeFrom(const VarTypeEnum_EnumEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeEnum_EnumEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint64 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeEnum.EnumEntry)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 value_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeEnum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeEnum) */ {
 public:
  VarTypeEnum();
  virtual ~VarTypeEnum();

  VarTypeEnum(const VarTypeEnum& from);

  inline VarTypeEnum& operator=(const VarTypeEnum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeEnum(VarTypeEnum&& from) noexcept
    : VarTypeEnum() {
    *this = ::std::move(from);
  }

  inline VarTypeEnum& operator=(VarTypeEnum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeEnum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeEnum* internal_default_instance() {
    return reinterpret_cast<const VarTypeEnum*>(
               &_VarTypeEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(VarTypeEnum* other);
  friend void swap(VarTypeEnum& a, VarTypeEnum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeEnum* New() const final {
    return CreateMaybeMessage<VarTypeEnum>(NULL);
  }

  VarTypeEnum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeEnum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeEnum& from);
  void MergeFrom(const VarTypeEnum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeEnum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VarTypeEnum_EnumEntry EnumEntry;

  // accessors -------------------------------------------------------

  // repeated .debugservermessages.VarTypeEnum.EnumEntry entries = 2;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 2;
  ::debugservermessages::VarTypeEnum_EnumEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >*
      mutable_entries();
  const ::debugservermessages::VarTypeEnum_EnumEntry& entries(int index) const;
  ::debugservermessages::VarTypeEnum_EnumEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >&
      entries() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeEnum)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry > entries_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeStruct_StructMember : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeStruct.StructMember) */ {
 public:
  VarTypeStruct_StructMember();
  virtual ~VarTypeStruct_StructMember();

  VarTypeStruct_StructMember(const VarTypeStruct_StructMember& from);

  inline VarTypeStruct_StructMember& operator=(const VarTypeStruct_StructMember& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeStruct_StructMember(VarTypeStruct_StructMember&& from) noexcept
    : VarTypeStruct_StructMember() {
    *this = ::std::move(from);
  }

  inline VarTypeStruct_StructMember& operator=(VarTypeStruct_StructMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeStruct_StructMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeStruct_StructMember* internal_default_instance() {
    return reinterpret_cast<const VarTypeStruct_StructMember*>(
               &_VarTypeStruct_StructMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(VarTypeStruct_StructMember* other);
  friend void swap(VarTypeStruct_StructMember& a, VarTypeStruct_StructMember& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeStruct_StructMember* New() const final {
    return CreateMaybeMessage<VarTypeStruct_StructMember>(NULL);
  }

  VarTypeStruct_StructMember* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeStruct_StructMember>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeStruct_StructMember& from);
  void MergeFrom(const VarTypeStruct_StructMember& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeStruct_StructMember* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .debugservermessages.VarTypeDescriptor type = 20;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 20;
  private:
  const ::debugservermessages::VarTypeDescriptor& _internal_type() const;
  public:
  const ::debugservermessages::VarTypeDescriptor& type() const;
  ::debugservermessages::VarTypeDescriptor* release_type();
  ::debugservermessages::VarTypeDescriptor* mutable_type();
  void set_allocated_type(::debugservermessages::VarTypeDescriptor* type);

  // required uint64 size_nbits = 2;
  bool has_size_nbits() const;
  void clear_size_nbits();
  static const int kSizeNbitsFieldNumber = 2;
  ::google::protobuf::uint64 size_nbits() const;
  void set_size_nbits(::google::protobuf::uint64 value);

  // required uint64 align_nbits = 3;
  bool has_align_nbits() const;
  void clear_align_nbits();
  static const int kAlignNbitsFieldNumber = 3;
  ::google::protobuf::uint64 align_nbits() const;
  void set_align_nbits(::google::protobuf::uint64 value);

  // required uint64 offset_nbits = 4;
  bool has_offset_nbits() const;
  void clear_offset_nbits();
  static const int kOffsetNbitsFieldNumber = 4;
  ::google::protobuf::uint64 offset_nbits() const;
  void set_offset_nbits(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeStruct.StructMember)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_size_nbits();
  void clear_has_size_nbits();
  void set_has_align_nbits();
  void clear_has_align_nbits();
  void set_has_offset_nbits();
  void clear_has_offset_nbits();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::debugservermessages::VarTypeDescriptor* type_;
  ::google::protobuf::uint64 size_nbits_;
  ::google::protobuf::uint64 align_nbits_;
  ::google::protobuf::uint64 offset_nbits_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeStruct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeStruct) */ {
 public:
  VarTypeStruct();
  virtual ~VarTypeStruct();

  VarTypeStruct(const VarTypeStruct& from);

  inline VarTypeStruct& operator=(const VarTypeStruct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeStruct(VarTypeStruct&& from) noexcept
    : VarTypeStruct() {
    *this = ::std::move(from);
  }

  inline VarTypeStruct& operator=(VarTypeStruct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeStruct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeStruct* internal_default_instance() {
    return reinterpret_cast<const VarTypeStruct*>(
               &_VarTypeStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(VarTypeStruct* other);
  friend void swap(VarTypeStruct& a, VarTypeStruct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeStruct* New() const final {
    return CreateMaybeMessage<VarTypeStruct>(NULL);
  }

  VarTypeStruct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeStruct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeStruct& from);
  void MergeFrom(const VarTypeStruct& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeStruct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VarTypeStruct_StructMember StructMember;

  // accessors -------------------------------------------------------

  // repeated .debugservermessages.VarTypeStruct.StructMember members = 2;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 2;
  ::debugservermessages::VarTypeStruct_StructMember* mutable_members(int index);
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >*
      mutable_members();
  const ::debugservermessages::VarTypeStruct_StructMember& members(int index) const;
  ::debugservermessages::VarTypeStruct_StructMember* add_members();
  const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >&
      members() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeStruct)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember > members_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeVector) */ {
 public:
  VarTypeVector();
  virtual ~VarTypeVector();

  VarTypeVector(const VarTypeVector& from);

  inline VarTypeVector& operator=(const VarTypeVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeVector(VarTypeVector&& from) noexcept
    : VarTypeVector() {
    *this = ::std::move(from);
  }

  inline VarTypeVector& operator=(VarTypeVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeVector* internal_default_instance() {
    return reinterpret_cast<const VarTypeVector*>(
               &_VarTypeVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(VarTypeVector* other);
  friend void swap(VarTypeVector& a, VarTypeVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeVector* New() const final {
    return CreateMaybeMessage<VarTypeVector>(NULL);
  }

  VarTypeVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeVector& from);
  void MergeFrom(const VarTypeVector& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeVector)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarTypeTypedef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:debugservermessages.VarTypeTypedef) */ {
 public:
  VarTypeTypedef();
  virtual ~VarTypeTypedef();

  VarTypeTypedef(const VarTypeTypedef& from);

  inline VarTypeTypedef& operator=(const VarTypeTypedef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarTypeTypedef(VarTypeTypedef&& from) noexcept
    : VarTypeTypedef() {
    *this = ::std::move(from);
  }

  inline VarTypeTypedef& operator=(VarTypeTypedef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarTypeTypedef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarTypeTypedef* internal_default_instance() {
    return reinterpret_cast<const VarTypeTypedef*>(
               &_VarTypeTypedef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(VarTypeTypedef* other);
  friend void swap(VarTypeTypedef& a, VarTypeTypedef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarTypeTypedef* New() const final {
    return CreateMaybeMessage<VarTypeTypedef>(NULL);
  }

  VarTypeTypedef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarTypeTypedef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarTypeTypedef& from);
  void MergeFrom(const VarTypeTypedef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarTypeTypedef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .debugservermessages.VarTypeDescriptor original_type = 2;
  bool has_original_type() const;
  void clear_original_type();
  static const int kOriginalTypeFieldNumber = 2;
  private:
  const ::debugservermessages::VarTypeDescriptor& _internal_original_type() const;
  public:
  const ::debugservermessages::VarTypeDescriptor& original_type() const;
  ::debugservermessages::VarTypeDescriptor* release_original_type();
  ::debugservermessages::VarTypeDescriptor* mutable_original_type();
  void set_allocated_original_type(::debugservermessages::VarTypeDescriptor* original_type);

  // @@protoc_insertion_point(class_scope:debugservermessages.VarTypeTypedef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_original_type();
  void clear_has_original_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::debugservermessages::VarTypeDescriptor* original_type_;
  friend struct ::protobuf_debugservermessages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientToServerMessage_StartSessionMsg

// required uint32 global_id_x = 1;
inline bool ClientToServerMessage_StartSessionMsg::has_global_id_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage_StartSessionMsg::set_has_global_id_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_has_global_id_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_global_id_x() {
  global_id_x_ = 0u;
  clear_has_global_id_x();
}
inline ::google::protobuf::uint32 ClientToServerMessage_StartSessionMsg::global_id_x() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.StartSessionMsg.global_id_x)
  return global_id_x_;
}
inline void ClientToServerMessage_StartSessionMsg::set_global_id_x(::google::protobuf::uint32 value) {
  set_has_global_id_x();
  global_id_x_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ClientToServerMessage.StartSessionMsg.global_id_x)
}

// required uint32 global_id_y = 2;
inline bool ClientToServerMessage_StartSessionMsg::has_global_id_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage_StartSessionMsg::set_has_global_id_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_has_global_id_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_global_id_y() {
  global_id_y_ = 0u;
  clear_has_global_id_y();
}
inline ::google::protobuf::uint32 ClientToServerMessage_StartSessionMsg::global_id_y() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.StartSessionMsg.global_id_y)
  return global_id_y_;
}
inline void ClientToServerMessage_StartSessionMsg::set_global_id_y(::google::protobuf::uint32 value) {
  set_has_global_id_y();
  global_id_y_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ClientToServerMessage.StartSessionMsg.global_id_y)
}

// required uint32 global_id_z = 3;
inline bool ClientToServerMessage_StartSessionMsg::has_global_id_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerMessage_StartSessionMsg::set_has_global_id_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_has_global_id_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToServerMessage_StartSessionMsg::clear_global_id_z() {
  global_id_z_ = 0u;
  clear_has_global_id_z();
}
inline ::google::protobuf::uint32 ClientToServerMessage_StartSessionMsg::global_id_z() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.StartSessionMsg.global_id_z)
  return global_id_z_;
}
inline void ClientToServerMessage_StartSessionMsg::set_global_id_z(::google::protobuf::uint32 value) {
  set_has_global_id_z();
  global_id_z_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ClientToServerMessage.StartSessionMsg.global_id_z)
}

// -------------------------------------------------------------------

// ClientToServerMessage_RunMsg

// required string info = 1;
inline bool ClientToServerMessage_RunMsg::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage_RunMsg::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage_RunMsg::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage_RunMsg::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info();
}
inline const ::std::string& ClientToServerMessage_RunMsg::info() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.RunMsg.info)
  return info_.GetNoArena();
}
inline void ClientToServerMessage_RunMsg::set_info(const ::std::string& value) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.ClientToServerMessage.RunMsg.info)
}
#if LANG_CXX11
inline void ClientToServerMessage_RunMsg::set_info(::std::string&& value) {
  set_has_info();
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.ClientToServerMessage.RunMsg.info)
}
#endif
inline void ClientToServerMessage_RunMsg::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.ClientToServerMessage.RunMsg.info)
}
inline void ClientToServerMessage_RunMsg::set_info(const char* value, size_t size) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.ClientToServerMessage.RunMsg.info)
}
inline ::std::string* ClientToServerMessage_RunMsg::mutable_info() {
  set_has_info();
  // @@protoc_insertion_point(field_mutable:debugservermessages.ClientToServerMessage.RunMsg.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientToServerMessage_RunMsg::release_info() {
  // @@protoc_insertion_point(field_release:debugservermessages.ClientToServerMessage.RunMsg.info)
  if (!has_info()) {
    return NULL;
  }
  clear_has_info();
  return info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientToServerMessage_RunMsg::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    set_has_info();
  } else {
    clear_has_info();
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ClientToServerMessage.RunMsg.info)
}

// repeated .debugservermessages.LineInfo breakpoints = 2;
inline int ClientToServerMessage_RunMsg::breakpoints_size() const {
  return breakpoints_.size();
}
inline void ClientToServerMessage_RunMsg::clear_breakpoints() {
  breakpoints_.Clear();
}
inline ::debugservermessages::LineInfo* ClientToServerMessage_RunMsg::mutable_breakpoints(int index) {
  // @@protoc_insertion_point(field_mutable:debugservermessages.ClientToServerMessage.RunMsg.breakpoints)
  return breakpoints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >*
ClientToServerMessage_RunMsg::mutable_breakpoints() {
  // @@protoc_insertion_point(field_mutable_list:debugservermessages.ClientToServerMessage.RunMsg.breakpoints)
  return &breakpoints_;
}
inline const ::debugservermessages::LineInfo& ClientToServerMessage_RunMsg::breakpoints(int index) const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.RunMsg.breakpoints)
  return breakpoints_.Get(index);
}
inline ::debugservermessages::LineInfo* ClientToServerMessage_RunMsg::add_breakpoints() {
  // @@protoc_insertion_point(field_add:debugservermessages.ClientToServerMessage.RunMsg.breakpoints)
  return breakpoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::LineInfo >&
ClientToServerMessage_RunMsg::breakpoints() const {
  // @@protoc_insertion_point(field_list:debugservermessages.ClientToServerMessage.RunMsg.breakpoints)
  return breakpoints_;
}

// -------------------------------------------------------------------

// ClientToServerMessage_GetMemoryRangeMsg

// required uint64 start_addr = 1;
inline bool ClientToServerMessage_GetMemoryRangeMsg::has_start_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_has_start_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_has_start_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_start_addr() {
  start_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_start_addr();
}
inline ::google::protobuf::uint64 ClientToServerMessage_GetMemoryRangeMsg::start_addr() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.GetMemoryRangeMsg.start_addr)
  return start_addr_;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_start_addr(::google::protobuf::uint64 value) {
  set_has_start_addr();
  start_addr_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ClientToServerMessage.GetMemoryRangeMsg.start_addr)
}

// required uint64 end_addr = 2;
inline bool ClientToServerMessage_GetMemoryRangeMsg::has_end_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_has_end_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_has_end_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::clear_end_addr() {
  end_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_end_addr();
}
inline ::google::protobuf::uint64 ClientToServerMessage_GetMemoryRangeMsg::end_addr() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.GetMemoryRangeMsg.end_addr)
  return end_addr_;
}
inline void ClientToServerMessage_GetMemoryRangeMsg::set_end_addr(::google::protobuf::uint64 value) {
  set_has_end_addr();
  end_addr_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ClientToServerMessage.GetMemoryRangeMsg.end_addr)
}

// -------------------------------------------------------------------

// ClientToServerMessage

// required .debugservermessages.ClientToServerMessage.Type type = 1;
inline bool ClientToServerMessage::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientToServerMessage::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientToServerMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientToServerMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::debugservermessages::ClientToServerMessage_Type ClientToServerMessage::type() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.type)
  return static_cast< ::debugservermessages::ClientToServerMessage_Type >(type_);
}
inline void ClientToServerMessage::set_type(::debugservermessages::ClientToServerMessage_Type value) {
  assert(::debugservermessages::ClientToServerMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ClientToServerMessage.type)
}

// optional .debugservermessages.ClientToServerMessage.StartSessionMsg start_session_msg = 20;
inline bool ClientToServerMessage::has_start_session_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage::set_has_start_session_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage::clear_has_start_session_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage::clear_start_session_msg() {
  if (start_session_msg_ != NULL) start_session_msg_->Clear();
  clear_has_start_session_msg();
}
inline const ::debugservermessages::ClientToServerMessage_StartSessionMsg& ClientToServerMessage::_internal_start_session_msg() const {
  return *start_session_msg_;
}
inline const ::debugservermessages::ClientToServerMessage_StartSessionMsg& ClientToServerMessage::start_session_msg() const {
  const ::debugservermessages::ClientToServerMessage_StartSessionMsg* p = start_session_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.start_session_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ClientToServerMessage_StartSessionMsg*>(
      &::debugservermessages::_ClientToServerMessage_StartSessionMsg_default_instance_);
}
inline ::debugservermessages::ClientToServerMessage_StartSessionMsg* ClientToServerMessage::release_start_session_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ClientToServerMessage.start_session_msg)
  clear_has_start_session_msg();
  ::debugservermessages::ClientToServerMessage_StartSessionMsg* temp = start_session_msg_;
  start_session_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ClientToServerMessage_StartSessionMsg* ClientToServerMessage::mutable_start_session_msg() {
  set_has_start_session_msg();
  if (start_session_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ClientToServerMessage_StartSessionMsg>(GetArenaNoVirtual());
    start_session_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ClientToServerMessage.start_session_msg)
  return start_session_msg_;
}
inline void ClientToServerMessage::set_allocated_start_session_msg(::debugservermessages::ClientToServerMessage_StartSessionMsg* start_session_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_session_msg_;
  }
  if (start_session_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_session_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_session_msg, submessage_arena);
    }
    set_has_start_session_msg();
  } else {
    clear_has_start_session_msg();
  }
  start_session_msg_ = start_session_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ClientToServerMessage.start_session_msg)
}

// optional .debugservermessages.ClientToServerMessage.RunMsg run_msg = 21;
inline bool ClientToServerMessage::has_run_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage::set_has_run_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerMessage::clear_has_run_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerMessage::clear_run_msg() {
  if (run_msg_ != NULL) run_msg_->Clear();
  clear_has_run_msg();
}
inline const ::debugservermessages::ClientToServerMessage_RunMsg& ClientToServerMessage::_internal_run_msg() const {
  return *run_msg_;
}
inline const ::debugservermessages::ClientToServerMessage_RunMsg& ClientToServerMessage::run_msg() const {
  const ::debugservermessages::ClientToServerMessage_RunMsg* p = run_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.run_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ClientToServerMessage_RunMsg*>(
      &::debugservermessages::_ClientToServerMessage_RunMsg_default_instance_);
}
inline ::debugservermessages::ClientToServerMessage_RunMsg* ClientToServerMessage::release_run_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ClientToServerMessage.run_msg)
  clear_has_run_msg();
  ::debugservermessages::ClientToServerMessage_RunMsg* temp = run_msg_;
  run_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ClientToServerMessage_RunMsg* ClientToServerMessage::mutable_run_msg() {
  set_has_run_msg();
  if (run_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ClientToServerMessage_RunMsg>(GetArenaNoVirtual());
    run_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ClientToServerMessage.run_msg)
  return run_msg_;
}
inline void ClientToServerMessage::set_allocated_run_msg(::debugservermessages::ClientToServerMessage_RunMsg* run_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete run_msg_;
  }
  if (run_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      run_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, run_msg, submessage_arena);
    }
    set_has_run_msg();
  } else {
    clear_has_run_msg();
  }
  run_msg_ = run_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ClientToServerMessage.run_msg)
}

// optional .debugservermessages.ClientToServerMessage.GetMemoryRangeMsg get_memory_range_msg = 31;
inline bool ClientToServerMessage::has_get_memory_range_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerMessage::set_has_get_memory_range_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToServerMessage::clear_has_get_memory_range_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToServerMessage::clear_get_memory_range_msg() {
  if (get_memory_range_msg_ != NULL) get_memory_range_msg_->Clear();
  clear_has_get_memory_range_msg();
}
inline const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg& ClientToServerMessage::_internal_get_memory_range_msg() const {
  return *get_memory_range_msg_;
}
inline const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg& ClientToServerMessage::get_memory_range_msg() const {
  const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* p = get_memory_range_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ClientToServerMessage.get_memory_range_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg*>(
      &::debugservermessages::_ClientToServerMessage_GetMemoryRangeMsg_default_instance_);
}
inline ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* ClientToServerMessage::release_get_memory_range_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ClientToServerMessage.get_memory_range_msg)
  clear_has_get_memory_range_msg();
  ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* temp = get_memory_range_msg_;
  get_memory_range_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* ClientToServerMessage::mutable_get_memory_range_msg() {
  set_has_get_memory_range_msg();
  if (get_memory_range_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg>(GetArenaNoVirtual());
    get_memory_range_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ClientToServerMessage.get_memory_range_msg)
  return get_memory_range_msg_;
}
inline void ClientToServerMessage::set_allocated_get_memory_range_msg(::debugservermessages::ClientToServerMessage_GetMemoryRangeMsg* get_memory_range_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_memory_range_msg_;
  }
  if (get_memory_range_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_memory_range_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_memory_range_msg, submessage_arena);
    }
    set_has_get_memory_range_msg();
  } else {
    clear_has_get_memory_range_msg();
  }
  get_memory_range_msg_ = get_memory_range_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ClientToServerMessage.get_memory_range_msg)
}

// -------------------------------------------------------------------

// ServerToClientMessage_CmdErrorMsg

// required string description = 1;
inline bool ServerToClientMessage_CmdErrorMsg::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_CmdErrorMsg::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_CmdErrorMsg::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_CmdErrorMsg::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& ServerToClientMessage_CmdErrorMsg::description() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
  return description_.GetNoArena();
}
inline void ServerToClientMessage_CmdErrorMsg::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
}
#if LANG_CXX11
inline void ServerToClientMessage_CmdErrorMsg::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
}
#endif
inline void ServerToClientMessage_CmdErrorMsg::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
}
inline void ServerToClientMessage_CmdErrorMsg::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
}
inline ::std::string* ServerToClientMessage_CmdErrorMsg::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerToClientMessage_CmdErrorMsg::release_description() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerToClientMessage_CmdErrorMsg::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.CmdErrorMsg.description)
}

// -------------------------------------------------------------------

// ServerToClientMessage_StartSessionAckMsg

// required uint32 sizeof_size_t = 1;
inline bool ServerToClientMessage_StartSessionAckMsg::has_sizeof_size_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_StartSessionAckMsg::set_has_sizeof_size_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_StartSessionAckMsg::clear_has_sizeof_size_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_StartSessionAckMsg::clear_sizeof_size_t() {
  sizeof_size_t_ = 0u;
  clear_has_sizeof_size_t();
}
inline ::google::protobuf::uint32 ServerToClientMessage_StartSessionAckMsg::sizeof_size_t() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.StartSessionAckMsg.sizeof_size_t)
  return sizeof_size_t_;
}
inline void ServerToClientMessage_StartSessionAckMsg::set_sizeof_size_t(::google::protobuf::uint32 value) {
  set_has_sizeof_size_t();
  sizeof_size_t_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.StartSessionAckMsg.sizeof_size_t)
}

// -------------------------------------------------------------------

// ServerToClientMessage_VarInfo

// required string name = 1;
inline bool ServerToClientMessage_VarInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_VarInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_VarInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ServerToClientMessage_VarInfo::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.VarInfo.name)
  return name_.GetNoArena();
}
inline void ServerToClientMessage_VarInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.VarInfo.name)
}
#if LANG_CXX11
inline void ServerToClientMessage_VarInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.ServerToClientMessage.VarInfo.name)
}
#endif
inline void ServerToClientMessage_VarInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.ServerToClientMessage.VarInfo.name)
}
inline void ServerToClientMessage_VarInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.ServerToClientMessage.VarInfo.name)
}
inline ::std::string* ServerToClientMessage_VarInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.VarInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerToClientMessage_VarInfo::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.VarInfo.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerToClientMessage_VarInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.VarInfo.name)
}

// required string value = 2;
inline bool ServerToClientMessage_VarInfo::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerToClientMessage_VarInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerToClientMessage_VarInfo::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ServerToClientMessage_VarInfo::value() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.VarInfo.value)
  return value_.GetNoArena();
}
inline void ServerToClientMessage_VarInfo::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.VarInfo.value)
}
#if LANG_CXX11
inline void ServerToClientMessage_VarInfo::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.ServerToClientMessage.VarInfo.value)
}
#endif
inline void ServerToClientMessage_VarInfo::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.ServerToClientMessage.VarInfo.value)
}
inline void ServerToClientMessage_VarInfo::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.ServerToClientMessage.VarInfo.value)
}
inline ::std::string* ServerToClientMessage_VarInfo::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.VarInfo.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerToClientMessage_VarInfo::release_value() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.VarInfo.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerToClientMessage_VarInfo::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.VarInfo.value)
}

// required string type = 3;
inline bool ServerToClientMessage_VarInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerToClientMessage_VarInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerToClientMessage_VarInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& ServerToClientMessage_VarInfo::type() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.VarInfo.type)
  return type_.GetNoArena();
}
inline void ServerToClientMessage_VarInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.VarInfo.type)
}
#if LANG_CXX11
inline void ServerToClientMessage_VarInfo::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.ServerToClientMessage.VarInfo.type)
}
#endif
inline void ServerToClientMessage_VarInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.ServerToClientMessage.VarInfo.type)
}
inline void ServerToClientMessage_VarInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.ServerToClientMessage.VarInfo.type)
}
inline ::std::string* ServerToClientMessage_VarInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.VarInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerToClientMessage_VarInfo::release_type() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.VarInfo.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerToClientMessage_VarInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.VarInfo.type)
}

// required uint64 address = 4;
inline bool ServerToClientMessage_VarInfo::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerToClientMessage_VarInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerToClientMessage_VarInfo::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
  clear_has_address();
}
inline ::google::protobuf::uint64 ServerToClientMessage_VarInfo::address() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.VarInfo.address)
  return address_;
}
inline void ServerToClientMessage_VarInfo::set_address(::google::protobuf::uint64 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.VarInfo.address)
}

// required .debugservermessages.VarTypeDescriptor type_descriptor = 5;
inline bool ServerToClientMessage_VarInfo::has_type_descriptor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerToClientMessage_VarInfo::set_has_type_descriptor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerToClientMessage_VarInfo::clear_has_type_descriptor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerToClientMessage_VarInfo::clear_type_descriptor() {
  if (type_descriptor_ != NULL) type_descriptor_->Clear();
  clear_has_type_descriptor();
}
inline const ::debugservermessages::VarTypeDescriptor& ServerToClientMessage_VarInfo::_internal_type_descriptor() const {
  return *type_descriptor_;
}
inline const ::debugservermessages::VarTypeDescriptor& ServerToClientMessage_VarInfo::type_descriptor() const {
  const ::debugservermessages::VarTypeDescriptor* p = type_descriptor_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.VarInfo.type_descriptor)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeDescriptor*>(
      &::debugservermessages::_VarTypeDescriptor_default_instance_);
}
inline ::debugservermessages::VarTypeDescriptor* ServerToClientMessage_VarInfo::release_type_descriptor() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.VarInfo.type_descriptor)
  clear_has_type_descriptor();
  ::debugservermessages::VarTypeDescriptor* temp = type_descriptor_;
  type_descriptor_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeDescriptor* ServerToClientMessage_VarInfo::mutable_type_descriptor() {
  set_has_type_descriptor();
  if (type_descriptor_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeDescriptor>(GetArenaNoVirtual());
    type_descriptor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.VarInfo.type_descriptor)
  return type_descriptor_;
}
inline void ServerToClientMessage_VarInfo::set_allocated_type_descriptor(::debugservermessages::VarTypeDescriptor* type_descriptor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_descriptor_;
  }
  if (type_descriptor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_descriptor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_descriptor, submessage_arena);
    }
    set_has_type_descriptor();
  } else {
    clear_has_type_descriptor();
  }
  type_descriptor_ = type_descriptor;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.VarInfo.type_descriptor)
}

// -------------------------------------------------------------------

// ServerToClientMessage_StackFrameInfo

// required string func_name = 1;
inline bool ServerToClientMessage_StackFrameInfo::has_func_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_StackFrameInfo::set_has_func_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_has_func_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_func_name() {
  func_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_func_name();
}
inline const ::std::string& ServerToClientMessage_StackFrameInfo::func_name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
  return func_name_.GetNoArena();
}
inline void ServerToClientMessage_StackFrameInfo::set_func_name(const ::std::string& value) {
  set_has_func_name();
  func_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
}
#if LANG_CXX11
inline void ServerToClientMessage_StackFrameInfo::set_func_name(::std::string&& value) {
  set_has_func_name();
  func_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
}
#endif
inline void ServerToClientMessage_StackFrameInfo::set_func_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_func_name();
  func_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
}
inline void ServerToClientMessage_StackFrameInfo::set_func_name(const char* value, size_t size) {
  set_has_func_name();
  func_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
}
inline ::std::string* ServerToClientMessage_StackFrameInfo::mutable_func_name() {
  set_has_func_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
  return func_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerToClientMessage_StackFrameInfo::release_func_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
  if (!has_func_name()) {
    return NULL;
  }
  clear_has_func_name();
  return func_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerToClientMessage_StackFrameInfo::set_allocated_func_name(::std::string* func_name) {
  if (func_name != NULL) {
    set_has_func_name();
  } else {
    clear_has_func_name();
  }
  func_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), func_name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.StackFrameInfo.func_name)
}

// required .debugservermessages.LineInfo call_line = 2;
inline bool ServerToClientMessage_StackFrameInfo::has_call_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClientMessage_StackFrameInfo::set_has_call_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_has_call_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerToClientMessage_StackFrameInfo::clear_call_line() {
  if (call_line_ != NULL) call_line_->Clear();
  clear_has_call_line();
}
inline const ::debugservermessages::LineInfo& ServerToClientMessage_StackFrameInfo::_internal_call_line() const {
  return *call_line_;
}
inline const ::debugservermessages::LineInfo& ServerToClientMessage_StackFrameInfo::call_line() const {
  const ::debugservermessages::LineInfo* p = call_line_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.StackFrameInfo.call_line)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::LineInfo*>(
      &::debugservermessages::_LineInfo_default_instance_);
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_StackFrameInfo::release_call_line() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.StackFrameInfo.call_line)
  clear_has_call_line();
  ::debugservermessages::LineInfo* temp = call_line_;
  call_line_ = NULL;
  return temp;
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_StackFrameInfo::mutable_call_line() {
  set_has_call_line();
  if (call_line_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::LineInfo>(GetArenaNoVirtual());
    call_line_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.StackFrameInfo.call_line)
  return call_line_;
}
inline void ServerToClientMessage_StackFrameInfo::set_allocated_call_line(::debugservermessages::LineInfo* call_line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete call_line_;
  }
  if (call_line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      call_line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, call_line, submessage_arena);
    }
    set_has_call_line();
  } else {
    clear_has_call_line();
  }
  call_line_ = call_line;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.StackFrameInfo.call_line)
}

// repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 3;
inline int ServerToClientMessage_StackFrameInfo::vars_size() const {
  return vars_.size();
}
inline void ServerToClientMessage_StackFrameInfo::clear_vars() {
  vars_.Clear();
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_StackFrameInfo::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.StackFrameInfo.vars)
  return vars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
ServerToClientMessage_StackFrameInfo::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:debugservermessages.ServerToClientMessage.StackFrameInfo.vars)
  return &vars_;
}
inline const ::debugservermessages::ServerToClientMessage_VarInfo& ServerToClientMessage_StackFrameInfo::vars(int index) const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.StackFrameInfo.vars)
  return vars_.Get(index);
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_StackFrameInfo::add_vars() {
  // @@protoc_insertion_point(field_add:debugservermessages.ServerToClientMessage.StackFrameInfo.vars)
  return vars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
ServerToClientMessage_StackFrameInfo::vars() const {
  // @@protoc_insertion_point(field_list:debugservermessages.ServerToClientMessage.StackFrameInfo.vars)
  return vars_;
}

// -------------------------------------------------------------------

// ServerToClientMessage_BPHitMsg

// required .debugservermessages.LineInfo breakpoint = 1;
inline bool ServerToClientMessage_BPHitMsg::has_breakpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_BPHitMsg::set_has_breakpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_BPHitMsg::clear_has_breakpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_BPHitMsg::clear_breakpoint() {
  if (breakpoint_ != NULL) breakpoint_->Clear();
  clear_has_breakpoint();
}
inline const ::debugservermessages::LineInfo& ServerToClientMessage_BPHitMsg::_internal_breakpoint() const {
  return *breakpoint_;
}
inline const ::debugservermessages::LineInfo& ServerToClientMessage_BPHitMsg::breakpoint() const {
  const ::debugservermessages::LineInfo* p = breakpoint_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.BPHitMsg.breakpoint)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::LineInfo*>(
      &::debugservermessages::_LineInfo_default_instance_);
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_BPHitMsg::release_breakpoint() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.BPHitMsg.breakpoint)
  clear_has_breakpoint();
  ::debugservermessages::LineInfo* temp = breakpoint_;
  breakpoint_ = NULL;
  return temp;
}
inline ::debugservermessages::LineInfo* ServerToClientMessage_BPHitMsg::mutable_breakpoint() {
  set_has_breakpoint();
  if (breakpoint_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::LineInfo>(GetArenaNoVirtual());
    breakpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.BPHitMsg.breakpoint)
  return breakpoint_;
}
inline void ServerToClientMessage_BPHitMsg::set_allocated_breakpoint(::debugservermessages::LineInfo* breakpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete breakpoint_;
  }
  if (breakpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      breakpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, breakpoint, submessage_arena);
    }
    set_has_breakpoint();
  } else {
    clear_has_breakpoint();
  }
  breakpoint_ = breakpoint;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.BPHitMsg.breakpoint)
}

// repeated .debugservermessages.ServerToClientMessage.VarInfo vars = 2;
inline int ServerToClientMessage_BPHitMsg::vars_size() const {
  return vars_.size();
}
inline void ServerToClientMessage_BPHitMsg::clear_vars() {
  vars_.Clear();
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_BPHitMsg::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.BPHitMsg.vars)
  return vars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >*
ServerToClientMessage_BPHitMsg::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:debugservermessages.ServerToClientMessage.BPHitMsg.vars)
  return &vars_;
}
inline const ::debugservermessages::ServerToClientMessage_VarInfo& ServerToClientMessage_BPHitMsg::vars(int index) const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.BPHitMsg.vars)
  return vars_.Get(index);
}
inline ::debugservermessages::ServerToClientMessage_VarInfo* ServerToClientMessage_BPHitMsg::add_vars() {
  // @@protoc_insertion_point(field_add:debugservermessages.ServerToClientMessage.BPHitMsg.vars)
  return vars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_VarInfo >&
ServerToClientMessage_BPHitMsg::vars() const {
  // @@protoc_insertion_point(field_list:debugservermessages.ServerToClientMessage.BPHitMsg.vars)
  return vars_;
}

// -------------------------------------------------------------------

// ServerToClientMessage_StackTraceInfoMsg

// repeated .debugservermessages.ServerToClientMessage.StackFrameInfo frames = 1;
inline int ServerToClientMessage_StackTraceInfoMsg::frames_size() const {
  return frames_.size();
}
inline void ServerToClientMessage_StackTraceInfoMsg::clear_frames() {
  frames_.Clear();
}
inline ::debugservermessages::ServerToClientMessage_StackFrameInfo* ServerToClientMessage_StackTraceInfoMsg::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.StackTraceInfoMsg.frames)
  return frames_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >*
ServerToClientMessage_StackTraceInfoMsg::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:debugservermessages.ServerToClientMessage.StackTraceInfoMsg.frames)
  return &frames_;
}
inline const ::debugservermessages::ServerToClientMessage_StackFrameInfo& ServerToClientMessage_StackTraceInfoMsg::frames(int index) const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.StackTraceInfoMsg.frames)
  return frames_.Get(index);
}
inline ::debugservermessages::ServerToClientMessage_StackFrameInfo* ServerToClientMessage_StackTraceInfoMsg::add_frames() {
  // @@protoc_insertion_point(field_add:debugservermessages.ServerToClientMessage.StackTraceInfoMsg.frames)
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::ServerToClientMessage_StackFrameInfo >&
ServerToClientMessage_StackTraceInfoMsg::frames() const {
  // @@protoc_insertion_point(field_list:debugservermessages.ServerToClientMessage.StackTraceInfoMsg.frames)
  return frames_;
}

// -------------------------------------------------------------------

// ServerToClientMessage_MemoryRangeInfoMsg

// required bytes buf = 1;
inline bool ServerToClientMessage_MemoryRangeInfoMsg::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_has_buf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::clear_has_buf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::clear_buf() {
  buf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buf();
}
inline const ::std::string& ServerToClientMessage_MemoryRangeInfoMsg::buf() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
  return buf_.GetNoArena();
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_buf(const ::std::string& value) {
  set_has_buf();
  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
}
#if LANG_CXX11
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_buf(::std::string&& value) {
  set_has_buf();
  buf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
}
#endif
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_buf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buf();
  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_buf(const void* value, size_t size) {
  set_has_buf();
  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
}
inline ::std::string* ServerToClientMessage_MemoryRangeInfoMsg::mutable_buf() {
  set_has_buf();
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
  return buf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerToClientMessage_MemoryRangeInfoMsg::release_buf() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
  if (!has_buf()) {
    return NULL;
  }
  clear_has_buf();
  return buf_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerToClientMessage_MemoryRangeInfoMsg::set_allocated_buf(::std::string* buf) {
  if (buf != NULL) {
    set_has_buf();
  } else {
    clear_has_buf();
  }
  buf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buf);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg.buf)
}

// -------------------------------------------------------------------

// ServerToClientMessage

// required .debugservermessages.ServerToClientMessage.Type type = 1;
inline bool ServerToClientMessage::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerToClientMessage::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerToClientMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerToClientMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::debugservermessages::ServerToClientMessage_Type ServerToClientMessage::type() const {
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.type)
  return static_cast< ::debugservermessages::ServerToClientMessage_Type >(type_);
}
inline void ServerToClientMessage::set_type(::debugservermessages::ServerToClientMessage_Type value) {
  assert(::debugservermessages::ServerToClientMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.ServerToClientMessage.type)
}

// optional .debugservermessages.ServerToClientMessage.CmdErrorMsg cmd_error_msg = 21;
inline bool ServerToClientMessage::has_cmd_error_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerToClientMessage::set_has_cmd_error_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerToClientMessage::clear_has_cmd_error_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerToClientMessage::clear_cmd_error_msg() {
  if (cmd_error_msg_ != NULL) cmd_error_msg_->Clear();
  clear_has_cmd_error_msg();
}
inline const ::debugservermessages::ServerToClientMessage_CmdErrorMsg& ServerToClientMessage::_internal_cmd_error_msg() const {
  return *cmd_error_msg_;
}
inline const ::debugservermessages::ServerToClientMessage_CmdErrorMsg& ServerToClientMessage::cmd_error_msg() const {
  const ::debugservermessages::ServerToClientMessage_CmdErrorMsg* p = cmd_error_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.cmd_error_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ServerToClientMessage_CmdErrorMsg*>(
      &::debugservermessages::_ServerToClientMessage_CmdErrorMsg_default_instance_);
}
inline ::debugservermessages::ServerToClientMessage_CmdErrorMsg* ServerToClientMessage::release_cmd_error_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.cmd_error_msg)
  clear_has_cmd_error_msg();
  ::debugservermessages::ServerToClientMessage_CmdErrorMsg* temp = cmd_error_msg_;
  cmd_error_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ServerToClientMessage_CmdErrorMsg* ServerToClientMessage::mutable_cmd_error_msg() {
  set_has_cmd_error_msg();
  if (cmd_error_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ServerToClientMessage_CmdErrorMsg>(GetArenaNoVirtual());
    cmd_error_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.cmd_error_msg)
  return cmd_error_msg_;
}
inline void ServerToClientMessage::set_allocated_cmd_error_msg(::debugservermessages::ServerToClientMessage_CmdErrorMsg* cmd_error_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cmd_error_msg_;
  }
  if (cmd_error_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cmd_error_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cmd_error_msg, submessage_arena);
    }
    set_has_cmd_error_msg();
  } else {
    clear_has_cmd_error_msg();
  }
  cmd_error_msg_ = cmd_error_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.cmd_error_msg)
}

// optional .debugservermessages.ServerToClientMessage.StartSessionAckMsg start_session_ack_msg = 22;
inline bool ServerToClientMessage::has_start_session_ack_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerToClientMessage::set_has_start_session_ack_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerToClientMessage::clear_has_start_session_ack_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerToClientMessage::clear_start_session_ack_msg() {
  if (start_session_ack_msg_ != NULL) start_session_ack_msg_->Clear();
  clear_has_start_session_ack_msg();
}
inline const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg& ServerToClientMessage::_internal_start_session_ack_msg() const {
  return *start_session_ack_msg_;
}
inline const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg& ServerToClientMessage::start_session_ack_msg() const {
  const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* p = start_session_ack_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.start_session_ack_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ServerToClientMessage_StartSessionAckMsg*>(
      &::debugservermessages::_ServerToClientMessage_StartSessionAckMsg_default_instance_);
}
inline ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* ServerToClientMessage::release_start_session_ack_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.start_session_ack_msg)
  clear_has_start_session_ack_msg();
  ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* temp = start_session_ack_msg_;
  start_session_ack_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ServerToClientMessage_StartSessionAckMsg* ServerToClientMessage::mutable_start_session_ack_msg() {
  set_has_start_session_ack_msg();
  if (start_session_ack_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ServerToClientMessage_StartSessionAckMsg>(GetArenaNoVirtual());
    start_session_ack_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.start_session_ack_msg)
  return start_session_ack_msg_;
}
inline void ServerToClientMessage::set_allocated_start_session_ack_msg(::debugservermessages::ServerToClientMessage_StartSessionAckMsg* start_session_ack_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_session_ack_msg_;
  }
  if (start_session_ack_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_session_ack_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_session_ack_msg, submessage_arena);
    }
    set_has_start_session_ack_msg();
  } else {
    clear_has_start_session_ack_msg();
  }
  start_session_ack_msg_ = start_session_ack_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.start_session_ack_msg)
}

// optional .debugservermessages.ServerToClientMessage.BPHitMsg bphit_msg = 31;
inline bool ServerToClientMessage::has_bphit_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerToClientMessage::set_has_bphit_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerToClientMessage::clear_has_bphit_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerToClientMessage::clear_bphit_msg() {
  if (bphit_msg_ != NULL) bphit_msg_->Clear();
  clear_has_bphit_msg();
}
inline const ::debugservermessages::ServerToClientMessage_BPHitMsg& ServerToClientMessage::_internal_bphit_msg() const {
  return *bphit_msg_;
}
inline const ::debugservermessages::ServerToClientMessage_BPHitMsg& ServerToClientMessage::bphit_msg() const {
  const ::debugservermessages::ServerToClientMessage_BPHitMsg* p = bphit_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.bphit_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ServerToClientMessage_BPHitMsg*>(
      &::debugservermessages::_ServerToClientMessage_BPHitMsg_default_instance_);
}
inline ::debugservermessages::ServerToClientMessage_BPHitMsg* ServerToClientMessage::release_bphit_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.bphit_msg)
  clear_has_bphit_msg();
  ::debugservermessages::ServerToClientMessage_BPHitMsg* temp = bphit_msg_;
  bphit_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ServerToClientMessage_BPHitMsg* ServerToClientMessage::mutable_bphit_msg() {
  set_has_bphit_msg();
  if (bphit_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ServerToClientMessage_BPHitMsg>(GetArenaNoVirtual());
    bphit_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.bphit_msg)
  return bphit_msg_;
}
inline void ServerToClientMessage::set_allocated_bphit_msg(::debugservermessages::ServerToClientMessage_BPHitMsg* bphit_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bphit_msg_;
  }
  if (bphit_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bphit_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bphit_msg, submessage_arena);
    }
    set_has_bphit_msg();
  } else {
    clear_has_bphit_msg();
  }
  bphit_msg_ = bphit_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.bphit_msg)
}

// optional .debugservermessages.ServerToClientMessage.StackTraceInfoMsg stack_trace_info_msg = 41;
inline bool ServerToClientMessage::has_stack_trace_info_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerToClientMessage::set_has_stack_trace_info_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerToClientMessage::clear_has_stack_trace_info_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerToClientMessage::clear_stack_trace_info_msg() {
  if (stack_trace_info_msg_ != NULL) stack_trace_info_msg_->Clear();
  clear_has_stack_trace_info_msg();
}
inline const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg& ServerToClientMessage::_internal_stack_trace_info_msg() const {
  return *stack_trace_info_msg_;
}
inline const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg& ServerToClientMessage::stack_trace_info_msg() const {
  const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* p = stack_trace_info_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.stack_trace_info_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg*>(
      &::debugservermessages::_ServerToClientMessage_StackTraceInfoMsg_default_instance_);
}
inline ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* ServerToClientMessage::release_stack_trace_info_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.stack_trace_info_msg)
  clear_has_stack_trace_info_msg();
  ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* temp = stack_trace_info_msg_;
  stack_trace_info_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* ServerToClientMessage::mutable_stack_trace_info_msg() {
  set_has_stack_trace_info_msg();
  if (stack_trace_info_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ServerToClientMessage_StackTraceInfoMsg>(GetArenaNoVirtual());
    stack_trace_info_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.stack_trace_info_msg)
  return stack_trace_info_msg_;
}
inline void ServerToClientMessage::set_allocated_stack_trace_info_msg(::debugservermessages::ServerToClientMessage_StackTraceInfoMsg* stack_trace_info_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stack_trace_info_msg_;
  }
  if (stack_trace_info_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stack_trace_info_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stack_trace_info_msg, submessage_arena);
    }
    set_has_stack_trace_info_msg();
  } else {
    clear_has_stack_trace_info_msg();
  }
  stack_trace_info_msg_ = stack_trace_info_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.stack_trace_info_msg)
}

// optional .debugservermessages.ServerToClientMessage.MemoryRangeInfoMsg memory_range_info_msg = 51;
inline bool ServerToClientMessage::has_memory_range_info_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerToClientMessage::set_has_memory_range_info_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerToClientMessage::clear_has_memory_range_info_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerToClientMessage::clear_memory_range_info_msg() {
  if (memory_range_info_msg_ != NULL) memory_range_info_msg_->Clear();
  clear_has_memory_range_info_msg();
}
inline const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg& ServerToClientMessage::_internal_memory_range_info_msg() const {
  return *memory_range_info_msg_;
}
inline const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg& ServerToClientMessage::memory_range_info_msg() const {
  const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* p = memory_range_info_msg_;
  // @@protoc_insertion_point(field_get:debugservermessages.ServerToClientMessage.memory_range_info_msg)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg*>(
      &::debugservermessages::_ServerToClientMessage_MemoryRangeInfoMsg_default_instance_);
}
inline ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* ServerToClientMessage::release_memory_range_info_msg() {
  // @@protoc_insertion_point(field_release:debugservermessages.ServerToClientMessage.memory_range_info_msg)
  clear_has_memory_range_info_msg();
  ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* temp = memory_range_info_msg_;
  memory_range_info_msg_ = NULL;
  return temp;
}
inline ::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* ServerToClientMessage::mutable_memory_range_info_msg() {
  set_has_memory_range_info_msg();
  if (memory_range_info_msg_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg>(GetArenaNoVirtual());
    memory_range_info_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.ServerToClientMessage.memory_range_info_msg)
  return memory_range_info_msg_;
}
inline void ServerToClientMessage::set_allocated_memory_range_info_msg(::debugservermessages::ServerToClientMessage_MemoryRangeInfoMsg* memory_range_info_msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete memory_range_info_msg_;
  }
  if (memory_range_info_msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      memory_range_info_msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, memory_range_info_msg, submessage_arena);
    }
    set_has_memory_range_info_msg();
  } else {
    clear_has_memory_range_info_msg();
  }
  memory_range_info_msg_ = memory_range_info_msg;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.ServerToClientMessage.memory_range_info_msg)
}

// -------------------------------------------------------------------

// LineInfo

// required string file = 1;
inline bool LineInfo::has_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineInfo::set_has_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineInfo::clear_has_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineInfo::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file();
}
inline const ::std::string& LineInfo::file() const {
  // @@protoc_insertion_point(field_get:debugservermessages.LineInfo.file)
  return file_.GetNoArena();
}
inline void LineInfo::set_file(const ::std::string& value) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.LineInfo.file)
}
#if LANG_CXX11
inline void LineInfo::set_file(::std::string&& value) {
  set_has_file();
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.LineInfo.file)
}
#endif
inline void LineInfo::set_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.LineInfo.file)
}
inline void LineInfo::set_file(const char* value, size_t size) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.LineInfo.file)
}
inline ::std::string* LineInfo::mutable_file() {
  set_has_file();
  // @@protoc_insertion_point(field_mutable:debugservermessages.LineInfo.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LineInfo::release_file() {
  // @@protoc_insertion_point(field_release:debugservermessages.LineInfo.file)
  if (!has_file()) {
    return NULL;
  }
  clear_has_file();
  return file_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LineInfo::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    set_has_file();
  } else {
    clear_has_file();
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.LineInfo.file)
}

// required uint32 lineno = 2;
inline bool LineInfo::has_lineno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineInfo::set_has_lineno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineInfo::clear_has_lineno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineInfo::clear_lineno() {
  lineno_ = 0u;
  clear_has_lineno();
}
inline ::google::protobuf::uint32 LineInfo::lineno() const {
  // @@protoc_insertion_point(field_get:debugservermessages.LineInfo.lineno)
  return lineno_;
}
inline void LineInfo::set_lineno(::google::protobuf::uint32 value) {
  set_has_lineno();
  lineno_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.LineInfo.lineno)
}

// -------------------------------------------------------------------

// VarTypeDescriptor

// required .debugservermessages.VarTypeDescriptor.Tag tag = 1;
inline bool VarTypeDescriptor::has_tag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VarTypeDescriptor::set_has_tag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VarTypeDescriptor::clear_has_tag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VarTypeDescriptor::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::debugservermessages::VarTypeDescriptor_Tag VarTypeDescriptor::tag() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.tag)
  return static_cast< ::debugservermessages::VarTypeDescriptor_Tag >(tag_);
}
inline void VarTypeDescriptor::set_tag(::debugservermessages::VarTypeDescriptor_Tag value) {
  assert(::debugservermessages::VarTypeDescriptor_Tag_IsValid(value));
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeDescriptor.tag)
}

// optional .debugservermessages.VarTypeBasic type_basic = 11;
inline bool VarTypeDescriptor::has_type_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeDescriptor::set_has_type_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeDescriptor::clear_has_type_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeDescriptor::clear_type_basic() {
  if (type_basic_ != NULL) type_basic_->Clear();
  clear_has_type_basic();
}
inline const ::debugservermessages::VarTypeBasic& VarTypeDescriptor::_internal_type_basic() const {
  return *type_basic_;
}
inline const ::debugservermessages::VarTypeBasic& VarTypeDescriptor::type_basic() const {
  const ::debugservermessages::VarTypeBasic* p = type_basic_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.type_basic)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeBasic*>(
      &::debugservermessages::_VarTypeBasic_default_instance_);
}
inline ::debugservermessages::VarTypeBasic* VarTypeDescriptor::release_type_basic() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeDescriptor.type_basic)
  clear_has_type_basic();
  ::debugservermessages::VarTypeBasic* temp = type_basic_;
  type_basic_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeBasic* VarTypeDescriptor::mutable_type_basic() {
  set_has_type_basic();
  if (type_basic_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeBasic>(GetArenaNoVirtual());
    type_basic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeDescriptor.type_basic)
  return type_basic_;
}
inline void VarTypeDescriptor::set_allocated_type_basic(::debugservermessages::VarTypeBasic* type_basic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_basic_;
  }
  if (type_basic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_basic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_basic, submessage_arena);
    }
    set_has_type_basic();
  } else {
    clear_has_type_basic();
  }
  type_basic_ = type_basic;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeDescriptor.type_basic)
}

// optional .debugservermessages.VarTypePointer type_pointer = 12;
inline bool VarTypeDescriptor::has_type_pointer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeDescriptor::set_has_type_pointer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeDescriptor::clear_has_type_pointer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeDescriptor::clear_type_pointer() {
  if (type_pointer_ != NULL) type_pointer_->Clear();
  clear_has_type_pointer();
}
inline const ::debugservermessages::VarTypePointer& VarTypeDescriptor::_internal_type_pointer() const {
  return *type_pointer_;
}
inline const ::debugservermessages::VarTypePointer& VarTypeDescriptor::type_pointer() const {
  const ::debugservermessages::VarTypePointer* p = type_pointer_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.type_pointer)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypePointer*>(
      &::debugservermessages::_VarTypePointer_default_instance_);
}
inline ::debugservermessages::VarTypePointer* VarTypeDescriptor::release_type_pointer() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeDescriptor.type_pointer)
  clear_has_type_pointer();
  ::debugservermessages::VarTypePointer* temp = type_pointer_;
  type_pointer_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypePointer* VarTypeDescriptor::mutable_type_pointer() {
  set_has_type_pointer();
  if (type_pointer_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypePointer>(GetArenaNoVirtual());
    type_pointer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeDescriptor.type_pointer)
  return type_pointer_;
}
inline void VarTypeDescriptor::set_allocated_type_pointer(::debugservermessages::VarTypePointer* type_pointer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_pointer_;
  }
  if (type_pointer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_pointer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_pointer, submessage_arena);
    }
    set_has_type_pointer();
  } else {
    clear_has_type_pointer();
  }
  type_pointer_ = type_pointer;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeDescriptor.type_pointer)
}

// optional .debugservermessages.VarTypeArray type_array = 13;
inline bool VarTypeDescriptor::has_type_array() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarTypeDescriptor::set_has_type_array() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarTypeDescriptor::clear_has_type_array() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarTypeDescriptor::clear_type_array() {
  if (type_array_ != NULL) type_array_->Clear();
  clear_has_type_array();
}
inline const ::debugservermessages::VarTypeArray& VarTypeDescriptor::_internal_type_array() const {
  return *type_array_;
}
inline const ::debugservermessages::VarTypeArray& VarTypeDescriptor::type_array() const {
  const ::debugservermessages::VarTypeArray* p = type_array_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.type_array)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeArray*>(
      &::debugservermessages::_VarTypeArray_default_instance_);
}
inline ::debugservermessages::VarTypeArray* VarTypeDescriptor::release_type_array() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeDescriptor.type_array)
  clear_has_type_array();
  ::debugservermessages::VarTypeArray* temp = type_array_;
  type_array_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeArray* VarTypeDescriptor::mutable_type_array() {
  set_has_type_array();
  if (type_array_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeArray>(GetArenaNoVirtual());
    type_array_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeDescriptor.type_array)
  return type_array_;
}
inline void VarTypeDescriptor::set_allocated_type_array(::debugservermessages::VarTypeArray* type_array) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_array_;
  }
  if (type_array) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_array = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_array, submessage_arena);
    }
    set_has_type_array();
  } else {
    clear_has_type_array();
  }
  type_array_ = type_array;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeDescriptor.type_array)
}

// optional .debugservermessages.VarTypeVector type_vector = 14;
inline bool VarTypeDescriptor::has_type_vector() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VarTypeDescriptor::set_has_type_vector() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VarTypeDescriptor::clear_has_type_vector() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VarTypeDescriptor::clear_type_vector() {
  if (type_vector_ != NULL) type_vector_->Clear();
  clear_has_type_vector();
}
inline const ::debugservermessages::VarTypeVector& VarTypeDescriptor::_internal_type_vector() const {
  return *type_vector_;
}
inline const ::debugservermessages::VarTypeVector& VarTypeDescriptor::type_vector() const {
  const ::debugservermessages::VarTypeVector* p = type_vector_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.type_vector)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeVector*>(
      &::debugservermessages::_VarTypeVector_default_instance_);
}
inline ::debugservermessages::VarTypeVector* VarTypeDescriptor::release_type_vector() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeDescriptor.type_vector)
  clear_has_type_vector();
  ::debugservermessages::VarTypeVector* temp = type_vector_;
  type_vector_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeVector* VarTypeDescriptor::mutable_type_vector() {
  set_has_type_vector();
  if (type_vector_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeVector>(GetArenaNoVirtual());
    type_vector_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeDescriptor.type_vector)
  return type_vector_;
}
inline void VarTypeDescriptor::set_allocated_type_vector(::debugservermessages::VarTypeVector* type_vector) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_vector_;
  }
  if (type_vector) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_vector = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_vector, submessage_arena);
    }
    set_has_type_vector();
  } else {
    clear_has_type_vector();
  }
  type_vector_ = type_vector;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeDescriptor.type_vector)
}

// optional .debugservermessages.VarTypeTypedef type_typedef = 15;
inline bool VarTypeDescriptor::has_type_typedef() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VarTypeDescriptor::set_has_type_typedef() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VarTypeDescriptor::clear_has_type_typedef() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VarTypeDescriptor::clear_type_typedef() {
  if (type_typedef_ != NULL) type_typedef_->Clear();
  clear_has_type_typedef();
}
inline const ::debugservermessages::VarTypeTypedef& VarTypeDescriptor::_internal_type_typedef() const {
  return *type_typedef_;
}
inline const ::debugservermessages::VarTypeTypedef& VarTypeDescriptor::type_typedef() const {
  const ::debugservermessages::VarTypeTypedef* p = type_typedef_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.type_typedef)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeTypedef*>(
      &::debugservermessages::_VarTypeTypedef_default_instance_);
}
inline ::debugservermessages::VarTypeTypedef* VarTypeDescriptor::release_type_typedef() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeDescriptor.type_typedef)
  clear_has_type_typedef();
  ::debugservermessages::VarTypeTypedef* temp = type_typedef_;
  type_typedef_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeTypedef* VarTypeDescriptor::mutable_type_typedef() {
  set_has_type_typedef();
  if (type_typedef_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeTypedef>(GetArenaNoVirtual());
    type_typedef_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeDescriptor.type_typedef)
  return type_typedef_;
}
inline void VarTypeDescriptor::set_allocated_type_typedef(::debugservermessages::VarTypeTypedef* type_typedef) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_typedef_;
  }
  if (type_typedef) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_typedef = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_typedef, submessage_arena);
    }
    set_has_type_typedef();
  } else {
    clear_has_type_typedef();
  }
  type_typedef_ = type_typedef;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeDescriptor.type_typedef)
}

// optional .debugservermessages.VarTypeEnum type_enum = 16;
inline bool VarTypeDescriptor::has_type_enum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VarTypeDescriptor::set_has_type_enum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VarTypeDescriptor::clear_has_type_enum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VarTypeDescriptor::clear_type_enum() {
  if (type_enum_ != NULL) type_enum_->Clear();
  clear_has_type_enum();
}
inline const ::debugservermessages::VarTypeEnum& VarTypeDescriptor::_internal_type_enum() const {
  return *type_enum_;
}
inline const ::debugservermessages::VarTypeEnum& VarTypeDescriptor::type_enum() const {
  const ::debugservermessages::VarTypeEnum* p = type_enum_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.type_enum)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeEnum*>(
      &::debugservermessages::_VarTypeEnum_default_instance_);
}
inline ::debugservermessages::VarTypeEnum* VarTypeDescriptor::release_type_enum() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeDescriptor.type_enum)
  clear_has_type_enum();
  ::debugservermessages::VarTypeEnum* temp = type_enum_;
  type_enum_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeEnum* VarTypeDescriptor::mutable_type_enum() {
  set_has_type_enum();
  if (type_enum_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeEnum>(GetArenaNoVirtual());
    type_enum_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeDescriptor.type_enum)
  return type_enum_;
}
inline void VarTypeDescriptor::set_allocated_type_enum(::debugservermessages::VarTypeEnum* type_enum) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_enum_;
  }
  if (type_enum) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_enum = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_enum, submessage_arena);
    }
    set_has_type_enum();
  } else {
    clear_has_type_enum();
  }
  type_enum_ = type_enum;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeDescriptor.type_enum)
}

// optional .debugservermessages.VarTypeStruct type_struct = 17;
inline bool VarTypeDescriptor::has_type_struct() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VarTypeDescriptor::set_has_type_struct() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VarTypeDescriptor::clear_has_type_struct() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VarTypeDescriptor::clear_type_struct() {
  if (type_struct_ != NULL) type_struct_->Clear();
  clear_has_type_struct();
}
inline const ::debugservermessages::VarTypeStruct& VarTypeDescriptor::_internal_type_struct() const {
  return *type_struct_;
}
inline const ::debugservermessages::VarTypeStruct& VarTypeDescriptor::type_struct() const {
  const ::debugservermessages::VarTypeStruct* p = type_struct_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeDescriptor.type_struct)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeStruct*>(
      &::debugservermessages::_VarTypeStruct_default_instance_);
}
inline ::debugservermessages::VarTypeStruct* VarTypeDescriptor::release_type_struct() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeDescriptor.type_struct)
  clear_has_type_struct();
  ::debugservermessages::VarTypeStruct* temp = type_struct_;
  type_struct_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeStruct* VarTypeDescriptor::mutable_type_struct() {
  set_has_type_struct();
  if (type_struct_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeStruct>(GetArenaNoVirtual());
    type_struct_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeDescriptor.type_struct)
  return type_struct_;
}
inline void VarTypeDescriptor::set_allocated_type_struct(::debugservermessages::VarTypeStruct* type_struct) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_struct_;
  }
  if (type_struct) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type_struct = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_struct, submessage_arena);
    }
    set_has_type_struct();
  } else {
    clear_has_type_struct();
  }
  type_struct_ = type_struct;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeDescriptor.type_struct)
}

// -------------------------------------------------------------------

// VarTypeBasic

// required .debugservermessages.VarTypeBasic.Tag tag = 1;
inline bool VarTypeBasic::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarTypeBasic::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarTypeBasic::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarTypeBasic::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::debugservermessages::VarTypeBasic_Tag VarTypeBasic::tag() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeBasic.tag)
  return static_cast< ::debugservermessages::VarTypeBasic_Tag >(tag_);
}
inline void VarTypeBasic::set_tag(::debugservermessages::VarTypeBasic_Tag value) {
  assert(::debugservermessages::VarTypeBasic_Tag_IsValid(value));
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeBasic.tag)
}

// required uint64 size_nbits = 2;
inline bool VarTypeBasic::has_size_nbits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeBasic::set_has_size_nbits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeBasic::clear_has_size_nbits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeBasic::clear_size_nbits() {
  size_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_size_nbits();
}
inline ::google::protobuf::uint64 VarTypeBasic::size_nbits() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeBasic.size_nbits)
  return size_nbits_;
}
inline void VarTypeBasic::set_size_nbits(::google::protobuf::uint64 value) {
  set_has_size_nbits();
  size_nbits_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeBasic.size_nbits)
}

// required string name = 20;
inline bool VarTypeBasic::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeBasic::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeBasic::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeBasic::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarTypeBasic::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeBasic.name)
  return name_.GetNoArena();
}
inline void VarTypeBasic::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeBasic.name)
}
#if LANG_CXX11
inline void VarTypeBasic::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.VarTypeBasic.name)
}
#endif
inline void VarTypeBasic::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.VarTypeBasic.name)
}
inline void VarTypeBasic::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.VarTypeBasic.name)
}
inline ::std::string* VarTypeBasic::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeBasic.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarTypeBasic::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeBasic.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarTypeBasic::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeBasic.name)
}

// -------------------------------------------------------------------

// VarTypePointer

// required .debugservermessages.VarTypeDescriptor pointee = 1;
inline bool VarTypePointer::has_pointee() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypePointer::set_has_pointee() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypePointer::clear_has_pointee() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypePointer::clear_pointee() {
  if (pointee_ != NULL) pointee_->Clear();
  clear_has_pointee();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypePointer::_internal_pointee() const {
  return *pointee_;
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypePointer::pointee() const {
  const ::debugservermessages::VarTypeDescriptor* p = pointee_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypePointer.pointee)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeDescriptor*>(
      &::debugservermessages::_VarTypeDescriptor_default_instance_);
}
inline ::debugservermessages::VarTypeDescriptor* VarTypePointer::release_pointee() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypePointer.pointee)
  clear_has_pointee();
  ::debugservermessages::VarTypeDescriptor* temp = pointee_;
  pointee_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypePointer::mutable_pointee() {
  set_has_pointee();
  if (pointee_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeDescriptor>(GetArenaNoVirtual());
    pointee_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypePointer.pointee)
  return pointee_;
}
inline void VarTypePointer::set_allocated_pointee(::debugservermessages::VarTypeDescriptor* pointee) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pointee_;
  }
  if (pointee) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pointee = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pointee, submessage_arena);
    }
    set_has_pointee();
  } else {
    clear_has_pointee();
  }
  pointee_ = pointee;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypePointer.pointee)
}

// -------------------------------------------------------------------

// VarTypeArray

// required .debugservermessages.VarTypeDescriptor element = 1;
inline bool VarTypeArray::has_element() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeArray::set_has_element() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeArray::clear_has_element() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeArray::clear_element() {
  if (element_ != NULL) element_->Clear();
  clear_has_element();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeArray::_internal_element() const {
  return *element_;
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeArray::element() const {
  const ::debugservermessages::VarTypeDescriptor* p = element_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeArray.element)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeDescriptor*>(
      &::debugservermessages::_VarTypeDescriptor_default_instance_);
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeArray::release_element() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeArray.element)
  clear_has_element();
  ::debugservermessages::VarTypeDescriptor* temp = element_;
  element_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeArray::mutable_element() {
  set_has_element();
  if (element_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeDescriptor>(GetArenaNoVirtual());
    element_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeArray.element)
  return element_;
}
inline void VarTypeArray::set_allocated_element(::debugservermessages::VarTypeDescriptor* element) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete element_;
  }
  if (element) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      element = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    set_has_element();
  } else {
    clear_has_element();
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeArray.element)
}

// repeated uint64 dimensions = 2;
inline int VarTypeArray::dimensions_size() const {
  return dimensions_.size();
}
inline void VarTypeArray::clear_dimensions() {
  dimensions_.Clear();
}
inline ::google::protobuf::uint64 VarTypeArray::dimensions(int index) const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeArray.dimensions)
  return dimensions_.Get(index);
}
inline void VarTypeArray::set_dimensions(int index, ::google::protobuf::uint64 value) {
  dimensions_.Set(index, value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeArray.dimensions)
}
inline void VarTypeArray::add_dimensions(::google::protobuf::uint64 value) {
  dimensions_.Add(value);
  // @@protoc_insertion_point(field_add:debugservermessages.VarTypeArray.dimensions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
VarTypeArray::dimensions() const {
  // @@protoc_insertion_point(field_list:debugservermessages.VarTypeArray.dimensions)
  return dimensions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
VarTypeArray::mutable_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:debugservermessages.VarTypeArray.dimensions)
  return &dimensions_;
}

// -------------------------------------------------------------------

// VarTypeEnum_EnumEntry

// required string name = 1;
inline bool VarTypeEnum_EnumEntry::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeEnum_EnumEntry::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeEnum_EnumEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeEnum_EnumEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarTypeEnum_EnumEntry::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeEnum.EnumEntry.name)
  return name_.GetNoArena();
}
inline void VarTypeEnum_EnumEntry::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeEnum.EnumEntry.name)
}
#if LANG_CXX11
inline void VarTypeEnum_EnumEntry::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.VarTypeEnum.EnumEntry.name)
}
#endif
inline void VarTypeEnum_EnumEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.VarTypeEnum.EnumEntry.name)
}
inline void VarTypeEnum_EnumEntry::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.VarTypeEnum.EnumEntry.name)
}
inline ::std::string* VarTypeEnum_EnumEntry::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeEnum.EnumEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarTypeEnum_EnumEntry::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeEnum.EnumEntry.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarTypeEnum_EnumEntry::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeEnum.EnumEntry.name)
}

// required uint64 value = 2;
inline bool VarTypeEnum_EnumEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeEnum_EnumEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeEnum_EnumEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeEnum_EnumEntry::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 VarTypeEnum_EnumEntry::value() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeEnum.EnumEntry.value)
  return value_;
}
inline void VarTypeEnum_EnumEntry::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeEnum.EnumEntry.value)
}

// -------------------------------------------------------------------

// VarTypeEnum

// required string name = 1;
inline bool VarTypeEnum::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeEnum::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeEnum::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeEnum::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarTypeEnum::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeEnum.name)
  return name_.GetNoArena();
}
inline void VarTypeEnum::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeEnum.name)
}
#if LANG_CXX11
inline void VarTypeEnum::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.VarTypeEnum.name)
}
#endif
inline void VarTypeEnum::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.VarTypeEnum.name)
}
inline void VarTypeEnum::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.VarTypeEnum.name)
}
inline ::std::string* VarTypeEnum::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeEnum.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarTypeEnum::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeEnum.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarTypeEnum::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeEnum.name)
}

// repeated .debugservermessages.VarTypeEnum.EnumEntry entries = 2;
inline int VarTypeEnum::entries_size() const {
  return entries_.size();
}
inline void VarTypeEnum::clear_entries() {
  entries_.Clear();
}
inline ::debugservermessages::VarTypeEnum_EnumEntry* VarTypeEnum::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeEnum.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >*
VarTypeEnum::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:debugservermessages.VarTypeEnum.entries)
  return &entries_;
}
inline const ::debugservermessages::VarTypeEnum_EnumEntry& VarTypeEnum::entries(int index) const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeEnum.entries)
  return entries_.Get(index);
}
inline ::debugservermessages::VarTypeEnum_EnumEntry* VarTypeEnum::add_entries() {
  // @@protoc_insertion_point(field_add:debugservermessages.VarTypeEnum.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeEnum_EnumEntry >&
VarTypeEnum::entries() const {
  // @@protoc_insertion_point(field_list:debugservermessages.VarTypeEnum.entries)
  return entries_;
}

// -------------------------------------------------------------------

// VarTypeStruct_StructMember

// required string name = 1;
inline bool VarTypeStruct_StructMember::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeStruct_StructMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeStruct_StructMember::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarTypeStruct_StructMember::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeStruct.StructMember.name)
  return name_.GetNoArena();
}
inline void VarTypeStruct_StructMember::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeStruct.StructMember.name)
}
#if LANG_CXX11
inline void VarTypeStruct_StructMember::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.VarTypeStruct.StructMember.name)
}
#endif
inline void VarTypeStruct_StructMember::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.VarTypeStruct.StructMember.name)
}
inline void VarTypeStruct_StructMember::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.VarTypeStruct.StructMember.name)
}
inline ::std::string* VarTypeStruct_StructMember::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeStruct.StructMember.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarTypeStruct_StructMember::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeStruct.StructMember.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarTypeStruct_StructMember::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeStruct.StructMember.name)
}

// required uint64 size_nbits = 2;
inline bool VarTypeStruct_StructMember::has_size_nbits() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_size_nbits() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarTypeStruct_StructMember::clear_has_size_nbits() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarTypeStruct_StructMember::clear_size_nbits() {
  size_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_size_nbits();
}
inline ::google::protobuf::uint64 VarTypeStruct_StructMember::size_nbits() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeStruct.StructMember.size_nbits)
  return size_nbits_;
}
inline void VarTypeStruct_StructMember::set_size_nbits(::google::protobuf::uint64 value) {
  set_has_size_nbits();
  size_nbits_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeStruct.StructMember.size_nbits)
}

// required uint64 align_nbits = 3;
inline bool VarTypeStruct_StructMember::has_align_nbits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_align_nbits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VarTypeStruct_StructMember::clear_has_align_nbits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VarTypeStruct_StructMember::clear_align_nbits() {
  align_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_align_nbits();
}
inline ::google::protobuf::uint64 VarTypeStruct_StructMember::align_nbits() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeStruct.StructMember.align_nbits)
  return align_nbits_;
}
inline void VarTypeStruct_StructMember::set_align_nbits(::google::protobuf::uint64 value) {
  set_has_align_nbits();
  align_nbits_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeStruct.StructMember.align_nbits)
}

// required uint64 offset_nbits = 4;
inline bool VarTypeStruct_StructMember::has_offset_nbits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_offset_nbits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VarTypeStruct_StructMember::clear_has_offset_nbits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VarTypeStruct_StructMember::clear_offset_nbits() {
  offset_nbits_ = GOOGLE_ULONGLONG(0);
  clear_has_offset_nbits();
}
inline ::google::protobuf::uint64 VarTypeStruct_StructMember::offset_nbits() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeStruct.StructMember.offset_nbits)
  return offset_nbits_;
}
inline void VarTypeStruct_StructMember::set_offset_nbits(::google::protobuf::uint64 value) {
  set_has_offset_nbits();
  offset_nbits_ = value;
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeStruct.StructMember.offset_nbits)
}

// required .debugservermessages.VarTypeDescriptor type = 20;
inline bool VarTypeStruct_StructMember::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeStruct_StructMember::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeStruct_StructMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeStruct_StructMember::clear_type() {
  if (type_ != NULL) type_->Clear();
  clear_has_type();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeStruct_StructMember::_internal_type() const {
  return *type_;
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeStruct_StructMember::type() const {
  const ::debugservermessages::VarTypeDescriptor* p = type_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeStruct.StructMember.type)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeDescriptor*>(
      &::debugservermessages::_VarTypeDescriptor_default_instance_);
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeStruct_StructMember::release_type() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeStruct.StructMember.type)
  clear_has_type();
  ::debugservermessages::VarTypeDescriptor* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeStruct_StructMember::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeDescriptor>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeStruct.StructMember.type)
  return type_;
}
inline void VarTypeStruct_StructMember::set_allocated_type(::debugservermessages::VarTypeDescriptor* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeStruct.StructMember.type)
}

// -------------------------------------------------------------------

// VarTypeStruct

// required string name = 1;
inline bool VarTypeStruct::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeStruct::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeStruct::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeStruct::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarTypeStruct::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeStruct.name)
  return name_.GetNoArena();
}
inline void VarTypeStruct::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeStruct.name)
}
#if LANG_CXX11
inline void VarTypeStruct::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.VarTypeStruct.name)
}
#endif
inline void VarTypeStruct::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.VarTypeStruct.name)
}
inline void VarTypeStruct::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.VarTypeStruct.name)
}
inline ::std::string* VarTypeStruct::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeStruct.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarTypeStruct::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeStruct.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarTypeStruct::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeStruct.name)
}

// repeated .debugservermessages.VarTypeStruct.StructMember members = 2;
inline int VarTypeStruct::members_size() const {
  return members_.size();
}
inline void VarTypeStruct::clear_members() {
  members_.Clear();
}
inline ::debugservermessages::VarTypeStruct_StructMember* VarTypeStruct::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeStruct.members)
  return members_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >*
VarTypeStruct::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:debugservermessages.VarTypeStruct.members)
  return &members_;
}
inline const ::debugservermessages::VarTypeStruct_StructMember& VarTypeStruct::members(int index) const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeStruct.members)
  return members_.Get(index);
}
inline ::debugservermessages::VarTypeStruct_StructMember* VarTypeStruct::add_members() {
  // @@protoc_insertion_point(field_add:debugservermessages.VarTypeStruct.members)
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::debugservermessages::VarTypeStruct_StructMember >&
VarTypeStruct::members() const {
  // @@protoc_insertion_point(field_list:debugservermessages.VarTypeStruct.members)
  return members_;
}

// -------------------------------------------------------------------

// VarTypeVector

// required string name = 1;
inline bool VarTypeVector::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeVector::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeVector::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeVector::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarTypeVector::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeVector.name)
  return name_.GetNoArena();
}
inline void VarTypeVector::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeVector.name)
}
#if LANG_CXX11
inline void VarTypeVector::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.VarTypeVector.name)
}
#endif
inline void VarTypeVector::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.VarTypeVector.name)
}
inline void VarTypeVector::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.VarTypeVector.name)
}
inline ::std::string* VarTypeVector::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeVector.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarTypeVector::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeVector.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarTypeVector::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeVector.name)
}

// -------------------------------------------------------------------

// VarTypeTypedef

// required string name = 1;
inline bool VarTypeTypedef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarTypeTypedef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarTypeTypedef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarTypeTypedef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VarTypeTypedef::name() const {
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeTypedef.name)
  return name_.GetNoArena();
}
inline void VarTypeTypedef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:debugservermessages.VarTypeTypedef.name)
}
#if LANG_CXX11
inline void VarTypeTypedef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:debugservermessages.VarTypeTypedef.name)
}
#endif
inline void VarTypeTypedef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:debugservermessages.VarTypeTypedef.name)
}
inline void VarTypeTypedef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:debugservermessages.VarTypeTypedef.name)
}
inline ::std::string* VarTypeTypedef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeTypedef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarTypeTypedef::release_name() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeTypedef.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarTypeTypedef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeTypedef.name)
}

// required .debugservermessages.VarTypeDescriptor original_type = 2;
inline bool VarTypeTypedef::has_original_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarTypeTypedef::set_has_original_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarTypeTypedef::clear_has_original_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarTypeTypedef::clear_original_type() {
  if (original_type_ != NULL) original_type_->Clear();
  clear_has_original_type();
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeTypedef::_internal_original_type() const {
  return *original_type_;
}
inline const ::debugservermessages::VarTypeDescriptor& VarTypeTypedef::original_type() const {
  const ::debugservermessages::VarTypeDescriptor* p = original_type_;
  // @@protoc_insertion_point(field_get:debugservermessages.VarTypeTypedef.original_type)
  return p != NULL ? *p : *reinterpret_cast<const ::debugservermessages::VarTypeDescriptor*>(
      &::debugservermessages::_VarTypeDescriptor_default_instance_);
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeTypedef::release_original_type() {
  // @@protoc_insertion_point(field_release:debugservermessages.VarTypeTypedef.original_type)
  clear_has_original_type();
  ::debugservermessages::VarTypeDescriptor* temp = original_type_;
  original_type_ = NULL;
  return temp;
}
inline ::debugservermessages::VarTypeDescriptor* VarTypeTypedef::mutable_original_type() {
  set_has_original_type();
  if (original_type_ == NULL) {
    auto* p = CreateMaybeMessage<::debugservermessages::VarTypeDescriptor>(GetArenaNoVirtual());
    original_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:debugservermessages.VarTypeTypedef.original_type)
  return original_type_;
}
inline void VarTypeTypedef::set_allocated_original_type(::debugservermessages::VarTypeDescriptor* original_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete original_type_;
  }
  if (original_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      original_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, original_type, submessage_arena);
    }
    set_has_original_type();
  } else {
    clear_has_original_type();
  }
  original_type_ = original_type;
  // @@protoc_insertion_point(field_set_allocated:debugservermessages.VarTypeTypedef.original_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace debugservermessages

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::debugservermessages::ClientToServerMessage_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::ClientToServerMessage_Type>() {
  return ::debugservermessages::ClientToServerMessage_Type_descriptor();
}
template <> struct is_proto_enum< ::debugservermessages::ServerToClientMessage_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::ServerToClientMessage_Type>() {
  return ::debugservermessages::ServerToClientMessage_Type_descriptor();
}
template <> struct is_proto_enum< ::debugservermessages::VarTypeDescriptor_Tag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::VarTypeDescriptor_Tag>() {
  return ::debugservermessages::VarTypeDescriptor_Tag_descriptor();
}
template <> struct is_proto_enum< ::debugservermessages::VarTypeBasic_Tag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::debugservermessages::VarTypeBasic_Tag>() {
  return ::debugservermessages::VarTypeBasic_Tag_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_debugservermessages_2eproto
