/*
 * Part of the control flow tests that check vectorization of control flow statements.
 *
 * Tests vectorization of 17 levels and the most inner level depend on thread id - shouldn't be vectorized.
 *
 * @param in
 * 		The input array.
 * @param out
 * 		The output array.
 *
 */
__kernel void
cf_17_levels ( __global const float *in,
		__global float *out)
{
	int gid = get_global_id(0);

	int tmp = 0;
	int tmp2 = 0;
	float tmp3 = 0;
	int tmp4 = 0;
	short tmp5 = 0;
	uchar tmp6 = 0;

	for (int i = 0; i < 10; i++) {

		tmp = i * 16 + in[0];

		while ((tmp % 2 == 0) && (tmp != 0)) {

			tmp = tmp / 2;

			if(abs(tmp)> 3) {

				if (tmp <= 20) {

					goto label1;

				} else {

					switch ( tmp % 3) {

						case 0:
						// TODO : go to end? should it be vectorized?
						if (tmp> 5) {
							goto label3;
						}
						break;

						case 1:
						tmp++;
						// fall through

						default:

						label1:
						tmp2 = tmp * 5;

						while (min(tmp2, 56)> 0) {

							tmp2--;

							label3:
							do {

								if (tmp2 + tmp < 100) {

									for (int j = max(tmp2 + tmp, 0); j < 50; j++) {

										tmp3 = tmp / tmp2;

										if (tmp3 < 1) {

											while (tmp3> -100) {

												tmp3=tmp3-1.;

												for (int k = min(tmp3 * tmp3, 30.0f); k> 0; k--) {

													tmp4 = min((int)abs((int)((tmp3 - tmp2) * tmp)), (int)160);

													do {

														if (tmp4 % 3 == 0) {

															label2:

															if ( tmp4 * tmp3> 0) {

																tmp5 = min((int)abs((tmp2 - tmp4) * 120), (int)1024);

																while ((tmp5 % 2 == 0) && (tmp5 != 0)) {

																	tmp5 = tmp5 / 4;

																	for (int l = 0; l < min((float)abs(tmp5), in[gid]); l++) {

																		tmp2--;

																		tmp6 = abs(tmp2);
																	}

																}

															}

														} else {
															goto label2;

														}

														tmp4 = tmp4 / 4;

													}while (tmp4> 0);
												}
											}
										}

									}
								}

								tmp2 = tmp2 / 2;

								if(tmp2> 100) {
									tmp2 = 100;
								}

							}while ((tmp2 % 2 == 0) && (tmp2 != 0));

						}
					}
				}
			}
		}
	}

	out[gid] = tmp + tmp2 + tmp3 + tmp4 + tmp5 + tmp6;

}
