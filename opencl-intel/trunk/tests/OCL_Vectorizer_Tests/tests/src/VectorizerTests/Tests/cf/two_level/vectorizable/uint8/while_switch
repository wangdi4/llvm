/*
 * Part of the control flow tests that check vectorization of control flow statements.
 *
 * Tests the LLVM switch instruction inseide the while statement when both their conditions
 * depend on uint and don't depend on thread id.
 *
 * @param in
 * 		The input array.
 * @param out
 * 		The output array.
 *
 */
__kernel void
while_switch (	__global const float *in,
		__global float *out,  const uint8 uint8Arg1)
{
	int gid = get_global_id(0);

	int i = 0;

	uint tmp1 = add_sat(uint8Arg1.s2 + uint8Arg1.s5, uint8Arg1.s3);
	float tmp2 = 0;

	while ((tmp1 / 2 > 0) && (i < 2048)) {

		tmp1 = tmp1 / 2;
		i++;

		// i will always be positive here
		switch (max(uint8Arg1.x, uint8Arg1.y) % min(i, 3)) {

		case 0:
			tmp2 += in[gid];
			break;

		case 1:
			tmp2 = clamp(tmp2, (float)uint8Arg1.s7,  (float)(uint8Arg1.s0 + uint8Arg1.s5 + (in[gid] * uint8Arg1.s4)));
			// fall through

		case 2:
			tmp2 = mix(tmp2, gid * tmp2, cbrt(tmp2));
			// fall through


		default:
			tmp2 = fast_distance(tmp2 * gid, in[gid]);
			break;

		}

	}

		out[gid] = tmp2 + in[gid];

}
