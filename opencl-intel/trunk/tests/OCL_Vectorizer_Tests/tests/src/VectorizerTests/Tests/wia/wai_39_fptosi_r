//The 'fptosi' instruction converts its floating point operand into the nearest (rounding towards zero) signed integer value.
// If the value cannot fit in ty2, the results are undefined
//can be used to performance mesuarment of uniform fptosi testing



__kernel void wai_39_fptosi_r ( __global  float *in,__global int4 *out)
{
	int gid=get_global_id(0);	
	int i=2,j,k,l;
	out[gid] = 0;    //UNIFORM
	
	int4 i_value1_u=1,i_value2_u=in[1];
	int2 i2_value1_u=1,i2_value2_u=in[1];
	
	int4 i_value1_c=1+gid,i_value2_c=in[1]+gid;  //cons
	int2 i2_value1_c=1+gid,i2_value2_c=in[1]+gid;
	
	int i_value1_s=(1+gid)*2,i_value2_s=(in[1]+gid)*4;  //str
	int2 i2_value1_s=(1+gid)*i+1,i2_value2_s=(in[1]+gid)*i; //str
	
	float4 f_value1_u=1.,f_value2_u=in[gid];
	float2 f2_value1_u=1,f2_value2_u=in[1];
	
	float4 f_value1_c=1.+gid,f_value2_c=in[1]+gid;  //cons
	float2 f2_value1_c=1+gid,f2_value2_c=in[1]+gid;
	
	float4 f_value1_s=(1+gid)*2,f_value2_s=(in[1]+gid)*4;  //str
	float2 f2_value1_s=(1+gid)*i+1,f2_value2_s=(in[1]+gid)*i; //str
	
	double4 d_value1_u=1.,d_value2_u=in[1];
	double2 d2_value1_u=1,d2_value2_u=in[1];
	
	double4 d_value1_c=1.+gid,d_value2_c=in[1]+gid;  //cons
	double2 d2_value1_c=1+gid,d2_value2_c=in[1]+gid;
	
	double4 d_value1_s=(1+gid)*2,d_value2_s=(in[1]+gid)*4;  //str
	double2 d2_value1_s=(1+gid)*i+1,d2_value2_s=(in[1]+gid)*i; //str
	
	out[gid] =(f_value2_u.s0, f_value2_u.s1, f_value2_u.s2,f_value2_u.s3);;  //uniform
	
	for (i=1;i<256;i++) 
	{
		out[gid].s1=f_value1_u.s2+12.34+in[gid]; //random
		if (out[gid].s1+1>15) 
		{
		;
			for (j=1;j<3;j++)
			{
			out[gid]+=f_value2_u.s1+gid;    
				for (j=1;j<14;j+=2) 
				{
					out[gid]=(f_value2_u.s0, f_value2_u.s1, f_value2_u.s2,f_value2_u.s3)+out[gid]+gid;
				}
			}
		}
	}
	
	out[gid]=(f_value2_u.s0, f_value2_u.s1, f_value2_u.s2,f_value2_u.s3)+out[gid]+gid;

}