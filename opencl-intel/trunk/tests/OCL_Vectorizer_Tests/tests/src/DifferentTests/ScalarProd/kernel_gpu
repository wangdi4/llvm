/*******************************************************************************
// Calculate scalar products of VectorN vectors of ElementN elements on DEVICE
// Parameters restrictions:
// 1) ElementN must be multiply of vector size
*******************************************************************************/
#define ElementN 4096
#define VectorN  4096
#define ACCUM_N	 256


/*******************************************************************************
// On G80-class hardware 24-bit multiplication takes 4 clocks per warp
// (the same as for floating point  multiplication and addition),
// whereas full 32-bit multiplication takes 16 clocks per warp.
// So if integer multiplication operands are  guaranteed to fit into 24 bits
// (always lie withtin [-8M, 8M - 1] range in signed case),
// explicit 24-bit multiplication is preferred for performance.
*******************************************************************************/
#define IMUL(a, b) mul24(a, b)

__kernel void scalarProd(__global float *d_C, __global float *d_A
	, __global float *d_B, __local float* accumResult)
{
	int localsize = get_local_size(0);/*args[0]; */
	int gtid = get_global_id(0);
	int ltid = get_local_id(0);
	int bid = get_group_id(0);
	int size = get_global_size(0);
	int GROUPS = size / localsize;
	
	/* Cycle through every pair of vectors */	
	for(int vec = bid; vec < VectorN; vec += GROUPS)
	{
		int vectorBase = IMUL(ElementN, vec);
        int vectorEnd  = vectorBase + ElementN;
		
		for(int iAccum = ltid; iAccum < ACCUM_N; iAccum += size) {
			float sum = 0;
			
			for(int pos = vectorBase + iAccum; pos < vectorEnd; pos += ACCUM_N)
				sum += d_A[pos] * d_B[pos];
			
			accumResult[iAccum] = sum;
			}
		
		/* Sum all the accumlator elements - Tree Recution */
		for(int stride = ACCUM_N / 2; stride > 0; stride >>= 1){
			barrier(CLK_LOCAL_MEM_FENCE);
			
			for(int iAccum = ltid; iAccum < stride; iAccum += size)
				accumResult[iAccum] += accumResult[stride + iAccum];
			}
		if(ltid == 0) d_C[vec] = accumResult[0];
	}
}

