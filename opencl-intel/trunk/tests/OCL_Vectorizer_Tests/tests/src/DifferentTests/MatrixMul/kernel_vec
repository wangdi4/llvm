/* This is a vector version for Matrix Multiply, assuming that the Matrix dim in Multiply of
	vector size */
	
#define VECTOR_SIZE 4
#define IMUL(X,Y) mul24(x,y);

__kernel void multiply(__global int* arg, __global const float *data1, __global float *data2
	, __global float *data3)
{	
	int M = arg[0];	/* ;HA height of A */
	int N = arg[1];	/* ;WA width of	 A */
	int R = arg[2];	/* ;WB width of  B */
	
	/* global thread index */
	int ty = VECTOR_SIZE * get_global_id(0);
	int tx = VECTOR_SIZE * get_global_id(1);
	
	/* if we have passed the matrix limit we may do nothing */
	if(tx >= R || ty >= M) return ;	
	
	/* local thread index */
	/* In CPU we may intialize this to zero, assuming there's one thread in local pool*/
	
	int ly = get_local_id(0);
	int lx = get_local_id(1);
	
	/* group index */
	int by = get_global_id(0);
	int bx = get_global_id(1);	
	
	/* group dim (BLOCK) */
	int dim = arg[3] * VECTOR_SIZE;	
	
	/* Index of the first sub-matrix of A (data1) processed by the block */
	int aBegin	= N * dim * by;

	/* Index of the last sub-matrix of A (data1) processed by the block	 */
	int aEnd	= aBegin + N - 1;
	
	/* Step size used to iterate through the sub-matrices of A (data1)	 */
	int aStep = dim;

	/* Index of the first sub-matrix of B processed by the block */
	int bBegin = dim * bx;

	/* Step size used to iterate through the sub-matrices of B   */
	int bStep = dim * R;
	
	/* Csub is used to store the elements of the block sub-matrix
	   that is computed by the thread	*/
	float4 Csub[4];
	
	/* Initializing */
	for(int i=0; i<4; ++i) {
		Csub[i] = make_float4(0,0,0,0);
		/*
		Csub[i].x = 0;
		Csub[i].y = 0;
		Csub[i].z = 0;
		Csub[i].w = 0;
		*/
		}

	float4 As[4];
	float4 Bs[4];
	
	/* Loop over all the sub-matrices of A and B
	   required to compute the block sub-matrix	*/
	for(int a = aBegin, b = bBegin;
			a <= aEnd;
			a += aStep, b += bStep) {	
			
			/* Note */
			/* As is vertical vectors memory which used to store the 
			   sub-Matrix of data1	*/
			/* Bs is horzinal vectors memory which used to store the
			   sub-Matrix of data2 */
			   
			/* Load the matrices from global memory to the vectors; */
			for(int i=0; i<4; ++i) {
				*((float4*)(As + i)) = *((float4*)(data1 + a + N*i));
				/*
				As[i].x = data1[a + N * i + 0];
				As[i].y = data1[a + N * i + 1];
				As[i].z = data1[a + N * i + 2];
				As[i].w = data1[a + N * i + 3];	
				*/																											
				}
				
			for(int i=0; i<4; ++i) {
				Bs[i].x = data2[b + i];
				Bs[i].y = data2[b + R * 1 + i];
				Bs[i].z = data2[b + R * 2 + i];
				Bs[i].w = data2[b + R * 3 + i];
				}
				
			/* Multiplying the vectors */
			float4 res;
			for(int i=0; i<4; ++i) {
				res = As[i] * Bs[0];
				Csub[i].x += res.x + res.y + res.z + res.w;
				res	= As[i] * Bs[1];
				Csub[i].y += res.x + res.y + res.z + res.w;
				res	= As[i] * Bs[2];
				Csub[i].z += res.x + res.y + res.z + res.w;
				res	= As[i] * Bs[3];
				Csub[i].w += res.x + res.y + res.z + res.w;											
				}
			}
			
	/* Write the block sub-matrix to device memory; */
	int c = ty * R + tx;
	unsigned int indx_in = c + R*ly + lx;
	
	for(int j=0; j<4; ++j) {
		int indx = indx_in + j*R;
		data3[indx +0] = Csub[j].x;
		data3[indx +1] = Csub[j].y;
		data3[indx +2] = Csub[j].z;
		data3[indx +3] = Csub[j].w;
		}
}
