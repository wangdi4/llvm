// Copyright (c) 2008-2009 Intel Corporation
// All rights reserved.
// 
// WARRANTY DISCLAIMER
// 
// THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING ANY WAY OF THE USE OF THESE
// MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Intel Corporation is the author of the Materials, and requests that all
// problem reports or change requests be submitted to it directly

///////////////////////////////////////////////////////////
//  lrb_program_service.h
//  
//  Created on:      17-Aug-2009
//  Original author: Peleg, Arnon
///////////////////////////////////////////////////////////
#if !defined(__LRB_PROGRAM_SERVICE_H__)
#define __LRB_PROGRAM_SERVICE_H__

#include <cl_device_api.h>
#include <cl_table.h>
#include <map>

namespace Intel { namespace OpenCL { namespace LRBAgent {

    //
    // Forward declaration
    //
    class XNWrapper;
    
    /************************************************************************
     * Kernel info is a struct that holds kernel's data.
     * such data are the kernel Id (Kernel obj. address on the device) and kernel Id
     * It may include more data which is generated by the device on build
     * TODO: identify which other data should be included in the kernel info
     ************************************************************************/
    struct sKernelInfo
    {
        cl_uint uiKernelHndl;
        char*   kernelName;
        // TODO: Add other info if required.
    };

    /************************************************************************
     * 
     ************************************************************************/
    struct sProgramEntry
    {
        cl_uint      uiBackendProgAddr; // On build the native provides the Prog address as an identifier, this is a 32 bit integer.
        cl_ulong     ulProgramBinHndl;  // Handle that returns from the LoadProgram interface - Build input
        cl_ulong     ulBuildOutputHndl; // Handle that returns from the LoadProgram interface - Build output (include kernel info)
        void*        pUserData;         // Data to be used when program build is done
        cl_uint      uiNumberOfKernels; // The number of kernels in the
        sKernelInfo* kernels;
    };

    /**********************************************************************************************
    * Class name:    LrbProgramService
    *
    * Description:    
    *       This class Interacts with compiler back end. The interaction is through XN API (XNWarraper)
    *       The service holds Program/Kernel handles and cache Kernel’s prototypes for validation.
    *
    * Author:        Arnon Peleg
    * Date:          Aug 2009
    /**********************************************************************************************/    
    class LrbProgramService
    {
    public:
        LrbProgramService( XNWrapper* pXnWrapper, fn_clDevBuildStatusUpdate* pclDevBuildStatusUpdate);
        ~LrbProgramService();

        //
        // The next commands are executed on the host
        //
        cl_int CreateProgram        (size_t binSize, const void* bin, cl_dev_binary_prop prop, cl_dev_program* prog);
        cl_int GetBuildLog          (cl_dev_program prog, size_t size, char* log, size_t* size_ret);
        cl_int GetSupportedBinaries ( cl_uint count, cl_prog_binary_desc* types, size_t* sizeRet );
        cl_int GetKernelId          (cl_dev_program prog, const char* name, cl_dev_kernel* kernelId);
        cl_int GetProgramKernels    (cl_dev_program prog, cl_uint numKernels, cl_dev_kernel* kernels, cl_uint* numKernelsRet);
        cl_int GetKernelInfo        (cl_dev_kernel kernel, cl_dev_kernel_info param, size_t valueSize, void* value, size_t* valueSizeRet);
        cl_int GetKernelParams      ( cl_dev_kernel kernel, cl_kernel_argument** ppArgsList, size_t* pArgsListSize );

        //
        // Only the functions below are doing a round trip to the device for execution.
        //
        cl_int BuildProgram         (cl_dev_program prog, const cl_char* options, void* userData);
        cl_int ReleaseProgram       (cl_dev_program prog);
        cl_int UnloadCompiler       ();
        cl_int GetProgramBinary     (cl_dev_program prog, size_t size, void* binary, size_t* sizeRet);

        //
        // Inter components public functions
        //
        cl_int NotifyBuildDone      (unsigned long prog);

    private:
        Intel::OpenCL::Utils::ClTable*          m_pPrograms;  // Table that holds all programs.
        std::map<cl_dev_kernel, sKernelInfo*>   m_pKernels; // Table that holds kernels for direct access on GetInfo functions.
        XNWrapper*                              m_pXnWrapper;
        fn_clDevBuildStatusUpdate*	            m_pclDevBuildStatusUpdate;        

        // Private functions
        void ParseBuildOutputBuffer( sProgramEntry* pProgEntry, void* pBuildOutputData);        

    };

}}};    // Intel::OpenCL::LRBAgent
#endif // __LRB_PROGRAM_SERVICE_H__
