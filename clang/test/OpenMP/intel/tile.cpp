// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -opaque-pointers -verify -triple x86_64-pc-linux-gnu -fopenmp -fopenmp-version=51 \
// RUN:   -fopenmp-late-outline -emit-llvm %s -o - | FileCheck %s

// expected-no-diagnostics
//
//  The implementation of standalone 'omp tile' completely reuses the community
//  codegen, and is therefore fully covered by the community lit tests.
//
//  When 'omp tile' is used under a late-outlined directive the original loop
//  counters must be handled on the late-outlined directive, otherwise they
//  would end up 'shared' by default.

void body(int);

// CHECK-LABEL: @_Z4foo1iii(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[START_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[END_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_0:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_1:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_2:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTFLOOR_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTILE_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[START:%.*]], ptr [[START_ADDR]], align 4
// CHECK-NEXT:    store i32 [[END:%.*]], ptr [[END_ADDR]], align 4
// CHECK-NEXT:    store i32 [[STEP:%.*]], ptr [[STEP_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[START_ADDR]], align 4
// CHECK-NEXT:    store i32 [[TMP0]], ptr [[DOTCAPTURE_EXPR_0]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[END_ADDR]], align 4
// CHECK-NEXT:    store i32 [[TMP1]], ptr [[DOTCAPTURE_EXPR_1]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[STEP_ADDR]], align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr [[DOTCAPTURE_EXPR_2]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_1]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_0]], align 4
// CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[TMP3]], [[TMP4]]
// CHECK-NEXT:    [[SUB1:%.*]] = sub i32 [[SUB]], 1
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_2]], align 4
// CHECK-NEXT:    [[ADD:%.*]] = add i32 [[SUB1]], [[TMP5]]
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_2]], align 4
// CHECK-NEXT:    [[DIV:%.*]] = udiv i32 [[ADD]], [[TMP6]]
// CHECK-NEXT:    [[SUB2:%.*]] = sub i32 [[DIV]], 1
// CHECK-NEXT:    store i32 [[SUB2]], ptr [[DOTCAPTURE_EXPR_3]], align 4
// CHECK-NEXT:    store i32 0, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_3]], align 4
// CHECK-NEXT:    [[ADD3:%.*]] = add i32 [[TMP8]], 1
// CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP7]], [[ADD3]]
// CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END15:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    store i32 [[TMP9]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND4:%.*]]
// CHECK:       for.cond4:
// CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_3]], align 4
// CHECK-NEXT:    [[ADD5:%.*]] = add i32 [[TMP11]], 1
// CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD6:%.*]] = add nsw i32 [[TMP12]], 5
// CHECK-NEXT:    [[CMP7:%.*]] = icmp ult i32 [[ADD5]], [[ADD6]]
// CHECK-NEXT:    br i1 [[CMP7]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK:       cond.true:
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_3]], align 4
// CHECK-NEXT:    [[ADD8:%.*]] = add i32 [[TMP13]], 1
// CHECK-NEXT:    br label [[COND_END:%.*]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD9:%.*]] = add nsw i32 [[TMP14]], 5
// CHECK-NEXT:    br label [[COND_END]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[ADD8]], [[COND_TRUE]] ], [ [[ADD9]], [[COND_FALSE]] ]
// CHECK-NEXT:    [[CMP10:%.*]] = icmp ult i32 [[TMP10]], [[COND]]
// CHECK-NEXT:    br i1 [[CMP10]], label [[FOR_BODY11:%.*]], label [[FOR_END:%.*]]
// CHECK:       for.body11:
// CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_0]], align 4
// CHECK-NEXT:    [[TMP16:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[DOTCAPTURE_EXPR_2]], align 4
// CHECK-NEXT:    [[MUL:%.*]] = mul i32 [[TMP16]], [[TMP17]]
// CHECK-NEXT:    [[ADD12:%.*]] = add i32 [[TMP15]], [[MUL]]
// CHECK-NEXT:    store i32 [[ADD12]], ptr [[I]], align 4
// CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    call void @_Z4bodyi(i32 noundef [[TMP18]])
// CHECK-NEXT:    br label [[FOR_INC:%.*]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[TMP19:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP19]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND4]], !llvm.loop [[LOOP3:![0-9]+]]
// CHECK:       for.end:
// CHECK-NEXT:    br label [[FOR_INC13:%.*]]
// CHECK:       for.inc13:
// CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD14:%.*]] = add nsw i32 [[TMP20]], 5
// CHECK-NEXT:    store i32 [[ADD14]], ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP5:![0-9]+]]
// CHECK:       for.end15:
// CHECK-NEXT:    ret void
//
void foo1(int start, int end, int step) {
  int i;
  #pragma omp tile sizes(5)
  for (i = start; i < end; i += step)
    body(i);
}

// CHECK-LABEL: @_Z4foo2v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTFLOOR_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTFLOOR_1_IV_J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTILE_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTILE_1_IV_J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 0, ptr [[I]], align 4
// CHECK-NEXT:    store i32 0, ptr [[J]], align 4
// CHECK-NEXT:    store i32 0, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 8
// CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END31:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    store i32 0, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND1:%.*]]
// CHECK:       for.cond1:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i32 [[TMP1]], 4
// CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY3:%.*]], label [[FOR_END28:%.*]]
// CHECK:       for.body3:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND4:%.*]]
// CHECK:       for.cond4:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP4]], 4
// CHECK-NEXT:    [[CMP5:%.*]] = icmp slt i32 8, [[ADD]]
// CHECK-NEXT:    br i1 [[CMP5]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK:       cond.true:
// CHECK-NEXT:    br label [[COND_END:%.*]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD6:%.*]] = add nsw i32 [[TMP5]], 4
// CHECK-NEXT:    br label [[COND_END]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 8, [[COND_TRUE]] ], [ [[ADD6]], [[COND_FALSE]] ]
// CHECK-NEXT:    [[CMP7:%.*]] = icmp slt i32 [[TMP3]], [[COND]]
// CHECK-NEXT:    br i1 [[CMP7]], label [[FOR_BODY8:%.*]], label [[FOR_END25:%.*]]
// CHECK:       for.body8:
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP6]], 1
// CHECK-NEXT:    [[ADD9:%.*]] = add nsw i32 0, [[MUL]]
// CHECK-NEXT:    store i32 [[ADD9]], ptr [[I]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    store i32 [[TMP7]], ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND10:%.*]]
// CHECK:       for.cond10:
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD11:%.*]] = add nsw i32 [[TMP9]], 2
// CHECK-NEXT:    [[CMP12:%.*]] = icmp slt i32 4, [[ADD11]]
// CHECK-NEXT:    br i1 [[CMP12]], label [[COND_TRUE13:%.*]], label [[COND_FALSE14:%.*]]
// CHECK:       cond.true13:
// CHECK-NEXT:    br label [[COND_END16:%.*]]
// CHECK:       cond.false14:
// CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD15:%.*]] = add nsw i32 [[TMP10]], 2
// CHECK-NEXT:    br label [[COND_END16]]
// CHECK:       cond.end16:
// CHECK-NEXT:    [[COND17:%.*]] = phi i32 [ 4, [[COND_TRUE13]] ], [ [[ADD15]], [[COND_FALSE14]] ]
// CHECK-NEXT:    [[CMP18:%.*]] = icmp slt i32 [[TMP8]], [[COND17]]
// CHECK-NEXT:    br i1 [[CMP18]], label [[FOR_BODY19:%.*]], label [[FOR_END:%.*]]
// CHECK:       for.body19:
// CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[MUL20:%.*]] = mul nsw i32 [[TMP11]], 1
// CHECK-NEXT:    [[ADD21:%.*]] = add nsw i32 0, [[MUL20]]
// CHECK-NEXT:    store i32 [[ADD21]], ptr [[J]], align 4
// CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[J]], align 4
// CHECK-NEXT:    [[ADD22:%.*]] = add nsw i32 [[TMP12]], [[TMP13]]
// CHECK-NEXT:    call void @_Z4bodyi(i32 noundef [[ADD22]])
// CHECK-NEXT:    br label [[FOR_INC:%.*]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP14]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND10]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK:       for.end:
// CHECK-NEXT:    br label [[FOR_INC23:%.*]]
// CHECK:       for.inc23:
// CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[INC24:%.*]] = add nsw i32 [[TMP15]], 1
// CHECK-NEXT:    store i32 [[INC24]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND4]], !llvm.loop [[LOOP7:![0-9]+]]
// CHECK:       for.end25:
// CHECK-NEXT:    br label [[FOR_INC26:%.*]]
// CHECK:       for.inc26:
// CHECK-NEXT:    [[TMP16:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD27:%.*]] = add nsw i32 [[TMP16]], 2
// CHECK-NEXT:    store i32 [[ADD27]], ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND1]], !llvm.loop [[LOOP8:![0-9]+]]
// CHECK:       for.end28:
// CHECK-NEXT:    br label [[FOR_INC29:%.*]]
// CHECK:       for.inc29:
// CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD30:%.*]] = add nsw i32 [[TMP17]], 4
// CHECK-NEXT:    store i32 [[ADD30]], ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP9:![0-9]+]]
// CHECK:       for.end31:
// CHECK-NEXT:    ret void
//
void foo2() {
  #pragma omp tile sizes(4,2)  // evenly divisible
  for (int i = 0; i < 8; ++i)
    for (int j = 0; j < 4; ++j)
      body(i+j);
}

// CHECK-LABEL: @_Z4foo3v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTFLOOR_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTFLOOR_1_IV_J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTILE_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTILE_1_IV_J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 0, ptr [[I]], align 4
// CHECK-NEXT:    store i32 0, ptr [[J]], align 4
// CHECK-NEXT:    store i32 0, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP0]], 8
// CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END31:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    store i32 0, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND1:%.*]]
// CHECK:       for.cond1:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp slt i32 [[TMP1]], 4
// CHECK-NEXT:    br i1 [[CMP2]], label [[FOR_BODY3:%.*]], label [[FOR_END28:%.*]]
// CHECK:       for.body3:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    store i32 [[TMP2]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND4:%.*]]
// CHECK:       for.cond4:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP4]], 3
// CHECK-NEXT:    [[CMP5:%.*]] = icmp slt i32 8, [[ADD]]
// CHECK-NEXT:    br i1 [[CMP5]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK:       cond.true:
// CHECK-NEXT:    br label [[COND_END:%.*]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD6:%.*]] = add nsw i32 [[TMP5]], 3
// CHECK-NEXT:    br label [[COND_END]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 8, [[COND_TRUE]] ], [ [[ADD6]], [[COND_FALSE]] ]
// CHECK-NEXT:    [[CMP7:%.*]] = icmp slt i32 [[TMP3]], [[COND]]
// CHECK-NEXT:    br i1 [[CMP7]], label [[FOR_BODY8:%.*]], label [[FOR_END25:%.*]]
// CHECK:       for.body8:
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP6]], 1
// CHECK-NEXT:    [[ADD9:%.*]] = add nsw i32 0, [[MUL]]
// CHECK-NEXT:    store i32 [[ADD9]], ptr [[I]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    store i32 [[TMP7]], ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND10:%.*]]
// CHECK:       for.cond10:
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD11:%.*]] = add nsw i32 [[TMP9]], 3
// CHECK-NEXT:    [[CMP12:%.*]] = icmp slt i32 4, [[ADD11]]
// CHECK-NEXT:    br i1 [[CMP12]], label [[COND_TRUE13:%.*]], label [[COND_FALSE14:%.*]]
// CHECK:       cond.true13:
// CHECK-NEXT:    br label [[COND_END16:%.*]]
// CHECK:       cond.false14:
// CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD15:%.*]] = add nsw i32 [[TMP10]], 3
// CHECK-NEXT:    br label [[COND_END16]]
// CHECK:       cond.end16:
// CHECK-NEXT:    [[COND17:%.*]] = phi i32 [ 4, [[COND_TRUE13]] ], [ [[ADD15]], [[COND_FALSE14]] ]
// CHECK-NEXT:    [[CMP18:%.*]] = icmp slt i32 [[TMP8]], [[COND17]]
// CHECK-NEXT:    br i1 [[CMP18]], label [[FOR_BODY19:%.*]], label [[FOR_END:%.*]]
// CHECK:       for.body19:
// CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[MUL20:%.*]] = mul nsw i32 [[TMP11]], 1
// CHECK-NEXT:    [[ADD21:%.*]] = add nsw i32 0, [[MUL20]]
// CHECK-NEXT:    store i32 [[ADD21]], ptr [[J]], align 4
// CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[J]], align 4
// CHECK-NEXT:    [[ADD22:%.*]] = add nsw i32 [[TMP12]], [[TMP13]]
// CHECK-NEXT:    call void @_Z4bodyi(i32 noundef [[ADD22]])
// CHECK-NEXT:    br label [[FOR_INC:%.*]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP14]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND10]], !llvm.loop [[LOOP10:![0-9]+]]
// CHECK:       for.end:
// CHECK-NEXT:    br label [[FOR_INC23:%.*]]
// CHECK:       for.inc23:
// CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[INC24:%.*]] = add nsw i32 [[TMP15]], 1
// CHECK-NEXT:    store i32 [[INC24]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND4]], !llvm.loop [[LOOP11:![0-9]+]]
// CHECK:       for.end25:
// CHECK-NEXT:    br label [[FOR_INC26:%.*]]
// CHECK:       for.inc26:
// CHECK-NEXT:    [[TMP16:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD27:%.*]] = add nsw i32 [[TMP16]], 3
// CHECK-NEXT:    store i32 [[ADD27]], ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND1]], !llvm.loop [[LOOP12:![0-9]+]]
// CHECK:       for.end28:
// CHECK-NEXT:    br label [[FOR_INC29:%.*]]
// CHECK:       for.inc29:
// CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD30:%.*]] = add nsw i32 [[TMP17]], 3
// CHECK-NEXT:    store i32 [[ADD30]], ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP13:![0-9]+]]
// CHECK:       for.end31:
// CHECK-NEXT:    ret void
//
void foo3() {
  #pragma omp tile sizes(3,3) // not divisible
  for (int i = 0; i < 8; ++i)
    for (int j = 0; j < 4; ++j)
      body(i+j);
}

// CHECK-LABEL: @_Z4foo4v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTFLOOR_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTFLOOR_1_IV_J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTILE_0_IV_I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTILE_1_IV_J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 0, ptr [[I]], align 4
// CHECK-NEXT:    store i32 0, ptr [[J]], align 4
// CHECK-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK-NEXT:    store i32 1, ptr [[DOTOMP_UB]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PARALLEL.LOOP"(), "QUAL.OMP.PRIVATE"(ptr [[DOTFLOOR_0_IV_I]]), "QUAL.OMP.PRIVATE"(ptr [[DOTFLOOR_1_IV_J]]), "QUAL.OMP.NORMALIZED.IV"(ptr [[DOTOMP_IV]]), "QUAL.OMP.FIRSTPRIVATE"(ptr [[DOTOMP_LB]]), "QUAL.OMP.NORMALIZED.UB"(ptr [[DOTOMP_UB]]), "QUAL.OMP.PRIVATE"(ptr [[DOTTILE_0_IV_I]]), "QUAL.OMP.PRIVATE"(ptr [[I]]), "QUAL.OMP.PRIVATE"(ptr [[DOTTILE_1_IV_J]]), "QUAL.OMP.PRIVATE"(ptr [[J]]) ]
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK-NEXT:    store i32 [[TMP1]], ptr [[DOTOMP_IV]], align 4
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK:       omp.inner.for.cond:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp sle i32 [[TMP2]], [[TMP3]]
// CHECK-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK:       omp.inner.for.body:
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP4]], 4
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]]
// CHECK-NEXT:    store i32 [[ADD]], ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    store i32 0, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[CMP1:%.*]] = icmp slt i32 [[TMP5]], 4
// CHECK-NEXT:    br i1 [[CMP1]], label [[FOR_BODY:%.*]], label [[FOR_END28:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    store i32 [[TMP6]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND2:%.*]]
// CHECK:       for.cond2:
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD3:%.*]] = add nsw i32 [[TMP8]], 4
// CHECK-NEXT:    [[CMP4:%.*]] = icmp slt i32 8, [[ADD3]]
// CHECK-NEXT:    br i1 [[CMP4]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK:       cond.true:
// CHECK-NEXT:    br label [[COND_END:%.*]]
// CHECK:       cond.false:
// CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTFLOOR_0_IV_I]], align 4
// CHECK-NEXT:    [[ADD5:%.*]] = add nsw i32 [[TMP9]], 4
// CHECK-NEXT:    br label [[COND_END]]
// CHECK:       cond.end:
// CHECK-NEXT:    [[COND:%.*]] = phi i32 [ 8, [[COND_TRUE]] ], [ [[ADD5]], [[COND_FALSE]] ]
// CHECK-NEXT:    [[CMP6:%.*]] = icmp slt i32 [[TMP7]], [[COND]]
// CHECK-NEXT:    br i1 [[CMP6]], label [[FOR_BODY7:%.*]], label [[FOR_END25:%.*]]
// CHECK:       for.body7:
// CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[MUL8:%.*]] = mul nsw i32 [[TMP10]], 1
// CHECK-NEXT:    [[ADD9:%.*]] = add nsw i32 0, [[MUL8]]
// CHECK-NEXT:    store i32 [[ADD9]], ptr [[I]], align 4
// CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    store i32 [[TMP11]], ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND10:%.*]]
// CHECK:       for.cond10:
// CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD11:%.*]] = add nsw i32 [[TMP13]], 2
// CHECK-NEXT:    [[CMP12:%.*]] = icmp slt i32 4, [[ADD11]]
// CHECK-NEXT:    br i1 [[CMP12]], label [[COND_TRUE13:%.*]], label [[COND_FALSE14:%.*]]
// CHECK:       cond.true13:
// CHECK-NEXT:    br label [[COND_END16:%.*]]
// CHECK:       cond.false14:
// CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD15:%.*]] = add nsw i32 [[TMP14]], 2
// CHECK-NEXT:    br label [[COND_END16]]
// CHECK:       cond.end16:
// CHECK-NEXT:    [[COND17:%.*]] = phi i32 [ 4, [[COND_TRUE13]] ], [ [[ADD15]], [[COND_FALSE14]] ]
// CHECK-NEXT:    [[CMP18:%.*]] = icmp slt i32 [[TMP12]], [[COND17]]
// CHECK-NEXT:    br i1 [[CMP18]], label [[FOR_BODY19:%.*]], label [[FOR_END:%.*]]
// CHECK:       for.body19:
// CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[MUL20:%.*]] = mul nsw i32 [[TMP15]], 1
// CHECK-NEXT:    [[ADD21:%.*]] = add nsw i32 0, [[MUL20]]
// CHECK-NEXT:    store i32 [[ADD21]], ptr [[J]], align 4
// CHECK-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[J]], align 4
// CHECK-NEXT:    [[ADD22:%.*]] = add nsw i32 [[TMP16]], [[TMP17]]
// CHECK-NEXT:    call void @_Z4bodyi(i32 noundef [[ADD22]]) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    br label [[FOR_INC:%.*]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP18]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[DOTTILE_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND10]], !llvm.loop [[LOOP14:![0-9]+]]
// CHECK:       for.end:
// CHECK-NEXT:    br label [[FOR_INC23:%.*]]
// CHECK:       for.inc23:
// CHECK-NEXT:    [[TMP19:%.*]] = load i32, ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    [[INC24:%.*]] = add nsw i32 [[TMP19]], 1
// CHECK-NEXT:    store i32 [[INC24]], ptr [[DOTTILE_0_IV_I]], align 4
// CHECK-NEXT:    br label [[FOR_COND2]], !llvm.loop [[LOOP15:![0-9]+]]
// CHECK:       for.end25:
// CHECK-NEXT:    br label [[FOR_INC26:%.*]]
// CHECK:       for.inc26:
// CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    [[ADD27:%.*]] = add nsw i32 [[TMP20]], 2
// CHECK-NEXT:    store i32 [[ADD27]], ptr [[DOTFLOOR_1_IV_J]], align 4
// CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP16:![0-9]+]]
// CHECK:       for.end28:
// CHECK-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK:       omp.body.continue:
// CHECK-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK:       omp.inner.for.inc:
// CHECK-NEXT:    [[TMP21:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK-NEXT:    [[ADD29:%.*]] = add nsw i32 [[TMP21]], 1
// CHECK-NEXT:    store i32 [[ADD29]], ptr [[DOTOMP_IV]], align 4
// CHECK-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK:       omp.inner.for.end:
// CHECK-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK:       omp.loop.exit:
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.PARALLEL.LOOP"() ]
// CHECK-NEXT:    ret void
//
void foo4() {
  #pragma omp parallel for
  #pragma omp tile sizes(4,2)
  for (int i = 0; i < 8; ++i)
    for (int j = 0; j < 4; ++j)
      body(i+j);
}
