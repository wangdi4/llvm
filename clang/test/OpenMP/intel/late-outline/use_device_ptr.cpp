// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//INTEL_COLLAB
//RUN: %clang_cc1 -opaque-pointers -emit-llvm -o - -fopenmp -fopenmp-version=50 \
//RUN:  -fopenmp-late-outline \
//RUN:  -triple x86_64-unknown-linux-gnu %s | FileCheck %s

struct S {
  int a = 0;
  int *ptr = &a;
  int *&ref = ptr;
  int *aaptr = &a;
  S() {}
  void foo();
};

// CHECK-LABEL: define {{[^@]+}}@_ZN1S3fooEv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS:%.*]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[REF:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 2
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[REF]], align 8
// CHECK-NEXT:    [[AAPTR:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 3
// CHECK-NEXT:    [[PTR2:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[REF3:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[REF3]], align 8
// CHECK-NEXT:    [[AAPTR4:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 3
// CHECK-NEXT:    [[PTR5:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[PTR6:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[PTR6]], align 8
// CHECK-NEXT:    [[REF7:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 2
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[REF7]], align 8
// CHECK-NEXT:    [[REF8:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 2
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[REF8]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[TMP4]], align 8
// CHECK-NEXT:    [[AAPTR9:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 3
// CHECK-NEXT:    [[AAPTR10:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 3
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[AAPTR10]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr ptr, ptr [[AAPTR4]], i32 1
// CHECK-NEXT:    [[TMP8:%.*]] = ptrtoint ptr [[TMP7]] to i64
// CHECK-NEXT:    [[TMP9:%.*]] = ptrtoint ptr [[PTR2]] to i64
// CHECK-NEXT:    [[TMP10:%.*]] = sub i64 [[TMP8]], [[TMP9]]
// CHECK-NEXT:    [[TMP11:%.*]] = sdiv exact i64 [[TMP10]], ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
// CHECK-NEXT:    [[TMP12:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.USE_DEVICE_PTR:PTR_TO_PTR"(ptr [[PTR]], ptr [[TMP0]], ptr [[AAPTR]]), "QUAL.OMP.MAP.TOFROM"(ptr [[THIS1]], ptr [[PTR2]], i64 [[TMP11]], i64 0, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[PTR5]], ptr [[TMP2]], i64 0, i64 281474976710736, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[TMP3]], ptr [[TMP5]], i64 0, i64 281474976710736, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[AAPTR9]], ptr [[TMP6]], i64 0, i64 281474976710736, ptr null, ptr null) ]
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[A]], align 8
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP13]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[A]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[PTR]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr [[TMP14]], align 4
// CHECK-NEXT:    [[INC11:%.*]] = add nsw i32 [[TMP15]], 1
// CHECK-NEXT:    store i32 [[INC11]], ptr [[TMP14]], align 4
// CHECK-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[TMP16]], align 4
// CHECK-NEXT:    [[INC12:%.*]] = add nsw i32 [[TMP17]], 1
// CHECK-NEXT:    store i32 [[INC12]], ptr [[TMP16]], align 4
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP12]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void S::foo() {

  #pragma omp target data use_device_ptr(ptr, ref, aaptr)
  ++a, ++*ptr, ++*ref;
}


// CHECK-LABEL: define {{[^@]+}}@_Z3foov(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[J:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[K:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[REF:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[REF_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[I]], ptr [[J]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[J]], align 8
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[K]], align 8
// CHECK-NEXT:    store ptr [[K]], ptr [[REF]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[REF]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[K]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[REF]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[TMP3]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.USE_DEVICE_PTR:PTR_TO_PTR"(ptr [[K]], ptr [[TMP1]]), "QUAL.OMP.MAP.TOFROM"(ptr [[I]], ptr [[I]], i64 4, i64 3, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP2]], ptr [[TMP2]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP4]], ptr [[TMP4]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.LIVEIN"(ptr [[REF_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[REF_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP6]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[I]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[J]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = load i32, ptr [[TMP7]], align 4
// CHECK-NEXT:    [[INC1:%.*]] = add nsw i32 [[TMP8]], 1
// CHECK-NEXT:    store i32 [[INC1]], ptr [[TMP7]], align 4
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[K]], align 8
// CHECK-NEXT:    [[INCDEC_PTR:%.*]] = getelementptr inbounds i32, ptr [[TMP9]], i32 1
// CHECK-NEXT:    store ptr [[INCDEC_PTR]], ptr [[K]], align 8
// CHECK-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[REF_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP10]], align 8
// CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[TMP11]], align 4
// CHECK-NEXT:    [[INC2:%.*]] = add nsw i32 [[TMP12]], 1
// CHECK-NEXT:    store i32 [[INC2]], ptr [[TMP11]], align 4
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP5]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void foo() {
  int i;
  int &j = i;
  int *k = &j;
  int *&ref = k;

  #pragma omp target data map(tofrom: i) use_device_ptr(k, ref)
  {
    i++; j++; k++; ++*ref;
  }
}

// CHECK-LABEL: define {{[^@]+}}@main(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[A:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[PTR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[REF:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 8
// CHECK-NEXT:    [[REF_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-NEXT:    store float 0.000000e+00, ptr [[A]], align 4
// CHECK-NEXT:    store ptr [[A]], ptr [[PTR]], align 8
// CHECK-NEXT:    store ptr [[PTR]], ptr [[REF]], align 8
// CHECK-NEXT:    call void @_ZN1SC1Ev(ptr noundef nonnull align 8 dereferenceable(32) [[S]])
// CHECK-NEXT:    call void @_ZN1S3fooEv(ptr noundef nonnull align 8 dereferenceable(32) [[S]])
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[REF]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[PTR]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[REF]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[TMP2]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.USE_DEVICE_PTR:PTR_TO_PTR"(ptr [[PTR]], ptr [[TMP0]]), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP1]], ptr [[TMP1]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP3]], ptr [[TMP3]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.LIVEIN"(ptr [[REF_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[REF_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[PTR]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = load float, ptr [[TMP5]], align 4
// CHECK-NEXT:    [[INC:%.*]] = fadd float [[TMP6]], 1.000000e+00
// CHECK-NEXT:    store float [[INC]], ptr [[TMP5]], align 4
// CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[REF_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[TMP7]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr [[TMP8]], align 4
// CHECK-NEXT:    [[INC1:%.*]] = fadd float [[TMP9]], 1.000000e+00
// CHECK-NEXT:    store float [[INC1]], ptr [[TMP8]], align 4
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP4]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    [[TMP10:%.*]] = load float, ptr [[A]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fptosi float [[TMP10]] to i32
// CHECK-NEXT:    ret i32 [[CONV]]
//
int main() {
  float a = 0;
  float *ptr = &a;
  float *&ref = ptr;



  S s;
  s.foo();




  #pragma omp target data \
               use_device_ptr(ptr, ref)
  ++*ptr, ++*ref;
  return a;
}

// end INTEL_COLLAB
