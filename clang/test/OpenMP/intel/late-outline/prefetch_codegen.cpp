// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// INTEL_COLLAB
// RUN: %clang_cc1 -opaque-pointers -emit-llvm -o - -fopenmp -fopenmp-late-outline \
// RUN: -triple i386-unknown-unknown %s | \
// RUN: FileCheck %s --check-prefix=CHECK-32
//
// RUN: %clang_cc1 -opaque-pointers -emit-llvm -o - -fopenmp -fopenmp-late-outline \
// RUN: -triple x86_64-unknown-linux-gnu %s | FileCheck %s
//
// RUN: %clang_cc1 -opaque-pointers -emit-llvm -o - -fopenmp -fopenmp-late-outline \
// RUN: -triple x86_64-unknown-linux-gnu -DMULTI_DATA %s | FileCheck %s
//
// RUN: %clang_cc1 -opaque-pointers -fopenmp -fopenmp-late-outline \
// RUN: -triple x86_64-unknown-linux-gnu -emit-pch %s -o %t

// RUN: %clang_cc1 -opaque-pointers -fopenmp -fopenmp-late-outline \
// RUN: -triple x86_64-unknown-linux-gnu -include-pch %t \
// RUN: -emit-llvm %s -o - | FileCheck %s
//
// RUN: %clang_cc1 -opaque-pointers -fopenmp -fopenmp-late-outline -DMULTI_DATA \
// RUN: -triple x86_64-unknown-linux-gnu -emit-pch %s -o %t

// RUN: %clang_cc1 -opaque-pointers -fopenmp -fopenmp-late-outline -DMULTI_DATA \
// RUN: -triple x86_64-unknown-linux-gnu -include-pch %t \
// RUN: -emit-llvm %s -o - | FileCheck %s
//
// expected-no-diagnostics
#ifndef HEADER
#define HEADER

struct foobar {
  int i;
  double d[10];
};

foobar bar;

// CHECK-32-LABEL: @main(
// CHECK-32-NEXT:  entry:
// CHECK-32-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[ARGC_ADDR:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[ARGV_ADDR:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[A:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[B:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[FOO1:%.*]] = alloca [10 x i32], align 4
// CHECK-32-NEXT:    [[FOO2:%.*]] = alloca [10 x i32], align 4
// CHECK-32-NEXT:    [[P:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH1:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH3:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH5:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH6:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH7:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH8:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH9:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH10:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH11:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH12:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[I14:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[PP:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[PTR:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[PPTR:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH17:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH18:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-32-NEXT:    store i32 [[ARGC:%.*]], ptr [[ARGC_ADDR]], align 4
// CHECK-32-NEXT:    store ptr [[ARGV:%.*]], ptr [[ARGV_ADDR]], align 4
// CHECK-32-NEXT:    store i32 1, ptr [[I]], align 4
// CHECK-32-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [10 x i32], ptr [[FOO1]], i32 0, i32 0
// CHECK-32-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 4
// CHECK-32-NEXT:    store ptr [[FOO1]], ptr [[DOTTMP_PREFETCH]], align 4
// CHECK-32-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH]], i32 1, i32 1) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[FOO1]], i32 0, i32 1
// CHECK-32-NEXT:    store ptr [[ARRAYIDX]], ptr [[DOTTMP_PREFETCH1]], align 4
// CHECK-32-NEXT:    [[TMP1:%.*]] = load i32, ptr [[A]], align 4
// CHECK-32-NEXT:    [[TMP2:%.*]] = load i32, ptr [[B]], align 4
// CHECK-32-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], [[TMP2]]
// CHECK-32-NEXT:    [[TMP3:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH1]], i32 1, i32 2), "QUAL.OMP.IF"(i1 [[CMP]]) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP3]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    [[TMP4:%.*]] = load i32, ptr [[A]], align 4
// CHECK-32-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[TMP4]], 0
// CHECK-32-NEXT:    [[TMP5:%.*]] = load i32, ptr [[I]], align 4
// CHECK-32-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [10 x i32], ptr [[FOO1]], i32 0, i32 [[TMP5]]
// CHECK-32-NEXT:    store ptr [[ARRAYIDX4]], ptr [[DOTTMP_PREFETCH3]], align 4
// CHECK-32-NEXT:    [[TMP6:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.IF"(i1 [[CMP2]]), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH3]], i32 1, i32 3) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP6]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    store ptr [[FOO1]], ptr [[DOTTMP_PREFETCH5]], align 4
// CHECK-32-NEXT:    store ptr [[FOO2]], ptr [[DOTTMP_PREFETCH6]], align 4
// CHECK-32-NEXT:    [[TMP7:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH5]], i32 1, i32 1), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH6]], i32 2, i32 5) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP7]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    store ptr [[FOO1]], ptr [[DOTTMP_PREFETCH7]], align 4
// CHECK-32-NEXT:    store ptr [[FOO2]], ptr [[DOTTMP_PREFETCH8]], align 4
// CHECK-32-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[P]], align 4
// CHECK-32-NEXT:    store ptr [[TMP8]], ptr [[DOTTMP_PREFETCH9]], align 4
// CHECK-32-NEXT:    [[TMP9:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH7]], i32 1, i32 1), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH8]], i32 2, i32 4), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH9]], i32 3, i32 10) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP9]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    store ptr @bar, ptr [[DOTTMP_PREFETCH10]], align 4
// CHECK-32-NEXT:    store ptr getelementptr inbounds ([[STRUCT_FOOBAR:%.*]], ptr @bar, i32 0, i32 1), ptr [[DOTTMP_PREFETCH11]], align 4
// CHECK-32-NEXT:    [[TMP10:%.*]] = load i32, ptr [[I]], align 4
// CHECK-32-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP10]], 1
// CHECK-32-NEXT:    store i32 [[INC]], ptr [[I]], align 4
// CHECK-32-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds [10 x double], ptr getelementptr inbounds ([[STRUCT_FOOBAR]], ptr @bar, i32 0, i32 1), i32 0, i32 [[INC]]
// CHECK-32-NEXT:    store ptr [[ARRAYIDX13]], ptr [[DOTTMP_PREFETCH12]], align 4
// CHECK-32-NEXT:    [[TMP11:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH10]], i32 1, i32 2), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH11]], i32 3, i32 20), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH12]], i32 2, i32 10) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP11]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    store i32 0, ptr [[I14]], align 4
// CHECK-32-NEXT:    br label [[FOR_COND:%.*]]
// CHECK-32:       for.cond:
// CHECK-32-NEXT:    [[TMP12:%.*]] = load i32, ptr [[I14]], align 4
// CHECK-32-NEXT:    [[CMP15:%.*]] = icmp slt i32 [[TMP12]], 10
// CHECK-32-NEXT:    br i1 [[CMP15]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK-32:       for.body:
// CHECK-32-NEXT:    br label [[FOR_INC:%.*]]
// CHECK-32:       for.inc:
// CHECK-32-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I14]], align 4
// CHECK-32-NEXT:    [[INC16:%.*]] = add nsw i32 [[TMP13]], 1
// CHECK-32-NEXT:    store i32 [[INC16]], ptr [[I14]], align 4
// CHECK-32-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4:![0-9]+]]
// CHECK-32:       for.end:
// CHECK-32-NEXT:    store i32 1, ptr [[PP]], align 4
// CHECK-32-NEXT:    store ptr [[PP]], ptr [[PTR]], align 4
// CHECK-32-NEXT:    store ptr [[PTR]], ptr [[PPTR]], align 4
// CHECK-32-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[PPTR]], align 4
// CHECK-32-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP14]], align 4
// CHECK-32-NEXT:    store ptr [[TMP15]], ptr [[DOTTMP_PREFETCH17]], align 4
// CHECK-32-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[PPTR]], align 4
// CHECK-32-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP16]], align 4
// CHECK-32-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[TMP17]], i32 1
// CHECK-32-NEXT:    store ptr [[ADD_PTR]], ptr [[DOTTMP_PREFETCH18]], align 4
// CHECK-32-NEXT:    [[TMP18:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH17]], i32 1, i32 100), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH18]], i32 4, i32 200) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP18]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    ret i32 0
//
// CHECK-LABEL: @main(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[ARGC_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[ARGV_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[A:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[FOO1:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    [[FOO2:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    [[P:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH1:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH3:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH5:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH6:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH7:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH8:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH9:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH10:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH11:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH12:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[I15:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[PP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[PTR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[PPTR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH18:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH19:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-NEXT:    store i32 [[ARGC:%.*]], ptr [[ARGC_ADDR]], align 4
// CHECK-NEXT:    store ptr [[ARGV:%.*]], ptr [[ARGV_ADDR]], align 8
// CHECK-NEXT:    store i32 1, ptr [[I]], align 4
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [10 x i32], ptr [[FOO1]], i64 0, i64 0
// CHECK-NEXT:    store ptr [[ARRAYDECAY]], ptr [[P]], align 8
// CHECK-NEXT:    store ptr [[FOO1]], ptr [[DOTTMP_PREFETCH]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH]], i32 1, i64 1) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[FOO1]], i64 0, i64 1
// CHECK-NEXT:    store ptr [[ARRAYIDX]], ptr [[DOTTMP_PREFETCH1]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[A]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[B]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[TMP1]], [[TMP2]]
// CHECK-NEXT:    [[TMP3:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH1]], i32 1, i64 2), "QUAL.OMP.IF"(i1 [[CMP]]) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP3]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[A]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp eq i32 [[TMP4]], 0
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP5]] to i64
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [10 x i32], ptr [[FOO1]], i64 0, i64 [[IDXPROM]]
// CHECK-NEXT:    store ptr [[ARRAYIDX4]], ptr [[DOTTMP_PREFETCH3]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.IF"(i1 [[CMP2]]), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH3]], i32 1, i64 3) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP6]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    store ptr [[FOO1]], ptr [[DOTTMP_PREFETCH5]], align 8
// CHECK-NEXT:    store ptr [[FOO2]], ptr [[DOTTMP_PREFETCH6]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH5]], i32 1, i64 1), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH6]], i32 2, i64 5) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP7]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    store ptr [[FOO1]], ptr [[DOTTMP_PREFETCH7]], align 8
// CHECK-NEXT:    store ptr [[FOO2]], ptr [[DOTTMP_PREFETCH8]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    store ptr [[TMP8]], ptr [[DOTTMP_PREFETCH9]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH7]], i32 1, i64 1), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH8]], i32 2, i64 4), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH9]], i32 3, i64 10) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP9]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    store ptr @bar, ptr [[DOTTMP_PREFETCH10]], align 8
// CHECK-NEXT:    store ptr getelementptr inbounds ([[STRUCT_FOOBAR:%.*]], ptr @bar, i32 0, i32 1), ptr [[DOTTMP_PREFETCH11]], align 8
// CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP10]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[I]], align 4
// CHECK-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[INC]] to i64
// CHECK-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds [10 x double], ptr getelementptr inbounds ([[STRUCT_FOOBAR]], ptr @bar, i32 0, i32 1), i64 0, i64 [[IDXPROM13]]
// CHECK-NEXT:    store ptr [[ARRAYIDX14]], ptr [[DOTTMP_PREFETCH12]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH10]], i32 1, i64 2), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH11]], i32 3, i64 20), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH12]], i32 2, i64 10) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP11]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    store i32 0, ptr [[I15]], align 4
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[I15]], align 4
// CHECK-NEXT:    [[CMP16:%.*]] = icmp slt i32 [[TMP12]], 10
// CHECK-NEXT:    br i1 [[CMP16]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    br label [[FOR_INC:%.*]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I15]], align 4
// CHECK-NEXT:    [[INC17:%.*]] = add nsw i32 [[TMP13]], 1
// CHECK-NEXT:    store i32 [[INC17]], ptr [[I15]], align 4
// CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP3:![0-9]+]]
// CHECK:       for.end:
// CHECK-NEXT:    store i32 1, ptr [[PP]], align 4
// CHECK-NEXT:    store ptr [[PP]], ptr [[PTR]], align 8
// CHECK-NEXT:    store ptr [[PTR]], ptr [[PPTR]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[PPTR]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP14]], align 8
// CHECK-NEXT:    store ptr [[TMP15]], ptr [[DOTTMP_PREFETCH18]], align 8
// CHECK-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[PPTR]], align 8
// CHECK-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP16]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[TMP17]], i64 1
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[DOTTMP_PREFETCH19]], align 8
// CHECK-NEXT:    [[TMP18:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH18]], i32 1, i64 100), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH19]], i32 4, i64 200) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP18]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    ret i32 0
//
int main(int argc, char *argv[]) {
  int i = 1;
  int a;
  int b;
  int foo1[10];
  int foo2[10];
  int *p = foo1;

  #pragma omp prefetch data(&foo1:1:1)
  #pragma omp prefetch data(&foo1[1]:1:2) if (a < b)
  #pragma omp prefetch if (a == 0) data(&foo1[i]:1:3)

  // One data clause with two prefetch expressions should generate same IR
  // as prefetch with two data clauses and same expressions.
#ifndef MULTI_DATA
  #pragma omp prefetch data(&foo1:1:1, &foo2:2:5)
#else
  #pragma omp prefetch data(&foo1:1:1) data(&foo2:2:5)
#endif

#ifndef MULTI_DATA
  #pragma omp prefetch data(&foo1:1:1, &foo2:2:4, p:3:10)
#else
  #pragma omp prefetch data(&foo1:1:1) data(&foo2:2:4) data(p:3:10)
#endif
  {}

  #pragma omp prefetch data(&bar:1:2, &bar.d:3:20) data(&bar.d[++i]:2:10)
  for (int i = 0; i < 10; ++i) {}

  {
    int pp = 1;
    int *ptr = &pp;
    int **pptr = &ptr;

    #pragma omp prefetch data((*pptr):1:100, (*pptr + 1):4:200)
  }
  return 0;
}

class A {
public:
  static int i;
  static int j[100];
};

int A::i = 1;
int A::j[] = {0,1,2,3,4,5,6,7,8,9};

namespace B {
int i = 1;
int j[] = {0,1,2,3,4,5,6,7,8,9};

};

// CHECK-32-LABEL: @_Z13prefetch_testv(
// CHECK-32-NEXT:  entry:
// CHECK-32-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    [[DOTTMP_PREFETCH1:%.*]] = alloca ptr, align 4
// CHECK-32-NEXT:    store ptr @_ZN1A1iE, ptr [[DOTTMP_PREFETCH]], align 4
// CHECK-32-NEXT:    [[TMP0:%.*]] = load i32, ptr [[I]], align 4
// CHECK-32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr @_ZN1B1jE, i32 0, i32 [[TMP0]]
// CHECK-32-NEXT:    store ptr [[ARRAYIDX]], ptr [[DOTTMP_PREFETCH1]], align 4
// CHECK-32-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH]], i32 1, i32 100), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH1]], i32 4, i32 5) ]
// CHECK-32-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-32-NEXT:    ret void
//
// CHECK-LABEL: @_Z13prefetch_testv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTTMP_PREFETCH:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[DOTTMP_PREFETCH1:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr @_ZN1A1iE, ptr [[DOTTMP_PREFETCH]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr @_ZN1B1jE, i64 0, i64 [[IDXPROM]]
// CHECK-NEXT:    store ptr [[ARRAYIDX]], ptr [[DOTTMP_PREFETCH1]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.PREFETCH"(), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH]], i32 1, i64 100), "QUAL.OMP.DATA"(ptr [[DOTTMP_PREFETCH1]], i32 4, i64 5) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.PREFETCH"() ]
// CHECK-NEXT:    ret void
//
void prefetch_test()
{
  int i;

#ifndef MULTI_DATA
  #pragma omp prefetch data(&A::i:1:100, &B::j[i]:4:5)
#else
  #pragma omp prefetch data(&A::i:1:100) data(&B::j[i]:4:5)
#endif

  return;
}

// Verify #pragma omp prefetch in function template.
template <typename T, unsigned size>
T run() {
  T foo[size];
  #pragma omp prefetch data(&foo:1:10)
  return foo[0];
}

// CHECK-32-LABEL: @_Z13template_testv(
// CHECK-32-NEXT:  entry:
// CHECK-32-NEXT:    [[RESULT:%.*]] = alloca double, align 8
// CHECK-32-NEXT:    [[CALL:%.*]] = call noundef double @_Z3runIdLj10EET_v()
// CHECK-32-NEXT:    store double [[CALL]], ptr [[RESULT]], align 8
// CHECK-32-NEXT:    ret i32 0
//
// CHECK-LABEL: @_Z13template_testv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RESULT:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[CALL:%.*]] = call noundef double @_Z3runIdLj10EET_v()
// CHECK-NEXT:    store double [[CALL]], ptr [[RESULT]], align 8
// CHECK-NEXT:    ret i32 0
//
int template_test() {
  double result;
  result = run<double, 10>();
  return 0;
}
#endif
// end INTEL_COLLAB
