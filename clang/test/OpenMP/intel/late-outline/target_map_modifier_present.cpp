// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// INTEL_COLLAB
// RUN: %clang_cc1 -emit-llvm -o - -fopenmp -fopenmp-late-outline -fopenmp-typed-clauses \
// RUN:  -fopenmp-version=51 \
// RUN:  -triple x86_64-unknown-linux-gnu %s | FileCheck %s

// CHECK-LABEL: @_Z21test_present_modifieri(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// CHECK:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM:PRESENT"(ptr [[ARG_ADDR]], ptr [[ARG_ADDR]], i64 4, i64 4099, ptr null, ptr null) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void test_present_modifier(int arg) {
#pragma omp target data map(present, tofrom \
                            : arg)
  {++arg;}
}
// CHECK-LABEL: @_Z3fooi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca i32, align 4
// CHECK:    [[LA:%.*]] = alloca i32, align 4
// CHECK:    [[TMP0:%.*]] = load i32, ptr [[ARG_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64
// CHECK:    [[VLA:%.*]] = alloca float, i64 [[TMP1]], align 16
// CHECK:    [[TMP3:%.*]] = mul nuw i64 [[TMP1]], 4
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[VLA]], i64 0
// CHECK-NEXT:    [[TMP4:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TO:PRESENT"(ptr [[VLA]], ptr [[ARRAYIDX]], i64 [[TMP3]], i64 4097, ptr null, ptr null) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP4]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    [[TMP6:%.*]] = mul nuw i64 [[TMP1]], 4
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds float, ptr [[VLA]], i64 0
// CHECK-NEXT:    [[TMP7:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TO:ALWAYS.CLOSE.PRESENT"(ptr [[VLA]], ptr [[ARRAYIDX1]], i64 [[TMP6]], i64 5125, ptr null, ptr null) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP7]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK:    ret void
//
void foo(int arg) {
  int la;
  float lb[arg];
  #pragma omp target data map(present, to: lb)
  {++arg;}
  #pragma omp target data map(always close present, to: lb)
  {++arg;}
}

class C {
public:
  int a;
  double *b;
};
#pragma omp declare mapper(id: C s) map(s.a, s.b[0:2])

// CHECK-LABEL: @_Z3zooi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[C:%.*]] = alloca [[CLASS_C:%.*]], align 8
// CHECK-NEXT:    store i32 [[A:%.*]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    store i32 [[TMP0]], ptr [[I]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[A1:%.*]] = getelementptr inbounds [[CLASS_C]], ptr [[C]], i32 0, i32 0
// CHECK-NEXT:    store i32 [[TMP1]], ptr [[A1]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.UPDATE"(), "QUAL.OMP.MAP.TO:PRESENT"(ptr [[C]], ptr [[C]], i64 16, i64 4097, ptr null, ptr @.omp_mapper._ZTS1C.id) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TARGET.UPDATE"() ]
// CHECK-NEXT:    [[TMP3:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.UPDATE"(), "QUAL.OMP.MAP.FROM:PRESENT"(ptr [[C]], ptr [[C]], i64 16, i64 4098, ptr null, ptr @.omp_mapper._ZTS1C.id) ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP3]]) [ "DIR.OMP.END.TARGET.UPDATE"() ]
// CHECK-NEXT:    ret void
//
void zoo(int a){
  int i = a;
  C c;
  c.a = a;
  #pragma omp target update to(present, mapper(id): c)
  #pragma omp target update from(mapper(id), present: c)
}

struct ST {
  int i;
  int j;

// CHECK-LABEL: @_ZN2ST20test_present_membersEv(
// CHECK:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[J:%.*]] = getelementptr inbounds [[STRUCT_ST:%.*]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[I:%.*]] = getelementptr inbounds [[STRUCT_ST]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i32, ptr [[J]], i32 1
// CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[TMP0]] to i64
// CHECK-NEXT:    [[TMP4:%.*]] = ptrtoint ptr [[I]] to i64
// CHECK-NEXT:    [[TMP5:%.*]] = sub i64 [[TMP3]], [[TMP4]]
// CHECK:    [[TMP6:%.*]] = sdiv exact i64 [[TMP5]], ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
// CHECK-NEXT:    [[TMP7:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 0), "QUAL.OMP.MAP.TOFROM:PRESENT"(ptr [[THIS1]], ptr [[I]], i64 [[TMP6]], i64 4128, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:PRESENT.CHAIN"(ptr [[THIS1]], ptr [[J]], i64 4, i64 281474976714755, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[THIS1]], ptr [[I]], i64 4, i64 281474976710659, ptr null, ptr null), "QUAL.OMP.FIRSTPRIVATE:TYPED"(ptr [[THIS1]], %struct.ST zeroinitializer, i32 1) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP7]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    ret void
//
  void test_present_members() {
  #pragma omp target map(tofrom                   \
                       : i) map(present, tofrom \
                                : j)
    {
      i++;
      j++;
    }
  }
};

void test() {
  ST s;
  s.test_present_members();
}

// CHECK-LABEL: @_Z23implicit_present_scalari(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 1), "QUAL.OMP.DEFAULTMAP.PRESENT:SCALAR"(), "QUAL.OMP.MAP.TOFROM:PRESENT"(ptr [[A_ADDR]], ptr [[A_ADDR]], i64 4, i64 4640, ptr null, ptr null) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    ret void
//
void implicit_present_scalar(int a){
  #pragma omp target defaultmap(present: scalar)
  {
    a += 1.0;
  }
}

// CHECK-LABEL: @_Z26implicit_present_aggregatei(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DARR:%.*]] = alloca [2 x double], align 16
// CHECK:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 2), "QUAL.OMP.DEFAULTMAP.PRESENT:AGGREGATE"(), "QUAL.OMP.MAP.TOFROM:PRESENT"(ptr [[DARR]], ptr [[DARR]], i64 16, i64 4640, ptr null, ptr null) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    ret void
//
void implicit_present_aggregate(int a) {
  double darr[2] = {(double)a, (double)a};
  #pragma omp target defaultmap(present: aggregate)
  {
    darr[0] += 1.0;
    darr[1] += 1.0;
  }
}

// CHECK-LABEL: @_Z24explicit_present_pointerv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PA:%.*]] = alloca ptr, align 8
// CHECK:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 3), "QUAL.OMP.DEFAULTMAP.PRESENT:POINTER"(), "QUAL.OMP.MAP.TOFROM:PRESENT"(ptr [[PA]], ptr [[PA]], i64 8, i64 4640, ptr null, ptr null) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    ret void
//
void explicit_present_pointer() {
  int *pa;
  #pragma omp target defaultmap(present: pointer)
  {
    pa[50]++;
  }
}

// CHECK-LABEL: @_Z31implicit_present_double_complexi(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DC:%.*]] = alloca { double, double }, align 8
// CHECK:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 4), "QUAL.OMP.DEFAULTMAP.PRESENT:SCALAR"(), "QUAL.OMP.MAP.TOFROM:PRESENT"(ptr [[DC]], ptr [[DC]], i64 16, i64 4640, ptr null, ptr null) ]
// CHECK:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    ret void
//
void implicit_present_double_complex (int a){
  double _Complex dc = (double)a;
  #pragma omp target defaultmap(present:scalar)
  {
   dc *= dc;
  }
}
// end INTEL_COLLAB
