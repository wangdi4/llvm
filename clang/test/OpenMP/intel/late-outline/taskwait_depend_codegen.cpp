// INTEL_COLLAB
// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//
// RUN: %clang_cc1 -emit-llvm -o - -fopenmp -fopenmp-late-outline \
// RUN: -triple x86_64-unknown-linux-gnu -fopenmp-version=51 %s | FileCheck %s

// RUN: %clang_cc1 -fopenmp -fopenmp-late-outline \
// RUN: -triple x86_64-unknown-linux-gnu -fopenmp-version=51 \
// RUN: -emit-pch %s -o %t

// RUN: %clang_cc1 -fopenmp -fopenmp-late-outline \
// RUN: -triple x86_64-unknown-linux-gnu -fopenmp-version=51 \
// RUN: -include-pch %t -emit-llvm %s -o - | FileCheck %s
// expected-no-diagnostics
//
#ifndef HEADER
#define HEADER
// CHECK-LABEL: @_Z3foov(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VAR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[ARR:%.*]] = alloca [100 x i32], align 16
// CHECK-NEXT:    store i32 1, i32* [[VAR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [100 x i32]* [[ARR]] to i8*
// CHECK-NEXT:    call void @llvm.memset.p0i8.i64(i8* align 16 [[TMP0]], i8 0, i64 400, i1 false)
// CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASK"(), "QUAL.OMP.FIRSTPRIVATE"(i32* [[VAR]]), "QUAL.OMP.FIRSTPRIVATE"([100 x i32]* [[ARR]]) ]
// CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASKWAIT"(), "QUAL.OMP.DEPEND.IN"(i32* [[VAR]]) ]
// CHECK-NEXT:    fence acq_rel
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TASKWAIT"() ]
// CHECK-NEXT:    [[TMP3:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASKWAIT"(), "QUAL.OMP.DEPEND.OUT"(i32* [[VAR]]) ]
// CHECK-NEXT:    fence acq_rel
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP3]]) [ "DIR.OMP.END.TASKWAIT"() ]
// CHECK-NEXT:    [[TMP4:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASKWAIT"(), "QUAL.OMP.DEPEND.INOUT"(i32* [[VAR]]) ]
// CHECK-NEXT:    fence acq_rel
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP4]]) [ "DIR.OMP.END.TASKWAIT"() ]
// CHECK-NEXT:    [[TMP5:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASKWAIT"(), "QUAL.OMP.NOWAIT"(), "QUAL.OMP.DEPEND.IN"([100 x i32]* [[ARR]]) ]
// CHECK-NEXT:    fence acq_rel
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP5]]) [ "DIR.OMP.END.TASKWAIT"() ]
// CHECK-NEXT:    [[TMP6:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASKWAIT"(), "QUAL.OMP.DEPEND.OUT:ARRSECT"([100 x i32]* [[ARR]], i64 1, i64 5, i64 10, i64 1) ]
// CHECK-NEXT:    fence acq_rel
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP6]]) [ "DIR.OMP.END.TASKWAIT"() ]
// CHECK-NEXT:    [[TMP7:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASKWAIT"(), "QUAL.OMP.DEPEND.IN"([100 x i32]* [[ARR]]), "QUAL.OMP.NOWAIT"() ]
// CHECK-NEXT:    fence acq_rel
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP7]]) [ "DIR.OMP.END.TASKWAIT"() ]
// CHECK-NEXT:    [[TMP8:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TASKWAIT"(), "QUAL.OMP.DEPEND.INOUT"(i32* [[VAR]]), "QUAL.OMP.DEPEND.OUT"(i32* [[VAR]]), "QUAL.OMP.DEPEND.IN"(i32* [[VAR]]), "QUAL.OMP.NOWAIT"() ]
// CHECK-NEXT:    fence acq_rel
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP8]]) [ "DIR.OMP.END.TASKWAIT"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.TASK"() ]
// CHECK-NEXT:    ret void
//
void foo()
{
  int var = 1;
  int arr[100] = {0};

  #pragma omp task
  {
    #pragma omp taskwait depend(in:var)
    #pragma omp taskwait depend(out:var)
    #pragma omp taskwait depend(inout:var)
    #pragma omp taskwait nowait depend(in:arr)
    #pragma omp taskwait depend(out:arr[5:10])
    #pragma omp taskwait depend(in:arr) nowait
    #pragma omp taskwait depend(inout:var) depend(out:var) depend(in:var) nowait
  }
}
#endif
// end INTEL_COLLAB
