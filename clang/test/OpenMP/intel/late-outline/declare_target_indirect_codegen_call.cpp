// INTEL_COLLAB
// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -fopenmp-version=51 \
//RUN:  -emit-llvm-bc -disable-llvm-passes \
//RUN:  -fopenmp -fopenmp-targets=spir64 \
//RUN:  -fopenmp-late-outline -fopenmp-typed-clauses \
//RUN:  -Werror -Wsource-uses-openmp -o %t_host.bc %s

//RUN: %clang_cc1 -triple spir64 -fopenmp-version=51 \
//RUN:  -aux-triple x86_64-unknown-linux-gnu \
//RUN:  -emit-llvm -disable-llvm-passes \
//RUN:  -fopenmp -fopenmp-targets=spir64 \
//RUN:  -fopenmp-late-outline -fopenmp-typed-clauses \
//RUN:  -fopenmp-is-device -fopenmp-host-ir-file-path %t_host.bc \
//RUN:  -Wsource-uses-openmp -o - %s | FileCheck %s -check-prefix TARG

//RUN: %clang_cc1 -triple x86_64-pc-windows-msvc19.29.30133 \
//RUN:  -fopenmp -fopenmp-version=51 -fopenmp-late-outline -fopenmp-typed-clauses \
//RUN:  -fopenmp-targets=spir64 -emit-llvm -disable-llvm-passes \
//RUN:  -Werror -Wsource-uses-openmp -o - %s | FileCheck %s -check-prefix WHOST

//RUN: %clang_cc1 -triple x86_64-pc-windows-msvc19.29.30133 \
//RUN:  -fopenmp -fopenmp-version=51 -fopenmp-late-outline -fopenmp-typed-clauses \
//RUN:  -fopenmp-targets=spir64 -emit-llvm-bc -disable-llvm-passes \
//RUN:  -Werror -Wsource-uses-openmp -o %t_host.bc %s

//RUN: %clang_cc1 -triple spir64 -aux-triple x86_64-pc-windows-msvc \
//RUN:  -fopenmp -fopenmp-targets=spir64  -fopenmp-is-device \
//RUN:  -fopenmp-late-outline -fopenmp-typed-clauses -fopenmp -fopenmp-version=51 \
//RUN:  -emit-llvm -fopenmp-host-ir-file-path %t_host.bc \
//RUN:  -Wsource-uses-openmp -o - %s | FileCheck %s -check-prefix TARG

// expected-no-diagnostics

typedef int(*func)(int, int);
typedef int(*fptr)(int);
extern int barr(int, int) {return 1;}
#pragma omp declare target to(barr) indirect(true)
extern int zoo(int) {return 2;}
extern int moo(int) {return 3;}
#pragma omp declare target to(zoo, moo) indirect(true)
func two = &barr;
int *const *f5(float add, int * const &res)
{
  *res += (int)add;
  return &res;
}

#pragma omp declare target to(f5) indirect(true)
// TARG-LABEL: @_Z3barv(
// TARG-NEXT:  entry:
// TARG-NEXT:    [[RET:%.*]] = alloca i32, align 4
// TARG-NEXT:    [[G:%.*]] = alloca ptr, align 8
// TARG-NEXT:    [[CP:%.*]] = alloca ptr addrspace(4), align 8
// TARG-NEXT:    [[RETPCP:%.*]] = alloca ptr addrspace(4), align 8
// TARG-NEXT:    [[RETPCP_MAP_PTR_TMP:%.*]] = alloca ptr addrspace(4), align 8
// TARG-NEXT:    [[G_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// TARG-NEXT:    [[CP_MAP_PTR_TMP:%.*]] = alloca ptr addrspace(4), align 8
// TARG-NEXT:    [[TWO_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// TARG-NEXT:    [[ONE:%.*]] = alloca ptr, align 8
// TARG-NEXT:    [[ONE_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// TARG-NEXT:    [[RET_ASCAST:%.*]] = addrspacecast ptr [[RET]] to ptr addrspace(4)
// TARG-NEXT:    [[G_ASCAST:%.*]] = addrspacecast ptr [[G]] to ptr addrspace(4)
// TARG-NEXT:    [[CP_ASCAST:%.*]] = addrspacecast ptr [[CP]] to ptr addrspace(4)
// TARG-NEXT:    [[RETPCP_ASCAST:%.*]] = addrspacecast ptr [[RETPCP]] to ptr addrspace(4)
// TARG-NEXT:    [[RETPCP_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast ptr [[RETPCP_MAP_PTR_TMP]] to ptr addrspace(4)
// TARG-NEXT:    [[G_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast ptr [[G_MAP_PTR_TMP]] to ptr addrspace(4)
// TARG-NEXT:    [[CP_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast ptr [[CP_MAP_PTR_TMP]] to ptr addrspace(4)
// TARG-NEXT:    [[TWO_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast ptr [[TWO_MAP_PTR_TMP]] to ptr addrspace(4)
// TARG-NEXT:    [[ONE_ASCAST:%.*]] = addrspacecast ptr [[ONE]] to ptr addrspace(4)
// TARG-NEXT:    [[ONE_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast ptr [[ONE_MAP_PTR_TMP]] to ptr addrspace(4)
// TARG-NEXT:    store i32 0, ptr addrspace(4) [[RET_ASCAST]], align 4
// TARG-NEXT:    store ptr @_Z2f5fRKPi, ptr addrspace(4) [[G_ASCAST]], align 8
// TARG-NEXT:    store ptr addrspace(4) [[RET_ASCAST]], ptr addrspace(4) [[CP_ASCAST]], align 8
// TARG-NEXT:    store ptr addrspace(4) null, ptr addrspace(4) [[RETPCP_ASCAST]], align 8
// TARG-NEXT:    [[TMP0:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[RETPCP_ASCAST]], align 8
// TARG-NEXT:    [[TMP1:%.*]] = load ptr, ptr addrspace(4) [[G_ASCAST]], align 8
// TARG-NEXT:    [[TMP2:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[CP_ASCAST]], align 8
// TARG-NEXT:    [[TMP3:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 4), "QUAL.OMP.MAP.TOFROM"(ptr addrspace(4) [[TMP0]], ptr addrspace(4) [[TMP0]], i64 0, i64 544, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:FPTR"(ptr [[TMP1]], ptr [[TMP1]], i64 0, i64 544, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM"(ptr addrspace(4) [[TMP2]], ptr addrspace(4) [[TMP2]], i64 0, i64 544, ptr null, ptr null), "QUAL.OMP.PRIVATE:TYPED"(ptr addrspace(4) [[RETPCP_MAP_PTR_TMP_ASCAST]], ptr addrspace(4) null, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr addrspace(4) [[G_MAP_PTR_TMP_ASCAST]], ptr null, i32 1), "QUAL.OMP.PRIVATE:TYPED"(ptr addrspace(4) [[CP_MAP_PTR_TMP_ASCAST]], ptr addrspace(4) null, i32 1) ]
// TARG-NEXT:    store ptr addrspace(4) [[TMP0]], ptr addrspace(4) [[RETPCP_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    store ptr [[TMP1]], ptr addrspace(4) [[G_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    store ptr addrspace(4) [[TMP2]], ptr addrspace(4) [[CP_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP4:%.*]] = load ptr, ptr addrspace(4) [[G_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP5:%.*]] =  ptrtoint ptr [[TMP4]] to i64
// TARG-NEXT:    [[TMP6:%.*]] = call ptr addrspace(4) @__kmpc_target_translate_fptr(i64 [[TMP5]])
// TARG-NEXT:    [[TMP7:%.*]] = addrspacecast ptr addrspace(4) [[TMP6]] to ptr
// TARG-NEXT:    [[TMP8:%.*]] = call ptr addrspace(4) [[TMP7]](float 3.000000e+00, ptr addrspace(4) [[CP_MAP_PTR_TMP_ASCAST]])
// TARG-NEXT:    store ptr addrspace(4) [[TMP8]], ptr addrspace(4) [[RETPCP_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    call void @llvm.directive.region.exit(token [[TMP3]]) [ "DIR.OMP.END.TARGET"() ]
// TARG-NEXT:    [[TMP9:%.*]] = load ptr, ptr addrspace(4) addrspacecast (ptr addrspace(1) @two to ptr addrspace(4)), align 8
// TARG-NEXT:    [[TMP10:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 5), "QUAL.OMP.MAP.TOFROM:FPTR"(ptr [[TMP9]], ptr [[TMP9]], i64 0, i64 544, ptr null, ptr null), "QUAL.OMP.PRIVATE:TYPED"(ptr addrspace(4) [[TWO_MAP_PTR_TMP_ASCAST]], ptr null, i32 1) ]
// TARG-NEXT:    store ptr [[TMP9]], ptr addrspace(4) [[TWO_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP11:%.*]] = load ptr, ptr addrspace(4) [[TWO_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP12:%.*]] = ptrtoint ptr [[TMP11]] to i64
// TARG-NEXT:    [[TMP13:%.*]] = call ptr addrspace(4) @__kmpc_target_translate_fptr(i64 [[TMP12]])
// TARG-NEXT:    [[TMP14:%.*]] = addrspacecast ptr addrspace(4) [[TMP13]] to ptr
// TARG-NEXT:    [[TMP15:%.*]] = call i32 [[TMP14]](i32 1, i32 2)
// TARG-NEXT:    call void @llvm.directive.region.exit(token [[TMP10]]) [ "DIR.OMP.END.TARGET"() ]
// TARG-NEXT:    [[TMP16:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[RETPCP_ASCAST]], align 8
// TARG-NEXT:    [[TOBOOL:%.*]] = icmp ne ptr addrspace(4) [[TMP16]], null
// TARG-NEXT:    [[TMP17:%.*]] = zext i1 [[TOBOOL]] to i64
// TARG-NEXT:    [[COND:%.*]] = select i1 [[TOBOOL]], ptr @_Z3mooi, ptr @_Z3zooi
// TARG-NEXT:    store ptr [[COND]], ptr addrspace(4) [[ONE_ASCAST]], align 8
// TARG-NEXT:    [[TMP18:%.*]] = load ptr, ptr addrspace(4) [[ONE_ASCAST]], align 8
// TARG-NEXT:    [[TMP19:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 6), "QUAL.OMP.MAP.TOFROM:FPTR"(ptr [[TMP18]], ptr [[TMP18]], i64 0, i64 544, ptr null, ptr null), "QUAL.OMP.PRIVATE:TYPED"(ptr addrspace(4) [[ONE_MAP_PTR_TMP_ASCAST]], ptr null, i32 1) ]
// TARG-NEXT:    store ptr [[TMP18]], ptr addrspace(4) [[ONE_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP20:%.*]] = load ptr, ptr addrspace(4) [[ONE_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP21:%.*]] = ptrtoint ptr [[TMP20]] to i64
// TARG-NEXT:    [[TMP22:%.*]] = call ptr addrspace(4) @__kmpc_target_translate_fptr(i64 [[TMP21]])
// TARG-NEXT:    [[TMP23:%.*]] = addrspacecast ptr addrspace(4) [[TMP22]] to ptr
// TARG-NEXT:    [[TMP24:%.*]] = call i32 [[TMP23]](i32 1)
// TARG-NEXT:    call void @llvm.directive.region.exit(token [[TMP19]]) [ "DIR.OMP.END.TARGET"() ]
// TARG-NEXT:    ret void
//
void bar()
{
  int ret = 0;
  int *const *(*g)(float, int* const &) = f5;
  int *const cp = &ret;
  int *const * retpcp = nullptr;
  #pragma omp target
  retpcp = g(3.0, cp);
  #pragma omp target
  two(1,2);
  fptr one = retpcp ? &moo : &zoo;
  #pragma omp target
  one(1);
}

struct C {
#pragma omp declare target
  void virtual foo() {};
};
// checking for virual function call to foo();
// TARG-LABEL: @_Z6test_5P1CMS_FvvE(
// TARG-NEXT:  entry:
// TARG-NEXT:    [[P_ADDR:%.*]] = alloca ptr addrspace(4), align 8
// TARG-NEXT:    [[Q_ADDR:%.*]] = alloca { i64, i64 }, align 8
// TARG-NEXT:    [[P_ADDR_ASCAST:%.*]] = addrspacecast ptr [[P_ADDR]] to ptr addrspace(4)
// TARG-NEXT:    [[Q_ADDR_ASCAST:%.*]] = addrspacecast ptr [[Q_ADDR]] to ptr addrspace(4)
// TARG-NEXT:    [[Q:%.*]] = load { i64, i64 }, ptr addrspace(4) [[TMP0:%.*]], align 8
// TARG-NEXT:    store ptr addrspace(4) [[P:%.*]], ptr addrspace(4) [[P_ADDR_ASCAST]], align 8
// TARG-NEXT:    store { i64, i64 } [[Q]], ptr addrspace(4) [[Q_ADDR_ASCAST]], align 8
// TARG-NEXT:    [[TMP1:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[P_ADDR_ASCAST]], align 8
// TARG-NEXT:    [[TMP2:%.*]] = load { i64, i64 }, ptr addrspace(4) [[Q_ADDR_ASCAST]], align 8
// TARG-NEXT:    [[MEMPTR_ADJ:%.*]] = extractvalue { i64, i64 } [[TMP2]], 1
// TARG-NEXT:    [[TMP3:%.*]] = addrspacecast ptr addrspace(4) [[TMP1]] to ptr
// TARG-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i8, ptr [[TMP3]], i64 [[MEMPTR_ADJ]]
// TARG-NEXT:    [[THIS_ADJUSTED:%.*]] = addrspacecast ptr [[TMP4]] to ptr addrspace(4)
// TARG-NEXT:    [[MEMPTR_PTR:%.*]] = extractvalue { i64, i64 } [[TMP2]], 0
// TARG-NEXT:    [[TMP5:%.*]] = and i64 [[MEMPTR_PTR]], 1
// TARG-NEXT:    [[MEMPTR_ISVIRTUAL:%.*]] = icmp ne i64 [[TMP5]], 0
// TARG-NEXT:    br i1 [[MEMPTR_ISVIRTUAL]], label [[MEMPTR_VIRTUAL:%.*]], label [[MEMPTR_NONVIRTUAL:%.*]]
// TARG:       memptr.virtual:
// TARG-NEXT:    [[VTABLE:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[THIS_ADJUSTED]], align 8
// TARG-NEXT:    [[TMP6:%.*]] = sub i64 [[MEMPTR_PTR]], 1
// TARG-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr addrspace(4) [[VTABLE]], i64 [[TMP6]], !nosanitize !11
// TARG-NEXT:    [[MEMPTR_VIRTUALFN:%.*]] = load ptr, ptr addrspace(4) [[TMP7]], align 8, !nosanitize !11
// TARG-NEXT:    br label [[MEMPTR_END:%.*]]
// TARG:       memptr.nonvirtual:
// TARG-NEXT:    [[MEMPTR_NONVIRTUALFN:%.*]] = inttoptr i64 [[MEMPTR_PTR]] to ptr
// TARG-NEXT:    br label [[MEMPTR_END]]
// TARG:       memptr.end:
// TARG-NEXT:    [[TMP8:%.*]] = phi ptr [ [[MEMPTR_VIRTUALFN]], [[MEMPTR_VIRTUAL]] ], [ [[MEMPTR_NONVIRTUALFN]], [[MEMPTR_NONVIRTUAL]] ]
// TARG-NEXT:    [[TMP9:%.*]] = ptrtoint ptr [[TMP8]] to i64
// TARG-NEXT:    [[TMP10:%.*]] = call ptr addrspace(4) @__kmpc_target_translate_fptr(i64 [[TMP9]])
// TARG-NEXT:    [[TMP11:%.*]] = addrspacecast ptr addrspace(4) [[TMP10]] to ptr
// TARG-NEXT:    call void [[TMP11]](ptr addrspace(4) [[THIS_ADJUSTED]])
// TARG-NEXT:    ret void
//
void test_5(C *p, void (C::*q)(void)) {
  (p->*q)();
}
typedef  void (C::*PMFn)();

// TARG-LABEL: @main(
// TARG-NEXT:  entry:
// TARG-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4
// TARG-NEXT:    [[C:%.*]] = alloca [[STRUCT_C:%.*]], align 8
// TARG-NEXT:    [[CP:%.*]] = alloca ptr addrspace(4), align 8
// TARG-NEXT:    [[PF:%.*]] = alloca { i64, i64 }, align 8
// TARG-NEXT:    [[INDIRECT_ARG_TEMP:%.*]] = alloca { i64, i64 }, align 8
// TARG-NEXT:    [[RETVAL_ASCAST:%.*]] = addrspacecast ptr [[RETVAL]] to ptr addrspace(4)
// TARG-NEXT:    [[C_ASCAST:%.*]] = addrspacecast ptr [[C]] to ptr addrspace(4)
// TARG-NEXT:    [[CP_ASCAST:%.*]] = addrspacecast ptr [[CP]] to ptr addrspace(4)
// TARG-NEXT:    [[PF_ASCAST:%.*]] = addrspacecast ptr [[PF]] to ptr addrspace(4)
// TARG-NEXT:    [[INDIRECT_ARG_TEMP_ASCAST:%.*]] = addrspacecast ptr [[INDIRECT_ARG_TEMP]] to ptr addrspace(4)
// TARG-NEXT:    call spir_func void @_ZN1CC1Ev(ptr addrspace(4) noundef align 8 dereferenceable_or_null(8) [[C_ASCAST]]) #[[ATTR5:[0-9]+]]
// TARG-NEXT:    store ptr addrspace(4) [[C_ASCAST]], ptr addrspace(4) [[CP_ASCAST]], align 8
// TARG-NEXT:    store { i64, i64 } { i64 1, i64 0 }, ptr addrspace(4) [[PF_ASCAST]], align 8
// TARG-NEXT:    [[TMP0:%.*]] = load ptr addrspace(4), ptr addrspace(4) [[CP_ASCAST]], align 8
// TARG-NEXT:    [[TMP1:%.*]] = load { i64, i64 }, ptr addrspace(4) [[PF_ASCAST]], align 8
// TARG-NEXT:    store { i64, i64 } [[TMP1]], ptr addrspace(4) [[INDIRECT_ARG_TEMP_ASCAST]], align 8
// TARG-NEXT:    call spir_func void @_Z6test_5P1CMS_FvvE(ptr addrspace(4) noundef [[TMP0]], ptr addrspace(4) noundef byval({ i64, i64 }) align 8 [[INDIRECT_ARG_TEMP_ASCAST]]) #[[ATTR6:[0-9]+]]
// TARG-NEXT:    call spir_func void @_Z3barv() #[[ATTR6]]
// TARG-NEXT:    ret i32 0
//
// WHOST-LABEL: @main(
// WHOST-NEXT:  entry:
// WHOST-NEXT:    [[C:%.*]] = alloca [[STRUCT_C:%.*]], align 8
// WHOST-NEXT:    [[CP:%.*]] = alloca ptr, align 8
// WHOST-NEXT:    [[PF:%.*]] = alloca ptr, align 8
// WHOST-NEXT:    [[CALL:%.*]] = call noundef ptr @"??0C@@QEAA@XZ"(ptr noundef nonnull align 8 dereferenceable(8) [[C]]) #[[ATTR2:[0-9]+]]
// WHOST-NEXT:    store ptr [[C]], ptr [[CP]], align 8
// WHOST-NEXT:    store ptr @"??_9C@@$BA@AA", ptr [[PF]], align 8
// WHOST-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PF]], align 8
// WHOST-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[CP]], align 8
// WHOST-NEXT:    call void @"?test_5@@YAXPEAUC@@P81@EAAXXZ@Z"(ptr noundef [[TMP1]], ptr [[TMP0]])
// WHOST-NEXT:    call void @"?bar@@YAXXZ"()
// WHOST-NEXT:    ret i32 0
//
int main()
{
  C c;
  C *cp = &c;
  PMFn pf = &C::foo;
  test_5(cp, pf);
  bar();
}
#pragma omp end declare target

// end INTEL_COLLAB
