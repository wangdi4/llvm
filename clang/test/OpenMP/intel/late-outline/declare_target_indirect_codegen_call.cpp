// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// INTEL_COLLAB
//RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -fopenmp-version=51 \
//RUN:  -emit-llvm-bc -disable-llvm-passes \
//RUN:  -fopenmp -fopenmp-targets=spir64 \
//RUN:  -fopenmp-late-outline \
//RUN:  -Werror -Wsource-uses-openmp -o %t_host.bc %s

//RUN: %clang_cc1 -triple spir64 -fopenmp-version=51 \
//RUN:  -aux-triple x86_64-unknown-linux-gnu \
//RUN:  -emit-llvm -disable-llvm-passes \
//RUN:  -fopenmp -fopenmp-targets=spir64 \
//RUN:  -fopenmp-late-outline \
//RUN:  -fopenmp-is-device -fopenmp-host-ir-file-path %t_host.bc \
//RUN:  -Wsource-uses-openmp -o - %s | FileCheck %s -check-prefix TARG

// expected-no-diagnostics

typedef int(*func)(int, int);
typedef int(*fptr)(int);
extern int barr(int, int) {return 1;}
#pragma omp declare target to(barr) indirect(true)
extern int zoo(int) {return 2;}
extern int moo(int) {return 3;}
#pragma omp declare target to(zoo, moo) indirect(true)
func two = &barr;
int *const *f5(float add, int * const &res)
{
  *res += (int)add;
  return &res;
}

#pragma omp declare target to(f5) indirect(true)
// TARG-LABEL: @_Z3barv(
// TARG-NEXT:  entry:
// TARG-NEXT:    [[RET:%.*]] = alloca i32, align 4
// TARG-NEXT:    [[G:%.*]] = alloca i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)*, align 8
// TARG-NEXT:    [[CP:%.*]] = alloca i32 addrspace(4)*, align 8
// TARG-NEXT:    [[RETPCP:%.*]] = alloca i32 addrspace(4)* addrspace(4)*, align 8
// TARG-NEXT:    [[RETPCP_MAP_PTR_TMP:%.*]] = alloca i32 addrspace(4)* addrspace(4)*, align 8
// TARG-NEXT:    [[G_MAP_PTR_TMP:%.*]] = alloca i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)*, align 8
// TARG-NEXT:    [[CP_MAP_PTR_TMP:%.*]] = alloca i32 addrspace(4)*, align 8
// TARG-NEXT:    [[TWO_MAP_PTR_TMP:%.*]] = alloca i32 (i32, i32)*, align 8
// TARG-NEXT:    [[ONE:%.*]] = alloca i32 (i32)*, align 8
// TARG-NEXT:    [[ONE_MAP_PTR_TMP:%.*]] = alloca i32 (i32)*, align 8
// TARG-NEXT:    [[RET_ASCAST:%.*]] = addrspacecast i32* [[RET]] to i32 addrspace(4)*
// TARG-NEXT:    [[G_ASCAST:%.*]] = addrspacecast i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)** [[G]] to i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)* addrspace(4)*
// TARG-NEXT:    [[CP_ASCAST:%.*]] = addrspacecast i32 addrspace(4)** [[CP]] to i32 addrspace(4)* addrspace(4)*
// TARG-NEXT:    [[RETPCP_ASCAST:%.*]] = addrspacecast i32 addrspace(4)* addrspace(4)** [[RETPCP]] to i32 addrspace(4)* addrspace(4)* addrspace(4)*
// TARG-NEXT:    [[RETPCP_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast i32 addrspace(4)* addrspace(4)** [[RETPCP_MAP_PTR_TMP]] to i32 addrspace(4)* addrspace(4)* addrspace(4)*
// TARG-NEXT:    [[G_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)** [[G_MAP_PTR_TMP]] to i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)* addrspace(4)*
// TARG-NEXT:    [[CP_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast i32 addrspace(4)** [[CP_MAP_PTR_TMP]] to i32 addrspace(4)* addrspace(4)*
// TARG-NEXT:    [[TWO_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast i32 (i32, i32)** [[TWO_MAP_PTR_TMP]] to i32 (i32, i32)* addrspace(4)*
// TARG-NEXT:    [[ONE_ASCAST:%.*]] = addrspacecast i32 (i32)** [[ONE]] to i32 (i32)* addrspace(4)*
// TARG-NEXT:    [[ONE_MAP_PTR_TMP_ASCAST:%.*]] = addrspacecast i32 (i32)** [[ONE_MAP_PTR_TMP]] to i32 (i32)* addrspace(4)*
// TARG:    [[TMP4:%.*]] = load i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)*, i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)* addrspace(4)* [[G_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP5:%.*]] = addrspacecast i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)* [[TMP4]] to i8 addrspace(4)*
// TARG-NEXT:    [[TMP6:%.*]] = call i8 addrspace(4)* @__kmpc_target_translate_fptr(i8 addrspace(4)* [[TMP5]])
// TARG-NEXT:    [[TMP7:%.*]] = addrspacecast i8 addrspace(4)* [[TMP6]] to i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)*
// TARG-NEXT:    [[TMP8:%.*]] = call i32 addrspace(4)* addrspace(4)* [[TMP7]](float 3.000000e+00, i32 addrspace(4)* addrspace(4)* [[CP_MAP_PTR_TMP_ASCAST]])
// TARG:  [[TMP11:%.*]] = load i32 (i32, i32)*, i32 (i32, i32)* addrspace(4)* [[TWO_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP12:%.*]] = addrspacecast i32 (i32, i32)* [[TMP11]] to i8 addrspace(4)*
// TARG-NEXT:    [[TMP13:%.*]] = call i8 addrspace(4)* @__kmpc_target_translate_fptr(i8 addrspace(4)* [[TMP12]])
// TARG-NEXT:    [[TMP14:%.*]] = addrspacecast i8 addrspace(4)* [[TMP13]] to i32 (i32, i32)*
// TARG-NEXT:    [[TMP15:%.*]] = call i32 [[TMP14]](i32 1, i32 2)
// TARG:    [[TMP20:%.*]] = load i32 (i32)*, i32 (i32)* addrspace(4)* [[ONE_MAP_PTR_TMP_ASCAST]], align 8
// TARG-NEXT:    [[TMP21:%.*]] = addrspacecast i32 (i32)* [[TMP20]] to i8 addrspace(4)*
// TARG-NEXT:    [[TMP22:%.*]] = call i8 addrspace(4)* @__kmpc_target_translate_fptr(i8 addrspace(4)* [[TMP21]])
// TARG-NEXT:    [[TMP23:%.*]] = addrspacecast i8 addrspace(4)* [[TMP22]] to i32 (i32)*
// TARG-NEXT:    [[TMP24:%.*]] = call i32 [[TMP23]](i32 1)
// TARG:    ret void
//
void bar()
{
  int ret = 0;
  int *const *(*g)(float, int* const &) = f5;
  int *const cp = &ret;
  int *const * retpcp = nullptr;
  #pragma omp target
  retpcp = g(3.0, cp);
  #pragma omp target
  two(1,2);
  fptr one = retpcp ? &moo : &zoo;
  #pragma omp target
  one(1);
}

struct C {
#pragma omp declare target
  void virtual foo() {};
};
// checking for virual function call to foo();
// TARG-LABEL: @_Z6test_5P1CMS_FvvE(
// TARG-NEXT:  entry:
// TARG-NEXT:    [[P_ADDR:%.*]] = alloca [[STRUCT_C:%.*]] addrspace(4)*, align 8
// TARG-NEXT:    [[Q_ADDR:%.*]] = alloca { i64, i64 }, align 8
// TARG-NEXT:    [[P_ADDR_ASCAST:%.*]] = addrspacecast [[STRUCT_C]] addrspace(4)** [[P_ADDR]] to [[STRUCT_C]] addrspace(4)* addrspace(4)*
// TARG-NEXT:    [[Q_ADDR_ASCAST:%.*]] = addrspacecast { i64, i64 }* [[Q_ADDR]] to { i64, i64 } addrspace(4)*
// TARG-NEXT:    [[Q:%.*]] = load { i64, i64 }, { i64, i64 } addrspace(4)* [[TMP0:%.*]], align 8
// TARG-NEXT:    store [[STRUCT_C]] addrspace(4)* [[P:%.*]], [[STRUCT_C]] addrspace(4)* addrspace(4)* [[P_ADDR_ASCAST]], align 8
// TARG-NEXT:    store { i64, i64 } [[Q]], { i64, i64 } addrspace(4)* [[Q_ADDR_ASCAST]], align 8
// TARG-NEXT:    [[TMP1:%.*]] = load [[STRUCT_C]] addrspace(4)*, [[STRUCT_C]] addrspace(4)* addrspace(4)* [[P_ADDR_ASCAST]], align 8
// TARG-NEXT:    [[TMP2:%.*]] = load { i64, i64 }, { i64, i64 } addrspace(4)* [[Q_ADDR_ASCAST]], align 8
// TARG-NEXT:    [[MEMPTR_ADJ:%.*]] = extractvalue { i64, i64 } [[TMP2]], 1
// TARG-NEXT:    [[TMP3:%.*]] = addrspacecast [[STRUCT_C]] addrspace(4)* [[TMP1]] to i8*
// TARG-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i8, i8* [[TMP3]], i64 [[MEMPTR_ADJ]]
// TARG-NEXT:    [[THIS_ADJUSTED:%.*]] = addrspacecast i8* [[TMP4]] to [[STRUCT_C]] addrspace(4)*
// TARG-NEXT:    [[MEMPTR_PTR:%.*]] = extractvalue { i64, i64 } [[TMP2]], 0
// TARG-NEXT:    [[TMP5:%.*]] = and i64 [[MEMPTR_PTR]], 1
// TARG-NEXT:    [[MEMPTR_ISVIRTUAL:%.*]] = icmp ne i64 [[TMP5]], 0
// TARG-NEXT:    br i1 [[MEMPTR_ISVIRTUAL]], label [[MEMPTR_VIRTUAL:%.*]], label [[MEMPTR_NONVIRTUAL:%.*]]
// TARG:       memptr.virtual:
// TARG-NEXT:    [[TMP6:%.*]] = bitcast [[STRUCT_C]] addrspace(4)* [[THIS_ADJUSTED]] to i8 addrspace(4)* addrspace(4)*
// TARG-NEXT:    [[VTABLE:%.*]] = load i8 addrspace(4)*, i8 addrspace(4)* addrspace(4)* [[TMP6]], align 8
// TARG-NEXT:    [[TMP7:%.*]] = sub i64 [[MEMPTR_PTR]], 1
// TARG-NEXT:    [[TMP8:%.*]] = getelementptr i8, i8 addrspace(4)* [[VTABLE]], i64 [[TMP7]], !nosanitize !11
// TARG-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(4)* [[TMP8]] to void ([[STRUCT_C]] addrspace(4)*)* addrspace(4)*, !nosanitize !11
// TARG-NEXT:    [[MEMPTR_VIRTUALFN:%.*]] = load void ([[STRUCT_C]] addrspace(4)*)*, void ([[STRUCT_C]] addrspace(4)*)* addrspace(4)* [[TMP9]], align 8, !nosanitize !11
// TARG-NEXT:    br label [[MEMPTR_END:%.*]]
// TARG:       memptr.nonvirtual:
// TARG-NEXT:    [[MEMPTR_NONVIRTUALFN:%.*]] = inttoptr i64 [[MEMPTR_PTR]] to void ([[STRUCT_C]] addrspace(4)*)*
// TARG-NEXT:    br label [[MEMPTR_END]]
// TARG:       memptr.end:
// TARG-NEXT:    [[TMP10:%.*]] = phi void ([[STRUCT_C]] addrspace(4)*)* [ [[MEMPTR_VIRTUALFN]], [[MEMPTR_VIRTUAL]] ], [ [[MEMPTR_NONVIRTUALFN]], [[MEMPTR_NONVIRTUAL]] ]
// TARG-NEXT:    [[TMP11:%.*]] = addrspacecast void ([[STRUCT_C]] addrspace(4)*)* [[TMP10]] to i8 addrspace(4)*
// TARG-NEXT:    [[TMP12:%.*]] = call i8 addrspace(4)* @__kmpc_target_translate_fptr(i8 addrspace(4)* [[TMP11]])
// TARG-NEXT:    [[TMP13:%.*]] = addrspacecast i8 addrspace(4)* [[TMP12]] to void ([[STRUCT_C]] addrspace(4)*)*
// TARG-NEXT:    call void [[TMP13]]([[STRUCT_C]] addrspace(4)* [[THIS_ADJUSTED]])
// TARG-NEXT:    ret void
//
void test_5(C *p, void (C::*q)(void)) {
  (p->*q)();
}
typedef  void (C::*PMFn)();

int main()
{
  C c;
  C *cp = &c;
  PMFn pf = &C::foo;
  test_5(cp, pf);
  bar();
}
// TARG: !omp_offload.info = !{!0, !1, !2, !3, !4, !5, !6, !7}
// TARG: !3 = !{i32 2, !"_Z2f5fRKPi", i32 3, i32 addrspace(4)* addrspace(4)* (float, i32 addrspace(4)* addrspace(4)*)* @_Z2f5fRKPi}
// TARG-NEXT: !4 = !{i32 2, !"_Z3mooi", i32 {{.*}}, i32 (i32)* @_Z3mooi}
// TARG-NEXT: !5 = !{i32 2, !"_Z3zooi", i32 {{.*}}, i32 (i32)* @_Z3zooi}
// TARG-NEXT: !6 = !{i32 2, !"_Z4barrii", i32 0, i32 (i32, i32)* @_Z4barrii}
// TARG-NEXT: !7 = !{i32 2, !"_ZN1C3fooEv", i32 7, void (%struct.C addrspace(4)*)* @_ZN1C3fooEv}
// end INTEL_COLLAB
