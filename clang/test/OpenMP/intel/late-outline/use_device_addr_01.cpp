// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
//INTEL_COLLAB
//RUN: %clang_cc1 -opaque-pointers -emit-llvm -o - -fopenmp \
//RUN:  -fopenmp-version=51 -fopenmp-late-outline -x c++ \
//RUN:  -triple x86_64-unknown-linux-gnu %s | FileCheck %s

int printf(const char*,...);
// CHECK-LABEL: define {{[^@]+}}@_Z3noov(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[BR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[BR_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[B]], ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[TMP0]], align 8
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i16, ptr [[TMP1]], i64 -1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[TMP2]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[TMP3]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i16, ptr [[TMP4]], i64 1
// CHECK-NEXT:    store i16 111, ptr [[ARRAYIDX]], align 2
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[TMP6]], align 8
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i16, ptr [[TMP7]], i64 1
// CHECK-NEXT:    [[TMP8:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP5]], ptr [[ARRAYIDX1]], i64 2, i64 19, ptr null, ptr null) ]
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP9]], ptr [[TMP9]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR:BYREF"(ptr [[BR]]) ]
// CHECK-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[BR]], align 8
// CHECK-NEXT:    [[TMP13:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 0), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP12]], ptr [[TMP12]], i64 8, i64 288, ptr null, ptr null), "QUAL.OMP.PRIVATE"(ptr [[BR_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP12]], ptr [[BR_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[BR_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP14]], align 8
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i16, ptr [[TMP15]], i64 1
// CHECK-NEXT:    store i16 222, ptr [[ARRAYIDX2]], align 2
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP13]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP11]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP8]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void noo() {
  short *b;
  short *&br = b;
  br = br - 1;

  br[1] = 111;
#pragma omp target data map(tofrom : br[1])
#pragma omp target data use_device_addr(br)
  {
#pragma omp target has_device_addr(br[1])
    {
      br[1] = 222;
    }
  }
}
// CHECK-LABEL: define {{[^@]+}}@_Z3ooov(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca i16, align 2
// CHECK-NEXT:    store i16 1, ptr [[A]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[A]], ptr [[A]], i64 2, i64 67, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[A]]) ]
// CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 1), "QUAL.OMP.MAP.TO"(ptr [[A]], ptr [[A]], i64 8, i64 33, ptr null, ptr null) ]
// CHECK-NEXT:    store i16 222, ptr [[A]], align 2
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void ooo() {
  short a = 1;

#pragma omp target data map(tofrom : a) use_device_addr(a)
#pragma omp target has_device_addr(a)
  {
    a = 222;
  }
}
// CHECK-LABEL: define {{[^@]+}}@_Z5test1v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    [[X_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[X]], i64 0, i64 1
// CHECK-NEXT:    store i32 111, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [10 x i32], ptr [[X]], i64 0, i64 1
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[X]], ptr [[ARRAYIDX1]], i64 12, i64 67, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[X]]), "QUAL.OMP.LIVEIN"(ptr [[X_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[X]], ptr [[X_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[X_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 2), "QUAL.OMP.MAP.TO"(ptr [[TMP1]], ptr [[TMP1]], i64 8, i64 33, ptr null, ptr null) ]
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [10 x i32], ptr [[TMP1]], i64 0, i64 1
// CHECK-NEXT:    store i32 222, ptr [[ARRAYIDX2]], align 4
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void test1() {
  int x[10];
  x[1] = 111;

  #pragma omp target data map(tofrom: x[1:3]) use_device_addr(x[1:3])
  #pragma omp target has_device_addr(x[1:3])
  {
    x[1] = 222;
  }
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test2v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X:%.*]] = alloca [10 x i16], align 16
// CHECK-NEXT:    [[XP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[XP_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[XP_MAP_PTR_TMP2:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i16], ptr [[X]], i64 0, i64 0
// CHECK-NEXT:    store ptr [[ARRAYIDX]], ptr [[XP]], align 8
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [10 x i16], ptr [[X]], i64 0, i64 1
// CHECK-NEXT:    store i16 111, ptr [[ARRAYIDX1]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[XP]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[X]], ptr [[X]], i64 20, i64 3, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP0]], ptr [[TMP0]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[TMP0]]), "QUAL.OMP.LIVEIN"(ptr [[XP_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[XP_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[XP_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 3), "QUAL.OMP.LIVEIN"(ptr %xp.map.ptr.tmp), "QUAL.OMP.MAP.TOFROM"(ptr %2, ptr %2, i64 8, i64 288, ptr null, ptr null), "QUAL.OMP.PRIVATE"(ptr %xp.map.ptr.tmp2)
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[XP_MAP_PTR_TMP2]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[XP_MAP_PTR_TMP2]], align 8
// CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i16, ptr [[TMP4]], i64 1
// CHECK-NEXT:    store i16 222, ptr [[ARRAYIDX3]], align 2
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP3]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void test2() {
  short x[10];
  short *xp = &x[0];

  x[1] = 111;

  #pragma omp target data use_device_addr(xp[1:3]) map(tofrom: x)
  #pragma omp target is_device_ptr(xp)
  {
    xp[1] = 222;
  }
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test3v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X:%.*]] = alloca [10 x i16], align 16
// CHECK-NEXT:    [[XP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[XP_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[XP_MAP_PTR_TMP3:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i16], ptr [[X]], i64 0, i64 0
// CHECK-NEXT:    store ptr [[ARRAYIDX]], ptr [[XP]], align 8
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [10 x i16], ptr [[X]], i64 0, i64 1
// CHECK-NEXT:    store i16 111, ptr [[ARRAYIDX1]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[XP]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[XP]], align 8
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i16, ptr [[TMP1]], i64 0
// CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP0]], ptr [[ARRAYIDX2]], i64 20, i64 67, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[TMP0]]), "QUAL.OMP.LIVEIN"(ptr [[XP_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[XP_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[XP_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 4), "QUAL.OMP.LIVEIN"(ptr %xp.map.ptr.tmp), "QUAL.OMP.MAP.TOFROM"(ptr %3, ptr %3, i64 8, i64 288, ptr null, ptr null), "QUAL.OMP.PRIVATE"(ptr %xp.map.ptr.tmp3) ]
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[XP_MAP_PTR_TMP3]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[XP_MAP_PTR_TMP3]], align 8
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i16, ptr [[TMP5]], i64 1
// CHECK-NEXT:    store i16 222, ptr [[ARRAYIDX4]], align 2
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP4]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void test3() {
  short x[10];
  short *xp = &x[0];

  x[1] = 111;

  #pragma omp target data map(tofrom: xp[0:10]) use_device_addr(xp[1])
  #pragma omp target is_device_ptr(xp)
  {
    xp[1] = 222;
  }
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test4v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X:%.*]] = alloca i16, align 2
// CHECK-NEXT:    [[P_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[P]], ptr [[P]], i64 8, i64 3, ptr null, ptr null) ]
// CHECK-NEXT:    [[TMP1:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[P]], ptr [[P]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[P]]) ]
// CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 5) ]
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 (ptr, ...) @_Z6printfPKcz(ptr noundef @.str) #[[ATTR1:[0-9]+]]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP1]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    store i16 111, ptr [[X]], align 2
// CHECK-NEXT:    store ptr [[X]], ptr [[P]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i16, ptr [[TMP4]], i64 0
// CHECK-NEXT:    [[TMP5:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TO"(ptr [[TMP3]], ptr [[ARRAYIDX]], i64 2, i64 1, ptr null, ptr null) ]
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP6]], ptr [[TMP6]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[TMP6]]), "QUAL.OMP.LIVEIN"(ptr [[P_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[P_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 6) ]
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef i32 (ptr, ...) @_Z6printfPKcz(ptr noundef @.str) #[[ATTR1]]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP8]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP7]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP5]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void test4() {
  short *p;

  #pragma omp target data map(p) //   map p itself, not its pointee
  {
    #pragma omp target data use_device_addr(p)
    {
      #pragma omp target has_device_addr(p)
      printf("ddd\n");
    }
  }

  short x = 111;
  p = &x;

  #pragma omp target data map(to:p[0:1]) // map the pointee of p
  {
    #pragma omp target data use_device_addr(p[0])
    {
      #pragma omp target has_device_addr(p[0])
       printf("ddd\n");
    }
  }
}

// CHECK-LABEL: define {{[^@]+}}@_Z5test6v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    [[P:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[P_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[A]], i64 0, i64 1
// CHECK-NEXT:    store i32 111, ptr [[ARRAYIDX]], align 4
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [10 x i32], ptr [[A]], i64 0, i64 0
// CHECK-NEXT:    store ptr [[ARRAYIDX1]], ptr [[P]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i64 1
// CHECK-NEXT:    [[TMP2:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[P]], ptr [[P]], i64 8, i64 3, ptr null, ptr null), "QUAL.OMP.MAP.TO:CHAIN"(ptr [[TMP0]], ptr [[ARRAYIDX2]], i64 12, i64 1, ptr null, ptr null) ]
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[P]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP3]], ptr [[TMP3]], i64 0, i64 64, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[TMP3]]), "QUAL.OMP.LIVEIN"(ptr [[P_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP3]], ptr [[P_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 7), "QUAL.OMP.MAP.TO"(ptr [[P_MAP_PTR_TMP]], ptr [[P_MAP_PTR_TMP]], i64 8, i64 33, ptr null, ptr null) ]
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[P_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i32, ptr [[TMP6]], i64 1
// CHECK-NEXT:    store i32 222, ptr [[ARRAYIDX3]], align 4
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP5]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP4]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP2]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void test6() {
  int a[10];
  int *p;
  a[1] = 111;
  p = &a[0];
  #pragma omp target data map(p) map(to:p[1:3])  //
  #pragma omp target data use_device_addr(p[1:3])
  {
#pragma omp target has_device_addr(p)
    {
      p[1] = 222;
    }
  }
}
// CHECK-LABEL: define {{[^@]+}}@_Z5test5v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X:%.*]] = alloca [10 x i16], align 16
// CHECK-NEXT:    [[XP:%.*]] = alloca [10 x ptr], align 16
// CHECK-NEXT:    [[XPP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[XPP_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[XPP_MAP_PTR_TMP7:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[XPP_MAP_PTR_TMP8:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i16], ptr [[X]], i64 0, i64 0
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [10 x ptr], ptr [[XP]], i64 0, i64 1
// CHECK-NEXT:    store ptr [[ARRAYIDX]], ptr [[ARRAYIDX1]], align 8
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [10 x ptr], ptr [[XP]], i64 0, i64 0
// CHECK-NEXT:    store ptr [[ARRAYIDX2]], ptr [[XPP]], align 8
// CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds [10 x i16], ptr [[X]], i64 0, i64 1
// CHECK-NEXT:    store i16 111, ptr [[ARRAYIDX3]], align 2
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[XPP]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[XPP]], align 8
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds ptr, ptr [[TMP1]], i64 1
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[XPP]], align 8
// CHECK-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds ptr, ptr [[TMP2]], i64 1
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[ARRAYIDX5]], align 8
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i16, ptr [[TMP3]], i64 1
// CHECK-NEXT:    [[TMP4:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP0]], ptr [[ARRAYIDX4]], i64 8, i64 67, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[ARRAYIDX4]], ptr [[ARRAYIDX6]], i64 2, i64 19, ptr null, ptr null), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[TMP0]]), "QUAL.OMP.USE_DEVICE_ADDR"(ptr [[ARRAYIDX4]]), "QUAL.OMP.LIVEIN"(ptr [[XPP_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[XPP_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    store ptr [[ARRAYIDX4]], ptr [[XPP_MAP_PTR_TMP7]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[XPP_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 8), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP5]], ptr [[TMP5]], i64 8, i64 288, ptr null, ptr null), "QUAL.OMP.PRIVATE"(ptr [[XPP_MAP_PTR_TMP8]]) ]
// CHECK-NEXT:    store ptr [[TMP5]], ptr [[XPP_MAP_PTR_TMP8]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[XPP_MAP_PTR_TMP8]], align 8
// CHECK-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds ptr, ptr [[TMP7]], i64 1
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[ARRAYIDX9]], align 8
// CHECK-NEXT:    [[ARRAYIDX10:%.*]] = getelementptr inbounds i16, ptr [[TMP8]], i64 1
// CHECK-NEXT:    store i16 222, ptr [[ARRAYIDX10]], align 2
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP6]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP4]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    ret void
//
void test5() {
 short x[10];
  short *(xp[10]);
  xp[1] = &x[0];
  short **xpp = &xp[0];

  x[1] = 111;

  #pragma omp target data map(tofrom: xpp[1][1]) use_device_addr(xpp[0:1][0:1])
  #pragma omp target has_device_addr(xpp[1][1])
  {
    xpp[1][1] = 222;
  }
}
