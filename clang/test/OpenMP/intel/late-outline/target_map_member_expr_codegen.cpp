// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs --replace-value-regex "__omp_offloading_[0-9a-z]+_[0-9a-z]+" "reduction_size[.].+[.]" "pl_cond[.].+[.|,]" --prefix-filecheck-ir-name _
// RUN: %clang_cc1 -verify -fopenmp -fopenmp-targets=x86_64-pc-linux-gnu  \
// RUN:  -fopenmp-late-outline \
// RUN:  -x c++ -triple x86_64-unknown-linux-gnu -emit-llvm %s -o - \
// RUN:   | FileCheck %s

// expected-no-diagnostics


class A {
protected:
  int X;
  int Y;

public:
  A (int x, int y) : X { x }, Y { y } { };
};

class B : public A {
  using A::X;
  using A::Y;
public:
  int res;
  B (int x, int y) : A(x,y), res{0} {}
  void run (void) {
  #pragma omp target
     res = X + Y;
  }
};

template<typename T>
struct descriptor
{
  T *A;
  T *C;
  T *C_ref;
  unsigned M;
  unsigned K;
  unsigned N;
};

class BASE
{
};

//template<typename T>
class C : public BASE
{
public:
  void bar (descriptor<float> &d)
  {
     auto Asize = d.M * d.K;
     auto Csize = d.M * d.N;
     #pragma omp target data map(to:d.A[0:Asize]) map(from:d.C[0:Csize])
     {
       #pragma omp target teams firstprivate(Csize)
       for (int i = 0; i < Csize; ++i)
          d.C[i] = 1;
     }
     #pragma omp target map(from:d.C[0:Csize])
     for (int i = 0; i < Csize; ++i)
        d.C[i] = 1;
   }
};

void foo() {
  B b(2, 3);
  b.run();
  C c;
  descriptor<float> d;
  c.bar(d);
}
// CHECK-LABEL: define {{[^@]+}}@_Z3foov
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = alloca [[CLASS_B:%.*]], align 4
// CHECK-NEXT:    [[C:%.*]] = alloca [[CLASS_C:%.*]], align 1
// CHECK-NEXT:    [[D:%.*]] = alloca [[STRUCT_DESCRIPTOR:%.*]], align 8
// CHECK-NEXT:    call void @_ZN1BC1Eii(ptr noundef nonnull align 4 dereferenceable(12) [[B]], i32 noundef 2, i32 noundef 3)
// CHECK-NEXT:    call void @_ZN1B3runEv(ptr noundef nonnull align 4 dereferenceable(12) [[B]])
// CHECK-NEXT:    call void @_ZN1C3barER10descriptorIfE(ptr noundef nonnull align 1 dereferenceable(1) [[C]], ptr noundef nonnull align 8 dereferenceable(40) [[D]])
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1BC1Eii
// CHECK-SAME: (ptr noundef nonnull align 4 dereferenceable(12) [[THIS:%.*]], i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) unnamed_addr #[[ATTR1:[0-9]+]] comdat align 2 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[Y_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    store i32 [[Y]], ptr [[Y_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[Y_ADDR]], align 4
// CHECK-NEXT:    call void @_ZN1BC2Eii(ptr noundef nonnull align 4 dereferenceable(12) [[THIS1]], i32 noundef [[TMP0]], i32 noundef [[TMP1]])
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1B3runEv
// CHECK-SAME: (ptr noundef nonnull align 4 dereferenceable(12) [[THIS:%.*]]) #[[ATTR2:[0-9]+]] comdat align 2 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[RES:%.*]] = getelementptr inbounds [[CLASS_B:%.*]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds [[CLASS_A:%.*]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[Y:%.*]] = getelementptr inbounds [[CLASS_A]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 0), "QUAL.OMP.MAP.TOFROM"(ptr [[THIS1]], ptr [[THIS1]], i64 12, i64 32, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[THIS1]], ptr [[RES]], i64 4, i64 281474976711171, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[THIS1]], ptr [[X]], i64 4, i64 281474976711171, ptr null, ptr null), "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[THIS1]], ptr [[Y]], i64 4, i64 281474976711171, ptr null, ptr null), "QUAL.OMP.FIRSTPRIVATE"(ptr [[THIS1]]) ]
// CHECK-NEXT:    [[X2:%.*]] = getelementptr inbounds [[CLASS_A]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[X2]], align 4
// CHECK-NEXT:    [[Y3:%.*]] = getelementptr inbounds [[CLASS_A]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[Y3]], align 4
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], [[TMP2]]
// CHECK-NEXT:    [[RES4:%.*]] = getelementptr inbounds [[CLASS_B]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    store i32 [[ADD]], ptr [[RES4]], align 4
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1C3barER10descriptorIfE
// CHECK-SAME: (ptr noundef nonnull align 1 dereferenceable(1) [[THIS:%.*]], ptr noundef nonnull align 8 dereferenceable(40) [[D:%.*]]) #[[ATTR2]] comdat align 2 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[ASIZE:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CSIZE:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[D_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[D_MAP_PTR_TMP14:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[I15:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[M:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR:%.*]], ptr [[TMP0]], i32 0, i32 3
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[M]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[K:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP2]], i32 0, i32 4
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[K]], align 4
// CHECK-NEXT:    [[MUL:%.*]] = mul i32 [[TMP1]], [[TMP3]]
// CHECK-NEXT:    store i32 [[MUL]], ptr [[ASIZE]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[M2:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP4]], i32 0, i32 3
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[M2]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[N:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP6]], i32 0, i32 5
// CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[N]], align 8
// CHECK-NEXT:    [[MUL3:%.*]] = mul i32 [[TMP5]], [[TMP7]]
// CHECK-NEXT:    store i32 [[MUL3]], ptr [[CSIZE]], align 4
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP9]], i32 0, i32 0
// CHECK-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[A4:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP10]], i32 0, i32 0
// CHECK-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[A4]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP11]], i64 0
// CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr [[ASIZE]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = zext i32 [[TMP12]] to i64
// CHECK-NEXT:    [[TMP13:%.*]] = mul nuw i64 [[CONV]], 4
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP15]], i32 0, i32 1
// CHECK-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[C5:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP16]], i32 0, i32 1
// CHECK-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[C5]], align 8
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds float, ptr [[TMP17]], i64 0
// CHECK-NEXT:    [[TMP18:%.*]] = load i32, ptr [[CSIZE]], align 4
// CHECK-NEXT:    [[CONV7:%.*]] = zext i32 [[TMP18]] to i64
// CHECK-NEXT:    [[TMP19:%.*]] = mul nuw i64 [[CONV7]], 4
// CHECK-NEXT:    [[TMP20:%.*]] = getelementptr ptr, ptr [[C]], i32 1
// CHECK-NEXT:    [[TMP21:%.*]] = ptrtoint ptr [[TMP20]] to i64
// CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint ptr [[A]] to i64
// CHECK-NEXT:    [[TMP23:%.*]] = sub i64 [[TMP21]], [[TMP22]]
// CHECK-NEXT:    [[TMP24:%.*]] = sdiv exact i64 [[TMP23]], ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
// CHECK-NEXT:    [[TMP25:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET.DATA"(), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP8]], ptr [[A]], i64 [[TMP24]], i64 0, ptr null, ptr null), "QUAL.OMP.MAP.TO:CHAIN"(ptr [[A]], ptr [[ARRAYIDX]], i64 [[TMP13]], i64 281474976710673, ptr null, ptr null), "QUAL.OMP.MAP.FROM:CHAIN"(ptr [[C]], ptr [[ARRAYIDX6]], i64 [[TMP19]], i64 281474976710674, ptr null, ptr null) ]
// CHECK-NEXT:    [[TMP26:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP27:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP28:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP29:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 1), "QUAL.OMP.FIRSTPRIVATE"(ptr [[CSIZE]]), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP27]], ptr [[TMP28]], i64 40, i64 547, ptr null, ptr null), "QUAL.OMP.PRIVATE"(ptr [[I]]), "QUAL.OMP.PRIVATE"(ptr [[D_MAP_PTR_TMP]]) ]
// CHECK-NEXT:    store ptr [[TMP27]], ptr [[D_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP30:%.*]] = load ptr, ptr [[D_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[TMP31:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TEAMS"(), "QUAL.OMP.FIRSTPRIVATE"(ptr [[CSIZE]]), "QUAL.OMP.SHARED:BYREF"(ptr [[D_MAP_PTR_TMP]]), "QUAL.OMP.PRIVATE"(ptr [[I]]) ]
// CHECK-NEXT:    store i32 0, ptr [[I]], align 4
// CHECK-NEXT:    br label [[FOR_COND:%.*]]
// CHECK:       for.cond:
// CHECK-NEXT:    [[TMP32:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[TMP33:%.*]] = load i32, ptr [[CSIZE]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP32]], [[TMP33]]
// CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK:       for.body:
// CHECK-NEXT:    [[TMP34:%.*]] = load ptr, ptr [[D_MAP_PTR_TMP]], align 8
// CHECK-NEXT:    [[C8:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP34]], i32 0, i32 1
// CHECK-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[C8]], align 8
// CHECK-NEXT:    [[TMP36:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP36]] to i64
// CHECK-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds float, ptr [[TMP35]], i64 [[IDXPROM]]
// CHECK-NEXT:    store float 1.000000e+00, ptr [[ARRAYIDX9]], align 4
// CHECK-NEXT:    br label [[FOR_INC:%.*]]
// CHECK:       for.inc:
// CHECK-NEXT:    [[TMP37:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP37]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[I]], align 4
// CHECK-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK:       for.end:
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP31]]) [ "DIR.OMP.END.TEAMS"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP29]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP25]]) [ "DIR.OMP.END.TARGET.DATA"() ]
// CHECK-NEXT:    [[TMP38:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP39:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[TMP40:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[C10:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP40]], i32 0, i32 1
// CHECK-NEXT:    [[TMP41:%.*]] = load ptr, ptr [[D_ADDR]], align 8
// CHECK-NEXT:    [[C11:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP41]], i32 0, i32 1
// CHECK-NEXT:    [[TMP42:%.*]] = load ptr, ptr [[C11]], align 8
// CHECK-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds float, ptr [[TMP42]], i64 0
// CHECK-NEXT:    [[TMP43:%.*]] = load i32, ptr [[CSIZE]], align 4
// CHECK-NEXT:    [[CONV13:%.*]] = zext i32 [[TMP43]] to i64
// CHECK-NEXT:    [[TMP44:%.*]] = mul nuw i64 [[CONV13]], 4
// CHECK-NEXT:    [[TMP45:%.*]] = getelementptr ptr, ptr [[C10]], i32 1
// CHECK-NEXT:    [[TMP46:%.*]] = ptrtoint ptr [[TMP45]] to i64
// CHECK-NEXT:    [[TMP47:%.*]] = ptrtoint ptr [[C10]] to i64
// CHECK-NEXT:    [[TMP48:%.*]] = sub i64 [[TMP46]], [[TMP47]]
// CHECK-NEXT:    [[TMP49:%.*]] = sdiv exact i64 [[TMP48]], ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
// CHECK-NEXT:    [[TMP50:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OMP.TARGET"(), "QUAL.OMP.OFFLOAD.ENTRY.IDX"(i32 2), "QUAL.OMP.MAP.TOFROM"(ptr [[TMP39]], ptr [[C10]], i64 [[TMP49]], i64 32, ptr null, ptr null), "QUAL.OMP.MAP.FROM:CHAIN"(ptr [[C10]], ptr [[ARRAYIDX12]], i64 [[TMP44]], i64 281474976710674, ptr null, ptr null), "QUAL.OMP.FIRSTPRIVATE"(ptr [[CSIZE]]), "QUAL.OMP.PRIVATE"(ptr [[I15]]), "QUAL.OMP.PRIVATE"(ptr [[D_MAP_PTR_TMP14]]) ]
// CHECK-NEXT:    store ptr [[TMP39]], ptr [[D_MAP_PTR_TMP14]], align 8
// CHECK-NEXT:    store i32 0, ptr [[I15]], align 4
// CHECK-NEXT:    br label [[FOR_COND16:%.*]]
// CHECK:       for.cond16:
// CHECK-NEXT:    [[TMP51:%.*]] = load i32, ptr [[I15]], align 4
// CHECK-NEXT:    [[TMP52:%.*]] = load i32, ptr [[CSIZE]], align 4
// CHECK-NEXT:    [[CMP17:%.*]] = icmp ult i32 [[TMP51]], [[TMP52]]
// CHECK-NEXT:    br i1 [[CMP17]], label [[FOR_BODY18:%.*]], label [[FOR_END24:%.*]]
// CHECK:       for.body18:
// CHECK-NEXT:    [[TMP53:%.*]] = load ptr, ptr [[D_MAP_PTR_TMP14]], align 8
// CHECK-NEXT:    [[C19:%.*]] = getelementptr inbounds [[STRUCT_DESCRIPTOR]], ptr [[TMP53]], i32 0, i32 1
// CHECK-NEXT:    [[TMP54:%.*]] = load ptr, ptr [[C19]], align 8
// CHECK-NEXT:    [[TMP55:%.*]] = load i32, ptr [[I15]], align 4
// CHECK-NEXT:    [[IDXPROM20:%.*]] = sext i32 [[TMP55]] to i64
// CHECK-NEXT:    [[ARRAYIDX21:%.*]] = getelementptr inbounds float, ptr [[TMP54]], i64 [[IDXPROM20]]
// CHECK-NEXT:    store float 1.000000e+00, ptr [[ARRAYIDX21]], align 4
// CHECK-NEXT:    br label [[FOR_INC22:%.*]]
// CHECK:       for.inc22:
// CHECK-NEXT:    [[TMP56:%.*]] = load i32, ptr [[I15]], align 4
// CHECK-NEXT:    [[INC23:%.*]] = add nsw i32 [[TMP56]], 1
// CHECK-NEXT:    store i32 [[INC23]], ptr [[I15]], align 4
// CHECK-NEXT:    br label [[FOR_COND16]], !llvm.loop [[LOOP8:![0-9]+]]
// CHECK:       for.end24:
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP50]]) [ "DIR.OMP.END.TARGET"() ]
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1BC2Eii
// CHECK-SAME: (ptr noundef nonnull align 4 dereferenceable(12) [[THIS:%.*]], i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) unnamed_addr #[[ATTR1]] comdat align 2 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[Y_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    store i32 [[Y]], ptr [[Y_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[Y_ADDR]], align 4
// CHECK-NEXT:    call void @_ZN1AC2Eii(ptr noundef nonnull align 4 dereferenceable(8) [[THIS1]], i32 noundef [[TMP0]], i32 noundef [[TMP1]])
// CHECK-NEXT:    [[RES:%.*]] = getelementptr inbounds [[CLASS_B:%.*]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    store i32 0, ptr [[RES]], align 4
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1AC2Eii
// CHECK-SAME: (ptr noundef nonnull align 4 dereferenceable(8) [[THIS:%.*]], i32 noundef [[X:%.*]], i32 noundef [[Y:%.*]]) unnamed_addr #[[ATTR1]] comdat align 2 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[Y_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    store i32 [[Y]], ptr [[Y_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds [[CLASS_A:%.*]], ptr [[THIS1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    store i32 [[TMP0]], ptr [[X]], align 4
// CHECK-NEXT:    [[Y:%.*]] = getelementptr inbounds [[CLASS_A]], ptr [[THIS1]], i32 0, i32 1
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[Y_ADDR]], align 4
// CHECK-NEXT:    store i32 [[TMP1]], ptr [[Y]], align 4
// CHECK-NEXT:    ret void
//
//
// CHECK-LABEL: define {{[^@]+}}@.omp_offloading.requires_reg
// CHECK-SAME: () #[[ATTR4:[0-9]+]] section ".text.startup" {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @__tgt_register_requires(i64 1)
// CHECK-NEXT:    ret void
//
