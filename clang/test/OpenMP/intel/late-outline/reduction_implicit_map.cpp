// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs --replace-value-regex "__omp_offloading_[0-9a-z]+_[0-9a-z]+" "reduction_size[.].+[.]" "pl_cond[.].+[.|,]" --prefix-filecheck-ir-name _

// INTEL_COLLAB

// RUN: %clang_cc1 -verify -fopenmp -x c++ \
// RUN:   -fopenmp-late-outline -emit-llvm \
// RUN:   -triple x86_64-pc-linux-gnu \
// RUN:   %s -o - | FileCheck %s

// Test map type with OMP_TGT_MAPTYPE_HOST_MEM 0x8000

int foo(int n) {
  double *e;
  double sum;
  #pragma omp target parallel reduction(+: e[:1])
    *e=10;
  #pragma omp target parallel map(e[:1]) reduction(+: e[:1])
    *e=10;
  #pragma omp target parallel reduction(+: sum)
    sum += e[0];
  return 0;
}
class S2 {
  mutable int a;
public:
  S2():a(0) { }
  S2(S2 &s2):a(s2.a) { }
  S2 &operator +(S2 &s);
  void moo() {
    #pragma omp target parallel reduction(+:a)
    a += 10;
  }
};
int bar() {
 S2 o[5];
#pragma omp target parallel reduction(+:o[0]) // expected-warning {{Type 'S2' is not trivially copyable and not guaranteed to be mapped correctly}}
  for (int i = 0; i < 10; i++);
  double b[10][10][10];
#pragma omp target parallel for reduction(task, +: b[0:2][2:4][1])
  for (long long i = 0; i < 10; ++i);
  o[0].moo();
  return 0;
}
void sum(int* input, int size, int* output)
{
#pragma omp target teams distribute parallel for reduction(+: output[0]) \
                                                 map(to: input [0:size])
  for (int i = 0; i < size; i++)
    output[0] += input[i];
#pragma omp target teams distribute parallel for reduction(+: output[:3])  \
                                                 map(to: input [0:size])
  for (int i = 0; i < size; i++)
    output[0] += input[i];
  int a[10];
#pragma omp target parallel reduction(+: a[:2])
  for (int i = 0; i < size; i++)
    ;
#pragma omp target parallel reduction(+: a[3])
  for (int i = 0; i < size; i++)
    ;
}
int main()
{
  int a = foo(10);
  a = bar();
  const int size = 100;
  int *array = new int[size];
  int result = 0;
  sum(array, size, &result);
  return 0;
}
// CHECK-LABEL: define {{[^@]+}}@_Z3fooi
// CHECK-SAME: (i32 noundef [[N:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[E:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[SUM:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[E_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[E_MAP_PTR_TMP3:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[E_MAP_PTR_TMP4:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store i32 [[N]], ptr [[N_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, ptr [[TMP2]], i64 0
// CHECK-NEXT:    "DIR.OMP.TARGET"(),
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[TMP1]], ptr [[ARRAYIDX]], i64 8, i64 33315, ptr null, ptr null),
// CHECK:          "DIR.OMP.PARALLEL"()
// CHECK:          "DIR.OMP.END.PARALLEL"()
// CHECK-NEXT:     "DIR.OMP.END.TARGET"()
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds double, ptr [[TMP8]], i64 0
// CHECK-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds double, ptr [[TMP10]], i64 0
// CHECK-NEXT:    "DIR.OMP.TARGET"()
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[TMP7]], ptr [[ARRAYIDX1]], i64 8, i64 35, ptr null, ptr null),
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM:CHAIN"(ptr [[TMP9]], ptr [[ARRAYIDX2]], i64 8, i64 515, ptr null, ptr null)
// CHECK:         "DIR.OMP.PARALLEL"()
// CHECK:         "DIR.OMP.END.PARALLEL"()
// CHECK:         "DIR.OMP.END.TARGET"()
// CHECK:         [[TMP14:%.*]] = load ptr, ptr [[E]], align 8
// CHECK-NEXT:    "DIR.OMP.TARGET"
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[SUM]], ptr [[SUM]], i64 8, i64 33315
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[TMP14]], ptr [[TMP14]], i64 0, i64 544
// CHECK:         "DIR.OMP.PARALLEL"()
// CHECK:         "DIR.OMP.END.PARALLEL"()
// CHECK:         "DIR.OMP.END.TARGET"()
// CHECK-NEXT:    ret i32 0
//
//
// CHECK-LABEL: define {{[^@]+}}@_Z3barv
// CHECK-SAME: () #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[O:%.*]] = alloca [5 x %class.S2], align 16
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[B:%.*]] = alloca [10 x [10 x [10 x double]]], align 16
// CHECK-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[I2:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[ARRAY_BEGIN:%.*]] = getelementptr inbounds [5 x %class.S2], ptr [[O]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYCTOR_END:%.*]] = getelementptr inbounds [[CLASS_S2:%.*]], ptr [[ARRAY_BEGIN]], i64 5
// CHECK-NEXT:    br label [[ARRAYCTOR_LOOP:%.*]]
// CHECK:       arrayctor.loop:
// CHECK-NEXT:    [[ARRAYCTOR_CUR:%.*]] = phi ptr [ [[ARRAY_BEGIN]], [[ENTRY:%.*]] ], [ [[ARRAYCTOR_NEXT:%.*]], [[ARRAYCTOR_LOOP]] ]
// CHECK-NEXT:    call void @_ZN2S2C1Ev(ptr noundef nonnull align 4 dereferenceable(4) [[ARRAYCTOR_CUR]])
// CHECK-NEXT:    [[ARRAYCTOR_NEXT]] = getelementptr inbounds [[CLASS_S2]], ptr [[ARRAYCTOR_CUR]], i64 1
// CHECK-NEXT:    [[ARRAYCTOR_DONE:%.*]] = icmp eq ptr [[ARRAYCTOR_NEXT]], [[ARRAYCTOR_END]]
// CHECK-NEXT:    br i1 [[ARRAYCTOR_DONE]], label [[ARRAYCTOR_CONT:%.*]], label [[ARRAYCTOR_LOOP]]
// CHECK:       arrayctor.cont:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [5 x %class.S2], ptr [[O]], i64 0, i64 0
// CHECK-NEXT:    "DIR.OMP.TARGET"()
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[O]], ptr [[ARRAYIDX]], i64 4, i64 33315, ptr null, ptr null)
// CHECK-NEXT:    "DIR.OMP.PARALLEL"()
// CHECK:         "DIR.OMP.END.PARALLEL"()
// CHECK-NEXT:    "DIR.OMP.END.TARGET"()
// CHECK-NEXT:    "DIR.OMP.TARGET"()
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[B]], ptr [[B]], i64 8000, i64 33315, ptr null, ptr null)
// CHECK:         "DIR.OMP.PARALLEL.LOOP"()
// CHECK:         "DIR.OMP.END.PARALLEL.LOOP"()
// CHECK:         "DIR.OMP.END.TARGET"()
// CHECK:    ret i32 0
//
// CHECK-LABEL: define {{[^@]+}}@_ZN2S23mooEv
// CHECK: [[THIS:%.*]] = alloca ptr
// CHECK: [[A:%.*]] = alloca ptr
// CHECK: [[THIS1:%.*]] = load ptr, ptr [[THIS]]
// CHECK: [[A2:%.*]] = getelementptr inbounds %class.S2, ptr [[THIS1]]
// CHECK: [[A3:%.*]] = getelementptr inbounds %class.S2, ptr [[THIS1]]
// CHECK: "DIR.OMP.TARGET"
// CHECK-SAME: "QUAL.OMP.MAP.TOFROM"(ptr [[A3]], ptr [[A3]], i64 4, i64 33315
// CHECK: "DIR.OMP.PARALLEL"
// CHECK: "DIR.OMP.END.PARALLEL"
// CHECK: "DIR.OMP.END.TARGET"
// CHECK: ret void
//
// CHECK-LABEL: define {{[^@]+}}@_Z3sumPiiS_
// CHECK-SAME: (ptr noundef [[INPUT:%.*]], i32 noundef [[SIZE:%.*]], ptr noundef [[OUTPUT:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[INPUT_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[SIZE_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[OUTPUT_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[OUTPUT_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[INPUT_MAP_PTR_TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_0:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_1:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[OUTPUT_MAP_PTR_TMP13:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[INPUT_MAP_PTR_TMP14:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[_TMP15:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_2:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_IV23:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_LB24:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[DOTOMP_UB25:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I29:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[A:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    [[I43:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[I46:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr [[INPUT]], ptr [[INPUT_ADDR]], align 8
// CHECK-NEXT:    store i32 [[SIZE]], ptr [[SIZE_ADDR]], align 4
// CHECK-NEXT:    store ptr [[OUTPUT]], ptr [[OUTPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[OUTPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[INPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[OUTPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[OUTPUT_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[TMP3]], i64 0
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[INPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[INPUT_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i32, ptr [[TMP5]], i64 0
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[SIZE_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[TMP6]] to i64
// CHECK-NEXT:    [[TMP7:%.*]] = mul nuw i64 [[CONV]], 4
// CHECK-NEXT:    "DIR.OMP.TARGET"()
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[TMP2]], ptr [[ARRAYIDX]], i64 4, i64 33315, ptr null, ptr null)
// CHECK-SAME:    "QUAL.OMP.MAP.TO"(ptr [[TMP4]], ptr [[ARRAYIDX1]], i64 [[TMP7]], i64 33, ptr null, ptr null)
// CHECK:         "DIR.OMP.TEAMS"()
// CHECK:         "DIR.OMP.DISTRIBUTE.PARLOOP"()
// CHECK:         "DIR.OMP.END.DISTRIBUTE.PARLOOP"()
// CHECK:         "DIR.OMP.END.TEAMS"()
// CHECK-NEXT:    "DIR.OMP.END.TARGET"()
// CHECK-NEXT:    [[TMP25:%.*]] = load ptr, ptr [[OUTPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP26:%.*]] = load ptr, ptr [[INPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP27:%.*]] = load ptr, ptr [[OUTPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP28:%.*]] = load ptr, ptr [[OUTPUT_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX10:%.*]] = getelementptr inbounds i32, ptr [[TMP28]], i64 0
// CHECK-NEXT:    [[TMP29:%.*]] = load ptr, ptr [[INPUT_ADDR]], align 8
// CHECK-NEXT:    [[TMP30:%.*]] = load ptr, ptr [[INPUT_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds i32, ptr [[TMP30]], i64 0
// CHECK-NEXT:    [[TMP31:%.*]] = load i32, ptr [[SIZE_ADDR]], align 4
// CHECK-NEXT:    [[CONV12:%.*]] = sext i32 [[TMP31]] to i64
// CHECK-NEXT:    [[TMP32:%.*]] = mul nuw i64 [[CONV12]], 4
// CHECK-NEXT:    "DIR.OMP.TARGET"()
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[TMP27]], ptr [[ARRAYIDX10]], i64 12, i64 33315, ptr null, ptr null),
// CHECK-SAME:    "QUAL.OMP.MAP.TO"(ptr [[TMP29]], ptr [[ARRAYIDX11]], i64 [[TMP32]], i64 33, ptr null, ptr null)
// CHECK:         "DIR.OMP.TEAMS"()
// CHECK:         "DIR.OMP.DISTRIBUTE.PARLOOP"()
// CHECK:         "DIR.OMP.END.DISTRIBUTE.PARLOOP"()
// CHECK:         "DIR.OMP.END.TARGET"()
// CHECK-NEXT:    [[ARRAYIDX42:%.*]] = getelementptr inbounds [10 x i32], ptr [[A]], i64 0, i64 0
// CHECK-NEXT:    "DIR.OMP.TARGET"()
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[A]], ptr [[ARRAYIDX42]], i64 8, i64 33315, ptr null, ptr null)
// CHECK:         "DIR.OMP.PARALLEL"()
// CHECK:         "DIR.OMP.END.PARALLEL"()
// CHECK:         "DIR.OMP.END.TARGET"()
// CHECK-NEXT:    [[ARRAYIDX45:%.*]] = getelementptr inbounds [10 x i32], ptr [[A]], i64 0, i64 3
// CHECK-NEXT:    "DIR.OMP.TARGET"()
// CHECK-SAME:    "QUAL.OMP.MAP.TOFROM"(ptr [[A]], ptr [[ARRAYIDX45]], i64 4, i64 33315, ptr null, ptr null)
// CHECK-NEXT:    "DIR.OMP.PARALLEL"()
// CHECK:         "DIR.OMP.END.PARALLEL"()
// CHECK-NEXT:    "DIR.OMP.END.TARGET"()
// CHECK-NEXT:    ret void

// end  INTEL_COLLAB
